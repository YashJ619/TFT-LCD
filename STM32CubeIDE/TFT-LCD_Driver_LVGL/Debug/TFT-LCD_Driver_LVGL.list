
TFT-LCD_Driver_LVGL.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000279d8  08000198  08000198  00001198  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000037b0  08027b70  08027b70  00028b70  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0802b320  0802b320  0002d024  2**0
                  CONTENTS
  4 .ARM          00000008  0802b320  0802b320  0002c320  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0802b328  0802b328  0002d024  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0802b328  0802b328  0002c328  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  0802b32c  0802b32c  0002c32c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000024  20000000  0802b330  0002d000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00010228  20000024  0802b354  0002d024  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2001024c  0802b354  0002d24c  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  0002d024  2**0
                  CONTENTS, READONLY
 12 .debug_info   00079142  00000000  00000000  0002d054  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000e495  00000000  00000000  000a6196  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00003f50  00000000  00000000  000b4630  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 0000326f  00000000  00000000  000b8580  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00033a29  00000000  00000000  000bb7ef  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   000b30b4  00000000  00000000  000ef218  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    000a1535  00000000  00000000  001a22cc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  00243801  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00010830  00000000  00000000  00243844  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 0000006d  00000000  00000000  00254074  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	@ (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	@ (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	@ (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000024 	.word	0x20000024
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08027b58 	.word	0x08027b58

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	@ (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	@ (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	@ (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	20000028 	.word	0x20000028
 80001d4:	08027b58 	.word	0x08027b58

080001d8 <__aeabi_ldivmod>:
 80001d8:	b97b      	cbnz	r3, 80001fa <__aeabi_ldivmod+0x22>
 80001da:	b972      	cbnz	r2, 80001fa <__aeabi_ldivmod+0x22>
 80001dc:	2900      	cmp	r1, #0
 80001de:	bfbe      	ittt	lt
 80001e0:	2000      	movlt	r0, #0
 80001e2:	f04f 4100 	movlt.w	r1, #2147483648	@ 0x80000000
 80001e6:	e006      	blt.n	80001f6 <__aeabi_ldivmod+0x1e>
 80001e8:	bf08      	it	eq
 80001ea:	2800      	cmpeq	r0, #0
 80001ec:	bf1c      	itt	ne
 80001ee:	f06f 4100 	mvnne.w	r1, #2147483648	@ 0x80000000
 80001f2:	f04f 30ff 	movne.w	r0, #4294967295
 80001f6:	f000 b9b5 	b.w	8000564 <__aeabi_idiv0>
 80001fa:	f1ad 0c08 	sub.w	ip, sp, #8
 80001fe:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000202:	2900      	cmp	r1, #0
 8000204:	db09      	blt.n	800021a <__aeabi_ldivmod+0x42>
 8000206:	2b00      	cmp	r3, #0
 8000208:	db1a      	blt.n	8000240 <__aeabi_ldivmod+0x68>
 800020a:	f000 f84d 	bl	80002a8 <__udivmoddi4>
 800020e:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000212:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000216:	b004      	add	sp, #16
 8000218:	4770      	bx	lr
 800021a:	4240      	negs	r0, r0
 800021c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000220:	2b00      	cmp	r3, #0
 8000222:	db1b      	blt.n	800025c <__aeabi_ldivmod+0x84>
 8000224:	f000 f840 	bl	80002a8 <__udivmoddi4>
 8000228:	f8dd e004 	ldr.w	lr, [sp, #4]
 800022c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000230:	b004      	add	sp, #16
 8000232:	4240      	negs	r0, r0
 8000234:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000238:	4252      	negs	r2, r2
 800023a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800023e:	4770      	bx	lr
 8000240:	4252      	negs	r2, r2
 8000242:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000246:	f000 f82f 	bl	80002a8 <__udivmoddi4>
 800024a:	f8dd e004 	ldr.w	lr, [sp, #4]
 800024e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000252:	b004      	add	sp, #16
 8000254:	4240      	negs	r0, r0
 8000256:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800025a:	4770      	bx	lr
 800025c:	4252      	negs	r2, r2
 800025e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000262:	f000 f821 	bl	80002a8 <__udivmoddi4>
 8000266:	f8dd e004 	ldr.w	lr, [sp, #4]
 800026a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800026e:	b004      	add	sp, #16
 8000270:	4252      	negs	r2, r2
 8000272:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000276:	4770      	bx	lr

08000278 <__aeabi_uldivmod>:
 8000278:	b953      	cbnz	r3, 8000290 <__aeabi_uldivmod+0x18>
 800027a:	b94a      	cbnz	r2, 8000290 <__aeabi_uldivmod+0x18>
 800027c:	2900      	cmp	r1, #0
 800027e:	bf08      	it	eq
 8000280:	2800      	cmpeq	r0, #0
 8000282:	bf1c      	itt	ne
 8000284:	f04f 31ff 	movne.w	r1, #4294967295
 8000288:	f04f 30ff 	movne.w	r0, #4294967295
 800028c:	f000 b96a 	b.w	8000564 <__aeabi_idiv0>
 8000290:	f1ad 0c08 	sub.w	ip, sp, #8
 8000294:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000298:	f000 f806 	bl	80002a8 <__udivmoddi4>
 800029c:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002a0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002a4:	b004      	add	sp, #16
 80002a6:	4770      	bx	lr

080002a8 <__udivmoddi4>:
 80002a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002ac:	9d08      	ldr	r5, [sp, #32]
 80002ae:	460c      	mov	r4, r1
 80002b0:	2b00      	cmp	r3, #0
 80002b2:	d14e      	bne.n	8000352 <__udivmoddi4+0xaa>
 80002b4:	4694      	mov	ip, r2
 80002b6:	458c      	cmp	ip, r1
 80002b8:	4686      	mov	lr, r0
 80002ba:	fab2 f282 	clz	r2, r2
 80002be:	d962      	bls.n	8000386 <__udivmoddi4+0xde>
 80002c0:	b14a      	cbz	r2, 80002d6 <__udivmoddi4+0x2e>
 80002c2:	f1c2 0320 	rsb	r3, r2, #32
 80002c6:	4091      	lsls	r1, r2
 80002c8:	fa20 f303 	lsr.w	r3, r0, r3
 80002cc:	fa0c fc02 	lsl.w	ip, ip, r2
 80002d0:	4319      	orrs	r1, r3
 80002d2:	fa00 fe02 	lsl.w	lr, r0, r2
 80002d6:	ea4f 471c 	mov.w	r7, ip, lsr #16
 80002da:	fa1f f68c 	uxth.w	r6, ip
 80002de:	fbb1 f4f7 	udiv	r4, r1, r7
 80002e2:	ea4f 431e 	mov.w	r3, lr, lsr #16
 80002e6:	fb07 1114 	mls	r1, r7, r4, r1
 80002ea:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80002ee:	fb04 f106 	mul.w	r1, r4, r6
 80002f2:	4299      	cmp	r1, r3
 80002f4:	d90a      	bls.n	800030c <__udivmoddi4+0x64>
 80002f6:	eb1c 0303 	adds.w	r3, ip, r3
 80002fa:	f104 30ff 	add.w	r0, r4, #4294967295
 80002fe:	f080 8112 	bcs.w	8000526 <__udivmoddi4+0x27e>
 8000302:	4299      	cmp	r1, r3
 8000304:	f240 810f 	bls.w	8000526 <__udivmoddi4+0x27e>
 8000308:	3c02      	subs	r4, #2
 800030a:	4463      	add	r3, ip
 800030c:	1a59      	subs	r1, r3, r1
 800030e:	fa1f f38e 	uxth.w	r3, lr
 8000312:	fbb1 f0f7 	udiv	r0, r1, r7
 8000316:	fb07 1110 	mls	r1, r7, r0, r1
 800031a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800031e:	fb00 f606 	mul.w	r6, r0, r6
 8000322:	429e      	cmp	r6, r3
 8000324:	d90a      	bls.n	800033c <__udivmoddi4+0x94>
 8000326:	eb1c 0303 	adds.w	r3, ip, r3
 800032a:	f100 31ff 	add.w	r1, r0, #4294967295
 800032e:	f080 80fc 	bcs.w	800052a <__udivmoddi4+0x282>
 8000332:	429e      	cmp	r6, r3
 8000334:	f240 80f9 	bls.w	800052a <__udivmoddi4+0x282>
 8000338:	4463      	add	r3, ip
 800033a:	3802      	subs	r0, #2
 800033c:	1b9b      	subs	r3, r3, r6
 800033e:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 8000342:	2100      	movs	r1, #0
 8000344:	b11d      	cbz	r5, 800034e <__udivmoddi4+0xa6>
 8000346:	40d3      	lsrs	r3, r2
 8000348:	2200      	movs	r2, #0
 800034a:	e9c5 3200 	strd	r3, r2, [r5]
 800034e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000352:	428b      	cmp	r3, r1
 8000354:	d905      	bls.n	8000362 <__udivmoddi4+0xba>
 8000356:	b10d      	cbz	r5, 800035c <__udivmoddi4+0xb4>
 8000358:	e9c5 0100 	strd	r0, r1, [r5]
 800035c:	2100      	movs	r1, #0
 800035e:	4608      	mov	r0, r1
 8000360:	e7f5      	b.n	800034e <__udivmoddi4+0xa6>
 8000362:	fab3 f183 	clz	r1, r3
 8000366:	2900      	cmp	r1, #0
 8000368:	d146      	bne.n	80003f8 <__udivmoddi4+0x150>
 800036a:	42a3      	cmp	r3, r4
 800036c:	d302      	bcc.n	8000374 <__udivmoddi4+0xcc>
 800036e:	4290      	cmp	r0, r2
 8000370:	f0c0 80f0 	bcc.w	8000554 <__udivmoddi4+0x2ac>
 8000374:	1a86      	subs	r6, r0, r2
 8000376:	eb64 0303 	sbc.w	r3, r4, r3
 800037a:	2001      	movs	r0, #1
 800037c:	2d00      	cmp	r5, #0
 800037e:	d0e6      	beq.n	800034e <__udivmoddi4+0xa6>
 8000380:	e9c5 6300 	strd	r6, r3, [r5]
 8000384:	e7e3      	b.n	800034e <__udivmoddi4+0xa6>
 8000386:	2a00      	cmp	r2, #0
 8000388:	f040 8090 	bne.w	80004ac <__udivmoddi4+0x204>
 800038c:	eba1 040c 	sub.w	r4, r1, ip
 8000390:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000394:	fa1f f78c 	uxth.w	r7, ip
 8000398:	2101      	movs	r1, #1
 800039a:	fbb4 f6f8 	udiv	r6, r4, r8
 800039e:	ea4f 431e 	mov.w	r3, lr, lsr #16
 80003a2:	fb08 4416 	mls	r4, r8, r6, r4
 80003a6:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 80003aa:	fb07 f006 	mul.w	r0, r7, r6
 80003ae:	4298      	cmp	r0, r3
 80003b0:	d908      	bls.n	80003c4 <__udivmoddi4+0x11c>
 80003b2:	eb1c 0303 	adds.w	r3, ip, r3
 80003b6:	f106 34ff 	add.w	r4, r6, #4294967295
 80003ba:	d202      	bcs.n	80003c2 <__udivmoddi4+0x11a>
 80003bc:	4298      	cmp	r0, r3
 80003be:	f200 80cd 	bhi.w	800055c <__udivmoddi4+0x2b4>
 80003c2:	4626      	mov	r6, r4
 80003c4:	1a1c      	subs	r4, r3, r0
 80003c6:	fa1f f38e 	uxth.w	r3, lr
 80003ca:	fbb4 f0f8 	udiv	r0, r4, r8
 80003ce:	fb08 4410 	mls	r4, r8, r0, r4
 80003d2:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 80003d6:	fb00 f707 	mul.w	r7, r0, r7
 80003da:	429f      	cmp	r7, r3
 80003dc:	d908      	bls.n	80003f0 <__udivmoddi4+0x148>
 80003de:	eb1c 0303 	adds.w	r3, ip, r3
 80003e2:	f100 34ff 	add.w	r4, r0, #4294967295
 80003e6:	d202      	bcs.n	80003ee <__udivmoddi4+0x146>
 80003e8:	429f      	cmp	r7, r3
 80003ea:	f200 80b0 	bhi.w	800054e <__udivmoddi4+0x2a6>
 80003ee:	4620      	mov	r0, r4
 80003f0:	1bdb      	subs	r3, r3, r7
 80003f2:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 80003f6:	e7a5      	b.n	8000344 <__udivmoddi4+0x9c>
 80003f8:	f1c1 0620 	rsb	r6, r1, #32
 80003fc:	408b      	lsls	r3, r1
 80003fe:	fa22 f706 	lsr.w	r7, r2, r6
 8000402:	431f      	orrs	r7, r3
 8000404:	fa20 fc06 	lsr.w	ip, r0, r6
 8000408:	fa04 f301 	lsl.w	r3, r4, r1
 800040c:	ea43 030c 	orr.w	r3, r3, ip
 8000410:	40f4      	lsrs	r4, r6
 8000412:	fa00 f801 	lsl.w	r8, r0, r1
 8000416:	0c38      	lsrs	r0, r7, #16
 8000418:	ea4f 4913 	mov.w	r9, r3, lsr #16
 800041c:	fbb4 fef0 	udiv	lr, r4, r0
 8000420:	fa1f fc87 	uxth.w	ip, r7
 8000424:	fb00 441e 	mls	r4, r0, lr, r4
 8000428:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 800042c:	fb0e f90c 	mul.w	r9, lr, ip
 8000430:	45a1      	cmp	r9, r4
 8000432:	fa02 f201 	lsl.w	r2, r2, r1
 8000436:	d90a      	bls.n	800044e <__udivmoddi4+0x1a6>
 8000438:	193c      	adds	r4, r7, r4
 800043a:	f10e 3aff 	add.w	sl, lr, #4294967295
 800043e:	f080 8084 	bcs.w	800054a <__udivmoddi4+0x2a2>
 8000442:	45a1      	cmp	r9, r4
 8000444:	f240 8081 	bls.w	800054a <__udivmoddi4+0x2a2>
 8000448:	f1ae 0e02 	sub.w	lr, lr, #2
 800044c:	443c      	add	r4, r7
 800044e:	eba4 0409 	sub.w	r4, r4, r9
 8000452:	fa1f f983 	uxth.w	r9, r3
 8000456:	fbb4 f3f0 	udiv	r3, r4, r0
 800045a:	fb00 4413 	mls	r4, r0, r3, r4
 800045e:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000462:	fb03 fc0c 	mul.w	ip, r3, ip
 8000466:	45a4      	cmp	ip, r4
 8000468:	d907      	bls.n	800047a <__udivmoddi4+0x1d2>
 800046a:	193c      	adds	r4, r7, r4
 800046c:	f103 30ff 	add.w	r0, r3, #4294967295
 8000470:	d267      	bcs.n	8000542 <__udivmoddi4+0x29a>
 8000472:	45a4      	cmp	ip, r4
 8000474:	d965      	bls.n	8000542 <__udivmoddi4+0x29a>
 8000476:	3b02      	subs	r3, #2
 8000478:	443c      	add	r4, r7
 800047a:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 800047e:	fba0 9302 	umull	r9, r3, r0, r2
 8000482:	eba4 040c 	sub.w	r4, r4, ip
 8000486:	429c      	cmp	r4, r3
 8000488:	46ce      	mov	lr, r9
 800048a:	469c      	mov	ip, r3
 800048c:	d351      	bcc.n	8000532 <__udivmoddi4+0x28a>
 800048e:	d04e      	beq.n	800052e <__udivmoddi4+0x286>
 8000490:	b155      	cbz	r5, 80004a8 <__udivmoddi4+0x200>
 8000492:	ebb8 030e 	subs.w	r3, r8, lr
 8000496:	eb64 040c 	sbc.w	r4, r4, ip
 800049a:	fa04 f606 	lsl.w	r6, r4, r6
 800049e:	40cb      	lsrs	r3, r1
 80004a0:	431e      	orrs	r6, r3
 80004a2:	40cc      	lsrs	r4, r1
 80004a4:	e9c5 6400 	strd	r6, r4, [r5]
 80004a8:	2100      	movs	r1, #0
 80004aa:	e750      	b.n	800034e <__udivmoddi4+0xa6>
 80004ac:	f1c2 0320 	rsb	r3, r2, #32
 80004b0:	fa20 f103 	lsr.w	r1, r0, r3
 80004b4:	fa0c fc02 	lsl.w	ip, ip, r2
 80004b8:	fa24 f303 	lsr.w	r3, r4, r3
 80004bc:	4094      	lsls	r4, r2
 80004be:	430c      	orrs	r4, r1
 80004c0:	ea4f 481c 	mov.w	r8, ip, lsr #16
 80004c4:	fa00 fe02 	lsl.w	lr, r0, r2
 80004c8:	fa1f f78c 	uxth.w	r7, ip
 80004cc:	fbb3 f0f8 	udiv	r0, r3, r8
 80004d0:	fb08 3110 	mls	r1, r8, r0, r3
 80004d4:	0c23      	lsrs	r3, r4, #16
 80004d6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80004da:	fb00 f107 	mul.w	r1, r0, r7
 80004de:	4299      	cmp	r1, r3
 80004e0:	d908      	bls.n	80004f4 <__udivmoddi4+0x24c>
 80004e2:	eb1c 0303 	adds.w	r3, ip, r3
 80004e6:	f100 36ff 	add.w	r6, r0, #4294967295
 80004ea:	d22c      	bcs.n	8000546 <__udivmoddi4+0x29e>
 80004ec:	4299      	cmp	r1, r3
 80004ee:	d92a      	bls.n	8000546 <__udivmoddi4+0x29e>
 80004f0:	3802      	subs	r0, #2
 80004f2:	4463      	add	r3, ip
 80004f4:	1a5b      	subs	r3, r3, r1
 80004f6:	b2a4      	uxth	r4, r4
 80004f8:	fbb3 f1f8 	udiv	r1, r3, r8
 80004fc:	fb08 3311 	mls	r3, r8, r1, r3
 8000500:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000504:	fb01 f307 	mul.w	r3, r1, r7
 8000508:	42a3      	cmp	r3, r4
 800050a:	d908      	bls.n	800051e <__udivmoddi4+0x276>
 800050c:	eb1c 0404 	adds.w	r4, ip, r4
 8000510:	f101 36ff 	add.w	r6, r1, #4294967295
 8000514:	d213      	bcs.n	800053e <__udivmoddi4+0x296>
 8000516:	42a3      	cmp	r3, r4
 8000518:	d911      	bls.n	800053e <__udivmoddi4+0x296>
 800051a:	3902      	subs	r1, #2
 800051c:	4464      	add	r4, ip
 800051e:	1ae4      	subs	r4, r4, r3
 8000520:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8000524:	e739      	b.n	800039a <__udivmoddi4+0xf2>
 8000526:	4604      	mov	r4, r0
 8000528:	e6f0      	b.n	800030c <__udivmoddi4+0x64>
 800052a:	4608      	mov	r0, r1
 800052c:	e706      	b.n	800033c <__udivmoddi4+0x94>
 800052e:	45c8      	cmp	r8, r9
 8000530:	d2ae      	bcs.n	8000490 <__udivmoddi4+0x1e8>
 8000532:	ebb9 0e02 	subs.w	lr, r9, r2
 8000536:	eb63 0c07 	sbc.w	ip, r3, r7
 800053a:	3801      	subs	r0, #1
 800053c:	e7a8      	b.n	8000490 <__udivmoddi4+0x1e8>
 800053e:	4631      	mov	r1, r6
 8000540:	e7ed      	b.n	800051e <__udivmoddi4+0x276>
 8000542:	4603      	mov	r3, r0
 8000544:	e799      	b.n	800047a <__udivmoddi4+0x1d2>
 8000546:	4630      	mov	r0, r6
 8000548:	e7d4      	b.n	80004f4 <__udivmoddi4+0x24c>
 800054a:	46d6      	mov	lr, sl
 800054c:	e77f      	b.n	800044e <__udivmoddi4+0x1a6>
 800054e:	4463      	add	r3, ip
 8000550:	3802      	subs	r0, #2
 8000552:	e74d      	b.n	80003f0 <__udivmoddi4+0x148>
 8000554:	4606      	mov	r6, r0
 8000556:	4623      	mov	r3, r4
 8000558:	4608      	mov	r0, r1
 800055a:	e70f      	b.n	800037c <__udivmoddi4+0xd4>
 800055c:	3e02      	subs	r6, #2
 800055e:	4463      	add	r3, ip
 8000560:	e730      	b.n	80003c4 <__udivmoddi4+0x11c>
 8000562:	bf00      	nop

08000564 <__aeabi_idiv0>:
 8000564:	4770      	bx	lr
 8000566:	bf00      	nop

08000568 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8000568:	b580      	push	{r7, lr}
 800056a:	b088      	sub	sp, #32
 800056c:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800056e:	f107 030c 	add.w	r3, r7, #12
 8000572:	2200      	movs	r2, #0
 8000574:	601a      	str	r2, [r3, #0]
 8000576:	605a      	str	r2, [r3, #4]
 8000578:	609a      	str	r2, [r3, #8]
 800057a:	60da      	str	r2, [r3, #12]
 800057c:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800057e:	2300      	movs	r3, #0
 8000580:	60bb      	str	r3, [r7, #8]
 8000582:	4b2a      	ldr	r3, [pc, #168]	@ (800062c <MX_GPIO_Init+0xc4>)
 8000584:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8000586:	4a29      	ldr	r2, [pc, #164]	@ (800062c <MX_GPIO_Init+0xc4>)
 8000588:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800058c:	6313      	str	r3, [r2, #48]	@ 0x30
 800058e:	4b27      	ldr	r3, [pc, #156]	@ (800062c <MX_GPIO_Init+0xc4>)
 8000590:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8000592:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8000596:	60bb      	str	r3, [r7, #8]
 8000598:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800059a:	2300      	movs	r3, #0
 800059c:	607b      	str	r3, [r7, #4]
 800059e:	4b23      	ldr	r3, [pc, #140]	@ (800062c <MX_GPIO_Init+0xc4>)
 80005a0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80005a2:	4a22      	ldr	r2, [pc, #136]	@ (800062c <MX_GPIO_Init+0xc4>)
 80005a4:	f043 0301 	orr.w	r3, r3, #1
 80005a8:	6313      	str	r3, [r2, #48]	@ 0x30
 80005aa:	4b20      	ldr	r3, [pc, #128]	@ (800062c <MX_GPIO_Init+0xc4>)
 80005ac:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80005ae:	f003 0301 	and.w	r3, r3, #1
 80005b2:	607b      	str	r3, [r7, #4]
 80005b4:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80005b6:	2300      	movs	r3, #0
 80005b8:	603b      	str	r3, [r7, #0]
 80005ba:	4b1c      	ldr	r3, [pc, #112]	@ (800062c <MX_GPIO_Init+0xc4>)
 80005bc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80005be:	4a1b      	ldr	r2, [pc, #108]	@ (800062c <MX_GPIO_Init+0xc4>)
 80005c0:	f043 0302 	orr.w	r3, r3, #2
 80005c4:	6313      	str	r3, [r2, #48]	@ 0x30
 80005c6:	4b19      	ldr	r3, [pc, #100]	@ (800062c <MX_GPIO_Init+0xc4>)
 80005c8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80005ca:	f003 0302 	and.w	r3, r3, #2
 80005ce:	603b      	str	r3, [r7, #0]
 80005d0:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
 80005d2:	2200      	movs	r2, #0
 80005d4:	2110      	movs	r1, #16
 80005d6:	4816      	ldr	r0, [pc, #88]	@ (8000630 <MX_GPIO_Init+0xc8>)
 80005d8:	f000 fcc4 	bl	8000f64 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_10, GPIO_PIN_RESET);
 80005dc:	2200      	movs	r2, #0
 80005de:	f240 4107 	movw	r1, #1031	@ 0x407
 80005e2:	4814      	ldr	r0, [pc, #80]	@ (8000634 <MX_GPIO_Init+0xcc>)
 80005e4:	f000 fcbe 	bl	8000f64 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PA4 */
  GPIO_InitStruct.Pin = GPIO_PIN_4;
 80005e8:	2310      	movs	r3, #16
 80005ea:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80005ec:	2301      	movs	r3, #1
 80005ee:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80005f0:	2300      	movs	r3, #0
 80005f2:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80005f4:	2300      	movs	r3, #0
 80005f6:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80005f8:	f107 030c 	add.w	r3, r7, #12
 80005fc:	4619      	mov	r1, r3
 80005fe:	480c      	ldr	r0, [pc, #48]	@ (8000630 <MX_GPIO_Init+0xc8>)
 8000600:	f000 fb2c 	bl	8000c5c <HAL_GPIO_Init>

  /*Configure GPIO pins : PB0 PB1 PB2 PB10 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_10;
 8000604:	f240 4307 	movw	r3, #1031	@ 0x407
 8000608:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800060a:	2301      	movs	r3, #1
 800060c:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800060e:	2300      	movs	r3, #0
 8000610:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000612:	2300      	movs	r3, #0
 8000614:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000616:	f107 030c 	add.w	r3, r7, #12
 800061a:	4619      	mov	r1, r3
 800061c:	4805      	ldr	r0, [pc, #20]	@ (8000634 <MX_GPIO_Init+0xcc>)
 800061e:	f000 fb1d 	bl	8000c5c <HAL_GPIO_Init>

}
 8000622:	bf00      	nop
 8000624:	3720      	adds	r7, #32
 8000626:	46bd      	mov	sp, r7
 8000628:	bd80      	pop	{r7, pc}
 800062a:	bf00      	nop
 800062c:	40023800 	.word	0x40023800
 8000630:	40020000 	.word	0x40020000
 8000634:	40020400 	.word	0x40020400

08000638 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8000638:	b580      	push	{r7, lr}
 800063a:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800063c:	f000 f992 	bl	8000964 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8000640:	f000 f810 	bl	8000664 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8000644:	f7ff ff90 	bl	8000568 <MX_GPIO_Init>
  MX_SPI1_Init();
 8000648:	f000 f87a 	bl	8000740 <MX_SPI1_Init>
  /* USER CODE BEGIN 2 */
lcd_config();
 800064c:	f001 fbf4 	bl	8001e38 <lcd_config>
lcd_setbackgroundcolor(ILI9486_PURPLE);
 8000650:	f647 000f 	movw	r0, #30735	@ 0x780f
 8000654:	f001 fd36 	bl	80020c4 <lcd_setbackgroundcolor>
lv_init();
 8000658:	f020 fb3c 	bl	8020cd4 <lv_init>

lv_example_get_started_1();
 800065c:	f001 fd8e 	bl	800217c <lv_example_get_started_1>
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 8000660:	bf00      	nop
 8000662:	e7fd      	b.n	8000660 <main+0x28>

08000664 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8000664:	b580      	push	{r7, lr}
 8000666:	b094      	sub	sp, #80	@ 0x50
 8000668:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800066a:	f107 0320 	add.w	r3, r7, #32
 800066e:	2230      	movs	r2, #48	@ 0x30
 8000670:	2100      	movs	r1, #0
 8000672:	4618      	mov	r0, r3
 8000674:	f027 fa36 	bl	8027ae4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000678:	f107 030c 	add.w	r3, r7, #12
 800067c:	2200      	movs	r2, #0
 800067e:	601a      	str	r2, [r3, #0]
 8000680:	605a      	str	r2, [r3, #4]
 8000682:	609a      	str	r2, [r3, #8]
 8000684:	60da      	str	r2, [r3, #12]
 8000686:	611a      	str	r2, [r3, #16]

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 8000688:	2300      	movs	r3, #0
 800068a:	60bb      	str	r3, [r7, #8]
 800068c:	4b27      	ldr	r3, [pc, #156]	@ (800072c <SystemClock_Config+0xc8>)
 800068e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8000690:	4a26      	ldr	r2, [pc, #152]	@ (800072c <SystemClock_Config+0xc8>)
 8000692:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8000696:	6413      	str	r3, [r2, #64]	@ 0x40
 8000698:	4b24      	ldr	r3, [pc, #144]	@ (800072c <SystemClock_Config+0xc8>)
 800069a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800069c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 80006a0:	60bb      	str	r3, [r7, #8]
 80006a2:	68bb      	ldr	r3, [r7, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80006a4:	2300      	movs	r3, #0
 80006a6:	607b      	str	r3, [r7, #4]
 80006a8:	4b21      	ldr	r3, [pc, #132]	@ (8000730 <SystemClock_Config+0xcc>)
 80006aa:	681b      	ldr	r3, [r3, #0]
 80006ac:	4a20      	ldr	r2, [pc, #128]	@ (8000730 <SystemClock_Config+0xcc>)
 80006ae:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 80006b2:	6013      	str	r3, [r2, #0]
 80006b4:	4b1e      	ldr	r3, [pc, #120]	@ (8000730 <SystemClock_Config+0xcc>)
 80006b6:	681b      	ldr	r3, [r3, #0]
 80006b8:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 80006bc:	607b      	str	r3, [r7, #4]
 80006be:	687b      	ldr	r3, [r7, #4]

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80006c0:	2301      	movs	r3, #1
 80006c2:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80006c4:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 80006c8:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80006ca:	2302      	movs	r3, #2
 80006cc:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80006ce:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 80006d2:	63fb      	str	r3, [r7, #60]	@ 0x3c
  RCC_OscInitStruct.PLL.PLLM = 25;
 80006d4:	2319      	movs	r3, #25
 80006d6:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.PLL.PLLN = 192;
 80006d8:	23c0      	movs	r3, #192	@ 0xc0
 80006da:	647b      	str	r3, [r7, #68]	@ 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80006dc:	2302      	movs	r3, #2
 80006de:	64bb      	str	r3, [r7, #72]	@ 0x48
  RCC_OscInitStruct.PLL.PLLQ = 4;
 80006e0:	2304      	movs	r3, #4
 80006e2:	64fb      	str	r3, [r7, #76]	@ 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80006e4:	f107 0320 	add.w	r3, r7, #32
 80006e8:	4618      	mov	r0, r3
 80006ea:	f000 fc55 	bl	8000f98 <HAL_RCC_OscConfig>
 80006ee:	4603      	mov	r3, r0
 80006f0:	2b00      	cmp	r3, #0
 80006f2:	d001      	beq.n	80006f8 <SystemClock_Config+0x94>
  {
    Error_Handler();
 80006f4:	f000 f81e 	bl	8000734 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80006f8:	230f      	movs	r3, #15
 80006fa:	60fb      	str	r3, [r7, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80006fc:	2302      	movs	r3, #2
 80006fe:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000700:	2300      	movs	r3, #0
 8000702:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8000704:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8000708:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800070a:	2300      	movs	r3, #0
 800070c:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
 800070e:	f107 030c 	add.w	r3, r7, #12
 8000712:	2103      	movs	r1, #3
 8000714:	4618      	mov	r0, r3
 8000716:	f000 feb7 	bl	8001488 <HAL_RCC_ClockConfig>
 800071a:	4603      	mov	r3, r0
 800071c:	2b00      	cmp	r3, #0
 800071e:	d001      	beq.n	8000724 <SystemClock_Config+0xc0>
  {
    Error_Handler();
 8000720:	f000 f808 	bl	8000734 <Error_Handler>
  }
}
 8000724:	bf00      	nop
 8000726:	3750      	adds	r7, #80	@ 0x50
 8000728:	46bd      	mov	sp, r7
 800072a:	bd80      	pop	{r7, pc}
 800072c:	40023800 	.word	0x40023800
 8000730:	40007000 	.word	0x40007000

08000734 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8000734:	b480      	push	{r7}
 8000736:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000738:	b672      	cpsid	i
}
 800073a:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 800073c:	bf00      	nop
 800073e:	e7fd      	b.n	800073c <Error_Handler+0x8>

08000740 <MX_SPI1_Init>:

SPI_HandleTypeDef hspi1;

/* SPI1 init function */
void MX_SPI1_Init(void)
{
 8000740:	b580      	push	{r7, lr}
 8000742:	af00      	add	r7, sp, #0
  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  hspi1.Instance = SPI1;
 8000744:	4b17      	ldr	r3, [pc, #92]	@ (80007a4 <MX_SPI1_Init+0x64>)
 8000746:	4a18      	ldr	r2, [pc, #96]	@ (80007a8 <MX_SPI1_Init+0x68>)
 8000748:	601a      	str	r2, [r3, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 800074a:	4b16      	ldr	r3, [pc, #88]	@ (80007a4 <MX_SPI1_Init+0x64>)
 800074c:	f44f 7282 	mov.w	r2, #260	@ 0x104
 8000750:	605a      	str	r2, [r3, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8000752:	4b14      	ldr	r3, [pc, #80]	@ (80007a4 <MX_SPI1_Init+0x64>)
 8000754:	2200      	movs	r2, #0
 8000756:	609a      	str	r2, [r3, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
 8000758:	4b12      	ldr	r3, [pc, #72]	@ (80007a4 <MX_SPI1_Init+0x64>)
 800075a:	2200      	movs	r2, #0
 800075c:	60da      	str	r2, [r3, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 800075e:	4b11      	ldr	r3, [pc, #68]	@ (80007a4 <MX_SPI1_Init+0x64>)
 8000760:	2200      	movs	r2, #0
 8000762:	611a      	str	r2, [r3, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000764:	4b0f      	ldr	r3, [pc, #60]	@ (80007a4 <MX_SPI1_Init+0x64>)
 8000766:	2200      	movs	r2, #0
 8000768:	615a      	str	r2, [r3, #20]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 800076a:	4b0e      	ldr	r3, [pc, #56]	@ (80007a4 <MX_SPI1_Init+0x64>)
 800076c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8000770:	619a      	str	r2, [r3, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_32;
 8000772:	4b0c      	ldr	r3, [pc, #48]	@ (80007a4 <MX_SPI1_Init+0x64>)
 8000774:	2220      	movs	r2, #32
 8000776:	61da      	str	r2, [r3, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000778:	4b0a      	ldr	r3, [pc, #40]	@ (80007a4 <MX_SPI1_Init+0x64>)
 800077a:	2200      	movs	r2, #0
 800077c:	621a      	str	r2, [r3, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 800077e:	4b09      	ldr	r3, [pc, #36]	@ (80007a4 <MX_SPI1_Init+0x64>)
 8000780:	2200      	movs	r2, #0
 8000782:	625a      	str	r2, [r3, #36]	@ 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000784:	4b07      	ldr	r3, [pc, #28]	@ (80007a4 <MX_SPI1_Init+0x64>)
 8000786:	2200      	movs	r2, #0
 8000788:	629a      	str	r2, [r3, #40]	@ 0x28
  hspi1.Init.CRCPolynomial = 10;
 800078a:	4b06      	ldr	r3, [pc, #24]	@ (80007a4 <MX_SPI1_Init+0x64>)
 800078c:	220a      	movs	r2, #10
 800078e:	62da      	str	r2, [r3, #44]	@ 0x2c
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8000790:	4804      	ldr	r0, [pc, #16]	@ (80007a4 <MX_SPI1_Init+0x64>)
 8000792:	f001 f825 	bl	80017e0 <HAL_SPI_Init>
 8000796:	4603      	mov	r3, r0
 8000798:	2b00      	cmp	r3, #0
 800079a:	d001      	beq.n	80007a0 <MX_SPI1_Init+0x60>
  {
    Error_Handler();
 800079c:	f7ff ffca 	bl	8000734 <Error_Handler>
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}
 80007a0:	bf00      	nop
 80007a2:	bd80      	pop	{r7, pc}
 80007a4:	20000040 	.word	0x20000040
 80007a8:	40013000 	.word	0x40013000

080007ac <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 80007ac:	b580      	push	{r7, lr}
 80007ae:	b08a      	sub	sp, #40	@ 0x28
 80007b0:	af00      	add	r7, sp, #0
 80007b2:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80007b4:	f107 0314 	add.w	r3, r7, #20
 80007b8:	2200      	movs	r2, #0
 80007ba:	601a      	str	r2, [r3, #0]
 80007bc:	605a      	str	r2, [r3, #4]
 80007be:	609a      	str	r2, [r3, #8]
 80007c0:	60da      	str	r2, [r3, #12]
 80007c2:	611a      	str	r2, [r3, #16]
  if(spiHandle->Instance==SPI1)
 80007c4:	687b      	ldr	r3, [r7, #4]
 80007c6:	681b      	ldr	r3, [r3, #0]
 80007c8:	4a19      	ldr	r2, [pc, #100]	@ (8000830 <HAL_SPI_MspInit+0x84>)
 80007ca:	4293      	cmp	r3, r2
 80007cc:	d12b      	bne.n	8000826 <HAL_SPI_MspInit+0x7a>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* SPI1 clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 80007ce:	2300      	movs	r3, #0
 80007d0:	613b      	str	r3, [r7, #16]
 80007d2:	4b18      	ldr	r3, [pc, #96]	@ (8000834 <HAL_SPI_MspInit+0x88>)
 80007d4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80007d6:	4a17      	ldr	r2, [pc, #92]	@ (8000834 <HAL_SPI_MspInit+0x88>)
 80007d8:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 80007dc:	6453      	str	r3, [r2, #68]	@ 0x44
 80007de:	4b15      	ldr	r3, [pc, #84]	@ (8000834 <HAL_SPI_MspInit+0x88>)
 80007e0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80007e2:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 80007e6:	613b      	str	r3, [r7, #16]
 80007e8:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80007ea:	2300      	movs	r3, #0
 80007ec:	60fb      	str	r3, [r7, #12]
 80007ee:	4b11      	ldr	r3, [pc, #68]	@ (8000834 <HAL_SPI_MspInit+0x88>)
 80007f0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80007f2:	4a10      	ldr	r2, [pc, #64]	@ (8000834 <HAL_SPI_MspInit+0x88>)
 80007f4:	f043 0301 	orr.w	r3, r3, #1
 80007f8:	6313      	str	r3, [r2, #48]	@ 0x30
 80007fa:	4b0e      	ldr	r3, [pc, #56]	@ (8000834 <HAL_SPI_MspInit+0x88>)
 80007fc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80007fe:	f003 0301 	and.w	r3, r3, #1
 8000802:	60fb      	str	r3, [r7, #12]
 8000804:	68fb      	ldr	r3, [r7, #12]
    /**SPI1 GPIO Configuration
    PA5     ------> SPI1_SCK
    PA6     ------> SPI1_MISO
    PA7     ------> SPI1_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
 8000806:	23e0      	movs	r3, #224	@ 0xe0
 8000808:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800080a:	2302      	movs	r3, #2
 800080c:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800080e:	2300      	movs	r3, #0
 8000810:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000812:	2303      	movs	r3, #3
 8000814:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 8000816:	2305      	movs	r3, #5
 8000818:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800081a:	f107 0314 	add.w	r3, r7, #20
 800081e:	4619      	mov	r1, r3
 8000820:	4805      	ldr	r0, [pc, #20]	@ (8000838 <HAL_SPI_MspInit+0x8c>)
 8000822:	f000 fa1b 	bl	8000c5c <HAL_GPIO_Init>

  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }
}
 8000826:	bf00      	nop
 8000828:	3728      	adds	r7, #40	@ 0x28
 800082a:	46bd      	mov	sp, r7
 800082c:	bd80      	pop	{r7, pc}
 800082e:	bf00      	nop
 8000830:	40013000 	.word	0x40013000
 8000834:	40023800 	.word	0x40023800
 8000838:	40020000 	.word	0x40020000

0800083c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800083c:	b480      	push	{r7}
 800083e:	b083      	sub	sp, #12
 8000840:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000842:	2300      	movs	r3, #0
 8000844:	607b      	str	r3, [r7, #4]
 8000846:	4b10      	ldr	r3, [pc, #64]	@ (8000888 <HAL_MspInit+0x4c>)
 8000848:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800084a:	4a0f      	ldr	r2, [pc, #60]	@ (8000888 <HAL_MspInit+0x4c>)
 800084c:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8000850:	6453      	str	r3, [r2, #68]	@ 0x44
 8000852:	4b0d      	ldr	r3, [pc, #52]	@ (8000888 <HAL_MspInit+0x4c>)
 8000854:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8000856:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800085a:	607b      	str	r3, [r7, #4]
 800085c:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 800085e:	2300      	movs	r3, #0
 8000860:	603b      	str	r3, [r7, #0]
 8000862:	4b09      	ldr	r3, [pc, #36]	@ (8000888 <HAL_MspInit+0x4c>)
 8000864:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8000866:	4a08      	ldr	r2, [pc, #32]	@ (8000888 <HAL_MspInit+0x4c>)
 8000868:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800086c:	6413      	str	r3, [r2, #64]	@ 0x40
 800086e:	4b06      	ldr	r3, [pc, #24]	@ (8000888 <HAL_MspInit+0x4c>)
 8000870:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8000872:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8000876:	603b      	str	r3, [r7, #0]
 8000878:	683b      	ldr	r3, [r7, #0]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800087a:	bf00      	nop
 800087c:	370c      	adds	r7, #12
 800087e:	46bd      	mov	sp, r7
 8000880:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000884:	4770      	bx	lr
 8000886:	bf00      	nop
 8000888:	40023800 	.word	0x40023800

0800088c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800088c:	b480      	push	{r7}
 800088e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8000890:	bf00      	nop
 8000892:	e7fd      	b.n	8000890 <NMI_Handler+0x4>

08000894 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8000894:	b480      	push	{r7}
 8000896:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8000898:	bf00      	nop
 800089a:	e7fd      	b.n	8000898 <HardFault_Handler+0x4>

0800089c <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 800089c:	b480      	push	{r7}
 800089e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 80008a0:	bf00      	nop
 80008a2:	e7fd      	b.n	80008a0 <MemManage_Handler+0x4>

080008a4 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 80008a4:	b480      	push	{r7}
 80008a6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 80008a8:	bf00      	nop
 80008aa:	e7fd      	b.n	80008a8 <BusFault_Handler+0x4>

080008ac <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 80008ac:	b480      	push	{r7}
 80008ae:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 80008b0:	bf00      	nop
 80008b2:	e7fd      	b.n	80008b0 <UsageFault_Handler+0x4>

080008b4 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 80008b4:	b480      	push	{r7}
 80008b6:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 80008b8:	bf00      	nop
 80008ba:	46bd      	mov	sp, r7
 80008bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008c0:	4770      	bx	lr

080008c2 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 80008c2:	b480      	push	{r7}
 80008c4:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 80008c6:	bf00      	nop
 80008c8:	46bd      	mov	sp, r7
 80008ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008ce:	4770      	bx	lr

080008d0 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 80008d0:	b480      	push	{r7}
 80008d2:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 80008d4:	bf00      	nop
 80008d6:	46bd      	mov	sp, r7
 80008d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008dc:	4770      	bx	lr

080008de <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 80008de:	b580      	push	{r7, lr}
 80008e0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80008e2:	f000 f891 	bl	8000a08 <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80008e6:	bf00      	nop
 80008e8:	bd80      	pop	{r7, pc}
	...

080008ec <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80008ec:	b480      	push	{r7}
 80008ee:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80008f0:	4b06      	ldr	r3, [pc, #24]	@ (800090c <SystemInit+0x20>)
 80008f2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80008f6:	4a05      	ldr	r2, [pc, #20]	@ (800090c <SystemInit+0x20>)
 80008f8:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 80008fc:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8000900:	bf00      	nop
 8000902:	46bd      	mov	sp, r7
 8000904:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000908:	4770      	bx	lr
 800090a:	bf00      	nop
 800090c:	e000ed00 	.word	0xe000ed00

08000910 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 8000910:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8000948 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 8000914:	f7ff ffea 	bl	80008ec <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8000918:	480c      	ldr	r0, [pc, #48]	@ (800094c <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 800091a:	490d      	ldr	r1, [pc, #52]	@ (8000950 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 800091c:	4a0d      	ldr	r2, [pc, #52]	@ (8000954 <LoopFillZerobss+0x1a>)
  movs r3, #0
 800091e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8000920:	e002      	b.n	8000928 <LoopCopyDataInit>

08000922 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8000922:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8000924:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8000926:	3304      	adds	r3, #4

08000928 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8000928:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800092a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 800092c:	d3f9      	bcc.n	8000922 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 800092e:	4a0a      	ldr	r2, [pc, #40]	@ (8000958 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8000930:	4c0a      	ldr	r4, [pc, #40]	@ (800095c <LoopFillZerobss+0x22>)
  movs r3, #0
 8000932:	2300      	movs	r3, #0
  b LoopFillZerobss
 8000934:	e001      	b.n	800093a <LoopFillZerobss>

08000936 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8000936:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8000938:	3204      	adds	r2, #4

0800093a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800093a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800093c:	d3fb      	bcc.n	8000936 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 800093e:	f027 f8d9 	bl	8027af4 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8000942:	f7ff fe79 	bl	8000638 <main>
  bx  lr    
 8000946:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 8000948:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 800094c:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000950:	20000024 	.word	0x20000024
  ldr r2, =_sidata
 8000954:	0802b330 	.word	0x0802b330
  ldr r2, =_sbss
 8000958:	20000024 	.word	0x20000024
  ldr r4, =_ebss
 800095c:	2001024c 	.word	0x2001024c

08000960 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000960:	e7fe      	b.n	8000960 <ADC_IRQHandler>
	...

08000964 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8000964:	b580      	push	{r7, lr}
 8000966:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8000968:	4b0e      	ldr	r3, [pc, #56]	@ (80009a4 <HAL_Init+0x40>)
 800096a:	681b      	ldr	r3, [r3, #0]
 800096c:	4a0d      	ldr	r2, [pc, #52]	@ (80009a4 <HAL_Init+0x40>)
 800096e:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8000972:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8000974:	4b0b      	ldr	r3, [pc, #44]	@ (80009a4 <HAL_Init+0x40>)
 8000976:	681b      	ldr	r3, [r3, #0]
 8000978:	4a0a      	ldr	r2, [pc, #40]	@ (80009a4 <HAL_Init+0x40>)
 800097a:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 800097e:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000980:	4b08      	ldr	r3, [pc, #32]	@ (80009a4 <HAL_Init+0x40>)
 8000982:	681b      	ldr	r3, [r3, #0]
 8000984:	4a07      	ldr	r2, [pc, #28]	@ (80009a4 <HAL_Init+0x40>)
 8000986:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800098a:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800098c:	2003      	movs	r0, #3
 800098e:	f000 f931 	bl	8000bf4 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8000992:	200f      	movs	r0, #15
 8000994:	f000 f808 	bl	80009a8 <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8000998:	f7ff ff50 	bl	800083c <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 800099c:	2300      	movs	r3, #0
}
 800099e:	4618      	mov	r0, r3
 80009a0:	bd80      	pop	{r7, pc}
 80009a2:	bf00      	nop
 80009a4:	40023c00 	.word	0x40023c00

080009a8 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80009a8:	b580      	push	{r7, lr}
 80009aa:	b082      	sub	sp, #8
 80009ac:	af00      	add	r7, sp, #0
 80009ae:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 80009b0:	4b12      	ldr	r3, [pc, #72]	@ (80009fc <HAL_InitTick+0x54>)
 80009b2:	681a      	ldr	r2, [r3, #0]
 80009b4:	4b12      	ldr	r3, [pc, #72]	@ (8000a00 <HAL_InitTick+0x58>)
 80009b6:	781b      	ldrb	r3, [r3, #0]
 80009b8:	4619      	mov	r1, r3
 80009ba:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 80009be:	fbb3 f3f1 	udiv	r3, r3, r1
 80009c2:	fbb2 f3f3 	udiv	r3, r2, r3
 80009c6:	4618      	mov	r0, r3
 80009c8:	f000 f93b 	bl	8000c42 <HAL_SYSTICK_Config>
 80009cc:	4603      	mov	r3, r0
 80009ce:	2b00      	cmp	r3, #0
 80009d0:	d001      	beq.n	80009d6 <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 80009d2:	2301      	movs	r3, #1
 80009d4:	e00e      	b.n	80009f4 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80009d6:	687b      	ldr	r3, [r7, #4]
 80009d8:	2b0f      	cmp	r3, #15
 80009da:	d80a      	bhi.n	80009f2 <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 80009dc:	2200      	movs	r2, #0
 80009de:	6879      	ldr	r1, [r7, #4]
 80009e0:	f04f 30ff 	mov.w	r0, #4294967295
 80009e4:	f000 f911 	bl	8000c0a <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 80009e8:	4a06      	ldr	r2, [pc, #24]	@ (8000a04 <HAL_InitTick+0x5c>)
 80009ea:	687b      	ldr	r3, [r7, #4]
 80009ec:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 80009ee:	2300      	movs	r3, #0
 80009f0:	e000      	b.n	80009f4 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 80009f2:	2301      	movs	r3, #1
}
 80009f4:	4618      	mov	r0, r3
 80009f6:	3708      	adds	r7, #8
 80009f8:	46bd      	mov	sp, r7
 80009fa:	bd80      	pop	{r7, pc}
 80009fc:	20000000 	.word	0x20000000
 8000a00:	20000008 	.word	0x20000008
 8000a04:	20000004 	.word	0x20000004

08000a08 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8000a08:	b480      	push	{r7}
 8000a0a:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8000a0c:	4b06      	ldr	r3, [pc, #24]	@ (8000a28 <HAL_IncTick+0x20>)
 8000a0e:	781b      	ldrb	r3, [r3, #0]
 8000a10:	461a      	mov	r2, r3
 8000a12:	4b06      	ldr	r3, [pc, #24]	@ (8000a2c <HAL_IncTick+0x24>)
 8000a14:	681b      	ldr	r3, [r3, #0]
 8000a16:	4413      	add	r3, r2
 8000a18:	4a04      	ldr	r2, [pc, #16]	@ (8000a2c <HAL_IncTick+0x24>)
 8000a1a:	6013      	str	r3, [r2, #0]
}
 8000a1c:	bf00      	nop
 8000a1e:	46bd      	mov	sp, r7
 8000a20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a24:	4770      	bx	lr
 8000a26:	bf00      	nop
 8000a28:	20000008 	.word	0x20000008
 8000a2c:	20000098 	.word	0x20000098

08000a30 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8000a30:	b480      	push	{r7}
 8000a32:	af00      	add	r7, sp, #0
  return uwTick;
 8000a34:	4b03      	ldr	r3, [pc, #12]	@ (8000a44 <HAL_GetTick+0x14>)
 8000a36:	681b      	ldr	r3, [r3, #0]
}
 8000a38:	4618      	mov	r0, r3
 8000a3a:	46bd      	mov	sp, r7
 8000a3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a40:	4770      	bx	lr
 8000a42:	bf00      	nop
 8000a44:	20000098 	.word	0x20000098

08000a48 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000a48:	b580      	push	{r7, lr}
 8000a4a:	b084      	sub	sp, #16
 8000a4c:	af00      	add	r7, sp, #0
 8000a4e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8000a50:	f7ff ffee 	bl	8000a30 <HAL_GetTick>
 8000a54:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8000a56:	687b      	ldr	r3, [r7, #4]
 8000a58:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000a5a:	68fb      	ldr	r3, [r7, #12]
 8000a5c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000a60:	d005      	beq.n	8000a6e <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8000a62:	4b0a      	ldr	r3, [pc, #40]	@ (8000a8c <HAL_Delay+0x44>)
 8000a64:	781b      	ldrb	r3, [r3, #0]
 8000a66:	461a      	mov	r2, r3
 8000a68:	68fb      	ldr	r3, [r7, #12]
 8000a6a:	4413      	add	r3, r2
 8000a6c:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 8000a6e:	bf00      	nop
 8000a70:	f7ff ffde 	bl	8000a30 <HAL_GetTick>
 8000a74:	4602      	mov	r2, r0
 8000a76:	68bb      	ldr	r3, [r7, #8]
 8000a78:	1ad3      	subs	r3, r2, r3
 8000a7a:	68fa      	ldr	r2, [r7, #12]
 8000a7c:	429a      	cmp	r2, r3
 8000a7e:	d8f7      	bhi.n	8000a70 <HAL_Delay+0x28>
  {
  }
}
 8000a80:	bf00      	nop
 8000a82:	bf00      	nop
 8000a84:	3710      	adds	r7, #16
 8000a86:	46bd      	mov	sp, r7
 8000a88:	bd80      	pop	{r7, pc}
 8000a8a:	bf00      	nop
 8000a8c:	20000008 	.word	0x20000008

08000a90 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000a90:	b480      	push	{r7}
 8000a92:	b085      	sub	sp, #20
 8000a94:	af00      	add	r7, sp, #0
 8000a96:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8000a98:	687b      	ldr	r3, [r7, #4]
 8000a9a:	f003 0307 	and.w	r3, r3, #7
 8000a9e:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000aa0:	4b0c      	ldr	r3, [pc, #48]	@ (8000ad4 <__NVIC_SetPriorityGrouping+0x44>)
 8000aa2:	68db      	ldr	r3, [r3, #12]
 8000aa4:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000aa6:	68ba      	ldr	r2, [r7, #8]
 8000aa8:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8000aac:	4013      	ands	r3, r2
 8000aae:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000ab0:	68fb      	ldr	r3, [r7, #12]
 8000ab2:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000ab4:	68bb      	ldr	r3, [r7, #8]
 8000ab6:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8000ab8:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8000abc:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8000ac0:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8000ac2:	4a04      	ldr	r2, [pc, #16]	@ (8000ad4 <__NVIC_SetPriorityGrouping+0x44>)
 8000ac4:	68bb      	ldr	r3, [r7, #8]
 8000ac6:	60d3      	str	r3, [r2, #12]
}
 8000ac8:	bf00      	nop
 8000aca:	3714      	adds	r7, #20
 8000acc:	46bd      	mov	sp, r7
 8000ace:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000ad2:	4770      	bx	lr
 8000ad4:	e000ed00 	.word	0xe000ed00

08000ad8 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8000ad8:	b480      	push	{r7}
 8000ada:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000adc:	4b04      	ldr	r3, [pc, #16]	@ (8000af0 <__NVIC_GetPriorityGrouping+0x18>)
 8000ade:	68db      	ldr	r3, [r3, #12]
 8000ae0:	0a1b      	lsrs	r3, r3, #8
 8000ae2:	f003 0307 	and.w	r3, r3, #7
}
 8000ae6:	4618      	mov	r0, r3
 8000ae8:	46bd      	mov	sp, r7
 8000aea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000aee:	4770      	bx	lr
 8000af0:	e000ed00 	.word	0xe000ed00

08000af4 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8000af4:	b480      	push	{r7}
 8000af6:	b083      	sub	sp, #12
 8000af8:	af00      	add	r7, sp, #0
 8000afa:	4603      	mov	r3, r0
 8000afc:	6039      	str	r1, [r7, #0]
 8000afe:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8000b00:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000b04:	2b00      	cmp	r3, #0
 8000b06:	db0a      	blt.n	8000b1e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000b08:	683b      	ldr	r3, [r7, #0]
 8000b0a:	b2da      	uxtb	r2, r3
 8000b0c:	490c      	ldr	r1, [pc, #48]	@ (8000b40 <__NVIC_SetPriority+0x4c>)
 8000b0e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000b12:	0112      	lsls	r2, r2, #4
 8000b14:	b2d2      	uxtb	r2, r2
 8000b16:	440b      	add	r3, r1
 8000b18:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8000b1c:	e00a      	b.n	8000b34 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000b1e:	683b      	ldr	r3, [r7, #0]
 8000b20:	b2da      	uxtb	r2, r3
 8000b22:	4908      	ldr	r1, [pc, #32]	@ (8000b44 <__NVIC_SetPriority+0x50>)
 8000b24:	79fb      	ldrb	r3, [r7, #7]
 8000b26:	f003 030f 	and.w	r3, r3, #15
 8000b2a:	3b04      	subs	r3, #4
 8000b2c:	0112      	lsls	r2, r2, #4
 8000b2e:	b2d2      	uxtb	r2, r2
 8000b30:	440b      	add	r3, r1
 8000b32:	761a      	strb	r2, [r3, #24]
}
 8000b34:	bf00      	nop
 8000b36:	370c      	adds	r7, #12
 8000b38:	46bd      	mov	sp, r7
 8000b3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b3e:	4770      	bx	lr
 8000b40:	e000e100 	.word	0xe000e100
 8000b44:	e000ed00 	.word	0xe000ed00

08000b48 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000b48:	b480      	push	{r7}
 8000b4a:	b089      	sub	sp, #36	@ 0x24
 8000b4c:	af00      	add	r7, sp, #0
 8000b4e:	60f8      	str	r0, [r7, #12]
 8000b50:	60b9      	str	r1, [r7, #8]
 8000b52:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000b54:	68fb      	ldr	r3, [r7, #12]
 8000b56:	f003 0307 	and.w	r3, r3, #7
 8000b5a:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000b5c:	69fb      	ldr	r3, [r7, #28]
 8000b5e:	f1c3 0307 	rsb	r3, r3, #7
 8000b62:	2b04      	cmp	r3, #4
 8000b64:	bf28      	it	cs
 8000b66:	2304      	movcs	r3, #4
 8000b68:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000b6a:	69fb      	ldr	r3, [r7, #28]
 8000b6c:	3304      	adds	r3, #4
 8000b6e:	2b06      	cmp	r3, #6
 8000b70:	d902      	bls.n	8000b78 <NVIC_EncodePriority+0x30>
 8000b72:	69fb      	ldr	r3, [r7, #28]
 8000b74:	3b03      	subs	r3, #3
 8000b76:	e000      	b.n	8000b7a <NVIC_EncodePriority+0x32>
 8000b78:	2300      	movs	r3, #0
 8000b7a:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000b7c:	f04f 32ff 	mov.w	r2, #4294967295
 8000b80:	69bb      	ldr	r3, [r7, #24]
 8000b82:	fa02 f303 	lsl.w	r3, r2, r3
 8000b86:	43da      	mvns	r2, r3
 8000b88:	68bb      	ldr	r3, [r7, #8]
 8000b8a:	401a      	ands	r2, r3
 8000b8c:	697b      	ldr	r3, [r7, #20]
 8000b8e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000b90:	f04f 31ff 	mov.w	r1, #4294967295
 8000b94:	697b      	ldr	r3, [r7, #20]
 8000b96:	fa01 f303 	lsl.w	r3, r1, r3
 8000b9a:	43d9      	mvns	r1, r3
 8000b9c:	687b      	ldr	r3, [r7, #4]
 8000b9e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000ba0:	4313      	orrs	r3, r2
         );
}
 8000ba2:	4618      	mov	r0, r3
 8000ba4:	3724      	adds	r7, #36	@ 0x24
 8000ba6:	46bd      	mov	sp, r7
 8000ba8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000bac:	4770      	bx	lr
	...

08000bb0 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8000bb0:	b580      	push	{r7, lr}
 8000bb2:	b082      	sub	sp, #8
 8000bb4:	af00      	add	r7, sp, #0
 8000bb6:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000bb8:	687b      	ldr	r3, [r7, #4]
 8000bba:	3b01      	subs	r3, #1
 8000bbc:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8000bc0:	d301      	bcc.n	8000bc6 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8000bc2:	2301      	movs	r3, #1
 8000bc4:	e00f      	b.n	8000be6 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000bc6:	4a0a      	ldr	r2, [pc, #40]	@ (8000bf0 <SysTick_Config+0x40>)
 8000bc8:	687b      	ldr	r3, [r7, #4]
 8000bca:	3b01      	subs	r3, #1
 8000bcc:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8000bce:	210f      	movs	r1, #15
 8000bd0:	f04f 30ff 	mov.w	r0, #4294967295
 8000bd4:	f7ff ff8e 	bl	8000af4 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000bd8:	4b05      	ldr	r3, [pc, #20]	@ (8000bf0 <SysTick_Config+0x40>)
 8000bda:	2200      	movs	r2, #0
 8000bdc:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000bde:	4b04      	ldr	r3, [pc, #16]	@ (8000bf0 <SysTick_Config+0x40>)
 8000be0:	2207      	movs	r2, #7
 8000be2:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8000be4:	2300      	movs	r3, #0
}
 8000be6:	4618      	mov	r0, r3
 8000be8:	3708      	adds	r7, #8
 8000bea:	46bd      	mov	sp, r7
 8000bec:	bd80      	pop	{r7, pc}
 8000bee:	bf00      	nop
 8000bf0:	e000e010 	.word	0xe000e010

08000bf4 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000bf4:	b580      	push	{r7, lr}
 8000bf6:	b082      	sub	sp, #8
 8000bf8:	af00      	add	r7, sp, #0
 8000bfa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8000bfc:	6878      	ldr	r0, [r7, #4]
 8000bfe:	f7ff ff47 	bl	8000a90 <__NVIC_SetPriorityGrouping>
}
 8000c02:	bf00      	nop
 8000c04:	3708      	adds	r7, #8
 8000c06:	46bd      	mov	sp, r7
 8000c08:	bd80      	pop	{r7, pc}

08000c0a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000c0a:	b580      	push	{r7, lr}
 8000c0c:	b086      	sub	sp, #24
 8000c0e:	af00      	add	r7, sp, #0
 8000c10:	4603      	mov	r3, r0
 8000c12:	60b9      	str	r1, [r7, #8]
 8000c14:	607a      	str	r2, [r7, #4]
 8000c16:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 8000c18:	2300      	movs	r3, #0
 8000c1a:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 8000c1c:	f7ff ff5c 	bl	8000ad8 <__NVIC_GetPriorityGrouping>
 8000c20:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8000c22:	687a      	ldr	r2, [r7, #4]
 8000c24:	68b9      	ldr	r1, [r7, #8]
 8000c26:	6978      	ldr	r0, [r7, #20]
 8000c28:	f7ff ff8e 	bl	8000b48 <NVIC_EncodePriority>
 8000c2c:	4602      	mov	r2, r0
 8000c2e:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8000c32:	4611      	mov	r1, r2
 8000c34:	4618      	mov	r0, r3
 8000c36:	f7ff ff5d 	bl	8000af4 <__NVIC_SetPriority>
}
 8000c3a:	bf00      	nop
 8000c3c:	3718      	adds	r7, #24
 8000c3e:	46bd      	mov	sp, r7
 8000c40:	bd80      	pop	{r7, pc}

08000c42 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8000c42:	b580      	push	{r7, lr}
 8000c44:	b082      	sub	sp, #8
 8000c46:	af00      	add	r7, sp, #0
 8000c48:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8000c4a:	6878      	ldr	r0, [r7, #4]
 8000c4c:	f7ff ffb0 	bl	8000bb0 <SysTick_Config>
 8000c50:	4603      	mov	r3, r0
}
 8000c52:	4618      	mov	r0, r3
 8000c54:	3708      	adds	r7, #8
 8000c56:	46bd      	mov	sp, r7
 8000c58:	bd80      	pop	{r7, pc}
	...

08000c5c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000c5c:	b480      	push	{r7}
 8000c5e:	b089      	sub	sp, #36	@ 0x24
 8000c60:	af00      	add	r7, sp, #0
 8000c62:	6078      	str	r0, [r7, #4]
 8000c64:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 8000c66:	2300      	movs	r3, #0
 8000c68:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 8000c6a:	2300      	movs	r3, #0
 8000c6c:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 8000c6e:	2300      	movs	r3, #0
 8000c70:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000c72:	2300      	movs	r3, #0
 8000c74:	61fb      	str	r3, [r7, #28]
 8000c76:	e159      	b.n	8000f2c <HAL_GPIO_Init+0x2d0>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 8000c78:	2201      	movs	r2, #1
 8000c7a:	69fb      	ldr	r3, [r7, #28]
 8000c7c:	fa02 f303 	lsl.w	r3, r2, r3
 8000c80:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000c82:	683b      	ldr	r3, [r7, #0]
 8000c84:	681b      	ldr	r3, [r3, #0]
 8000c86:	697a      	ldr	r2, [r7, #20]
 8000c88:	4013      	ands	r3, r2
 8000c8a:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 8000c8c:	693a      	ldr	r2, [r7, #16]
 8000c8e:	697b      	ldr	r3, [r7, #20]
 8000c90:	429a      	cmp	r2, r3
 8000c92:	f040 8148 	bne.w	8000f26 <HAL_GPIO_Init+0x2ca>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 8000c96:	683b      	ldr	r3, [r7, #0]
 8000c98:	685b      	ldr	r3, [r3, #4]
 8000c9a:	f003 0303 	and.w	r3, r3, #3
 8000c9e:	2b01      	cmp	r3, #1
 8000ca0:	d005      	beq.n	8000cae <HAL_GPIO_Init+0x52>
          (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8000ca2:	683b      	ldr	r3, [r7, #0]
 8000ca4:	685b      	ldr	r3, [r3, #4]
 8000ca6:	f003 0303 	and.w	r3, r3, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 8000caa:	2b02      	cmp	r3, #2
 8000cac:	d130      	bne.n	8000d10 <HAL_GPIO_Init+0xb4>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8000cae:	687b      	ldr	r3, [r7, #4]
 8000cb0:	689b      	ldr	r3, [r3, #8]
 8000cb2:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8000cb4:	69fb      	ldr	r3, [r7, #28]
 8000cb6:	005b      	lsls	r3, r3, #1
 8000cb8:	2203      	movs	r2, #3
 8000cba:	fa02 f303 	lsl.w	r3, r2, r3
 8000cbe:	43db      	mvns	r3, r3
 8000cc0:	69ba      	ldr	r2, [r7, #24]
 8000cc2:	4013      	ands	r3, r2
 8000cc4:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8000cc6:	683b      	ldr	r3, [r7, #0]
 8000cc8:	68da      	ldr	r2, [r3, #12]
 8000cca:	69fb      	ldr	r3, [r7, #28]
 8000ccc:	005b      	lsls	r3, r3, #1
 8000cce:	fa02 f303 	lsl.w	r3, r2, r3
 8000cd2:	69ba      	ldr	r2, [r7, #24]
 8000cd4:	4313      	orrs	r3, r2
 8000cd6:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8000cd8:	687b      	ldr	r3, [r7, #4]
 8000cda:	69ba      	ldr	r2, [r7, #24]
 8000cdc:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8000cde:	687b      	ldr	r3, [r7, #4]
 8000ce0:	685b      	ldr	r3, [r3, #4]
 8000ce2:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000ce4:	2201      	movs	r2, #1
 8000ce6:	69fb      	ldr	r3, [r7, #28]
 8000ce8:	fa02 f303 	lsl.w	r3, r2, r3
 8000cec:	43db      	mvns	r3, r3
 8000cee:	69ba      	ldr	r2, [r7, #24]
 8000cf0:	4013      	ands	r3, r2
 8000cf2:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8000cf4:	683b      	ldr	r3, [r7, #0]
 8000cf6:	685b      	ldr	r3, [r3, #4]
 8000cf8:	091b      	lsrs	r3, r3, #4
 8000cfa:	f003 0201 	and.w	r2, r3, #1
 8000cfe:	69fb      	ldr	r3, [r7, #28]
 8000d00:	fa02 f303 	lsl.w	r3, r2, r3
 8000d04:	69ba      	ldr	r2, [r7, #24]
 8000d06:	4313      	orrs	r3, r2
 8000d08:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8000d0a:	687b      	ldr	r3, [r7, #4]
 8000d0c:	69ba      	ldr	r2, [r7, #24]
 8000d0e:	605a      	str	r2, [r3, #4]
       }

      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8000d10:	683b      	ldr	r3, [r7, #0]
 8000d12:	685b      	ldr	r3, [r3, #4]
 8000d14:	f003 0303 	and.w	r3, r3, #3
 8000d18:	2b03      	cmp	r3, #3
 8000d1a:	d017      	beq.n	8000d4c <HAL_GPIO_Init+0xf0>
      {
        /* Check the parameters */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
        
        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 8000d1c:	687b      	ldr	r3, [r7, #4]
 8000d1e:	68db      	ldr	r3, [r3, #12]
 8000d20:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8000d22:	69fb      	ldr	r3, [r7, #28]
 8000d24:	005b      	lsls	r3, r3, #1
 8000d26:	2203      	movs	r2, #3
 8000d28:	fa02 f303 	lsl.w	r3, r2, r3
 8000d2c:	43db      	mvns	r3, r3
 8000d2e:	69ba      	ldr	r2, [r7, #24]
 8000d30:	4013      	ands	r3, r2
 8000d32:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8000d34:	683b      	ldr	r3, [r7, #0]
 8000d36:	689a      	ldr	r2, [r3, #8]
 8000d38:	69fb      	ldr	r3, [r7, #28]
 8000d3a:	005b      	lsls	r3, r3, #1
 8000d3c:	fa02 f303 	lsl.w	r3, r2, r3
 8000d40:	69ba      	ldr	r2, [r7, #24]
 8000d42:	4313      	orrs	r3, r2
 8000d44:	61bb      	str	r3, [r7, #24]
        GPIOx->PUPDR = temp;
 8000d46:	687b      	ldr	r3, [r7, #4]
 8000d48:	69ba      	ldr	r2, [r7, #24]
 8000d4a:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8000d4c:	683b      	ldr	r3, [r7, #0]
 8000d4e:	685b      	ldr	r3, [r3, #4]
 8000d50:	f003 0303 	and.w	r3, r3, #3
 8000d54:	2b02      	cmp	r3, #2
 8000d56:	d123      	bne.n	8000da0 <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8000d58:	69fb      	ldr	r3, [r7, #28]
 8000d5a:	08da      	lsrs	r2, r3, #3
 8000d5c:	687b      	ldr	r3, [r7, #4]
 8000d5e:	3208      	adds	r2, #8
 8000d60:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8000d64:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8000d66:	69fb      	ldr	r3, [r7, #28]
 8000d68:	f003 0307 	and.w	r3, r3, #7
 8000d6c:	009b      	lsls	r3, r3, #2
 8000d6e:	220f      	movs	r2, #15
 8000d70:	fa02 f303 	lsl.w	r3, r2, r3
 8000d74:	43db      	mvns	r3, r3
 8000d76:	69ba      	ldr	r2, [r7, #24]
 8000d78:	4013      	ands	r3, r2
 8000d7a:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8000d7c:	683b      	ldr	r3, [r7, #0]
 8000d7e:	691a      	ldr	r2, [r3, #16]
 8000d80:	69fb      	ldr	r3, [r7, #28]
 8000d82:	f003 0307 	and.w	r3, r3, #7
 8000d86:	009b      	lsls	r3, r3, #2
 8000d88:	fa02 f303 	lsl.w	r3, r2, r3
 8000d8c:	69ba      	ldr	r2, [r7, #24]
 8000d8e:	4313      	orrs	r3, r2
 8000d90:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8000d92:	69fb      	ldr	r3, [r7, #28]
 8000d94:	08da      	lsrs	r2, r3, #3
 8000d96:	687b      	ldr	r3, [r7, #4]
 8000d98:	3208      	adds	r2, #8
 8000d9a:	69b9      	ldr	r1, [r7, #24]
 8000d9c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8000da0:	687b      	ldr	r3, [r7, #4]
 8000da2:	681b      	ldr	r3, [r3, #0]
 8000da4:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000da6:	69fb      	ldr	r3, [r7, #28]
 8000da8:	005b      	lsls	r3, r3, #1
 8000daa:	2203      	movs	r2, #3
 8000dac:	fa02 f303 	lsl.w	r3, r2, r3
 8000db0:	43db      	mvns	r3, r3
 8000db2:	69ba      	ldr	r2, [r7, #24]
 8000db4:	4013      	ands	r3, r2
 8000db6:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000db8:	683b      	ldr	r3, [r7, #0]
 8000dba:	685b      	ldr	r3, [r3, #4]
 8000dbc:	f003 0203 	and.w	r2, r3, #3
 8000dc0:	69fb      	ldr	r3, [r7, #28]
 8000dc2:	005b      	lsls	r3, r3, #1
 8000dc4:	fa02 f303 	lsl.w	r3, r2, r3
 8000dc8:	69ba      	ldr	r2, [r7, #24]
 8000dca:	4313      	orrs	r3, r2
 8000dcc:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8000dce:	687b      	ldr	r3, [r7, #4]
 8000dd0:	69ba      	ldr	r2, [r7, #24]
 8000dd2:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8000dd4:	683b      	ldr	r3, [r7, #0]
 8000dd6:	685b      	ldr	r3, [r3, #4]
 8000dd8:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8000ddc:	2b00      	cmp	r3, #0
 8000dde:	f000 80a2 	beq.w	8000f26 <HAL_GPIO_Init+0x2ca>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000de2:	2300      	movs	r3, #0
 8000de4:	60fb      	str	r3, [r7, #12]
 8000de6:	4b57      	ldr	r3, [pc, #348]	@ (8000f44 <HAL_GPIO_Init+0x2e8>)
 8000de8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8000dea:	4a56      	ldr	r2, [pc, #344]	@ (8000f44 <HAL_GPIO_Init+0x2e8>)
 8000dec:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8000df0:	6453      	str	r3, [r2, #68]	@ 0x44
 8000df2:	4b54      	ldr	r3, [pc, #336]	@ (8000f44 <HAL_GPIO_Init+0x2e8>)
 8000df4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8000df6:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8000dfa:	60fb      	str	r3, [r7, #12]
 8000dfc:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8000dfe:	4a52      	ldr	r2, [pc, #328]	@ (8000f48 <HAL_GPIO_Init+0x2ec>)
 8000e00:	69fb      	ldr	r3, [r7, #28]
 8000e02:	089b      	lsrs	r3, r3, #2
 8000e04:	3302      	adds	r3, #2
 8000e06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000e0a:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8000e0c:	69fb      	ldr	r3, [r7, #28]
 8000e0e:	f003 0303 	and.w	r3, r3, #3
 8000e12:	009b      	lsls	r3, r3, #2
 8000e14:	220f      	movs	r2, #15
 8000e16:	fa02 f303 	lsl.w	r3, r2, r3
 8000e1a:	43db      	mvns	r3, r3
 8000e1c:	69ba      	ldr	r2, [r7, #24]
 8000e1e:	4013      	ands	r3, r2
 8000e20:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8000e22:	687b      	ldr	r3, [r7, #4]
 8000e24:	4a49      	ldr	r2, [pc, #292]	@ (8000f4c <HAL_GPIO_Init+0x2f0>)
 8000e26:	4293      	cmp	r3, r2
 8000e28:	d019      	beq.n	8000e5e <HAL_GPIO_Init+0x202>
 8000e2a:	687b      	ldr	r3, [r7, #4]
 8000e2c:	4a48      	ldr	r2, [pc, #288]	@ (8000f50 <HAL_GPIO_Init+0x2f4>)
 8000e2e:	4293      	cmp	r3, r2
 8000e30:	d013      	beq.n	8000e5a <HAL_GPIO_Init+0x1fe>
 8000e32:	687b      	ldr	r3, [r7, #4]
 8000e34:	4a47      	ldr	r2, [pc, #284]	@ (8000f54 <HAL_GPIO_Init+0x2f8>)
 8000e36:	4293      	cmp	r3, r2
 8000e38:	d00d      	beq.n	8000e56 <HAL_GPIO_Init+0x1fa>
 8000e3a:	687b      	ldr	r3, [r7, #4]
 8000e3c:	4a46      	ldr	r2, [pc, #280]	@ (8000f58 <HAL_GPIO_Init+0x2fc>)
 8000e3e:	4293      	cmp	r3, r2
 8000e40:	d007      	beq.n	8000e52 <HAL_GPIO_Init+0x1f6>
 8000e42:	687b      	ldr	r3, [r7, #4]
 8000e44:	4a45      	ldr	r2, [pc, #276]	@ (8000f5c <HAL_GPIO_Init+0x300>)
 8000e46:	4293      	cmp	r3, r2
 8000e48:	d101      	bne.n	8000e4e <HAL_GPIO_Init+0x1f2>
 8000e4a:	2304      	movs	r3, #4
 8000e4c:	e008      	b.n	8000e60 <HAL_GPIO_Init+0x204>
 8000e4e:	2307      	movs	r3, #7
 8000e50:	e006      	b.n	8000e60 <HAL_GPIO_Init+0x204>
 8000e52:	2303      	movs	r3, #3
 8000e54:	e004      	b.n	8000e60 <HAL_GPIO_Init+0x204>
 8000e56:	2302      	movs	r3, #2
 8000e58:	e002      	b.n	8000e60 <HAL_GPIO_Init+0x204>
 8000e5a:	2301      	movs	r3, #1
 8000e5c:	e000      	b.n	8000e60 <HAL_GPIO_Init+0x204>
 8000e5e:	2300      	movs	r3, #0
 8000e60:	69fa      	ldr	r2, [r7, #28]
 8000e62:	f002 0203 	and.w	r2, r2, #3
 8000e66:	0092      	lsls	r2, r2, #2
 8000e68:	4093      	lsls	r3, r2
 8000e6a:	69ba      	ldr	r2, [r7, #24]
 8000e6c:	4313      	orrs	r3, r2
 8000e6e:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8000e70:	4935      	ldr	r1, [pc, #212]	@ (8000f48 <HAL_GPIO_Init+0x2ec>)
 8000e72:	69fb      	ldr	r3, [r7, #28]
 8000e74:	089b      	lsrs	r3, r3, #2
 8000e76:	3302      	adds	r3, #2
 8000e78:	69ba      	ldr	r2, [r7, #24]
 8000e7a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8000e7e:	4b38      	ldr	r3, [pc, #224]	@ (8000f60 <HAL_GPIO_Init+0x304>)
 8000e80:	689b      	ldr	r3, [r3, #8]
 8000e82:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8000e84:	693b      	ldr	r3, [r7, #16]
 8000e86:	43db      	mvns	r3, r3
 8000e88:	69ba      	ldr	r2, [r7, #24]
 8000e8a:	4013      	ands	r3, r2
 8000e8c:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8000e8e:	683b      	ldr	r3, [r7, #0]
 8000e90:	685b      	ldr	r3, [r3, #4]
 8000e92:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8000e96:	2b00      	cmp	r3, #0
 8000e98:	d003      	beq.n	8000ea2 <HAL_GPIO_Init+0x246>
        {
          temp |= iocurrent;
 8000e9a:	69ba      	ldr	r2, [r7, #24]
 8000e9c:	693b      	ldr	r3, [r7, #16]
 8000e9e:	4313      	orrs	r3, r2
 8000ea0:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 8000ea2:	4a2f      	ldr	r2, [pc, #188]	@ (8000f60 <HAL_GPIO_Init+0x304>)
 8000ea4:	69bb      	ldr	r3, [r7, #24]
 8000ea6:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 8000ea8:	4b2d      	ldr	r3, [pc, #180]	@ (8000f60 <HAL_GPIO_Init+0x304>)
 8000eaa:	68db      	ldr	r3, [r3, #12]
 8000eac:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8000eae:	693b      	ldr	r3, [r7, #16]
 8000eb0:	43db      	mvns	r3, r3
 8000eb2:	69ba      	ldr	r2, [r7, #24]
 8000eb4:	4013      	ands	r3, r2
 8000eb6:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8000eb8:	683b      	ldr	r3, [r7, #0]
 8000eba:	685b      	ldr	r3, [r3, #4]
 8000ebc:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8000ec0:	2b00      	cmp	r3, #0
 8000ec2:	d003      	beq.n	8000ecc <HAL_GPIO_Init+0x270>
        {
          temp |= iocurrent;
 8000ec4:	69ba      	ldr	r2, [r7, #24]
 8000ec6:	693b      	ldr	r3, [r7, #16]
 8000ec8:	4313      	orrs	r3, r2
 8000eca:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 8000ecc:	4a24      	ldr	r2, [pc, #144]	@ (8000f60 <HAL_GPIO_Init+0x304>)
 8000ece:	69bb      	ldr	r3, [r7, #24]
 8000ed0:	60d3      	str	r3, [r2, #12]

        temp = EXTI->EMR;
 8000ed2:	4b23      	ldr	r3, [pc, #140]	@ (8000f60 <HAL_GPIO_Init+0x304>)
 8000ed4:	685b      	ldr	r3, [r3, #4]
 8000ed6:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8000ed8:	693b      	ldr	r3, [r7, #16]
 8000eda:	43db      	mvns	r3, r3
 8000edc:	69ba      	ldr	r2, [r7, #24]
 8000ede:	4013      	ands	r3, r2
 8000ee0:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8000ee2:	683b      	ldr	r3, [r7, #0]
 8000ee4:	685b      	ldr	r3, [r3, #4]
 8000ee6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8000eea:	2b00      	cmp	r3, #0
 8000eec:	d003      	beq.n	8000ef6 <HAL_GPIO_Init+0x29a>
        {
          temp |= iocurrent;
 8000eee:	69ba      	ldr	r2, [r7, #24]
 8000ef0:	693b      	ldr	r3, [r7, #16]
 8000ef2:	4313      	orrs	r3, r2
 8000ef4:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 8000ef6:	4a1a      	ldr	r2, [pc, #104]	@ (8000f60 <HAL_GPIO_Init+0x304>)
 8000ef8:	69bb      	ldr	r3, [r7, #24]
 8000efa:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000efc:	4b18      	ldr	r3, [pc, #96]	@ (8000f60 <HAL_GPIO_Init+0x304>)
 8000efe:	681b      	ldr	r3, [r3, #0]
 8000f00:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8000f02:	693b      	ldr	r3, [r7, #16]
 8000f04:	43db      	mvns	r3, r3
 8000f06:	69ba      	ldr	r2, [r7, #24]
 8000f08:	4013      	ands	r3, r2
 8000f0a:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8000f0c:	683b      	ldr	r3, [r7, #0]
 8000f0e:	685b      	ldr	r3, [r3, #4]
 8000f10:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8000f14:	2b00      	cmp	r3, #0
 8000f16:	d003      	beq.n	8000f20 <HAL_GPIO_Init+0x2c4>
        {
          temp |= iocurrent;
 8000f18:	69ba      	ldr	r2, [r7, #24]
 8000f1a:	693b      	ldr	r3, [r7, #16]
 8000f1c:	4313      	orrs	r3, r2
 8000f1e:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 8000f20:	4a0f      	ldr	r2, [pc, #60]	@ (8000f60 <HAL_GPIO_Init+0x304>)
 8000f22:	69bb      	ldr	r3, [r7, #24]
 8000f24:	6013      	str	r3, [r2, #0]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8000f26:	69fb      	ldr	r3, [r7, #28]
 8000f28:	3301      	adds	r3, #1
 8000f2a:	61fb      	str	r3, [r7, #28]
 8000f2c:	69fb      	ldr	r3, [r7, #28]
 8000f2e:	2b0f      	cmp	r3, #15
 8000f30:	f67f aea2 	bls.w	8000c78 <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 8000f34:	bf00      	nop
 8000f36:	bf00      	nop
 8000f38:	3724      	adds	r7, #36	@ 0x24
 8000f3a:	46bd      	mov	sp, r7
 8000f3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f40:	4770      	bx	lr
 8000f42:	bf00      	nop
 8000f44:	40023800 	.word	0x40023800
 8000f48:	40013800 	.word	0x40013800
 8000f4c:	40020000 	.word	0x40020000
 8000f50:	40020400 	.word	0x40020400
 8000f54:	40020800 	.word	0x40020800
 8000f58:	40020c00 	.word	0x40020c00
 8000f5c:	40021000 	.word	0x40021000
 8000f60:	40013c00 	.word	0x40013c00

08000f64 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8000f64:	b480      	push	{r7}
 8000f66:	b083      	sub	sp, #12
 8000f68:	af00      	add	r7, sp, #0
 8000f6a:	6078      	str	r0, [r7, #4]
 8000f6c:	460b      	mov	r3, r1
 8000f6e:	807b      	strh	r3, [r7, #2]
 8000f70:	4613      	mov	r3, r2
 8000f72:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8000f74:	787b      	ldrb	r3, [r7, #1]
 8000f76:	2b00      	cmp	r3, #0
 8000f78:	d003      	beq.n	8000f82 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8000f7a:	887a      	ldrh	r2, [r7, #2]
 8000f7c:	687b      	ldr	r3, [r7, #4]
 8000f7e:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 8000f80:	e003      	b.n	8000f8a <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8000f82:	887b      	ldrh	r3, [r7, #2]
 8000f84:	041a      	lsls	r2, r3, #16
 8000f86:	687b      	ldr	r3, [r7, #4]
 8000f88:	619a      	str	r2, [r3, #24]
}
 8000f8a:	bf00      	nop
 8000f8c:	370c      	adds	r7, #12
 8000f8e:	46bd      	mov	sp, r7
 8000f90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f94:	4770      	bx	lr
	...

08000f98 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8000f98:	b580      	push	{r7, lr}
 8000f9a:	b086      	sub	sp, #24
 8000f9c:	af00      	add	r7, sp, #0
 8000f9e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t pll_config;
  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8000fa0:	687b      	ldr	r3, [r7, #4]
 8000fa2:	2b00      	cmp	r3, #0
 8000fa4:	d101      	bne.n	8000faa <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 8000fa6:	2301      	movs	r3, #1
 8000fa8:	e267      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000faa:	687b      	ldr	r3, [r7, #4]
 8000fac:	681b      	ldr	r3, [r3, #0]
 8000fae:	f003 0301 	and.w	r3, r3, #1
 8000fb2:	2b00      	cmp	r3, #0
 8000fb4:	d075      	beq.n	80010a2 <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || \
 8000fb6:	4b88      	ldr	r3, [pc, #544]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8000fb8:	689b      	ldr	r3, [r3, #8]
 8000fba:	f003 030c 	and.w	r3, r3, #12
 8000fbe:	2b04      	cmp	r3, #4
 8000fc0:	d00c      	beq.n	8000fdc <HAL_RCC_OscConfig+0x44>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8000fc2:	4b85      	ldr	r3, [pc, #532]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8000fc4:	689b      	ldr	r3, [r3, #8]
 8000fc6:	f003 030c 	and.w	r3, r3, #12
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) || \
 8000fca:	2b08      	cmp	r3, #8
 8000fcc:	d112      	bne.n	8000ff4 <HAL_RCC_OscConfig+0x5c>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8000fce:	4b82      	ldr	r3, [pc, #520]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8000fd0:	685b      	ldr	r3, [r3, #4]
 8000fd2:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8000fd6:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8000fda:	d10b      	bne.n	8000ff4 <HAL_RCC_OscConfig+0x5c>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000fdc:	4b7e      	ldr	r3, [pc, #504]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8000fde:	681b      	ldr	r3, [r3, #0]
 8000fe0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8000fe4:	2b00      	cmp	r3, #0
 8000fe6:	d05b      	beq.n	80010a0 <HAL_RCC_OscConfig+0x108>
 8000fe8:	687b      	ldr	r3, [r7, #4]
 8000fea:	685b      	ldr	r3, [r3, #4]
 8000fec:	2b00      	cmp	r3, #0
 8000fee:	d157      	bne.n	80010a0 <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
 8000ff0:	2301      	movs	r3, #1
 8000ff2:	e242      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000ff4:	687b      	ldr	r3, [r7, #4]
 8000ff6:	685b      	ldr	r3, [r3, #4]
 8000ff8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8000ffc:	d106      	bne.n	800100c <HAL_RCC_OscConfig+0x74>
 8000ffe:	4b76      	ldr	r3, [pc, #472]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8001000:	681b      	ldr	r3, [r3, #0]
 8001002:	4a75      	ldr	r2, [pc, #468]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8001004:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8001008:	6013      	str	r3, [r2, #0]
 800100a:	e01d      	b.n	8001048 <HAL_RCC_OscConfig+0xb0>
 800100c:	687b      	ldr	r3, [r7, #4]
 800100e:	685b      	ldr	r3, [r3, #4]
 8001010:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8001014:	d10c      	bne.n	8001030 <HAL_RCC_OscConfig+0x98>
 8001016:	4b70      	ldr	r3, [pc, #448]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8001018:	681b      	ldr	r3, [r3, #0]
 800101a:	4a6f      	ldr	r2, [pc, #444]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 800101c:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8001020:	6013      	str	r3, [r2, #0]
 8001022:	4b6d      	ldr	r3, [pc, #436]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8001024:	681b      	ldr	r3, [r3, #0]
 8001026:	4a6c      	ldr	r2, [pc, #432]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8001028:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800102c:	6013      	str	r3, [r2, #0]
 800102e:	e00b      	b.n	8001048 <HAL_RCC_OscConfig+0xb0>
 8001030:	4b69      	ldr	r3, [pc, #420]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8001032:	681b      	ldr	r3, [r3, #0]
 8001034:	4a68      	ldr	r2, [pc, #416]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8001036:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800103a:	6013      	str	r3, [r2, #0]
 800103c:	4b66      	ldr	r3, [pc, #408]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 800103e:	681b      	ldr	r3, [r3, #0]
 8001040:	4a65      	ldr	r2, [pc, #404]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8001042:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8001046:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if ((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8001048:	687b      	ldr	r3, [r7, #4]
 800104a:	685b      	ldr	r3, [r3, #4]
 800104c:	2b00      	cmp	r3, #0
 800104e:	d013      	beq.n	8001078 <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001050:	f7ff fcee 	bl	8000a30 <HAL_GetTick>
 8001054:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001056:	e008      	b.n	800106a <HAL_RCC_OscConfig+0xd2>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001058:	f7ff fcea 	bl	8000a30 <HAL_GetTick>
 800105c:	4602      	mov	r2, r0
 800105e:	693b      	ldr	r3, [r7, #16]
 8001060:	1ad3      	subs	r3, r2, r3
 8001062:	2b64      	cmp	r3, #100	@ 0x64
 8001064:	d901      	bls.n	800106a <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 8001066:	2303      	movs	r3, #3
 8001068:	e207      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800106a:	4b5b      	ldr	r3, [pc, #364]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 800106c:	681b      	ldr	r3, [r3, #0]
 800106e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8001072:	2b00      	cmp	r3, #0
 8001074:	d0f0      	beq.n	8001058 <HAL_RCC_OscConfig+0xc0>
 8001076:	e014      	b.n	80010a2 <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001078:	f7ff fcda 	bl	8000a30 <HAL_GetTick>
 800107c:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800107e:	e008      	b.n	8001092 <HAL_RCC_OscConfig+0xfa>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001080:	f7ff fcd6 	bl	8000a30 <HAL_GetTick>
 8001084:	4602      	mov	r2, r0
 8001086:	693b      	ldr	r3, [r7, #16]
 8001088:	1ad3      	subs	r3, r2, r3
 800108a:	2b64      	cmp	r3, #100	@ 0x64
 800108c:	d901      	bls.n	8001092 <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 800108e:	2303      	movs	r3, #3
 8001090:	e1f3      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8001092:	4b51      	ldr	r3, [pc, #324]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8001094:	681b      	ldr	r3, [r3, #0]
 8001096:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800109a:	2b00      	cmp	r3, #0
 800109c:	d1f0      	bne.n	8001080 <HAL_RCC_OscConfig+0xe8>
 800109e:	e000      	b.n	80010a2 <HAL_RCC_OscConfig+0x10a>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80010a0:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80010a2:	687b      	ldr	r3, [r7, #4]
 80010a4:	681b      	ldr	r3, [r3, #0]
 80010a6:	f003 0302 	and.w	r3, r3, #2
 80010aa:	2b00      	cmp	r3, #0
 80010ac:	d063      	beq.n	8001176 <HAL_RCC_OscConfig+0x1de>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || \
 80010ae:	4b4a      	ldr	r3, [pc, #296]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 80010b0:	689b      	ldr	r3, [r3, #8]
 80010b2:	f003 030c 	and.w	r3, r3, #12
 80010b6:	2b00      	cmp	r3, #0
 80010b8:	d00b      	beq.n	80010d2 <HAL_RCC_OscConfig+0x13a>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80010ba:	4b47      	ldr	r3, [pc, #284]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 80010bc:	689b      	ldr	r3, [r3, #8]
 80010be:	f003 030c 	and.w	r3, r3, #12
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) || \
 80010c2:	2b08      	cmp	r3, #8
 80010c4:	d11c      	bne.n	8001100 <HAL_RCC_OscConfig+0x168>
        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80010c6:	4b44      	ldr	r3, [pc, #272]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 80010c8:	685b      	ldr	r3, [r3, #4]
 80010ca:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 80010ce:	2b00      	cmp	r3, #0
 80010d0:	d116      	bne.n	8001100 <HAL_RCC_OscConfig+0x168>
    {
      /* When HSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80010d2:	4b41      	ldr	r3, [pc, #260]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 80010d4:	681b      	ldr	r3, [r3, #0]
 80010d6:	f003 0302 	and.w	r3, r3, #2
 80010da:	2b00      	cmp	r3, #0
 80010dc:	d005      	beq.n	80010ea <HAL_RCC_OscConfig+0x152>
 80010de:	687b      	ldr	r3, [r7, #4]
 80010e0:	68db      	ldr	r3, [r3, #12]
 80010e2:	2b01      	cmp	r3, #1
 80010e4:	d001      	beq.n	80010ea <HAL_RCC_OscConfig+0x152>
      {
        return HAL_ERROR;
 80010e6:	2301      	movs	r3, #1
 80010e8:	e1c7      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80010ea:	4b3b      	ldr	r3, [pc, #236]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 80010ec:	681b      	ldr	r3, [r3, #0]
 80010ee:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 80010f2:	687b      	ldr	r3, [r7, #4]
 80010f4:	691b      	ldr	r3, [r3, #16]
 80010f6:	00db      	lsls	r3, r3, #3
 80010f8:	4937      	ldr	r1, [pc, #220]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 80010fa:	4313      	orrs	r3, r2
 80010fc:	600b      	str	r3, [r1, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80010fe:	e03a      	b.n	8001176 <HAL_RCC_OscConfig+0x1de>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 8001100:	687b      	ldr	r3, [r7, #4]
 8001102:	68db      	ldr	r3, [r3, #12]
 8001104:	2b00      	cmp	r3, #0
 8001106:	d020      	beq.n	800114a <HAL_RCC_OscConfig+0x1b2>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8001108:	4b34      	ldr	r3, [pc, #208]	@ (80011dc <HAL_RCC_OscConfig+0x244>)
 800110a:	2201      	movs	r2, #1
 800110c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800110e:	f7ff fc8f 	bl	8000a30 <HAL_GetTick>
 8001112:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001114:	e008      	b.n	8001128 <HAL_RCC_OscConfig+0x190>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001116:	f7ff fc8b 	bl	8000a30 <HAL_GetTick>
 800111a:	4602      	mov	r2, r0
 800111c:	693b      	ldr	r3, [r7, #16]
 800111e:	1ad3      	subs	r3, r2, r3
 8001120:	2b02      	cmp	r3, #2
 8001122:	d901      	bls.n	8001128 <HAL_RCC_OscConfig+0x190>
          {
            return HAL_TIMEOUT;
 8001124:	2303      	movs	r3, #3
 8001126:	e1a8      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001128:	4b2b      	ldr	r3, [pc, #172]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 800112a:	681b      	ldr	r3, [r3, #0]
 800112c:	f003 0302 	and.w	r3, r3, #2
 8001130:	2b00      	cmp	r3, #0
 8001132:	d0f0      	beq.n	8001116 <HAL_RCC_OscConfig+0x17e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001134:	4b28      	ldr	r3, [pc, #160]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8001136:	681b      	ldr	r3, [r3, #0]
 8001138:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 800113c:	687b      	ldr	r3, [r7, #4]
 800113e:	691b      	ldr	r3, [r3, #16]
 8001140:	00db      	lsls	r3, r3, #3
 8001142:	4925      	ldr	r1, [pc, #148]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 8001144:	4313      	orrs	r3, r2
 8001146:	600b      	str	r3, [r1, #0]
 8001148:	e015      	b.n	8001176 <HAL_RCC_OscConfig+0x1de>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800114a:	4b24      	ldr	r3, [pc, #144]	@ (80011dc <HAL_RCC_OscConfig+0x244>)
 800114c:	2200      	movs	r2, #0
 800114e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001150:	f7ff fc6e 	bl	8000a30 <HAL_GetTick>
 8001154:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8001156:	e008      	b.n	800116a <HAL_RCC_OscConfig+0x1d2>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001158:	f7ff fc6a 	bl	8000a30 <HAL_GetTick>
 800115c:	4602      	mov	r2, r0
 800115e:	693b      	ldr	r3, [r7, #16]
 8001160:	1ad3      	subs	r3, r2, r3
 8001162:	2b02      	cmp	r3, #2
 8001164:	d901      	bls.n	800116a <HAL_RCC_OscConfig+0x1d2>
          {
            return HAL_TIMEOUT;
 8001166:	2303      	movs	r3, #3
 8001168:	e187      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800116a:	4b1b      	ldr	r3, [pc, #108]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 800116c:	681b      	ldr	r3, [r3, #0]
 800116e:	f003 0302 	and.w	r3, r3, #2
 8001172:	2b00      	cmp	r3, #0
 8001174:	d1f0      	bne.n	8001158 <HAL_RCC_OscConfig+0x1c0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001176:	687b      	ldr	r3, [r7, #4]
 8001178:	681b      	ldr	r3, [r3, #0]
 800117a:	f003 0308 	and.w	r3, r3, #8
 800117e:	2b00      	cmp	r3, #0
 8001180:	d036      	beq.n	80011f0 <HAL_RCC_OscConfig+0x258>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 8001182:	687b      	ldr	r3, [r7, #4]
 8001184:	695b      	ldr	r3, [r3, #20]
 8001186:	2b00      	cmp	r3, #0
 8001188:	d016      	beq.n	80011b8 <HAL_RCC_OscConfig+0x220>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800118a:	4b15      	ldr	r3, [pc, #84]	@ (80011e0 <HAL_RCC_OscConfig+0x248>)
 800118c:	2201      	movs	r2, #1
 800118e:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001190:	f7ff fc4e 	bl	8000a30 <HAL_GetTick>
 8001194:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001196:	e008      	b.n	80011aa <HAL_RCC_OscConfig+0x212>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001198:	f7ff fc4a 	bl	8000a30 <HAL_GetTick>
 800119c:	4602      	mov	r2, r0
 800119e:	693b      	ldr	r3, [r7, #16]
 80011a0:	1ad3      	subs	r3, r2, r3
 80011a2:	2b02      	cmp	r3, #2
 80011a4:	d901      	bls.n	80011aa <HAL_RCC_OscConfig+0x212>
        {
          return HAL_TIMEOUT;
 80011a6:	2303      	movs	r3, #3
 80011a8:	e167      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80011aa:	4b0b      	ldr	r3, [pc, #44]	@ (80011d8 <HAL_RCC_OscConfig+0x240>)
 80011ac:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80011ae:	f003 0302 	and.w	r3, r3, #2
 80011b2:	2b00      	cmp	r3, #0
 80011b4:	d0f0      	beq.n	8001198 <HAL_RCC_OscConfig+0x200>
 80011b6:	e01b      	b.n	80011f0 <HAL_RCC_OscConfig+0x258>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80011b8:	4b09      	ldr	r3, [pc, #36]	@ (80011e0 <HAL_RCC_OscConfig+0x248>)
 80011ba:	2200      	movs	r2, #0
 80011bc:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 80011be:	f7ff fc37 	bl	8000a30 <HAL_GetTick>
 80011c2:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80011c4:	e00e      	b.n	80011e4 <HAL_RCC_OscConfig+0x24c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80011c6:	f7ff fc33 	bl	8000a30 <HAL_GetTick>
 80011ca:	4602      	mov	r2, r0
 80011cc:	693b      	ldr	r3, [r7, #16]
 80011ce:	1ad3      	subs	r3, r2, r3
 80011d0:	2b02      	cmp	r3, #2
 80011d2:	d907      	bls.n	80011e4 <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
 80011d4:	2303      	movs	r3, #3
 80011d6:	e150      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
 80011d8:	40023800 	.word	0x40023800
 80011dc:	42470000 	.word	0x42470000
 80011e0:	42470e80 	.word	0x42470e80
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80011e4:	4b88      	ldr	r3, [pc, #544]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 80011e6:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80011e8:	f003 0302 	and.w	r3, r3, #2
 80011ec:	2b00      	cmp	r3, #0
 80011ee:	d1ea      	bne.n	80011c6 <HAL_RCC_OscConfig+0x22e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80011f0:	687b      	ldr	r3, [r7, #4]
 80011f2:	681b      	ldr	r3, [r3, #0]
 80011f4:	f003 0304 	and.w	r3, r3, #4
 80011f8:	2b00      	cmp	r3, #0
 80011fa:	f000 8097 	beq.w	800132c <HAL_RCC_OscConfig+0x394>
  {
    FlagStatus       pwrclkchanged = RESET;
 80011fe:	2300      	movs	r3, #0
 8001200:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001202:	4b81      	ldr	r3, [pc, #516]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 8001204:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001206:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800120a:	2b00      	cmp	r3, #0
 800120c:	d10f      	bne.n	800122e <HAL_RCC_OscConfig+0x296>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800120e:	2300      	movs	r3, #0
 8001210:	60bb      	str	r3, [r7, #8]
 8001212:	4b7d      	ldr	r3, [pc, #500]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 8001214:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001216:	4a7c      	ldr	r2, [pc, #496]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 8001218:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800121c:	6413      	str	r3, [r2, #64]	@ 0x40
 800121e:	4b7a      	ldr	r3, [pc, #488]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 8001220:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001222:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8001226:	60bb      	str	r3, [r7, #8]
 8001228:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 800122a:	2301      	movs	r3, #1
 800122c:	75fb      	strb	r3, [r7, #23]
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800122e:	4b77      	ldr	r3, [pc, #476]	@ (800140c <HAL_RCC_OscConfig+0x474>)
 8001230:	681b      	ldr	r3, [r3, #0]
 8001232:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8001236:	2b00      	cmp	r3, #0
 8001238:	d118      	bne.n	800126c <HAL_RCC_OscConfig+0x2d4>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800123a:	4b74      	ldr	r3, [pc, #464]	@ (800140c <HAL_RCC_OscConfig+0x474>)
 800123c:	681b      	ldr	r3, [r3, #0]
 800123e:	4a73      	ldr	r2, [pc, #460]	@ (800140c <HAL_RCC_OscConfig+0x474>)
 8001240:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8001244:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8001246:	f7ff fbf3 	bl	8000a30 <HAL_GetTick>
 800124a:	6138      	str	r0, [r7, #16]

      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800124c:	e008      	b.n	8001260 <HAL_RCC_OscConfig+0x2c8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800124e:	f7ff fbef 	bl	8000a30 <HAL_GetTick>
 8001252:	4602      	mov	r2, r0
 8001254:	693b      	ldr	r3, [r7, #16]
 8001256:	1ad3      	subs	r3, r2, r3
 8001258:	2b02      	cmp	r3, #2
 800125a:	d901      	bls.n	8001260 <HAL_RCC_OscConfig+0x2c8>
        {
          return HAL_TIMEOUT;
 800125c:	2303      	movs	r3, #3
 800125e:	e10c      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001260:	4b6a      	ldr	r3, [pc, #424]	@ (800140c <HAL_RCC_OscConfig+0x474>)
 8001262:	681b      	ldr	r3, [r3, #0]
 8001264:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8001268:	2b00      	cmp	r3, #0
 800126a:	d0f0      	beq.n	800124e <HAL_RCC_OscConfig+0x2b6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800126c:	687b      	ldr	r3, [r7, #4]
 800126e:	689b      	ldr	r3, [r3, #8]
 8001270:	2b01      	cmp	r3, #1
 8001272:	d106      	bne.n	8001282 <HAL_RCC_OscConfig+0x2ea>
 8001274:	4b64      	ldr	r3, [pc, #400]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 8001276:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8001278:	4a63      	ldr	r2, [pc, #396]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 800127a:	f043 0301 	orr.w	r3, r3, #1
 800127e:	6713      	str	r3, [r2, #112]	@ 0x70
 8001280:	e01c      	b.n	80012bc <HAL_RCC_OscConfig+0x324>
 8001282:	687b      	ldr	r3, [r7, #4]
 8001284:	689b      	ldr	r3, [r3, #8]
 8001286:	2b05      	cmp	r3, #5
 8001288:	d10c      	bne.n	80012a4 <HAL_RCC_OscConfig+0x30c>
 800128a:	4b5f      	ldr	r3, [pc, #380]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 800128c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800128e:	4a5e      	ldr	r2, [pc, #376]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 8001290:	f043 0304 	orr.w	r3, r3, #4
 8001294:	6713      	str	r3, [r2, #112]	@ 0x70
 8001296:	4b5c      	ldr	r3, [pc, #368]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 8001298:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800129a:	4a5b      	ldr	r2, [pc, #364]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 800129c:	f043 0301 	orr.w	r3, r3, #1
 80012a0:	6713      	str	r3, [r2, #112]	@ 0x70
 80012a2:	e00b      	b.n	80012bc <HAL_RCC_OscConfig+0x324>
 80012a4:	4b58      	ldr	r3, [pc, #352]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 80012a6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80012a8:	4a57      	ldr	r2, [pc, #348]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 80012aa:	f023 0301 	bic.w	r3, r3, #1
 80012ae:	6713      	str	r3, [r2, #112]	@ 0x70
 80012b0:	4b55      	ldr	r3, [pc, #340]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 80012b2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80012b4:	4a54      	ldr	r2, [pc, #336]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 80012b6:	f023 0304 	bic.w	r3, r3, #4
 80012ba:	6713      	str	r3, [r2, #112]	@ 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80012bc:	687b      	ldr	r3, [r7, #4]
 80012be:	689b      	ldr	r3, [r3, #8]
 80012c0:	2b00      	cmp	r3, #0
 80012c2:	d015      	beq.n	80012f0 <HAL_RCC_OscConfig+0x358>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80012c4:	f7ff fbb4 	bl	8000a30 <HAL_GetTick>
 80012c8:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80012ca:	e00a      	b.n	80012e2 <HAL_RCC_OscConfig+0x34a>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80012cc:	f7ff fbb0 	bl	8000a30 <HAL_GetTick>
 80012d0:	4602      	mov	r2, r0
 80012d2:	693b      	ldr	r3, [r7, #16]
 80012d4:	1ad3      	subs	r3, r2, r3
 80012d6:	f241 3288 	movw	r2, #5000	@ 0x1388
 80012da:	4293      	cmp	r3, r2
 80012dc:	d901      	bls.n	80012e2 <HAL_RCC_OscConfig+0x34a>
        {
          return HAL_TIMEOUT;
 80012de:	2303      	movs	r3, #3
 80012e0:	e0cb      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80012e2:	4b49      	ldr	r3, [pc, #292]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 80012e4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80012e6:	f003 0302 	and.w	r3, r3, #2
 80012ea:	2b00      	cmp	r3, #0
 80012ec:	d0ee      	beq.n	80012cc <HAL_RCC_OscConfig+0x334>
 80012ee:	e014      	b.n	800131a <HAL_RCC_OscConfig+0x382>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 80012f0:	f7ff fb9e 	bl	8000a30 <HAL_GetTick>
 80012f4:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80012f6:	e00a      	b.n	800130e <HAL_RCC_OscConfig+0x376>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80012f8:	f7ff fb9a 	bl	8000a30 <HAL_GetTick>
 80012fc:	4602      	mov	r2, r0
 80012fe:	693b      	ldr	r3, [r7, #16]
 8001300:	1ad3      	subs	r3, r2, r3
 8001302:	f241 3288 	movw	r2, #5000	@ 0x1388
 8001306:	4293      	cmp	r3, r2
 8001308:	d901      	bls.n	800130e <HAL_RCC_OscConfig+0x376>
        {
          return HAL_TIMEOUT;
 800130a:	2303      	movs	r3, #3
 800130c:	e0b5      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800130e:	4b3e      	ldr	r3, [pc, #248]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 8001310:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8001312:	f003 0302 	and.w	r3, r3, #2
 8001316:	2b00      	cmp	r3, #0
 8001318:	d1ee      	bne.n	80012f8 <HAL_RCC_OscConfig+0x360>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 800131a:	7dfb      	ldrb	r3, [r7, #23]
 800131c:	2b01      	cmp	r3, #1
 800131e:	d105      	bne.n	800132c <HAL_RCC_OscConfig+0x394>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8001320:	4b39      	ldr	r3, [pc, #228]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 8001322:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001324:	4a38      	ldr	r2, [pc, #224]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 8001326:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 800132a:	6413      	str	r3, [r2, #64]	@ 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800132c:	687b      	ldr	r3, [r7, #4]
 800132e:	699b      	ldr	r3, [r3, #24]
 8001330:	2b00      	cmp	r3, #0
 8001332:	f000 80a1 	beq.w	8001478 <HAL_RCC_OscConfig+0x4e0>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001336:	4b34      	ldr	r3, [pc, #208]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 8001338:	689b      	ldr	r3, [r3, #8]
 800133a:	f003 030c 	and.w	r3, r3, #12
 800133e:	2b08      	cmp	r3, #8
 8001340:	d05c      	beq.n	80013fc <HAL_RCC_OscConfig+0x464>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001342:	687b      	ldr	r3, [r7, #4]
 8001344:	699b      	ldr	r3, [r3, #24]
 8001346:	2b02      	cmp	r3, #2
 8001348:	d141      	bne.n	80013ce <HAL_RCC_OscConfig+0x436>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800134a:	4b31      	ldr	r3, [pc, #196]	@ (8001410 <HAL_RCC_OscConfig+0x478>)
 800134c:	2200      	movs	r2, #0
 800134e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8001350:	f7ff fb6e 	bl	8000a30 <HAL_GetTick>
 8001354:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001356:	e008      	b.n	800136a <HAL_RCC_OscConfig+0x3d2>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001358:	f7ff fb6a 	bl	8000a30 <HAL_GetTick>
 800135c:	4602      	mov	r2, r0
 800135e:	693b      	ldr	r3, [r7, #16]
 8001360:	1ad3      	subs	r3, r2, r3
 8001362:	2b02      	cmp	r3, #2
 8001364:	d901      	bls.n	800136a <HAL_RCC_OscConfig+0x3d2>
          {
            return HAL_TIMEOUT;
 8001366:	2303      	movs	r3, #3
 8001368:	e087      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800136a:	4b27      	ldr	r3, [pc, #156]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 800136c:	681b      	ldr	r3, [r3, #0]
 800136e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8001372:	2b00      	cmp	r3, #0
 8001374:	d1f0      	bne.n	8001358 <HAL_RCC_OscConfig+0x3c0>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8001376:	687b      	ldr	r3, [r7, #4]
 8001378:	69da      	ldr	r2, [r3, #28]
 800137a:	687b      	ldr	r3, [r7, #4]
 800137c:	6a1b      	ldr	r3, [r3, #32]
 800137e:	431a      	orrs	r2, r3
 8001380:	687b      	ldr	r3, [r7, #4]
 8001382:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8001384:	019b      	lsls	r3, r3, #6
 8001386:	431a      	orrs	r2, r3
 8001388:	687b      	ldr	r3, [r7, #4]
 800138a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800138c:	085b      	lsrs	r3, r3, #1
 800138e:	3b01      	subs	r3, #1
 8001390:	041b      	lsls	r3, r3, #16
 8001392:	431a      	orrs	r2, r3
 8001394:	687b      	ldr	r3, [r7, #4]
 8001396:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8001398:	061b      	lsls	r3, r3, #24
 800139a:	491b      	ldr	r1, [pc, #108]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 800139c:	4313      	orrs	r3, r2
 800139e:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 80013a0:	4b1b      	ldr	r3, [pc, #108]	@ (8001410 <HAL_RCC_OscConfig+0x478>)
 80013a2:	2201      	movs	r2, #1
 80013a4:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80013a6:	f7ff fb43 	bl	8000a30 <HAL_GetTick>
 80013aa:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80013ac:	e008      	b.n	80013c0 <HAL_RCC_OscConfig+0x428>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80013ae:	f7ff fb3f 	bl	8000a30 <HAL_GetTick>
 80013b2:	4602      	mov	r2, r0
 80013b4:	693b      	ldr	r3, [r7, #16]
 80013b6:	1ad3      	subs	r3, r2, r3
 80013b8:	2b02      	cmp	r3, #2
 80013ba:	d901      	bls.n	80013c0 <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
 80013bc:	2303      	movs	r3, #3
 80013be:	e05c      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80013c0:	4b11      	ldr	r3, [pc, #68]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 80013c2:	681b      	ldr	r3, [r3, #0]
 80013c4:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80013c8:	2b00      	cmp	r3, #0
 80013ca:	d0f0      	beq.n	80013ae <HAL_RCC_OscConfig+0x416>
 80013cc:	e054      	b.n	8001478 <HAL_RCC_OscConfig+0x4e0>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80013ce:	4b10      	ldr	r3, [pc, #64]	@ (8001410 <HAL_RCC_OscConfig+0x478>)
 80013d0:	2200      	movs	r2, #0
 80013d2:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 80013d4:	f7ff fb2c 	bl	8000a30 <HAL_GetTick>
 80013d8:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80013da:	e008      	b.n	80013ee <HAL_RCC_OscConfig+0x456>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80013dc:	f7ff fb28 	bl	8000a30 <HAL_GetTick>
 80013e0:	4602      	mov	r2, r0
 80013e2:	693b      	ldr	r3, [r7, #16]
 80013e4:	1ad3      	subs	r3, r2, r3
 80013e6:	2b02      	cmp	r3, #2
 80013e8:	d901      	bls.n	80013ee <HAL_RCC_OscConfig+0x456>
          {
            return HAL_TIMEOUT;
 80013ea:	2303      	movs	r3, #3
 80013ec:	e045      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80013ee:	4b06      	ldr	r3, [pc, #24]	@ (8001408 <HAL_RCC_OscConfig+0x470>)
 80013f0:	681b      	ldr	r3, [r3, #0]
 80013f2:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80013f6:	2b00      	cmp	r3, #0
 80013f8:	d1f0      	bne.n	80013dc <HAL_RCC_OscConfig+0x444>
 80013fa:	e03d      	b.n	8001478 <HAL_RCC_OscConfig+0x4e0>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 80013fc:	687b      	ldr	r3, [r7, #4]
 80013fe:	699b      	ldr	r3, [r3, #24]
 8001400:	2b01      	cmp	r3, #1
 8001402:	d107      	bne.n	8001414 <HAL_RCC_OscConfig+0x47c>
      {
        return HAL_ERROR;
 8001404:	2301      	movs	r3, #1
 8001406:	e038      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
 8001408:	40023800 	.word	0x40023800
 800140c:	40007000 	.word	0x40007000
 8001410:	42470060 	.word	0x42470060
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR;
 8001414:	4b1b      	ldr	r3, [pc, #108]	@ (8001484 <HAL_RCC_OscConfig+0x4ec>)
 8001416:	685b      	ldr	r3, [r3, #4]
 8001418:	60fb      	str	r3, [r7, #12]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
#else
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800141a:	687b      	ldr	r3, [r7, #4]
 800141c:	699b      	ldr	r3, [r3, #24]
 800141e:	2b01      	cmp	r3, #1
 8001420:	d028      	beq.n	8001474 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8001422:	68fb      	ldr	r3, [r7, #12]
 8001424:	f403 0280 	and.w	r2, r3, #4194304	@ 0x400000
 8001428:	687b      	ldr	r3, [r7, #4]
 800142a:	69db      	ldr	r3, [r3, #28]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800142c:	429a      	cmp	r2, r3
 800142e:	d121      	bne.n	8001474 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 8001430:	68fb      	ldr	r3, [r7, #12]
 8001432:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
 8001436:	687b      	ldr	r3, [r7, #4]
 8001438:	6a1b      	ldr	r3, [r3, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800143a:	429a      	cmp	r2, r3
 800143c:	d11a      	bne.n	8001474 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 800143e:	68fa      	ldr	r2, [r7, #12]
 8001440:	f647 73c0 	movw	r3, #32704	@ 0x7fc0
 8001444:	4013      	ands	r3, r2
 8001446:	687a      	ldr	r2, [r7, #4]
 8001448:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 800144a:	0192      	lsls	r2, r2, #6
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 800144c:	4293      	cmp	r3, r2
 800144e:	d111      	bne.n	8001474 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 8001450:	68fb      	ldr	r3, [r7, #12]
 8001452:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
 8001456:	687b      	ldr	r3, [r7, #4]
 8001458:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800145a:	085b      	lsrs	r3, r3, #1
 800145c:	3b01      	subs	r3, #1
 800145e:	041b      	lsls	r3, r3, #16
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 8001460:	429a      	cmp	r2, r3
 8001462:	d107      	bne.n	8001474 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 8001464:	68fb      	ldr	r3, [r7, #12]
 8001466:	f003 6270 	and.w	r2, r3, #251658240	@ 0xf000000
 800146a:	687b      	ldr	r3, [r7, #4]
 800146c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800146e:	061b      	lsls	r3, r3, #24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 8001470:	429a      	cmp	r2, r3
 8001472:	d001      	beq.n	8001478 <HAL_RCC_OscConfig+0x4e0>
#endif /* RCC_PLLCFGR_PLLR */
        {
          return HAL_ERROR;
 8001474:	2301      	movs	r3, #1
 8001476:	e000      	b.n	800147a <HAL_RCC_OscConfig+0x4e2>
        }
      }
    }
  }
  return HAL_OK;
 8001478:	2300      	movs	r3, #0
}
 800147a:	4618      	mov	r0, r3
 800147c:	3718      	adds	r7, #24
 800147e:	46bd      	mov	sp, r7
 8001480:	bd80      	pop	{r7, pc}
 8001482:	bf00      	nop
 8001484:	40023800 	.word	0x40023800

08001488 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8001488:	b580      	push	{r7, lr}
 800148a:	b084      	sub	sp, #16
 800148c:	af00      	add	r7, sp, #0
 800148e:	6078      	str	r0, [r7, #4]
 8001490:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 8001492:	687b      	ldr	r3, [r7, #4]
 8001494:	2b00      	cmp	r3, #0
 8001496:	d101      	bne.n	800149c <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8001498:	2301      	movs	r3, #1
 800149a:	e0cc      	b.n	8001636 <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800149c:	4b68      	ldr	r3, [pc, #416]	@ (8001640 <HAL_RCC_ClockConfig+0x1b8>)
 800149e:	681b      	ldr	r3, [r3, #0]
 80014a0:	f003 0307 	and.w	r3, r3, #7
 80014a4:	683a      	ldr	r2, [r7, #0]
 80014a6:	429a      	cmp	r2, r3
 80014a8:	d90c      	bls.n	80014c4 <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80014aa:	4b65      	ldr	r3, [pc, #404]	@ (8001640 <HAL_RCC_ClockConfig+0x1b8>)
 80014ac:	683a      	ldr	r2, [r7, #0]
 80014ae:	b2d2      	uxtb	r2, r2
 80014b0:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 80014b2:	4b63      	ldr	r3, [pc, #396]	@ (8001640 <HAL_RCC_ClockConfig+0x1b8>)
 80014b4:	681b      	ldr	r3, [r3, #0]
 80014b6:	f003 0307 	and.w	r3, r3, #7
 80014ba:	683a      	ldr	r2, [r7, #0]
 80014bc:	429a      	cmp	r2, r3
 80014be:	d001      	beq.n	80014c4 <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 80014c0:	2301      	movs	r3, #1
 80014c2:	e0b8      	b.n	8001636 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80014c4:	687b      	ldr	r3, [r7, #4]
 80014c6:	681b      	ldr	r3, [r3, #0]
 80014c8:	f003 0302 	and.w	r3, r3, #2
 80014cc:	2b00      	cmp	r3, #0
 80014ce:	d020      	beq.n	8001512 <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80014d0:	687b      	ldr	r3, [r7, #4]
 80014d2:	681b      	ldr	r3, [r3, #0]
 80014d4:	f003 0304 	and.w	r3, r3, #4
 80014d8:	2b00      	cmp	r3, #0
 80014da:	d005      	beq.n	80014e8 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80014dc:	4b59      	ldr	r3, [pc, #356]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 80014de:	689b      	ldr	r3, [r3, #8]
 80014e0:	4a58      	ldr	r2, [pc, #352]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 80014e2:	f443 53e0 	orr.w	r3, r3, #7168	@ 0x1c00
 80014e6:	6093      	str	r3, [r2, #8]
    }

    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80014e8:	687b      	ldr	r3, [r7, #4]
 80014ea:	681b      	ldr	r3, [r3, #0]
 80014ec:	f003 0308 	and.w	r3, r3, #8
 80014f0:	2b00      	cmp	r3, #0
 80014f2:	d005      	beq.n	8001500 <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80014f4:	4b53      	ldr	r3, [pc, #332]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 80014f6:	689b      	ldr	r3, [r3, #8]
 80014f8:	4a52      	ldr	r2, [pc, #328]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 80014fa:	f443 4360 	orr.w	r3, r3, #57344	@ 0xe000
 80014fe:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001500:	4b50      	ldr	r3, [pc, #320]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 8001502:	689b      	ldr	r3, [r3, #8]
 8001504:	f023 02f0 	bic.w	r2, r3, #240	@ 0xf0
 8001508:	687b      	ldr	r3, [r7, #4]
 800150a:	689b      	ldr	r3, [r3, #8]
 800150c:	494d      	ldr	r1, [pc, #308]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 800150e:	4313      	orrs	r3, r2
 8001510:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001512:	687b      	ldr	r3, [r7, #4]
 8001514:	681b      	ldr	r3, [r3, #0]
 8001516:	f003 0301 	and.w	r3, r3, #1
 800151a:	2b00      	cmp	r3, #0
 800151c:	d044      	beq.n	80015a8 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800151e:	687b      	ldr	r3, [r7, #4]
 8001520:	685b      	ldr	r3, [r3, #4]
 8001522:	2b01      	cmp	r3, #1
 8001524:	d107      	bne.n	8001536 <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001526:	4b47      	ldr	r3, [pc, #284]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 8001528:	681b      	ldr	r3, [r3, #0]
 800152a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800152e:	2b00      	cmp	r3, #0
 8001530:	d119      	bne.n	8001566 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8001532:	2301      	movs	r3, #1
 8001534:	e07f      	b.n	8001636 <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if ((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8001536:	687b      	ldr	r3, [r7, #4]
 8001538:	685b      	ldr	r3, [r3, #4]
 800153a:	2b02      	cmp	r3, #2
 800153c:	d003      	beq.n	8001546 <HAL_RCC_ClockConfig+0xbe>
             (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 800153e:	687b      	ldr	r3, [r7, #4]
 8001540:	685b      	ldr	r3, [r3, #4]
    else if ((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8001542:	2b03      	cmp	r3, #3
 8001544:	d107      	bne.n	8001556 <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001546:	4b3f      	ldr	r3, [pc, #252]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 8001548:	681b      	ldr	r3, [r3, #0]
 800154a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800154e:	2b00      	cmp	r3, #0
 8001550:	d109      	bne.n	8001566 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8001552:	2301      	movs	r3, #1
 8001554:	e06f      	b.n	8001636 <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001556:	4b3b      	ldr	r3, [pc, #236]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 8001558:	681b      	ldr	r3, [r3, #0]
 800155a:	f003 0302 	and.w	r3, r3, #2
 800155e:	2b00      	cmp	r3, #0
 8001560:	d101      	bne.n	8001566 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8001562:	2301      	movs	r3, #1
 8001564:	e067      	b.n	8001636 <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001566:	4b37      	ldr	r3, [pc, #220]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 8001568:	689b      	ldr	r3, [r3, #8]
 800156a:	f023 0203 	bic.w	r2, r3, #3
 800156e:	687b      	ldr	r3, [r7, #4]
 8001570:	685b      	ldr	r3, [r3, #4]
 8001572:	4934      	ldr	r1, [pc, #208]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 8001574:	4313      	orrs	r3, r2
 8001576:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8001578:	f7ff fa5a 	bl	8000a30 <HAL_GetTick>
 800157c:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800157e:	e00a      	b.n	8001596 <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001580:	f7ff fa56 	bl	8000a30 <HAL_GetTick>
 8001584:	4602      	mov	r2, r0
 8001586:	68fb      	ldr	r3, [r7, #12]
 8001588:	1ad3      	subs	r3, r2, r3
 800158a:	f241 3288 	movw	r2, #5000	@ 0x1388
 800158e:	4293      	cmp	r3, r2
 8001590:	d901      	bls.n	8001596 <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 8001592:	2303      	movs	r3, #3
 8001594:	e04f      	b.n	8001636 <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8001596:	4b2b      	ldr	r3, [pc, #172]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 8001598:	689b      	ldr	r3, [r3, #8]
 800159a:	f003 020c 	and.w	r2, r3, #12
 800159e:	687b      	ldr	r3, [r7, #4]
 80015a0:	685b      	ldr	r3, [r3, #4]
 80015a2:	009b      	lsls	r3, r3, #2
 80015a4:	429a      	cmp	r2, r3
 80015a6:	d1eb      	bne.n	8001580 <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 80015a8:	4b25      	ldr	r3, [pc, #148]	@ (8001640 <HAL_RCC_ClockConfig+0x1b8>)
 80015aa:	681b      	ldr	r3, [r3, #0]
 80015ac:	f003 0307 	and.w	r3, r3, #7
 80015b0:	683a      	ldr	r2, [r7, #0]
 80015b2:	429a      	cmp	r2, r3
 80015b4:	d20c      	bcs.n	80015d0 <HAL_RCC_ClockConfig+0x148>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80015b6:	4b22      	ldr	r3, [pc, #136]	@ (8001640 <HAL_RCC_ClockConfig+0x1b8>)
 80015b8:	683a      	ldr	r2, [r7, #0]
 80015ba:	b2d2      	uxtb	r2, r2
 80015bc:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 80015be:	4b20      	ldr	r3, [pc, #128]	@ (8001640 <HAL_RCC_ClockConfig+0x1b8>)
 80015c0:	681b      	ldr	r3, [r3, #0]
 80015c2:	f003 0307 	and.w	r3, r3, #7
 80015c6:	683a      	ldr	r2, [r7, #0]
 80015c8:	429a      	cmp	r2, r3
 80015ca:	d001      	beq.n	80015d0 <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 80015cc:	2301      	movs	r3, #1
 80015ce:	e032      	b.n	8001636 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80015d0:	687b      	ldr	r3, [r7, #4]
 80015d2:	681b      	ldr	r3, [r3, #0]
 80015d4:	f003 0304 	and.w	r3, r3, #4
 80015d8:	2b00      	cmp	r3, #0
 80015da:	d008      	beq.n	80015ee <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80015dc:	4b19      	ldr	r3, [pc, #100]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 80015de:	689b      	ldr	r3, [r3, #8]
 80015e0:	f423 52e0 	bic.w	r2, r3, #7168	@ 0x1c00
 80015e4:	687b      	ldr	r3, [r7, #4]
 80015e6:	68db      	ldr	r3, [r3, #12]
 80015e8:	4916      	ldr	r1, [pc, #88]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 80015ea:	4313      	orrs	r3, r2
 80015ec:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80015ee:	687b      	ldr	r3, [r7, #4]
 80015f0:	681b      	ldr	r3, [r3, #0]
 80015f2:	f003 0308 	and.w	r3, r3, #8
 80015f6:	2b00      	cmp	r3, #0
 80015f8:	d009      	beq.n	800160e <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80015fa:	4b12      	ldr	r3, [pc, #72]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 80015fc:	689b      	ldr	r3, [r3, #8]
 80015fe:	f423 4260 	bic.w	r2, r3, #57344	@ 0xe000
 8001602:	687b      	ldr	r3, [r7, #4]
 8001604:	691b      	ldr	r3, [r3, #16]
 8001606:	00db      	lsls	r3, r3, #3
 8001608:	490e      	ldr	r1, [pc, #56]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 800160a:	4313      	orrs	r3, r2
 800160c:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 800160e:	f000 f821 	bl	8001654 <HAL_RCC_GetSysClockFreq>
 8001612:	4602      	mov	r2, r0
 8001614:	4b0b      	ldr	r3, [pc, #44]	@ (8001644 <HAL_RCC_ClockConfig+0x1bc>)
 8001616:	689b      	ldr	r3, [r3, #8]
 8001618:	091b      	lsrs	r3, r3, #4
 800161a:	f003 030f 	and.w	r3, r3, #15
 800161e:	490a      	ldr	r1, [pc, #40]	@ (8001648 <HAL_RCC_ClockConfig+0x1c0>)
 8001620:	5ccb      	ldrb	r3, [r1, r3]
 8001622:	fa22 f303 	lsr.w	r3, r2, r3
 8001626:	4a09      	ldr	r2, [pc, #36]	@ (800164c <HAL_RCC_ClockConfig+0x1c4>)
 8001628:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick(uwTickPrio);
 800162a:	4b09      	ldr	r3, [pc, #36]	@ (8001650 <HAL_RCC_ClockConfig+0x1c8>)
 800162c:	681b      	ldr	r3, [r3, #0]
 800162e:	4618      	mov	r0, r3
 8001630:	f7ff f9ba 	bl	80009a8 <HAL_InitTick>

  return HAL_OK;
 8001634:	2300      	movs	r3, #0
}
 8001636:	4618      	mov	r0, r3
 8001638:	3710      	adds	r7, #16
 800163a:	46bd      	mov	sp, r7
 800163c:	bd80      	pop	{r7, pc}
 800163e:	bf00      	nop
 8001640:	40023c00 	.word	0x40023c00
 8001644:	40023800 	.word	0x40023800
 8001648:	08027bbc 	.word	0x08027bbc
 800164c:	20000000 	.word	0x20000000
 8001650:	20000004 	.word	0x20000004

08001654 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8001654:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8001658:	b090      	sub	sp, #64	@ 0x40
 800165a:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U;
 800165c:	2300      	movs	r3, #0
 800165e:	637b      	str	r3, [r7, #52]	@ 0x34
  uint32_t pllvco = 0U;
 8001660:	2300      	movs	r3, #0
 8001662:	63fb      	str	r3, [r7, #60]	@ 0x3c
  uint32_t pllp = 0U;
 8001664:	2300      	movs	r3, #0
 8001666:	633b      	str	r3, [r7, #48]	@ 0x30
  uint32_t sysclockfreq = 0U;
 8001668:	2300      	movs	r3, #0
 800166a:	63bb      	str	r3, [r7, #56]	@ 0x38

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800166c:	4b59      	ldr	r3, [pc, #356]	@ (80017d4 <HAL_RCC_GetSysClockFreq+0x180>)
 800166e:	689b      	ldr	r3, [r3, #8]
 8001670:	f003 030c 	and.w	r3, r3, #12
 8001674:	2b08      	cmp	r3, #8
 8001676:	d00d      	beq.n	8001694 <HAL_RCC_GetSysClockFreq+0x40>
 8001678:	2b08      	cmp	r3, #8
 800167a:	f200 80a1 	bhi.w	80017c0 <HAL_RCC_GetSysClockFreq+0x16c>
 800167e:	2b00      	cmp	r3, #0
 8001680:	d002      	beq.n	8001688 <HAL_RCC_GetSysClockFreq+0x34>
 8001682:	2b04      	cmp	r3, #4
 8001684:	d003      	beq.n	800168e <HAL_RCC_GetSysClockFreq+0x3a>
 8001686:	e09b      	b.n	80017c0 <HAL_RCC_GetSysClockFreq+0x16c>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8001688:	4b53      	ldr	r3, [pc, #332]	@ (80017d8 <HAL_RCC_GetSysClockFreq+0x184>)
 800168a:	63bb      	str	r3, [r7, #56]	@ 0x38
      break;
 800168c:	e09b      	b.n	80017c6 <HAL_RCC_GetSysClockFreq+0x172>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 800168e:	4b53      	ldr	r3, [pc, #332]	@ (80017dc <HAL_RCC_GetSysClockFreq+0x188>)
 8001690:	63bb      	str	r3, [r7, #56]	@ 0x38
      break;
 8001692:	e098      	b.n	80017c6 <HAL_RCC_GetSysClockFreq+0x172>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001694:	4b4f      	ldr	r3, [pc, #316]	@ (80017d4 <HAL_RCC_GetSysClockFreq+0x180>)
 8001696:	685b      	ldr	r3, [r3, #4]
 8001698:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800169c:	637b      	str	r3, [r7, #52]	@ 0x34
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800169e:	4b4d      	ldr	r3, [pc, #308]	@ (80017d4 <HAL_RCC_GetSysClockFreq+0x180>)
 80016a0:	685b      	ldr	r3, [r3, #4]
 80016a2:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 80016a6:	2b00      	cmp	r3, #0
 80016a8:	d028      	beq.n	80016fc <HAL_RCC_GetSysClockFreq+0xa8>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80016aa:	4b4a      	ldr	r3, [pc, #296]	@ (80017d4 <HAL_RCC_GetSysClockFreq+0x180>)
 80016ac:	685b      	ldr	r3, [r3, #4]
 80016ae:	099b      	lsrs	r3, r3, #6
 80016b0:	2200      	movs	r2, #0
 80016b2:	623b      	str	r3, [r7, #32]
 80016b4:	627a      	str	r2, [r7, #36]	@ 0x24
 80016b6:	6a3b      	ldr	r3, [r7, #32]
 80016b8:	f3c3 0008 	ubfx	r0, r3, #0, #9
 80016bc:	2100      	movs	r1, #0
 80016be:	4b47      	ldr	r3, [pc, #284]	@ (80017dc <HAL_RCC_GetSysClockFreq+0x188>)
 80016c0:	fb03 f201 	mul.w	r2, r3, r1
 80016c4:	2300      	movs	r3, #0
 80016c6:	fb00 f303 	mul.w	r3, r0, r3
 80016ca:	4413      	add	r3, r2
 80016cc:	4a43      	ldr	r2, [pc, #268]	@ (80017dc <HAL_RCC_GetSysClockFreq+0x188>)
 80016ce:	fba0 1202 	umull	r1, r2, r0, r2
 80016d2:	62fa      	str	r2, [r7, #44]	@ 0x2c
 80016d4:	460a      	mov	r2, r1
 80016d6:	62ba      	str	r2, [r7, #40]	@ 0x28
 80016d8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80016da:	4413      	add	r3, r2
 80016dc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80016de:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80016e0:	2200      	movs	r2, #0
 80016e2:	61bb      	str	r3, [r7, #24]
 80016e4:	61fa      	str	r2, [r7, #28]
 80016e6:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 80016ea:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 80016ee:	f7fe fdc3 	bl	8000278 <__aeabi_uldivmod>
 80016f2:	4602      	mov	r2, r0
 80016f4:	460b      	mov	r3, r1
 80016f6:	4613      	mov	r3, r2
 80016f8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80016fa:	e053      	b.n	80017a4 <HAL_RCC_GetSysClockFreq+0x150>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 80016fc:	4b35      	ldr	r3, [pc, #212]	@ (80017d4 <HAL_RCC_GetSysClockFreq+0x180>)
 80016fe:	685b      	ldr	r3, [r3, #4]
 8001700:	099b      	lsrs	r3, r3, #6
 8001702:	2200      	movs	r2, #0
 8001704:	613b      	str	r3, [r7, #16]
 8001706:	617a      	str	r2, [r7, #20]
 8001708:	693b      	ldr	r3, [r7, #16]
 800170a:	f3c3 0a08 	ubfx	sl, r3, #0, #9
 800170e:	f04f 0b00 	mov.w	fp, #0
 8001712:	4652      	mov	r2, sl
 8001714:	465b      	mov	r3, fp
 8001716:	f04f 0000 	mov.w	r0, #0
 800171a:	f04f 0100 	mov.w	r1, #0
 800171e:	0159      	lsls	r1, r3, #5
 8001720:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 8001724:	0150      	lsls	r0, r2, #5
 8001726:	4602      	mov	r2, r0
 8001728:	460b      	mov	r3, r1
 800172a:	ebb2 080a 	subs.w	r8, r2, sl
 800172e:	eb63 090b 	sbc.w	r9, r3, fp
 8001732:	f04f 0200 	mov.w	r2, #0
 8001736:	f04f 0300 	mov.w	r3, #0
 800173a:	ea4f 1389 	mov.w	r3, r9, lsl #6
 800173e:	ea43 6398 	orr.w	r3, r3, r8, lsr #26
 8001742:	ea4f 1288 	mov.w	r2, r8, lsl #6
 8001746:	ebb2 0408 	subs.w	r4, r2, r8
 800174a:	eb63 0509 	sbc.w	r5, r3, r9
 800174e:	f04f 0200 	mov.w	r2, #0
 8001752:	f04f 0300 	mov.w	r3, #0
 8001756:	00eb      	lsls	r3, r5, #3
 8001758:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 800175c:	00e2      	lsls	r2, r4, #3
 800175e:	4614      	mov	r4, r2
 8001760:	461d      	mov	r5, r3
 8001762:	eb14 030a 	adds.w	r3, r4, sl
 8001766:	603b      	str	r3, [r7, #0]
 8001768:	eb45 030b 	adc.w	r3, r5, fp
 800176c:	607b      	str	r3, [r7, #4]
 800176e:	f04f 0200 	mov.w	r2, #0
 8001772:	f04f 0300 	mov.w	r3, #0
 8001776:	e9d7 4500 	ldrd	r4, r5, [r7]
 800177a:	4629      	mov	r1, r5
 800177c:	028b      	lsls	r3, r1, #10
 800177e:	4621      	mov	r1, r4
 8001780:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
 8001784:	4621      	mov	r1, r4
 8001786:	028a      	lsls	r2, r1, #10
 8001788:	4610      	mov	r0, r2
 800178a:	4619      	mov	r1, r3
 800178c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800178e:	2200      	movs	r2, #0
 8001790:	60bb      	str	r3, [r7, #8]
 8001792:	60fa      	str	r2, [r7, #12]
 8001794:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8001798:	f7fe fd6e 	bl	8000278 <__aeabi_uldivmod>
 800179c:	4602      	mov	r2, r0
 800179e:	460b      	mov	r3, r1
 80017a0:	4613      	mov	r3, r2
 80017a2:	63fb      	str	r3, [r7, #60]	@ 0x3c
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) * 2U);
 80017a4:	4b0b      	ldr	r3, [pc, #44]	@ (80017d4 <HAL_RCC_GetSysClockFreq+0x180>)
 80017a6:	685b      	ldr	r3, [r3, #4]
 80017a8:	0c1b      	lsrs	r3, r3, #16
 80017aa:	f003 0303 	and.w	r3, r3, #3
 80017ae:	3301      	adds	r3, #1
 80017b0:	005b      	lsls	r3, r3, #1
 80017b2:	633b      	str	r3, [r7, #48]	@ 0x30

      sysclockfreq = pllvco / pllp;
 80017b4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80017b6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80017b8:	fbb2 f3f3 	udiv	r3, r2, r3
 80017bc:	63bb      	str	r3, [r7, #56]	@ 0x38
      break;
 80017be:	e002      	b.n	80017c6 <HAL_RCC_GetSysClockFreq+0x172>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 80017c0:	4b05      	ldr	r3, [pc, #20]	@ (80017d8 <HAL_RCC_GetSysClockFreq+0x184>)
 80017c2:	63bb      	str	r3, [r7, #56]	@ 0x38
      break;
 80017c4:	bf00      	nop
    }
  }
  return sysclockfreq;
 80017c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
}
 80017c8:	4618      	mov	r0, r3
 80017ca:	3740      	adds	r7, #64	@ 0x40
 80017cc:	46bd      	mov	sp, r7
 80017ce:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80017d2:	bf00      	nop
 80017d4:	40023800 	.word	0x40023800
 80017d8:	00f42400 	.word	0x00f42400
 80017dc:	017d7840 	.word	0x017d7840

080017e0 <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 80017e0:	b580      	push	{r7, lr}
 80017e2:	b082      	sub	sp, #8
 80017e4:	af00      	add	r7, sp, #0
 80017e6:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 80017e8:	687b      	ldr	r3, [r7, #4]
 80017ea:	2b00      	cmp	r3, #0
 80017ec:	d101      	bne.n	80017f2 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 80017ee:	2301      	movs	r3, #1
 80017f0:	e07b      	b.n	80018ea <HAL_SPI_Init+0x10a>
  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 80017f2:	687b      	ldr	r3, [r7, #4]
 80017f4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80017f6:	2b00      	cmp	r3, #0
 80017f8:	d108      	bne.n	800180c <HAL_SPI_Init+0x2c>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 80017fa:	687b      	ldr	r3, [r7, #4]
 80017fc:	685b      	ldr	r3, [r3, #4]
 80017fe:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8001802:	d009      	beq.n	8001818 <HAL_SPI_Init+0x38>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8001804:	687b      	ldr	r3, [r7, #4]
 8001806:	2200      	movs	r2, #0
 8001808:	61da      	str	r2, [r3, #28]
 800180a:	e005      	b.n	8001818 <HAL_SPI_Init+0x38>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 800180c:	687b      	ldr	r3, [r7, #4]
 800180e:	2200      	movs	r2, #0
 8001810:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 8001812:	687b      	ldr	r3, [r7, #4]
 8001814:	2200      	movs	r2, #0
 8001816:	615a      	str	r2, [r3, #20]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001818:	687b      	ldr	r3, [r7, #4]
 800181a:	2200      	movs	r2, #0
 800181c:	629a      	str	r2, [r3, #40]	@ 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800181e:	687b      	ldr	r3, [r7, #4]
 8001820:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 8001824:	b2db      	uxtb	r3, r3
 8001826:	2b00      	cmp	r3, #0
 8001828:	d106      	bne.n	8001838 <HAL_SPI_Init+0x58>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 800182a:	687b      	ldr	r3, [r7, #4]
 800182c:	2200      	movs	r2, #0
 800182e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8001832:	6878      	ldr	r0, [r7, #4]
 8001834:	f7fe ffba 	bl	80007ac <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8001838:	687b      	ldr	r3, [r7, #4]
 800183a:	2202      	movs	r2, #2
 800183c:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8001840:	687b      	ldr	r3, [r7, #4]
 8001842:	681b      	ldr	r3, [r3, #0]
 8001844:	681a      	ldr	r2, [r3, #0]
 8001846:	687b      	ldr	r3, [r7, #4]
 8001848:	681b      	ldr	r3, [r3, #0]
 800184a:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 800184e:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8001850:	687b      	ldr	r3, [r7, #4]
 8001852:	685b      	ldr	r3, [r3, #4]
 8001854:	f403 7282 	and.w	r2, r3, #260	@ 0x104
 8001858:	687b      	ldr	r3, [r7, #4]
 800185a:	689b      	ldr	r3, [r3, #8]
 800185c:	f403 4304 	and.w	r3, r3, #33792	@ 0x8400
 8001860:	431a      	orrs	r2, r3
 8001862:	687b      	ldr	r3, [r7, #4]
 8001864:	68db      	ldr	r3, [r3, #12]
 8001866:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800186a:	431a      	orrs	r2, r3
 800186c:	687b      	ldr	r3, [r7, #4]
 800186e:	691b      	ldr	r3, [r3, #16]
 8001870:	f003 0302 	and.w	r3, r3, #2
 8001874:	431a      	orrs	r2, r3
 8001876:	687b      	ldr	r3, [r7, #4]
 8001878:	695b      	ldr	r3, [r3, #20]
 800187a:	f003 0301 	and.w	r3, r3, #1
 800187e:	431a      	orrs	r2, r3
 8001880:	687b      	ldr	r3, [r7, #4]
 8001882:	699b      	ldr	r3, [r3, #24]
 8001884:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8001888:	431a      	orrs	r2, r3
 800188a:	687b      	ldr	r3, [r7, #4]
 800188c:	69db      	ldr	r3, [r3, #28]
 800188e:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8001892:	431a      	orrs	r2, r3
 8001894:	687b      	ldr	r3, [r7, #4]
 8001896:	6a1b      	ldr	r3, [r3, #32]
 8001898:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800189c:	ea42 0103 	orr.w	r1, r2, r3
 80018a0:	687b      	ldr	r3, [r7, #4]
 80018a2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80018a4:	f403 5200 	and.w	r2, r3, #8192	@ 0x2000
 80018a8:	687b      	ldr	r3, [r7, #4]
 80018aa:	681b      	ldr	r3, [r3, #0]
 80018ac:	430a      	orrs	r2, r1
 80018ae:	601a      	str	r2, [r3, #0]
                                  (hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
                                  (hspi->Init.FirstBit  & SPI_CR1_LSBFIRST) |
                                  (hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));

  /* Configure : NSS management, TI Mode */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 80018b0:	687b      	ldr	r3, [r7, #4]
 80018b2:	699b      	ldr	r3, [r3, #24]
 80018b4:	0c1b      	lsrs	r3, r3, #16
 80018b6:	f003 0104 	and.w	r1, r3, #4
 80018ba:	687b      	ldr	r3, [r7, #4]
 80018bc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80018be:	f003 0210 	and.w	r2, r3, #16
 80018c2:	687b      	ldr	r3, [r7, #4]
 80018c4:	681b      	ldr	r3, [r3, #0]
 80018c6:	430a      	orrs	r2, r1
 80018c8:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80018ca:	687b      	ldr	r3, [r7, #4]
 80018cc:	681b      	ldr	r3, [r3, #0]
 80018ce:	69da      	ldr	r2, [r3, #28]
 80018d0:	687b      	ldr	r3, [r7, #4]
 80018d2:	681b      	ldr	r3, [r3, #0]
 80018d4:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 80018d8:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80018da:	687b      	ldr	r3, [r7, #4]
 80018dc:	2200      	movs	r2, #0
 80018de:	655a      	str	r2, [r3, #84]	@ 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 80018e0:	687b      	ldr	r3, [r7, #4]
 80018e2:	2201      	movs	r2, #1
 80018e4:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

  return HAL_OK;
 80018e8:	2300      	movs	r3, #0
}
 80018ea:	4618      	mov	r0, r3
 80018ec:	3708      	adds	r7, #8
 80018ee:	46bd      	mov	sp, r7
 80018f0:	bd80      	pop	{r7, pc}

080018f2 <HAL_SPI_Transmit>:
  * @param  Size amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80018f2:	b580      	push	{r7, lr}
 80018f4:	b088      	sub	sp, #32
 80018f6:	af00      	add	r7, sp, #0
 80018f8:	60f8      	str	r0, [r7, #12]
 80018fa:	60b9      	str	r1, [r7, #8]
 80018fc:	603b      	str	r3, [r7, #0]
 80018fe:	4613      	mov	r3, r2
 8001900:	80fb      	strh	r3, [r7, #6]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8001902:	f7ff f895 	bl	8000a30 <HAL_GetTick>
 8001906:	61f8      	str	r0, [r7, #28]
  initial_TxXferCount = Size;
 8001908:	88fb      	ldrh	r3, [r7, #6]
 800190a:	837b      	strh	r3, [r7, #26]

  if (hspi->State != HAL_SPI_STATE_READY)
 800190c:	68fb      	ldr	r3, [r7, #12]
 800190e:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 8001912:	b2db      	uxtb	r3, r3
 8001914:	2b01      	cmp	r3, #1
 8001916:	d001      	beq.n	800191c <HAL_SPI_Transmit+0x2a>
  {
    return HAL_BUSY;
 8001918:	2302      	movs	r3, #2
 800191a:	e12a      	b.n	8001b72 <HAL_SPI_Transmit+0x280>
  }

  if ((pData == NULL) || (Size == 0U))
 800191c:	68bb      	ldr	r3, [r7, #8]
 800191e:	2b00      	cmp	r3, #0
 8001920:	d002      	beq.n	8001928 <HAL_SPI_Transmit+0x36>
 8001922:	88fb      	ldrh	r3, [r7, #6]
 8001924:	2b00      	cmp	r3, #0
 8001926:	d101      	bne.n	800192c <HAL_SPI_Transmit+0x3a>
  {
    return HAL_ERROR;
 8001928:	2301      	movs	r3, #1
 800192a:	e122      	b.n	8001b72 <HAL_SPI_Transmit+0x280>
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 800192c:	68fb      	ldr	r3, [r7, #12]
 800192e:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 8001932:	2b01      	cmp	r3, #1
 8001934:	d101      	bne.n	800193a <HAL_SPI_Transmit+0x48>
 8001936:	2302      	movs	r3, #2
 8001938:	e11b      	b.n	8001b72 <HAL_SPI_Transmit+0x280>
 800193a:	68fb      	ldr	r3, [r7, #12]
 800193c:	2201      	movs	r2, #1
 800193e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8001942:	68fb      	ldr	r3, [r7, #12]
 8001944:	2203      	movs	r2, #3
 8001946:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 800194a:	68fb      	ldr	r3, [r7, #12]
 800194c:	2200      	movs	r2, #0
 800194e:	655a      	str	r2, [r3, #84]	@ 0x54
  hspi->pTxBuffPtr  = (const uint8_t *)pData;
 8001950:	68fb      	ldr	r3, [r7, #12]
 8001952:	68ba      	ldr	r2, [r7, #8]
 8001954:	631a      	str	r2, [r3, #48]	@ 0x30
  hspi->TxXferSize  = Size;
 8001956:	68fb      	ldr	r3, [r7, #12]
 8001958:	88fa      	ldrh	r2, [r7, #6]
 800195a:	869a      	strh	r2, [r3, #52]	@ 0x34
  hspi->TxXferCount = Size;
 800195c:	68fb      	ldr	r3, [r7, #12]
 800195e:	88fa      	ldrh	r2, [r7, #6]
 8001960:	86da      	strh	r2, [r3, #54]	@ 0x36

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8001962:	68fb      	ldr	r3, [r7, #12]
 8001964:	2200      	movs	r2, #0
 8001966:	639a      	str	r2, [r3, #56]	@ 0x38
  hspi->RxXferSize  = 0U;
 8001968:	68fb      	ldr	r3, [r7, #12]
 800196a:	2200      	movs	r2, #0
 800196c:	879a      	strh	r2, [r3, #60]	@ 0x3c
  hspi->RxXferCount = 0U;
 800196e:	68fb      	ldr	r3, [r7, #12]
 8001970:	2200      	movs	r2, #0
 8001972:	87da      	strh	r2, [r3, #62]	@ 0x3e
  hspi->TxISR       = NULL;
 8001974:	68fb      	ldr	r3, [r7, #12]
 8001976:	2200      	movs	r2, #0
 8001978:	645a      	str	r2, [r3, #68]	@ 0x44
  hspi->RxISR       = NULL;
 800197a:	68fb      	ldr	r3, [r7, #12]
 800197c:	2200      	movs	r2, #0
 800197e:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001980:	68fb      	ldr	r3, [r7, #12]
 8001982:	689b      	ldr	r3, [r3, #8]
 8001984:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8001988:	d10f      	bne.n	80019aa <HAL_SPI_Transmit+0xb8>
  {
    /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
    __HAL_SPI_DISABLE(hspi);
 800198a:	68fb      	ldr	r3, [r7, #12]
 800198c:	681b      	ldr	r3, [r3, #0]
 800198e:	681a      	ldr	r2, [r3, #0]
 8001990:	68fb      	ldr	r3, [r7, #12]
 8001992:	681b      	ldr	r3, [r3, #0]
 8001994:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8001998:	601a      	str	r2, [r3, #0]
    SPI_1LINE_TX(hspi);
 800199a:	68fb      	ldr	r3, [r7, #12]
 800199c:	681b      	ldr	r3, [r3, #0]
 800199e:	681a      	ldr	r2, [r3, #0]
 80019a0:	68fb      	ldr	r3, [r7, #12]
 80019a2:	681b      	ldr	r3, [r3, #0]
 80019a4:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 80019a8:	601a      	str	r2, [r3, #0]
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80019aa:	68fb      	ldr	r3, [r7, #12]
 80019ac:	681b      	ldr	r3, [r3, #0]
 80019ae:	681b      	ldr	r3, [r3, #0]
 80019b0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80019b4:	2b40      	cmp	r3, #64	@ 0x40
 80019b6:	d007      	beq.n	80019c8 <HAL_SPI_Transmit+0xd6>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80019b8:	68fb      	ldr	r3, [r7, #12]
 80019ba:	681b      	ldr	r3, [r3, #0]
 80019bc:	681a      	ldr	r2, [r3, #0]
 80019be:	68fb      	ldr	r3, [r7, #12]
 80019c0:	681b      	ldr	r3, [r3, #0]
 80019c2:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80019c6:	601a      	str	r2, [r3, #0]
  }

  /* Transmit data in 16 Bit mode */
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 80019c8:	68fb      	ldr	r3, [r7, #12]
 80019ca:	68db      	ldr	r3, [r3, #12]
 80019cc:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 80019d0:	d152      	bne.n	8001a78 <HAL_SPI_Transmit+0x186>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80019d2:	68fb      	ldr	r3, [r7, #12]
 80019d4:	685b      	ldr	r3, [r3, #4]
 80019d6:	2b00      	cmp	r3, #0
 80019d8:	d002      	beq.n	80019e0 <HAL_SPI_Transmit+0xee>
 80019da:	8b7b      	ldrh	r3, [r7, #26]
 80019dc:	2b01      	cmp	r3, #1
 80019de:	d145      	bne.n	8001a6c <HAL_SPI_Transmit+0x17a>
    {
      hspi->Instance->DR = *((const uint16_t *)hspi->pTxBuffPtr);
 80019e0:	68fb      	ldr	r3, [r7, #12]
 80019e2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019e4:	881a      	ldrh	r2, [r3, #0]
 80019e6:	68fb      	ldr	r3, [r7, #12]
 80019e8:	681b      	ldr	r3, [r3, #0]
 80019ea:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 80019ec:	68fb      	ldr	r3, [r7, #12]
 80019ee:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80019f0:	1c9a      	adds	r2, r3, #2
 80019f2:	68fb      	ldr	r3, [r7, #12]
 80019f4:	631a      	str	r2, [r3, #48]	@ 0x30
      hspi->TxXferCount--;
 80019f6:	68fb      	ldr	r3, [r7, #12]
 80019f8:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 80019fa:	b29b      	uxth	r3, r3
 80019fc:	3b01      	subs	r3, #1
 80019fe:	b29a      	uxth	r2, r3
 8001a00:	68fb      	ldr	r3, [r7, #12]
 8001a02:	86da      	strh	r2, [r3, #54]	@ 0x36
    }
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0U)
 8001a04:	e032      	b.n	8001a6c <HAL_SPI_Transmit+0x17a>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8001a06:	68fb      	ldr	r3, [r7, #12]
 8001a08:	681b      	ldr	r3, [r3, #0]
 8001a0a:	689b      	ldr	r3, [r3, #8]
 8001a0c:	f003 0302 	and.w	r3, r3, #2
 8001a10:	2b02      	cmp	r3, #2
 8001a12:	d112      	bne.n	8001a3a <HAL_SPI_Transmit+0x148>
      {
        hspi->Instance->DR = *((const uint16_t *)hspi->pTxBuffPtr);
 8001a14:	68fb      	ldr	r3, [r7, #12]
 8001a16:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a18:	881a      	ldrh	r2, [r3, #0]
 8001a1a:	68fb      	ldr	r3, [r7, #12]
 8001a1c:	681b      	ldr	r3, [r3, #0]
 8001a1e:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8001a20:	68fb      	ldr	r3, [r7, #12]
 8001a22:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a24:	1c9a      	adds	r2, r3, #2
 8001a26:	68fb      	ldr	r3, [r7, #12]
 8001a28:	631a      	str	r2, [r3, #48]	@ 0x30
        hspi->TxXferCount--;
 8001a2a:	68fb      	ldr	r3, [r7, #12]
 8001a2c:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8001a2e:	b29b      	uxth	r3, r3
 8001a30:	3b01      	subs	r3, #1
 8001a32:	b29a      	uxth	r2, r3
 8001a34:	68fb      	ldr	r3, [r7, #12]
 8001a36:	86da      	strh	r2, [r3, #54]	@ 0x36
 8001a38:	e018      	b.n	8001a6c <HAL_SPI_Transmit+0x17a>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8001a3a:	f7fe fff9 	bl	8000a30 <HAL_GetTick>
 8001a3e:	4602      	mov	r2, r0
 8001a40:	69fb      	ldr	r3, [r7, #28]
 8001a42:	1ad3      	subs	r3, r2, r3
 8001a44:	683a      	ldr	r2, [r7, #0]
 8001a46:	429a      	cmp	r2, r3
 8001a48:	d803      	bhi.n	8001a52 <HAL_SPI_Transmit+0x160>
 8001a4a:	683b      	ldr	r3, [r7, #0]
 8001a4c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001a50:	d102      	bne.n	8001a58 <HAL_SPI_Transmit+0x166>
 8001a52:	683b      	ldr	r3, [r7, #0]
 8001a54:	2b00      	cmp	r3, #0
 8001a56:	d109      	bne.n	8001a6c <HAL_SPI_Transmit+0x17a>
        {
          hspi->State = HAL_SPI_STATE_READY;
 8001a58:	68fb      	ldr	r3, [r7, #12]
 8001a5a:	2201      	movs	r2, #1
 8001a5c:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
          __HAL_UNLOCK(hspi);
 8001a60:	68fb      	ldr	r3, [r7, #12]
 8001a62:	2200      	movs	r2, #0
 8001a64:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
          return HAL_TIMEOUT;
 8001a68:	2303      	movs	r3, #3
 8001a6a:	e082      	b.n	8001b72 <HAL_SPI_Transmit+0x280>
    while (hspi->TxXferCount > 0U)
 8001a6c:	68fb      	ldr	r3, [r7, #12]
 8001a6e:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8001a70:	b29b      	uxth	r3, r3
 8001a72:	2b00      	cmp	r3, #0
 8001a74:	d1c7      	bne.n	8001a06 <HAL_SPI_Transmit+0x114>
 8001a76:	e053      	b.n	8001b20 <HAL_SPI_Transmit+0x22e>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8001a78:	68fb      	ldr	r3, [r7, #12]
 8001a7a:	685b      	ldr	r3, [r3, #4]
 8001a7c:	2b00      	cmp	r3, #0
 8001a7e:	d002      	beq.n	8001a86 <HAL_SPI_Transmit+0x194>
 8001a80:	8b7b      	ldrh	r3, [r7, #26]
 8001a82:	2b01      	cmp	r3, #1
 8001a84:	d147      	bne.n	8001b16 <HAL_SPI_Transmit+0x224>
    {
      *((__IO uint8_t *)&hspi->Instance->DR) = *((const uint8_t *)hspi->pTxBuffPtr);
 8001a86:	68fb      	ldr	r3, [r7, #12]
 8001a88:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8001a8a:	68fb      	ldr	r3, [r7, #12]
 8001a8c:	681b      	ldr	r3, [r3, #0]
 8001a8e:	330c      	adds	r3, #12
 8001a90:	7812      	ldrb	r2, [r2, #0]
 8001a92:	701a      	strb	r2, [r3, #0]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8001a94:	68fb      	ldr	r3, [r7, #12]
 8001a96:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001a98:	1c5a      	adds	r2, r3, #1
 8001a9a:	68fb      	ldr	r3, [r7, #12]
 8001a9c:	631a      	str	r2, [r3, #48]	@ 0x30
      hspi->TxXferCount--;
 8001a9e:	68fb      	ldr	r3, [r7, #12]
 8001aa0:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8001aa2:	b29b      	uxth	r3, r3
 8001aa4:	3b01      	subs	r3, #1
 8001aa6:	b29a      	uxth	r2, r3
 8001aa8:	68fb      	ldr	r3, [r7, #12]
 8001aaa:	86da      	strh	r2, [r3, #54]	@ 0x36
    }
    while (hspi->TxXferCount > 0U)
 8001aac:	e033      	b.n	8001b16 <HAL_SPI_Transmit+0x224>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8001aae:	68fb      	ldr	r3, [r7, #12]
 8001ab0:	681b      	ldr	r3, [r3, #0]
 8001ab2:	689b      	ldr	r3, [r3, #8]
 8001ab4:	f003 0302 	and.w	r3, r3, #2
 8001ab8:	2b02      	cmp	r3, #2
 8001aba:	d113      	bne.n	8001ae4 <HAL_SPI_Transmit+0x1f2>
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = *((const uint8_t *)hspi->pTxBuffPtr);
 8001abc:	68fb      	ldr	r3, [r7, #12]
 8001abe:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8001ac0:	68fb      	ldr	r3, [r7, #12]
 8001ac2:	681b      	ldr	r3, [r3, #0]
 8001ac4:	330c      	adds	r3, #12
 8001ac6:	7812      	ldrb	r2, [r2, #0]
 8001ac8:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8001aca:	68fb      	ldr	r3, [r7, #12]
 8001acc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001ace:	1c5a      	adds	r2, r3, #1
 8001ad0:	68fb      	ldr	r3, [r7, #12]
 8001ad2:	631a      	str	r2, [r3, #48]	@ 0x30
        hspi->TxXferCount--;
 8001ad4:	68fb      	ldr	r3, [r7, #12]
 8001ad6:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8001ad8:	b29b      	uxth	r3, r3
 8001ada:	3b01      	subs	r3, #1
 8001adc:	b29a      	uxth	r2, r3
 8001ade:	68fb      	ldr	r3, [r7, #12]
 8001ae0:	86da      	strh	r2, [r3, #54]	@ 0x36
 8001ae2:	e018      	b.n	8001b16 <HAL_SPI_Transmit+0x224>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8001ae4:	f7fe ffa4 	bl	8000a30 <HAL_GetTick>
 8001ae8:	4602      	mov	r2, r0
 8001aea:	69fb      	ldr	r3, [r7, #28]
 8001aec:	1ad3      	subs	r3, r2, r3
 8001aee:	683a      	ldr	r2, [r7, #0]
 8001af0:	429a      	cmp	r2, r3
 8001af2:	d803      	bhi.n	8001afc <HAL_SPI_Transmit+0x20a>
 8001af4:	683b      	ldr	r3, [r7, #0]
 8001af6:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001afa:	d102      	bne.n	8001b02 <HAL_SPI_Transmit+0x210>
 8001afc:	683b      	ldr	r3, [r7, #0]
 8001afe:	2b00      	cmp	r3, #0
 8001b00:	d109      	bne.n	8001b16 <HAL_SPI_Transmit+0x224>
        {
          hspi->State = HAL_SPI_STATE_READY;
 8001b02:	68fb      	ldr	r3, [r7, #12]
 8001b04:	2201      	movs	r2, #1
 8001b06:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
          __HAL_UNLOCK(hspi);
 8001b0a:	68fb      	ldr	r3, [r7, #12]
 8001b0c:	2200      	movs	r2, #0
 8001b0e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
          return HAL_TIMEOUT;
 8001b12:	2303      	movs	r3, #3
 8001b14:	e02d      	b.n	8001b72 <HAL_SPI_Transmit+0x280>
    while (hspi->TxXferCount > 0U)
 8001b16:	68fb      	ldr	r3, [r7, #12]
 8001b18:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8001b1a:	b29b      	uxth	r3, r3
 8001b1c:	2b00      	cmp	r3, #0
 8001b1e:	d1c6      	bne.n	8001aae <HAL_SPI_Transmit+0x1bc>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8001b20:	69fa      	ldr	r2, [r7, #28]
 8001b22:	6839      	ldr	r1, [r7, #0]
 8001b24:	68f8      	ldr	r0, [r7, #12]
 8001b26:	f000 f8b1 	bl	8001c8c <SPI_EndRxTxTransaction>
 8001b2a:	4603      	mov	r3, r0
 8001b2c:	2b00      	cmp	r3, #0
 8001b2e:	d002      	beq.n	8001b36 <HAL_SPI_Transmit+0x244>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8001b30:	68fb      	ldr	r3, [r7, #12]
 8001b32:	2220      	movs	r2, #32
 8001b34:	655a      	str	r2, [r3, #84]	@ 0x54
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8001b36:	68fb      	ldr	r3, [r7, #12]
 8001b38:	689b      	ldr	r3, [r3, #8]
 8001b3a:	2b00      	cmp	r3, #0
 8001b3c:	d10a      	bne.n	8001b54 <HAL_SPI_Transmit+0x262>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8001b3e:	2300      	movs	r3, #0
 8001b40:	617b      	str	r3, [r7, #20]
 8001b42:	68fb      	ldr	r3, [r7, #12]
 8001b44:	681b      	ldr	r3, [r3, #0]
 8001b46:	68db      	ldr	r3, [r3, #12]
 8001b48:	617b      	str	r3, [r7, #20]
 8001b4a:	68fb      	ldr	r3, [r7, #12]
 8001b4c:	681b      	ldr	r3, [r3, #0]
 8001b4e:	689b      	ldr	r3, [r3, #8]
 8001b50:	617b      	str	r3, [r7, #20]
 8001b52:	697b      	ldr	r3, [r7, #20]
  }

  hspi->State = HAL_SPI_STATE_READY;
 8001b54:	68fb      	ldr	r3, [r7, #12]
 8001b56:	2201      	movs	r2, #1
 8001b58:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 8001b5c:	68fb      	ldr	r3, [r7, #12]
 8001b5e:	2200      	movs	r2, #0
 8001b60:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8001b64:	68fb      	ldr	r3, [r7, #12]
 8001b66:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8001b68:	2b00      	cmp	r3, #0
 8001b6a:	d001      	beq.n	8001b70 <HAL_SPI_Transmit+0x27e>
  {
    return HAL_ERROR;
 8001b6c:	2301      	movs	r3, #1
 8001b6e:	e000      	b.n	8001b72 <HAL_SPI_Transmit+0x280>
  }
  else
  {
    return HAL_OK;
 8001b70:	2300      	movs	r3, #0
  }
}
 8001b72:	4618      	mov	r0, r3
 8001b74:	3720      	adds	r7, #32
 8001b76:	46bd      	mov	sp, r7
 8001b78:	bd80      	pop	{r7, pc}
	...

08001b7c <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8001b7c:	b580      	push	{r7, lr}
 8001b7e:	b088      	sub	sp, #32
 8001b80:	af00      	add	r7, sp, #0
 8001b82:	60f8      	str	r0, [r7, #12]
 8001b84:	60b9      	str	r1, [r7, #8]
 8001b86:	603b      	str	r3, [r7, #0]
 8001b88:	4613      	mov	r3, r2
 8001b8a:	71fb      	strb	r3, [r7, #7]
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 8001b8c:	f7fe ff50 	bl	8000a30 <HAL_GetTick>
 8001b90:	4602      	mov	r2, r0
 8001b92:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001b94:	1a9b      	subs	r3, r3, r2
 8001b96:	683a      	ldr	r2, [r7, #0]
 8001b98:	4413      	add	r3, r2
 8001b9a:	61fb      	str	r3, [r7, #28]
  tmp_tickstart = HAL_GetTick();
 8001b9c:	f7fe ff48 	bl	8000a30 <HAL_GetTick>
 8001ba0:	61b8      	str	r0, [r7, #24]

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 8001ba2:	4b39      	ldr	r3, [pc, #228]	@ (8001c88 <SPI_WaitFlagStateUntilTimeout+0x10c>)
 8001ba4:	681b      	ldr	r3, [r3, #0]
 8001ba6:	015b      	lsls	r3, r3, #5
 8001ba8:	0d1b      	lsrs	r3, r3, #20
 8001baa:	69fa      	ldr	r2, [r7, #28]
 8001bac:	fb02 f303 	mul.w	r3, r2, r3
 8001bb0:	617b      	str	r3, [r7, #20]

  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8001bb2:	e054      	b.n	8001c5e <SPI_WaitFlagStateUntilTimeout+0xe2>
  {
    if (Timeout != HAL_MAX_DELAY)
 8001bb4:	683b      	ldr	r3, [r7, #0]
 8001bb6:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001bba:	d050      	beq.n	8001c5e <SPI_WaitFlagStateUntilTimeout+0xe2>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8001bbc:	f7fe ff38 	bl	8000a30 <HAL_GetTick>
 8001bc0:	4602      	mov	r2, r0
 8001bc2:	69bb      	ldr	r3, [r7, #24]
 8001bc4:	1ad3      	subs	r3, r2, r3
 8001bc6:	69fa      	ldr	r2, [r7, #28]
 8001bc8:	429a      	cmp	r2, r3
 8001bca:	d902      	bls.n	8001bd2 <SPI_WaitFlagStateUntilTimeout+0x56>
 8001bcc:	69fb      	ldr	r3, [r7, #28]
 8001bce:	2b00      	cmp	r3, #0
 8001bd0:	d13d      	bne.n	8001c4e <SPI_WaitFlagStateUntilTimeout+0xd2>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8001bd2:	68fb      	ldr	r3, [r7, #12]
 8001bd4:	681b      	ldr	r3, [r3, #0]
 8001bd6:	685a      	ldr	r2, [r3, #4]
 8001bd8:	68fb      	ldr	r3, [r7, #12]
 8001bda:	681b      	ldr	r3, [r3, #0]
 8001bdc:	f022 02e0 	bic.w	r2, r2, #224	@ 0xe0
 8001be0:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8001be2:	68fb      	ldr	r3, [r7, #12]
 8001be4:	685b      	ldr	r3, [r3, #4]
 8001be6:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8001bea:	d111      	bne.n	8001c10 <SPI_WaitFlagStateUntilTimeout+0x94>
 8001bec:	68fb      	ldr	r3, [r7, #12]
 8001bee:	689b      	ldr	r3, [r3, #8]
 8001bf0:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8001bf4:	d004      	beq.n	8001c00 <SPI_WaitFlagStateUntilTimeout+0x84>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8001bf6:	68fb      	ldr	r3, [r7, #12]
 8001bf8:	689b      	ldr	r3, [r3, #8]
 8001bfa:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8001bfe:	d107      	bne.n	8001c10 <SPI_WaitFlagStateUntilTimeout+0x94>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8001c00:	68fb      	ldr	r3, [r7, #12]
 8001c02:	681b      	ldr	r3, [r3, #0]
 8001c04:	681a      	ldr	r2, [r3, #0]
 8001c06:	68fb      	ldr	r3, [r7, #12]
 8001c08:	681b      	ldr	r3, [r3, #0]
 8001c0a:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8001c0e:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8001c10:	68fb      	ldr	r3, [r7, #12]
 8001c12:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8001c14:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8001c18:	d10f      	bne.n	8001c3a <SPI_WaitFlagStateUntilTimeout+0xbe>
        {
          SPI_RESET_CRC(hspi);
 8001c1a:	68fb      	ldr	r3, [r7, #12]
 8001c1c:	681b      	ldr	r3, [r3, #0]
 8001c1e:	681a      	ldr	r2, [r3, #0]
 8001c20:	68fb      	ldr	r3, [r7, #12]
 8001c22:	681b      	ldr	r3, [r3, #0]
 8001c24:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 8001c28:	601a      	str	r2, [r3, #0]
 8001c2a:	68fb      	ldr	r3, [r7, #12]
 8001c2c:	681b      	ldr	r3, [r3, #0]
 8001c2e:	681a      	ldr	r2, [r3, #0]
 8001c30:	68fb      	ldr	r3, [r7, #12]
 8001c32:	681b      	ldr	r3, [r3, #0]
 8001c34:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8001c38:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8001c3a:	68fb      	ldr	r3, [r7, #12]
 8001c3c:	2201      	movs	r2, #1
 8001c3e:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8001c42:	68fb      	ldr	r3, [r7, #12]
 8001c44:	2200      	movs	r2, #0
 8001c46:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

        return HAL_TIMEOUT;
 8001c4a:	2303      	movs	r3, #3
 8001c4c:	e017      	b.n	8001c7e <SPI_WaitFlagStateUntilTimeout+0x102>
      }
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if (count == 0U)
 8001c4e:	697b      	ldr	r3, [r7, #20]
 8001c50:	2b00      	cmp	r3, #0
 8001c52:	d101      	bne.n	8001c58 <SPI_WaitFlagStateUntilTimeout+0xdc>
      {
        tmp_timeout = 0U;
 8001c54:	2300      	movs	r3, #0
 8001c56:	61fb      	str	r3, [r7, #28]
      }
      count--;
 8001c58:	697b      	ldr	r3, [r7, #20]
 8001c5a:	3b01      	subs	r3, #1
 8001c5c:	617b      	str	r3, [r7, #20]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8001c5e:	68fb      	ldr	r3, [r7, #12]
 8001c60:	681b      	ldr	r3, [r3, #0]
 8001c62:	689a      	ldr	r2, [r3, #8]
 8001c64:	68bb      	ldr	r3, [r7, #8]
 8001c66:	4013      	ands	r3, r2
 8001c68:	68ba      	ldr	r2, [r7, #8]
 8001c6a:	429a      	cmp	r2, r3
 8001c6c:	bf0c      	ite	eq
 8001c6e:	2301      	moveq	r3, #1
 8001c70:	2300      	movne	r3, #0
 8001c72:	b2db      	uxtb	r3, r3
 8001c74:	461a      	mov	r2, r3
 8001c76:	79fb      	ldrb	r3, [r7, #7]
 8001c78:	429a      	cmp	r2, r3
 8001c7a:	d19b      	bne.n	8001bb4 <SPI_WaitFlagStateUntilTimeout+0x38>
    }
  }

  return HAL_OK;
 8001c7c:	2300      	movs	r3, #0
}
 8001c7e:	4618      	mov	r0, r3
 8001c80:	3720      	adds	r7, #32
 8001c82:	46bd      	mov	sp, r7
 8001c84:	bd80      	pop	{r7, pc}
 8001c86:	bf00      	nop
 8001c88:	20000000 	.word	0x20000000

08001c8c <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8001c8c:	b580      	push	{r7, lr}
 8001c8e:	b088      	sub	sp, #32
 8001c90:	af02      	add	r7, sp, #8
 8001c92:	60f8      	str	r0, [r7, #12]
 8001c94:	60b9      	str	r1, [r7, #8]
 8001c96:	607a      	str	r2, [r7, #4]
  /* Wait until TXE flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, Tickstart) != HAL_OK)
 8001c98:	687b      	ldr	r3, [r7, #4]
 8001c9a:	9300      	str	r3, [sp, #0]
 8001c9c:	68bb      	ldr	r3, [r7, #8]
 8001c9e:	2201      	movs	r2, #1
 8001ca0:	2102      	movs	r1, #2
 8001ca2:	68f8      	ldr	r0, [r7, #12]
 8001ca4:	f7ff ff6a 	bl	8001b7c <SPI_WaitFlagStateUntilTimeout>
 8001ca8:	4603      	mov	r3, r0
 8001caa:	2b00      	cmp	r3, #0
 8001cac:	d007      	beq.n	8001cbe <SPI_EndRxTxTransaction+0x32>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001cae:	68fb      	ldr	r3, [r7, #12]
 8001cb0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8001cb2:	f043 0220 	orr.w	r2, r3, #32
 8001cb6:	68fb      	ldr	r3, [r7, #12]
 8001cb8:	655a      	str	r2, [r3, #84]	@ 0x54
    return HAL_TIMEOUT;
 8001cba:	2303      	movs	r3, #3
 8001cbc:	e032      	b.n	8001d24 <SPI_EndRxTxTransaction+0x98>
  }

  /* Timeout in µs */
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 8001cbe:	4b1b      	ldr	r3, [pc, #108]	@ (8001d2c <SPI_EndRxTxTransaction+0xa0>)
 8001cc0:	681b      	ldr	r3, [r3, #0]
 8001cc2:	4a1b      	ldr	r2, [pc, #108]	@ (8001d30 <SPI_EndRxTxTransaction+0xa4>)
 8001cc4:	fba2 2303 	umull	r2, r3, r2, r3
 8001cc8:	0d5b      	lsrs	r3, r3, #21
 8001cca:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8001cce:	fb02 f303 	mul.w	r3, r2, r3
 8001cd2:	617b      	str	r3, [r7, #20]
  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 8001cd4:	68fb      	ldr	r3, [r7, #12]
 8001cd6:	685b      	ldr	r3, [r3, #4]
 8001cd8:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8001cdc:	d112      	bne.n	8001d04 <SPI_EndRxTxTransaction+0x78>
  {
    /* Control the BSY flag */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8001cde:	687b      	ldr	r3, [r7, #4]
 8001ce0:	9300      	str	r3, [sp, #0]
 8001ce2:	68bb      	ldr	r3, [r7, #8]
 8001ce4:	2200      	movs	r2, #0
 8001ce6:	2180      	movs	r1, #128	@ 0x80
 8001ce8:	68f8      	ldr	r0, [r7, #12]
 8001cea:	f7ff ff47 	bl	8001b7c <SPI_WaitFlagStateUntilTimeout>
 8001cee:	4603      	mov	r3, r0
 8001cf0:	2b00      	cmp	r3, #0
 8001cf2:	d016      	beq.n	8001d22 <SPI_EndRxTxTransaction+0x96>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8001cf4:	68fb      	ldr	r3, [r7, #12]
 8001cf6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8001cf8:	f043 0220 	orr.w	r2, r3, #32
 8001cfc:	68fb      	ldr	r3, [r7, #12]
 8001cfe:	655a      	str	r2, [r3, #84]	@ 0x54
      return HAL_TIMEOUT;
 8001d00:	2303      	movs	r3, #3
 8001d02:	e00f      	b.n	8001d24 <SPI_EndRxTxTransaction+0x98>
    * User have to calculate the timeout value to fit with the time of 1 byte transfer.
    * This time is directly link with the SPI clock from Master device.
    */
    do
    {
      if (count == 0U)
 8001d04:	697b      	ldr	r3, [r7, #20]
 8001d06:	2b00      	cmp	r3, #0
 8001d08:	d00a      	beq.n	8001d20 <SPI_EndRxTxTransaction+0x94>
      {
        break;
      }
      count--;
 8001d0a:	697b      	ldr	r3, [r7, #20]
 8001d0c:	3b01      	subs	r3, #1
 8001d0e:	617b      	str	r3, [r7, #20]
    } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
 8001d10:	68fb      	ldr	r3, [r7, #12]
 8001d12:	681b      	ldr	r3, [r3, #0]
 8001d14:	689b      	ldr	r3, [r3, #8]
 8001d16:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8001d1a:	2b80      	cmp	r3, #128	@ 0x80
 8001d1c:	d0f2      	beq.n	8001d04 <SPI_EndRxTxTransaction+0x78>
 8001d1e:	e000      	b.n	8001d22 <SPI_EndRxTxTransaction+0x96>
        break;
 8001d20:	bf00      	nop
  }

  return HAL_OK;
 8001d22:	2300      	movs	r3, #0
}
 8001d24:	4618      	mov	r0, r3
 8001d26:	3718      	adds	r7, #24
 8001d28:	46bd      	mov	sp, r7
 8001d2a:	bd80      	pop	{r7, pc}
 8001d2c:	20000000 	.word	0x20000000
 8001d30:	165e9f81 	.word	0x165e9f81

08001d34 <lcd_write_cmd>:
	HAL_Delay(250);
	HAL_GPIO_WritePin(LCD_RST_Port, LCD_RST_Pin, HIGH);
	HAL_Delay(250);
}

void lcd_write_cmd(uint8_t cmd){
 8001d34:	b580      	push	{r7, lr}
 8001d36:	b082      	sub	sp, #8
 8001d38:	af00      	add	r7, sp, #0
 8001d3a:	4603      	mov	r3, r0
 8001d3c:	71fb      	strb	r3, [r7, #7]
	HAL_GPIO_WritePin(LCD_CS_Port, LCD_CS_Pin, LOW);
 8001d3e:	2200      	movs	r2, #0
 8001d40:	2110      	movs	r1, #16
 8001d42:	480e      	ldr	r0, [pc, #56]	@ (8001d7c <lcd_write_cmd+0x48>)
 8001d44:	f7ff f90e 	bl	8000f64 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(LCD_DC_Port, LCD_DC_Pin, LOW);
 8001d48:	2200      	movs	r2, #0
 8001d4a:	2102      	movs	r1, #2
 8001d4c:	480c      	ldr	r0, [pc, #48]	@ (8001d80 <lcd_write_cmd+0x4c>)
 8001d4e:	f7ff f909 	bl	8000f64 <HAL_GPIO_WritePin>
	HAL_SPI_Transmit(&hspi1, &cmd, 1, 100);
 8001d52:	1df9      	adds	r1, r7, #7
 8001d54:	2364      	movs	r3, #100	@ 0x64
 8001d56:	2201      	movs	r2, #1
 8001d58:	480a      	ldr	r0, [pc, #40]	@ (8001d84 <lcd_write_cmd+0x50>)
 8001d5a:	f7ff fdca 	bl	80018f2 <HAL_SPI_Transmit>
	HAL_GPIO_WritePin(LCD_DC_Port, LCD_DC_Pin, HIGH);
 8001d5e:	2201      	movs	r2, #1
 8001d60:	2102      	movs	r1, #2
 8001d62:	4807      	ldr	r0, [pc, #28]	@ (8001d80 <lcd_write_cmd+0x4c>)
 8001d64:	f7ff f8fe 	bl	8000f64 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(LCD_CS_Port, LCD_CS_Pin, HIGH);
 8001d68:	2201      	movs	r2, #1
 8001d6a:	2110      	movs	r1, #16
 8001d6c:	4803      	ldr	r0, [pc, #12]	@ (8001d7c <lcd_write_cmd+0x48>)
 8001d6e:	f7ff f8f9 	bl	8000f64 <HAL_GPIO_WritePin>
}
 8001d72:	bf00      	nop
 8001d74:	3708      	adds	r7, #8
 8001d76:	46bd      	mov	sp, r7
 8001d78:	bd80      	pop	{r7, pc}
 8001d7a:	bf00      	nop
 8001d7c:	40020000 	.word	0x40020000
 8001d80:	40020400 	.word	0x40020400
 8001d84:	20000040 	.word	0x20000040

08001d88 <lcd_write_8data>:

void lcd_write_8data(uint8_t *buf, uint16_t len){
 8001d88:	b580      	push	{r7, lr}
 8001d8a:	b082      	sub	sp, #8
 8001d8c:	af00      	add	r7, sp, #0
 8001d8e:	6078      	str	r0, [r7, #4]
 8001d90:	460b      	mov	r3, r1
 8001d92:	807b      	strh	r3, [r7, #2]
	HAL_GPIO_WritePin(LCD_CS_Port, LCD_CS_Pin, LOW);
 8001d94:	2200      	movs	r2, #0
 8001d96:	2110      	movs	r1, #16
 8001d98:	4809      	ldr	r0, [pc, #36]	@ (8001dc0 <lcd_write_8data+0x38>)
 8001d9a:	f7ff f8e3 	bl	8000f64 <HAL_GPIO_WritePin>
	HAL_SPI_Transmit(&hspi1, buf, len, HAL_MAX_DELAY);
 8001d9e:	887a      	ldrh	r2, [r7, #2]
 8001da0:	f04f 33ff 	mov.w	r3, #4294967295
 8001da4:	6879      	ldr	r1, [r7, #4]
 8001da6:	4807      	ldr	r0, [pc, #28]	@ (8001dc4 <lcd_write_8data+0x3c>)
 8001da8:	f7ff fda3 	bl	80018f2 <HAL_SPI_Transmit>
	HAL_GPIO_WritePin(LCD_CS_Port, LCD_CS_Pin, HIGH);
 8001dac:	2201      	movs	r2, #1
 8001dae:	2110      	movs	r1, #16
 8001db0:	4803      	ldr	r0, [pc, #12]	@ (8001dc0 <lcd_write_8data+0x38>)
 8001db2:	f7ff f8d7 	bl	8000f64 <HAL_GPIO_WritePin>
}
 8001db6:	bf00      	nop
 8001db8:	3708      	adds	r7, #8
 8001dba:	46bd      	mov	sp, r7
 8001dbc:	bd80      	pop	{r7, pc}
 8001dbe:	bf00      	nop
 8001dc0:	40020000 	.word	0x40020000
 8001dc4:	20000040 	.word	0x20000040

08001dc8 <lcd_write_16data>:

void lcd_write_16data(uint16_t *buf, uint16_t len){
 8001dc8:	b580      	push	{r7, lr}
 8001dca:	b084      	sub	sp, #16
 8001dcc:	af00      	add	r7, sp, #0
 8001dce:	6078      	str	r0, [r7, #4]
 8001dd0:	460b      	mov	r3, r1
 8001dd2:	807b      	strh	r3, [r7, #2]
	uint8_t data_buf[2] = {0x00,0x00};
 8001dd4:	2300      	movs	r3, #0
 8001dd6:	813b      	strh	r3, [r7, #8]
	uint16_t *ptr = buf;
 8001dd8:	687b      	ldr	r3, [r7, #4]
 8001dda:	60fb      	str	r3, [r7, #12]
	HAL_GPIO_WritePin(LCD_CS_Port, LCD_CS_Pin, LOW);
 8001ddc:	2200      	movs	r2, #0
 8001dde:	2110      	movs	r1, #16
 8001de0:	4813      	ldr	r0, [pc, #76]	@ (8001e30 <lcd_write_16data+0x68>)
 8001de2:	f7ff f8bf 	bl	8000f64 <HAL_GPIO_WritePin>
	while(len--){
 8001de6:	e014      	b.n	8001e12 <lcd_write_16data+0x4a>
		data_buf[0] = (uint8_t)((*buf >> 8) & 0xFF);
 8001de8:	687b      	ldr	r3, [r7, #4]
 8001dea:	881b      	ldrh	r3, [r3, #0]
 8001dec:	0a1b      	lsrs	r3, r3, #8
 8001dee:	b29b      	uxth	r3, r3
 8001df0:	b2db      	uxtb	r3, r3
 8001df2:	723b      	strb	r3, [r7, #8]
		data_buf[1] = (uint8_t)(*buf & 0xFF);
 8001df4:	687b      	ldr	r3, [r7, #4]
 8001df6:	881b      	ldrh	r3, [r3, #0]
 8001df8:	b2db      	uxtb	r3, r3
 8001dfa:	727b      	strb	r3, [r7, #9]
		HAL_SPI_Transmit(&hspi1, data_buf, 2, HAL_MAX_DELAY);
 8001dfc:	f107 0108 	add.w	r1, r7, #8
 8001e00:	f04f 33ff 	mov.w	r3, #4294967295
 8001e04:	2202      	movs	r2, #2
 8001e06:	480b      	ldr	r0, [pc, #44]	@ (8001e34 <lcd_write_16data+0x6c>)
 8001e08:	f7ff fd73 	bl	80018f2 <HAL_SPI_Transmit>
		ptr++;
 8001e0c:	68fb      	ldr	r3, [r7, #12]
 8001e0e:	3302      	adds	r3, #2
 8001e10:	60fb      	str	r3, [r7, #12]
	while(len--){
 8001e12:	887b      	ldrh	r3, [r7, #2]
 8001e14:	1e5a      	subs	r2, r3, #1
 8001e16:	807a      	strh	r2, [r7, #2]
 8001e18:	2b00      	cmp	r3, #0
 8001e1a:	d1e5      	bne.n	8001de8 <lcd_write_16data+0x20>
		}
	HAL_GPIO_WritePin(LCD_CS_Port, LCD_CS_Pin, HIGH);
 8001e1c:	2201      	movs	r2, #1
 8001e1e:	2110      	movs	r1, #16
 8001e20:	4803      	ldr	r0, [pc, #12]	@ (8001e30 <lcd_write_16data+0x68>)
 8001e22:	f7ff f89f 	bl	8000f64 <HAL_GPIO_WritePin>
}
 8001e26:	bf00      	nop
 8001e28:	3710      	adds	r7, #16
 8001e2a:	46bd      	mov	sp, r7
 8001e2c:	bd80      	pop	{r7, pc}
 8001e2e:	bf00      	nop
 8001e30:	40020000 	.word	0x40020000
 8001e34:	20000040 	.word	0x20000040

08001e38 <lcd_config>:

void lcd_config(void){
 8001e38:	b580      	push	{r7, lr}
 8001e3a:	af00      	add	r7, sp, #0

	lcd_write_cmd(TFT_SWRST); // SW reset
 8001e3c:	2001      	movs	r0, #1
 8001e3e:	f7ff ff79 	bl	8001d34 <lcd_write_cmd>
    HAL_Delay(120);
 8001e42:	2078      	movs	r0, #120	@ 0x78
 8001e44:	f7fe fe00 	bl	8000a48 <HAL_Delay>

	lcd_write_cmd(TFT_SLPOUT); // Sleep out, also SW reset
 8001e48:	2011      	movs	r0, #17
 8001e4a:	f7ff ff73 	bl	8001d34 <lcd_write_cmd>
    HAL_Delay(120);
 8001e4e:	2078      	movs	r0, #120	@ 0x78
 8001e50:	f7fe fdfa 	bl	8000a48 <HAL_Delay>

	lcd_write_cmd(TFT_PIX_FMT); //Set Pixel Format Value
 8001e54:	203a      	movs	r0, #58	@ 0x3a
 8001e56:	f7ff ff6d 	bl	8001d34 <lcd_write_cmd>
	lcd_write_8data((uint8_t*)TFT_PIX_FMT_16BIT,1); //Set 16bit Pixel Format
 8001e5a:	2101      	movs	r1, #1
 8001e5c:	2055      	movs	r0, #85	@ 0x55
 8001e5e:	f7ff ff93 	bl	8001d88 <lcd_write_8data>

	// By default is also same
	lcd_write_cmd(TFT_PWRCTRL1); //Set Power Control 1
 8001e62:	20c0      	movs	r0, #192	@ 0xc0
 8001e64:	f7ff ff66 	bl	8001d34 <lcd_write_cmd>
	lcd_write_8data((uint8_t*)0x0E,1);    //                          0001.0111   ... VRH1
 8001e68:	2101      	movs	r1, #1
 8001e6a:	200e      	movs	r0, #14
 8001e6c:	f7ff ff8c 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x0E,1);    //                          0001.0101   ... VRH2
 8001e70:	2101      	movs	r1, #1
 8001e72:	200e      	movs	r0, #14
 8001e74:	f7ff ff88 	bl	8001d88 <lcd_write_8data>
    
	lcd_write_cmd(TFT_PWRCTRL2); //                          1100.0001 Power Control 2
 8001e78:	20c1      	movs	r0, #193	@ 0xc1
 8001e7a:	f7ff ff5b 	bl	8001d34 <lcd_write_cmd>
    lcd_write_8data((uint8_t*)0x41,1);    //                          0100.0001   . SAP BT
 8001e7e:	2101      	movs	r1, #1
 8001e80:	2041      	movs	r0, #65	@ 0x41
 8001e82:	f7ff ff81 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x00,1);    //                          0000.0000   ..... VC
 8001e86:	2101      	movs	r1, #1
 8001e88:	2000      	movs	r0, #0
 8001e8a:	f7ff ff7d 	bl	8001d88 <lcd_write_8data>
    
	lcd_write_cmd(TFT_PWRCTRL3); //                          1100.0010 Power Control 3
 8001e8e:	20c2      	movs	r0, #194	@ 0xc2
 8001e90:	f7ff ff50 	bl	8001d34 <lcd_write_cmd>
    lcd_write_8data((uint8_t*)0x55,1);    //     nb. was 0x44         0101.0101   . DCA1 . DCA0
 8001e94:	2101      	movs	r1, #1
 8001e96:	2055      	movs	r0, #85	@ 0x55
 8001e98:	f7ff ff76 	bl	8001d88 <lcd_write_8data>

	lcd_write_cmd(TFT_VCOM_CTRL);
 8001e9c:	20c5      	movs	r0, #197	@ 0xc5
 8001e9e:	f7ff ff49 	bl	8001d34 <lcd_write_cmd>
    lcd_write_8data((uint8_t*)0x00,1);
 8001ea2:	2101      	movs	r1, #1
 8001ea4:	2000      	movs	r0, #0
 8001ea6:	f7ff ff6f 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x00,1);
 8001eaa:	2101      	movs	r1, #1
 8001eac:	2000      	movs	r0, #0
 8001eae:	f7ff ff6b 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x00,1);
 8001eb2:	2101      	movs	r1, #1
 8001eb4:	2000      	movs	r0, #0
 8001eb6:	f7ff ff67 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x00,1);
 8001eba:	2101      	movs	r1, #1
 8001ebc:	2000      	movs	r0, #0
 8001ebe:	f7ff ff63 	bl	8001d88 <lcd_write_8data>

	lcd_write_cmd(TFT_PGAMCTRL);
 8001ec2:	20e0      	movs	r0, #224	@ 0xe0
 8001ec4:	f7ff ff36 	bl	8001d34 <lcd_write_cmd>
    lcd_write_8data((uint8_t*)0x0F,1);
 8001ec8:	2101      	movs	r1, #1
 8001eca:	200f      	movs	r0, #15
 8001ecc:	f7ff ff5c 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x1F,1);
 8001ed0:	2101      	movs	r1, #1
 8001ed2:	201f      	movs	r0, #31
 8001ed4:	f7ff ff58 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x1C,1);
 8001ed8:	2101      	movs	r1, #1
 8001eda:	201c      	movs	r0, #28
 8001edc:	f7ff ff54 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x0C,1);
 8001ee0:	2101      	movs	r1, #1
 8001ee2:	200c      	movs	r0, #12
 8001ee4:	f7ff ff50 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x0F,1);
 8001ee8:	2101      	movs	r1, #1
 8001eea:	200f      	movs	r0, #15
 8001eec:	f7ff ff4c 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x08,1);
 8001ef0:	2101      	movs	r1, #1
 8001ef2:	2008      	movs	r0, #8
 8001ef4:	f7ff ff48 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x48,1);
 8001ef8:	2101      	movs	r1, #1
 8001efa:	2048      	movs	r0, #72	@ 0x48
 8001efc:	f7ff ff44 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x98,1);
 8001f00:	2101      	movs	r1, #1
 8001f02:	2098      	movs	r0, #152	@ 0x98
 8001f04:	f7ff ff40 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x37,1);
 8001f08:	2101      	movs	r1, #1
 8001f0a:	2037      	movs	r0, #55	@ 0x37
 8001f0c:	f7ff ff3c 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x0A,1);
 8001f10:	2101      	movs	r1, #1
 8001f12:	200a      	movs	r0, #10
 8001f14:	f7ff ff38 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x13,1);
 8001f18:	2101      	movs	r1, #1
 8001f1a:	2013      	movs	r0, #19
 8001f1c:	f7ff ff34 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x04,1);
 8001f20:	2101      	movs	r1, #1
 8001f22:	2004      	movs	r0, #4
 8001f24:	f7ff ff30 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x11,1);
 8001f28:	2101      	movs	r1, #1
 8001f2a:	2011      	movs	r0, #17
 8001f2c:	f7ff ff2c 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x0D,1);
 8001f30:	2101      	movs	r1, #1
 8001f32:	200d      	movs	r0, #13
 8001f34:	f7ff ff28 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x00,1);
 8001f38:	2101      	movs	r1, #1
 8001f3a:	2000      	movs	r0, #0
 8001f3c:	f7ff ff24 	bl	8001d88 <lcd_write_8data>
 
	lcd_write_cmd(TFT_NGAMCTRL);
 8001f40:	20e1      	movs	r0, #225	@ 0xe1
 8001f42:	f7ff fef7 	bl	8001d34 <lcd_write_cmd>
    lcd_write_8data((uint8_t*)0x0F,1);
 8001f46:	2101      	movs	r1, #1
 8001f48:	200f      	movs	r0, #15
 8001f4a:	f7ff ff1d 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x32,1);
 8001f4e:	2101      	movs	r1, #1
 8001f50:	2032      	movs	r0, #50	@ 0x32
 8001f52:	f7ff ff19 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x2E,1);
 8001f56:	2101      	movs	r1, #1
 8001f58:	202e      	movs	r0, #46	@ 0x2e
 8001f5a:	f7ff ff15 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x0B,1);
 8001f5e:	2101      	movs	r1, #1
 8001f60:	200b      	movs	r0, #11
 8001f62:	f7ff ff11 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x0D,1);
 8001f66:	2101      	movs	r1, #1
 8001f68:	200d      	movs	r0, #13
 8001f6a:	f7ff ff0d 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x05,1);
 8001f6e:	2101      	movs	r1, #1
 8001f70:	2005      	movs	r0, #5
 8001f72:	f7ff ff09 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x47,1);
 8001f76:	2101      	movs	r1, #1
 8001f78:	2047      	movs	r0, #71	@ 0x47
 8001f7a:	f7ff ff05 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x75,1);
 8001f7e:	2101      	movs	r1, #1
 8001f80:	2075      	movs	r0, #117	@ 0x75
 8001f82:	f7ff ff01 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x37,1);
 8001f86:	2101      	movs	r1, #1
 8001f88:	2037      	movs	r0, #55	@ 0x37
 8001f8a:	f7ff fefd 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x06,1);
 8001f8e:	2101      	movs	r1, #1
 8001f90:	2006      	movs	r0, #6
 8001f92:	f7ff fef9 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x10,1);
 8001f96:	2101      	movs	r1, #1
 8001f98:	2010      	movs	r0, #16
 8001f9a:	f7ff fef5 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x03,1);
 8001f9e:	2101      	movs	r1, #1
 8001fa0:	2003      	movs	r0, #3
 8001fa2:	f7ff fef1 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x24,1);
 8001fa6:	2101      	movs	r1, #1
 8001fa8:	2024      	movs	r0, #36	@ 0x24
 8001faa:	f7ff feed 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x20,1);
 8001fae:	2101      	movs	r1, #1
 8001fb0:	2020      	movs	r0, #32
 8001fb2:	f7ff fee9 	bl	8001d88 <lcd_write_8data>
    lcd_write_8data((uint8_t*)0x00,1);
 8001fb6:	2101      	movs	r1, #1
 8001fb8:	2000      	movs	r0, #0
 8001fba:	f7ff fee5 	bl	8001d88 <lcd_write_8data>

	lcd_write_cmd(TFT_INVOFF); //Display Inversion OFF
 8001fbe:	2020      	movs	r0, #32
 8001fc0:	f7ff feb8 	bl	8001d34 <lcd_write_cmd>

	lcd_write_cmd(TFT_MADCTL); //Set Memory Access Control
 8001fc4:	2036      	movs	r0, #54	@ 0x36
 8001fc6:	f7ff feb5 	bl	8001d34 <lcd_write_cmd>
	lcd_write_8data((uint8_t*)(TFT_MAD_MX | TFT_MAD_BGR),1); // Set MX = 1, BGR = 1
 8001fca:	2101      	movs	r1, #1
 8001fcc:	2048      	movs	r0, #72	@ 0x48
 8001fce:	f7ff fedb 	bl	8001d88 <lcd_write_8data>

	lcd_write_cmd(TFT_DISPLAY_ON); // display on
 8001fd2:	2029      	movs	r0, #41	@ 0x29
 8001fd4:	f7ff feae 	bl	8001d34 <lcd_write_cmd>
    HAL_Delay(150);
 8001fd8:	2096      	movs	r0, #150	@ 0x96
 8001fda:	f7fe fd35 	bl	8000a48 <HAL_Delay>
}
 8001fde:	bf00      	nop
 8001fe0:	bd80      	pop	{r7, pc}

08001fe2 <lcd_set_display_area>:

void lcd_set_display_area(uint16_t x1, uint16_t x2, uint16_t y1, uint16_t y2)
{
 8001fe2:	b590      	push	{r4, r7, lr}
 8001fe4:	b085      	sub	sp, #20
 8001fe6:	af00      	add	r7, sp, #0
 8001fe8:	4604      	mov	r4, r0
 8001fea:	4608      	mov	r0, r1
 8001fec:	4611      	mov	r1, r2
 8001fee:	461a      	mov	r2, r3
 8001ff0:	4623      	mov	r3, r4
 8001ff2:	80fb      	strh	r3, [r7, #6]
 8001ff4:	4603      	mov	r3, r0
 8001ff6:	80bb      	strh	r3, [r7, #4]
 8001ff8:	460b      	mov	r3, r1
 8001ffa:	807b      	strh	r3, [r7, #2]
 8001ffc:	4613      	mov	r3, r2
 8001ffe:	803b      	strh	r3, [r7, #0]
	uint8_t params[4];
	/*Column address set(2Ah) */
	params[0] = (uint8_t)((x1 >> 8) & 0xFF);
 8002000:	88fb      	ldrh	r3, [r7, #6]
 8002002:	0a1b      	lsrs	r3, r3, #8
 8002004:	b29b      	uxth	r3, r3
 8002006:	b2db      	uxtb	r3, r3
 8002008:	733b      	strb	r3, [r7, #12]
	params[1] = (uint8_t)(x1 & 0xFF);
 800200a:	88fb      	ldrh	r3, [r7, #6]
 800200c:	b2db      	uxtb	r3, r3
 800200e:	737b      	strb	r3, [r7, #13]
	params[2] = (uint8_t)((x2 >> 8) & 0xFF);
 8002010:	88bb      	ldrh	r3, [r7, #4]
 8002012:	0a1b      	lsrs	r3, r3, #8
 8002014:	b29b      	uxth	r3, r3
 8002016:	b2db      	uxtb	r3, r3
 8002018:	73bb      	strb	r3, [r7, #14]
	params[3] = (uint8_t)(x2 & 0xFF);
 800201a:	88bb      	ldrh	r3, [r7, #4]
 800201c:	b2db      	uxtb	r3, r3
 800201e:	73fb      	strb	r3, [r7, #15]
	lcd_write_cmd(TFT_CASET);
 8002020:	202a      	movs	r0, #42	@ 0x2a
 8002022:	f7ff fe87 	bl	8001d34 <lcd_write_cmd>
	lcd_write_8data(params, 4);
 8002026:	f107 030c 	add.w	r3, r7, #12
 800202a:	2104      	movs	r1, #4
 800202c:	4618      	mov	r0, r3
 800202e:	f7ff feab 	bl	8001d88 <lcd_write_8data>

	params[0] = (uint8_t)((y1 >> 8) & 0xFF);
 8002032:	887b      	ldrh	r3, [r7, #2]
 8002034:	0a1b      	lsrs	r3, r3, #8
 8002036:	b29b      	uxth	r3, r3
 8002038:	b2db      	uxtb	r3, r3
 800203a:	733b      	strb	r3, [r7, #12]
	params[1] = (uint8_t)(y1 & 0xFF);
 800203c:	887b      	ldrh	r3, [r7, #2]
 800203e:	b2db      	uxtb	r3, r3
 8002040:	737b      	strb	r3, [r7, #13]
	params[2] = (uint8_t)((y2 >> 8) & 0xFF);
 8002042:	883b      	ldrh	r3, [r7, #0]
 8002044:	0a1b      	lsrs	r3, r3, #8
 8002046:	b29b      	uxth	r3, r3
 8002048:	b2db      	uxtb	r3, r3
 800204a:	73bb      	strb	r3, [r7, #14]
	params[3] = (uint8_t)(y2 & 0xFF);
 800204c:	883b      	ldrh	r3, [r7, #0]
 800204e:	b2db      	uxtb	r3, r3
 8002050:	73fb      	strb	r3, [r7, #15]
	lcd_write_cmd(TFT_PASET);
 8002052:	202b      	movs	r0, #43	@ 0x2b
 8002054:	f7ff fe6e 	bl	8001d34 <lcd_write_cmd>
	lcd_write_8data(params, 4);
 8002058:	f107 030c 	add.w	r3, r7, #12
 800205c:	2104      	movs	r1, #4
 800205e:	4618      	mov	r0, r3
 8002060:	f7ff fe92 	bl	8001d88 <lcd_write_8data>

	lcd_write_cmd(TFT_RAMWR);
 8002064:	202c      	movs	r0, #44	@ 0x2c
 8002066:	f7ff fe65 	bl	8001d34 <lcd_write_cmd>
}
 800206a:	bf00      	nop
 800206c:	3714      	adds	r7, #20
 800206e:	46bd      	mov	sp, r7
 8002070:	bd90      	pop	{r4, r7, pc}

08002072 <convert_rgb888_to_rgb565>:

uint16_t convert_rgb888_to_rgb565(uint32_t rgb888)
{
 8002072:	b480      	push	{r7}
 8002074:	b085      	sub	sp, #20
 8002076:	af00      	add	r7, sp, #0
 8002078:	6078      	str	r0, [r7, #4]
    uint16_t r,g,b;
	r = (rgb888 >> 19) & 0x1FU;
 800207a:	687b      	ldr	r3, [r7, #4]
 800207c:	0cdb      	lsrs	r3, r3, #19
 800207e:	b29b      	uxth	r3, r3
 8002080:	f003 031f 	and.w	r3, r3, #31
 8002084:	81fb      	strh	r3, [r7, #14]
	g = (rgb888 >> 10) & 0x3FU;
 8002086:	687b      	ldr	r3, [r7, #4]
 8002088:	0a9b      	lsrs	r3, r3, #10
 800208a:	b29b      	uxth	r3, r3
 800208c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8002090:	81bb      	strh	r3, [r7, #12]
	b = (rgb888 >> 3)  & 0x1FU;
 8002092:	687b      	ldr	r3, [r7, #4]
 8002094:	08db      	lsrs	r3, r3, #3
 8002096:	b29b      	uxth	r3, r3
 8002098:	f003 031f 	and.w	r3, r3, #31
 800209c:	817b      	strh	r3, [r7, #10]
	return (uint16_t)((r << 11) | (g << 5) | b);
 800209e:	89fb      	ldrh	r3, [r7, #14]
 80020a0:	02db      	lsls	r3, r3, #11
 80020a2:	b21a      	sxth	r2, r3
 80020a4:	89bb      	ldrh	r3, [r7, #12]
 80020a6:	015b      	lsls	r3, r3, #5
 80020a8:	b21b      	sxth	r3, r3
 80020aa:	4313      	orrs	r3, r2
 80020ac:	b21a      	sxth	r2, r3
 80020ae:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 80020b2:	4313      	orrs	r3, r2
 80020b4:	b21b      	sxth	r3, r3
 80020b6:	b29b      	uxth	r3, r3
}
 80020b8:	4618      	mov	r0, r3
 80020ba:	3714      	adds	r7, #20
 80020bc:	46bd      	mov	sp, r7
 80020be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80020c2:	4770      	bx	lr

080020c4 <lcd_setbackgroundcolor>:

void lcd_setbackgroundcolor(uint16_t color){
 80020c4:	b580      	push	{r7, lr}
 80020c6:	b084      	sub	sp, #16
 80020c8:	af00      	add	r7, sp, #0
 80020ca:	4603      	mov	r3, r0
 80020cc:	80fb      	strh	r3, [r7, #6]
	color = convert_rgb888_to_rgb565(color);
 80020ce:	88fb      	ldrh	r3, [r7, #6]
 80020d0:	4618      	mov	r0, r3
 80020d2:	f7ff ffce 	bl	8002072 <convert_rgb888_to_rgb565>
 80020d6:	4603      	mov	r3, r0
 80020d8:	80fb      	strh	r3, [r7, #6]
	lcd_set_display_area(0,TFT_WIDTH,0,TFT_HEIGHT);
 80020da:	f44f 73f0 	mov.w	r3, #480	@ 0x1e0
 80020de:	2200      	movs	r2, #0
 80020e0:	f44f 71a0 	mov.w	r1, #320	@ 0x140
 80020e4:	2000      	movs	r0, #0
 80020e6:	f7ff ff7c 	bl	8001fe2 <lcd_set_display_area>
	for(int i = 0; i < (TFT_WIDTH * TFT_HEIGHT); i++){
 80020ea:	2300      	movs	r3, #0
 80020ec:	60fb      	str	r3, [r7, #12]
 80020ee:	e007      	b.n	8002100 <lcd_setbackgroundcolor+0x3c>
		lcd_write_16data(&color,1);
 80020f0:	1dbb      	adds	r3, r7, #6
 80020f2:	2101      	movs	r1, #1
 80020f4:	4618      	mov	r0, r3
 80020f6:	f7ff fe67 	bl	8001dc8 <lcd_write_16data>
	for(int i = 0; i < (TFT_WIDTH * TFT_HEIGHT); i++){
 80020fa:	68fb      	ldr	r3, [r7, #12]
 80020fc:	3301      	adds	r3, #1
 80020fe:	60fb      	str	r3, [r7, #12]
 8002100:	68fb      	ldr	r3, [r7, #12]
 8002102:	f5b3 3f16 	cmp.w	r3, #153600	@ 0x25800
 8002106:	dbf3      	blt.n	80020f0 <lcd_setbackgroundcolor+0x2c>
	}
}
 8002108:	bf00      	nop
 800210a:	bf00      	nop
 800210c:	3710      	adds	r7, #16
 800210e:	46bd      	mov	sp, r7
 8002110:	bd80      	pop	{r7, pc}

08002112 <lv_color_hex>:
 * Create a color from 0x000000..0xffffff input
 * @param c     the hex input
 * @return      the color
 */
static inline lv_color_t lv_color_hex(uint32_t c)
{
 8002112:	b480      	push	{r7}
 8002114:	b085      	sub	sp, #20
 8002116:	af00      	add	r7, sp, #0
 8002118:	6078      	str	r0, [r7, #4]
    lv_color_t ret;
    ret.red = (c >> 16) & 0xff;
 800211a:	687b      	ldr	r3, [r7, #4]
 800211c:	0c1b      	lsrs	r3, r3, #16
 800211e:	b2db      	uxtb	r3, r3
 8002120:	72bb      	strb	r3, [r7, #10]
    ret.green = (c >> 8) & 0xff;
 8002122:	687b      	ldr	r3, [r7, #4]
 8002124:	0a1b      	lsrs	r3, r3, #8
 8002126:	b2db      	uxtb	r3, r3
 8002128:	727b      	strb	r3, [r7, #9]
    ret.blue = (c >> 0) & 0xff;
 800212a:	687b      	ldr	r3, [r7, #4]
 800212c:	b2db      	uxtb	r3, r3
 800212e:	723b      	strb	r3, [r7, #8]
    return ret;
 8002130:	f107 030c 	add.w	r3, r7, #12
 8002134:	f107 0208 	add.w	r2, r7, #8
 8002138:	6812      	ldr	r2, [r2, #0]
 800213a:	4611      	mov	r1, r2
 800213c:	8019      	strh	r1, [r3, #0]
 800213e:	3302      	adds	r3, #2
 8002140:	0c12      	lsrs	r2, r2, #16
 8002142:	701a      	strb	r2, [r3, #0]
 8002144:	2300      	movs	r3, #0
 8002146:	7b3a      	ldrb	r2, [r7, #12]
 8002148:	f362 0307 	bfi	r3, r2, #0, #8
 800214c:	7b7a      	ldrb	r2, [r7, #13]
 800214e:	f362 230f 	bfi	r3, r2, #8, #8
 8002152:	7bba      	ldrb	r2, [r7, #14]
 8002154:	f362 4317 	bfi	r3, r2, #16, #8
}
 8002158:	4618      	mov	r0, r3
 800215a:	3714      	adds	r7, #20
 800215c:	46bd      	mov	sp, r7
 800215e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002162:	4770      	bx	lr

08002164 <lv_screen_active>:
/**
 * Get the active screen of the default display
 * @return          pointer to the active screen
 */
static inline lv_obj_t * lv_screen_active(void)
{
 8002164:	b580      	push	{r7, lr}
 8002166:	af00      	add	r7, sp, #0
    return lv_display_get_screen_active(lv_display_get_default());
 8002168:	f008 ffba 	bl	800b0e0 <lv_display_get_default>
 800216c:	4603      	mov	r3, r0
 800216e:	4618      	mov	r0, r3
 8002170:	f009 f849 	bl	800b206 <lv_display_get_screen_active>
 8002174:	4603      	mov	r3, r0
}
 8002176:	4618      	mov	r0, r3
 8002178:	bd80      	pop	{r7, pc}
	...

0800217c <lv_example_get_started_1>:

/**
 * Basic example to create a "Hello world" label
 */
void lv_example_get_started_1(void)
{
 800217c:	b590      	push	{r4, r7, lr}
 800217e:	b085      	sub	sp, #20
 8002180:	af00      	add	r7, sp, #0
    /*Change the active screen's background color*/
    lv_obj_set_style_bg_color(lv_screen_active(), lv_color_hex(0x003a57), LV_PART_MAIN);
 8002182:	f7ff ffef 	bl	8002164 <lv_screen_active>
 8002186:	4604      	mov	r4, r0
 8002188:	f643 2057 	movw	r0, #14935	@ 0x3a57
 800218c:	f7ff ffc1 	bl	8002112 <lv_color_hex>
 8002190:	4603      	mov	r3, r0
 8002192:	461a      	mov	r2, r3
 8002194:	713a      	strb	r2, [r7, #4]
 8002196:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800219a:	717a      	strb	r2, [r7, #5]
 800219c:	f3c3 4307 	ubfx	r3, r3, #16, #8
 80021a0:	71bb      	strb	r3, [r7, #6]
 80021a2:	2200      	movs	r2, #0
 80021a4:	6879      	ldr	r1, [r7, #4]
 80021a6:	4620      	mov	r0, r4
 80021a8:	f008 fdb9 	bl	800ad1e <lv_obj_set_style_bg_color>

    /*Create a white label, set its text and align it to the center*/
    lv_obj_t * label = lv_label_create(lv_screen_active());
 80021ac:	f7ff ffda 	bl	8002164 <lv_screen_active>
 80021b0:	4603      	mov	r3, r0
 80021b2:	4618      	mov	r0, r3
 80021b4:	f024 f8e6 	bl	8026384 <lv_label_create>
 80021b8:	60f8      	str	r0, [r7, #12]
    lv_label_set_text(label, "Hello world");
 80021ba:	4911      	ldr	r1, [pc, #68]	@ (8002200 <lv_example_get_started_1+0x84>)
 80021bc:	68f8      	ldr	r0, [r7, #12]
 80021be:	f024 f8f5 	bl	80263ac <lv_label_set_text>
    lv_obj_set_style_text_color(lv_screen_active(), lv_color_hex(0xffffff), LV_PART_MAIN);
 80021c2:	f7ff ffcf 	bl	8002164 <lv_screen_active>
 80021c6:	4604      	mov	r4, r0
 80021c8:	f06f 407f 	mvn.w	r0, #4278190080	@ 0xff000000
 80021cc:	f7ff ffa1 	bl	8002112 <lv_color_hex>
 80021d0:	4603      	mov	r3, r0
 80021d2:	461a      	mov	r2, r3
 80021d4:	723a      	strb	r2, [r7, #8]
 80021d6:	f3c3 2207 	ubfx	r2, r3, #8, #8
 80021da:	727a      	strb	r2, [r7, #9]
 80021dc:	f3c3 4307 	ubfx	r3, r3, #16, #8
 80021e0:	72bb      	strb	r3, [r7, #10]
 80021e2:	2200      	movs	r2, #0
 80021e4:	68b9      	ldr	r1, [r7, #8]
 80021e6:	4620      	mov	r0, r4
 80021e8:	f008 fdb5 	bl	800ad56 <lv_obj_set_style_text_color>
    lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);
 80021ec:	2300      	movs	r3, #0
 80021ee:	2200      	movs	r2, #0
 80021f0:	2109      	movs	r1, #9
 80021f2:	68f8      	ldr	r0, [r7, #12]
 80021f4:	f003 fd76 	bl	8005ce4 <lv_obj_align>
}
 80021f8:	bf00      	nop
 80021fa:	3714      	adds	r7, #20
 80021fc:	46bd      	mov	sp, r7
 80021fe:	bd90      	pop	{r4, r7, pc}
 8002200:	08027b70 	.word	0x08027b70

08002204 <_lv_group_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void _lv_group_init(void)
{
 8002204:	b580      	push	{r7, lr}
 8002206:	af00      	add	r7, sp, #0
    _lv_ll_init(group_ll_p, sizeof(lv_group_t));
 8002208:	2120      	movs	r1, #32
 800220a:	4802      	ldr	r0, [pc, #8]	@ (8002214 <_lv_group_init+0x10>)
 800220c:	f020 ff01 	bl	8023012 <_lv_ll_init>
}
 8002210:	bf00      	nop
 8002212:	bd80      	pop	{r7, pc}
 8002214:	200000d0 	.word	0x200000d0

08002218 <lv_group_get_default>:
{
    default_group = group;
}

lv_group_t * lv_group_get_default(void)
{
 8002218:	b480      	push	{r7}
 800221a:	af00      	add	r7, sp, #0
    return default_group;
 800221c:	4b03      	ldr	r3, [pc, #12]	@ (800222c <lv_group_get_default+0x14>)
 800221e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
}
 8002220:	4618      	mov	r0, r3
 8002222:	46bd      	mov	sp, r7
 8002224:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002228:	4770      	bx	lr
 800222a:	bf00      	nop
 800222c:	2000009c 	.word	0x2000009c

08002230 <lv_group_add_obj>:

void lv_group_add_obj(lv_group_t * group, lv_obj_t * obj)
{
 8002230:	b580      	push	{r7, lr}
 8002232:	b086      	sub	sp, #24
 8002234:	af00      	add	r7, sp, #0
 8002236:	6078      	str	r0, [r7, #4]
 8002238:	6039      	str	r1, [r7, #0]
    if(group == NULL) return;
 800223a:	687b      	ldr	r3, [r7, #4]
 800223c:	2b00      	cmp	r3, #0
 800223e:	d054      	beq.n	80022ea <lv_group_add_obj+0xba>

    LV_LOG_TRACE("begin");

    /*Be sure the object is removed from its current group*/
    lv_group_remove_obj(obj);
 8002240:	6838      	ldr	r0, [r7, #0]
 8002242:	f000 f85a 	bl	80022fa <lv_group_remove_obj>

    /*Do not add the object twice*/
    lv_obj_t ** obj_i;
    _LV_LL_READ(&group->obj_ll, obj_i) {
 8002246:	687b      	ldr	r3, [r7, #4]
 8002248:	4618      	mov	r0, r3
 800224a:	f020 ffc0 	bl	80231ce <_lv_ll_get_head>
 800224e:	6178      	str	r0, [r7, #20]
 8002250:	e00a      	b.n	8002268 <lv_group_add_obj+0x38>
        if((*obj_i) == obj) {
 8002252:	697b      	ldr	r3, [r7, #20]
 8002254:	681b      	ldr	r3, [r3, #0]
 8002256:	683a      	ldr	r2, [r7, #0]
 8002258:	429a      	cmp	r2, r3
 800225a:	d048      	beq.n	80022ee <lv_group_add_obj+0xbe>
    _LV_LL_READ(&group->obj_ll, obj_i) {
 800225c:	687b      	ldr	r3, [r7, #4]
 800225e:	6979      	ldr	r1, [r7, #20]
 8002260:	4618      	mov	r0, r3
 8002262:	f020 ffd6 	bl	8023212 <_lv_ll_get_next>
 8002266:	6178      	str	r0, [r7, #20]
 8002268:	697b      	ldr	r3, [r7, #20]
 800226a:	2b00      	cmp	r3, #0
 800226c:	d1f1      	bne.n	8002252 <lv_group_add_obj+0x22>
            return;
        }
    }

    /*If the object is already in a group and focused then refocus it*/
    lv_group_t * group_cur = lv_obj_get_group(obj);
 800226e:	6838      	ldr	r0, [r7, #0]
 8002270:	f000 fda2 	bl	8002db8 <lv_obj_get_group>
 8002274:	6138      	str	r0, [r7, #16]
    if(group_cur) {
 8002276:	693b      	ldr	r3, [r7, #16]
 8002278:	2b00      	cmp	r3, #0
 800227a:	d00f      	beq.n	800229c <lv_group_add_obj+0x6c>
        if(obj->spec_attr->group_p && *(obj->spec_attr->group_p->obj_focus) == obj) {
 800227c:	683b      	ldr	r3, [r7, #0]
 800227e:	689b      	ldr	r3, [r3, #8]
 8002280:	685b      	ldr	r3, [r3, #4]
 8002282:	2b00      	cmp	r3, #0
 8002284:	d00a      	beq.n	800229c <lv_group_add_obj+0x6c>
 8002286:	683b      	ldr	r3, [r7, #0]
 8002288:	689b      	ldr	r3, [r3, #8]
 800228a:	685b      	ldr	r3, [r3, #4]
 800228c:	68db      	ldr	r3, [r3, #12]
 800228e:	681b      	ldr	r3, [r3, #0]
 8002290:	683a      	ldr	r2, [r7, #0]
 8002292:	429a      	cmp	r2, r3
 8002294:	d102      	bne.n	800229c <lv_group_add_obj+0x6c>
            lv_group_refocus(group_cur);
 8002296:	6938      	ldr	r0, [r7, #16]
 8002298:	f000 f909 	bl	80024ae <lv_group_refocus>

            LV_LOG_INFO("changing object's group");
        }
    }

    if(obj->spec_attr == NULL) lv_obj_allocate_spec_attr(obj);
 800229c:	683b      	ldr	r3, [r7, #0]
 800229e:	689b      	ldr	r3, [r3, #8]
 80022a0:	2b00      	cmp	r3, #0
 80022a2:	d102      	bne.n	80022aa <lv_group_add_obj+0x7a>
 80022a4:	6838      	ldr	r0, [r7, #0]
 80022a6:	f000 fd9a 	bl	8002dde <lv_obj_allocate_spec_attr>
    obj->spec_attr->group_p = group;
 80022aa:	683b      	ldr	r3, [r7, #0]
 80022ac:	689b      	ldr	r3, [r3, #8]
 80022ae:	687a      	ldr	r2, [r7, #4]
 80022b0:	605a      	str	r2, [r3, #4]

    lv_obj_t ** next = _lv_ll_ins_tail(&group->obj_ll);
 80022b2:	687b      	ldr	r3, [r7, #4]
 80022b4:	4618      	mov	r0, r3
 80022b6:	f020 fef9 	bl	80230ac <_lv_ll_ins_tail>
 80022ba:	60f8      	str	r0, [r7, #12]
    LV_ASSERT_MALLOC(next);
 80022bc:	68fb      	ldr	r3, [r7, #12]
 80022be:	2b00      	cmp	r3, #0
 80022c0:	d101      	bne.n	80022c6 <lv_group_add_obj+0x96>
 80022c2:	bf00      	nop
 80022c4:	e7fd      	b.n	80022c2 <lv_group_add_obj+0x92>
    if(next == NULL) return;
 80022c6:	68fb      	ldr	r3, [r7, #12]
 80022c8:	2b00      	cmp	r3, #0
 80022ca:	d012      	beq.n	80022f2 <lv_group_add_obj+0xc2>
    *next = obj;
 80022cc:	68fb      	ldr	r3, [r7, #12]
 80022ce:	683a      	ldr	r2, [r7, #0]
 80022d0:	601a      	str	r2, [r3, #0]

    /*If the head and the tail is equal then there is only one object in the linked list.
     *In this case automatically activate it*/
    if(_lv_ll_get_head(&group->obj_ll) == next) {
 80022d2:	687b      	ldr	r3, [r7, #4]
 80022d4:	4618      	mov	r0, r3
 80022d6:	f020 ff7a 	bl	80231ce <_lv_ll_get_head>
 80022da:	4602      	mov	r2, r0
 80022dc:	68fb      	ldr	r3, [r7, #12]
 80022de:	4293      	cmp	r3, r2
 80022e0:	d108      	bne.n	80022f4 <lv_group_add_obj+0xc4>
        lv_group_refocus(group);
 80022e2:	6878      	ldr	r0, [r7, #4]
 80022e4:	f000 f8e3 	bl	80024ae <lv_group_refocus>
 80022e8:	e004      	b.n	80022f4 <lv_group_add_obj+0xc4>
    if(group == NULL) return;
 80022ea:	bf00      	nop
 80022ec:	e002      	b.n	80022f4 <lv_group_add_obj+0xc4>
            return;
 80022ee:	bf00      	nop
 80022f0:	e000      	b.n	80022f4 <lv_group_add_obj+0xc4>
    if(next == NULL) return;
 80022f2:	bf00      	nop
    }

    LV_LOG_TRACE("finished");
}
 80022f4:	3718      	adds	r7, #24
 80022f6:	46bd      	mov	sp, r7
 80022f8:	bd80      	pop	{r7, pc}

080022fa <lv_group_remove_obj>:
    else if(*g1->obj_focus == obj2) lv_group_focus_obj(obj1);

}

void lv_group_remove_obj(lv_obj_t * obj)
{
 80022fa:	b590      	push	{r4, r7, lr}
 80022fc:	b085      	sub	sp, #20
 80022fe:	af00      	add	r7, sp, #0
 8002300:	6078      	str	r0, [r7, #4]
    lv_group_t * g = lv_obj_get_group(obj);
 8002302:	6878      	ldr	r0, [r7, #4]
 8002304:	f000 fd58 	bl	8002db8 <lv_obj_get_group>
 8002308:	60b8      	str	r0, [r7, #8]
    if(g == NULL) return;
 800230a:	68bb      	ldr	r3, [r7, #8]
 800230c:	2b00      	cmp	r3, #0
 800230e:	d06a      	beq.n	80023e6 <lv_group_remove_obj+0xec>

    LV_LOG_TRACE("begin");

    /*Focus on the next object*/
    if(g->obj_focus && *g->obj_focus == obj) {
 8002310:	68bb      	ldr	r3, [r7, #8]
 8002312:	68db      	ldr	r3, [r3, #12]
 8002314:	2b00      	cmp	r3, #0
 8002316:	d033      	beq.n	8002380 <lv_group_remove_obj+0x86>
 8002318:	68bb      	ldr	r3, [r7, #8]
 800231a:	68db      	ldr	r3, [r3, #12]
 800231c:	681b      	ldr	r3, [r3, #0]
 800231e:	687a      	ldr	r2, [r7, #4]
 8002320:	429a      	cmp	r2, r3
 8002322:	d12d      	bne.n	8002380 <lv_group_remove_obj+0x86>
        if(g->frozen) g->frozen = 0;
 8002324:	68bb      	ldr	r3, [r7, #8]
 8002326:	7f1b      	ldrb	r3, [r3, #28]
 8002328:	f003 0301 	and.w	r3, r3, #1
 800232c:	b2db      	uxtb	r3, r3
 800232e:	2b00      	cmp	r3, #0
 8002330:	d004      	beq.n	800233c <lv_group_remove_obj+0x42>
 8002332:	68ba      	ldr	r2, [r7, #8]
 8002334:	7f13      	ldrb	r3, [r2, #28]
 8002336:	f36f 0300 	bfc	r3, #0, #1
 800233a:	7713      	strb	r3, [r2, #28]

        /*If this is the only object in the group then focus to nothing.*/
        if(_lv_ll_get_head(&g->obj_ll) == g->obj_focus && _lv_ll_get_tail(&g->obj_ll) == g->obj_focus) {
 800233c:	68bb      	ldr	r3, [r7, #8]
 800233e:	4618      	mov	r0, r3
 8002340:	f020 ff45 	bl	80231ce <_lv_ll_get_head>
 8002344:	4602      	mov	r2, r0
 8002346:	68bb      	ldr	r3, [r7, #8]
 8002348:	68db      	ldr	r3, [r3, #12]
 800234a:	429a      	cmp	r2, r3
 800234c:	d115      	bne.n	800237a <lv_group_remove_obj+0x80>
 800234e:	68bb      	ldr	r3, [r7, #8]
 8002350:	4618      	mov	r0, r3
 8002352:	f020 ff4d 	bl	80231f0 <_lv_ll_get_tail>
 8002356:	4602      	mov	r2, r0
 8002358:	68bb      	ldr	r3, [r7, #8]
 800235a:	68db      	ldr	r3, [r3, #12]
 800235c:	429a      	cmp	r2, r3
 800235e:	d10c      	bne.n	800237a <lv_group_remove_obj+0x80>
            lv_obj_send_event(*g->obj_focus, LV_EVENT_DEFOCUSED, get_indev(g));
 8002360:	68bb      	ldr	r3, [r7, #8]
 8002362:	68db      	ldr	r3, [r3, #12]
 8002364:	681c      	ldr	r4, [r3, #0]
 8002366:	68b8      	ldr	r0, [r7, #8]
 8002368:	f000 f9a8 	bl	80026bc <get_indev>
 800236c:	4603      	mov	r3, r0
 800236e:	461a      	mov	r2, r3
 8002370:	2110      	movs	r1, #16
 8002372:	4620      	mov	r0, r4
 8002374:	f002 fd4e 	bl	8004e14 <lv_obj_send_event>
 8002378:	e002      	b.n	8002380 <lv_group_remove_obj+0x86>
        }
        /*If there more objects in the group then focus to the next/prev object*/
        else {
            lv_group_refocus(g);
 800237a:	68b8      	ldr	r0, [r7, #8]
 800237c:	f000 f897 	bl	80024ae <lv_group_refocus>
    }

    /*If the focuses object is still the same then it was the only object in the group but it will
     *be deleted. Set the `obj_focus` to NULL to get back to the initial state of the group with
     *zero objects*/
    if(g->obj_focus && *g->obj_focus == obj) {
 8002380:	68bb      	ldr	r3, [r7, #8]
 8002382:	68db      	ldr	r3, [r3, #12]
 8002384:	2b00      	cmp	r3, #0
 8002386:	d008      	beq.n	800239a <lv_group_remove_obj+0xa0>
 8002388:	68bb      	ldr	r3, [r7, #8]
 800238a:	68db      	ldr	r3, [r3, #12]
 800238c:	681b      	ldr	r3, [r3, #0]
 800238e:	687a      	ldr	r2, [r7, #4]
 8002390:	429a      	cmp	r2, r3
 8002392:	d102      	bne.n	800239a <lv_group_remove_obj+0xa0>
        g->obj_focus = NULL;
 8002394:	68bb      	ldr	r3, [r7, #8]
 8002396:	2200      	movs	r2, #0
 8002398:	60da      	str	r2, [r3, #12]
    }

    /*Search the object and remove it from its group*/
    lv_obj_t ** i;
    _LV_LL_READ(&g->obj_ll, i) {
 800239a:	68bb      	ldr	r3, [r7, #8]
 800239c:	4618      	mov	r0, r3
 800239e:	f020 ff16 	bl	80231ce <_lv_ll_get_head>
 80023a2:	60f8      	str	r0, [r7, #12]
 80023a4:	e01b      	b.n	80023de <lv_group_remove_obj+0xe4>
        if(*i == obj) {
 80023a6:	68fb      	ldr	r3, [r7, #12]
 80023a8:	681b      	ldr	r3, [r3, #0]
 80023aa:	687a      	ldr	r2, [r7, #4]
 80023ac:	429a      	cmp	r2, r3
 80023ae:	d110      	bne.n	80023d2 <lv_group_remove_obj+0xd8>
            _lv_ll_remove(&g->obj_ll, i);
 80023b0:	68bb      	ldr	r3, [r7, #8]
 80023b2:	68f9      	ldr	r1, [r7, #12]
 80023b4:	4618      	mov	r0, r3
 80023b6:	f020 fead 	bl	8023114 <_lv_ll_remove>
            lv_free(i);
 80023ba:	68f8      	ldr	r0, [r7, #12]
 80023bc:	f023 fd3c 	bl	8025e38 <lv_free>
            if(obj->spec_attr) obj->spec_attr->group_p = NULL;
 80023c0:	687b      	ldr	r3, [r7, #4]
 80023c2:	689b      	ldr	r3, [r3, #8]
 80023c4:	2b00      	cmp	r3, #0
 80023c6:	d010      	beq.n	80023ea <lv_group_remove_obj+0xf0>
 80023c8:	687b      	ldr	r3, [r7, #4]
 80023ca:	689b      	ldr	r3, [r3, #8]
 80023cc:	2200      	movs	r2, #0
 80023ce:	605a      	str	r2, [r3, #4]
            break;
 80023d0:	e00b      	b.n	80023ea <lv_group_remove_obj+0xf0>
    _LV_LL_READ(&g->obj_ll, i) {
 80023d2:	68bb      	ldr	r3, [r7, #8]
 80023d4:	68f9      	ldr	r1, [r7, #12]
 80023d6:	4618      	mov	r0, r3
 80023d8:	f020 ff1b 	bl	8023212 <_lv_ll_get_next>
 80023dc:	60f8      	str	r0, [r7, #12]
 80023de:	68fb      	ldr	r3, [r7, #12]
 80023e0:	2b00      	cmp	r3, #0
 80023e2:	d1e0      	bne.n	80023a6 <lv_group_remove_obj+0xac>
 80023e4:	e002      	b.n	80023ec <lv_group_remove_obj+0xf2>
    if(g == NULL) return;
 80023e6:	bf00      	nop
 80023e8:	e000      	b.n	80023ec <lv_group_remove_obj+0xf2>
            break;
 80023ea:	bf00      	nop
        }
    }
    LV_LOG_TRACE("finished");
}
 80023ec:	3714      	adds	r7, #20
 80023ee:	46bd      	mov	sp, r7
 80023f0:	bd90      	pop	{r4, r7, pc}
	...

080023f4 <lv_group_focus_next>:
        }
    }
}

void lv_group_focus_next(lv_group_t * group)
{
 80023f4:	b580      	push	{r7, lr}
 80023f6:	b084      	sub	sp, #16
 80023f8:	af00      	add	r7, sp, #0
 80023fa:	6078      	str	r0, [r7, #4]
    bool focus_changed = focus_next_core(group, _lv_ll_get_head, _lv_ll_get_next);
 80023fc:	4a0c      	ldr	r2, [pc, #48]	@ (8002430 <lv_group_focus_next+0x3c>)
 80023fe:	490d      	ldr	r1, [pc, #52]	@ (8002434 <lv_group_focus_next+0x40>)
 8002400:	6878      	ldr	r0, [r7, #4]
 8002402:	f000 f885 	bl	8002510 <focus_next_core>
 8002406:	4603      	mov	r3, r0
 8002408:	73fb      	strb	r3, [r7, #15]
    if(group->edge_cb) {
 800240a:	687b      	ldr	r3, [r7, #4]
 800240c:	695b      	ldr	r3, [r3, #20]
 800240e:	2b00      	cmp	r3, #0
 8002410:	d00a      	beq.n	8002428 <lv_group_focus_next+0x34>
        if(!focus_changed)
 8002412:	7bfb      	ldrb	r3, [r7, #15]
 8002414:	f083 0301 	eor.w	r3, r3, #1
 8002418:	b2db      	uxtb	r3, r3
 800241a:	2b00      	cmp	r3, #0
 800241c:	d004      	beq.n	8002428 <lv_group_focus_next+0x34>
            group->edge_cb(group, true);
 800241e:	687b      	ldr	r3, [r7, #4]
 8002420:	695b      	ldr	r3, [r3, #20]
 8002422:	2101      	movs	r1, #1
 8002424:	6878      	ldr	r0, [r7, #4]
 8002426:	4798      	blx	r3
    }
}
 8002428:	bf00      	nop
 800242a:	3710      	adds	r7, #16
 800242c:	46bd      	mov	sp, r7
 800242e:	bd80      	pop	{r7, pc}
 8002430:	08023213 	.word	0x08023213
 8002434:	080231cf 	.word	0x080231cf

08002438 <lv_group_focus_prev>:

void lv_group_focus_prev(lv_group_t * group)
{
 8002438:	b580      	push	{r7, lr}
 800243a:	b084      	sub	sp, #16
 800243c:	af00      	add	r7, sp, #0
 800243e:	6078      	str	r0, [r7, #4]
    bool focus_changed = focus_next_core(group, _lv_ll_get_tail, _lv_ll_get_prev);
 8002440:	4a0c      	ldr	r2, [pc, #48]	@ (8002474 <lv_group_focus_prev+0x3c>)
 8002442:	490d      	ldr	r1, [pc, #52]	@ (8002478 <lv_group_focus_prev+0x40>)
 8002444:	6878      	ldr	r0, [r7, #4]
 8002446:	f000 f863 	bl	8002510 <focus_next_core>
 800244a:	4603      	mov	r3, r0
 800244c:	73fb      	strb	r3, [r7, #15]
    if(group->edge_cb) {
 800244e:	687b      	ldr	r3, [r7, #4]
 8002450:	695b      	ldr	r3, [r3, #20]
 8002452:	2b00      	cmp	r3, #0
 8002454:	d00a      	beq.n	800246c <lv_group_focus_prev+0x34>
        if(!focus_changed)
 8002456:	7bfb      	ldrb	r3, [r7, #15]
 8002458:	f083 0301 	eor.w	r3, r3, #1
 800245c:	b2db      	uxtb	r3, r3
 800245e:	2b00      	cmp	r3, #0
 8002460:	d004      	beq.n	800246c <lv_group_focus_prev+0x34>
            group->edge_cb(group, false);
 8002462:	687b      	ldr	r3, [r7, #4]
 8002464:	695b      	ldr	r3, [r3, #20]
 8002466:	2100      	movs	r1, #0
 8002468:	6878      	ldr	r0, [r7, #4]
 800246a:	4798      	blx	r3
    }
}
 800246c:	bf00      	nop
 800246e:	3710      	adds	r7, #16
 8002470:	46bd      	mov	sp, r7
 8002472:	bd80      	pop	{r7, pc}
 8002474:	0802323d 	.word	0x0802323d
 8002478:	080231f1 	.word	0x080231f1

0800247c <lv_group_get_editing>:
    if(!group) return NULL;
    return group->edge_cb;
}

bool lv_group_get_editing(const lv_group_t * group)
{
 800247c:	b480      	push	{r7}
 800247e:	b083      	sub	sp, #12
 8002480:	af00      	add	r7, sp, #0
 8002482:	6078      	str	r0, [r7, #4]
    if(!group) return false;
 8002484:	687b      	ldr	r3, [r7, #4]
 8002486:	2b00      	cmp	r3, #0
 8002488:	d101      	bne.n	800248e <lv_group_get_editing+0x12>
 800248a:	2300      	movs	r3, #0
 800248c:	e009      	b.n	80024a2 <lv_group_get_editing+0x26>
    return group->editing;
 800248e:	687b      	ldr	r3, [r7, #4]
 8002490:	7f1b      	ldrb	r3, [r3, #28]
 8002492:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8002496:	b2db      	uxtb	r3, r3
 8002498:	2b00      	cmp	r3, #0
 800249a:	bf14      	ite	ne
 800249c:	2301      	movne	r3, #1
 800249e:	2300      	moveq	r3, #0
 80024a0:	b2db      	uxtb	r3, r3
}
 80024a2:	4618      	mov	r0, r3
 80024a4:	370c      	adds	r7, #12
 80024a6:	46bd      	mov	sp, r7
 80024a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80024ac:	4770      	bx	lr

080024ae <lv_group_refocus>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void lv_group_refocus(lv_group_t * g)
{
 80024ae:	b580      	push	{r7, lr}
 80024b0:	b084      	sub	sp, #16
 80024b2:	af00      	add	r7, sp, #0
 80024b4:	6078      	str	r0, [r7, #4]
    /*Refocus must temporarily allow wrapping to work correctly*/
    uint8_t temp_wrap = g->wrap;
 80024b6:	687b      	ldr	r3, [r7, #4]
 80024b8:	7f1b      	ldrb	r3, [r3, #28]
 80024ba:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 80024be:	b2db      	uxtb	r3, r3
 80024c0:	73fb      	strb	r3, [r7, #15]
    g->wrap           = 1;
 80024c2:	687a      	ldr	r2, [r7, #4]
 80024c4:	7f13      	ldrb	r3, [r2, #28]
 80024c6:	f043 0308 	orr.w	r3, r3, #8
 80024ca:	7713      	strb	r3, [r2, #28]

    if(g->refocus_policy == LV_GROUP_REFOCUS_POLICY_NEXT)
 80024cc:	687b      	ldr	r3, [r7, #4]
 80024ce:	7f1b      	ldrb	r3, [r3, #28]
 80024d0:	f003 0304 	and.w	r3, r3, #4
 80024d4:	b2db      	uxtb	r3, r3
 80024d6:	2b00      	cmp	r3, #0
 80024d8:	d103      	bne.n	80024e2 <lv_group_refocus+0x34>
        lv_group_focus_next(g);
 80024da:	6878      	ldr	r0, [r7, #4]
 80024dc:	f7ff ff8a 	bl	80023f4 <lv_group_focus_next>
 80024e0:	e009      	b.n	80024f6 <lv_group_refocus+0x48>
    else if(g->refocus_policy == LV_GROUP_REFOCUS_POLICY_PREV)
 80024e2:	687b      	ldr	r3, [r7, #4]
 80024e4:	7f1b      	ldrb	r3, [r3, #28]
 80024e6:	f003 0304 	and.w	r3, r3, #4
 80024ea:	b2db      	uxtb	r3, r3
 80024ec:	2b00      	cmp	r3, #0
 80024ee:	d002      	beq.n	80024f6 <lv_group_refocus+0x48>
        lv_group_focus_prev(g);
 80024f0:	6878      	ldr	r0, [r7, #4]
 80024f2:	f7ff ffa1 	bl	8002438 <lv_group_focus_prev>
    /*Restore wrap property*/
    g->wrap = temp_wrap;
 80024f6:	7bfb      	ldrb	r3, [r7, #15]
 80024f8:	f003 0301 	and.w	r3, r3, #1
 80024fc:	b2d9      	uxtb	r1, r3
 80024fe:	687a      	ldr	r2, [r7, #4]
 8002500:	7f13      	ldrb	r3, [r2, #28]
 8002502:	f361 03c3 	bfi	r3, r1, #3, #1
 8002506:	7713      	strb	r3, [r2, #28]
}
 8002508:	bf00      	nop
 800250a:	3710      	adds	r7, #16
 800250c:	46bd      	mov	sp, r7
 800250e:	bd80      	pop	{r7, pc}

08002510 <focus_next_core>:

static bool focus_next_core(lv_group_t * group, void * (*begin)(const lv_ll_t *),
                            void * (*move)(const lv_ll_t *, const void *))
{
 8002510:	b590      	push	{r4, r7, lr}
 8002512:	b08b      	sub	sp, #44	@ 0x2c
 8002514:	af00      	add	r7, sp, #0
 8002516:	60f8      	str	r0, [r7, #12]
 8002518:	60b9      	str	r1, [r7, #8]
 800251a:	607a      	str	r2, [r7, #4]
    bool focus_changed = false;
 800251c:	2300      	movs	r3, #0
 800251e:	75fb      	strb	r3, [r7, #23]
    if(group->frozen) return focus_changed;
 8002520:	68fb      	ldr	r3, [r7, #12]
 8002522:	7f1b      	ldrb	r3, [r3, #28]
 8002524:	f003 0301 	and.w	r3, r3, #1
 8002528:	b2db      	uxtb	r3, r3
 800252a:	2b00      	cmp	r3, #0
 800252c:	d001      	beq.n	8002532 <focus_next_core+0x22>
 800252e:	7dfb      	ldrb	r3, [r7, #23]
 8002530:	e0c0      	b.n	80026b4 <focus_next_core+0x1a4>

    lv_obj_t ** obj_next     = group->obj_focus;
 8002532:	68fb      	ldr	r3, [r7, #12]
 8002534:	68db      	ldr	r3, [r3, #12]
 8002536:	627b      	str	r3, [r7, #36]	@ 0x24
    lv_obj_t ** obj_sentinel = NULL;
 8002538:	2300      	movs	r3, #0
 800253a:	623b      	str	r3, [r7, #32]
    bool can_move            = true;
 800253c:	2301      	movs	r3, #1
 800253e:	77fb      	strb	r3, [r7, #31]
    bool can_begin           = true;
 8002540:	2301      	movs	r3, #1
 8002542:	77bb      	strb	r3, [r7, #30]

    for(;;) {
        if(obj_next == NULL) {
 8002544:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002546:	2b00      	cmp	r3, #0
 8002548:	d11d      	bne.n	8002586 <focus_next_core+0x76>
            if(group->wrap || obj_sentinel == NULL) {
 800254a:	68fb      	ldr	r3, [r7, #12]
 800254c:	7f1b      	ldrb	r3, [r3, #28]
 800254e:	f003 0308 	and.w	r3, r3, #8
 8002552:	b2db      	uxtb	r3, r3
 8002554:	2b00      	cmp	r3, #0
 8002556:	d102      	bne.n	800255e <focus_next_core+0x4e>
 8002558:	6a3b      	ldr	r3, [r7, #32]
 800255a:	2b00      	cmp	r3, #0
 800255c:	d111      	bne.n	8002582 <focus_next_core+0x72>
                if(!can_begin) return focus_changed;
 800255e:	7fbb      	ldrb	r3, [r7, #30]
 8002560:	f083 0301 	eor.w	r3, r3, #1
 8002564:	b2db      	uxtb	r3, r3
 8002566:	2b00      	cmp	r3, #0
 8002568:	d001      	beq.n	800256e <focus_next_core+0x5e>
 800256a:	7dfb      	ldrb	r3, [r7, #23]
 800256c:	e0a2      	b.n	80026b4 <focus_next_core+0x1a4>
                obj_next  = begin(&group->obj_ll);
 800256e:	68fa      	ldr	r2, [r7, #12]
 8002570:	68bb      	ldr	r3, [r7, #8]
 8002572:	4610      	mov	r0, r2
 8002574:	4798      	blx	r3
 8002576:	6278      	str	r0, [r7, #36]	@ 0x24
                can_move  = false;
 8002578:	2300      	movs	r3, #0
 800257a:	77fb      	strb	r3, [r7, #31]
                can_begin = false;
 800257c:	2300      	movs	r3, #0
 800257e:	77bb      	strb	r3, [r7, #30]
 8002580:	e001      	b.n	8002586 <focus_next_core+0x76>
            }
            else {
                /*Currently focused object is the last/first in the group, keep it that way*/
                return focus_changed;
 8002582:	7dfb      	ldrb	r3, [r7, #23]
 8002584:	e096      	b.n	80026b4 <focus_next_core+0x1a4>
            }
        }

        if(obj_sentinel == NULL) {
 8002586:	6a3b      	ldr	r3, [r7, #32]
 8002588:	2b00      	cmp	r3, #0
 800258a:	d106      	bne.n	800259a <focus_next_core+0x8a>
            obj_sentinel = obj_next;
 800258c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800258e:	623b      	str	r3, [r7, #32]
            if(obj_sentinel == NULL) return focus_changed; /*Group is empty*/
 8002590:	6a3b      	ldr	r3, [r7, #32]
 8002592:	2b00      	cmp	r3, #0
 8002594:	d101      	bne.n	800259a <focus_next_core+0x8a>
 8002596:	7dfb      	ldrb	r3, [r7, #23]
 8002598:	e08c      	b.n	80026b4 <focus_next_core+0x1a4>
        }

        if(can_move) {
 800259a:	7ffb      	ldrb	r3, [r7, #31]
 800259c:	2b00      	cmp	r3, #0
 800259e:	d00b      	beq.n	80025b8 <focus_next_core+0xa8>
            obj_next = move(&group->obj_ll, obj_next);
 80025a0:	68fa      	ldr	r2, [r7, #12]
 80025a2:	687b      	ldr	r3, [r7, #4]
 80025a4:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80025a6:	4610      	mov	r0, r2
 80025a8:	4798      	blx	r3
 80025aa:	6278      	str	r0, [r7, #36]	@ 0x24

            /*Give up if we walked the entire list and haven't found another visible object*/
            if(obj_next == obj_sentinel) return focus_changed;
 80025ac:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80025ae:	6a3b      	ldr	r3, [r7, #32]
 80025b0:	429a      	cmp	r2, r3
 80025b2:	d101      	bne.n	80025b8 <focus_next_core+0xa8>
 80025b4:	7dfb      	ldrb	r3, [r7, #23]
 80025b6:	e07d      	b.n	80026b4 <focus_next_core+0x1a4>
        }

        can_move = true;
 80025b8:	2301      	movs	r3, #1
 80025ba:	77fb      	strb	r3, [r7, #31]

        if(obj_next == NULL) continue;
 80025bc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80025be:	2b00      	cmp	r3, #0
 80025c0:	d028      	beq.n	8002614 <focus_next_core+0x104>
        if(lv_obj_get_state(*obj_next) & LV_STATE_DISABLED) continue;
 80025c2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80025c4:	681b      	ldr	r3, [r3, #0]
 80025c6:	4618      	mov	r0, r3
 80025c8:	f000 fbea 	bl	8002da0 <lv_obj_get_state>
 80025cc:	4603      	mov	r3, r0
 80025ce:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80025d2:	2b00      	cmp	r3, #0
 80025d4:	d120      	bne.n	8002618 <focus_next_core+0x108>

        /*Hidden objects don't receive focus.
         *If any parent is hidden, the object is also hidden)*/
        lv_obj_t * parent = *obj_next;
 80025d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80025d8:	681b      	ldr	r3, [r3, #0]
 80025da:	61bb      	str	r3, [r7, #24]
        while(parent) {
 80025dc:	e00a      	b.n	80025f4 <focus_next_core+0xe4>
            if(lv_obj_has_flag(parent, LV_OBJ_FLAG_HIDDEN)) break;
 80025de:	2101      	movs	r1, #1
 80025e0:	69b8      	ldr	r0, [r7, #24]
 80025e2:	f000 fbb4 	bl	8002d4e <lv_obj_has_flag>
 80025e6:	4603      	mov	r3, r0
 80025e8:	2b00      	cmp	r3, #0
 80025ea:	d107      	bne.n	80025fc <focus_next_core+0xec>
            parent = lv_obj_get_parent(parent);
 80025ec:	69b8      	ldr	r0, [r7, #24]
 80025ee:	f008 fc21 	bl	800ae34 <lv_obj_get_parent>
 80025f2:	61b8      	str	r0, [r7, #24]
        while(parent) {
 80025f4:	69bb      	ldr	r3, [r7, #24]
 80025f6:	2b00      	cmp	r3, #0
 80025f8:	d1f1      	bne.n	80025de <focus_next_core+0xce>
 80025fa:	e000      	b.n	80025fe <focus_next_core+0xee>
            if(lv_obj_has_flag(parent, LV_OBJ_FLAG_HIDDEN)) break;
 80025fc:	bf00      	nop
        }

        if(parent && lv_obj_has_flag(parent, LV_OBJ_FLAG_HIDDEN)) continue;
 80025fe:	69bb      	ldr	r3, [r7, #24]
 8002600:	2b00      	cmp	r3, #0
 8002602:	d00b      	beq.n	800261c <focus_next_core+0x10c>
 8002604:	2101      	movs	r1, #1
 8002606:	69b8      	ldr	r0, [r7, #24]
 8002608:	f000 fba1 	bl	8002d4e <lv_obj_has_flag>
 800260c:	4603      	mov	r3, r0
 800260e:	2b00      	cmp	r3, #0
 8002610:	d004      	beq.n	800261c <focus_next_core+0x10c>
 8002612:	e002      	b.n	800261a <focus_next_core+0x10a>
        if(obj_next == NULL) continue;
 8002614:	bf00      	nop
 8002616:	e795      	b.n	8002544 <focus_next_core+0x34>
        if(lv_obj_get_state(*obj_next) & LV_STATE_DISABLED) continue;
 8002618:	bf00      	nop
    for(;;) {
 800261a:	e793      	b.n	8002544 <focus_next_core+0x34>

        /*If we got her a good candidate is found*/
        break;
 800261c:	bf00      	nop
    }

    if(obj_next == group->obj_focus) return focus_changed; /*There's only one visible object and it's already focused*/
 800261e:	68fb      	ldr	r3, [r7, #12]
 8002620:	68db      	ldr	r3, [r3, #12]
 8002622:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8002624:	429a      	cmp	r2, r3
 8002626:	d101      	bne.n	800262c <focus_next_core+0x11c>
 8002628:	7dfb      	ldrb	r3, [r7, #23]
 800262a:	e043      	b.n	80026b4 <focus_next_core+0x1a4>

    if(group->obj_focus) {
 800262c:	68fb      	ldr	r3, [r7, #12]
 800262e:	68db      	ldr	r3, [r3, #12]
 8002630:	2b00      	cmp	r3, #0
 8002632:	d018      	beq.n	8002666 <focus_next_core+0x156>
        lv_result_t res = lv_obj_send_event(*group->obj_focus, LV_EVENT_DEFOCUSED, get_indev(group));
 8002634:	68fb      	ldr	r3, [r7, #12]
 8002636:	68db      	ldr	r3, [r3, #12]
 8002638:	681c      	ldr	r4, [r3, #0]
 800263a:	68f8      	ldr	r0, [r7, #12]
 800263c:	f000 f83e 	bl	80026bc <get_indev>
 8002640:	4603      	mov	r3, r0
 8002642:	461a      	mov	r2, r3
 8002644:	2110      	movs	r1, #16
 8002646:	4620      	mov	r0, r4
 8002648:	f002 fbe4 	bl	8004e14 <lv_obj_send_event>
 800264c:	4603      	mov	r3, r0
 800264e:	75bb      	strb	r3, [r7, #22]
        if(res != LV_RESULT_OK) return focus_changed;
 8002650:	7dbb      	ldrb	r3, [r7, #22]
 8002652:	2b01      	cmp	r3, #1
 8002654:	d001      	beq.n	800265a <focus_next_core+0x14a>
 8002656:	7dfb      	ldrb	r3, [r7, #23]
 8002658:	e02c      	b.n	80026b4 <focus_next_core+0x1a4>
        lv_obj_invalidate(*group->obj_focus);
 800265a:	68fb      	ldr	r3, [r7, #12]
 800265c:	68db      	ldr	r3, [r3, #12]
 800265e:	681b      	ldr	r3, [r3, #0]
 8002660:	4618      	mov	r0, r3
 8002662:	f003 ffed 	bl	8006640 <lv_obj_invalidate>
    }

    group->obj_focus = obj_next;
 8002666:	68fb      	ldr	r3, [r7, #12]
 8002668:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800266a:	60da      	str	r2, [r3, #12]

    lv_result_t res = lv_obj_send_event(*group->obj_focus, LV_EVENT_FOCUSED, get_indev(group));
 800266c:	68fb      	ldr	r3, [r7, #12]
 800266e:	68db      	ldr	r3, [r3, #12]
 8002670:	681c      	ldr	r4, [r3, #0]
 8002672:	68f8      	ldr	r0, [r7, #12]
 8002674:	f000 f822 	bl	80026bc <get_indev>
 8002678:	4603      	mov	r3, r0
 800267a:	461a      	mov	r2, r3
 800267c:	210f      	movs	r1, #15
 800267e:	4620      	mov	r0, r4
 8002680:	f002 fbc8 	bl	8004e14 <lv_obj_send_event>
 8002684:	4603      	mov	r3, r0
 8002686:	757b      	strb	r3, [r7, #21]
    if(res != LV_RESULT_OK) return focus_changed;
 8002688:	7d7b      	ldrb	r3, [r7, #21]
 800268a:	2b01      	cmp	r3, #1
 800268c:	d001      	beq.n	8002692 <focus_next_core+0x182>
 800268e:	7dfb      	ldrb	r3, [r7, #23]
 8002690:	e010      	b.n	80026b4 <focus_next_core+0x1a4>

    lv_obj_invalidate(*group->obj_focus);
 8002692:	68fb      	ldr	r3, [r7, #12]
 8002694:	68db      	ldr	r3, [r3, #12]
 8002696:	681b      	ldr	r3, [r3, #0]
 8002698:	4618      	mov	r0, r3
 800269a:	f003 ffd1 	bl	8006640 <lv_obj_invalidate>

    if(group->focus_cb) group->focus_cb(group);
 800269e:	68fb      	ldr	r3, [r7, #12]
 80026a0:	691b      	ldr	r3, [r3, #16]
 80026a2:	2b00      	cmp	r3, #0
 80026a4:	d003      	beq.n	80026ae <focus_next_core+0x19e>
 80026a6:	68fb      	ldr	r3, [r7, #12]
 80026a8:	691b      	ldr	r3, [r3, #16]
 80026aa:	68f8      	ldr	r0, [r7, #12]
 80026ac:	4798      	blx	r3
    focus_changed = true;
 80026ae:	2301      	movs	r3, #1
 80026b0:	75fb      	strb	r3, [r7, #23]
    return focus_changed;
 80026b2:	7dfb      	ldrb	r3, [r7, #23]
}
 80026b4:	4618      	mov	r0, r3
 80026b6:	372c      	adds	r7, #44	@ 0x2c
 80026b8:	46bd      	mov	sp, r7
 80026ba:	bd90      	pop	{r4, r7, pc}

080026bc <get_indev>:
 * In the worst case simply return the latest indev
 * @param g     a group the find in the indevs
 * @return      the suggested indev
 */
static lv_indev_t * get_indev(const lv_group_t * g)
{
 80026bc:	b580      	push	{r7, lr}
 80026be:	b086      	sub	sp, #24
 80026c0:	af00      	add	r7, sp, #0
 80026c2:	6078      	str	r0, [r7, #4]
    lv_indev_t * indev_guess = NULL;
 80026c4:	2300      	movs	r3, #0
 80026c6:	617b      	str	r3, [r7, #20]
    lv_indev_t * indev = lv_indev_get_next(NULL);
 80026c8:	2000      	movs	r0, #0
 80026ca:	f01a fb77 	bl	801cdbc <lv_indev_get_next>
 80026ce:	6138      	str	r0, [r7, #16]

    while(indev) {
 80026d0:	e016      	b.n	8002700 <get_indev+0x44>
        lv_indev_type_t indev_type = lv_indev_get_type(indev);
 80026d2:	6938      	ldr	r0, [r7, #16]
 80026d4:	f01a fb96 	bl	801ce04 <lv_indev_get_type>
 80026d8:	4603      	mov	r3, r0
 80026da:	73fb      	strb	r3, [r7, #15]
        /*Prefer POINTER*/
        if(indev_type == LV_INDEV_TYPE_POINTER) return indev;
 80026dc:	7bfb      	ldrb	r3, [r7, #15]
 80026de:	2b01      	cmp	r3, #1
 80026e0:	d101      	bne.n	80026e6 <get_indev+0x2a>
 80026e2:	693b      	ldr	r3, [r7, #16]
 80026e4:	e010      	b.n	8002708 <get_indev+0x4c>
        if(lv_indev_get_group(indev) == g) {
 80026e6:	6938      	ldr	r0, [r7, #16]
 80026e8:	f01a fb9d 	bl	801ce26 <lv_indev_get_group>
 80026ec:	4602      	mov	r2, r0
 80026ee:	687b      	ldr	r3, [r7, #4]
 80026f0:	4293      	cmp	r3, r2
 80026f2:	d101      	bne.n	80026f8 <get_indev+0x3c>
            indev_guess = indev;
 80026f4:	693b      	ldr	r3, [r7, #16]
 80026f6:	617b      	str	r3, [r7, #20]
        }
        indev = lv_indev_get_next(indev);
 80026f8:	6938      	ldr	r0, [r7, #16]
 80026fa:	f01a fb5f 	bl	801cdbc <lv_indev_get_next>
 80026fe:	6138      	str	r0, [r7, #16]
    while(indev) {
 8002700:	693b      	ldr	r3, [r7, #16]
 8002702:	2b00      	cmp	r3, #0
 8002704:	d1e5      	bne.n	80026d2 <get_indev+0x16>
    }

    return indev_guess;
 8002706:	697b      	ldr	r3, [r7, #20]
}
 8002708:	4618      	mov	r0, r3
 800270a:	3718      	adds	r7, #24
 800270c:	46bd      	mov	sp, r7
 800270e:	bd80      	pop	{r7, pc}

08002710 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 8002710:	b480      	push	{r7}
 8002712:	b083      	sub	sp, #12
 8002714:	af00      	add	r7, sp, #0
 8002716:	6078      	str	r0, [r7, #4]
 8002718:	6039      	str	r1, [r7, #0]
    dest->x1 = src->x1;
 800271a:	683b      	ldr	r3, [r7, #0]
 800271c:	681a      	ldr	r2, [r3, #0]
 800271e:	687b      	ldr	r3, [r7, #4]
 8002720:	601a      	str	r2, [r3, #0]
    dest->y1 = src->y1;
 8002722:	683b      	ldr	r3, [r7, #0]
 8002724:	685a      	ldr	r2, [r3, #4]
 8002726:	687b      	ldr	r3, [r7, #4]
 8002728:	605a      	str	r2, [r3, #4]
    dest->x2 = src->x2;
 800272a:	683b      	ldr	r3, [r7, #0]
 800272c:	689a      	ldr	r2, [r3, #8]
 800272e:	687b      	ldr	r3, [r7, #4]
 8002730:	609a      	str	r2, [r3, #8]
    dest->y2 = src->y2;
 8002732:	683b      	ldr	r3, [r7, #0]
 8002734:	68da      	ldr	r2, [r3, #12]
 8002736:	687b      	ldr	r3, [r7, #4]
 8002738:	60da      	str	r2, [r3, #12]
}
 800273a:	bf00      	nop
 800273c:	370c      	adds	r7, #12
 800273e:	46bd      	mov	sp, r7
 8002740:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002744:	4770      	bx	lr

08002746 <lv_style_is_const>:
 * Check if a style is constant
 * @param style     pointer to a style
 * @return          true: the style is constant
 */
static inline bool lv_style_is_const(const lv_style_t * style)
{
 8002746:	b480      	push	{r7}
 8002748:	b083      	sub	sp, #12
 800274a:	af00      	add	r7, sp, #0
 800274c:	6078      	str	r0, [r7, #4]
    if(style->prop_cnt == 255) return true;
 800274e:	687b      	ldr	r3, [r7, #4]
 8002750:	7a1b      	ldrb	r3, [r3, #8]
 8002752:	2bff      	cmp	r3, #255	@ 0xff
 8002754:	d101      	bne.n	800275a <lv_style_is_const+0x14>
 8002756:	2301      	movs	r3, #1
 8002758:	e000      	b.n	800275c <lv_style_is_const+0x16>
    return false;
 800275a:	2300      	movs	r3, #0
}
 800275c:	4618      	mov	r0, r3
 800275e:	370c      	adds	r7, #12
 8002760:	46bd      	mov	sp, r7
 8002762:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002766:	4770      	bx	lr

08002768 <lv_style_get_prop_inlined>:
 * @note For performance reasons there are no sanity check on `style`
 * @note This function is the same as ::lv_style_get_prop but inlined. Use it only on performance critical places
 */
static inline lv_style_res_t lv_style_get_prop_inlined(const lv_style_t * style, lv_style_prop_t prop,
                                                       lv_style_value_t * value)
{
 8002768:	b580      	push	{r7, lr}
 800276a:	b08a      	sub	sp, #40	@ 0x28
 800276c:	af00      	add	r7, sp, #0
 800276e:	60f8      	str	r0, [r7, #12]
 8002770:	460b      	mov	r3, r1
 8002772:	607a      	str	r2, [r7, #4]
 8002774:	72fb      	strb	r3, [r7, #11]
    if(lv_style_is_const(style)) {
 8002776:	68f8      	ldr	r0, [r7, #12]
 8002778:	f7ff ffe5 	bl	8002746 <lv_style_is_const>
 800277c:	4603      	mov	r3, r0
 800277e:	2b00      	cmp	r3, #0
 8002780:	d022      	beq.n	80027c8 <lv_style_get_prop_inlined+0x60>
        lv_style_const_prop_t * props = (lv_style_const_prop_t *)style->values_and_props;
 8002782:	68fb      	ldr	r3, [r7, #12]
 8002784:	681b      	ldr	r3, [r3, #0]
 8002786:	617b      	str	r3, [r7, #20]
        uint32_t i;
        for(i = 0; props[i].prop_ptr; i++) {
 8002788:	2300      	movs	r3, #0
 800278a:	627b      	str	r3, [r7, #36]	@ 0x24
 800278c:	e014      	b.n	80027b8 <lv_style_get_prop_inlined+0x50>
            if(*props[i].prop_ptr == prop) {
 800278e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002790:	00db      	lsls	r3, r3, #3
 8002792:	697a      	ldr	r2, [r7, #20]
 8002794:	4413      	add	r3, r2
 8002796:	681b      	ldr	r3, [r3, #0]
 8002798:	781b      	ldrb	r3, [r3, #0]
 800279a:	7afa      	ldrb	r2, [r7, #11]
 800279c:	429a      	cmp	r2, r3
 800279e:	d108      	bne.n	80027b2 <lv_style_get_prop_inlined+0x4a>
                *value = props[i].value;
 80027a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80027a2:	00db      	lsls	r3, r3, #3
 80027a4:	697a      	ldr	r2, [r7, #20]
 80027a6:	441a      	add	r2, r3
 80027a8:	687b      	ldr	r3, [r7, #4]
 80027aa:	6852      	ldr	r2, [r2, #4]
 80027ac:	601a      	str	r2, [r3, #0]
                return LV_STYLE_RES_FOUND;
 80027ae:	2301      	movs	r3, #1
 80027b0:	e031      	b.n	8002816 <lv_style_get_prop_inlined+0xae>
        for(i = 0; props[i].prop_ptr; i++) {
 80027b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80027b4:	3301      	adds	r3, #1
 80027b6:	627b      	str	r3, [r7, #36]	@ 0x24
 80027b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80027ba:	00db      	lsls	r3, r3, #3
 80027bc:	697a      	ldr	r2, [r7, #20]
 80027be:	4413      	add	r3, r2
 80027c0:	681b      	ldr	r3, [r3, #0]
 80027c2:	2b00      	cmp	r3, #0
 80027c4:	d1e3      	bne.n	800278e <lv_style_get_prop_inlined+0x26>
 80027c6:	e025      	b.n	8002814 <lv_style_get_prop_inlined+0xac>
            }
        }
    }
    else {
        lv_style_prop_t * props = (lv_style_prop_t *)style->values_and_props + style->prop_cnt * sizeof(lv_style_value_t);
 80027c8:	68fb      	ldr	r3, [r7, #12]
 80027ca:	681a      	ldr	r2, [r3, #0]
 80027cc:	68fb      	ldr	r3, [r7, #12]
 80027ce:	7a1b      	ldrb	r3, [r3, #8]
 80027d0:	009b      	lsls	r3, r3, #2
 80027d2:	4413      	add	r3, r2
 80027d4:	61fb      	str	r3, [r7, #28]
        uint32_t i;
        for(i = 0; i < style->prop_cnt; i++) {
 80027d6:	2300      	movs	r3, #0
 80027d8:	623b      	str	r3, [r7, #32]
 80027da:	e015      	b.n	8002808 <lv_style_get_prop_inlined+0xa0>
            if(props[i] == prop) {
 80027dc:	69fa      	ldr	r2, [r7, #28]
 80027de:	6a3b      	ldr	r3, [r7, #32]
 80027e0:	4413      	add	r3, r2
 80027e2:	781b      	ldrb	r3, [r3, #0]
 80027e4:	7afa      	ldrb	r2, [r7, #11]
 80027e6:	429a      	cmp	r2, r3
 80027e8:	d10b      	bne.n	8002802 <lv_style_get_prop_inlined+0x9a>
                lv_style_value_t * values = (lv_style_value_t *)style->values_and_props;
 80027ea:	68fb      	ldr	r3, [r7, #12]
 80027ec:	681b      	ldr	r3, [r3, #0]
 80027ee:	61bb      	str	r3, [r7, #24]
                *value = values[i];
 80027f0:	6a3b      	ldr	r3, [r7, #32]
 80027f2:	009b      	lsls	r3, r3, #2
 80027f4:	69ba      	ldr	r2, [r7, #24]
 80027f6:	441a      	add	r2, r3
 80027f8:	687b      	ldr	r3, [r7, #4]
 80027fa:	6812      	ldr	r2, [r2, #0]
 80027fc:	601a      	str	r2, [r3, #0]
                return LV_STYLE_RES_FOUND;
 80027fe:	2301      	movs	r3, #1
 8002800:	e009      	b.n	8002816 <lv_style_get_prop_inlined+0xae>
        for(i = 0; i < style->prop_cnt; i++) {
 8002802:	6a3b      	ldr	r3, [r7, #32]
 8002804:	3301      	adds	r3, #1
 8002806:	623b      	str	r3, [r7, #32]
 8002808:	68fb      	ldr	r3, [r7, #12]
 800280a:	7a1b      	ldrb	r3, [r3, #8]
 800280c:	461a      	mov	r2, r3
 800280e:	6a3b      	ldr	r3, [r7, #32]
 8002810:	4293      	cmp	r3, r2
 8002812:	d3e3      	bcc.n	80027dc <lv_style_get_prop_inlined+0x74>
            }
        }
    }
    return LV_STYLE_RES_NOT_FOUND;
 8002814:	2300      	movs	r3, #0
}
 8002816:	4618      	mov	r0, r3
 8002818:	3728      	adds	r7, #40	@ 0x28
 800281a:	46bd      	mov	sp, r7
 800281c:	bd80      	pop	{r7, pc}

0800281e <lv_obj_style_get_selector_state>:
 * @param delay     delay to start the animation
 */
void lv_obj_fade_out(lv_obj_t * obj, uint32_t time, uint32_t delay);

static inline lv_state_t lv_obj_style_get_selector_state(lv_style_selector_t selector)
{
 800281e:	b480      	push	{r7}
 8002820:	b083      	sub	sp, #12
 8002822:	af00      	add	r7, sp, #0
 8002824:	6078      	str	r0, [r7, #4]
    return selector & 0xFFFF;
 8002826:	687b      	ldr	r3, [r7, #4]
 8002828:	b29b      	uxth	r3, r3
}
 800282a:	4618      	mov	r0, r3
 800282c:	370c      	adds	r7, #12
 800282e:	46bd      	mov	sp, r7
 8002830:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002834:	4770      	bx	lr

08002836 <lv_obj_style_get_selector_part>:

static inline lv_part_t lv_obj_style_get_selector_part(lv_style_selector_t selector)
{
 8002836:	b480      	push	{r7}
 8002838:	b083      	sub	sp, #12
 800283a:	af00      	add	r7, sp, #0
 800283c:	6078      	str	r0, [r7, #4]
    return selector & 0xFF0000;
 800283e:	687b      	ldr	r3, [r7, #4]
 8002840:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
}
 8002844:	4618      	mov	r0, r3
 8002846:	370c      	adds	r7, #12
 8002848:	46bd      	mov	sp, r7
 800284a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800284e:	4770      	bx	lr

08002850 <lv_obj_get_style_width>:
#include "../misc/lv_area.h"
#include "../misc/lv_style.h"
#include "../core/lv_obj_style.h"

static inline int32_t lv_obj_get_style_width(const lv_obj_t * obj, uint32_t part)
{
 8002850:	b580      	push	{r7, lr}
 8002852:	b084      	sub	sp, #16
 8002854:	af00      	add	r7, sp, #0
 8002856:	6078      	str	r0, [r7, #4]
 8002858:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_WIDTH);
 800285a:	2201      	movs	r2, #1
 800285c:	6839      	ldr	r1, [r7, #0]
 800285e:	6878      	ldr	r0, [r7, #4]
 8002860:	f006 ff62 	bl	8009728 <lv_obj_get_style_prop>
 8002864:	4603      	mov	r3, r0
 8002866:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8002868:	68fb      	ldr	r3, [r7, #12]
}
 800286a:	4618      	mov	r0, r3
 800286c:	3710      	adds	r7, #16
 800286e:	46bd      	mov	sp, r7
 8002870:	bd80      	pop	{r7, pc}

08002872 <lv_obj_get_style_height>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MAX_WIDTH);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_height(const lv_obj_t * obj, uint32_t part)
{
 8002872:	b580      	push	{r7, lr}
 8002874:	b084      	sub	sp, #16
 8002876:	af00      	add	r7, sp, #0
 8002878:	6078      	str	r0, [r7, #4]
 800287a:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_HEIGHT);
 800287c:	2202      	movs	r2, #2
 800287e:	6839      	ldr	r1, [r7, #0]
 8002880:	6878      	ldr	r0, [r7, #4]
 8002882:	f006 ff51 	bl	8009728 <lv_obj_get_style_prop>
 8002886:	4603      	mov	r3, r0
 8002888:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 800288a:	68fb      	ldr	r3, [r7, #12]
}
 800288c:	4618      	mov	r0, r3
 800288e:	3710      	adds	r7, #16
 8002890:	46bd      	mov	sp, r7
 8002892:	bd80      	pop	{r7, pc}

08002894 <lv_obj_get_style_align>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_Y);
    return (int32_t)v.num;
}

static inline lv_align_t lv_obj_get_style_align(const lv_obj_t * obj, uint32_t part)
{
 8002894:	b580      	push	{r7, lr}
 8002896:	b084      	sub	sp, #16
 8002898:	af00      	add	r7, sp, #0
 800289a:	6078      	str	r0, [r7, #4]
 800289c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ALIGN);
 800289e:	220a      	movs	r2, #10
 80028a0:	6839      	ldr	r1, [r7, #0]
 80028a2:	6878      	ldr	r0, [r7, #4]
 80028a4:	f006 ff40 	bl	8009728 <lv_obj_get_style_prop>
 80028a8:	4603      	mov	r3, r0
 80028aa:	60fb      	str	r3, [r7, #12]
    return (lv_align_t)v.num;
 80028ac:	68fb      	ldr	r3, [r7, #12]
 80028ae:	b2db      	uxtb	r3, r3
}
 80028b0:	4618      	mov	r0, r3
 80028b2:	3710      	adds	r7, #16
 80028b4:	46bd      	mov	sp, r7
 80028b6:	bd80      	pop	{r7, pc}

080028b8 <lv_obj_get_style_transform_width>:

static inline int32_t lv_obj_get_style_transform_width(const lv_obj_t * obj, uint32_t part)
{
 80028b8:	b580      	push	{r7, lr}
 80028ba:	b084      	sub	sp, #16
 80028bc:	af00      	add	r7, sp, #0
 80028be:	6078      	str	r0, [r7, #4]
 80028c0:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_WIDTH);
 80028c2:	2268      	movs	r2, #104	@ 0x68
 80028c4:	6839      	ldr	r1, [r7, #0]
 80028c6:	6878      	ldr	r0, [r7, #4]
 80028c8:	f006 ff2e 	bl	8009728 <lv_obj_get_style_prop>
 80028cc:	4603      	mov	r3, r0
 80028ce:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80028d0:	68fb      	ldr	r3, [r7, #12]
}
 80028d2:	4618      	mov	r0, r3
 80028d4:	3710      	adds	r7, #16
 80028d6:	46bd      	mov	sp, r7
 80028d8:	bd80      	pop	{r7, pc}

080028da <lv_obj_get_style_transform_height>:

static inline int32_t lv_obj_get_style_transform_height(const lv_obj_t * obj, uint32_t part)
{
 80028da:	b580      	push	{r7, lr}
 80028dc:	b084      	sub	sp, #16
 80028de:	af00      	add	r7, sp, #0
 80028e0:	6078      	str	r0, [r7, #4]
 80028e2:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_HEIGHT);
 80028e4:	2269      	movs	r2, #105	@ 0x69
 80028e6:	6839      	ldr	r1, [r7, #0]
 80028e8:	6878      	ldr	r0, [r7, #4]
 80028ea:	f006 ff1d 	bl	8009728 <lv_obj_get_style_prop>
 80028ee:	4603      	mov	r3, r0
 80028f0:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80028f2:	68fb      	ldr	r3, [r7, #12]
}
 80028f4:	4618      	mov	r0, r3
 80028f6:	3710      	adds	r7, #16
 80028f8:	46bd      	mov	sp, r7
 80028fa:	bd80      	pop	{r7, pc}

080028fc <lv_obj_get_style_pad_top>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_SKEW_Y);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_pad_top(const lv_obj_t * obj, uint32_t part)
{
 80028fc:	b580      	push	{r7, lr}
 80028fe:	b084      	sub	sp, #16
 8002900:	af00      	add	r7, sp, #0
 8002902:	6078      	str	r0, [r7, #4]
 8002904:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_TOP);
 8002906:	2210      	movs	r2, #16
 8002908:	6839      	ldr	r1, [r7, #0]
 800290a:	6878      	ldr	r0, [r7, #4]
 800290c:	f006 ff0c 	bl	8009728 <lv_obj_get_style_prop>
 8002910:	4603      	mov	r3, r0
 8002912:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8002914:	68fb      	ldr	r3, [r7, #12]
}
 8002916:	4618      	mov	r0, r3
 8002918:	3710      	adds	r7, #16
 800291a:	46bd      	mov	sp, r7
 800291c:	bd80      	pop	{r7, pc}

0800291e <lv_obj_get_style_pad_left>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_BOTTOM);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_pad_left(const lv_obj_t * obj, uint32_t part)
{
 800291e:	b580      	push	{r7, lr}
 8002920:	b084      	sub	sp, #16
 8002922:	af00      	add	r7, sp, #0
 8002924:	6078      	str	r0, [r7, #4]
 8002926:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_LEFT);
 8002928:	2212      	movs	r2, #18
 800292a:	6839      	ldr	r1, [r7, #0]
 800292c:	6878      	ldr	r0, [r7, #4]
 800292e:	f006 fefb 	bl	8009728 <lv_obj_get_style_prop>
 8002932:	4603      	mov	r3, r0
 8002934:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8002936:	68fb      	ldr	r3, [r7, #12]
}
 8002938:	4618      	mov	r0, r3
 800293a:	3710      	adds	r7, #16
 800293c:	46bd      	mov	sp, r7
 800293e:	bd80      	pop	{r7, pc}

08002940 <lv_obj_get_style_bg_color>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_RIGHT);
    return (int32_t)v.num;
}

static inline lv_color_t lv_obj_get_style_bg_color(const lv_obj_t * obj, uint32_t part)
{
 8002940:	b580      	push	{r7, lr}
 8002942:	b084      	sub	sp, #16
 8002944:	af00      	add	r7, sp, #0
 8002946:	6078      	str	r0, [r7, #4]
 8002948:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_COLOR);
 800294a:	221c      	movs	r2, #28
 800294c:	6839      	ldr	r1, [r7, #0]
 800294e:	6878      	ldr	r0, [r7, #4]
 8002950:	f006 feea 	bl	8009728 <lv_obj_get_style_prop>
 8002954:	4603      	mov	r3, r0
 8002956:	60bb      	str	r3, [r7, #8]
    return v.color;
 8002958:	f107 030c 	add.w	r3, r7, #12
 800295c:	f107 0208 	add.w	r2, r7, #8
 8002960:	6812      	ldr	r2, [r2, #0]
 8002962:	4611      	mov	r1, r2
 8002964:	8019      	strh	r1, [r3, #0]
 8002966:	3302      	adds	r3, #2
 8002968:	0c12      	lsrs	r2, r2, #16
 800296a:	701a      	strb	r2, [r3, #0]
 800296c:	2300      	movs	r3, #0
 800296e:	7b3a      	ldrb	r2, [r7, #12]
 8002970:	f362 0307 	bfi	r3, r2, #0, #8
 8002974:	7b7a      	ldrb	r2, [r7, #13]
 8002976:	f362 230f 	bfi	r3, r2, #8, #8
 800297a:	7bba      	ldrb	r2, [r7, #14]
 800297c:	f362 4317 	bfi	r3, r2, #16, #8
}
 8002980:	4618      	mov	r0, r3
 8002982:	3710      	adds	r7, #16
 8002984:	46bd      	mov	sp, r7
 8002986:	bd80      	pop	{r7, pc}

08002988 <lv_obj_get_style_bg_opa>:
    lv_style_value_t v = _lv_obj_style_apply_color_filter(obj, part, lv_obj_get_style_prop(obj, part, LV_STYLE_BG_COLOR));
    return v.color;
}

static inline lv_opa_t lv_obj_get_style_bg_opa(const lv_obj_t * obj, uint32_t part)
{
 8002988:	b580      	push	{r7, lr}
 800298a:	b084      	sub	sp, #16
 800298c:	af00      	add	r7, sp, #0
 800298e:	6078      	str	r0, [r7, #4]
 8002990:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_OPA);
 8002992:	221d      	movs	r2, #29
 8002994:	6839      	ldr	r1, [r7, #0]
 8002996:	6878      	ldr	r0, [r7, #4]
 8002998:	f006 fec6 	bl	8009728 <lv_obj_get_style_prop>
 800299c:	4603      	mov	r3, r0
 800299e:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 80029a0:	68fb      	ldr	r3, [r7, #12]
 80029a2:	b2db      	uxtb	r3, r3
}
 80029a4:	4618      	mov	r0, r3
 80029a6:	3710      	adds	r7, #16
 80029a8:	46bd      	mov	sp, r7
 80029aa:	bd80      	pop	{r7, pc}

080029ac <lv_obj_get_style_bg_grad_dir>:
    lv_style_value_t v = _lv_obj_style_apply_color_filter(obj, part, lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD_COLOR));
    return v.color;
}

static inline lv_grad_dir_t lv_obj_get_style_bg_grad_dir(const lv_obj_t * obj, uint32_t part)
{
 80029ac:	b580      	push	{r7, lr}
 80029ae:	b084      	sub	sp, #16
 80029b0:	af00      	add	r7, sp, #0
 80029b2:	6078      	str	r0, [r7, #4]
 80029b4:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD_DIR);
 80029b6:	2220      	movs	r2, #32
 80029b8:	6839      	ldr	r1, [r7, #0]
 80029ba:	6878      	ldr	r0, [r7, #4]
 80029bc:	f006 feb4 	bl	8009728 <lv_obj_get_style_prop>
 80029c0:	4603      	mov	r3, r0
 80029c2:	60fb      	str	r3, [r7, #12]
    return (lv_grad_dir_t)v.num;
 80029c4:	68fb      	ldr	r3, [r7, #12]
 80029c6:	b2db      	uxtb	r3, r3
}
 80029c8:	4618      	mov	r0, r3
 80029ca:	3710      	adds	r7, #16
 80029cc:	46bd      	mov	sp, r7
 80029ce:	bd80      	pop	{r7, pc}

080029d0 <lv_obj_get_style_bg_grad_opa>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_MAIN_OPA);
    return (lv_opa_t)v.num;
}

static inline lv_opa_t lv_obj_get_style_bg_grad_opa(const lv_obj_t * obj, uint32_t part)
{
 80029d0:	b580      	push	{r7, lr}
 80029d2:	b084      	sub	sp, #16
 80029d4:	af00      	add	r7, sp, #0
 80029d6:	6078      	str	r0, [r7, #4]
 80029d8:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD_OPA);
 80029da:	2225      	movs	r2, #37	@ 0x25
 80029dc:	6839      	ldr	r1, [r7, #0]
 80029de:	6878      	ldr	r0, [r7, #4]
 80029e0:	f006 fea2 	bl	8009728 <lv_obj_get_style_prop>
 80029e4:	4603      	mov	r3, r0
 80029e6:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 80029e8:	68fb      	ldr	r3, [r7, #12]
 80029ea:	b2db      	uxtb	r3, r3
}
 80029ec:	4618      	mov	r0, r3
 80029ee:	3710      	adds	r7, #16
 80029f0:	46bd      	mov	sp, r7
 80029f2:	bd80      	pop	{r7, pc}

080029f4 <lv_obj_get_style_bg_grad>:

static inline const lv_grad_dsc_t * lv_obj_get_style_bg_grad(const lv_obj_t * obj, uint32_t part)
{
 80029f4:	b580      	push	{r7, lr}
 80029f6:	b084      	sub	sp, #16
 80029f8:	af00      	add	r7, sp, #0
 80029fa:	6078      	str	r0, [r7, #4]
 80029fc:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD);
 80029fe:	2226      	movs	r2, #38	@ 0x26
 8002a00:	6839      	ldr	r1, [r7, #0]
 8002a02:	6878      	ldr	r0, [r7, #4]
 8002a04:	f006 fe90 	bl	8009728 <lv_obj_get_style_prop>
 8002a08:	4603      	mov	r3, r0
 8002a0a:	60fb      	str	r3, [r7, #12]
    return (const lv_grad_dsc_t *)v.ptr;
 8002a0c:	68fb      	ldr	r3, [r7, #12]
}
 8002a0e:	4618      	mov	r0, r3
 8002a10:	3710      	adds	r7, #16
 8002a12:	46bd      	mov	sp, r7
 8002a14:	bd80      	pop	{r7, pc}

08002a16 <lv_obj_get_style_border_color>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_IMAGE_TILED);
    return (bool)v.num;
}

static inline lv_color_t lv_obj_get_style_border_color(const lv_obj_t * obj, uint32_t part)
{
 8002a16:	b580      	push	{r7, lr}
 8002a18:	b084      	sub	sp, #16
 8002a1a:	af00      	add	r7, sp, #0
 8002a1c:	6078      	str	r0, [r7, #4]
 8002a1e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_COLOR);
 8002a20:	2231      	movs	r2, #49	@ 0x31
 8002a22:	6839      	ldr	r1, [r7, #0]
 8002a24:	6878      	ldr	r0, [r7, #4]
 8002a26:	f006 fe7f 	bl	8009728 <lv_obj_get_style_prop>
 8002a2a:	4603      	mov	r3, r0
 8002a2c:	60bb      	str	r3, [r7, #8]
    return v.color;
 8002a2e:	f107 030c 	add.w	r3, r7, #12
 8002a32:	f107 0208 	add.w	r2, r7, #8
 8002a36:	6812      	ldr	r2, [r2, #0]
 8002a38:	4611      	mov	r1, r2
 8002a3a:	8019      	strh	r1, [r3, #0]
 8002a3c:	3302      	adds	r3, #2
 8002a3e:	0c12      	lsrs	r2, r2, #16
 8002a40:	701a      	strb	r2, [r3, #0]
 8002a42:	2300      	movs	r3, #0
 8002a44:	7b3a      	ldrb	r2, [r7, #12]
 8002a46:	f362 0307 	bfi	r3, r2, #0, #8
 8002a4a:	7b7a      	ldrb	r2, [r7, #13]
 8002a4c:	f362 230f 	bfi	r3, r2, #8, #8
 8002a50:	7bba      	ldrb	r2, [r7, #14]
 8002a52:	f362 4317 	bfi	r3, r2, #16, #8
}
 8002a56:	4618      	mov	r0, r3
 8002a58:	3710      	adds	r7, #16
 8002a5a:	46bd      	mov	sp, r7
 8002a5c:	bd80      	pop	{r7, pc}

08002a5e <lv_obj_get_style_border_opa>:
    lv_style_value_t v = _lv_obj_style_apply_color_filter(obj, part, lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_COLOR));
    return v.color;
}

static inline lv_opa_t lv_obj_get_style_border_opa(const lv_obj_t * obj, uint32_t part)
{
 8002a5e:	b580      	push	{r7, lr}
 8002a60:	b084      	sub	sp, #16
 8002a62:	af00      	add	r7, sp, #0
 8002a64:	6078      	str	r0, [r7, #4]
 8002a66:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_OPA);
 8002a68:	2232      	movs	r2, #50	@ 0x32
 8002a6a:	6839      	ldr	r1, [r7, #0]
 8002a6c:	6878      	ldr	r0, [r7, #4]
 8002a6e:	f006 fe5b 	bl	8009728 <lv_obj_get_style_prop>
 8002a72:	4603      	mov	r3, r0
 8002a74:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 8002a76:	68fb      	ldr	r3, [r7, #12]
 8002a78:	b2db      	uxtb	r3, r3
}
 8002a7a:	4618      	mov	r0, r3
 8002a7c:	3710      	adds	r7, #16
 8002a7e:	46bd      	mov	sp, r7
 8002a80:	bd80      	pop	{r7, pc}

08002a82 <lv_obj_get_style_border_width>:

static inline int32_t lv_obj_get_style_border_width(const lv_obj_t * obj, uint32_t part)
{
 8002a82:	b580      	push	{r7, lr}
 8002a84:	b084      	sub	sp, #16
 8002a86:	af00      	add	r7, sp, #0
 8002a88:	6078      	str	r0, [r7, #4]
 8002a8a:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_WIDTH);
 8002a8c:	2230      	movs	r2, #48	@ 0x30
 8002a8e:	6839      	ldr	r1, [r7, #0]
 8002a90:	6878      	ldr	r0, [r7, #4]
 8002a92:	f006 fe49 	bl	8009728 <lv_obj_get_style_prop>
 8002a96:	4603      	mov	r3, r0
 8002a98:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8002a9a:	68fb      	ldr	r3, [r7, #12]
}
 8002a9c:	4618      	mov	r0, r3
 8002a9e:	3710      	adds	r7, #16
 8002aa0:	46bd      	mov	sp, r7
 8002aa2:	bd80      	pop	{r7, pc}

08002aa4 <lv_obj_get_style_border_post>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_SIDE);
    return (lv_border_side_t)v.num;
}

static inline bool lv_obj_get_style_border_post(const lv_obj_t * obj, uint32_t part)
{
 8002aa4:	b580      	push	{r7, lr}
 8002aa6:	b084      	sub	sp, #16
 8002aa8:	af00      	add	r7, sp, #0
 8002aaa:	6078      	str	r0, [r7, #4]
 8002aac:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_POST);
 8002aae:	2235      	movs	r2, #53	@ 0x35
 8002ab0:	6839      	ldr	r1, [r7, #0]
 8002ab2:	6878      	ldr	r0, [r7, #4]
 8002ab4:	f006 fe38 	bl	8009728 <lv_obj_get_style_prop>
 8002ab8:	4603      	mov	r3, r0
 8002aba:	60fb      	str	r3, [r7, #12]
    return (bool)v.num;
 8002abc:	68fb      	ldr	r3, [r7, #12]
 8002abe:	2b00      	cmp	r3, #0
 8002ac0:	bf14      	ite	ne
 8002ac2:	2301      	movne	r3, #1
 8002ac4:	2300      	moveq	r3, #0
 8002ac6:	b2db      	uxtb	r3, r3
}
 8002ac8:	4618      	mov	r0, r3
 8002aca:	3710      	adds	r7, #16
 8002acc:	46bd      	mov	sp, r7
 8002ace:	bd80      	pop	{r7, pc}

08002ad0 <lv_obj_get_style_shadow_width>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OUTLINE_PAD);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_shadow_width(const lv_obj_t * obj, uint32_t part)
{
 8002ad0:	b580      	push	{r7, lr}
 8002ad2:	b084      	sub	sp, #16
 8002ad4:	af00      	add	r7, sp, #0
 8002ad6:	6078      	str	r0, [r7, #4]
 8002ad8:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_WIDTH);
 8002ada:	223c      	movs	r2, #60	@ 0x3c
 8002adc:	6839      	ldr	r1, [r7, #0]
 8002ade:	6878      	ldr	r0, [r7, #4]
 8002ae0:	f006 fe22 	bl	8009728 <lv_obj_get_style_prop>
 8002ae4:	4603      	mov	r3, r0
 8002ae6:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8002ae8:	68fb      	ldr	r3, [r7, #12]
}
 8002aea:	4618      	mov	r0, r3
 8002aec:	3710      	adds	r7, #16
 8002aee:	46bd      	mov	sp, r7
 8002af0:	bd80      	pop	{r7, pc}

08002af2 <lv_obj_get_style_shadow_spread>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_OFFSET_Y);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_shadow_spread(const lv_obj_t * obj, uint32_t part)
{
 8002af2:	b580      	push	{r7, lr}
 8002af4:	b084      	sub	sp, #16
 8002af6:	af00      	add	r7, sp, #0
 8002af8:	6078      	str	r0, [r7, #4]
 8002afa:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_SPREAD);
 8002afc:	2242      	movs	r2, #66	@ 0x42
 8002afe:	6839      	ldr	r1, [r7, #0]
 8002b00:	6878      	ldr	r0, [r7, #4]
 8002b02:	f006 fe11 	bl	8009728 <lv_obj_get_style_prop>
 8002b06:	4603      	mov	r3, r0
 8002b08:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8002b0a:	68fb      	ldr	r3, [r7, #12]
}
 8002b0c:	4618      	mov	r0, r3
 8002b0e:	3710      	adds	r7, #16
 8002b10:	46bd      	mov	sp, r7
 8002b12:	bd80      	pop	{r7, pc}

08002b14 <lv_obj_get_style_shadow_color>:

static inline lv_color_t lv_obj_get_style_shadow_color(const lv_obj_t * obj, uint32_t part)
{
 8002b14:	b580      	push	{r7, lr}
 8002b16:	b084      	sub	sp, #16
 8002b18:	af00      	add	r7, sp, #0
 8002b1a:	6078      	str	r0, [r7, #4]
 8002b1c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_COLOR);
 8002b1e:	223d      	movs	r2, #61	@ 0x3d
 8002b20:	6839      	ldr	r1, [r7, #0]
 8002b22:	6878      	ldr	r0, [r7, #4]
 8002b24:	f006 fe00 	bl	8009728 <lv_obj_get_style_prop>
 8002b28:	4603      	mov	r3, r0
 8002b2a:	60bb      	str	r3, [r7, #8]
    return v.color;
 8002b2c:	f107 030c 	add.w	r3, r7, #12
 8002b30:	f107 0208 	add.w	r2, r7, #8
 8002b34:	6812      	ldr	r2, [r2, #0]
 8002b36:	4611      	mov	r1, r2
 8002b38:	8019      	strh	r1, [r3, #0]
 8002b3a:	3302      	adds	r3, #2
 8002b3c:	0c12      	lsrs	r2, r2, #16
 8002b3e:	701a      	strb	r2, [r3, #0]
 8002b40:	2300      	movs	r3, #0
 8002b42:	7b3a      	ldrb	r2, [r7, #12]
 8002b44:	f362 0307 	bfi	r3, r2, #0, #8
 8002b48:	7b7a      	ldrb	r2, [r7, #13]
 8002b4a:	f362 230f 	bfi	r3, r2, #8, #8
 8002b4e:	7bba      	ldrb	r2, [r7, #14]
 8002b50:	f362 4317 	bfi	r3, r2, #16, #8
}
 8002b54:	4618      	mov	r0, r3
 8002b56:	3710      	adds	r7, #16
 8002b58:	46bd      	mov	sp, r7
 8002b5a:	bd80      	pop	{r7, pc}

08002b5c <lv_obj_get_style_shadow_opa>:
    lv_style_value_t v = _lv_obj_style_apply_color_filter(obj, part, lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_COLOR));
    return v.color;
}

static inline lv_opa_t lv_obj_get_style_shadow_opa(const lv_obj_t * obj, uint32_t part)
{
 8002b5c:	b580      	push	{r7, lr}
 8002b5e:	b084      	sub	sp, #16
 8002b60:	af00      	add	r7, sp, #0
 8002b62:	6078      	str	r0, [r7, #4]
 8002b64:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_OPA);
 8002b66:	223e      	movs	r2, #62	@ 0x3e
 8002b68:	6839      	ldr	r1, [r7, #0]
 8002b6a:	6878      	ldr	r0, [r7, #4]
 8002b6c:	f006 fddc 	bl	8009728 <lv_obj_get_style_prop>
 8002b70:	4603      	mov	r3, r0
 8002b72:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 8002b74:	68fb      	ldr	r3, [r7, #12]
 8002b76:	b2db      	uxtb	r3, r3
}
 8002b78:	4618      	mov	r0, r3
 8002b7a:	3710      	adds	r7, #16
 8002b7c:	46bd      	mov	sp, r7
 8002b7e:	bd80      	pop	{r7, pc}

08002b80 <lv_obj_get_style_radius>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_ALIGN);
    return (lv_text_align_t)v.num;
}

static inline int32_t lv_obj_get_style_radius(const lv_obj_t * obj, uint32_t part)
{
 8002b80:	b580      	push	{r7, lr}
 8002b82:	b084      	sub	sp, #16
 8002b84:	af00      	add	r7, sp, #0
 8002b86:	6078      	str	r0, [r7, #4]
 8002b88:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_RADIUS);
 8002b8a:	220c      	movs	r2, #12
 8002b8c:	6839      	ldr	r1, [r7, #0]
 8002b8e:	6878      	ldr	r0, [r7, #4]
 8002b90:	f006 fdca 	bl	8009728 <lv_obj_get_style_prop>
 8002b94:	4603      	mov	r3, r0
 8002b96:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8002b98:	68fb      	ldr	r3, [r7, #12]
}
 8002b9a:	4618      	mov	r0, r3
 8002b9c:	3710      	adds	r7, #16
 8002b9e:	46bd      	mov	sp, r7
 8002ba0:	bd80      	pop	{r7, pc}

08002ba2 <lv_obj_get_style_clip_corner>:

static inline bool lv_obj_get_style_clip_corner(const lv_obj_t * obj, uint32_t part)
{
 8002ba2:	b580      	push	{r7, lr}
 8002ba4:	b084      	sub	sp, #16
 8002ba6:	af00      	add	r7, sp, #0
 8002ba8:	6078      	str	r0, [r7, #4]
 8002baa:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_CLIP_CORNER);
 8002bac:	222d      	movs	r2, #45	@ 0x2d
 8002bae:	6839      	ldr	r1, [r7, #0]
 8002bb0:	6878      	ldr	r0, [r7, #4]
 8002bb2:	f006 fdb9 	bl	8009728 <lv_obj_get_style_prop>
 8002bb6:	4603      	mov	r3, r0
 8002bb8:	60fb      	str	r3, [r7, #12]
    return (bool)v.num;
 8002bba:	68fb      	ldr	r3, [r7, #12]
 8002bbc:	2b00      	cmp	r3, #0
 8002bbe:	bf14      	ite	ne
 8002bc0:	2301      	movne	r3, #1
 8002bc2:	2300      	moveq	r3, #0
 8002bc4:	b2db      	uxtb	r3, r3
}
 8002bc6:	4618      	mov	r0, r3
 8002bc8:	3710      	adds	r7, #16
 8002bca:	46bd      	mov	sp, r7
 8002bcc:	bd80      	pop	{r7, pc}

08002bce <lv_obj_get_style_opa>:

static inline lv_opa_t lv_obj_get_style_opa(const lv_obj_t * obj, uint32_t part)
{
 8002bce:	b580      	push	{r7, lr}
 8002bd0:	b084      	sub	sp, #16
 8002bd2:	af00      	add	r7, sp, #0
 8002bd4:	6078      	str	r0, [r7, #4]
 8002bd6:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OPA);
 8002bd8:	225f      	movs	r2, #95	@ 0x5f
 8002bda:	6839      	ldr	r1, [r7, #0]
 8002bdc:	6878      	ldr	r0, [r7, #4]
 8002bde:	f006 fda3 	bl	8009728 <lv_obj_get_style_prop>
 8002be2:	4603      	mov	r3, r0
 8002be4:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 8002be6:	68fb      	ldr	r3, [r7, #12]
 8002be8:	b2db      	uxtb	r3, r3
}
 8002bea:	4618      	mov	r0, r3
 8002bec:	3710      	adds	r7, #16
 8002bee:	46bd      	mov	sp, r7
 8002bf0:	bd80      	pop	{r7, pc}

08002bf2 <lv_obj_get_style_layout>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BLEND_MODE);
    return (lv_blend_mode_t)v.num;
}

static inline uint16_t lv_obj_get_style_layout(const lv_obj_t * obj, uint32_t part)
{
 8002bf2:	b580      	push	{r7, lr}
 8002bf4:	b084      	sub	sp, #16
 8002bf6:	af00      	add	r7, sp, #0
 8002bf8:	6078      	str	r0, [r7, #4]
 8002bfa:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LAYOUT);
 8002bfc:	2216      	movs	r2, #22
 8002bfe:	6839      	ldr	r1, [r7, #0]
 8002c00:	6878      	ldr	r0, [r7, #4]
 8002c02:	f006 fd91 	bl	8009728 <lv_obj_get_style_prop>
 8002c06:	4603      	mov	r3, r0
 8002c08:	60fb      	str	r3, [r7, #12]
    return (uint16_t)v.num;
 8002c0a:	68fb      	ldr	r3, [r7, #12]
 8002c0c:	b29b      	uxth	r3, r3
}
 8002c0e:	4618      	mov	r0, r3
 8002c10:	3710      	adds	r7, #16
 8002c12:	46bd      	mov	sp, r7
 8002c14:	bd80      	pop	{r7, pc}

08002c16 <lv_obj_remove_flag>:
        lv_obj_invalidate_area(obj, &ver_area);
    }
}

void lv_obj_remove_flag(lv_obj_t * obj, lv_obj_flag_t f)
{
 8002c16:	b580      	push	{r7, lr}
 8002c18:	b08c      	sub	sp, #48	@ 0x30
 8002c1a:	af00      	add	r7, sp, #0
 8002c1c:	6078      	str	r0, [r7, #4]
 8002c1e:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    bool was_on_layout = lv_obj_is_layout_positioned(obj);
 8002c20:	6878      	ldr	r0, [r7, #4]
 8002c22:	f002 ffe3 	bl	8005bec <lv_obj_is_layout_positioned>
 8002c26:	4603      	mov	r3, r0
 8002c28:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if(f & LV_OBJ_FLAG_SCROLLABLE) {
 8002c2c:	683b      	ldr	r3, [r7, #0]
 8002c2e:	f003 0310 	and.w	r3, r3, #16
 8002c32:	2b00      	cmp	r3, #0
 8002c34:	d013      	beq.n	8002c5e <lv_obj_remove_flag+0x48>
        lv_area_t hor_area, ver_area;
        lv_obj_get_scrollbar_area(obj, &hor_area, &ver_area);
 8002c36:	f107 020c 	add.w	r2, r7, #12
 8002c3a:	f107 031c 	add.w	r3, r7, #28
 8002c3e:	4619      	mov	r1, r3
 8002c40:	6878      	ldr	r0, [r7, #4]
 8002c42:	f004 ffe1 	bl	8007c08 <lv_obj_get_scrollbar_area>
        lv_obj_invalidate_area(obj, &hor_area);
 8002c46:	f107 031c 	add.w	r3, r7, #28
 8002c4a:	4619      	mov	r1, r3
 8002c4c:	6878      	ldr	r0, [r7, #4]
 8002c4e:	f003 fcc2 	bl	80065d6 <lv_obj_invalidate_area>
        lv_obj_invalidate_area(obj, &ver_area);
 8002c52:	f107 030c 	add.w	r3, r7, #12
 8002c56:	4619      	mov	r1, r3
 8002c58:	6878      	ldr	r0, [r7, #4]
 8002c5a:	f003 fcbc 	bl	80065d6 <lv_obj_invalidate_area>
    }

    obj->flags &= (~f);
 8002c5e:	687b      	ldr	r3, [r7, #4]
 8002c60:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8002c62:	683b      	ldr	r3, [r7, #0]
 8002c64:	43db      	mvns	r3, r3
 8002c66:	401a      	ands	r2, r3
 8002c68:	687b      	ldr	r3, [r7, #4]
 8002c6a:	625a      	str	r2, [r3, #36]	@ 0x24

    if(f & LV_OBJ_FLAG_HIDDEN) {
 8002c6c:	683b      	ldr	r3, [r7, #0]
 8002c6e:	f003 0301 	and.w	r3, r3, #1
 8002c72:	2b00      	cmp	r3, #0
 8002c74:	d012      	beq.n	8002c9c <lv_obj_remove_flag+0x86>
        lv_obj_invalidate(obj);
 8002c76:	6878      	ldr	r0, [r7, #4]
 8002c78:	f003 fce2 	bl	8006640 <lv_obj_invalidate>
        if(lv_obj_is_layout_positioned(obj)) {
 8002c7c:	6878      	ldr	r0, [r7, #4]
 8002c7e:	f002 ffb5 	bl	8005bec <lv_obj_is_layout_positioned>
 8002c82:	4603      	mov	r3, r0
 8002c84:	2b00      	cmp	r3, #0
 8002c86:	d009      	beq.n	8002c9c <lv_obj_remove_flag+0x86>
            lv_obj_mark_layout_as_dirty(lv_obj_get_parent(obj));
 8002c88:	6878      	ldr	r0, [r7, #4]
 8002c8a:	f008 f8d3 	bl	800ae34 <lv_obj_get_parent>
 8002c8e:	4603      	mov	r3, r0
 8002c90:	4618      	mov	r0, r3
 8002c92:	f002 ffd3 	bl	8005c3c <lv_obj_mark_layout_as_dirty>
            lv_obj_mark_layout_as_dirty(obj);
 8002c96:	6878      	ldr	r0, [r7, #4]
 8002c98:	f002 ffd0 	bl	8005c3c <lv_obj_mark_layout_as_dirty>
        }
    }

    if((was_on_layout != lv_obj_is_layout_positioned(obj)) || (f & (LV_OBJ_FLAG_LAYOUT_1 |  LV_OBJ_FLAG_LAYOUT_2))) {
 8002c9c:	6878      	ldr	r0, [r7, #4]
 8002c9e:	f002 ffa5 	bl	8005bec <lv_obj_is_layout_positioned>
 8002ca2:	4603      	mov	r3, r0
 8002ca4:	461a      	mov	r2, r3
 8002ca6:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8002caa:	4293      	cmp	r3, r2
 8002cac:	d104      	bne.n	8002cb8 <lv_obj_remove_flag+0xa2>
 8002cae:	683b      	ldr	r3, [r7, #0]
 8002cb0:	f003 73c0 	and.w	r3, r3, #25165824	@ 0x1800000
 8002cb4:	2b00      	cmp	r3, #0
 8002cb6:	d006      	beq.n	8002cc6 <lv_obj_remove_flag+0xb0>
        lv_obj_mark_layout_as_dirty(lv_obj_get_parent(obj));
 8002cb8:	6878      	ldr	r0, [r7, #4]
 8002cba:	f008 f8bb 	bl	800ae34 <lv_obj_get_parent>
 8002cbe:	4603      	mov	r3, r0
 8002cc0:	4618      	mov	r0, r3
 8002cc2:	f002 ffbb 	bl	8005c3c <lv_obj_mark_layout_as_dirty>
    }

}
 8002cc6:	bf00      	nop
 8002cc8:	3730      	adds	r7, #48	@ 0x30
 8002cca:	46bd      	mov	sp, r7
 8002ccc:	bd80      	pop	{r7, pc}

08002cce <lv_obj_add_state>:
    if(v) lv_obj_add_flag(obj, f);
    else lv_obj_remove_flag(obj, f);
}

void lv_obj_add_state(lv_obj_t * obj, lv_state_t state)
{
 8002cce:	b580      	push	{r7, lr}
 8002cd0:	b084      	sub	sp, #16
 8002cd2:	af00      	add	r7, sp, #0
 8002cd4:	6078      	str	r0, [r7, #4]
 8002cd6:	460b      	mov	r3, r1
 8002cd8:	807b      	strh	r3, [r7, #2]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    lv_state_t new_state = obj->state | state;
 8002cda:	687b      	ldr	r3, [r7, #4]
 8002cdc:	8d1a      	ldrh	r2, [r3, #40]	@ 0x28
 8002cde:	887b      	ldrh	r3, [r7, #2]
 8002ce0:	4313      	orrs	r3, r2
 8002ce2:	81fb      	strh	r3, [r7, #14]
    if(obj->state != new_state) {
 8002ce4:	687b      	ldr	r3, [r7, #4]
 8002ce6:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8002ce8:	89fa      	ldrh	r2, [r7, #14]
 8002cea:	429a      	cmp	r2, r3
 8002cec:	d00d      	beq.n	8002d0a <lv_obj_add_state+0x3c>

        if(new_state & LV_STATE_DISABLED) {
 8002cee:	89fb      	ldrh	r3, [r7, #14]
 8002cf0:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002cf4:	2b00      	cmp	r3, #0
 8002cf6:	d003      	beq.n	8002d00 <lv_obj_add_state+0x32>
            lv_indev_reset(NULL, obj);
 8002cf8:	6879      	ldr	r1, [r7, #4]
 8002cfa:	2000      	movs	r0, #0
 8002cfc:	f01a f8a6 	bl	801ce4c <lv_indev_reset>
        }

        update_obj_state(obj, new_state);
 8002d00:	89fb      	ldrh	r3, [r7, #14]
 8002d02:	4619      	mov	r1, r3
 8002d04:	6878      	ldr	r0, [r7, #4]
 8002d06:	f000 fea5 	bl	8003a54 <update_obj_state>
    }
}
 8002d0a:	bf00      	nop
 8002d0c:	3710      	adds	r7, #16
 8002d0e:	46bd      	mov	sp, r7
 8002d10:	bd80      	pop	{r7, pc}

08002d12 <lv_obj_remove_state>:

void lv_obj_remove_state(lv_obj_t * obj, lv_state_t state)
{
 8002d12:	b580      	push	{r7, lr}
 8002d14:	b084      	sub	sp, #16
 8002d16:	af00      	add	r7, sp, #0
 8002d18:	6078      	str	r0, [r7, #4]
 8002d1a:	460b      	mov	r3, r1
 8002d1c:	807b      	strh	r3, [r7, #2]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    lv_state_t new_state = obj->state & (~state);
 8002d1e:	687b      	ldr	r3, [r7, #4]
 8002d20:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8002d22:	b21a      	sxth	r2, r3
 8002d24:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8002d28:	43db      	mvns	r3, r3
 8002d2a:	b21b      	sxth	r3, r3
 8002d2c:	4013      	ands	r3, r2
 8002d2e:	b21b      	sxth	r3, r3
 8002d30:	81fb      	strh	r3, [r7, #14]
    if(obj->state != new_state) {
 8002d32:	687b      	ldr	r3, [r7, #4]
 8002d34:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8002d36:	89fa      	ldrh	r2, [r7, #14]
 8002d38:	429a      	cmp	r2, r3
 8002d3a:	d004      	beq.n	8002d46 <lv_obj_remove_state+0x34>
        update_obj_state(obj, new_state);
 8002d3c:	89fb      	ldrh	r3, [r7, #14]
 8002d3e:	4619      	mov	r1, r3
 8002d40:	6878      	ldr	r0, [r7, #4]
 8002d42:	f000 fe87 	bl	8003a54 <update_obj_state>
    }
}
 8002d46:	bf00      	nop
 8002d48:	3710      	adds	r7, #16
 8002d4a:	46bd      	mov	sp, r7
 8002d4c:	bd80      	pop	{r7, pc}

08002d4e <lv_obj_has_flag>:
/*=======================
 * Getter functions
 *======================*/

bool lv_obj_has_flag(const lv_obj_t * obj, lv_obj_flag_t f)
{
 8002d4e:	b480      	push	{r7}
 8002d50:	b083      	sub	sp, #12
 8002d52:	af00      	add	r7, sp, #0
 8002d54:	6078      	str	r0, [r7, #4]
 8002d56:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    return (obj->flags & f)  == f;
 8002d58:	687b      	ldr	r3, [r7, #4]
 8002d5a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8002d5c:	683b      	ldr	r3, [r7, #0]
 8002d5e:	4013      	ands	r3, r2
 8002d60:	683a      	ldr	r2, [r7, #0]
 8002d62:	429a      	cmp	r2, r3
 8002d64:	bf0c      	ite	eq
 8002d66:	2301      	moveq	r3, #1
 8002d68:	2300      	movne	r3, #0
 8002d6a:	b2db      	uxtb	r3, r3
}
 8002d6c:	4618      	mov	r0, r3
 8002d6e:	370c      	adds	r7, #12
 8002d70:	46bd      	mov	sp, r7
 8002d72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d76:	4770      	bx	lr

08002d78 <lv_obj_has_flag_any>:

bool lv_obj_has_flag_any(const lv_obj_t * obj, lv_obj_flag_t f)
{
 8002d78:	b480      	push	{r7}
 8002d7a:	b083      	sub	sp, #12
 8002d7c:	af00      	add	r7, sp, #0
 8002d7e:	6078      	str	r0, [r7, #4]
 8002d80:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    return !!(obj->flags & f);
 8002d82:	687b      	ldr	r3, [r7, #4]
 8002d84:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8002d86:	683b      	ldr	r3, [r7, #0]
 8002d88:	4013      	ands	r3, r2
 8002d8a:	2b00      	cmp	r3, #0
 8002d8c:	bf14      	ite	ne
 8002d8e:	2301      	movne	r3, #1
 8002d90:	2300      	moveq	r3, #0
 8002d92:	b2db      	uxtb	r3, r3
}
 8002d94:	4618      	mov	r0, r3
 8002d96:	370c      	adds	r7, #12
 8002d98:	46bd      	mov	sp, r7
 8002d9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d9e:	4770      	bx	lr

08002da0 <lv_obj_get_state>:

lv_state_t lv_obj_get_state(const lv_obj_t * obj)
{
 8002da0:	b480      	push	{r7}
 8002da2:	b083      	sub	sp, #12
 8002da4:	af00      	add	r7, sp, #0
 8002da6:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    return obj->state;
 8002da8:	687b      	ldr	r3, [r7, #4]
 8002daa:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
}
 8002dac:	4618      	mov	r0, r3
 8002dae:	370c      	adds	r7, #12
 8002db0:	46bd      	mov	sp, r7
 8002db2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002db6:	4770      	bx	lr

08002db8 <lv_obj_get_group>:

    return !!(obj->state & state);
}

lv_group_t * lv_obj_get_group(const lv_obj_t * obj)
{
 8002db8:	b480      	push	{r7}
 8002dba:	b083      	sub	sp, #12
 8002dbc:	af00      	add	r7, sp, #0
 8002dbe:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    if(obj->spec_attr) return obj->spec_attr->group_p;
 8002dc0:	687b      	ldr	r3, [r7, #4]
 8002dc2:	689b      	ldr	r3, [r3, #8]
 8002dc4:	2b00      	cmp	r3, #0
 8002dc6:	d003      	beq.n	8002dd0 <lv_obj_get_group+0x18>
 8002dc8:	687b      	ldr	r3, [r7, #4]
 8002dca:	689b      	ldr	r3, [r3, #8]
 8002dcc:	685b      	ldr	r3, [r3, #4]
 8002dce:	e000      	b.n	8002dd2 <lv_obj_get_group+0x1a>
    else return NULL;
 8002dd0:	2300      	movs	r3, #0
}
 8002dd2:	4618      	mov	r0, r3
 8002dd4:	370c      	adds	r7, #12
 8002dd6:	46bd      	mov	sp, r7
 8002dd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ddc:	4770      	bx	lr

08002dde <lv_obj_allocate_spec_attr>:
/*-------------------
 * OTHER FUNCTIONS
 *------------------*/

void lv_obj_allocate_spec_attr(lv_obj_t * obj)
{
 8002dde:	b580      	push	{r7, lr}
 8002de0:	b082      	sub	sp, #8
 8002de2:	af00      	add	r7, sp, #0
 8002de4:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    if(obj->spec_attr == NULL) {
 8002de6:	687b      	ldr	r3, [r7, #4]
 8002de8:	689b      	ldr	r3, [r3, #8]
 8002dea:	2b00      	cmp	r3, #0
 8002dec:	d11f      	bne.n	8002e2e <lv_obj_allocate_spec_attr+0x50>
        obj->spec_attr = lv_malloc_zeroed(sizeof(_lv_obj_spec_attr_t));
 8002dee:	202c      	movs	r0, #44	@ 0x2c
 8002df0:	f023 f804 	bl	8025dfc <lv_malloc_zeroed>
 8002df4:	4602      	mov	r2, r0
 8002df6:	687b      	ldr	r3, [r7, #4]
 8002df8:	609a      	str	r2, [r3, #8]
        LV_ASSERT_MALLOC(obj->spec_attr);
 8002dfa:	687b      	ldr	r3, [r7, #4]
 8002dfc:	689b      	ldr	r3, [r3, #8]
 8002dfe:	2b00      	cmp	r3, #0
 8002e00:	d101      	bne.n	8002e06 <lv_obj_allocate_spec_attr+0x28>
 8002e02:	bf00      	nop
 8002e04:	e7fd      	b.n	8002e02 <lv_obj_allocate_spec_attr+0x24>
        if(obj->spec_attr == NULL) return;
 8002e06:	687b      	ldr	r3, [r7, #4]
 8002e08:	689b      	ldr	r3, [r3, #8]
 8002e0a:	2b00      	cmp	r3, #0
 8002e0c:	d00e      	beq.n	8002e2c <lv_obj_allocate_spec_attr+0x4e>

        obj->spec_attr->scroll_dir = LV_DIR_ALL;
 8002e0e:	687b      	ldr	r3, [r7, #4]
 8002e10:	689a      	ldr	r2, [r3, #8]
 8002e12:	8d53      	ldrh	r3, [r2, #42]	@ 0x2a
 8002e14:	f443 7370 	orr.w	r3, r3, #960	@ 0x3c0
 8002e18:	8553      	strh	r3, [r2, #42]	@ 0x2a
        obj->spec_attr->scrollbar_mode = LV_SCROLLBAR_MODE_AUTO;
 8002e1a:	687b      	ldr	r3, [r7, #4]
 8002e1c:	689a      	ldr	r2, [r3, #8]
 8002e1e:	f892 302a 	ldrb.w	r3, [r2, #42]	@ 0x2a
 8002e22:	f043 0303 	orr.w	r3, r3, #3
 8002e26:	f882 302a 	strb.w	r3, [r2, #42]	@ 0x2a
 8002e2a:	e000      	b.n	8002e2e <lv_obj_allocate_spec_attr+0x50>
        if(obj->spec_attr == NULL) return;
 8002e2c:	bf00      	nop
    }
}
 8002e2e:	3708      	adds	r7, #8
 8002e30:	46bd      	mov	sp, r7
 8002e32:	bd80      	pop	{r7, pc}

08002e34 <lv_obj_constructor>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void lv_obj_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
{
 8002e34:	b590      	push	{r4, r7, lr}
 8002e36:	b087      	sub	sp, #28
 8002e38:	af00      	add	r7, sp, #0
 8002e3a:	6078      	str	r0, [r7, #4]
 8002e3c:	6039      	str	r1, [r7, #0]
    LV_UNUSED(class_p);
    LV_TRACE_OBJ_CREATE("begin");

    lv_obj_t * parent = obj->parent;
 8002e3e:	683b      	ldr	r3, [r7, #0]
 8002e40:	685b      	ldr	r3, [r3, #4]
 8002e42:	617b      	str	r3, [r7, #20]
    if(parent) {
 8002e44:	697b      	ldr	r3, [r7, #20]
 8002e46:	2b00      	cmp	r3, #0
 8002e48:	d029      	beq.n	8002e9e <lv_obj_constructor+0x6a>
        int32_t sl = lv_obj_get_scroll_left(parent);
 8002e4a:	6978      	ldr	r0, [r7, #20]
 8002e4c:	f004 fb9e 	bl	800758c <lv_obj_get_scroll_left>
 8002e50:	6138      	str	r0, [r7, #16]
        int32_t st = lv_obj_get_scroll_top(parent);
 8002e52:	6978      	ldr	r0, [r7, #20]
 8002e54:	f004 fb1a 	bl	800748c <lv_obj_get_scroll_top>
 8002e58:	60f8      	str	r0, [r7, #12]

        obj->coords.y1 = parent->coords.y1 + lv_obj_get_style_pad_top(parent, LV_PART_MAIN) - st;
 8002e5a:	697b      	ldr	r3, [r7, #20]
 8002e5c:	699c      	ldr	r4, [r3, #24]
 8002e5e:	2100      	movs	r1, #0
 8002e60:	6978      	ldr	r0, [r7, #20]
 8002e62:	f7ff fd4b 	bl	80028fc <lv_obj_get_style_pad_top>
 8002e66:	4603      	mov	r3, r0
 8002e68:	18e2      	adds	r2, r4, r3
 8002e6a:	68fb      	ldr	r3, [r7, #12]
 8002e6c:	1ad2      	subs	r2, r2, r3
 8002e6e:	683b      	ldr	r3, [r7, #0]
 8002e70:	619a      	str	r2, [r3, #24]
        obj->coords.y2 = obj->coords.y1 - 1;
 8002e72:	683b      	ldr	r3, [r7, #0]
 8002e74:	699b      	ldr	r3, [r3, #24]
 8002e76:	1e5a      	subs	r2, r3, #1
 8002e78:	683b      	ldr	r3, [r7, #0]
 8002e7a:	621a      	str	r2, [r3, #32]
        obj->coords.x1  = parent->coords.x1 + lv_obj_get_style_pad_left(parent, LV_PART_MAIN) - sl;
 8002e7c:	697b      	ldr	r3, [r7, #20]
 8002e7e:	695c      	ldr	r4, [r3, #20]
 8002e80:	2100      	movs	r1, #0
 8002e82:	6978      	ldr	r0, [r7, #20]
 8002e84:	f7ff fd4b 	bl	800291e <lv_obj_get_style_pad_left>
 8002e88:	4603      	mov	r3, r0
 8002e8a:	18e2      	adds	r2, r4, r3
 8002e8c:	693b      	ldr	r3, [r7, #16]
 8002e8e:	1ad2      	subs	r2, r2, r3
 8002e90:	683b      	ldr	r3, [r7, #0]
 8002e92:	615a      	str	r2, [r3, #20]
        obj->coords.x2  = obj->coords.x1 - 1;
 8002e94:	683b      	ldr	r3, [r7, #0]
 8002e96:	695b      	ldr	r3, [r3, #20]
 8002e98:	1e5a      	subs	r2, r3, #1
 8002e9a:	683b      	ldr	r3, [r7, #0]
 8002e9c:	61da      	str	r2, [r3, #28]
    }

    /*Set attributes*/
    obj->flags = LV_OBJ_FLAG_CLICKABLE;
 8002e9e:	683b      	ldr	r3, [r7, #0]
 8002ea0:	2202      	movs	r2, #2
 8002ea2:	625a      	str	r2, [r3, #36]	@ 0x24
    obj->flags |= LV_OBJ_FLAG_SNAPPABLE;
 8002ea4:	683b      	ldr	r3, [r7, #0]
 8002ea6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002ea8:	f443 5280 	orr.w	r2, r3, #4096	@ 0x1000
 8002eac:	683b      	ldr	r3, [r7, #0]
 8002eae:	625a      	str	r2, [r3, #36]	@ 0x24
    if(parent) obj->flags |= LV_OBJ_FLAG_PRESS_LOCK;
 8002eb0:	697b      	ldr	r3, [r7, #20]
 8002eb2:	2b00      	cmp	r3, #0
 8002eb4:	d005      	beq.n	8002ec2 <lv_obj_constructor+0x8e>
 8002eb6:	683b      	ldr	r3, [r7, #0]
 8002eb8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002eba:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
 8002ebe:	683b      	ldr	r3, [r7, #0]
 8002ec0:	625a      	str	r2, [r3, #36]	@ 0x24
    if(parent) obj->flags |= LV_OBJ_FLAG_SCROLL_CHAIN;
 8002ec2:	697b      	ldr	r3, [r7, #20]
 8002ec4:	2b00      	cmp	r3, #0
 8002ec6:	d005      	beq.n	8002ed4 <lv_obj_constructor+0xa0>
 8002ec8:	683b      	ldr	r3, [r7, #0]
 8002eca:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002ecc:	f443 7240 	orr.w	r2, r3, #768	@ 0x300
 8002ed0:	683b      	ldr	r3, [r7, #0]
 8002ed2:	625a      	str	r2, [r3, #36]	@ 0x24
    obj->flags |= LV_OBJ_FLAG_CLICK_FOCUSABLE;
 8002ed4:	683b      	ldr	r3, [r7, #0]
 8002ed6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002ed8:	f043 0204 	orr.w	r2, r3, #4
 8002edc:	683b      	ldr	r3, [r7, #0]
 8002ede:	625a      	str	r2, [r3, #36]	@ 0x24
    obj->flags |= LV_OBJ_FLAG_SCROLLABLE;
 8002ee0:	683b      	ldr	r3, [r7, #0]
 8002ee2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002ee4:	f043 0210 	orr.w	r2, r3, #16
 8002ee8:	683b      	ldr	r3, [r7, #0]
 8002eea:	625a      	str	r2, [r3, #36]	@ 0x24
    obj->flags |= LV_OBJ_FLAG_SCROLL_ELASTIC;
 8002eec:	683b      	ldr	r3, [r7, #0]
 8002eee:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002ef0:	f043 0220 	orr.w	r2, r3, #32
 8002ef4:	683b      	ldr	r3, [r7, #0]
 8002ef6:	625a      	str	r2, [r3, #36]	@ 0x24
    obj->flags |= LV_OBJ_FLAG_SCROLL_MOMENTUM;
 8002ef8:	683b      	ldr	r3, [r7, #0]
 8002efa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002efc:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 8002f00:	683b      	ldr	r3, [r7, #0]
 8002f02:	625a      	str	r2, [r3, #36]	@ 0x24
    obj->flags |= LV_OBJ_FLAG_SCROLL_WITH_ARROW;
 8002f04:	683b      	ldr	r3, [r7, #0]
 8002f06:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002f08:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
 8002f0c:	683b      	ldr	r3, [r7, #0]
 8002f0e:	625a      	str	r2, [r3, #36]	@ 0x24
    if(parent) obj->flags |= LV_OBJ_FLAG_GESTURE_BUBBLE;
 8002f10:	697b      	ldr	r3, [r7, #20]
 8002f12:	2b00      	cmp	r3, #0
 8002f14:	d005      	beq.n	8002f22 <lv_obj_constructor+0xee>
 8002f16:	683b      	ldr	r3, [r7, #0]
 8002f18:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002f1a:	f443 4200 	orr.w	r2, r3, #32768	@ 0x8000
 8002f1e:	683b      	ldr	r3, [r7, #0]
 8002f20:	625a      	str	r2, [r3, #36]	@ 0x24
#if LV_USE_OBJ_ID
    lv_obj_assign_id(class_p, obj);
#endif

    LV_TRACE_OBJ_CREATE("finished");
}
 8002f22:	bf00      	nop
 8002f24:	371c      	adds	r7, #28
 8002f26:	46bd      	mov	sp, r7
 8002f28:	bd90      	pop	{r4, r7, pc}

08002f2a <lv_obj_destructor>:

static void lv_obj_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
{
 8002f2a:	b580      	push	{r7, lr}
 8002f2c:	b084      	sub	sp, #16
 8002f2e:	af00      	add	r7, sp, #0
 8002f30:	6078      	str	r0, [r7, #4]
 8002f32:	6039      	str	r1, [r7, #0]
    LV_UNUSED(class_p);

    _lv_event_mark_deleted(obj);
 8002f34:	6838      	ldr	r0, [r7, #0]
 8002f36:	f01f fca7 	bl	8022888 <_lv_event_mark_deleted>

    /*Remove all style*/
    lv_obj_enable_style_refresh(false); /*No need to refresh the style because the object will be deleted*/
 8002f3a:	2000      	movs	r0, #0
 8002f3c:	f006 fad2 	bl	80094e4 <lv_obj_enable_style_refresh>
    lv_obj_remove_style_all(obj);
 8002f40:	6838      	ldr	r0, [r7, #0]
 8002f42:	f006 f9f9 	bl	8009338 <lv_obj_remove_style_all>
    lv_obj_enable_style_refresh(true);
 8002f46:	2001      	movs	r0, #1
 8002f48:	f006 facc 	bl	80094e4 <lv_obj_enable_style_refresh>

    /*Remove the animations from this object*/
    lv_anim_delete(obj, NULL);
 8002f4c:	2100      	movs	r1, #0
 8002f4e:	6838      	ldr	r0, [r7, #0]
 8002f50:	f01e f894 	bl	802107c <lv_anim_delete>

    /*Delete from the group*/
    lv_group_t * group = lv_obj_get_group(obj);
 8002f54:	6838      	ldr	r0, [r7, #0]
 8002f56:	f7ff ff2f 	bl	8002db8 <lv_obj_get_group>
 8002f5a:	60f8      	str	r0, [r7, #12]
    if(group) lv_group_remove_obj(obj);
 8002f5c:	68fb      	ldr	r3, [r7, #12]
 8002f5e:	2b00      	cmp	r3, #0
 8002f60:	d002      	beq.n	8002f68 <lv_obj_destructor+0x3e>
 8002f62:	6838      	ldr	r0, [r7, #0]
 8002f64:	f7ff f9c9 	bl	80022fa <lv_group_remove_obj>

    if(obj->spec_attr) {
 8002f68:	683b      	ldr	r3, [r7, #0]
 8002f6a:	689b      	ldr	r3, [r3, #8]
 8002f6c:	2b00      	cmp	r3, #0
 8002f6e:	d01c      	beq.n	8002faa <lv_obj_destructor+0x80>
        if(obj->spec_attr->children) {
 8002f70:	683b      	ldr	r3, [r7, #0]
 8002f72:	689b      	ldr	r3, [r3, #8]
 8002f74:	681b      	ldr	r3, [r3, #0]
 8002f76:	2b00      	cmp	r3, #0
 8002f78:	d009      	beq.n	8002f8e <lv_obj_destructor+0x64>
            lv_free(obj->spec_attr->children);
 8002f7a:	683b      	ldr	r3, [r7, #0]
 8002f7c:	689b      	ldr	r3, [r3, #8]
 8002f7e:	681b      	ldr	r3, [r3, #0]
 8002f80:	4618      	mov	r0, r3
 8002f82:	f022 ff59 	bl	8025e38 <lv_free>
            obj->spec_attr->children = NULL;
 8002f86:	683b      	ldr	r3, [r7, #0]
 8002f88:	689b      	ldr	r3, [r3, #8]
 8002f8a:	2200      	movs	r2, #0
 8002f8c:	601a      	str	r2, [r3, #0]
        }

        lv_event_remove_all(&obj->spec_attr->event_list);
 8002f8e:	683b      	ldr	r3, [r7, #0]
 8002f90:	689b      	ldr	r3, [r3, #8]
 8002f92:	3308      	adds	r3, #8
 8002f94:	4618      	mov	r0, r3
 8002f96:	f01f fc24 	bl	80227e2 <lv_event_remove_all>

        lv_free(obj->spec_attr);
 8002f9a:	683b      	ldr	r3, [r7, #0]
 8002f9c:	689b      	ldr	r3, [r3, #8]
 8002f9e:	4618      	mov	r0, r3
 8002fa0:	f022 ff4a 	bl	8025e38 <lv_free>
        obj->spec_attr = NULL;
 8002fa4:	683b      	ldr	r3, [r7, #0]
 8002fa6:	2200      	movs	r2, #0
 8002fa8:	609a      	str	r2, [r3, #8]
    }

#if LV_USE_OBJ_ID
    lv_obj_free_id(obj);
#endif
}
 8002faa:	bf00      	nop
 8002fac:	3710      	adds	r7, #16
 8002fae:	46bd      	mov	sp, r7
 8002fb0:	bd80      	pop	{r7, pc}

08002fb2 <lv_obj_draw>:

static void lv_obj_draw(lv_event_t * e)
{
 8002fb2:	b580      	push	{r7, lr}
 8002fb4:	b0b8      	sub	sp, #224	@ 0xe0
 8002fb6:	af00      	add	r7, sp, #0
 8002fb8:	6078      	str	r0, [r7, #4]
    lv_event_code_t code = lv_event_get_code(e);
 8002fba:	6878      	ldr	r0, [r7, #4]
 8002fbc:	f01f fc48 	bl	8022850 <lv_event_get_code>
 8002fc0:	4603      	mov	r3, r0
 8002fc2:	f8a7 30da 	strh.w	r3, [r7, #218]	@ 0xda
    lv_obj_t * obj = lv_event_get_current_target(e);
 8002fc6:	6878      	ldr	r0, [r7, #4]
 8002fc8:	f01f fc36 	bl	8022838 <lv_event_get_current_target>
 8002fcc:	f8c7 00d4 	str.w	r0, [r7, #212]	@ 0xd4
    if(code == LV_EVENT_COVER_CHECK) {
 8002fd0:	f8b7 30da 	ldrh.w	r3, [r7, #218]	@ 0xda
 8002fd4:	2b14      	cmp	r3, #20
 8002fd6:	f040 80b6 	bne.w	8003146 <lv_obj_draw+0x194>
        lv_cover_check_info_t * info = lv_event_get_param(e);
 8002fda:	6878      	ldr	r0, [r7, #4]
 8002fdc:	f01f fc47 	bl	802286e <lv_event_get_param>
 8002fe0:	f8c7 00b8 	str.w	r0, [r7, #184]	@ 0xb8
        if(info->res == LV_COVER_RES_MASKED) return;
 8002fe4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8002fe8:	781b      	ldrb	r3, [r3, #0]
 8002fea:	2b02      	cmp	r3, #2
 8002fec:	f000 8155 	beq.w	800329a <lv_obj_draw+0x2e8>
        if(lv_obj_get_style_clip_corner(obj, LV_PART_MAIN)) {
 8002ff0:	2100      	movs	r1, #0
 8002ff2:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 8002ff6:	f7ff fdd4 	bl	8002ba2 <lv_obj_get_style_clip_corner>
 8002ffa:	4603      	mov	r3, r0
 8002ffc:	2b00      	cmp	r3, #0
 8002ffe:	d004      	beq.n	800300a <lv_obj_draw+0x58>
            info->res = LV_COVER_RES_MASKED;
 8003000:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8003004:	2202      	movs	r2, #2
 8003006:	701a      	strb	r2, [r3, #0]
            return;
 8003008:	e148      	b.n	800329c <lv_obj_draw+0x2ea>
        }

        /*Most trivial test. Is the mask fully IN the object? If no it surely doesn't cover it*/
        int32_t r = lv_obj_get_style_radius(obj, LV_PART_MAIN);
 800300a:	2100      	movs	r1, #0
 800300c:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 8003010:	f7ff fdb6 	bl	8002b80 <lv_obj_get_style_radius>
 8003014:	f8c7 00b4 	str.w	r0, [r7, #180]	@ 0xb4
        int32_t w = lv_obj_get_style_transform_width(obj, LV_PART_MAIN);
 8003018:	2100      	movs	r1, #0
 800301a:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 800301e:	f7ff fc4b 	bl	80028b8 <lv_obj_get_style_transform_width>
 8003022:	f8c7 00b0 	str.w	r0, [r7, #176]	@ 0xb0
        int32_t h = lv_obj_get_style_transform_height(obj, LV_PART_MAIN);
 8003026:	2100      	movs	r1, #0
 8003028:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 800302c:	f7ff fc55 	bl	80028da <lv_obj_get_style_transform_height>
 8003030:	f8c7 00ac 	str.w	r0, [r7, #172]	@ 0xac
        lv_area_t coords;
        lv_area_copy(&coords, &obj->coords);
 8003034:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8003038:	f103 0214 	add.w	r2, r3, #20
 800303c:	f107 0398 	add.w	r3, r7, #152	@ 0x98
 8003040:	4611      	mov	r1, r2
 8003042:	4618      	mov	r0, r3
 8003044:	f7ff fb64 	bl	8002710 <lv_area_copy>
        lv_area_increase(&coords, w, h);
 8003048:	f107 0398 	add.w	r3, r7, #152	@ 0x98
 800304c:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8003050:	f8d7 10b0 	ldr.w	r1, [r7, #176]	@ 0xb0
 8003054:	4618      	mov	r0, r3
 8003056:	f01e fc2f 	bl	80218b8 <lv_area_increase>

        if(_lv_area_is_in(info->area, &coords, r) == false) {
 800305a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 800305e:	685b      	ldr	r3, [r3, #4]
 8003060:	f107 0198 	add.w	r1, r7, #152	@ 0x98
 8003064:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8003068:	4618      	mov	r0, r3
 800306a:	f01e fd91 	bl	8021b90 <_lv_area_is_in>
 800306e:	4603      	mov	r3, r0
 8003070:	f083 0301 	eor.w	r3, r3, #1
 8003074:	b2db      	uxtb	r3, r3
 8003076:	2b00      	cmp	r3, #0
 8003078:	d004      	beq.n	8003084 <lv_obj_draw+0xd2>
            info->res = LV_COVER_RES_NOT_COVER;
 800307a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 800307e:	2201      	movs	r2, #1
 8003080:	701a      	strb	r2, [r3, #0]
            return;
 8003082:	e10b      	b.n	800329c <lv_obj_draw+0x2ea>
        }

        if(lv_obj_get_style_bg_opa(obj, LV_PART_MAIN) < LV_OPA_MAX) {
 8003084:	2100      	movs	r1, #0
 8003086:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 800308a:	f7ff fc7d 	bl	8002988 <lv_obj_get_style_bg_opa>
 800308e:	4603      	mov	r3, r0
 8003090:	2bfc      	cmp	r3, #252	@ 0xfc
 8003092:	d804      	bhi.n	800309e <lv_obj_draw+0xec>
            info->res = LV_COVER_RES_NOT_COVER;
 8003094:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8003098:	2201      	movs	r2, #1
 800309a:	701a      	strb	r2, [r3, #0]
            return;
 800309c:	e0fe      	b.n	800329c <lv_obj_draw+0x2ea>
        }

        if(lv_obj_get_style_opa(obj, LV_PART_MAIN) < LV_OPA_MAX) {
 800309e:	2100      	movs	r1, #0
 80030a0:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 80030a4:	f7ff fd93 	bl	8002bce <lv_obj_get_style_opa>
 80030a8:	4603      	mov	r3, r0
 80030aa:	2bfc      	cmp	r3, #252	@ 0xfc
 80030ac:	d804      	bhi.n	80030b8 <lv_obj_draw+0x106>
            info->res = LV_COVER_RES_NOT_COVER;
 80030ae:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80030b2:	2201      	movs	r2, #1
 80030b4:	701a      	strb	r2, [r3, #0]
            return;
 80030b6:	e0f1      	b.n	800329c <lv_obj_draw+0x2ea>
        }

        if(lv_obj_get_style_bg_grad_dir(obj, 0) != LV_GRAD_DIR_NONE) {
 80030b8:	2100      	movs	r1, #0
 80030ba:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 80030be:	f7ff fc75 	bl	80029ac <lv_obj_get_style_bg_grad_dir>
 80030c2:	4603      	mov	r3, r0
 80030c4:	2b00      	cmp	r3, #0
 80030c6:	d00c      	beq.n	80030e2 <lv_obj_draw+0x130>
            if(lv_obj_get_style_bg_grad_opa(obj, 0) < LV_OPA_MAX) {
 80030c8:	2100      	movs	r1, #0
 80030ca:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 80030ce:	f7ff fc7f 	bl	80029d0 <lv_obj_get_style_bg_grad_opa>
 80030d2:	4603      	mov	r3, r0
 80030d4:	2bfc      	cmp	r3, #252	@ 0xfc
 80030d6:	d804      	bhi.n	80030e2 <lv_obj_draw+0x130>
                info->res = LV_COVER_RES_NOT_COVER;
 80030d8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80030dc:	2201      	movs	r2, #1
 80030de:	701a      	strb	r2, [r3, #0]
                return;
 80030e0:	e0dc      	b.n	800329c <lv_obj_draw+0x2ea>
            }
        }
        const lv_grad_dsc_t * grad_dsc = lv_obj_get_style_bg_grad(obj, 0);
 80030e2:	2100      	movs	r1, #0
 80030e4:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 80030e8:	f7ff fc84 	bl	80029f4 <lv_obj_get_style_bg_grad>
 80030ec:	f8c7 00a8 	str.w	r0, [r7, #168]	@ 0xa8
        if(grad_dsc) {
 80030f0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80030f4:	2b00      	cmp	r3, #0
 80030f6:	d021      	beq.n	800313c <lv_obj_draw+0x18a>
            uint32_t i;
            for(i = 0; i < grad_dsc->stops_count; i++) {
 80030f8:	2300      	movs	r3, #0
 80030fa:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 80030fe:	e015      	b.n	800312c <lv_obj_draw+0x17a>
                if(grad_dsc->stops[i].opa < LV_OPA_MAX) {
 8003100:	f8d7 10a8 	ldr.w	r1, [r7, #168]	@ 0xa8
 8003104:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8003108:	4613      	mov	r3, r2
 800310a:	009b      	lsls	r3, r3, #2
 800310c:	4413      	add	r3, r2
 800310e:	440b      	add	r3, r1
 8003110:	3303      	adds	r3, #3
 8003112:	781b      	ldrb	r3, [r3, #0]
 8003114:	2bfc      	cmp	r3, #252	@ 0xfc
 8003116:	d804      	bhi.n	8003122 <lv_obj_draw+0x170>
                    info->res = LV_COVER_RES_NOT_COVER;
 8003118:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 800311c:	2201      	movs	r2, #1
 800311e:	701a      	strb	r2, [r3, #0]
                    return;
 8003120:	e0bc      	b.n	800329c <lv_obj_draw+0x2ea>
            for(i = 0; i < grad_dsc->stops_count; i++) {
 8003122:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8003126:	3301      	adds	r3, #1
 8003128:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 800312c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8003130:	7a9b      	ldrb	r3, [r3, #10]
 8003132:	461a      	mov	r2, r3
 8003134:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8003138:	4293      	cmp	r3, r2
 800313a:	d3e1      	bcc.n	8003100 <lv_obj_draw+0x14e>
                }
            }
        }
        info->res = LV_COVER_RES_COVER;
 800313c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8003140:	2200      	movs	r2, #0
 8003142:	701a      	strb	r2, [r3, #0]
 8003144:	e0aa      	b.n	800329c <lv_obj_draw+0x2ea>
    }
    else if(code == LV_EVENT_DRAW_MAIN) {
 8003146:	f8b7 30da 	ldrh.w	r3, [r7, #218]	@ 0xda
 800314a:	2b17      	cmp	r3, #23
 800314c:	d14a      	bne.n	80031e4 <lv_obj_draw+0x232>
        lv_layer_t * layer = lv_event_get_layer(e);
 800314e:	6878      	ldr	r0, [r7, #4]
 8003150:	f001 ff2c 	bl	8004fac <lv_event_get_layer>
 8003154:	f8c7 00c4 	str.w	r0, [r7, #196]	@ 0xc4
        lv_draw_rect_dsc_t draw_dsc;
        lv_draw_rect_dsc_init(&draw_dsc);
 8003158:	f107 0308 	add.w	r3, r7, #8
 800315c:	4618      	mov	r0, r3
 800315e:	f00a fd5b 	bl	800dc18 <lv_draw_rect_dsc_init>

        lv_obj_init_draw_rect_dsc(obj, LV_PART_MAIN, &draw_dsc);
 8003162:	f107 0308 	add.w	r3, r7, #8
 8003166:	461a      	mov	r2, r3
 8003168:	2100      	movs	r1, #0
 800316a:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 800316e:	f001 fabd 	bl	80046ec <lv_obj_init_draw_rect_dsc>
        /*If the border is drawn later disable loading its properties*/
        if(lv_obj_get_style_border_post(obj, LV_PART_MAIN)) {
 8003172:	2100      	movs	r1, #0
 8003174:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 8003178:	f7ff fc94 	bl	8002aa4 <lv_obj_get_style_border_post>
 800317c:	4603      	mov	r3, r0
 800317e:	2b00      	cmp	r3, #0
 8003180:	d005      	beq.n	800318e <lv_obj_draw+0x1dc>
            draw_dsc.border_post = 1;
 8003182:	f897 3051 	ldrb.w	r3, [r7, #81]	@ 0x51
 8003186:	f043 0320 	orr.w	r3, r3, #32
 800318a:	f887 3051 	strb.w	r3, [r7, #81]	@ 0x51
        }

        int32_t w = lv_obj_get_style_transform_width(obj, LV_PART_MAIN);
 800318e:	2100      	movs	r1, #0
 8003190:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 8003194:	f7ff fb90 	bl	80028b8 <lv_obj_get_style_transform_width>
 8003198:	f8c7 00c0 	str.w	r0, [r7, #192]	@ 0xc0
        int32_t h = lv_obj_get_style_transform_height(obj, LV_PART_MAIN);
 800319c:	2100      	movs	r1, #0
 800319e:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 80031a2:	f7ff fb9a 	bl	80028da <lv_obj_get_style_transform_height>
 80031a6:	f8c7 00bc 	str.w	r0, [r7, #188]	@ 0xbc
        lv_area_t coords;
        lv_area_copy(&coords, &obj->coords);
 80031aa:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80031ae:	f103 0214 	add.w	r2, r3, #20
 80031b2:	f107 0388 	add.w	r3, r7, #136	@ 0x88
 80031b6:	4611      	mov	r1, r2
 80031b8:	4618      	mov	r0, r3
 80031ba:	f7ff faa9 	bl	8002710 <lv_area_copy>
        lv_area_increase(&coords, w, h);
 80031be:	f107 0388 	add.w	r3, r7, #136	@ 0x88
 80031c2:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 80031c6:	f8d7 10c0 	ldr.w	r1, [r7, #192]	@ 0xc0
 80031ca:	4618      	mov	r0, r3
 80031cc:	f01e fb74 	bl	80218b8 <lv_area_increase>

        lv_draw_rect(layer, &draw_dsc, &coords);
 80031d0:	f107 0288 	add.w	r2, r7, #136	@ 0x88
 80031d4:	f107 0308 	add.w	r3, r7, #8
 80031d8:	4619      	mov	r1, r3
 80031da:	f8d7 00c4 	ldr.w	r0, [r7, #196]	@ 0xc4
 80031de:	f00a fdc9 	bl	800dd74 <lv_draw_rect>
 80031e2:	e05b      	b.n	800329c <lv_obj_draw+0x2ea>
    }
    else if(code == LV_EVENT_DRAW_POST) {
 80031e4:	f8b7 30da 	ldrh.w	r3, [r7, #218]	@ 0xda
 80031e8:	2b1a      	cmp	r3, #26
 80031ea:	d157      	bne.n	800329c <lv_obj_draw+0x2ea>
        lv_layer_t * layer = lv_event_get_layer(e);
 80031ec:	6878      	ldr	r0, [r7, #4]
 80031ee:	f001 fedd 	bl	8004fac <lv_event_get_layer>
 80031f2:	f8c7 00d0 	str.w	r0, [r7, #208]	@ 0xd0
        draw_scrollbar(obj, layer);
 80031f6:	f8d7 10d0 	ldr.w	r1, [r7, #208]	@ 0xd0
 80031fa:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 80031fe:	f000 f850 	bl	80032a2 <draw_scrollbar>

        /*If the border is drawn later disable loading other properties*/
        if(lv_obj_get_style_border_post(obj, LV_PART_MAIN)) {
 8003202:	2100      	movs	r1, #0
 8003204:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 8003208:	f7ff fc4c 	bl	8002aa4 <lv_obj_get_style_border_post>
 800320c:	4603      	mov	r3, r0
 800320e:	2b00      	cmp	r3, #0
 8003210:	d044      	beq.n	800329c <lv_obj_draw+0x2ea>
            lv_draw_rect_dsc_t draw_dsc;
            lv_draw_rect_dsc_init(&draw_dsc);
 8003212:	f107 0308 	add.w	r3, r7, #8
 8003216:	4618      	mov	r0, r3
 8003218:	f00a fcfe 	bl	800dc18 <lv_draw_rect_dsc_init>
            draw_dsc.bg_opa = LV_OPA_TRANSP;
 800321c:	2300      	movs	r3, #0
 800321e:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
            draw_dsc.bg_image_opa = LV_OPA_TRANSP;
 8003222:	2300      	movs	r3, #0
 8003224:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
            draw_dsc.outline_opa = LV_OPA_TRANSP;
 8003228:	2300      	movs	r3, #0
 800322a:	f887 3060 	strb.w	r3, [r7, #96]	@ 0x60
            draw_dsc.shadow_opa = LV_OPA_TRANSP;
 800322e:	2300      	movs	r3, #0
 8003230:	f887 3074 	strb.w	r3, [r7, #116]	@ 0x74
            lv_obj_init_draw_rect_dsc(obj, LV_PART_MAIN, &draw_dsc);
 8003234:	f107 0308 	add.w	r3, r7, #8
 8003238:	461a      	mov	r2, r3
 800323a:	2100      	movs	r1, #0
 800323c:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 8003240:	f001 fa54 	bl	80046ec <lv_obj_init_draw_rect_dsc>

            int32_t w = lv_obj_get_style_transform_width(obj, LV_PART_MAIN);
 8003244:	2100      	movs	r1, #0
 8003246:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 800324a:	f7ff fb35 	bl	80028b8 <lv_obj_get_style_transform_width>
 800324e:	f8c7 00cc 	str.w	r0, [r7, #204]	@ 0xcc
            int32_t h = lv_obj_get_style_transform_height(obj, LV_PART_MAIN);
 8003252:	2100      	movs	r1, #0
 8003254:	f8d7 00d4 	ldr.w	r0, [r7, #212]	@ 0xd4
 8003258:	f7ff fb3f 	bl	80028da <lv_obj_get_style_transform_height>
 800325c:	f8c7 00c8 	str.w	r0, [r7, #200]	@ 0xc8
            lv_area_t coords;
            lv_area_copy(&coords, &obj->coords);
 8003260:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8003264:	f103 0214 	add.w	r2, r3, #20
 8003268:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 800326c:	4611      	mov	r1, r2
 800326e:	4618      	mov	r0, r3
 8003270:	f7ff fa4e 	bl	8002710 <lv_area_copy>
            lv_area_increase(&coords, w, h);
 8003274:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8003278:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 800327c:	f8d7 10cc 	ldr.w	r1, [r7, #204]	@ 0xcc
 8003280:	4618      	mov	r0, r3
 8003282:	f01e fb19 	bl	80218b8 <lv_area_increase>

            lv_draw_rect(layer, &draw_dsc, &coords);
 8003286:	f107 0278 	add.w	r2, r7, #120	@ 0x78
 800328a:	f107 0308 	add.w	r3, r7, #8
 800328e:	4619      	mov	r1, r3
 8003290:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 8003294:	f00a fd6e 	bl	800dd74 <lv_draw_rect>
 8003298:	e000      	b.n	800329c <lv_obj_draw+0x2ea>
        if(info->res == LV_COVER_RES_MASKED) return;
 800329a:	bf00      	nop
        }
    }
}
 800329c:	37e0      	adds	r7, #224	@ 0xe0
 800329e:	46bd      	mov	sp, r7
 80032a0:	bd80      	pop	{r7, pc}

080032a2 <draw_scrollbar>:

static void draw_scrollbar(lv_obj_t * obj, lv_layer_t * layer)
{
 80032a2:	b580      	push	{r7, lr}
 80032a4:	b0a8      	sub	sp, #160	@ 0xa0
 80032a6:	af00      	add	r7, sp, #0
 80032a8:	6078      	str	r0, [r7, #4]
 80032aa:	6039      	str	r1, [r7, #0]

    lv_area_t hor_area;
    lv_area_t ver_area;
    lv_obj_get_scrollbar_area(obj, &hor_area, &ver_area);
 80032ac:	f107 027c 	add.w	r2, r7, #124	@ 0x7c
 80032b0:	f107 038c 	add.w	r3, r7, #140	@ 0x8c
 80032b4:	4619      	mov	r1, r3
 80032b6:	6878      	ldr	r0, [r7, #4]
 80032b8:	f004 fca6 	bl	8007c08 <lv_obj_get_scrollbar_area>

    if(lv_area_get_size(&hor_area) <= 0 && lv_area_get_size(&ver_area) <= 0) return;
 80032bc:	f107 038c 	add.w	r3, r7, #140	@ 0x8c
 80032c0:	4618      	mov	r0, r3
 80032c2:	f01e fade 	bl	8021882 <lv_area_get_size>
 80032c6:	4603      	mov	r3, r0
 80032c8:	2b00      	cmp	r3, #0
 80032ca:	d107      	bne.n	80032dc <draw_scrollbar+0x3a>
 80032cc:	f107 037c 	add.w	r3, r7, #124	@ 0x7c
 80032d0:	4618      	mov	r0, r3
 80032d2:	f01e fad6 	bl	8021882 <lv_area_get_size>
 80032d6:	4603      	mov	r3, r0
 80032d8:	2b00      	cmp	r3, #0
 80032da:	d031      	beq.n	8003340 <draw_scrollbar+0x9e>

    lv_draw_rect_dsc_t draw_dsc;
    lv_result_t sb_res = scrollbar_init_draw_dsc(obj, &draw_dsc);
 80032dc:	f107 030c 	add.w	r3, r7, #12
 80032e0:	4619      	mov	r1, r3
 80032e2:	6878      	ldr	r0, [r7, #4]
 80032e4:	f000 f832 	bl	800334c <scrollbar_init_draw_dsc>
 80032e8:	4603      	mov	r3, r0
 80032ea:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
    if(sb_res != LV_RESULT_OK) return;
 80032ee:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 80032f2:	2b01      	cmp	r3, #1
 80032f4:	d126      	bne.n	8003344 <draw_scrollbar+0xa2>

    if(lv_area_get_size(&hor_area) > 0) {
 80032f6:	f107 038c 	add.w	r3, r7, #140	@ 0x8c
 80032fa:	4618      	mov	r0, r3
 80032fc:	f01e fac1 	bl	8021882 <lv_area_get_size>
 8003300:	4603      	mov	r3, r0
 8003302:	2b00      	cmp	r3, #0
 8003304:	d009      	beq.n	800331a <draw_scrollbar+0x78>
        draw_dsc.base.id1 = 0;
 8003306:	2300      	movs	r3, #0
 8003308:	617b      	str	r3, [r7, #20]
        lv_draw_rect(layer, &draw_dsc, &hor_area);
 800330a:	f107 028c 	add.w	r2, r7, #140	@ 0x8c
 800330e:	f107 030c 	add.w	r3, r7, #12
 8003312:	4619      	mov	r1, r3
 8003314:	6838      	ldr	r0, [r7, #0]
 8003316:	f00a fd2d 	bl	800dd74 <lv_draw_rect>
    }
    if(lv_area_get_size(&ver_area) > 0) {
 800331a:	f107 037c 	add.w	r3, r7, #124	@ 0x7c
 800331e:	4618      	mov	r0, r3
 8003320:	f01e faaf 	bl	8021882 <lv_area_get_size>
 8003324:	4603      	mov	r3, r0
 8003326:	2b00      	cmp	r3, #0
 8003328:	d00d      	beq.n	8003346 <draw_scrollbar+0xa4>
        draw_dsc.base.id1 = 1;
 800332a:	2301      	movs	r3, #1
 800332c:	617b      	str	r3, [r7, #20]
        lv_draw_rect(layer, &draw_dsc, &ver_area);
 800332e:	f107 027c 	add.w	r2, r7, #124	@ 0x7c
 8003332:	f107 030c 	add.w	r3, r7, #12
 8003336:	4619      	mov	r1, r3
 8003338:	6838      	ldr	r0, [r7, #0]
 800333a:	f00a fd1b 	bl	800dd74 <lv_draw_rect>
 800333e:	e002      	b.n	8003346 <draw_scrollbar+0xa4>
    if(lv_area_get_size(&hor_area) <= 0 && lv_area_get_size(&ver_area) <= 0) return;
 8003340:	bf00      	nop
 8003342:	e000      	b.n	8003346 <draw_scrollbar+0xa4>
    if(sb_res != LV_RESULT_OK) return;
 8003344:	bf00      	nop
    }
}
 8003346:	37a0      	adds	r7, #160	@ 0xa0
 8003348:	46bd      	mov	sp, r7
 800334a:	bd80      	pop	{r7, pc}

0800334c <scrollbar_init_draw_dsc>:
 * @param obj pointer to an object
 * @param dsc the draw descriptor to initialize
 * @return LV_RESULT_OK: the scrollbar is visible; LV_RESULT_INVALID: the scrollbar is not visible
 */
static lv_result_t scrollbar_init_draw_dsc(lv_obj_t * obj, lv_draw_rect_dsc_t * dsc)
{
 800334c:	b590      	push	{r4, r7, lr}
 800334e:	b085      	sub	sp, #20
 8003350:	af00      	add	r7, sp, #0
 8003352:	6078      	str	r0, [r7, #4]
 8003354:	6039      	str	r1, [r7, #0]
    lv_draw_rect_dsc_init(dsc);
 8003356:	6838      	ldr	r0, [r7, #0]
 8003358:	f00a fc5e 	bl	800dc18 <lv_draw_rect_dsc_init>
    dsc->bg_opa = lv_obj_get_style_bg_opa(obj, LV_PART_SCROLLBAR);
 800335c:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8003360:	6878      	ldr	r0, [r7, #4]
 8003362:	f7ff fb11 	bl	8002988 <lv_obj_get_style_bg_opa>
 8003366:	4603      	mov	r3, r0
 8003368:	461a      	mov	r2, r3
 800336a:	683b      	ldr	r3, [r7, #0]
 800336c:	f883 2020 	strb.w	r2, [r3, #32]
    if(dsc->bg_opa > LV_OPA_MIN) {
 8003370:	683b      	ldr	r3, [r7, #0]
 8003372:	f893 3020 	ldrb.w	r3, [r3, #32]
 8003376:	2b02      	cmp	r3, #2
 8003378:	d911      	bls.n	800339e <scrollbar_init_draw_dsc+0x52>
        dsc->bg_color = lv_obj_get_style_bg_color(obj, LV_PART_SCROLLBAR);
 800337a:	683c      	ldr	r4, [r7, #0]
 800337c:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8003380:	6878      	ldr	r0, [r7, #4]
 8003382:	f7ff fadd 	bl	8002940 <lv_obj_get_style_bg_color>
 8003386:	4603      	mov	r3, r0
 8003388:	461a      	mov	r2, r3
 800338a:	f884 2021 	strb.w	r2, [r4, #33]	@ 0x21
 800338e:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8003392:	f884 2022 	strb.w	r2, [r4, #34]	@ 0x22
 8003396:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800339a:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
    }

    dsc->border_opa = lv_obj_get_style_border_opa(obj, LV_PART_SCROLLBAR);
 800339e:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 80033a2:	6878      	ldr	r0, [r7, #4]
 80033a4:	f7ff fb5b 	bl	8002a5e <lv_obj_get_style_border_opa>
 80033a8:	4603      	mov	r3, r0
 80033aa:	461a      	mov	r2, r3
 80033ac:	683b      	ldr	r3, [r7, #0]
 80033ae:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
    if(dsc->border_opa > LV_OPA_MIN) {
 80033b2:	683b      	ldr	r3, [r7, #0]
 80033b4:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 80033b8:	2b02      	cmp	r3, #2
 80033ba:	d922      	bls.n	8003402 <scrollbar_init_draw_dsc+0xb6>
        dsc->border_width = lv_obj_get_style_border_width(obj, LV_PART_SCROLLBAR);
 80033bc:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 80033c0:	6878      	ldr	r0, [r7, #4]
 80033c2:	f7ff fb5e 	bl	8002a82 <lv_obj_get_style_border_width>
 80033c6:	4602      	mov	r2, r0
 80033c8:	683b      	ldr	r3, [r7, #0]
 80033ca:	645a      	str	r2, [r3, #68]	@ 0x44
        if(dsc->border_width > 0) {
 80033cc:	683b      	ldr	r3, [r7, #0]
 80033ce:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80033d0:	2b00      	cmp	r3, #0
 80033d2:	dd12      	ble.n	80033fa <scrollbar_init_draw_dsc+0xae>
            dsc->border_color = lv_obj_get_style_border_color(obj, LV_PART_SCROLLBAR);
 80033d4:	683c      	ldr	r4, [r7, #0]
 80033d6:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 80033da:	6878      	ldr	r0, [r7, #4]
 80033dc:	f7ff fb1b 	bl	8002a16 <lv_obj_get_style_border_color>
 80033e0:	4603      	mov	r3, r0
 80033e2:	461a      	mov	r2, r3
 80033e4:	f884 203e 	strb.w	r2, [r4, #62]	@ 0x3e
 80033e8:	f3c3 2207 	ubfx	r2, r3, #8, #8
 80033ec:	f884 203f 	strb.w	r2, [r4, #63]	@ 0x3f
 80033f0:	f3c3 4307 	ubfx	r3, r3, #16, #8
 80033f4:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
 80033f8:	e003      	b.n	8003402 <scrollbar_init_draw_dsc+0xb6>
        }
        else {
            dsc->border_opa = LV_OPA_TRANSP;
 80033fa:	683b      	ldr	r3, [r7, #0]
 80033fc:	2200      	movs	r2, #0
 80033fe:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
        }
    }

    dsc->shadow_opa = lv_obj_get_style_shadow_opa(obj, LV_PART_SCROLLBAR);
 8003402:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8003406:	6878      	ldr	r0, [r7, #4]
 8003408:	f7ff fba8 	bl	8002b5c <lv_obj_get_style_shadow_opa>
 800340c:	4603      	mov	r3, r0
 800340e:	461a      	mov	r2, r3
 8003410:	683b      	ldr	r3, [r7, #0]
 8003412:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
    if(dsc->shadow_opa > LV_OPA_MIN) {
 8003416:	683b      	ldr	r3, [r7, #0]
 8003418:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
 800341c:	2b02      	cmp	r3, #2
 800341e:	d92a      	bls.n	8003476 <scrollbar_init_draw_dsc+0x12a>
        dsc->shadow_width = lv_obj_get_style_shadow_width(obj, LV_PART_SCROLLBAR);
 8003420:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8003424:	6878      	ldr	r0, [r7, #4]
 8003426:	f7ff fb53 	bl	8002ad0 <lv_obj_get_style_shadow_width>
 800342a:	4602      	mov	r2, r0
 800342c:	683b      	ldr	r3, [r7, #0]
 800342e:	65da      	str	r2, [r3, #92]	@ 0x5c
        if(dsc->shadow_width > 0) {
 8003430:	683b      	ldr	r3, [r7, #0]
 8003432:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8003434:	2b00      	cmp	r3, #0
 8003436:	dd1a      	ble.n	800346e <scrollbar_init_draw_dsc+0x122>
            dsc->shadow_spread = lv_obj_get_style_shadow_spread(obj, LV_PART_SCROLLBAR);
 8003438:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 800343c:	6878      	ldr	r0, [r7, #4]
 800343e:	f7ff fb58 	bl	8002af2 <lv_obj_get_style_shadow_spread>
 8003442:	4602      	mov	r2, r0
 8003444:	683b      	ldr	r3, [r7, #0]
 8003446:	669a      	str	r2, [r3, #104]	@ 0x68
            dsc->shadow_color = lv_obj_get_style_shadow_color(obj, LV_PART_SCROLLBAR);
 8003448:	683c      	ldr	r4, [r7, #0]
 800344a:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 800344e:	6878      	ldr	r0, [r7, #4]
 8003450:	f7ff fb60 	bl	8002b14 <lv_obj_get_style_shadow_color>
 8003454:	4603      	mov	r3, r0
 8003456:	461a      	mov	r2, r3
 8003458:	f884 2059 	strb.w	r2, [r4, #89]	@ 0x59
 800345c:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8003460:	f884 205a 	strb.w	r2, [r4, #90]	@ 0x5a
 8003464:	f3c3 4307 	ubfx	r3, r3, #16, #8
 8003468:	f884 305b 	strb.w	r3, [r4, #91]	@ 0x5b
 800346c:	e003      	b.n	8003476 <scrollbar_init_draw_dsc+0x12a>
        }
        else {
            dsc->shadow_opa = LV_OPA_TRANSP;
 800346e:	683b      	ldr	r3, [r7, #0]
 8003470:	2200      	movs	r2, #0
 8003472:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
        }
    }

    lv_opa_t opa = lv_obj_get_style_opa_recursive(obj, LV_PART_SCROLLBAR);
 8003476:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 800347a:	6878      	ldr	r0, [r7, #4]
 800347c:	f006 fd4d 	bl	8009f1a <lv_obj_get_style_opa_recursive>
 8003480:	4603      	mov	r3, r0
 8003482:	73fb      	strb	r3, [r7, #15]
    if(opa < LV_OPA_MAX) {
 8003484:	7bfb      	ldrb	r3, [r7, #15]
 8003486:	2bfc      	cmp	r3, #252	@ 0xfc
 8003488:	d814      	bhi.n	80034b4 <scrollbar_init_draw_dsc+0x168>
        lv_opa_t v = LV_OPA_MIX2(dsc->bg_opa, opa);
 800348a:	683b      	ldr	r3, [r7, #0]
 800348c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8003490:	461a      	mov	r2, r3
 8003492:	7bfb      	ldrb	r3, [r7, #15]
 8003494:	fb02 f303 	mul.w	r3, r2, r3
 8003498:	121b      	asrs	r3, r3, #8
 800349a:	73bb      	strb	r3, [r7, #14]
        dsc->bg_opa = v;
 800349c:	683b      	ldr	r3, [r7, #0]
 800349e:	7bba      	ldrb	r2, [r7, #14]
 80034a0:	f883 2020 	strb.w	r2, [r3, #32]
        dsc->border_opa = v;
 80034a4:	683b      	ldr	r3, [r7, #0]
 80034a6:	7bba      	ldrb	r2, [r7, #14]
 80034a8:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
        dsc->shadow_opa = v;
 80034ac:	683b      	ldr	r3, [r7, #0]
 80034ae:	7bba      	ldrb	r2, [r7, #14]
 80034b0:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
    }

    if(dsc->bg_opa != LV_OPA_TRANSP || dsc->border_opa != LV_OPA_TRANSP || dsc->shadow_opa != LV_OPA_TRANSP) {
 80034b4:	683b      	ldr	r3, [r7, #0]
 80034b6:	f893 3020 	ldrb.w	r3, [r3, #32]
 80034ba:	2b00      	cmp	r3, #0
 80034bc:	d109      	bne.n	80034d2 <scrollbar_init_draw_dsc+0x186>
 80034be:	683b      	ldr	r3, [r7, #0]
 80034c0:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 80034c4:	2b00      	cmp	r3, #0
 80034c6:	d104      	bne.n	80034d2 <scrollbar_init_draw_dsc+0x186>
 80034c8:	683b      	ldr	r3, [r7, #0]
 80034ca:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
 80034ce:	2b00      	cmp	r3, #0
 80034d0:	d009      	beq.n	80034e6 <scrollbar_init_draw_dsc+0x19a>
        dsc->radius = lv_obj_get_style_radius(obj, LV_PART_SCROLLBAR);
 80034d2:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 80034d6:	6878      	ldr	r0, [r7, #4]
 80034d8:	f7ff fb52 	bl	8002b80 <lv_obj_get_style_radius>
 80034dc:	4602      	mov	r2, r0
 80034de:	683b      	ldr	r3, [r7, #0]
 80034e0:	61da      	str	r2, [r3, #28]
        return LV_RESULT_OK;
 80034e2:	2301      	movs	r3, #1
 80034e4:	e000      	b.n	80034e8 <scrollbar_init_draw_dsc+0x19c>
    }
    else {
        return LV_RESULT_INVALID;
 80034e6:	2300      	movs	r3, #0
    }
}
 80034e8:	4618      	mov	r0, r3
 80034ea:	3714      	adds	r7, #20
 80034ec:	46bd      	mov	sp, r7
 80034ee:	bd90      	pop	{r4, r7, pc}

080034f0 <lv_obj_event>:

static void lv_obj_event(const lv_obj_class_t * class_p, lv_event_t * e)
{
 80034f0:	b590      	push	{r4, r7, lr}
 80034f2:	b0a5      	sub	sp, #148	@ 0x94
 80034f4:	af00      	add	r7, sp, #0
 80034f6:	6078      	str	r0, [r7, #4]
 80034f8:	6039      	str	r1, [r7, #0]
    LV_UNUSED(class_p);

    lv_event_code_t code = lv_event_get_code(e);
 80034fa:	6838      	ldr	r0, [r7, #0]
 80034fc:	f01f f9a8 	bl	8022850 <lv_event_get_code>
 8003500:	4603      	mov	r3, r0
 8003502:	f8a7 307e 	strh.w	r3, [r7, #126]	@ 0x7e
    lv_obj_t * obj = lv_event_get_current_target(e);
 8003506:	6838      	ldr	r0, [r7, #0]
 8003508:	f01f f996 	bl	8022838 <lv_event_get_current_target>
 800350c:	67b8      	str	r0, [r7, #120]	@ 0x78
    if(code == LV_EVENT_PRESSED) {
 800350e:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 8003512:	2b01      	cmp	r3, #1
 8003514:	d104      	bne.n	8003520 <lv_obj_event+0x30>
        lv_obj_add_state(obj, LV_STATE_PRESSED);
 8003516:	2120      	movs	r1, #32
 8003518:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800351a:	f7ff fbd8 	bl	8002cce <lv_obj_add_state>
 800351e:	e293      	b.n	8003a48 <lv_obj_event+0x558>
    }
    else if(code == LV_EVENT_RELEASED) {
 8003520:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 8003524:	2b08      	cmp	r3, #8
 8003526:	d133      	bne.n	8003590 <lv_obj_event+0xa0>
        lv_obj_remove_state(obj, LV_STATE_PRESSED);
 8003528:	2120      	movs	r1, #32
 800352a:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800352c:	f7ff fbf1 	bl	8002d12 <lv_obj_remove_state>
        void * param = lv_event_get_param(e);
 8003530:	6838      	ldr	r0, [r7, #0]
 8003532:	f01f f99c 	bl	802286e <lv_event_get_param>
 8003536:	6338      	str	r0, [r7, #48]	@ 0x30
        /*Go the checked state if enabled*/
        if(lv_indev_get_scroll_obj(param) == NULL && lv_obj_has_flag(obj, LV_OBJ_FLAG_CHECKABLE)) {
 8003538:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 800353a:	f019 fccc 	bl	801ced6 <lv_indev_get_scroll_obj>
 800353e:	4603      	mov	r3, r0
 8003540:	2b00      	cmp	r3, #0
 8003542:	f040 8281 	bne.w	8003a48 <lv_obj_event+0x558>
 8003546:	2108      	movs	r1, #8
 8003548:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800354a:	f7ff fc00 	bl	8002d4e <lv_obj_has_flag>
 800354e:	4603      	mov	r3, r0
 8003550:	2b00      	cmp	r3, #0
 8003552:	f000 8279 	beq.w	8003a48 <lv_obj_event+0x558>
            if(!(lv_obj_get_state(obj) & LV_STATE_CHECKED)) lv_obj_add_state(obj, LV_STATE_CHECKED);
 8003556:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003558:	f7ff fc22 	bl	8002da0 <lv_obj_get_state>
 800355c:	4603      	mov	r3, r0
 800355e:	f003 0301 	and.w	r3, r3, #1
 8003562:	2b00      	cmp	r3, #0
 8003564:	d104      	bne.n	8003570 <lv_obj_event+0x80>
 8003566:	2101      	movs	r1, #1
 8003568:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800356a:	f7ff fbb0 	bl	8002cce <lv_obj_add_state>
 800356e:	e003      	b.n	8003578 <lv_obj_event+0x88>
            else lv_obj_remove_state(obj, LV_STATE_CHECKED);
 8003570:	2101      	movs	r1, #1
 8003572:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003574:	f7ff fbcd 	bl	8002d12 <lv_obj_remove_state>

            lv_result_t res = lv_obj_send_event(obj, LV_EVENT_VALUE_CHANGED, NULL);
 8003578:	2200      	movs	r2, #0
 800357a:	211d      	movs	r1, #29
 800357c:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800357e:	f001 fc49 	bl	8004e14 <lv_obj_send_event>
 8003582:	4603      	mov	r3, r0
 8003584:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
            if(res != LV_RESULT_OK) return;
 8003588:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800358c:	2b01      	cmp	r3, #1
 800358e:	e25b      	b.n	8003a48 <lv_obj_event+0x558>
        }
    }
    else if(code == LV_EVENT_PRESS_LOST) {
 8003590:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 8003594:	2b03      	cmp	r3, #3
 8003596:	d104      	bne.n	80035a2 <lv_obj_event+0xb2>
        lv_obj_remove_state(obj, LV_STATE_PRESSED);
 8003598:	2120      	movs	r1, #32
 800359a:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800359c:	f7ff fbb9 	bl	8002d12 <lv_obj_remove_state>
 80035a0:	e252      	b.n	8003a48 <lv_obj_event+0x558>
    }
    else if(code == LV_EVENT_STYLE_CHANGED) {
 80035a2:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 80035a6:	2b2c      	cmp	r3, #44	@ 0x2c
 80035a8:	d11e      	bne.n	80035e8 <lv_obj_event+0xf8>
        uint32_t child_cnt = lv_obj_get_child_count(obj);
 80035aa:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80035ac:	f007 fc88 	bl	800aec0 <lv_obj_get_child_count>
 80035b0:	63b8      	str	r0, [r7, #56]	@ 0x38
        for(uint32_t i = 0; i < child_cnt; i++) {
 80035b2:	2300      	movs	r3, #0
 80035b4:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 80035b8:	e010      	b.n	80035dc <lv_obj_event+0xec>
            lv_obj_t * child = obj->spec_attr->children[i];
 80035ba:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 80035bc:	689b      	ldr	r3, [r3, #8]
 80035be:	681a      	ldr	r2, [r3, #0]
 80035c0:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80035c4:	009b      	lsls	r3, r3, #2
 80035c6:	4413      	add	r3, r2
 80035c8:	681b      	ldr	r3, [r3, #0]
 80035ca:	637b      	str	r3, [r7, #52]	@ 0x34
            lv_obj_mark_layout_as_dirty(child);
 80035cc:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80035ce:	f002 fb35 	bl	8005c3c <lv_obj_mark_layout_as_dirty>
        for(uint32_t i = 0; i < child_cnt; i++) {
 80035d2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80035d6:	3301      	adds	r3, #1
 80035d8:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 80035dc:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 80035e0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80035e2:	429a      	cmp	r2, r3
 80035e4:	d3e9      	bcc.n	80035ba <lv_obj_event+0xca>
 80035e6:	e22f      	b.n	8003a48 <lv_obj_event+0x558>
        }
    }
    else if(code == LV_EVENT_KEY) {
 80035e8:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 80035ec:	2b0e      	cmp	r3, #14
 80035ee:	f040 80f6 	bne.w	80037de <lv_obj_event+0x2ee>
        if(lv_obj_has_flag(obj, LV_OBJ_FLAG_CHECKABLE)) {
 80035f2:	2108      	movs	r1, #8
 80035f4:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80035f6:	f7ff fbaa 	bl	8002d4e <lv_obj_has_flag>
 80035fa:	4603      	mov	r3, r0
 80035fc:	2b00      	cmp	r3, #0
 80035fe:	d028      	beq.n	8003652 <lv_obj_event+0x162>
            uint32_t c = lv_event_get_key(e);
 8003600:	6838      	ldr	r0, [r7, #0]
 8003602:	f001 fcf9 	bl	8004ff8 <lv_event_get_key>
 8003606:	6438      	str	r0, [r7, #64]	@ 0x40
            if(c == LV_KEY_RIGHT || c == LV_KEY_UP) {
 8003608:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800360a:	2b13      	cmp	r3, #19
 800360c:	d002      	beq.n	8003614 <lv_obj_event+0x124>
 800360e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8003610:	2b11      	cmp	r3, #17
 8003612:	d104      	bne.n	800361e <lv_obj_event+0x12e>
                lv_obj_add_state(obj, LV_STATE_CHECKED);
 8003614:	2101      	movs	r1, #1
 8003616:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003618:	f7ff fb59 	bl	8002cce <lv_obj_add_state>
 800361c:	e009      	b.n	8003632 <lv_obj_event+0x142>
            }
            else if(c == LV_KEY_LEFT || c == LV_KEY_DOWN) {
 800361e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8003620:	2b14      	cmp	r3, #20
 8003622:	d002      	beq.n	800362a <lv_obj_event+0x13a>
 8003624:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8003626:	2b12      	cmp	r3, #18
 8003628:	d103      	bne.n	8003632 <lv_obj_event+0x142>
                lv_obj_remove_state(obj, LV_STATE_CHECKED);
 800362a:	2101      	movs	r1, #1
 800362c:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800362e:	f7ff fb70 	bl	8002d12 <lv_obj_remove_state>
            }

            /*With Enter LV_EVENT_RELEASED will send VALUE_CHANGE event*/
            if(c != LV_KEY_ENTER) {
 8003632:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8003634:	2b0a      	cmp	r3, #10
 8003636:	f000 8207 	beq.w	8003a48 <lv_obj_event+0x558>
                lv_result_t res = lv_obj_send_event(obj, LV_EVENT_VALUE_CHANGED, NULL);
 800363a:	2200      	movs	r2, #0
 800363c:	211d      	movs	r1, #29
 800363e:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003640:	f001 fbe8 	bl	8004e14 <lv_obj_send_event>
 8003644:	4603      	mov	r3, r0
 8003646:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
                if(res != LV_RESULT_OK) return;
 800364a:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 800364e:	2b01      	cmp	r3, #1
 8003650:	e1fa      	b.n	8003a48 <lv_obj_event+0x558>
            }
        }
        else if(lv_obj_has_flag(obj, LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_WITH_ARROW) && !lv_obj_is_editable(obj)) {
 8003652:	f44f 6101 	mov.w	r1, #2064	@ 0x810
 8003656:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003658:	f7ff fb79 	bl	8002d4e <lv_obj_has_flag>
 800365c:	4603      	mov	r3, r0
 800365e:	2b00      	cmp	r3, #0
 8003660:	f000 81f2 	beq.w	8003a48 <lv_obj_event+0x558>
 8003664:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003666:	f000 fc3a 	bl	8003ede <lv_obj_is_editable>
 800366a:	4603      	mov	r3, r0
 800366c:	f083 0301 	eor.w	r3, r3, #1
 8003670:	b2db      	uxtb	r3, r3
 8003672:	2b00      	cmp	r3, #0
 8003674:	f000 81e8 	beq.w	8003a48 <lv_obj_event+0x558>
            /*scroll by keypad or encoder*/
            lv_anim_enable_t anim_enable = LV_ANIM_OFF;
 8003678:	2300      	movs	r3, #0
 800367a:	f887 3051 	strb.w	r3, [r7, #81]	@ 0x51
            int32_t sl = lv_obj_get_scroll_left(obj);
 800367e:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003680:	f003 ff84 	bl	800758c <lv_obj_get_scroll_left>
 8003684:	64f8      	str	r0, [r7, #76]	@ 0x4c
            int32_t sr = lv_obj_get_scroll_right(obj);
 8003686:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003688:	f004 f808 	bl	800769c <lv_obj_get_scroll_right>
 800368c:	64b8      	str	r0, [r7, #72]	@ 0x48
            uint32_t c = lv_event_get_key(e);
 800368e:	6838      	ldr	r0, [r7, #0]
 8003690:	f001 fcb2 	bl	8004ff8 <lv_event_get_key>
 8003694:	6478      	str	r0, [r7, #68]	@ 0x44
            if(c == LV_KEY_DOWN) {
 8003696:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8003698:	2b12      	cmp	r3, #18
 800369a:	d113      	bne.n	80036c4 <lv_obj_event+0x1d4>
                /*use scroll_to_x/y functions to enforce scroll limits*/
                lv_obj_scroll_to_y(obj, lv_obj_get_scroll_y(obj) + lv_obj_get_height(obj) / 4, anim_enable);
 800369c:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800369e:	f003 fee1 	bl	8007464 <lv_obj_get_scroll_y>
 80036a2:	4604      	mov	r4, r0
 80036a4:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80036a6:	f002 fb51 	bl	8005d4c <lv_obj_get_height>
 80036aa:	4603      	mov	r3, r0
 80036ac:	2b00      	cmp	r3, #0
 80036ae:	da00      	bge.n	80036b2 <lv_obj_event+0x1c2>
 80036b0:	3303      	adds	r3, #3
 80036b2:	109b      	asrs	r3, r3, #2
 80036b4:	4423      	add	r3, r4
 80036b6:	f897 2051 	ldrb.w	r2, [r7, #81]	@ 0x51
 80036ba:	4619      	mov	r1, r3
 80036bc:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80036be:	f004 fa1d 	bl	8007afc <lv_obj_scroll_to_y>
 80036c2:	e1c1      	b.n	8003a48 <lv_obj_event+0x558>
            }
            else if(c == LV_KEY_UP) {
 80036c4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80036c6:	2b11      	cmp	r3, #17
 80036c8:	d114      	bne.n	80036f4 <lv_obj_event+0x204>
                lv_obj_scroll_to_y(obj, lv_obj_get_scroll_y(obj) - lv_obj_get_height(obj) / 4, anim_enable);
 80036ca:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80036cc:	f003 feca 	bl	8007464 <lv_obj_get_scroll_y>
 80036d0:	4604      	mov	r4, r0
 80036d2:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80036d4:	f002 fb3a 	bl	8005d4c <lv_obj_get_height>
 80036d8:	4603      	mov	r3, r0
 80036da:	2b00      	cmp	r3, #0
 80036dc:	da00      	bge.n	80036e0 <lv_obj_event+0x1f0>
 80036de:	3303      	adds	r3, #3
 80036e0:	109b      	asrs	r3, r3, #2
 80036e2:	425b      	negs	r3, r3
 80036e4:	4423      	add	r3, r4
 80036e6:	f897 2051 	ldrb.w	r2, [r7, #81]	@ 0x51
 80036ea:	4619      	mov	r1, r3
 80036ec:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80036ee:	f004 fa05 	bl	8007afc <lv_obj_scroll_to_y>
 80036f2:	e1a9      	b.n	8003a48 <lv_obj_event+0x558>
            }
            else if(c == LV_KEY_RIGHT) {
 80036f4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80036f6:	2b13      	cmp	r3, #19
 80036f8:	d135      	bne.n	8003766 <lv_obj_event+0x276>
                /*If the object can't be scrolled horizontally then scroll it vertically*/
                if(!((lv_obj_get_scroll_dir(obj) & LV_DIR_HOR) && (sl > 0 || sr > 0)))
 80036fa:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80036fc:	f003 fe5a 	bl	80073b4 <lv_obj_get_scroll_dir>
 8003700:	4603      	mov	r3, r0
 8003702:	f003 0303 	and.w	r3, r3, #3
 8003706:	2b00      	cmp	r3, #0
 8003708:	d005      	beq.n	8003716 <lv_obj_event+0x226>
 800370a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800370c:	2b00      	cmp	r3, #0
 800370e:	dc16      	bgt.n	800373e <lv_obj_event+0x24e>
 8003710:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8003712:	2b00      	cmp	r3, #0
 8003714:	dc13      	bgt.n	800373e <lv_obj_event+0x24e>
                    lv_obj_scroll_to_y(obj, lv_obj_get_scroll_y(obj) + lv_obj_get_height(obj) / 4, anim_enable);
 8003716:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003718:	f003 fea4 	bl	8007464 <lv_obj_get_scroll_y>
 800371c:	4604      	mov	r4, r0
 800371e:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003720:	f002 fb14 	bl	8005d4c <lv_obj_get_height>
 8003724:	4603      	mov	r3, r0
 8003726:	2b00      	cmp	r3, #0
 8003728:	da00      	bge.n	800372c <lv_obj_event+0x23c>
 800372a:	3303      	adds	r3, #3
 800372c:	109b      	asrs	r3, r3, #2
 800372e:	4423      	add	r3, r4
 8003730:	f897 2051 	ldrb.w	r2, [r7, #81]	@ 0x51
 8003734:	4619      	mov	r1, r3
 8003736:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003738:	f004 f9e0 	bl	8007afc <lv_obj_scroll_to_y>
 800373c:	e184      	b.n	8003a48 <lv_obj_event+0x558>
                else
                    lv_obj_scroll_to_x(obj, lv_obj_get_scroll_x(obj) + lv_obj_get_width(obj) / 4, anim_enable);
 800373e:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003740:	f003 fe7c 	bl	800743c <lv_obj_get_scroll_x>
 8003744:	4604      	mov	r4, r0
 8003746:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003748:	f002 faf2 	bl	8005d30 <lv_obj_get_width>
 800374c:	4603      	mov	r3, r0
 800374e:	2b00      	cmp	r3, #0
 8003750:	da00      	bge.n	8003754 <lv_obj_event+0x264>
 8003752:	3303      	adds	r3, #3
 8003754:	109b      	asrs	r3, r3, #2
 8003756:	4423      	add	r3, r4
 8003758:	f897 2051 	ldrb.w	r2, [r7, #81]	@ 0x51
 800375c:	4619      	mov	r1, r3
 800375e:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003760:	f004 f9ac 	bl	8007abc <lv_obj_scroll_to_x>
 8003764:	e170      	b.n	8003a48 <lv_obj_event+0x558>
            }
            else if(c == LV_KEY_LEFT) {
 8003766:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8003768:	2b14      	cmp	r3, #20
 800376a:	f040 816d 	bne.w	8003a48 <lv_obj_event+0x558>
                /*If the object can't be scrolled horizontally then scroll it vertically*/
                if(!((lv_obj_get_scroll_dir(obj) & LV_DIR_HOR) && (sl > 0 || sr > 0)))
 800376e:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003770:	f003 fe20 	bl	80073b4 <lv_obj_get_scroll_dir>
 8003774:	4603      	mov	r3, r0
 8003776:	f003 0303 	and.w	r3, r3, #3
 800377a:	2b00      	cmp	r3, #0
 800377c:	d005      	beq.n	800378a <lv_obj_event+0x29a>
 800377e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8003780:	2b00      	cmp	r3, #0
 8003782:	dc17      	bgt.n	80037b4 <lv_obj_event+0x2c4>
 8003784:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8003786:	2b00      	cmp	r3, #0
 8003788:	dc14      	bgt.n	80037b4 <lv_obj_event+0x2c4>
                    lv_obj_scroll_to_y(obj, lv_obj_get_scroll_y(obj) - lv_obj_get_height(obj) / 4, anim_enable);
 800378a:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800378c:	f003 fe6a 	bl	8007464 <lv_obj_get_scroll_y>
 8003790:	4604      	mov	r4, r0
 8003792:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003794:	f002 fada 	bl	8005d4c <lv_obj_get_height>
 8003798:	4603      	mov	r3, r0
 800379a:	2b00      	cmp	r3, #0
 800379c:	da00      	bge.n	80037a0 <lv_obj_event+0x2b0>
 800379e:	3303      	adds	r3, #3
 80037a0:	109b      	asrs	r3, r3, #2
 80037a2:	425b      	negs	r3, r3
 80037a4:	4423      	add	r3, r4
 80037a6:	f897 2051 	ldrb.w	r2, [r7, #81]	@ 0x51
 80037aa:	4619      	mov	r1, r3
 80037ac:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80037ae:	f004 f9a5 	bl	8007afc <lv_obj_scroll_to_y>
 80037b2:	e149      	b.n	8003a48 <lv_obj_event+0x558>
                else
                    lv_obj_scroll_to_x(obj, lv_obj_get_scroll_x(obj) - lv_obj_get_width(obj) / 4, anim_enable);
 80037b4:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80037b6:	f003 fe41 	bl	800743c <lv_obj_get_scroll_x>
 80037ba:	4604      	mov	r4, r0
 80037bc:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80037be:	f002 fab7 	bl	8005d30 <lv_obj_get_width>
 80037c2:	4603      	mov	r3, r0
 80037c4:	2b00      	cmp	r3, #0
 80037c6:	da00      	bge.n	80037ca <lv_obj_event+0x2da>
 80037c8:	3303      	adds	r3, #3
 80037ca:	109b      	asrs	r3, r3, #2
 80037cc:	425b      	negs	r3, r3
 80037ce:	4423      	add	r3, r4
 80037d0:	f897 2051 	ldrb.w	r2, [r7, #81]	@ 0x51
 80037d4:	4619      	mov	r1, r3
 80037d6:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80037d8:	f004 f970 	bl	8007abc <lv_obj_scroll_to_x>
 80037dc:	e134      	b.n	8003a48 <lv_obj_event+0x558>
            }
        }
    }
    else if(code == LV_EVENT_FOCUSED) {
 80037de:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 80037e2:	2b0f      	cmp	r3, #15
 80037e4:	d159      	bne.n	800389a <lv_obj_event+0x3aa>
        if(lv_obj_has_flag(obj, LV_OBJ_FLAG_SCROLL_ON_FOCUS)) {
 80037e6:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 80037ea:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80037ec:	f7ff faaf 	bl	8002d4e <lv_obj_has_flag>
 80037f0:	4603      	mov	r3, r0
 80037f2:	2b00      	cmp	r3, #0
 80037f4:	d003      	beq.n	80037fe <lv_obj_event+0x30e>
            lv_obj_scroll_to_view_recursive(obj, LV_ANIM_ON);
 80037f6:	2101      	movs	r1, #1
 80037f8:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80037fa:	f004 f99f 	bl	8007b3c <lv_obj_scroll_to_view_recursive>
        }

        bool editing = false;
 80037fe:	2300      	movs	r3, #0
 8003800:	f887 3053 	strb.w	r3, [r7, #83]	@ 0x53
        editing = lv_group_get_editing(lv_obj_get_group(obj));
 8003804:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003806:	f7ff fad7 	bl	8002db8 <lv_obj_get_group>
 800380a:	4603      	mov	r3, r0
 800380c:	4618      	mov	r0, r3
 800380e:	f7fe fe35 	bl	800247c <lv_group_get_editing>
 8003812:	4603      	mov	r3, r0
 8003814:	f887 3053 	strb.w	r3, [r7, #83]	@ 0x53
        lv_state_t state = LV_STATE_FOCUSED;
 8003818:	2302      	movs	r3, #2
 800381a:	f8a7 308a 	strh.w	r3, [r7, #138]	@ 0x8a

        /* Use the indev for then indev handler.
         * But if the obj was focused manually it returns NULL so try to
         * use the indev from the event*/
        lv_indev_t * indev = lv_indev_active();
 800381e:	f019 fae5 	bl	801cdec <lv_indev_active>
 8003822:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84
        if(indev == NULL) indev = lv_event_get_indev(e);
 8003826:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 800382a:	2b00      	cmp	r3, #0
 800382c:	d104      	bne.n	8003838 <lv_obj_event+0x348>
 800382e:	6838      	ldr	r0, [r7, #0]
 8003830:	f001 fb6e 	bl	8004f10 <lv_event_get_indev>
 8003834:	f8c7 0084 	str.w	r0, [r7, #132]	@ 0x84

        lv_indev_type_t indev_type = lv_indev_get_type(indev);
 8003838:	f8d7 0084 	ldr.w	r0, [r7, #132]	@ 0x84
 800383c:	f019 fae2 	bl	801ce04 <lv_indev_get_type>
 8003840:	4603      	mov	r3, r0
 8003842:	f887 3052 	strb.w	r3, [r7, #82]	@ 0x52
        if(indev_type == LV_INDEV_TYPE_KEYPAD || indev_type == LV_INDEV_TYPE_ENCODER) state |= LV_STATE_FOCUS_KEY;
 8003846:	f897 3052 	ldrb.w	r3, [r7, #82]	@ 0x52
 800384a:	2b02      	cmp	r3, #2
 800384c:	d003      	beq.n	8003856 <lv_obj_event+0x366>
 800384e:	f897 3052 	ldrb.w	r3, [r7, #82]	@ 0x52
 8003852:	2b04      	cmp	r3, #4
 8003854:	d105      	bne.n	8003862 <lv_obj_event+0x372>
 8003856:	f8b7 308a 	ldrh.w	r3, [r7, #138]	@ 0x8a
 800385a:	f043 0304 	orr.w	r3, r3, #4
 800385e:	f8a7 308a 	strh.w	r3, [r7, #138]	@ 0x8a
        if(editing) {
 8003862:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 8003866:	2b00      	cmp	r3, #0
 8003868:	d00c      	beq.n	8003884 <lv_obj_event+0x394>
            state |= LV_STATE_EDITED;
 800386a:	f8b7 308a 	ldrh.w	r3, [r7, #138]	@ 0x8a
 800386e:	f043 0308 	orr.w	r3, r3, #8
 8003872:	f8a7 308a 	strh.w	r3, [r7, #138]	@ 0x8a
            lv_obj_add_state(obj, state);
 8003876:	f8b7 308a 	ldrh.w	r3, [r7, #138]	@ 0x8a
 800387a:	4619      	mov	r1, r3
 800387c:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800387e:	f7ff fa26 	bl	8002cce <lv_obj_add_state>
 8003882:	e0e1      	b.n	8003a48 <lv_obj_event+0x558>
        }
        else {
            lv_obj_add_state(obj, state);
 8003884:	f8b7 308a 	ldrh.w	r3, [r7, #138]	@ 0x8a
 8003888:	4619      	mov	r1, r3
 800388a:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800388c:	f7ff fa1f 	bl	8002cce <lv_obj_add_state>
            lv_obj_remove_state(obj, LV_STATE_EDITED);
 8003890:	2108      	movs	r1, #8
 8003892:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003894:	f7ff fa3d 	bl	8002d12 <lv_obj_remove_state>
 8003898:	e0d6      	b.n	8003a48 <lv_obj_event+0x558>
        }
    }
    else if(code == LV_EVENT_SCROLL_BEGIN) {
 800389a:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 800389e:	2b09      	cmp	r3, #9
 80038a0:	d104      	bne.n	80038ac <lv_obj_event+0x3bc>
        lv_obj_add_state(obj, LV_STATE_SCROLLED);
 80038a2:	2140      	movs	r1, #64	@ 0x40
 80038a4:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80038a6:	f7ff fa12 	bl	8002cce <lv_obj_add_state>
 80038aa:	e0cd      	b.n	8003a48 <lv_obj_event+0x558>
    }
    else if(code == LV_EVENT_SCROLL_END) {
 80038ac:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 80038b0:	2b0b      	cmp	r3, #11
 80038b2:	d11f      	bne.n	80038f4 <lv_obj_event+0x404>
        lv_obj_remove_state(obj, LV_STATE_SCROLLED);
 80038b4:	2140      	movs	r1, #64	@ 0x40
 80038b6:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80038b8:	f7ff fa2b 	bl	8002d12 <lv_obj_remove_state>
        if(lv_obj_get_scrollbar_mode(obj) == LV_SCROLLBAR_MODE_ACTIVE) {
 80038bc:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80038be:	f003 fd62 	bl	8007386 <lv_obj_get_scrollbar_mode>
 80038c2:	4603      	mov	r3, r0
 80038c4:	2b02      	cmp	r3, #2
 80038c6:	f040 80bf 	bne.w	8003a48 <lv_obj_event+0x558>
            lv_area_t hor_area, ver_area;
            lv_obj_get_scrollbar_area(obj, &hor_area, &ver_area);
 80038ca:	f107 020c 	add.w	r2, r7, #12
 80038ce:	f107 031c 	add.w	r3, r7, #28
 80038d2:	4619      	mov	r1, r3
 80038d4:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80038d6:	f004 f997 	bl	8007c08 <lv_obj_get_scrollbar_area>
            lv_obj_invalidate_area(obj, &hor_area);
 80038da:	f107 031c 	add.w	r3, r7, #28
 80038de:	4619      	mov	r1, r3
 80038e0:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80038e2:	f002 fe78 	bl	80065d6 <lv_obj_invalidate_area>
            lv_obj_invalidate_area(obj, &ver_area);
 80038e6:	f107 030c 	add.w	r3, r7, #12
 80038ea:	4619      	mov	r1, r3
 80038ec:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80038ee:	f002 fe72 	bl	80065d6 <lv_obj_invalidate_area>
 80038f2:	e0a9      	b.n	8003a48 <lv_obj_event+0x558>
        }
    }
    else if(code == LV_EVENT_DEFOCUSED) {
 80038f4:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 80038f8:	2b10      	cmp	r3, #16
 80038fa:	d104      	bne.n	8003906 <lv_obj_event+0x416>
        lv_obj_remove_state(obj, LV_STATE_FOCUSED | LV_STATE_EDITED | LV_STATE_FOCUS_KEY);
 80038fc:	210e      	movs	r1, #14
 80038fe:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003900:	f7ff fa07 	bl	8002d12 <lv_obj_remove_state>
 8003904:	e0a0      	b.n	8003a48 <lv_obj_event+0x558>
    }
    else if(code == LV_EVENT_SIZE_CHANGED) {
 8003906:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 800390a:	2b2b      	cmp	r3, #43	@ 0x2b
 800390c:	d135      	bne.n	800397a <lv_obj_event+0x48a>
        int32_t align = lv_obj_get_style_align(obj, LV_PART_MAIN);
 800390e:	2100      	movs	r1, #0
 8003910:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003912:	f7fe ffbf 	bl	8002894 <lv_obj_get_style_align>
 8003916:	4603      	mov	r3, r0
 8003918:	663b      	str	r3, [r7, #96]	@ 0x60
        uint16_t layout = lv_obj_get_style_layout(obj, LV_PART_MAIN);
 800391a:	2100      	movs	r1, #0
 800391c:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800391e:	f7ff f968 	bl	8002bf2 <lv_obj_get_style_layout>
 8003922:	4603      	mov	r3, r0
 8003924:	f8a7 305e 	strh.w	r3, [r7, #94]	@ 0x5e
        if(layout || align) {
 8003928:	f8b7 305e 	ldrh.w	r3, [r7, #94]	@ 0x5e
 800392c:	2b00      	cmp	r3, #0
 800392e:	d102      	bne.n	8003936 <lv_obj_event+0x446>
 8003930:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8003932:	2b00      	cmp	r3, #0
 8003934:	d002      	beq.n	800393c <lv_obj_event+0x44c>
            lv_obj_mark_layout_as_dirty(obj);
 8003936:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003938:	f002 f980 	bl	8005c3c <lv_obj_mark_layout_as_dirty>
        }

        uint32_t i;
        uint32_t child_cnt = lv_obj_get_child_count(obj);
 800393c:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800393e:	f007 fabf 	bl	800aec0 <lv_obj_get_child_count>
 8003942:	65b8      	str	r0, [r7, #88]	@ 0x58
        for(i = 0; i < child_cnt; i++) {
 8003944:	2300      	movs	r3, #0
 8003946:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 800394a:	e010      	b.n	800396e <lv_obj_event+0x47e>
            lv_obj_t * child = obj->spec_attr->children[i];
 800394c:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800394e:	689b      	ldr	r3, [r3, #8]
 8003950:	681a      	ldr	r2, [r3, #0]
 8003952:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8003956:	009b      	lsls	r3, r3, #2
 8003958:	4413      	add	r3, r2
 800395a:	681b      	ldr	r3, [r3, #0]
 800395c:	657b      	str	r3, [r7, #84]	@ 0x54
            lv_obj_mark_layout_as_dirty(child);
 800395e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8003960:	f002 f96c 	bl	8005c3c <lv_obj_mark_layout_as_dirty>
        for(i = 0; i < child_cnt; i++) {
 8003964:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8003968:	3301      	adds	r3, #1
 800396a:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 800396e:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 8003972:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8003974:	429a      	cmp	r2, r3
 8003976:	d3e9      	bcc.n	800394c <lv_obj_event+0x45c>
 8003978:	e066      	b.n	8003a48 <lv_obj_event+0x558>
        }
    }
    else if(code == LV_EVENT_CHILD_CHANGED) {
 800397a:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 800397e:	2b24      	cmp	r3, #36	@ 0x24
 8003980:	d129      	bne.n	80039d6 <lv_obj_event+0x4e6>
        int32_t w = lv_obj_get_style_width(obj, LV_PART_MAIN);
 8003982:	2100      	movs	r1, #0
 8003984:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003986:	f7fe ff63 	bl	8002850 <lv_obj_get_style_width>
 800398a:	6738      	str	r0, [r7, #112]	@ 0x70
        int32_t h = lv_obj_get_style_height(obj, LV_PART_MAIN);
 800398c:	2100      	movs	r1, #0
 800398e:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003990:	f7fe ff6f 	bl	8002872 <lv_obj_get_style_height>
 8003994:	66f8      	str	r0, [r7, #108]	@ 0x6c
        int32_t align = lv_obj_get_style_align(obj, LV_PART_MAIN);
 8003996:	2100      	movs	r1, #0
 8003998:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 800399a:	f7fe ff7b 	bl	8002894 <lv_obj_get_style_align>
 800399e:	4603      	mov	r3, r0
 80039a0:	66bb      	str	r3, [r7, #104]	@ 0x68
        uint16_t layout = lv_obj_get_style_layout(obj, LV_PART_MAIN);
 80039a2:	2100      	movs	r1, #0
 80039a4:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80039a6:	f7ff f924 	bl	8002bf2 <lv_obj_get_style_layout>
 80039aa:	4603      	mov	r3, r0
 80039ac:	f8a7 3066 	strh.w	r3, [r7, #102]	@ 0x66
        if(layout || align || w == LV_SIZE_CONTENT || h == LV_SIZE_CONTENT) {
 80039b0:	f8b7 3066 	ldrh.w	r3, [r7, #102]	@ 0x66
 80039b4:	2b00      	cmp	r3, #0
 80039b6:	d10a      	bne.n	80039ce <lv_obj_event+0x4de>
 80039b8:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80039ba:	2b00      	cmp	r3, #0
 80039bc:	d107      	bne.n	80039ce <lv_obj_event+0x4de>
 80039be:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80039c0:	4a23      	ldr	r2, [pc, #140]	@ (8003a50 <lv_obj_event+0x560>)
 80039c2:	4293      	cmp	r3, r2
 80039c4:	d003      	beq.n	80039ce <lv_obj_event+0x4de>
 80039c6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80039c8:	4a21      	ldr	r2, [pc, #132]	@ (8003a50 <lv_obj_event+0x560>)
 80039ca:	4293      	cmp	r3, r2
 80039cc:	d13c      	bne.n	8003a48 <lv_obj_event+0x558>
            lv_obj_mark_layout_as_dirty(obj);
 80039ce:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80039d0:	f002 f934 	bl	8005c3c <lv_obj_mark_layout_as_dirty>
 80039d4:	e038      	b.n	8003a48 <lv_obj_event+0x558>
        }
    }
    else if(code == LV_EVENT_CHILD_DELETED) {
 80039d6:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 80039da:	2b26      	cmp	r3, #38	@ 0x26
 80039dc:	d10a      	bne.n	80039f4 <lv_obj_event+0x504>
        obj->readjust_scroll_after_layout = 1;
 80039de:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 80039e0:	f892 302a 	ldrb.w	r3, [r2, #42]	@ 0x2a
 80039e4:	f043 0302 	orr.w	r3, r3, #2
 80039e8:	f882 302a 	strb.w	r3, [r2, #42]	@ 0x2a
        lv_obj_mark_layout_as_dirty(obj);
 80039ec:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 80039ee:	f002 f925 	bl	8005c3c <lv_obj_mark_layout_as_dirty>
 80039f2:	e029      	b.n	8003a48 <lv_obj_event+0x558>
    }
    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {
 80039f4:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 80039f8:	2b15      	cmp	r3, #21
 80039fa:	d109      	bne.n	8003a10 <lv_obj_event+0x520>
        int32_t d = lv_obj_calculate_ext_draw_size(obj, LV_PART_MAIN);
 80039fc:	2100      	movs	r1, #0
 80039fe:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003a00:	f001 f92e 	bl	8004c60 <lv_obj_calculate_ext_draw_size>
 8003a04:	6778      	str	r0, [r7, #116]	@ 0x74
        lv_event_set_ext_draw_size(e, d);
 8003a06:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 8003a08:	6838      	ldr	r0, [r7, #0]
 8003a0a:	f001 fb0e 	bl	800502a <lv_event_set_ext_draw_size>
 8003a0e:	e01b      	b.n	8003a48 <lv_obj_event+0x558>
    }
    else if(code == LV_EVENT_DRAW_MAIN || code == LV_EVENT_DRAW_POST || code == LV_EVENT_COVER_CHECK) {
 8003a10:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 8003a14:	2b17      	cmp	r3, #23
 8003a16:	d007      	beq.n	8003a28 <lv_obj_event+0x538>
 8003a18:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 8003a1c:	2b1a      	cmp	r3, #26
 8003a1e:	d003      	beq.n	8003a28 <lv_obj_event+0x538>
 8003a20:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 8003a24:	2b14      	cmp	r3, #20
 8003a26:	d103      	bne.n	8003a30 <lv_obj_event+0x540>
        lv_obj_draw(e);
 8003a28:	6838      	ldr	r0, [r7, #0]
 8003a2a:	f7ff fac2 	bl	8002fb2 <lv_obj_draw>
 8003a2e:	e00b      	b.n	8003a48 <lv_obj_event+0x558>
    }
    else if(code == LV_EVENT_INDEV_RESET) {
 8003a30:	f8b7 307e 	ldrh.w	r3, [r7, #126]	@ 0x7e
 8003a34:	2b13      	cmp	r3, #19
 8003a36:	d107      	bne.n	8003a48 <lv_obj_event+0x558>
        lv_obj_remove_state(obj, LV_STATE_PRESSED);
 8003a38:	2120      	movs	r1, #32
 8003a3a:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003a3c:	f7ff f969 	bl	8002d12 <lv_obj_remove_state>
        lv_obj_remove_state(obj, LV_STATE_SCROLLED);
 8003a40:	2140      	movs	r1, #64	@ 0x40
 8003a42:	6fb8      	ldr	r0, [r7, #120]	@ 0x78
 8003a44:	f7ff f965 	bl	8002d12 <lv_obj_remove_state>
    }
}
 8003a48:	3794      	adds	r7, #148	@ 0x94
 8003a4a:	46bd      	mov	sp, r7
 8003a4c:	bd90      	pop	{r4, r7, pc}
 8003a4e:	bf00      	nop
 8003a50:	200007d1 	.word	0x200007d1

08003a54 <update_obj_state>:
 * If specified in the styles, transition animations will be started from the previous state to the current.
 * @param obj       pointer to an object
 * @param state     the new state
 */
static void update_obj_state(lv_obj_t * obj, lv_state_t new_state)
{
 8003a54:	b580      	push	{r7, lr}
 8003a56:	b094      	sub	sp, #80	@ 0x50
 8003a58:	af02      	add	r7, sp, #8
 8003a5a:	6078      	str	r0, [r7, #4]
 8003a5c:	460b      	mov	r3, r1
 8003a5e:	807b      	strh	r3, [r7, #2]
    if(obj->state == new_state) return;
 8003a60:	687b      	ldr	r3, [r7, #4]
 8003a62:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8003a64:	887a      	ldrh	r2, [r7, #2]
 8003a66:	429a      	cmp	r2, r3
 8003a68:	f000 815a 	beq.w	8003d20 <update_obj_state+0x2cc>

    LV_ASSERT_OBJ(obj, MY_CLASS);

    lv_state_t prev_state = obj->state;
 8003a6c:	687b      	ldr	r3, [r7, #4]
 8003a6e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8003a70:	86fb      	strh	r3, [r7, #54]	@ 0x36

    _lv_style_state_cmp_t cmp_res = _lv_obj_style_state_compare(obj, prev_state, new_state);
 8003a72:	887a      	ldrh	r2, [r7, #2]
 8003a74:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 8003a76:	4619      	mov	r1, r3
 8003a78:	6878      	ldr	r0, [r7, #4]
 8003a7a:	f006 f846 	bl	8009b0a <_lv_obj_style_state_compare>
 8003a7e:	4603      	mov	r3, r0
 8003a80:	f887 3035 	strb.w	r3, [r7, #53]	@ 0x35
    /*If there is no difference in styles there is nothing else to do*/
    if(cmp_res == _LV_STYLE_STATE_CMP_SAME) {
 8003a84:	f897 3035 	ldrb.w	r3, [r7, #53]	@ 0x35
 8003a88:	2b00      	cmp	r3, #0
 8003a8a:	d103      	bne.n	8003a94 <update_obj_state+0x40>
        obj->state = new_state;
 8003a8c:	687b      	ldr	r3, [r7, #4]
 8003a8e:	887a      	ldrh	r2, [r7, #2]
 8003a90:	851a      	strh	r2, [r3, #40]	@ 0x28
        return;
 8003a92:	e146      	b.n	8003d22 <update_obj_state+0x2ce>
    }

    /*Invalidate the object in their current state*/
    lv_obj_invalidate(obj);
 8003a94:	6878      	ldr	r0, [r7, #4]
 8003a96:	f002 fdd3 	bl	8006640 <lv_obj_invalidate>

    obj->state = new_state;
 8003a9a:	687b      	ldr	r3, [r7, #4]
 8003a9c:	887a      	ldrh	r2, [r7, #2]
 8003a9e:	851a      	strh	r2, [r3, #40]	@ 0x28

    _lv_obj_style_transition_dsc_t * ts = lv_malloc_zeroed(sizeof(_lv_obj_style_transition_dsc_t) * STYLE_TRANSITION_MAX);
 8003aa0:	f44f 7020 	mov.w	r0, #640	@ 0x280
 8003aa4:	f022 f9aa 	bl	8025dfc <lv_malloc_zeroed>
 8003aa8:	6338      	str	r0, [r7, #48]	@ 0x30
    uint32_t tsi = 0;
 8003aaa:	2300      	movs	r3, #0
 8003aac:	647b      	str	r3, [r7, #68]	@ 0x44
    uint32_t i;
    for(i = 0; i < obj->style_cnt && tsi < STYLE_TRANSITION_MAX; i++) {
 8003aae:	2300      	movs	r3, #0
 8003ab0:	643b      	str	r3, [r7, #64]	@ 0x40
 8003ab2:	e0dd      	b.n	8003c70 <update_obj_state+0x21c>
        _lv_obj_style_t * obj_style = &obj->styles[i];
 8003ab4:	687b      	ldr	r3, [r7, #4]
 8003ab6:	68da      	ldr	r2, [r3, #12]
 8003ab8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8003aba:	00db      	lsls	r3, r3, #3
 8003abc:	4413      	add	r3, r2
 8003abe:	62fb      	str	r3, [r7, #44]	@ 0x2c
        lv_state_t state_act = lv_obj_style_get_selector_state(obj->styles[i].selector);
 8003ac0:	687b      	ldr	r3, [r7, #4]
 8003ac2:	68da      	ldr	r2, [r3, #12]
 8003ac4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8003ac6:	00db      	lsls	r3, r3, #3
 8003ac8:	4413      	add	r3, r2
 8003aca:	685b      	ldr	r3, [r3, #4]
 8003acc:	f3c3 0317 	ubfx	r3, r3, #0, #24
 8003ad0:	4618      	mov	r0, r3
 8003ad2:	f7fe fea4 	bl	800281e <lv_obj_style_get_selector_state>
 8003ad6:	4603      	mov	r3, r0
 8003ad8:	857b      	strh	r3, [r7, #42]	@ 0x2a
        lv_part_t part_act = lv_obj_style_get_selector_part(obj->styles[i].selector);
 8003ada:	687b      	ldr	r3, [r7, #4]
 8003adc:	68da      	ldr	r2, [r3, #12]
 8003ade:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8003ae0:	00db      	lsls	r3, r3, #3
 8003ae2:	4413      	add	r3, r2
 8003ae4:	685b      	ldr	r3, [r3, #4]
 8003ae6:	f3c3 0317 	ubfx	r3, r3, #0, #24
 8003aea:	4618      	mov	r0, r3
 8003aec:	f7fe fea3 	bl	8002836 <lv_obj_style_get_selector_part>
 8003af0:	6278      	str	r0, [r7, #36]	@ 0x24
        if(state_act & (~new_state)) continue; /*Skip unrelated styles*/
 8003af2:	8d7a      	ldrh	r2, [r7, #42]	@ 0x2a
 8003af4:	887b      	ldrh	r3, [r7, #2]
 8003af6:	43db      	mvns	r3, r3
 8003af8:	4013      	ands	r3, r2
 8003afa:	2b00      	cmp	r3, #0
 8003afc:	f040 80b0 	bne.w	8003c60 <update_obj_state+0x20c>
        if(obj_style->is_trans) continue;
 8003b00:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003b02:	79db      	ldrb	r3, [r3, #7]
 8003b04:	f003 0302 	and.w	r3, r3, #2
 8003b08:	b2db      	uxtb	r3, r3
 8003b0a:	2b00      	cmp	r3, #0
 8003b0c:	f040 80aa 	bne.w	8003c64 <update_obj_state+0x210>

        lv_style_value_t v;
        if(lv_style_get_prop_inlined(obj_style->style, LV_STYLE_TRANSITION, &v) != LV_STYLE_RES_FOUND) continue;
 8003b10:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003b12:	681b      	ldr	r3, [r3, #0]
 8003b14:	f107 020c 	add.w	r2, r7, #12
 8003b18:	2166      	movs	r1, #102	@ 0x66
 8003b1a:	4618      	mov	r0, r3
 8003b1c:	f7fe fe24 	bl	8002768 <lv_style_get_prop_inlined>
 8003b20:	4603      	mov	r3, r0
 8003b22:	2b01      	cmp	r3, #1
 8003b24:	f040 80a0 	bne.w	8003c68 <update_obj_state+0x214>
        const lv_style_transition_dsc_t * tr = v.ptr;
 8003b28:	68fb      	ldr	r3, [r7, #12]
 8003b2a:	623b      	str	r3, [r7, #32]

        /*Add the props to the set if not added yet or added but with smaller weight*/
        uint32_t j;
        for(j = 0; tr->props[j] != 0 && tsi < STYLE_TRANSITION_MAX; j++) {
 8003b2c:	2300      	movs	r3, #0
 8003b2e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8003b30:	e08a      	b.n	8003c48 <update_obj_state+0x1f4>
            uint32_t t;
            for(t = 0; t < tsi; t++) {
 8003b32:	2300      	movs	r3, #0
 8003b34:	63bb      	str	r3, [r7, #56]	@ 0x38
 8003b36:	e02d      	b.n	8003b94 <update_obj_state+0x140>
                lv_style_selector_t selector = ts[t].selector;
 8003b38:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8003b3a:	4613      	mov	r3, r2
 8003b3c:	009b      	lsls	r3, r3, #2
 8003b3e:	4413      	add	r3, r2
 8003b40:	009b      	lsls	r3, r3, #2
 8003b42:	461a      	mov	r2, r3
 8003b44:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8003b46:	4413      	add	r3, r2
 8003b48:	685b      	ldr	r3, [r3, #4]
 8003b4a:	61fb      	str	r3, [r7, #28]
                lv_state_t state_ts = lv_obj_style_get_selector_state(selector);
 8003b4c:	69f8      	ldr	r0, [r7, #28]
 8003b4e:	f7fe fe66 	bl	800281e <lv_obj_style_get_selector_state>
 8003b52:	4603      	mov	r3, r0
 8003b54:	837b      	strh	r3, [r7, #26]
                lv_part_t part_ts = lv_obj_style_get_selector_part(selector);
 8003b56:	69f8      	ldr	r0, [r7, #28]
 8003b58:	f7fe fe6d 	bl	8002836 <lv_obj_style_get_selector_part>
 8003b5c:	6178      	str	r0, [r7, #20]
                if(ts[t].prop == tr->props[j] && part_ts == part_act && state_ts >= state_act) break;
 8003b5e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8003b60:	4613      	mov	r3, r2
 8003b62:	009b      	lsls	r3, r3, #2
 8003b64:	4413      	add	r3, r2
 8003b66:	009b      	lsls	r3, r3, #2
 8003b68:	461a      	mov	r2, r3
 8003b6a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8003b6c:	4413      	add	r3, r2
 8003b6e:	7a1a      	ldrb	r2, [r3, #8]
 8003b70:	6a3b      	ldr	r3, [r7, #32]
 8003b72:	6819      	ldr	r1, [r3, #0]
 8003b74:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8003b76:	440b      	add	r3, r1
 8003b78:	781b      	ldrb	r3, [r3, #0]
 8003b7a:	429a      	cmp	r2, r3
 8003b7c:	d107      	bne.n	8003b8e <update_obj_state+0x13a>
 8003b7e:	697a      	ldr	r2, [r7, #20]
 8003b80:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003b82:	429a      	cmp	r2, r3
 8003b84:	d103      	bne.n	8003b8e <update_obj_state+0x13a>
 8003b86:	8b7a      	ldrh	r2, [r7, #26]
 8003b88:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8003b8a:	429a      	cmp	r2, r3
 8003b8c:	d207      	bcs.n	8003b9e <update_obj_state+0x14a>
            for(t = 0; t < tsi; t++) {
 8003b8e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8003b90:	3301      	adds	r3, #1
 8003b92:	63bb      	str	r3, [r7, #56]	@ 0x38
 8003b94:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8003b96:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8003b98:	429a      	cmp	r2, r3
 8003b9a:	d3cd      	bcc.n	8003b38 <update_obj_state+0xe4>
 8003b9c:	e000      	b.n	8003ba0 <update_obj_state+0x14c>
                if(ts[t].prop == tr->props[j] && part_ts == part_act && state_ts >= state_act) break;
 8003b9e:	bf00      	nop
            }

            /*If not found  add it*/
            if(t == tsi) {
 8003ba0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8003ba2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8003ba4:	429a      	cmp	r2, r3
 8003ba6:	d14c      	bne.n	8003c42 <update_obj_state+0x1ee>
                ts[tsi].time = tr->time;
 8003ba8:	6a3b      	ldr	r3, [r7, #32]
 8003baa:	68d9      	ldr	r1, [r3, #12]
 8003bac:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8003bae:	4613      	mov	r3, r2
 8003bb0:	009b      	lsls	r3, r3, #2
 8003bb2:	4413      	add	r3, r2
 8003bb4:	009b      	lsls	r3, r3, #2
 8003bb6:	461a      	mov	r2, r3
 8003bb8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8003bba:	4413      	add	r3, r2
 8003bbc:	b28a      	uxth	r2, r1
 8003bbe:	801a      	strh	r2, [r3, #0]
                ts[tsi].delay = tr->delay;
 8003bc0:	6a3b      	ldr	r3, [r7, #32]
 8003bc2:	6919      	ldr	r1, [r3, #16]
 8003bc4:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8003bc6:	4613      	mov	r3, r2
 8003bc8:	009b      	lsls	r3, r3, #2
 8003bca:	4413      	add	r3, r2
 8003bcc:	009b      	lsls	r3, r3, #2
 8003bce:	461a      	mov	r2, r3
 8003bd0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8003bd2:	4413      	add	r3, r2
 8003bd4:	b28a      	uxth	r2, r1
 8003bd6:	805a      	strh	r2, [r3, #2]
                ts[tsi].path_cb = tr->path_xcb;
 8003bd8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8003bda:	4613      	mov	r3, r2
 8003bdc:	009b      	lsls	r3, r3, #2
 8003bde:	4413      	add	r3, r2
 8003be0:	009b      	lsls	r3, r3, #2
 8003be2:	461a      	mov	r2, r3
 8003be4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8003be6:	4413      	add	r3, r2
 8003be8:	6a3a      	ldr	r2, [r7, #32]
 8003bea:	6892      	ldr	r2, [r2, #8]
 8003bec:	60da      	str	r2, [r3, #12]
                ts[tsi].prop = tr->props[j];
 8003bee:	6a3b      	ldr	r3, [r7, #32]
 8003bf0:	681a      	ldr	r2, [r3, #0]
 8003bf2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8003bf4:	18d1      	adds	r1, r2, r3
 8003bf6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8003bf8:	4613      	mov	r3, r2
 8003bfa:	009b      	lsls	r3, r3, #2
 8003bfc:	4413      	add	r3, r2
 8003bfe:	009b      	lsls	r3, r3, #2
 8003c00:	461a      	mov	r2, r3
 8003c02:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8003c04:	4413      	add	r3, r2
 8003c06:	780a      	ldrb	r2, [r1, #0]
 8003c08:	721a      	strb	r2, [r3, #8]
                ts[tsi].user_data = tr->user_data;
 8003c0a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8003c0c:	4613      	mov	r3, r2
 8003c0e:	009b      	lsls	r3, r3, #2
 8003c10:	4413      	add	r3, r2
 8003c12:	009b      	lsls	r3, r3, #2
 8003c14:	461a      	mov	r2, r3
 8003c16:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8003c18:	4413      	add	r3, r2
 8003c1a:	6a3a      	ldr	r2, [r7, #32]
 8003c1c:	6852      	ldr	r2, [r2, #4]
 8003c1e:	611a      	str	r2, [r3, #16]
                ts[tsi].selector = obj_style->selector;
 8003c20:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003c22:	685b      	ldr	r3, [r3, #4]
 8003c24:	f3c3 0117 	ubfx	r1, r3, #0, #24
 8003c28:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8003c2a:	4613      	mov	r3, r2
 8003c2c:	009b      	lsls	r3, r3, #2
 8003c2e:	4413      	add	r3, r2
 8003c30:	009b      	lsls	r3, r3, #2
 8003c32:	461a      	mov	r2, r3
 8003c34:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8003c36:	4413      	add	r3, r2
 8003c38:	460a      	mov	r2, r1
 8003c3a:	605a      	str	r2, [r3, #4]
                tsi++;
 8003c3c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8003c3e:	3301      	adds	r3, #1
 8003c40:	647b      	str	r3, [r7, #68]	@ 0x44
        for(j = 0; tr->props[j] != 0 && tsi < STYLE_TRANSITION_MAX; j++) {
 8003c42:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8003c44:	3301      	adds	r3, #1
 8003c46:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8003c48:	6a3b      	ldr	r3, [r7, #32]
 8003c4a:	681a      	ldr	r2, [r3, #0]
 8003c4c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8003c4e:	4413      	add	r3, r2
 8003c50:	781b      	ldrb	r3, [r3, #0]
 8003c52:	2b00      	cmp	r3, #0
 8003c54:	d009      	beq.n	8003c6a <update_obj_state+0x216>
 8003c56:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8003c58:	2b1f      	cmp	r3, #31
 8003c5a:	f67f af6a 	bls.w	8003b32 <update_obj_state+0xde>
 8003c5e:	e004      	b.n	8003c6a <update_obj_state+0x216>
        if(state_act & (~new_state)) continue; /*Skip unrelated styles*/
 8003c60:	bf00      	nop
 8003c62:	e002      	b.n	8003c6a <update_obj_state+0x216>
        if(obj_style->is_trans) continue;
 8003c64:	bf00      	nop
 8003c66:	e000      	b.n	8003c6a <update_obj_state+0x216>
        if(lv_style_get_prop_inlined(obj_style->style, LV_STYLE_TRANSITION, &v) != LV_STYLE_RES_FOUND) continue;
 8003c68:	bf00      	nop
    for(i = 0; i < obj->style_cnt && tsi < STYLE_TRANSITION_MAX; i++) {
 8003c6a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8003c6c:	3301      	adds	r3, #1
 8003c6e:	643b      	str	r3, [r7, #64]	@ 0x40
 8003c70:	687b      	ldr	r3, [r7, #4]
 8003c72:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8003c74:	f3c3 1305 	ubfx	r3, r3, #4, #6
 8003c78:	b2db      	uxtb	r3, r3
 8003c7a:	461a      	mov	r2, r3
 8003c7c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8003c7e:	4293      	cmp	r3, r2
 8003c80:	d203      	bcs.n	8003c8a <update_obj_state+0x236>
 8003c82:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8003c84:	2b1f      	cmp	r3, #31
 8003c86:	f67f af15 	bls.w	8003ab4 <update_obj_state+0x60>
            }
        }
    }

    for(i = 0; i < tsi; i++) {
 8003c8a:	2300      	movs	r3, #0
 8003c8c:	643b      	str	r3, [r7, #64]	@ 0x40
 8003c8e:	e01f      	b.n	8003cd0 <update_obj_state+0x27c>
        lv_part_t part_act = lv_obj_style_get_selector_part(ts[i].selector);
 8003c90:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8003c92:	4613      	mov	r3, r2
 8003c94:	009b      	lsls	r3, r3, #2
 8003c96:	4413      	add	r3, r2
 8003c98:	009b      	lsls	r3, r3, #2
 8003c9a:	461a      	mov	r2, r3
 8003c9c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8003c9e:	4413      	add	r3, r2
 8003ca0:	685b      	ldr	r3, [r3, #4]
 8003ca2:	4618      	mov	r0, r3
 8003ca4:	f7fe fdc7 	bl	8002836 <lv_obj_style_get_selector_part>
 8003ca8:	6138      	str	r0, [r7, #16]
        _lv_obj_style_create_transition(obj, part_act, prev_state, new_state, &ts[i]);
 8003caa:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8003cac:	4613      	mov	r3, r2
 8003cae:	009b      	lsls	r3, r3, #2
 8003cb0:	4413      	add	r3, r2
 8003cb2:	009b      	lsls	r3, r3, #2
 8003cb4:	461a      	mov	r2, r3
 8003cb6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8003cb8:	4413      	add	r3, r2
 8003cba:	8879      	ldrh	r1, [r7, #2]
 8003cbc:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 8003cbe:	9300      	str	r3, [sp, #0]
 8003cc0:	460b      	mov	r3, r1
 8003cc2:	6939      	ldr	r1, [r7, #16]
 8003cc4:	6878      	ldr	r0, [r7, #4]
 8003cc6:	f005 fdc9 	bl	800985c <_lv_obj_style_create_transition>
    for(i = 0; i < tsi; i++) {
 8003cca:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8003ccc:	3301      	adds	r3, #1
 8003cce:	643b      	str	r3, [r7, #64]	@ 0x40
 8003cd0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8003cd2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8003cd4:	429a      	cmp	r2, r3
 8003cd6:	d3db      	bcc.n	8003c90 <update_obj_state+0x23c>
    }

    lv_free(ts);
 8003cd8:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8003cda:	f022 f8ad 	bl	8025e38 <lv_free>

    if(cmp_res == _LV_STYLE_STATE_CMP_DIFF_REDRAW) {
 8003cde:	f897 3035 	ldrb.w	r3, [r7, #53]	@ 0x35
 8003ce2:	2b01      	cmp	r3, #1
 8003ce4:	d106      	bne.n	8003cf4 <update_obj_state+0x2a0>
        /*Invalidation is not enough, e.g. layer type needs to be updated too*/
        lv_obj_refresh_style(obj, LV_PART_ANY, LV_STYLE_PROP_ANY);
 8003ce6:	22ff      	movs	r2, #255	@ 0xff
 8003ce8:	f44f 2170 	mov.w	r1, #983040	@ 0xf0000
 8003cec:	6878      	ldr	r0, [r7, #4]
 8003cee:	f005 fb33 	bl	8009358 <lv_obj_refresh_style>
 8003cf2:	e016      	b.n	8003d22 <update_obj_state+0x2ce>
    }
    else if(cmp_res == _LV_STYLE_STATE_CMP_DIFF_LAYOUT) {
 8003cf4:	f897 3035 	ldrb.w	r3, [r7, #53]	@ 0x35
 8003cf8:	2b03      	cmp	r3, #3
 8003cfa:	d106      	bne.n	8003d0a <update_obj_state+0x2b6>
        lv_obj_refresh_style(obj, LV_PART_ANY, LV_STYLE_PROP_ANY);
 8003cfc:	22ff      	movs	r2, #255	@ 0xff
 8003cfe:	f44f 2170 	mov.w	r1, #983040	@ 0xf0000
 8003d02:	6878      	ldr	r0, [r7, #4]
 8003d04:	f005 fb28 	bl	8009358 <lv_obj_refresh_style>
 8003d08:	e00b      	b.n	8003d22 <update_obj_state+0x2ce>
    }
    else if(cmp_res == _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD) {
 8003d0a:	f897 3035 	ldrb.w	r3, [r7, #53]	@ 0x35
 8003d0e:	2b02      	cmp	r3, #2
 8003d10:	d107      	bne.n	8003d22 <update_obj_state+0x2ce>
        lv_obj_invalidate(obj);
 8003d12:	6878      	ldr	r0, [r7, #4]
 8003d14:	f002 fc94 	bl	8006640 <lv_obj_invalidate>
        lv_obj_refresh_ext_draw_size(obj);
 8003d18:	6878      	ldr	r0, [r7, #4]
 8003d1a:	f001 f822 	bl	8004d62 <lv_obj_refresh_ext_draw_size>
 8003d1e:	e000      	b.n	8003d22 <update_obj_state+0x2ce>
    if(obj->state == new_state) return;
 8003d20:	bf00      	nop
    }
}
 8003d22:	3748      	adds	r7, #72	@ 0x48
 8003d24:	46bd      	mov	sp, r7
 8003d26:	bd80      	pop	{r7, pc}

08003d28 <lv_obj_class_create_obj>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

lv_obj_t * lv_obj_class_create_obj(const lv_obj_class_t * class_p, lv_obj_t * parent)
{
 8003d28:	b590      	push	{r4, r7, lr}
 8003d2a:	b087      	sub	sp, #28
 8003d2c:	af00      	add	r7, sp, #0
 8003d2e:	6078      	str	r0, [r7, #4]
 8003d30:	6039      	str	r1, [r7, #0]
    LV_TRACE_OBJ_CREATE("Creating object with %p class on %p parent", (void *)class_p, (void *)parent);
    uint32_t s = get_instance_size(class_p);
 8003d32:	6878      	ldr	r0, [r7, #4]
 8003d34:	f000 f954 	bl	8003fe0 <get_instance_size>
 8003d38:	6178      	str	r0, [r7, #20]
    lv_obj_t * obj = lv_malloc_zeroed(s);
 8003d3a:	6978      	ldr	r0, [r7, #20]
 8003d3c:	f022 f85e 	bl	8025dfc <lv_malloc_zeroed>
 8003d40:	6138      	str	r0, [r7, #16]
    if(obj == NULL) return NULL;
 8003d42:	693b      	ldr	r3, [r7, #16]
 8003d44:	2b00      	cmp	r3, #0
 8003d46:	d101      	bne.n	8003d4c <lv_obj_class_create_obj+0x24>
 8003d48:	2300      	movs	r3, #0
 8003d4a:	e07d      	b.n	8003e48 <lv_obj_class_create_obj+0x120>
    obj->class_p = class_p;
 8003d4c:	693b      	ldr	r3, [r7, #16]
 8003d4e:	687a      	ldr	r2, [r7, #4]
 8003d50:	601a      	str	r2, [r3, #0]
    obj->parent = parent;
 8003d52:	693b      	ldr	r3, [r7, #16]
 8003d54:	683a      	ldr	r2, [r7, #0]
 8003d56:	605a      	str	r2, [r3, #4]

    /*Create a screen*/
    if(parent == NULL) {
 8003d58:	683b      	ldr	r3, [r7, #0]
 8003d5a:	2b00      	cmp	r3, #0
 8003d5c:	d14b      	bne.n	8003df6 <lv_obj_class_create_obj+0xce>
        LV_TRACE_OBJ_CREATE("creating a screen");
        lv_display_t * disp = lv_display_get_default();
 8003d5e:	f007 f9bf 	bl	800b0e0 <lv_display_get_default>
 8003d62:	60f8      	str	r0, [r7, #12]
        if(!disp) {
 8003d64:	68fb      	ldr	r3, [r7, #12]
 8003d66:	2b00      	cmp	r3, #0
 8003d68:	d104      	bne.n	8003d74 <lv_obj_class_create_obj+0x4c>
            LV_LOG_WARN("No display created yet. No place to assign the new screen");
            lv_free(obj);
 8003d6a:	6938      	ldr	r0, [r7, #16]
 8003d6c:	f022 f864 	bl	8025e38 <lv_free>
            return NULL;
 8003d70:	2300      	movs	r3, #0
 8003d72:	e069      	b.n	8003e48 <lv_obj_class_create_obj+0x120>
        }

        if(disp->screens == NULL) {
 8003d74:	68fb      	ldr	r3, [r7, #12]
 8003d76:	f8d3 32ac 	ldr.w	r3, [r3, #684]	@ 0x2ac
 8003d7a:	2b00      	cmp	r3, #0
 8003d7c:	d103      	bne.n	8003d86 <lv_obj_class_create_obj+0x5e>
            disp->screen_cnt = 0;
 8003d7e:	68fb      	ldr	r3, [r7, #12]
 8003d80:	2200      	movs	r2, #0
 8003d82:	f8c3 22c8 	str.w	r2, [r3, #712]	@ 0x2c8
        }

        disp->screen_cnt++;
 8003d86:	68fb      	ldr	r3, [r7, #12]
 8003d88:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8003d8c:	1c5a      	adds	r2, r3, #1
 8003d8e:	68fb      	ldr	r3, [r7, #12]
 8003d90:	f8c3 22c8 	str.w	r2, [r3, #712]	@ 0x2c8
        disp->screens = lv_realloc(disp->screens, sizeof(lv_obj_t *) * disp->screen_cnt);
 8003d94:	68fb      	ldr	r3, [r7, #12]
 8003d96:	f8d3 22ac 	ldr.w	r2, [r3, #684]	@ 0x2ac
 8003d9a:	68fb      	ldr	r3, [r7, #12]
 8003d9c:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8003da0:	009b      	lsls	r3, r3, #2
 8003da2:	4619      	mov	r1, r3
 8003da4:	4610      	mov	r0, r2
 8003da6:	f022 f85f 	bl	8025e68 <lv_realloc>
 8003daa:	4602      	mov	r2, r0
 8003dac:	68fb      	ldr	r3, [r7, #12]
 8003dae:	f8c3 22ac 	str.w	r2, [r3, #684]	@ 0x2ac
        disp->screens[disp->screen_cnt - 1] = obj;
 8003db2:	68fb      	ldr	r3, [r7, #12]
 8003db4:	f8d3 22ac 	ldr.w	r2, [r3, #684]	@ 0x2ac
 8003db8:	68fb      	ldr	r3, [r7, #12]
 8003dba:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 8003dbe:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8003dc2:	3b01      	subs	r3, #1
 8003dc4:	009b      	lsls	r3, r3, #2
 8003dc6:	4413      	add	r3, r2
 8003dc8:	693a      	ldr	r2, [r7, #16]
 8003dca:	601a      	str	r2, [r3, #0]

        /*Set coordinates to full screen size*/
        obj->coords.x1 = 0;
 8003dcc:	693b      	ldr	r3, [r7, #16]
 8003dce:	2200      	movs	r2, #0
 8003dd0:	615a      	str	r2, [r3, #20]
        obj->coords.y1 = 0;
 8003dd2:	693b      	ldr	r3, [r7, #16]
 8003dd4:	2200      	movs	r2, #0
 8003dd6:	619a      	str	r2, [r3, #24]
        obj->coords.x2 = lv_display_get_horizontal_resolution(NULL) - 1;
 8003dd8:	2000      	movs	r0, #0
 8003dda:	f007 f9a5 	bl	800b128 <lv_display_get_horizontal_resolution>
 8003dde:	4603      	mov	r3, r0
 8003de0:	1e5a      	subs	r2, r3, #1
 8003de2:	693b      	ldr	r3, [r7, #16]
 8003de4:	61da      	str	r2, [r3, #28]
        obj->coords.y2 = lv_display_get_vertical_resolution(NULL) - 1;
 8003de6:	2000      	movs	r0, #0
 8003de8:	f007 f9c0 	bl	800b16c <lv_display_get_vertical_resolution>
 8003dec:	4603      	mov	r3, r0
 8003dee:	1e5a      	subs	r2, r3, #1
 8003df0:	693b      	ldr	r3, [r7, #16]
 8003df2:	621a      	str	r2, [r3, #32]
 8003df4:	e027      	b.n	8003e46 <lv_obj_class_create_obj+0x11e>
    }
    /*Create a normal object*/
    else {
        LV_TRACE_OBJ_CREATE("creating normal object");
        LV_ASSERT_OBJ(parent, MY_CLASS);
        if(parent->spec_attr == NULL) {
 8003df6:	683b      	ldr	r3, [r7, #0]
 8003df8:	689b      	ldr	r3, [r3, #8]
 8003dfa:	2b00      	cmp	r3, #0
 8003dfc:	d102      	bne.n	8003e04 <lv_obj_class_create_obj+0xdc>
            lv_obj_allocate_spec_attr(parent);
 8003dfe:	6838      	ldr	r0, [r7, #0]
 8003e00:	f7fe ffed 	bl	8002dde <lv_obj_allocate_spec_attr>
        }

        parent->spec_attr->child_cnt++;
 8003e04:	683b      	ldr	r3, [r7, #0]
 8003e06:	689b      	ldr	r3, [r3, #8]
 8003e08:	8d1a      	ldrh	r2, [r3, #40]	@ 0x28
 8003e0a:	3201      	adds	r2, #1
 8003e0c:	b292      	uxth	r2, r2
 8003e0e:	851a      	strh	r2, [r3, #40]	@ 0x28
        parent->spec_attr->children = lv_realloc(parent->spec_attr->children,
 8003e10:	683b      	ldr	r3, [r7, #0]
 8003e12:	689b      	ldr	r3, [r3, #8]
 8003e14:	681a      	ldr	r2, [r3, #0]
                                                 sizeof(lv_obj_t *) * parent->spec_attr->child_cnt);
 8003e16:	683b      	ldr	r3, [r7, #0]
 8003e18:	689b      	ldr	r3, [r3, #8]
 8003e1a:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
        parent->spec_attr->children = lv_realloc(parent->spec_attr->children,
 8003e1c:	0099      	lsls	r1, r3, #2
 8003e1e:	683b      	ldr	r3, [r7, #0]
 8003e20:	689c      	ldr	r4, [r3, #8]
 8003e22:	4610      	mov	r0, r2
 8003e24:	f022 f820 	bl	8025e68 <lv_realloc>
 8003e28:	4603      	mov	r3, r0
 8003e2a:	6023      	str	r3, [r4, #0]
        parent->spec_attr->children[parent->spec_attr->child_cnt - 1] = obj;
 8003e2c:	683b      	ldr	r3, [r7, #0]
 8003e2e:	689b      	ldr	r3, [r3, #8]
 8003e30:	681a      	ldr	r2, [r3, #0]
 8003e32:	683b      	ldr	r3, [r7, #0]
 8003e34:	689b      	ldr	r3, [r3, #8]
 8003e36:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8003e38:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8003e3c:	3b01      	subs	r3, #1
 8003e3e:	009b      	lsls	r3, r3, #2
 8003e40:	4413      	add	r3, r2
 8003e42:	693a      	ldr	r2, [r7, #16]
 8003e44:	601a      	str	r2, [r3, #0]
    }

    return obj;
 8003e46:	693b      	ldr	r3, [r7, #16]
}
 8003e48:	4618      	mov	r0, r3
 8003e4a:	371c      	adds	r7, #28
 8003e4c:	46bd      	mov	sp, r7
 8003e4e:	bd90      	pop	{r4, r7, pc}

08003e50 <lv_obj_class_init_obj>:

void lv_obj_class_init_obj(lv_obj_t * obj)
{
 8003e50:	b580      	push	{r7, lr}
 8003e52:	b084      	sub	sp, #16
 8003e54:	af00      	add	r7, sp, #0
 8003e56:	6078      	str	r0, [r7, #4]
    lv_obj_mark_layout_as_dirty(obj);
 8003e58:	6878      	ldr	r0, [r7, #4]
 8003e5a:	f001 feef 	bl	8005c3c <lv_obj_mark_layout_as_dirty>
    lv_obj_enable_style_refresh(false);
 8003e5e:	2000      	movs	r0, #0
 8003e60:	f005 fb40 	bl	80094e4 <lv_obj_enable_style_refresh>

    lv_theme_apply(obj);
 8003e64:	6878      	ldr	r0, [r7, #4]
 8003e66:	f022 f83f 	bl	8025ee8 <lv_theme_apply>
    lv_obj_construct(obj->class_p, obj);
 8003e6a:	687b      	ldr	r3, [r7, #4]
 8003e6c:	681b      	ldr	r3, [r3, #0]
 8003e6e:	6879      	ldr	r1, [r7, #4]
 8003e70:	4618      	mov	r0, r3
 8003e72:	f000 f88c 	bl	8003f8e <lv_obj_construct>

    lv_obj_enable_style_refresh(true);
 8003e76:	2001      	movs	r0, #1
 8003e78:	f005 fb34 	bl	80094e4 <lv_obj_enable_style_refresh>
    lv_obj_refresh_style(obj, LV_PART_ANY, LV_STYLE_PROP_ANY);
 8003e7c:	22ff      	movs	r2, #255	@ 0xff
 8003e7e:	f44f 2170 	mov.w	r1, #983040	@ 0xf0000
 8003e82:	6878      	ldr	r0, [r7, #4]
 8003e84:	f005 fa68 	bl	8009358 <lv_obj_refresh_style>

    lv_obj_refresh_self_size(obj);
 8003e88:	6878      	ldr	r0, [r7, #4]
 8003e8a:	f002 f803 	bl	8005e94 <lv_obj_refresh_self_size>

    lv_group_t * def_group = lv_group_get_default();
 8003e8e:	f7fe f9c3 	bl	8002218 <lv_group_get_default>
 8003e92:	60f8      	str	r0, [r7, #12]
    if(def_group && lv_obj_is_group_def(obj)) {
 8003e94:	68fb      	ldr	r3, [r7, #12]
 8003e96:	2b00      	cmp	r3, #0
 8003e98:	d009      	beq.n	8003eae <lv_obj_class_init_obj+0x5e>
 8003e9a:	6878      	ldr	r0, [r7, #4]
 8003e9c:	f000 f84b 	bl	8003f36 <lv_obj_is_group_def>
 8003ea0:	4603      	mov	r3, r0
 8003ea2:	2b00      	cmp	r3, #0
 8003ea4:	d003      	beq.n	8003eae <lv_obj_class_init_obj+0x5e>
        lv_group_add_obj(def_group, obj);
 8003ea6:	6879      	ldr	r1, [r7, #4]
 8003ea8:	68f8      	ldr	r0, [r7, #12]
 8003eaa:	f7fe f9c1 	bl	8002230 <lv_group_add_obj>
    }

    lv_obj_t * parent = lv_obj_get_parent(obj);
 8003eae:	6878      	ldr	r0, [r7, #4]
 8003eb0:	f006 ffc0 	bl	800ae34 <lv_obj_get_parent>
 8003eb4:	60b8      	str	r0, [r7, #8]
    if(parent) {
 8003eb6:	68bb      	ldr	r3, [r7, #8]
 8003eb8:	2b00      	cmp	r3, #0
 8003eba:	d00c      	beq.n	8003ed6 <lv_obj_class_init_obj+0x86>
        /*Call the ancestor's event handler to the parent to notify it about the new child.
         *Also triggers layout update*/
        lv_obj_send_event(parent, LV_EVENT_CHILD_CHANGED, obj);
 8003ebc:	687a      	ldr	r2, [r7, #4]
 8003ebe:	2124      	movs	r1, #36	@ 0x24
 8003ec0:	68b8      	ldr	r0, [r7, #8]
 8003ec2:	f000 ffa7 	bl	8004e14 <lv_obj_send_event>
        lv_obj_send_event(parent, LV_EVENT_CHILD_CREATED, obj);
 8003ec6:	687a      	ldr	r2, [r7, #4]
 8003ec8:	2125      	movs	r1, #37	@ 0x25
 8003eca:	68b8      	ldr	r0, [r7, #8]
 8003ecc:	f000 ffa2 	bl	8004e14 <lv_obj_send_event>

        /*Invalidate the area if not screen created*/
        lv_obj_invalidate(obj);
 8003ed0:	6878      	ldr	r0, [r7, #4]
 8003ed2:	f002 fbb5 	bl	8006640 <lv_obj_invalidate>
    }
}
 8003ed6:	bf00      	nop
 8003ed8:	3710      	adds	r7, #16
 8003eda:	46bd      	mov	sp, r7
 8003edc:	bd80      	pop	{r7, pc}

08003ede <lv_obj_is_editable>:
        _lv_obj_destruct(obj);
    }
}

bool lv_obj_is_editable(lv_obj_t * obj)
{
 8003ede:	b480      	push	{r7}
 8003ee0:	b085      	sub	sp, #20
 8003ee2:	af00      	add	r7, sp, #0
 8003ee4:	6078      	str	r0, [r7, #4]
    const lv_obj_class_t * class_p = obj->class_p;
 8003ee6:	687b      	ldr	r3, [r7, #4]
 8003ee8:	681b      	ldr	r3, [r3, #0]
 8003eea:	60fb      	str	r3, [r7, #12]

    /*Find a base in which editable is set*/
    while(class_p && class_p->editable == LV_OBJ_CLASS_EDITABLE_INHERIT) class_p = class_p->base_class;
 8003eec:	e002      	b.n	8003ef4 <lv_obj_is_editable+0x16>
 8003eee:	68fb      	ldr	r3, [r7, #12]
 8003ef0:	681b      	ldr	r3, [r3, #0]
 8003ef2:	60fb      	str	r3, [r7, #12]
 8003ef4:	68fb      	ldr	r3, [r7, #12]
 8003ef6:	2b00      	cmp	r3, #0
 8003ef8:	d007      	beq.n	8003f0a <lv_obj_is_editable+0x2c>
 8003efa:	68fb      	ldr	r3, [r7, #12]
 8003efc:	f893 3020 	ldrb.w	r3, [r3, #32]
 8003f00:	f003 0303 	and.w	r3, r3, #3
 8003f04:	b2db      	uxtb	r3, r3
 8003f06:	2b00      	cmp	r3, #0
 8003f08:	d0f1      	beq.n	8003eee <lv_obj_is_editable+0x10>

    if(class_p == NULL) return false;
 8003f0a:	68fb      	ldr	r3, [r7, #12]
 8003f0c:	2b00      	cmp	r3, #0
 8003f0e:	d101      	bne.n	8003f14 <lv_obj_is_editable+0x36>
 8003f10:	2300      	movs	r3, #0
 8003f12:	e00a      	b.n	8003f2a <lv_obj_is_editable+0x4c>

    return class_p->editable == LV_OBJ_CLASS_EDITABLE_TRUE;
 8003f14:	68fb      	ldr	r3, [r7, #12]
 8003f16:	f893 3020 	ldrb.w	r3, [r3, #32]
 8003f1a:	f003 0303 	and.w	r3, r3, #3
 8003f1e:	b2db      	uxtb	r3, r3
 8003f20:	2b01      	cmp	r3, #1
 8003f22:	bf0c      	ite	eq
 8003f24:	2301      	moveq	r3, #1
 8003f26:	2300      	movne	r3, #0
 8003f28:	b2db      	uxtb	r3, r3
}
 8003f2a:	4618      	mov	r0, r3
 8003f2c:	3714      	adds	r7, #20
 8003f2e:	46bd      	mov	sp, r7
 8003f30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f34:	4770      	bx	lr

08003f36 <lv_obj_is_group_def>:

bool lv_obj_is_group_def(lv_obj_t * obj)
{
 8003f36:	b480      	push	{r7}
 8003f38:	b085      	sub	sp, #20
 8003f3a:	af00      	add	r7, sp, #0
 8003f3c:	6078      	str	r0, [r7, #4]
    const lv_obj_class_t * class_p = obj->class_p;
 8003f3e:	687b      	ldr	r3, [r7, #4]
 8003f40:	681b      	ldr	r3, [r3, #0]
 8003f42:	60fb      	str	r3, [r7, #12]

    /*Find a base in which group_def is set*/
    while(class_p && class_p->group_def == LV_OBJ_CLASS_GROUP_DEF_INHERIT) class_p = class_p->base_class;
 8003f44:	e002      	b.n	8003f4c <lv_obj_is_group_def+0x16>
 8003f46:	68fb      	ldr	r3, [r7, #12]
 8003f48:	681b      	ldr	r3, [r3, #0]
 8003f4a:	60fb      	str	r3, [r7, #12]
 8003f4c:	68fb      	ldr	r3, [r7, #12]
 8003f4e:	2b00      	cmp	r3, #0
 8003f50:	d007      	beq.n	8003f62 <lv_obj_is_group_def+0x2c>
 8003f52:	68fb      	ldr	r3, [r7, #12]
 8003f54:	f893 3020 	ldrb.w	r3, [r3, #32]
 8003f58:	f003 030c 	and.w	r3, r3, #12
 8003f5c:	b2db      	uxtb	r3, r3
 8003f5e:	2b00      	cmp	r3, #0
 8003f60:	d0f1      	beq.n	8003f46 <lv_obj_is_group_def+0x10>

    if(class_p == NULL) return false;
 8003f62:	68fb      	ldr	r3, [r7, #12]
 8003f64:	2b00      	cmp	r3, #0
 8003f66:	d101      	bne.n	8003f6c <lv_obj_is_group_def+0x36>
 8003f68:	2300      	movs	r3, #0
 8003f6a:	e00a      	b.n	8003f82 <lv_obj_is_group_def+0x4c>

    return class_p->group_def == LV_OBJ_CLASS_GROUP_DEF_TRUE;
 8003f6c:	68fb      	ldr	r3, [r7, #12]
 8003f6e:	f893 3020 	ldrb.w	r3, [r3, #32]
 8003f72:	f003 030c 	and.w	r3, r3, #12
 8003f76:	b2db      	uxtb	r3, r3
 8003f78:	2b04      	cmp	r3, #4
 8003f7a:	bf0c      	ite	eq
 8003f7c:	2301      	moveq	r3, #1
 8003f7e:	2300      	movne	r3, #0
 8003f80:	b2db      	uxtb	r3, r3
}
 8003f82:	4618      	mov	r0, r3
 8003f84:	3714      	adds	r7, #20
 8003f86:	46bd      	mov	sp, r7
 8003f88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f8c:	4770      	bx	lr

08003f8e <lv_obj_construct>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void lv_obj_construct(const lv_obj_class_t * class_p, lv_obj_t * obj)
{
 8003f8e:	b580      	push	{r7, lr}
 8003f90:	b084      	sub	sp, #16
 8003f92:	af00      	add	r7, sp, #0
 8003f94:	6078      	str	r0, [r7, #4]
 8003f96:	6039      	str	r1, [r7, #0]
    if(obj->class_p->base_class) {
 8003f98:	683b      	ldr	r3, [r7, #0]
 8003f9a:	681b      	ldr	r3, [r3, #0]
 8003f9c:	681b      	ldr	r3, [r3, #0]
 8003f9e:	2b00      	cmp	r3, #0
 8003fa0:	d00e      	beq.n	8003fc0 <lv_obj_construct+0x32>
        const lv_obj_class_t * original_class_p = obj->class_p;
 8003fa2:	683b      	ldr	r3, [r7, #0]
 8003fa4:	681b      	ldr	r3, [r3, #0]
 8003fa6:	60fb      	str	r3, [r7, #12]

        /*Don't let the descendant methods run during constructing the ancestor type*/
        obj->class_p = obj->class_p->base_class;
 8003fa8:	683b      	ldr	r3, [r7, #0]
 8003faa:	681b      	ldr	r3, [r3, #0]
 8003fac:	681a      	ldr	r2, [r3, #0]
 8003fae:	683b      	ldr	r3, [r7, #0]
 8003fb0:	601a      	str	r2, [r3, #0]

        /*Construct the base first*/
        lv_obj_construct(class_p, obj);
 8003fb2:	6839      	ldr	r1, [r7, #0]
 8003fb4:	6878      	ldr	r0, [r7, #4]
 8003fb6:	f7ff ffea 	bl	8003f8e <lv_obj_construct>

        /*Restore the original class*/
        obj->class_p = original_class_p;
 8003fba:	683b      	ldr	r3, [r7, #0]
 8003fbc:	68fa      	ldr	r2, [r7, #12]
 8003fbe:	601a      	str	r2, [r3, #0]
    }

    if(obj->class_p->constructor_cb) obj->class_p->constructor_cb(class_p, obj);
 8003fc0:	683b      	ldr	r3, [r7, #0]
 8003fc2:	681b      	ldr	r3, [r3, #0]
 8003fc4:	685b      	ldr	r3, [r3, #4]
 8003fc6:	2b00      	cmp	r3, #0
 8003fc8:	d005      	beq.n	8003fd6 <lv_obj_construct+0x48>
 8003fca:	683b      	ldr	r3, [r7, #0]
 8003fcc:	681b      	ldr	r3, [r3, #0]
 8003fce:	685b      	ldr	r3, [r3, #4]
 8003fd0:	6839      	ldr	r1, [r7, #0]
 8003fd2:	6878      	ldr	r0, [r7, #4]
 8003fd4:	4798      	blx	r3
}
 8003fd6:	bf00      	nop
 8003fd8:	3710      	adds	r7, #16
 8003fda:	46bd      	mov	sp, r7
 8003fdc:	bd80      	pop	{r7, pc}
	...

08003fe0 <get_instance_size>:

static uint32_t get_instance_size(const lv_obj_class_t * class_p)
{
 8003fe0:	b480      	push	{r7}
 8003fe2:	b085      	sub	sp, #20
 8003fe4:	af00      	add	r7, sp, #0
 8003fe6:	6078      	str	r0, [r7, #4]
    /*Find a base in which instance size is set*/
    const lv_obj_class_t * base = class_p;
 8003fe8:	687b      	ldr	r3, [r7, #4]
 8003fea:	60fb      	str	r3, [r7, #12]
    while(base && base->instance_size == 0) base = base->base_class;
 8003fec:	e002      	b.n	8003ff4 <get_instance_size+0x14>
 8003fee:	68fb      	ldr	r3, [r7, #12]
 8003ff0:	681b      	ldr	r3, [r3, #0]
 8003ff2:	60fb      	str	r3, [r7, #12]
 8003ff4:	68fb      	ldr	r3, [r7, #12]
 8003ff6:	2b00      	cmp	r3, #0
 8003ff8:	d005      	beq.n	8004006 <get_instance_size+0x26>
 8003ffa:	68fb      	ldr	r3, [r7, #12]
 8003ffc:	6a1a      	ldr	r2, [r3, #32]
 8003ffe:	4b0a      	ldr	r3, [pc, #40]	@ (8004028 <get_instance_size+0x48>)
 8004000:	4013      	ands	r3, r2
 8004002:	2b00      	cmp	r3, #0
 8004004:	d0f3      	beq.n	8003fee <get_instance_size+0xe>

    if(base == NULL) return 0;  /*Never happens: set at least in `lv_obj` class*/
 8004006:	68fb      	ldr	r3, [r7, #12]
 8004008:	2b00      	cmp	r3, #0
 800400a:	d101      	bne.n	8004010 <get_instance_size+0x30>
 800400c:	2300      	movs	r3, #0
 800400e:	e004      	b.n	800401a <get_instance_size+0x3a>

    return base->instance_size;
 8004010:	68fb      	ldr	r3, [r7, #12]
 8004012:	6a1b      	ldr	r3, [r3, #32]
 8004014:	f3c3 130f 	ubfx	r3, r3, #4, #16
 8004018:	b29b      	uxth	r3, r3
}
 800401a:	4618      	mov	r0, r3
 800401c:	3714      	adds	r7, #20
 800401e:	46bd      	mov	sp, r7
 8004020:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004024:	4770      	bx	lr
 8004026:	bf00      	nop
 8004028:	000ffff0 	.word	0x000ffff0

0800402c <lv_obj_get_style_transform_width>:
{
 800402c:	b580      	push	{r7, lr}
 800402e:	b084      	sub	sp, #16
 8004030:	af00      	add	r7, sp, #0
 8004032:	6078      	str	r0, [r7, #4]
 8004034:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_WIDTH);
 8004036:	2268      	movs	r2, #104	@ 0x68
 8004038:	6839      	ldr	r1, [r7, #0]
 800403a:	6878      	ldr	r0, [r7, #4]
 800403c:	f005 fb74 	bl	8009728 <lv_obj_get_style_prop>
 8004040:	4603      	mov	r3, r0
 8004042:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8004044:	68fb      	ldr	r3, [r7, #12]
}
 8004046:	4618      	mov	r0, r3
 8004048:	3710      	adds	r7, #16
 800404a:	46bd      	mov	sp, r7
 800404c:	bd80      	pop	{r7, pc}

0800404e <lv_obj_get_style_transform_height>:
{
 800404e:	b580      	push	{r7, lr}
 8004050:	b084      	sub	sp, #16
 8004052:	af00      	add	r7, sp, #0
 8004054:	6078      	str	r0, [r7, #4]
 8004056:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_HEIGHT);
 8004058:	2269      	movs	r2, #105	@ 0x69
 800405a:	6839      	ldr	r1, [r7, #0]
 800405c:	6878      	ldr	r0, [r7, #4]
 800405e:	f005 fb63 	bl	8009728 <lv_obj_get_style_prop>
 8004062:	4603      	mov	r3, r0
 8004064:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8004066:	68fb      	ldr	r3, [r7, #12]
}
 8004068:	4618      	mov	r0, r3
 800406a:	3710      	adds	r7, #16
 800406c:	46bd      	mov	sp, r7
 800406e:	bd80      	pop	{r7, pc}

08004070 <lv_obj_get_style_bg_color_filtered>:
{
 8004070:	b580      	push	{r7, lr}
 8004072:	b086      	sub	sp, #24
 8004074:	af00      	add	r7, sp, #0
 8004076:	6078      	str	r0, [r7, #4]
 8004078:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = _lv_obj_style_apply_color_filter(obj, part, lv_obj_get_style_prop(obj, part, LV_STYLE_BG_COLOR));
 800407a:	221c      	movs	r2, #28
 800407c:	6839      	ldr	r1, [r7, #0]
 800407e:	6878      	ldr	r0, [r7, #4]
 8004080:	f005 fb52 	bl	8009728 <lv_obj_get_style_prop>
 8004084:	4603      	mov	r3, r0
 8004086:	613b      	str	r3, [r7, #16]
 8004088:	693a      	ldr	r2, [r7, #16]
 800408a:	6839      	ldr	r1, [r7, #0]
 800408c:	6878      	ldr	r0, [r7, #4]
 800408e:	f005 fd05 	bl	8009a9c <_lv_obj_style_apply_color_filter>
 8004092:	4603      	mov	r3, r0
 8004094:	60fb      	str	r3, [r7, #12]
    return v.color;
 8004096:	f107 0314 	add.w	r3, r7, #20
 800409a:	f107 020c 	add.w	r2, r7, #12
 800409e:	6812      	ldr	r2, [r2, #0]
 80040a0:	4611      	mov	r1, r2
 80040a2:	8019      	strh	r1, [r3, #0]
 80040a4:	3302      	adds	r3, #2
 80040a6:	0c12      	lsrs	r2, r2, #16
 80040a8:	701a      	strb	r2, [r3, #0]
 80040aa:	2300      	movs	r3, #0
 80040ac:	7d3a      	ldrb	r2, [r7, #20]
 80040ae:	f362 0307 	bfi	r3, r2, #0, #8
 80040b2:	7d7a      	ldrb	r2, [r7, #21]
 80040b4:	f362 230f 	bfi	r3, r2, #8, #8
 80040b8:	7dba      	ldrb	r2, [r7, #22]
 80040ba:	f362 4317 	bfi	r3, r2, #16, #8
}
 80040be:	4618      	mov	r0, r3
 80040c0:	3718      	adds	r7, #24
 80040c2:	46bd      	mov	sp, r7
 80040c4:	bd80      	pop	{r7, pc}

080040c6 <lv_obj_get_style_bg_opa>:
{
 80040c6:	b580      	push	{r7, lr}
 80040c8:	b084      	sub	sp, #16
 80040ca:	af00      	add	r7, sp, #0
 80040cc:	6078      	str	r0, [r7, #4]
 80040ce:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_OPA);
 80040d0:	221d      	movs	r2, #29
 80040d2:	6839      	ldr	r1, [r7, #0]
 80040d4:	6878      	ldr	r0, [r7, #4]
 80040d6:	f005 fb27 	bl	8009728 <lv_obj_get_style_prop>
 80040da:	4603      	mov	r3, r0
 80040dc:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 80040de:	68fb      	ldr	r3, [r7, #12]
 80040e0:	b2db      	uxtb	r3, r3
}
 80040e2:	4618      	mov	r0, r3
 80040e4:	3710      	adds	r7, #16
 80040e6:	46bd      	mov	sp, r7
 80040e8:	bd80      	pop	{r7, pc}

080040ea <lv_obj_get_style_bg_grad_color_filtered>:
{
 80040ea:	b580      	push	{r7, lr}
 80040ec:	b086      	sub	sp, #24
 80040ee:	af00      	add	r7, sp, #0
 80040f0:	6078      	str	r0, [r7, #4]
 80040f2:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = _lv_obj_style_apply_color_filter(obj, part, lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD_COLOR));
 80040f4:	2223      	movs	r2, #35	@ 0x23
 80040f6:	6839      	ldr	r1, [r7, #0]
 80040f8:	6878      	ldr	r0, [r7, #4]
 80040fa:	f005 fb15 	bl	8009728 <lv_obj_get_style_prop>
 80040fe:	4603      	mov	r3, r0
 8004100:	613b      	str	r3, [r7, #16]
 8004102:	693a      	ldr	r2, [r7, #16]
 8004104:	6839      	ldr	r1, [r7, #0]
 8004106:	6878      	ldr	r0, [r7, #4]
 8004108:	f005 fcc8 	bl	8009a9c <_lv_obj_style_apply_color_filter>
 800410c:	4603      	mov	r3, r0
 800410e:	60fb      	str	r3, [r7, #12]
    return v.color;
 8004110:	f107 0314 	add.w	r3, r7, #20
 8004114:	f107 020c 	add.w	r2, r7, #12
 8004118:	6812      	ldr	r2, [r2, #0]
 800411a:	4611      	mov	r1, r2
 800411c:	8019      	strh	r1, [r3, #0]
 800411e:	3302      	adds	r3, #2
 8004120:	0c12      	lsrs	r2, r2, #16
 8004122:	701a      	strb	r2, [r3, #0]
 8004124:	2300      	movs	r3, #0
 8004126:	7d3a      	ldrb	r2, [r7, #20]
 8004128:	f362 0307 	bfi	r3, r2, #0, #8
 800412c:	7d7a      	ldrb	r2, [r7, #21]
 800412e:	f362 230f 	bfi	r3, r2, #8, #8
 8004132:	7dba      	ldrb	r2, [r7, #22]
 8004134:	f362 4317 	bfi	r3, r2, #16, #8
}
 8004138:	4618      	mov	r0, r3
 800413a:	3718      	adds	r7, #24
 800413c:	46bd      	mov	sp, r7
 800413e:	bd80      	pop	{r7, pc}

08004140 <lv_obj_get_style_bg_grad_dir>:
{
 8004140:	b580      	push	{r7, lr}
 8004142:	b084      	sub	sp, #16
 8004144:	af00      	add	r7, sp, #0
 8004146:	6078      	str	r0, [r7, #4]
 8004148:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD_DIR);
 800414a:	2220      	movs	r2, #32
 800414c:	6839      	ldr	r1, [r7, #0]
 800414e:	6878      	ldr	r0, [r7, #4]
 8004150:	f005 faea 	bl	8009728 <lv_obj_get_style_prop>
 8004154:	4603      	mov	r3, r0
 8004156:	60fb      	str	r3, [r7, #12]
    return (lv_grad_dir_t)v.num;
 8004158:	68fb      	ldr	r3, [r7, #12]
 800415a:	b2db      	uxtb	r3, r3
}
 800415c:	4618      	mov	r0, r3
 800415e:	3710      	adds	r7, #16
 8004160:	46bd      	mov	sp, r7
 8004162:	bd80      	pop	{r7, pc}

08004164 <lv_obj_get_style_bg_main_stop>:
{
 8004164:	b580      	push	{r7, lr}
 8004166:	b084      	sub	sp, #16
 8004168:	af00      	add	r7, sp, #0
 800416a:	6078      	str	r0, [r7, #4]
 800416c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_MAIN_STOP);
 800416e:	2221      	movs	r2, #33	@ 0x21
 8004170:	6839      	ldr	r1, [r7, #0]
 8004172:	6878      	ldr	r0, [r7, #4]
 8004174:	f005 fad8 	bl	8009728 <lv_obj_get_style_prop>
 8004178:	4603      	mov	r3, r0
 800417a:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 800417c:	68fb      	ldr	r3, [r7, #12]
}
 800417e:	4618      	mov	r0, r3
 8004180:	3710      	adds	r7, #16
 8004182:	46bd      	mov	sp, r7
 8004184:	bd80      	pop	{r7, pc}

08004186 <lv_obj_get_style_bg_grad_stop>:
{
 8004186:	b580      	push	{r7, lr}
 8004188:	b084      	sub	sp, #16
 800418a:	af00      	add	r7, sp, #0
 800418c:	6078      	str	r0, [r7, #4]
 800418e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD_STOP);
 8004190:	2222      	movs	r2, #34	@ 0x22
 8004192:	6839      	ldr	r1, [r7, #0]
 8004194:	6878      	ldr	r0, [r7, #4]
 8004196:	f005 fac7 	bl	8009728 <lv_obj_get_style_prop>
 800419a:	4603      	mov	r3, r0
 800419c:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 800419e:	68fb      	ldr	r3, [r7, #12]
}
 80041a0:	4618      	mov	r0, r3
 80041a2:	3710      	adds	r7, #16
 80041a4:	46bd      	mov	sp, r7
 80041a6:	bd80      	pop	{r7, pc}

080041a8 <lv_obj_get_style_bg_main_opa>:
{
 80041a8:	b580      	push	{r7, lr}
 80041aa:	b084      	sub	sp, #16
 80041ac:	af00      	add	r7, sp, #0
 80041ae:	6078      	str	r0, [r7, #4]
 80041b0:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_MAIN_OPA);
 80041b2:	2224      	movs	r2, #36	@ 0x24
 80041b4:	6839      	ldr	r1, [r7, #0]
 80041b6:	6878      	ldr	r0, [r7, #4]
 80041b8:	f005 fab6 	bl	8009728 <lv_obj_get_style_prop>
 80041bc:	4603      	mov	r3, r0
 80041be:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 80041c0:	68fb      	ldr	r3, [r7, #12]
 80041c2:	b2db      	uxtb	r3, r3
}
 80041c4:	4618      	mov	r0, r3
 80041c6:	3710      	adds	r7, #16
 80041c8:	46bd      	mov	sp, r7
 80041ca:	bd80      	pop	{r7, pc}

080041cc <lv_obj_get_style_bg_grad_opa>:
{
 80041cc:	b580      	push	{r7, lr}
 80041ce:	b084      	sub	sp, #16
 80041d0:	af00      	add	r7, sp, #0
 80041d2:	6078      	str	r0, [r7, #4]
 80041d4:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD_OPA);
 80041d6:	2225      	movs	r2, #37	@ 0x25
 80041d8:	6839      	ldr	r1, [r7, #0]
 80041da:	6878      	ldr	r0, [r7, #4]
 80041dc:	f005 faa4 	bl	8009728 <lv_obj_get_style_prop>
 80041e0:	4603      	mov	r3, r0
 80041e2:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 80041e4:	68fb      	ldr	r3, [r7, #12]
 80041e6:	b2db      	uxtb	r3, r3
}
 80041e8:	4618      	mov	r0, r3
 80041ea:	3710      	adds	r7, #16
 80041ec:	46bd      	mov	sp, r7
 80041ee:	bd80      	pop	{r7, pc}

080041f0 <lv_obj_get_style_bg_grad>:
{
 80041f0:	b580      	push	{r7, lr}
 80041f2:	b084      	sub	sp, #16
 80041f4:	af00      	add	r7, sp, #0
 80041f6:	6078      	str	r0, [r7, #4]
 80041f8:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_GRAD);
 80041fa:	2226      	movs	r2, #38	@ 0x26
 80041fc:	6839      	ldr	r1, [r7, #0]
 80041fe:	6878      	ldr	r0, [r7, #4]
 8004200:	f005 fa92 	bl	8009728 <lv_obj_get_style_prop>
 8004204:	4603      	mov	r3, r0
 8004206:	60fb      	str	r3, [r7, #12]
    return (const lv_grad_dsc_t *)v.ptr;
 8004208:	68fb      	ldr	r3, [r7, #12]
}
 800420a:	4618      	mov	r0, r3
 800420c:	3710      	adds	r7, #16
 800420e:	46bd      	mov	sp, r7
 8004210:	bd80      	pop	{r7, pc}

08004212 <lv_obj_get_style_bg_image_src>:
{
 8004212:	b580      	push	{r7, lr}
 8004214:	b084      	sub	sp, #16
 8004216:	af00      	add	r7, sp, #0
 8004218:	6078      	str	r0, [r7, #4]
 800421a:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_IMAGE_SRC);
 800421c:	2228      	movs	r2, #40	@ 0x28
 800421e:	6839      	ldr	r1, [r7, #0]
 8004220:	6878      	ldr	r0, [r7, #4]
 8004222:	f005 fa81 	bl	8009728 <lv_obj_get_style_prop>
 8004226:	4603      	mov	r3, r0
 8004228:	60fb      	str	r3, [r7, #12]
    return (const void *)v.ptr;
 800422a:	68fb      	ldr	r3, [r7, #12]
}
 800422c:	4618      	mov	r0, r3
 800422e:	3710      	adds	r7, #16
 8004230:	46bd      	mov	sp, r7
 8004232:	bd80      	pop	{r7, pc}

08004234 <lv_obj_get_style_bg_image_opa>:
{
 8004234:	b580      	push	{r7, lr}
 8004236:	b084      	sub	sp, #16
 8004238:	af00      	add	r7, sp, #0
 800423a:	6078      	str	r0, [r7, #4]
 800423c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_IMAGE_OPA);
 800423e:	2229      	movs	r2, #41	@ 0x29
 8004240:	6839      	ldr	r1, [r7, #0]
 8004242:	6878      	ldr	r0, [r7, #4]
 8004244:	f005 fa70 	bl	8009728 <lv_obj_get_style_prop>
 8004248:	4603      	mov	r3, r0
 800424a:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 800424c:	68fb      	ldr	r3, [r7, #12]
 800424e:	b2db      	uxtb	r3, r3
}
 8004250:	4618      	mov	r0, r3
 8004252:	3710      	adds	r7, #16
 8004254:	46bd      	mov	sp, r7
 8004256:	bd80      	pop	{r7, pc}

08004258 <lv_obj_get_style_bg_image_recolor_filtered>:
{
 8004258:	b580      	push	{r7, lr}
 800425a:	b086      	sub	sp, #24
 800425c:	af00      	add	r7, sp, #0
 800425e:	6078      	str	r0, [r7, #4]
 8004260:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = _lv_obj_style_apply_color_filter(obj, part, lv_obj_get_style_prop(obj, part, LV_STYLE_BG_IMAGE_RECOLOR));
 8004262:	222a      	movs	r2, #42	@ 0x2a
 8004264:	6839      	ldr	r1, [r7, #0]
 8004266:	6878      	ldr	r0, [r7, #4]
 8004268:	f005 fa5e 	bl	8009728 <lv_obj_get_style_prop>
 800426c:	4603      	mov	r3, r0
 800426e:	613b      	str	r3, [r7, #16]
 8004270:	693a      	ldr	r2, [r7, #16]
 8004272:	6839      	ldr	r1, [r7, #0]
 8004274:	6878      	ldr	r0, [r7, #4]
 8004276:	f005 fc11 	bl	8009a9c <_lv_obj_style_apply_color_filter>
 800427a:	4603      	mov	r3, r0
 800427c:	60fb      	str	r3, [r7, #12]
    return v.color;
 800427e:	f107 0314 	add.w	r3, r7, #20
 8004282:	f107 020c 	add.w	r2, r7, #12
 8004286:	6812      	ldr	r2, [r2, #0]
 8004288:	4611      	mov	r1, r2
 800428a:	8019      	strh	r1, [r3, #0]
 800428c:	3302      	adds	r3, #2
 800428e:	0c12      	lsrs	r2, r2, #16
 8004290:	701a      	strb	r2, [r3, #0]
 8004292:	2300      	movs	r3, #0
 8004294:	7d3a      	ldrb	r2, [r7, #20]
 8004296:	f362 0307 	bfi	r3, r2, #0, #8
 800429a:	7d7a      	ldrb	r2, [r7, #21]
 800429c:	f362 230f 	bfi	r3, r2, #8, #8
 80042a0:	7dba      	ldrb	r2, [r7, #22]
 80042a2:	f362 4317 	bfi	r3, r2, #16, #8
}
 80042a6:	4618      	mov	r0, r3
 80042a8:	3718      	adds	r7, #24
 80042aa:	46bd      	mov	sp, r7
 80042ac:	bd80      	pop	{r7, pc}

080042ae <lv_obj_get_style_bg_image_recolor_opa>:
{
 80042ae:	b580      	push	{r7, lr}
 80042b0:	b084      	sub	sp, #16
 80042b2:	af00      	add	r7, sp, #0
 80042b4:	6078      	str	r0, [r7, #4]
 80042b6:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_IMAGE_RECOLOR_OPA);
 80042b8:	222b      	movs	r2, #43	@ 0x2b
 80042ba:	6839      	ldr	r1, [r7, #0]
 80042bc:	6878      	ldr	r0, [r7, #4]
 80042be:	f005 fa33 	bl	8009728 <lv_obj_get_style_prop>
 80042c2:	4603      	mov	r3, r0
 80042c4:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 80042c6:	68fb      	ldr	r3, [r7, #12]
 80042c8:	b2db      	uxtb	r3, r3
}
 80042ca:	4618      	mov	r0, r3
 80042cc:	3710      	adds	r7, #16
 80042ce:	46bd      	mov	sp, r7
 80042d0:	bd80      	pop	{r7, pc}

080042d2 <lv_obj_get_style_bg_image_tiled>:
{
 80042d2:	b580      	push	{r7, lr}
 80042d4:	b084      	sub	sp, #16
 80042d6:	af00      	add	r7, sp, #0
 80042d8:	6078      	str	r0, [r7, #4]
 80042da:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_IMAGE_TILED);
 80042dc:	222c      	movs	r2, #44	@ 0x2c
 80042de:	6839      	ldr	r1, [r7, #0]
 80042e0:	6878      	ldr	r0, [r7, #4]
 80042e2:	f005 fa21 	bl	8009728 <lv_obj_get_style_prop>
 80042e6:	4603      	mov	r3, r0
 80042e8:	60fb      	str	r3, [r7, #12]
    return (bool)v.num;
 80042ea:	68fb      	ldr	r3, [r7, #12]
 80042ec:	2b00      	cmp	r3, #0
 80042ee:	bf14      	ite	ne
 80042f0:	2301      	movne	r3, #1
 80042f2:	2300      	moveq	r3, #0
 80042f4:	b2db      	uxtb	r3, r3
}
 80042f6:	4618      	mov	r0, r3
 80042f8:	3710      	adds	r7, #16
 80042fa:	46bd      	mov	sp, r7
 80042fc:	bd80      	pop	{r7, pc}

080042fe <lv_obj_get_style_border_color_filtered>:
{
 80042fe:	b580      	push	{r7, lr}
 8004300:	b086      	sub	sp, #24
 8004302:	af00      	add	r7, sp, #0
 8004304:	6078      	str	r0, [r7, #4]
 8004306:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = _lv_obj_style_apply_color_filter(obj, part, lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_COLOR));
 8004308:	2231      	movs	r2, #49	@ 0x31
 800430a:	6839      	ldr	r1, [r7, #0]
 800430c:	6878      	ldr	r0, [r7, #4]
 800430e:	f005 fa0b 	bl	8009728 <lv_obj_get_style_prop>
 8004312:	4603      	mov	r3, r0
 8004314:	613b      	str	r3, [r7, #16]
 8004316:	693a      	ldr	r2, [r7, #16]
 8004318:	6839      	ldr	r1, [r7, #0]
 800431a:	6878      	ldr	r0, [r7, #4]
 800431c:	f005 fbbe 	bl	8009a9c <_lv_obj_style_apply_color_filter>
 8004320:	4603      	mov	r3, r0
 8004322:	60fb      	str	r3, [r7, #12]
    return v.color;
 8004324:	f107 0314 	add.w	r3, r7, #20
 8004328:	f107 020c 	add.w	r2, r7, #12
 800432c:	6812      	ldr	r2, [r2, #0]
 800432e:	4611      	mov	r1, r2
 8004330:	8019      	strh	r1, [r3, #0]
 8004332:	3302      	adds	r3, #2
 8004334:	0c12      	lsrs	r2, r2, #16
 8004336:	701a      	strb	r2, [r3, #0]
 8004338:	2300      	movs	r3, #0
 800433a:	7d3a      	ldrb	r2, [r7, #20]
 800433c:	f362 0307 	bfi	r3, r2, #0, #8
 8004340:	7d7a      	ldrb	r2, [r7, #21]
 8004342:	f362 230f 	bfi	r3, r2, #8, #8
 8004346:	7dba      	ldrb	r2, [r7, #22]
 8004348:	f362 4317 	bfi	r3, r2, #16, #8
}
 800434c:	4618      	mov	r0, r3
 800434e:	3718      	adds	r7, #24
 8004350:	46bd      	mov	sp, r7
 8004352:	bd80      	pop	{r7, pc}

08004354 <lv_obj_get_style_border_opa>:
{
 8004354:	b580      	push	{r7, lr}
 8004356:	b084      	sub	sp, #16
 8004358:	af00      	add	r7, sp, #0
 800435a:	6078      	str	r0, [r7, #4]
 800435c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_OPA);
 800435e:	2232      	movs	r2, #50	@ 0x32
 8004360:	6839      	ldr	r1, [r7, #0]
 8004362:	6878      	ldr	r0, [r7, #4]
 8004364:	f005 f9e0 	bl	8009728 <lv_obj_get_style_prop>
 8004368:	4603      	mov	r3, r0
 800436a:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 800436c:	68fb      	ldr	r3, [r7, #12]
 800436e:	b2db      	uxtb	r3, r3
}
 8004370:	4618      	mov	r0, r3
 8004372:	3710      	adds	r7, #16
 8004374:	46bd      	mov	sp, r7
 8004376:	bd80      	pop	{r7, pc}

08004378 <lv_obj_get_style_border_width>:
{
 8004378:	b580      	push	{r7, lr}
 800437a:	b084      	sub	sp, #16
 800437c:	af00      	add	r7, sp, #0
 800437e:	6078      	str	r0, [r7, #4]
 8004380:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_WIDTH);
 8004382:	2230      	movs	r2, #48	@ 0x30
 8004384:	6839      	ldr	r1, [r7, #0]
 8004386:	6878      	ldr	r0, [r7, #4]
 8004388:	f005 f9ce 	bl	8009728 <lv_obj_get_style_prop>
 800438c:	4603      	mov	r3, r0
 800438e:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8004390:	68fb      	ldr	r3, [r7, #12]
}
 8004392:	4618      	mov	r0, r3
 8004394:	3710      	adds	r7, #16
 8004396:	46bd      	mov	sp, r7
 8004398:	bd80      	pop	{r7, pc}

0800439a <lv_obj_get_style_border_side>:
{
 800439a:	b580      	push	{r7, lr}
 800439c:	b084      	sub	sp, #16
 800439e:	af00      	add	r7, sp, #0
 80043a0:	6078      	str	r0, [r7, #4]
 80043a2:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_SIDE);
 80043a4:	2234      	movs	r2, #52	@ 0x34
 80043a6:	6839      	ldr	r1, [r7, #0]
 80043a8:	6878      	ldr	r0, [r7, #4]
 80043aa:	f005 f9bd 	bl	8009728 <lv_obj_get_style_prop>
 80043ae:	4603      	mov	r3, r0
 80043b0:	60fb      	str	r3, [r7, #12]
    return (lv_border_side_t)v.num;
 80043b2:	68fb      	ldr	r3, [r7, #12]
 80043b4:	b2db      	uxtb	r3, r3
}
 80043b6:	4618      	mov	r0, r3
 80043b8:	3710      	adds	r7, #16
 80043ba:	46bd      	mov	sp, r7
 80043bc:	bd80      	pop	{r7, pc}

080043be <lv_obj_get_style_outline_width>:
{
 80043be:	b580      	push	{r7, lr}
 80043c0:	b084      	sub	sp, #16
 80043c2:	af00      	add	r7, sp, #0
 80043c4:	6078      	str	r0, [r7, #4]
 80043c6:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OUTLINE_WIDTH);
 80043c8:	2238      	movs	r2, #56	@ 0x38
 80043ca:	6839      	ldr	r1, [r7, #0]
 80043cc:	6878      	ldr	r0, [r7, #4]
 80043ce:	f005 f9ab 	bl	8009728 <lv_obj_get_style_prop>
 80043d2:	4603      	mov	r3, r0
 80043d4:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80043d6:	68fb      	ldr	r3, [r7, #12]
}
 80043d8:	4618      	mov	r0, r3
 80043da:	3710      	adds	r7, #16
 80043dc:	46bd      	mov	sp, r7
 80043de:	bd80      	pop	{r7, pc}

080043e0 <lv_obj_get_style_outline_color_filtered>:
{
 80043e0:	b580      	push	{r7, lr}
 80043e2:	b086      	sub	sp, #24
 80043e4:	af00      	add	r7, sp, #0
 80043e6:	6078      	str	r0, [r7, #4]
 80043e8:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = _lv_obj_style_apply_color_filter(obj, part, lv_obj_get_style_prop(obj, part, LV_STYLE_OUTLINE_COLOR));
 80043ea:	2239      	movs	r2, #57	@ 0x39
 80043ec:	6839      	ldr	r1, [r7, #0]
 80043ee:	6878      	ldr	r0, [r7, #4]
 80043f0:	f005 f99a 	bl	8009728 <lv_obj_get_style_prop>
 80043f4:	4603      	mov	r3, r0
 80043f6:	613b      	str	r3, [r7, #16]
 80043f8:	693a      	ldr	r2, [r7, #16]
 80043fa:	6839      	ldr	r1, [r7, #0]
 80043fc:	6878      	ldr	r0, [r7, #4]
 80043fe:	f005 fb4d 	bl	8009a9c <_lv_obj_style_apply_color_filter>
 8004402:	4603      	mov	r3, r0
 8004404:	60fb      	str	r3, [r7, #12]
    return v.color;
 8004406:	f107 0314 	add.w	r3, r7, #20
 800440a:	f107 020c 	add.w	r2, r7, #12
 800440e:	6812      	ldr	r2, [r2, #0]
 8004410:	4611      	mov	r1, r2
 8004412:	8019      	strh	r1, [r3, #0]
 8004414:	3302      	adds	r3, #2
 8004416:	0c12      	lsrs	r2, r2, #16
 8004418:	701a      	strb	r2, [r3, #0]
 800441a:	2300      	movs	r3, #0
 800441c:	7d3a      	ldrb	r2, [r7, #20]
 800441e:	f362 0307 	bfi	r3, r2, #0, #8
 8004422:	7d7a      	ldrb	r2, [r7, #21]
 8004424:	f362 230f 	bfi	r3, r2, #8, #8
 8004428:	7dba      	ldrb	r2, [r7, #22]
 800442a:	f362 4317 	bfi	r3, r2, #16, #8
}
 800442e:	4618      	mov	r0, r3
 8004430:	3718      	adds	r7, #24
 8004432:	46bd      	mov	sp, r7
 8004434:	bd80      	pop	{r7, pc}

08004436 <lv_obj_get_style_outline_opa>:
{
 8004436:	b580      	push	{r7, lr}
 8004438:	b084      	sub	sp, #16
 800443a:	af00      	add	r7, sp, #0
 800443c:	6078      	str	r0, [r7, #4]
 800443e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OUTLINE_OPA);
 8004440:	223a      	movs	r2, #58	@ 0x3a
 8004442:	6839      	ldr	r1, [r7, #0]
 8004444:	6878      	ldr	r0, [r7, #4]
 8004446:	f005 f96f 	bl	8009728 <lv_obj_get_style_prop>
 800444a:	4603      	mov	r3, r0
 800444c:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 800444e:	68fb      	ldr	r3, [r7, #12]
 8004450:	b2db      	uxtb	r3, r3
}
 8004452:	4618      	mov	r0, r3
 8004454:	3710      	adds	r7, #16
 8004456:	46bd      	mov	sp, r7
 8004458:	bd80      	pop	{r7, pc}

0800445a <lv_obj_get_style_outline_pad>:
{
 800445a:	b580      	push	{r7, lr}
 800445c:	b084      	sub	sp, #16
 800445e:	af00      	add	r7, sp, #0
 8004460:	6078      	str	r0, [r7, #4]
 8004462:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OUTLINE_PAD);
 8004464:	223b      	movs	r2, #59	@ 0x3b
 8004466:	6839      	ldr	r1, [r7, #0]
 8004468:	6878      	ldr	r0, [r7, #4]
 800446a:	f005 f95d 	bl	8009728 <lv_obj_get_style_prop>
 800446e:	4603      	mov	r3, r0
 8004470:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8004472:	68fb      	ldr	r3, [r7, #12]
}
 8004474:	4618      	mov	r0, r3
 8004476:	3710      	adds	r7, #16
 8004478:	46bd      	mov	sp, r7
 800447a:	bd80      	pop	{r7, pc}

0800447c <lv_obj_get_style_shadow_width>:
{
 800447c:	b580      	push	{r7, lr}
 800447e:	b084      	sub	sp, #16
 8004480:	af00      	add	r7, sp, #0
 8004482:	6078      	str	r0, [r7, #4]
 8004484:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_WIDTH);
 8004486:	223c      	movs	r2, #60	@ 0x3c
 8004488:	6839      	ldr	r1, [r7, #0]
 800448a:	6878      	ldr	r0, [r7, #4]
 800448c:	f005 f94c 	bl	8009728 <lv_obj_get_style_prop>
 8004490:	4603      	mov	r3, r0
 8004492:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8004494:	68fb      	ldr	r3, [r7, #12]
}
 8004496:	4618      	mov	r0, r3
 8004498:	3710      	adds	r7, #16
 800449a:	46bd      	mov	sp, r7
 800449c:	bd80      	pop	{r7, pc}

0800449e <lv_obj_get_style_shadow_offset_x>:
{
 800449e:	b580      	push	{r7, lr}
 80044a0:	b084      	sub	sp, #16
 80044a2:	af00      	add	r7, sp, #0
 80044a4:	6078      	str	r0, [r7, #4]
 80044a6:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_OFFSET_X);
 80044a8:	2240      	movs	r2, #64	@ 0x40
 80044aa:	6839      	ldr	r1, [r7, #0]
 80044ac:	6878      	ldr	r0, [r7, #4]
 80044ae:	f005 f93b 	bl	8009728 <lv_obj_get_style_prop>
 80044b2:	4603      	mov	r3, r0
 80044b4:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80044b6:	68fb      	ldr	r3, [r7, #12]
}
 80044b8:	4618      	mov	r0, r3
 80044ba:	3710      	adds	r7, #16
 80044bc:	46bd      	mov	sp, r7
 80044be:	bd80      	pop	{r7, pc}

080044c0 <lv_obj_get_style_shadow_offset_y>:
{
 80044c0:	b580      	push	{r7, lr}
 80044c2:	b084      	sub	sp, #16
 80044c4:	af00      	add	r7, sp, #0
 80044c6:	6078      	str	r0, [r7, #4]
 80044c8:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_OFFSET_Y);
 80044ca:	2241      	movs	r2, #65	@ 0x41
 80044cc:	6839      	ldr	r1, [r7, #0]
 80044ce:	6878      	ldr	r0, [r7, #4]
 80044d0:	f005 f92a 	bl	8009728 <lv_obj_get_style_prop>
 80044d4:	4603      	mov	r3, r0
 80044d6:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80044d8:	68fb      	ldr	r3, [r7, #12]
}
 80044da:	4618      	mov	r0, r3
 80044dc:	3710      	adds	r7, #16
 80044de:	46bd      	mov	sp, r7
 80044e0:	bd80      	pop	{r7, pc}

080044e2 <lv_obj_get_style_shadow_spread>:
{
 80044e2:	b580      	push	{r7, lr}
 80044e4:	b084      	sub	sp, #16
 80044e6:	af00      	add	r7, sp, #0
 80044e8:	6078      	str	r0, [r7, #4]
 80044ea:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_SPREAD);
 80044ec:	2242      	movs	r2, #66	@ 0x42
 80044ee:	6839      	ldr	r1, [r7, #0]
 80044f0:	6878      	ldr	r0, [r7, #4]
 80044f2:	f005 f919 	bl	8009728 <lv_obj_get_style_prop>
 80044f6:	4603      	mov	r3, r0
 80044f8:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80044fa:	68fb      	ldr	r3, [r7, #12]
}
 80044fc:	4618      	mov	r0, r3
 80044fe:	3710      	adds	r7, #16
 8004500:	46bd      	mov	sp, r7
 8004502:	bd80      	pop	{r7, pc}

08004504 <lv_obj_get_style_shadow_color_filtered>:
{
 8004504:	b580      	push	{r7, lr}
 8004506:	b086      	sub	sp, #24
 8004508:	af00      	add	r7, sp, #0
 800450a:	6078      	str	r0, [r7, #4]
 800450c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = _lv_obj_style_apply_color_filter(obj, part, lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_COLOR));
 800450e:	223d      	movs	r2, #61	@ 0x3d
 8004510:	6839      	ldr	r1, [r7, #0]
 8004512:	6878      	ldr	r0, [r7, #4]
 8004514:	f005 f908 	bl	8009728 <lv_obj_get_style_prop>
 8004518:	4603      	mov	r3, r0
 800451a:	613b      	str	r3, [r7, #16]
 800451c:	693a      	ldr	r2, [r7, #16]
 800451e:	6839      	ldr	r1, [r7, #0]
 8004520:	6878      	ldr	r0, [r7, #4]
 8004522:	f005 fabb 	bl	8009a9c <_lv_obj_style_apply_color_filter>
 8004526:	4603      	mov	r3, r0
 8004528:	60fb      	str	r3, [r7, #12]
    return v.color;
 800452a:	f107 0314 	add.w	r3, r7, #20
 800452e:	f107 020c 	add.w	r2, r7, #12
 8004532:	6812      	ldr	r2, [r2, #0]
 8004534:	4611      	mov	r1, r2
 8004536:	8019      	strh	r1, [r3, #0]
 8004538:	3302      	adds	r3, #2
 800453a:	0c12      	lsrs	r2, r2, #16
 800453c:	701a      	strb	r2, [r3, #0]
 800453e:	2300      	movs	r3, #0
 8004540:	7d3a      	ldrb	r2, [r7, #20]
 8004542:	f362 0307 	bfi	r3, r2, #0, #8
 8004546:	7d7a      	ldrb	r2, [r7, #21]
 8004548:	f362 230f 	bfi	r3, r2, #8, #8
 800454c:	7dba      	ldrb	r2, [r7, #22]
 800454e:	f362 4317 	bfi	r3, r2, #16, #8
}
 8004552:	4618      	mov	r0, r3
 8004554:	3718      	adds	r7, #24
 8004556:	46bd      	mov	sp, r7
 8004558:	bd80      	pop	{r7, pc}

0800455a <lv_obj_get_style_shadow_opa>:
{
 800455a:	b580      	push	{r7, lr}
 800455c:	b084      	sub	sp, #16
 800455e:	af00      	add	r7, sp, #0
 8004560:	6078      	str	r0, [r7, #4]
 8004562:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_SHADOW_OPA);
 8004564:	223e      	movs	r2, #62	@ 0x3e
 8004566:	6839      	ldr	r1, [r7, #0]
 8004568:	6878      	ldr	r0, [r7, #4]
 800456a:	f005 f8dd 	bl	8009728 <lv_obj_get_style_prop>
 800456e:	4603      	mov	r3, r0
 8004570:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 8004572:	68fb      	ldr	r3, [r7, #12]
 8004574:	b2db      	uxtb	r3, r3
}
 8004576:	4618      	mov	r0, r3
 8004578:	3710      	adds	r7, #16
 800457a:	46bd      	mov	sp, r7
 800457c:	bd80      	pop	{r7, pc}

0800457e <lv_obj_get_style_text_color_filtered>:
{
 800457e:	b580      	push	{r7, lr}
 8004580:	b086      	sub	sp, #24
 8004582:	af00      	add	r7, sp, #0
 8004584:	6078      	str	r0, [r7, #4]
 8004586:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = _lv_obj_style_apply_color_filter(obj, part, lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_COLOR));
 8004588:	2258      	movs	r2, #88	@ 0x58
 800458a:	6839      	ldr	r1, [r7, #0]
 800458c:	6878      	ldr	r0, [r7, #4]
 800458e:	f005 f8cb 	bl	8009728 <lv_obj_get_style_prop>
 8004592:	4603      	mov	r3, r0
 8004594:	613b      	str	r3, [r7, #16]
 8004596:	693a      	ldr	r2, [r7, #16]
 8004598:	6839      	ldr	r1, [r7, #0]
 800459a:	6878      	ldr	r0, [r7, #4]
 800459c:	f005 fa7e 	bl	8009a9c <_lv_obj_style_apply_color_filter>
 80045a0:	4603      	mov	r3, r0
 80045a2:	60fb      	str	r3, [r7, #12]
    return v.color;
 80045a4:	f107 0314 	add.w	r3, r7, #20
 80045a8:	f107 020c 	add.w	r2, r7, #12
 80045ac:	6812      	ldr	r2, [r2, #0]
 80045ae:	4611      	mov	r1, r2
 80045b0:	8019      	strh	r1, [r3, #0]
 80045b2:	3302      	adds	r3, #2
 80045b4:	0c12      	lsrs	r2, r2, #16
 80045b6:	701a      	strb	r2, [r3, #0]
 80045b8:	2300      	movs	r3, #0
 80045ba:	7d3a      	ldrb	r2, [r7, #20]
 80045bc:	f362 0307 	bfi	r3, r2, #0, #8
 80045c0:	7d7a      	ldrb	r2, [r7, #21]
 80045c2:	f362 230f 	bfi	r3, r2, #8, #8
 80045c6:	7dba      	ldrb	r2, [r7, #22]
 80045c8:	f362 4317 	bfi	r3, r2, #16, #8
}
 80045cc:	4618      	mov	r0, r3
 80045ce:	3718      	adds	r7, #24
 80045d0:	46bd      	mov	sp, r7
 80045d2:	bd80      	pop	{r7, pc}

080045d4 <lv_obj_get_style_text_opa>:
{
 80045d4:	b580      	push	{r7, lr}
 80045d6:	b084      	sub	sp, #16
 80045d8:	af00      	add	r7, sp, #0
 80045da:	6078      	str	r0, [r7, #4]
 80045dc:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_OPA);
 80045de:	2259      	movs	r2, #89	@ 0x59
 80045e0:	6839      	ldr	r1, [r7, #0]
 80045e2:	6878      	ldr	r0, [r7, #4]
 80045e4:	f005 f8a0 	bl	8009728 <lv_obj_get_style_prop>
 80045e8:	4603      	mov	r3, r0
 80045ea:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 80045ec:	68fb      	ldr	r3, [r7, #12]
 80045ee:	b2db      	uxtb	r3, r3
}
 80045f0:	4618      	mov	r0, r3
 80045f2:	3710      	adds	r7, #16
 80045f4:	46bd      	mov	sp, r7
 80045f6:	bd80      	pop	{r7, pc}

080045f8 <lv_obj_get_style_text_font>:
{
 80045f8:	b580      	push	{r7, lr}
 80045fa:	b084      	sub	sp, #16
 80045fc:	af00      	add	r7, sp, #0
 80045fe:	6078      	str	r0, [r7, #4]
 8004600:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_FONT);
 8004602:	225a      	movs	r2, #90	@ 0x5a
 8004604:	6839      	ldr	r1, [r7, #0]
 8004606:	6878      	ldr	r0, [r7, #4]
 8004608:	f005 f88e 	bl	8009728 <lv_obj_get_style_prop>
 800460c:	4603      	mov	r3, r0
 800460e:	60fb      	str	r3, [r7, #12]
    return (const lv_font_t *)v.ptr;
 8004610:	68fb      	ldr	r3, [r7, #12]
}
 8004612:	4618      	mov	r0, r3
 8004614:	3710      	adds	r7, #16
 8004616:	46bd      	mov	sp, r7
 8004618:	bd80      	pop	{r7, pc}

0800461a <lv_obj_get_style_text_letter_space>:
{
 800461a:	b580      	push	{r7, lr}
 800461c:	b084      	sub	sp, #16
 800461e:	af00      	add	r7, sp, #0
 8004620:	6078      	str	r0, [r7, #4]
 8004622:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_LETTER_SPACE);
 8004624:	225b      	movs	r2, #91	@ 0x5b
 8004626:	6839      	ldr	r1, [r7, #0]
 8004628:	6878      	ldr	r0, [r7, #4]
 800462a:	f005 f87d 	bl	8009728 <lv_obj_get_style_prop>
 800462e:	4603      	mov	r3, r0
 8004630:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8004632:	68fb      	ldr	r3, [r7, #12]
}
 8004634:	4618      	mov	r0, r3
 8004636:	3710      	adds	r7, #16
 8004638:	46bd      	mov	sp, r7
 800463a:	bd80      	pop	{r7, pc}

0800463c <lv_obj_get_style_text_line_space>:
{
 800463c:	b580      	push	{r7, lr}
 800463e:	b084      	sub	sp, #16
 8004640:	af00      	add	r7, sp, #0
 8004642:	6078      	str	r0, [r7, #4]
 8004644:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_LINE_SPACE);
 8004646:	225c      	movs	r2, #92	@ 0x5c
 8004648:	6839      	ldr	r1, [r7, #0]
 800464a:	6878      	ldr	r0, [r7, #4]
 800464c:	f005 f86c 	bl	8009728 <lv_obj_get_style_prop>
 8004650:	4603      	mov	r3, r0
 8004652:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8004654:	68fb      	ldr	r3, [r7, #12]
}
 8004656:	4618      	mov	r0, r3
 8004658:	3710      	adds	r7, #16
 800465a:	46bd      	mov	sp, r7
 800465c:	bd80      	pop	{r7, pc}

0800465e <lv_obj_get_style_text_decor>:
{
 800465e:	b580      	push	{r7, lr}
 8004660:	b084      	sub	sp, #16
 8004662:	af00      	add	r7, sp, #0
 8004664:	6078      	str	r0, [r7, #4]
 8004666:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_DECOR);
 8004668:	225d      	movs	r2, #93	@ 0x5d
 800466a:	6839      	ldr	r1, [r7, #0]
 800466c:	6878      	ldr	r0, [r7, #4]
 800466e:	f005 f85b 	bl	8009728 <lv_obj_get_style_prop>
 8004672:	4603      	mov	r3, r0
 8004674:	60fb      	str	r3, [r7, #12]
    return (lv_text_decor_t)v.num;
 8004676:	68fb      	ldr	r3, [r7, #12]
 8004678:	b2db      	uxtb	r3, r3
}
 800467a:	4618      	mov	r0, r3
 800467c:	3710      	adds	r7, #16
 800467e:	46bd      	mov	sp, r7
 8004680:	bd80      	pop	{r7, pc}

08004682 <lv_obj_get_style_text_align>:
{
 8004682:	b580      	push	{r7, lr}
 8004684:	b084      	sub	sp, #16
 8004686:	af00      	add	r7, sp, #0
 8004688:	6078      	str	r0, [r7, #4]
 800468a:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_ALIGN);
 800468c:	225e      	movs	r2, #94	@ 0x5e
 800468e:	6839      	ldr	r1, [r7, #0]
 8004690:	6878      	ldr	r0, [r7, #4]
 8004692:	f005 f849 	bl	8009728 <lv_obj_get_style_prop>
 8004696:	4603      	mov	r3, r0
 8004698:	60fb      	str	r3, [r7, #12]
    return (lv_text_align_t)v.num;
 800469a:	68fb      	ldr	r3, [r7, #12]
 800469c:	b2db      	uxtb	r3, r3
}
 800469e:	4618      	mov	r0, r3
 80046a0:	3710      	adds	r7, #16
 80046a2:	46bd      	mov	sp, r7
 80046a4:	bd80      	pop	{r7, pc}

080046a6 <lv_obj_get_style_radius>:
{
 80046a6:	b580      	push	{r7, lr}
 80046a8:	b084      	sub	sp, #16
 80046aa:	af00      	add	r7, sp, #0
 80046ac:	6078      	str	r0, [r7, #4]
 80046ae:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_RADIUS);
 80046b0:	220c      	movs	r2, #12
 80046b2:	6839      	ldr	r1, [r7, #0]
 80046b4:	6878      	ldr	r0, [r7, #4]
 80046b6:	f005 f837 	bl	8009728 <lv_obj_get_style_prop>
 80046ba:	4603      	mov	r3, r0
 80046bc:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80046be:	68fb      	ldr	r3, [r7, #12]
}
 80046c0:	4618      	mov	r0, r3
 80046c2:	3710      	adds	r7, #16
 80046c4:	46bd      	mov	sp, r7
 80046c6:	bd80      	pop	{r7, pc}

080046c8 <lv_obj_get_style_blend_mode>:
{
 80046c8:	b580      	push	{r7, lr}
 80046ca:	b084      	sub	sp, #16
 80046cc:	af00      	add	r7, sp, #0
 80046ce:	6078      	str	r0, [r7, #4]
 80046d0:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BLEND_MODE);
 80046d2:	2267      	movs	r2, #103	@ 0x67
 80046d4:	6839      	ldr	r1, [r7, #0]
 80046d6:	6878      	ldr	r0, [r7, #4]
 80046d8:	f005 f826 	bl	8009728 <lv_obj_get_style_prop>
 80046dc:	4603      	mov	r3, r0
 80046de:	60fb      	str	r3, [r7, #12]
    return (lv_blend_mode_t)v.num;
 80046e0:	68fb      	ldr	r3, [r7, #12]
 80046e2:	b2db      	uxtb	r3, r3
}
 80046e4:	4618      	mov	r0, r3
 80046e6:	3710      	adds	r7, #16
 80046e8:	46bd      	mov	sp, r7
 80046ea:	bd80      	pop	{r7, pc}

080046ec <lv_obj_init_draw_rect_dsc>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_obj_init_draw_rect_dsc(lv_obj_t * obj, uint32_t part, lv_draw_rect_dsc_t * draw_dsc)
{
 80046ec:	b590      	push	{r4, r7, lr}
 80046ee:	b087      	sub	sp, #28
 80046f0:	af00      	add	r7, sp, #0
 80046f2:	60f8      	str	r0, [r7, #12]
 80046f4:	60b9      	str	r1, [r7, #8]
 80046f6:	607a      	str	r2, [r7, #4]
    draw_dsc->base.obj = obj;
 80046f8:	687b      	ldr	r3, [r7, #4]
 80046fa:	68fa      	ldr	r2, [r7, #12]
 80046fc:	601a      	str	r2, [r3, #0]
    draw_dsc->base.part = part;
 80046fe:	687b      	ldr	r3, [r7, #4]
 8004700:	68ba      	ldr	r2, [r7, #8]
 8004702:	605a      	str	r2, [r3, #4]

    lv_opa_t opa = lv_obj_get_style_opa_recursive(obj, part);
 8004704:	68b9      	ldr	r1, [r7, #8]
 8004706:	68f8      	ldr	r0, [r7, #12]
 8004708:	f005 fc07 	bl	8009f1a <lv_obj_get_style_opa_recursive>
 800470c:	4603      	mov	r3, r0
 800470e:	75fb      	strb	r3, [r7, #23]
    if(part != LV_PART_MAIN) {
 8004710:	68bb      	ldr	r3, [r7, #8]
 8004712:	2b00      	cmp	r3, #0
 8004714:	d017      	beq.n	8004746 <lv_obj_init_draw_rect_dsc+0x5a>
        if(opa <= LV_OPA_MIN) {
 8004716:	7dfb      	ldrb	r3, [r7, #23]
 8004718:	2b02      	cmp	r3, #2
 800471a:	d814      	bhi.n	8004746 <lv_obj_init_draw_rect_dsc+0x5a>
            draw_dsc->bg_opa = LV_OPA_TRANSP;
 800471c:	687b      	ldr	r3, [r7, #4]
 800471e:	2200      	movs	r2, #0
 8004720:	f883 2020 	strb.w	r2, [r3, #32]
            draw_dsc->bg_image_opa = LV_OPA_TRANSP;
 8004724:	687b      	ldr	r3, [r7, #4]
 8004726:	2200      	movs	r2, #0
 8004728:	f883 203b 	strb.w	r2, [r3, #59]	@ 0x3b
            draw_dsc->border_opa = LV_OPA_TRANSP;
 800472c:	687b      	ldr	r3, [r7, #4]
 800472e:	2200      	movs	r2, #0
 8004730:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
            draw_dsc->outline_opa = LV_OPA_TRANSP;
 8004734:	687b      	ldr	r3, [r7, #4]
 8004736:	2200      	movs	r2, #0
 8004738:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
            draw_dsc->shadow_opa = LV_OPA_TRANSP;
 800473c:	687b      	ldr	r3, [r7, #4]
 800473e:	2200      	movs	r2, #0
 8004740:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
            return;
 8004744:	e1fe      	b.n	8004b44 <lv_obj_init_draw_rect_dsc+0x458>
        }
    }

    draw_dsc->radius = lv_obj_get_style_radius(obj, part);
 8004746:	68b9      	ldr	r1, [r7, #8]
 8004748:	68f8      	ldr	r0, [r7, #12]
 800474a:	f7ff ffac 	bl	80046a6 <lv_obj_get_style_radius>
 800474e:	4602      	mov	r2, r0
 8004750:	687b      	ldr	r3, [r7, #4]
 8004752:	61da      	str	r2, [r3, #28]

    if(draw_dsc->bg_opa != LV_OPA_TRANSP) {
 8004754:	687b      	ldr	r3, [r7, #4]
 8004756:	f893 3020 	ldrb.w	r3, [r3, #32]
 800475a:	2b00      	cmp	r3, #0
 800475c:	f000 8094 	beq.w	8004888 <lv_obj_init_draw_rect_dsc+0x19c>
        draw_dsc->bg_opa = lv_obj_get_style_bg_opa(obj, part);
 8004760:	68b9      	ldr	r1, [r7, #8]
 8004762:	68f8      	ldr	r0, [r7, #12]
 8004764:	f7ff fcaf 	bl	80040c6 <lv_obj_get_style_bg_opa>
 8004768:	4603      	mov	r3, r0
 800476a:	461a      	mov	r2, r3
 800476c:	687b      	ldr	r3, [r7, #4]
 800476e:	f883 2020 	strb.w	r2, [r3, #32]
        if(draw_dsc->bg_opa > LV_OPA_MIN) {
 8004772:	687b      	ldr	r3, [r7, #4]
 8004774:	f893 3020 	ldrb.w	r3, [r3, #32]
 8004778:	2b02      	cmp	r3, #2
 800477a:	f240 8085 	bls.w	8004888 <lv_obj_init_draw_rect_dsc+0x19c>
            draw_dsc->bg_color = lv_obj_get_style_bg_color_filtered(obj, part);
 800477e:	687c      	ldr	r4, [r7, #4]
 8004780:	68b9      	ldr	r1, [r7, #8]
 8004782:	68f8      	ldr	r0, [r7, #12]
 8004784:	f7ff fc74 	bl	8004070 <lv_obj_get_style_bg_color_filtered>
 8004788:	4603      	mov	r3, r0
 800478a:	461a      	mov	r2, r3
 800478c:	f884 2021 	strb.w	r2, [r4, #33]	@ 0x21
 8004790:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8004794:	f884 2022 	strb.w	r2, [r4, #34]	@ 0x22
 8004798:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800479c:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
            const lv_grad_dsc_t * grad = lv_obj_get_style_bg_grad(obj, part);
 80047a0:	68b9      	ldr	r1, [r7, #8]
 80047a2:	68f8      	ldr	r0, [r7, #12]
 80047a4:	f7ff fd24 	bl	80041f0 <lv_obj_get_style_bg_grad>
 80047a8:	6138      	str	r0, [r7, #16]
            if(grad && grad->dir != LV_GRAD_DIR_NONE) {
 80047aa:	693b      	ldr	r3, [r7, #16]
 80047ac:	2b00      	cmp	r3, #0
 80047ae:	d00e      	beq.n	80047ce <lv_obj_init_draw_rect_dsc+0xe2>
 80047b0:	693b      	ldr	r3, [r7, #16]
 80047b2:	7adb      	ldrb	r3, [r3, #11]
 80047b4:	f003 0307 	and.w	r3, r3, #7
 80047b8:	b2db      	uxtb	r3, r3
 80047ba:	2b00      	cmp	r3, #0
 80047bc:	d007      	beq.n	80047ce <lv_obj_init_draw_rect_dsc+0xe2>
                lv_memcpy(&draw_dsc->bg_grad, grad, sizeof(*grad));
 80047be:	687b      	ldr	r3, [r7, #4]
 80047c0:	3324      	adds	r3, #36	@ 0x24
 80047c2:	220c      	movs	r2, #12
 80047c4:	6939      	ldr	r1, [r7, #16]
 80047c6:	4618      	mov	r0, r3
 80047c8:	f020 f90e 	bl	80249e8 <lv_memcpy>
 80047cc:	e05c      	b.n	8004888 <lv_obj_init_draw_rect_dsc+0x19c>
            }
            else {
                draw_dsc->bg_grad.dir = lv_obj_get_style_bg_grad_dir(obj, part);
 80047ce:	68b9      	ldr	r1, [r7, #8]
 80047d0:	68f8      	ldr	r0, [r7, #12]
 80047d2:	f7ff fcb5 	bl	8004140 <lv_obj_get_style_bg_grad_dir>
 80047d6:	4603      	mov	r3, r0
 80047d8:	f003 0307 	and.w	r3, r3, #7
 80047dc:	b2d9      	uxtb	r1, r3
 80047de:	687a      	ldr	r2, [r7, #4]
 80047e0:	f892 302f 	ldrb.w	r3, [r2, #47]	@ 0x2f
 80047e4:	f361 0302 	bfi	r3, r1, #0, #3
 80047e8:	f882 302f 	strb.w	r3, [r2, #47]	@ 0x2f
                if(draw_dsc->bg_grad.dir != LV_GRAD_DIR_NONE) {
 80047ec:	687b      	ldr	r3, [r7, #4]
 80047ee:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
 80047f2:	f003 0307 	and.w	r3, r3, #7
 80047f6:	b2db      	uxtb	r3, r3
 80047f8:	2b00      	cmp	r3, #0
 80047fa:	d045      	beq.n	8004888 <lv_obj_init_draw_rect_dsc+0x19c>
                    draw_dsc->bg_grad.stops[0].color = lv_obj_get_style_bg_color_filtered(obj, part);
 80047fc:	687c      	ldr	r4, [r7, #4]
 80047fe:	68b9      	ldr	r1, [r7, #8]
 8004800:	68f8      	ldr	r0, [r7, #12]
 8004802:	f7ff fc35 	bl	8004070 <lv_obj_get_style_bg_color_filtered>
 8004806:	4603      	mov	r3, r0
 8004808:	461a      	mov	r2, r3
 800480a:	f884 2024 	strb.w	r2, [r4, #36]	@ 0x24
 800480e:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8004812:	f884 2025 	strb.w	r2, [r4, #37]	@ 0x25
 8004816:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800481a:	f884 3026 	strb.w	r3, [r4, #38]	@ 0x26
                    draw_dsc->bg_grad.stops[1].color = lv_obj_get_style_bg_grad_color_filtered(obj, part);
 800481e:	687c      	ldr	r4, [r7, #4]
 8004820:	68b9      	ldr	r1, [r7, #8]
 8004822:	68f8      	ldr	r0, [r7, #12]
 8004824:	f7ff fc61 	bl	80040ea <lv_obj_get_style_bg_grad_color_filtered>
 8004828:	4603      	mov	r3, r0
 800482a:	461a      	mov	r2, r3
 800482c:	f884 2029 	strb.w	r2, [r4, #41]	@ 0x29
 8004830:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8004834:	f884 202a 	strb.w	r2, [r4, #42]	@ 0x2a
 8004838:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800483c:	f884 302b 	strb.w	r3, [r4, #43]	@ 0x2b
                    draw_dsc->bg_grad.stops[0].frac = lv_obj_get_style_bg_main_stop(obj, part);
 8004840:	68b9      	ldr	r1, [r7, #8]
 8004842:	68f8      	ldr	r0, [r7, #12]
 8004844:	f7ff fc8e 	bl	8004164 <lv_obj_get_style_bg_main_stop>
 8004848:	4603      	mov	r3, r0
 800484a:	b2da      	uxtb	r2, r3
 800484c:	687b      	ldr	r3, [r7, #4]
 800484e:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
                    draw_dsc->bg_grad.stops[1].frac = lv_obj_get_style_bg_grad_stop(obj, part);
 8004852:	68b9      	ldr	r1, [r7, #8]
 8004854:	68f8      	ldr	r0, [r7, #12]
 8004856:	f7ff fc96 	bl	8004186 <lv_obj_get_style_bg_grad_stop>
 800485a:	4603      	mov	r3, r0
 800485c:	b2da      	uxtb	r2, r3
 800485e:	687b      	ldr	r3, [r7, #4]
 8004860:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d
                    draw_dsc->bg_grad.stops[0].opa = lv_obj_get_style_bg_main_opa(obj, part);
 8004864:	68b9      	ldr	r1, [r7, #8]
 8004866:	68f8      	ldr	r0, [r7, #12]
 8004868:	f7ff fc9e 	bl	80041a8 <lv_obj_get_style_bg_main_opa>
 800486c:	4603      	mov	r3, r0
 800486e:	461a      	mov	r2, r3
 8004870:	687b      	ldr	r3, [r7, #4]
 8004872:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
                    draw_dsc->bg_grad.stops[1].opa = lv_obj_get_style_bg_grad_opa(obj, part);
 8004876:	68b9      	ldr	r1, [r7, #8]
 8004878:	68f8      	ldr	r0, [r7, #12]
 800487a:	f7ff fca7 	bl	80041cc <lv_obj_get_style_bg_grad_opa>
 800487e:	4603      	mov	r3, r0
 8004880:	461a      	mov	r2, r3
 8004882:	687b      	ldr	r3, [r7, #4]
 8004884:	f883 202c 	strb.w	r2, [r3, #44]	@ 0x2c
                }
            }
        }
    }

    if(draw_dsc->border_opa != LV_OPA_TRANSP) {
 8004888:	687b      	ldr	r3, [r7, #4]
 800488a:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800488e:	2b00      	cmp	r3, #0
 8004890:	d038      	beq.n	8004904 <lv_obj_init_draw_rect_dsc+0x218>
        draw_dsc->border_width = lv_obj_get_style_border_width(obj, part);
 8004892:	68b9      	ldr	r1, [r7, #8]
 8004894:	68f8      	ldr	r0, [r7, #12]
 8004896:	f7ff fd6f 	bl	8004378 <lv_obj_get_style_border_width>
 800489a:	4602      	mov	r2, r0
 800489c:	687b      	ldr	r3, [r7, #4]
 800489e:	645a      	str	r2, [r3, #68]	@ 0x44
        if(draw_dsc->border_width) {
 80048a0:	687b      	ldr	r3, [r7, #4]
 80048a2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80048a4:	2b00      	cmp	r3, #0
 80048a6:	d02d      	beq.n	8004904 <lv_obj_init_draw_rect_dsc+0x218>
            draw_dsc->border_opa = lv_obj_get_style_border_opa(obj, part);
 80048a8:	68b9      	ldr	r1, [r7, #8]
 80048aa:	68f8      	ldr	r0, [r7, #12]
 80048ac:	f7ff fd52 	bl	8004354 <lv_obj_get_style_border_opa>
 80048b0:	4603      	mov	r3, r0
 80048b2:	461a      	mov	r2, r3
 80048b4:	687b      	ldr	r3, [r7, #4]
 80048b6:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
            if(draw_dsc->border_opa > LV_OPA_MIN) {
 80048ba:	687b      	ldr	r3, [r7, #4]
 80048bc:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 80048c0:	2b02      	cmp	r3, #2
 80048c2:	d91f      	bls.n	8004904 <lv_obj_init_draw_rect_dsc+0x218>
                draw_dsc->border_side = lv_obj_get_style_border_side(obj, part);
 80048c4:	68b9      	ldr	r1, [r7, #8]
 80048c6:	68f8      	ldr	r0, [r7, #12]
 80048c8:	f7ff fd67 	bl	800439a <lv_obj_get_style_border_side>
 80048cc:	4603      	mov	r3, r0
 80048ce:	f003 031f 	and.w	r3, r3, #31
 80048d2:	b2d9      	uxtb	r1, r3
 80048d4:	687a      	ldr	r2, [r7, #4]
 80048d6:	f892 3049 	ldrb.w	r3, [r2, #73]	@ 0x49
 80048da:	f361 0304 	bfi	r3, r1, #0, #5
 80048de:	f882 3049 	strb.w	r3, [r2, #73]	@ 0x49
                draw_dsc->border_color = lv_obj_get_style_border_color_filtered(obj, part);
 80048e2:	687c      	ldr	r4, [r7, #4]
 80048e4:	68b9      	ldr	r1, [r7, #8]
 80048e6:	68f8      	ldr	r0, [r7, #12]
 80048e8:	f7ff fd09 	bl	80042fe <lv_obj_get_style_border_color_filtered>
 80048ec:	4603      	mov	r3, r0
 80048ee:	461a      	mov	r2, r3
 80048f0:	f884 203e 	strb.w	r2, [r4, #62]	@ 0x3e
 80048f4:	f3c3 2207 	ubfx	r2, r3, #8, #8
 80048f8:	f884 203f 	strb.w	r2, [r4, #63]	@ 0x3f
 80048fc:	f3c3 4307 	ubfx	r3, r3, #16, #8
 8004900:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
            }
        }
    }

    if(draw_dsc->outline_opa != LV_OPA_TRANSP) {
 8004904:	687b      	ldr	r3, [r7, #4]
 8004906:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 800490a:	2b00      	cmp	r3, #0
 800490c:	d030      	beq.n	8004970 <lv_obj_init_draw_rect_dsc+0x284>
        draw_dsc->outline_width = lv_obj_get_style_outline_width(obj, part);
 800490e:	68b9      	ldr	r1, [r7, #8]
 8004910:	68f8      	ldr	r0, [r7, #12]
 8004912:	f7ff fd54 	bl	80043be <lv_obj_get_style_outline_width>
 8004916:	4602      	mov	r2, r0
 8004918:	687b      	ldr	r3, [r7, #4]
 800491a:	651a      	str	r2, [r3, #80]	@ 0x50
        if(draw_dsc->outline_width) {
 800491c:	687b      	ldr	r3, [r7, #4]
 800491e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8004920:	2b00      	cmp	r3, #0
 8004922:	d025      	beq.n	8004970 <lv_obj_init_draw_rect_dsc+0x284>
            draw_dsc->outline_opa = lv_obj_get_style_outline_opa(obj, part);
 8004924:	68b9      	ldr	r1, [r7, #8]
 8004926:	68f8      	ldr	r0, [r7, #12]
 8004928:	f7ff fd85 	bl	8004436 <lv_obj_get_style_outline_opa>
 800492c:	4603      	mov	r3, r0
 800492e:	461a      	mov	r2, r3
 8004930:	687b      	ldr	r3, [r7, #4]
 8004932:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
            if(draw_dsc->outline_opa > LV_OPA_MIN) {
 8004936:	687b      	ldr	r3, [r7, #4]
 8004938:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 800493c:	2b02      	cmp	r3, #2
 800493e:	d917      	bls.n	8004970 <lv_obj_init_draw_rect_dsc+0x284>
                draw_dsc->outline_pad = lv_obj_get_style_outline_pad(obj, part);
 8004940:	68b9      	ldr	r1, [r7, #8]
 8004942:	68f8      	ldr	r0, [r7, #12]
 8004944:	f7ff fd89 	bl	800445a <lv_obj_get_style_outline_pad>
 8004948:	4602      	mov	r2, r0
 800494a:	687b      	ldr	r3, [r7, #4]
 800494c:	655a      	str	r2, [r3, #84]	@ 0x54
                draw_dsc->outline_color = lv_obj_get_style_outline_color_filtered(obj, part);
 800494e:	687c      	ldr	r4, [r7, #4]
 8004950:	68b9      	ldr	r1, [r7, #8]
 8004952:	68f8      	ldr	r0, [r7, #12]
 8004954:	f7ff fd44 	bl	80043e0 <lv_obj_get_style_outline_color_filtered>
 8004958:	4603      	mov	r3, r0
 800495a:	461a      	mov	r2, r3
 800495c:	f884 204a 	strb.w	r2, [r4, #74]	@ 0x4a
 8004960:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8004964:	f884 204b 	strb.w	r2, [r4, #75]	@ 0x4b
 8004968:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800496c:	f884 304c 	strb.w	r3, [r4, #76]	@ 0x4c
            }
        }
    }

    if(draw_dsc->bg_image_opa != LV_OPA_TRANSP) {
 8004970:	687b      	ldr	r3, [r7, #4]
 8004972:	f893 303b 	ldrb.w	r3, [r3, #59]	@ 0x3b
 8004976:	2b00      	cmp	r3, #0
 8004978:	d05c      	beq.n	8004a34 <lv_obj_init_draw_rect_dsc+0x348>
        draw_dsc->bg_image_src = lv_obj_get_style_bg_image_src(obj, part);
 800497a:	68b9      	ldr	r1, [r7, #8]
 800497c:	68f8      	ldr	r0, [r7, #12]
 800497e:	f7ff fc48 	bl	8004212 <lv_obj_get_style_bg_image_src>
 8004982:	4602      	mov	r2, r0
 8004984:	687b      	ldr	r3, [r7, #4]
 8004986:	631a      	str	r2, [r3, #48]	@ 0x30
        if(draw_dsc->bg_image_src) {
 8004988:	687b      	ldr	r3, [r7, #4]
 800498a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800498c:	2b00      	cmp	r3, #0
 800498e:	d051      	beq.n	8004a34 <lv_obj_init_draw_rect_dsc+0x348>
            draw_dsc->bg_image_opa = lv_obj_get_style_bg_image_opa(obj, part);
 8004990:	68b9      	ldr	r1, [r7, #8]
 8004992:	68f8      	ldr	r0, [r7, #12]
 8004994:	f7ff fc4e 	bl	8004234 <lv_obj_get_style_bg_image_opa>
 8004998:	4603      	mov	r3, r0
 800499a:	461a      	mov	r2, r3
 800499c:	687b      	ldr	r3, [r7, #4]
 800499e:	f883 203b 	strb.w	r2, [r3, #59]	@ 0x3b
            if(draw_dsc->bg_image_opa > LV_OPA_MIN) {
 80049a2:	687b      	ldr	r3, [r7, #4]
 80049a4:	f893 303b 	ldrb.w	r3, [r3, #59]	@ 0x3b
 80049a8:	2b02      	cmp	r3, #2
 80049aa:	d943      	bls.n	8004a34 <lv_obj_init_draw_rect_dsc+0x348>
                if(lv_image_src_get_type(draw_dsc->bg_image_src) == LV_IMAGE_SRC_SYMBOL) {
 80049ac:	687b      	ldr	r3, [r7, #4]
 80049ae:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80049b0:	4618      	mov	r0, r3
 80049b2:	f007 febf 	bl	800c734 <lv_image_src_get_type>
 80049b6:	4603      	mov	r3, r0
 80049b8:	2b02      	cmp	r3, #2
 80049ba:	d118      	bne.n	80049ee <lv_obj_init_draw_rect_dsc+0x302>
                    draw_dsc->bg_image_symbol_font = lv_obj_get_style_text_font(obj, part);
 80049bc:	68b9      	ldr	r1, [r7, #8]
 80049be:	68f8      	ldr	r0, [r7, #12]
 80049c0:	f7ff fe1a 	bl	80045f8 <lv_obj_get_style_text_font>
 80049c4:	4602      	mov	r2, r0
 80049c6:	687b      	ldr	r3, [r7, #4]
 80049c8:	635a      	str	r2, [r3, #52]	@ 0x34
                    draw_dsc->bg_image_recolor = lv_obj_get_style_text_color_filtered(obj, part);
 80049ca:	687c      	ldr	r4, [r7, #4]
 80049cc:	68b9      	ldr	r1, [r7, #8]
 80049ce:	68f8      	ldr	r0, [r7, #12]
 80049d0:	f7ff fdd5 	bl	800457e <lv_obj_get_style_text_color_filtered>
 80049d4:	4603      	mov	r3, r0
 80049d6:	461a      	mov	r2, r3
 80049d8:	f884 2038 	strb.w	r2, [r4, #56]	@ 0x38
 80049dc:	f3c3 2207 	ubfx	r2, r3, #8, #8
 80049e0:	f884 2039 	strb.w	r2, [r4, #57]	@ 0x39
 80049e4:	f3c3 4307 	ubfx	r3, r3, #16, #8
 80049e8:	f884 303a 	strb.w	r3, [r4, #58]	@ 0x3a
 80049ec:	e022      	b.n	8004a34 <lv_obj_init_draw_rect_dsc+0x348>
                }
                else {
                    draw_dsc->bg_image_recolor = lv_obj_get_style_bg_image_recolor_filtered(obj, part);
 80049ee:	687c      	ldr	r4, [r7, #4]
 80049f0:	68b9      	ldr	r1, [r7, #8]
 80049f2:	68f8      	ldr	r0, [r7, #12]
 80049f4:	f7ff fc30 	bl	8004258 <lv_obj_get_style_bg_image_recolor_filtered>
 80049f8:	4603      	mov	r3, r0
 80049fa:	461a      	mov	r2, r3
 80049fc:	f884 2038 	strb.w	r2, [r4, #56]	@ 0x38
 8004a00:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8004a04:	f884 2039 	strb.w	r2, [r4, #57]	@ 0x39
 8004a08:	f3c3 4307 	ubfx	r3, r3, #16, #8
 8004a0c:	f884 303a 	strb.w	r3, [r4, #58]	@ 0x3a
                    draw_dsc->bg_image_recolor_opa = lv_obj_get_style_bg_image_recolor_opa(obj, part);
 8004a10:	68b9      	ldr	r1, [r7, #8]
 8004a12:	68f8      	ldr	r0, [r7, #12]
 8004a14:	f7ff fc4b 	bl	80042ae <lv_obj_get_style_bg_image_recolor_opa>
 8004a18:	4603      	mov	r3, r0
 8004a1a:	461a      	mov	r2, r3
 8004a1c:	687b      	ldr	r3, [r7, #4]
 8004a1e:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
                    draw_dsc->bg_image_tiled = lv_obj_get_style_bg_image_tiled(obj, part);
 8004a22:	68b9      	ldr	r1, [r7, #8]
 8004a24:	68f8      	ldr	r0, [r7, #12]
 8004a26:	f7ff fc54 	bl	80042d2 <lv_obj_get_style_bg_image_tiled>
 8004a2a:	4603      	mov	r3, r0
 8004a2c:	461a      	mov	r2, r3
 8004a2e:	687b      	ldr	r3, [r7, #4]
 8004a30:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
                }
            }
        }
    }

    if(draw_dsc->shadow_opa) {
 8004a34:	687b      	ldr	r3, [r7, #4]
 8004a36:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
 8004a3a:	2b00      	cmp	r3, #0
 8004a3c:	d043      	beq.n	8004ac6 <lv_obj_init_draw_rect_dsc+0x3da>
        draw_dsc->shadow_width = lv_obj_get_style_shadow_width(obj, part);
 8004a3e:	68b9      	ldr	r1, [r7, #8]
 8004a40:	68f8      	ldr	r0, [r7, #12]
 8004a42:	f7ff fd1b 	bl	800447c <lv_obj_get_style_shadow_width>
 8004a46:	4602      	mov	r2, r0
 8004a48:	687b      	ldr	r3, [r7, #4]
 8004a4a:	65da      	str	r2, [r3, #92]	@ 0x5c
        if(draw_dsc->shadow_width) {
 8004a4c:	687b      	ldr	r3, [r7, #4]
 8004a4e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004a50:	2b00      	cmp	r3, #0
 8004a52:	d038      	beq.n	8004ac6 <lv_obj_init_draw_rect_dsc+0x3da>
            if(draw_dsc->shadow_opa > LV_OPA_MIN) {
 8004a54:	687b      	ldr	r3, [r7, #4]
 8004a56:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
 8004a5a:	2b02      	cmp	r3, #2
 8004a5c:	d933      	bls.n	8004ac6 <lv_obj_init_draw_rect_dsc+0x3da>
                draw_dsc->shadow_opa = lv_obj_get_style_shadow_opa(obj, part);
 8004a5e:	68b9      	ldr	r1, [r7, #8]
 8004a60:	68f8      	ldr	r0, [r7, #12]
 8004a62:	f7ff fd7a 	bl	800455a <lv_obj_get_style_shadow_opa>
 8004a66:	4603      	mov	r3, r0
 8004a68:	461a      	mov	r2, r3
 8004a6a:	687b      	ldr	r3, [r7, #4]
 8004a6c:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
                if(draw_dsc->shadow_opa > LV_OPA_MIN) {
 8004a70:	687b      	ldr	r3, [r7, #4]
 8004a72:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
 8004a76:	2b02      	cmp	r3, #2
 8004a78:	d925      	bls.n	8004ac6 <lv_obj_init_draw_rect_dsc+0x3da>
                    draw_dsc->shadow_offset_x = lv_obj_get_style_shadow_offset_x(obj, part);
 8004a7a:	68b9      	ldr	r1, [r7, #8]
 8004a7c:	68f8      	ldr	r0, [r7, #12]
 8004a7e:	f7ff fd0e 	bl	800449e <lv_obj_get_style_shadow_offset_x>
 8004a82:	4602      	mov	r2, r0
 8004a84:	687b      	ldr	r3, [r7, #4]
 8004a86:	661a      	str	r2, [r3, #96]	@ 0x60
                    draw_dsc->shadow_offset_y = lv_obj_get_style_shadow_offset_y(obj, part);
 8004a88:	68b9      	ldr	r1, [r7, #8]
 8004a8a:	68f8      	ldr	r0, [r7, #12]
 8004a8c:	f7ff fd18 	bl	80044c0 <lv_obj_get_style_shadow_offset_y>
 8004a90:	4602      	mov	r2, r0
 8004a92:	687b      	ldr	r3, [r7, #4]
 8004a94:	665a      	str	r2, [r3, #100]	@ 0x64
                    draw_dsc->shadow_spread = lv_obj_get_style_shadow_spread(obj, part);
 8004a96:	68b9      	ldr	r1, [r7, #8]
 8004a98:	68f8      	ldr	r0, [r7, #12]
 8004a9a:	f7ff fd22 	bl	80044e2 <lv_obj_get_style_shadow_spread>
 8004a9e:	4602      	mov	r2, r0
 8004aa0:	687b      	ldr	r3, [r7, #4]
 8004aa2:	669a      	str	r2, [r3, #104]	@ 0x68
                    draw_dsc->shadow_color = lv_obj_get_style_shadow_color_filtered(obj, part);
 8004aa4:	687c      	ldr	r4, [r7, #4]
 8004aa6:	68b9      	ldr	r1, [r7, #8]
 8004aa8:	68f8      	ldr	r0, [r7, #12]
 8004aaa:	f7ff fd2b 	bl	8004504 <lv_obj_get_style_shadow_color_filtered>
 8004aae:	4603      	mov	r3, r0
 8004ab0:	461a      	mov	r2, r3
 8004ab2:	f884 2059 	strb.w	r2, [r4, #89]	@ 0x59
 8004ab6:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8004aba:	f884 205a 	strb.w	r2, [r4, #90]	@ 0x5a
 8004abe:	f3c3 4307 	ubfx	r3, r3, #16, #8
 8004ac2:	f884 305b 	strb.w	r3, [r4, #91]	@ 0x5b
                }
            }
        }
    }

    if(opa < LV_OPA_MAX) {
 8004ac6:	7dfb      	ldrb	r3, [r7, #23]
 8004ac8:	2bfc      	cmp	r3, #252	@ 0xfc
 8004aca:	d83b      	bhi.n	8004b44 <lv_obj_init_draw_rect_dsc+0x458>
        draw_dsc->bg_opa = LV_OPA_MIX2(draw_dsc->bg_opa, opa);
 8004acc:	687b      	ldr	r3, [r7, #4]
 8004ace:	f893 3020 	ldrb.w	r3, [r3, #32]
 8004ad2:	461a      	mov	r2, r3
 8004ad4:	7dfb      	ldrb	r3, [r7, #23]
 8004ad6:	fb02 f303 	mul.w	r3, r2, r3
 8004ada:	121b      	asrs	r3, r3, #8
 8004adc:	b2da      	uxtb	r2, r3
 8004ade:	687b      	ldr	r3, [r7, #4]
 8004ae0:	f883 2020 	strb.w	r2, [r3, #32]
        draw_dsc->bg_image_opa = LV_OPA_MIX2(draw_dsc->bg_image_opa, opa);
 8004ae4:	687b      	ldr	r3, [r7, #4]
 8004ae6:	f893 303b 	ldrb.w	r3, [r3, #59]	@ 0x3b
 8004aea:	461a      	mov	r2, r3
 8004aec:	7dfb      	ldrb	r3, [r7, #23]
 8004aee:	fb02 f303 	mul.w	r3, r2, r3
 8004af2:	121b      	asrs	r3, r3, #8
 8004af4:	b2da      	uxtb	r2, r3
 8004af6:	687b      	ldr	r3, [r7, #4]
 8004af8:	f883 203b 	strb.w	r2, [r3, #59]	@ 0x3b
        draw_dsc->border_opa = LV_OPA_MIX2(draw_dsc->border_opa, opa);
 8004afc:	687b      	ldr	r3, [r7, #4]
 8004afe:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 8004b02:	461a      	mov	r2, r3
 8004b04:	7dfb      	ldrb	r3, [r7, #23]
 8004b06:	fb02 f303 	mul.w	r3, r2, r3
 8004b0a:	121b      	asrs	r3, r3, #8
 8004b0c:	b2da      	uxtb	r2, r3
 8004b0e:	687b      	ldr	r3, [r7, #4]
 8004b10:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
        draw_dsc->shadow_opa = LV_OPA_MIX2(draw_dsc->shadow_opa, opa);
 8004b14:	687b      	ldr	r3, [r7, #4]
 8004b16:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
 8004b1a:	461a      	mov	r2, r3
 8004b1c:	7dfb      	ldrb	r3, [r7, #23]
 8004b1e:	fb02 f303 	mul.w	r3, r2, r3
 8004b22:	121b      	asrs	r3, r3, #8
 8004b24:	b2da      	uxtb	r2, r3
 8004b26:	687b      	ldr	r3, [r7, #4]
 8004b28:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
        draw_dsc->outline_opa = LV_OPA_MIX2(draw_dsc->outline_opa, opa);
 8004b2c:	687b      	ldr	r3, [r7, #4]
 8004b2e:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 8004b32:	461a      	mov	r2, r3
 8004b34:	7dfb      	ldrb	r3, [r7, #23]
 8004b36:	fb02 f303 	mul.w	r3, r2, r3
 8004b3a:	121b      	asrs	r3, r3, #8
 8004b3c:	b2da      	uxtb	r2, r3
 8004b3e:	687b      	ldr	r3, [r7, #4]
 8004b40:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
    }
}
 8004b44:	371c      	adds	r7, #28
 8004b46:	46bd      	mov	sp, r7
 8004b48:	bd90      	pop	{r4, r7, pc}

08004b4a <lv_obj_init_draw_label_dsc>:

void lv_obj_init_draw_label_dsc(lv_obj_t * obj, uint32_t part, lv_draw_label_dsc_t * draw_dsc)
{
 8004b4a:	b590      	push	{r4, r7, lr}
 8004b4c:	b087      	sub	sp, #28
 8004b4e:	af00      	add	r7, sp, #0
 8004b50:	60f8      	str	r0, [r7, #12]
 8004b52:	60b9      	str	r1, [r7, #8]
 8004b54:	607a      	str	r2, [r7, #4]
    draw_dsc->base.obj = obj;
 8004b56:	687b      	ldr	r3, [r7, #4]
 8004b58:	68fa      	ldr	r2, [r7, #12]
 8004b5a:	601a      	str	r2, [r3, #0]
    draw_dsc->base.part = part;
 8004b5c:	687b      	ldr	r3, [r7, #4]
 8004b5e:	68ba      	ldr	r2, [r7, #8]
 8004b60:	605a      	str	r2, [r3, #4]

    draw_dsc->opa = lv_obj_get_style_text_opa(obj, part);
 8004b62:	68b9      	ldr	r1, [r7, #8]
 8004b64:	68f8      	ldr	r0, [r7, #12]
 8004b66:	f7ff fd35 	bl	80045d4 <lv_obj_get_style_text_opa>
 8004b6a:	4603      	mov	r3, r0
 8004b6c:	461a      	mov	r2, r3
 8004b6e:	687b      	ldr	r3, [r7, #4]
 8004b70:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
    if(draw_dsc->opa <= LV_OPA_MIN) return;
 8004b74:	687b      	ldr	r3, [r7, #4]
 8004b76:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 8004b7a:	2b02      	cmp	r3, #2
 8004b7c:	d96a      	bls.n	8004c54 <lv_obj_init_draw_label_dsc+0x10a>

    lv_opa_t opa = lv_obj_get_style_opa_recursive(obj, part);
 8004b7e:	68b9      	ldr	r1, [r7, #8]
 8004b80:	68f8      	ldr	r0, [r7, #12]
 8004b82:	f005 f9ca 	bl	8009f1a <lv_obj_get_style_opa_recursive>
 8004b86:	4603      	mov	r3, r0
 8004b88:	75fb      	strb	r3, [r7, #23]
    if(opa < LV_OPA_MAX) {
 8004b8a:	7dfb      	ldrb	r3, [r7, #23]
 8004b8c:	2bfc      	cmp	r3, #252	@ 0xfc
 8004b8e:	d80b      	bhi.n	8004ba8 <lv_obj_init_draw_label_dsc+0x5e>
        draw_dsc->opa = LV_OPA_MIX2(draw_dsc->opa, opa);
 8004b90:	687b      	ldr	r3, [r7, #4]
 8004b92:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 8004b96:	461a      	mov	r2, r3
 8004b98:	7dfb      	ldrb	r3, [r7, #23]
 8004b9a:	fb02 f303 	mul.w	r3, r2, r3
 8004b9e:	121b      	asrs	r3, r3, #8
 8004ba0:	b2da      	uxtb	r2, r3
 8004ba2:	687b      	ldr	r3, [r7, #4]
 8004ba4:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
    }
    if(draw_dsc->opa <= LV_OPA_MIN) return;
 8004ba8:	687b      	ldr	r3, [r7, #4]
 8004baa:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 8004bae:	2b02      	cmp	r3, #2
 8004bb0:	d952      	bls.n	8004c58 <lv_obj_init_draw_label_dsc+0x10e>

    draw_dsc->color = lv_obj_get_style_text_color_filtered(obj, part);
 8004bb2:	687c      	ldr	r4, [r7, #4]
 8004bb4:	68b9      	ldr	r1, [r7, #8]
 8004bb6:	68f8      	ldr	r0, [r7, #12]
 8004bb8:	f7ff fce1 	bl	800457e <lv_obj_get_style_text_color_filtered>
 8004bbc:	4603      	mov	r3, r0
 8004bbe:	461a      	mov	r2, r3
 8004bc0:	f884 202c 	strb.w	r2, [r4, #44]	@ 0x2c
 8004bc4:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8004bc8:	f884 202d 	strb.w	r2, [r4, #45]	@ 0x2d
 8004bcc:	f3c3 4307 	ubfx	r3, r3, #16, #8
 8004bd0:	f884 302e 	strb.w	r3, [r4, #46]	@ 0x2e
    draw_dsc->letter_space = lv_obj_get_style_text_letter_space(obj, part);
 8004bd4:	68b9      	ldr	r1, [r7, #8]
 8004bd6:	68f8      	ldr	r0, [r7, #12]
 8004bd8:	f7ff fd1f 	bl	800461a <lv_obj_get_style_text_letter_space>
 8004bdc:	4602      	mov	r2, r0
 8004bde:	687b      	ldr	r3, [r7, #4]
 8004be0:	63da      	str	r2, [r3, #60]	@ 0x3c
    draw_dsc->line_space = lv_obj_get_style_text_line_space(obj, part);
 8004be2:	68b9      	ldr	r1, [r7, #8]
 8004be4:	68f8      	ldr	r0, [r7, #12]
 8004be6:	f7ff fd29 	bl	800463c <lv_obj_get_style_text_line_space>
 8004bea:	4602      	mov	r2, r0
 8004bec:	687b      	ldr	r3, [r7, #4]
 8004bee:	639a      	str	r2, [r3, #56]	@ 0x38
    draw_dsc->decor = lv_obj_get_style_text_decor(obj, part);
 8004bf0:	68b9      	ldr	r1, [r7, #8]
 8004bf2:	68f8      	ldr	r0, [r7, #12]
 8004bf4:	f7ff fd33 	bl	800465e <lv_obj_get_style_text_decor>
 8004bf8:	4603      	mov	r3, r0
 8004bfa:	f003 0307 	and.w	r3, r3, #7
 8004bfe:	b2d9      	uxtb	r1, r3
 8004c00:	687a      	ldr	r2, [r7, #4]
 8004c02:	f892 304c 	ldrb.w	r3, [r2, #76]	@ 0x4c
 8004c06:	f361 0302 	bfi	r3, r1, #0, #3
 8004c0a:	f882 304c 	strb.w	r3, [r2, #76]	@ 0x4c
    if(part != LV_PART_MAIN) draw_dsc->blend_mode = lv_obj_get_style_blend_mode(obj, part);
 8004c0e:	68bb      	ldr	r3, [r7, #8]
 8004c10:	2b00      	cmp	r3, #0
 8004c12:	d00e      	beq.n	8004c32 <lv_obj_init_draw_label_dsc+0xe8>
 8004c14:	68b9      	ldr	r1, [r7, #8]
 8004c16:	68f8      	ldr	r0, [r7, #12]
 8004c18:	f7ff fd56 	bl	80046c8 <lv_obj_get_style_blend_mode>
 8004c1c:	4603      	mov	r3, r0
 8004c1e:	f003 0307 	and.w	r3, r3, #7
 8004c22:	b2d9      	uxtb	r1, r3
 8004c24:	687a      	ldr	r2, [r7, #4]
 8004c26:	f892 304c 	ldrb.w	r3, [r2, #76]	@ 0x4c
 8004c2a:	f361 03c5 	bfi	r3, r1, #3, #3
 8004c2e:	f882 304c 	strb.w	r3, [r2, #76]	@ 0x4c

    draw_dsc->font = lv_obj_get_style_text_font(obj, part);
 8004c32:	68b9      	ldr	r1, [r7, #8]
 8004c34:	68f8      	ldr	r0, [r7, #12]
 8004c36:	f7ff fcdf 	bl	80045f8 <lv_obj_get_style_text_font>
 8004c3a:	4602      	mov	r2, r0
 8004c3c:	687b      	ldr	r3, [r7, #4]
 8004c3e:	621a      	str	r2, [r3, #32]

#if LV_USE_BIDI
    draw_dsc->bidi_dir = lv_obj_get_style_base_dir(obj, LV_PART_MAIN);
#endif

    draw_dsc->align = lv_obj_get_style_text_align(obj, part);
 8004c40:	68b9      	ldr	r1, [r7, #8]
 8004c42:	68f8      	ldr	r0, [r7, #12]
 8004c44:	f7ff fd1d 	bl	8004682 <lv_obj_get_style_text_align>
 8004c48:	4603      	mov	r3, r0
 8004c4a:	461a      	mov	r2, r3
 8004c4c:	687b      	ldr	r3, [r7, #4]
 8004c4e:	f883 204a 	strb.w	r2, [r3, #74]	@ 0x4a
 8004c52:	e002      	b.n	8004c5a <lv_obj_init_draw_label_dsc+0x110>
    if(draw_dsc->opa <= LV_OPA_MIN) return;
 8004c54:	bf00      	nop
 8004c56:	e000      	b.n	8004c5a <lv_obj_init_draw_label_dsc+0x110>
    if(draw_dsc->opa <= LV_OPA_MIN) return;
 8004c58:	bf00      	nop
}
 8004c5a:	371c      	adds	r7, #28
 8004c5c:	46bd      	mov	sp, r7
 8004c5e:	bd90      	pop	{r4, r7, pc}

08004c60 <lv_obj_calculate_ext_draw_size>:

    draw_dsc->rounded = lv_obj_get_style_arc_rounded(obj, part);
}

int32_t lv_obj_calculate_ext_draw_size(lv_obj_t * obj, uint32_t part)
{
 8004c60:	b580      	push	{r7, lr}
 8004c62:	b08e      	sub	sp, #56	@ 0x38
 8004c64:	af00      	add	r7, sp, #0
 8004c66:	6078      	str	r0, [r7, #4]
 8004c68:	6039      	str	r1, [r7, #0]
    int32_t s = 0;
 8004c6a:	2300      	movs	r3, #0
 8004c6c:	637b      	str	r3, [r7, #52]	@ 0x34

    int32_t sh_width = lv_obj_get_style_shadow_width(obj, part);
 8004c6e:	6839      	ldr	r1, [r7, #0]
 8004c70:	6878      	ldr	r0, [r7, #4]
 8004c72:	f7ff fc03 	bl	800447c <lv_obj_get_style_shadow_width>
 8004c76:	6338      	str	r0, [r7, #48]	@ 0x30
    if(sh_width) {
 8004c78:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004c7a:	2b00      	cmp	r3, #0
 8004c7c:	d037      	beq.n	8004cee <lv_obj_calculate_ext_draw_size+0x8e>
        lv_opa_t sh_opa = lv_obj_get_style_shadow_opa(obj, part);
 8004c7e:	6839      	ldr	r1, [r7, #0]
 8004c80:	6878      	ldr	r0, [r7, #4]
 8004c82:	f7ff fc6a 	bl	800455a <lv_obj_get_style_shadow_opa>
 8004c86:	4603      	mov	r3, r0
 8004c88:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        if(sh_opa > LV_OPA_MIN) {
 8004c8c:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8004c90:	2b02      	cmp	r3, #2
 8004c92:	d92c      	bls.n	8004cee <lv_obj_calculate_ext_draw_size+0x8e>
            sh_width = sh_width / 2 + 1;    /*The blur adds only half width*/
 8004c94:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004c96:	0fda      	lsrs	r2, r3, #31
 8004c98:	4413      	add	r3, r2
 8004c9a:	105b      	asrs	r3, r3, #1
 8004c9c:	3301      	adds	r3, #1
 8004c9e:	633b      	str	r3, [r7, #48]	@ 0x30
            sh_width += lv_obj_get_style_shadow_spread(obj, part);
 8004ca0:	6839      	ldr	r1, [r7, #0]
 8004ca2:	6878      	ldr	r0, [r7, #4]
 8004ca4:	f7ff fc1d 	bl	80044e2 <lv_obj_get_style_shadow_spread>
 8004ca8:	4602      	mov	r2, r0
 8004caa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004cac:	4413      	add	r3, r2
 8004cae:	633b      	str	r3, [r7, #48]	@ 0x30
            int32_t sh_ofs_x = lv_obj_get_style_shadow_offset_x(obj, part);
 8004cb0:	6839      	ldr	r1, [r7, #0]
 8004cb2:	6878      	ldr	r0, [r7, #4]
 8004cb4:	f7ff fbf3 	bl	800449e <lv_obj_get_style_shadow_offset_x>
 8004cb8:	62b8      	str	r0, [r7, #40]	@ 0x28
            int32_t sh_ofs_y = lv_obj_get_style_shadow_offset_y(obj, part);
 8004cba:	6839      	ldr	r1, [r7, #0]
 8004cbc:	6878      	ldr	r0, [r7, #4]
 8004cbe:	f7ff fbff 	bl	80044c0 <lv_obj_get_style_shadow_offset_y>
 8004cc2:	6278      	str	r0, [r7, #36]	@ 0x24
            sh_width += LV_MAX(LV_ABS(sh_ofs_x), LV_ABS(sh_ofs_y));
 8004cc4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8004cc6:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8004cca:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 8004cce:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8004cd0:	2b00      	cmp	r3, #0
 8004cd2:	bfb8      	it	lt
 8004cd4:	425b      	neglt	r3, r3
 8004cd6:	4293      	cmp	r3, r2
 8004cd8:	bfb8      	it	lt
 8004cda:	4613      	movlt	r3, r2
 8004cdc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8004cde:	4413      	add	r3, r2
 8004ce0:	633b      	str	r3, [r7, #48]	@ 0x30
            s = LV_MAX(s, sh_width);
 8004ce2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8004ce4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8004ce6:	4293      	cmp	r3, r2
 8004ce8:	bfb8      	it	lt
 8004cea:	4613      	movlt	r3, r2
 8004cec:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }

    int32_t outline_width = lv_obj_get_style_outline_width(obj, part);
 8004cee:	6839      	ldr	r1, [r7, #0]
 8004cf0:	6878      	ldr	r0, [r7, #4]
 8004cf2:	f7ff fb64 	bl	80043be <lv_obj_get_style_outline_width>
 8004cf6:	6238      	str	r0, [r7, #32]
    if(outline_width) {
 8004cf8:	6a3b      	ldr	r3, [r7, #32]
 8004cfa:	2b00      	cmp	r3, #0
 8004cfc:	d015      	beq.n	8004d2a <lv_obj_calculate_ext_draw_size+0xca>
        lv_opa_t outline_opa = lv_obj_get_style_outline_opa(obj, part);
 8004cfe:	6839      	ldr	r1, [r7, #0]
 8004d00:	6878      	ldr	r0, [r7, #4]
 8004d02:	f7ff fb98 	bl	8004436 <lv_obj_get_style_outline_opa>
 8004d06:	4603      	mov	r3, r0
 8004d08:	77fb      	strb	r3, [r7, #31]
        if(outline_opa > LV_OPA_MIN) {
 8004d0a:	7ffb      	ldrb	r3, [r7, #31]
 8004d0c:	2b02      	cmp	r3, #2
 8004d0e:	d90c      	bls.n	8004d2a <lv_obj_calculate_ext_draw_size+0xca>
            int32_t outline_pad = lv_obj_get_style_outline_pad(obj, part);
 8004d10:	6839      	ldr	r1, [r7, #0]
 8004d12:	6878      	ldr	r0, [r7, #4]
 8004d14:	f7ff fba1 	bl	800445a <lv_obj_get_style_outline_pad>
 8004d18:	61b8      	str	r0, [r7, #24]
            s = LV_MAX(s, outline_pad + outline_width);
 8004d1a:	69ba      	ldr	r2, [r7, #24]
 8004d1c:	6a3b      	ldr	r3, [r7, #32]
 8004d1e:	4413      	add	r3, r2
 8004d20:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8004d22:	4293      	cmp	r3, r2
 8004d24:	bfb8      	it	lt
 8004d26:	4613      	movlt	r3, r2
 8004d28:	637b      	str	r3, [r7, #52]	@ 0x34
        }
    }

    int32_t w = lv_obj_get_style_transform_width(obj, part);
 8004d2a:	6839      	ldr	r1, [r7, #0]
 8004d2c:	6878      	ldr	r0, [r7, #4]
 8004d2e:	f7ff f97d 	bl	800402c <lv_obj_get_style_transform_width>
 8004d32:	6178      	str	r0, [r7, #20]
    int32_t h = lv_obj_get_style_transform_height(obj, part);
 8004d34:	6839      	ldr	r1, [r7, #0]
 8004d36:	6878      	ldr	r0, [r7, #4]
 8004d38:	f7ff f989 	bl	800404e <lv_obj_get_style_transform_height>
 8004d3c:	6138      	str	r0, [r7, #16]
    int32_t wh = LV_MAX(w, h);
 8004d3e:	693a      	ldr	r2, [r7, #16]
 8004d40:	697b      	ldr	r3, [r7, #20]
 8004d42:	4293      	cmp	r3, r2
 8004d44:	bfb8      	it	lt
 8004d46:	4613      	movlt	r3, r2
 8004d48:	60fb      	str	r3, [r7, #12]
    if(wh > 0) s += wh;
 8004d4a:	68fb      	ldr	r3, [r7, #12]
 8004d4c:	2b00      	cmp	r3, #0
 8004d4e:	dd03      	ble.n	8004d58 <lv_obj_calculate_ext_draw_size+0xf8>
 8004d50:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8004d52:	68fb      	ldr	r3, [r7, #12]
 8004d54:	4413      	add	r3, r2
 8004d56:	637b      	str	r3, [r7, #52]	@ 0x34

    return s;
 8004d58:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
 8004d5a:	4618      	mov	r0, r3
 8004d5c:	3738      	adds	r7, #56	@ 0x38
 8004d5e:	46bd      	mov	sp, r7
 8004d60:	bd80      	pop	{r7, pc}

08004d62 <lv_obj_refresh_ext_draw_size>:

void lv_obj_refresh_ext_draw_size(lv_obj_t * obj)
{
 8004d62:	b580      	push	{r7, lr}
 8004d64:	b084      	sub	sp, #16
 8004d66:	af00      	add	r7, sp, #0
 8004d68:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    int32_t s_old = _lv_obj_get_ext_draw_size(obj);
 8004d6a:	6878      	ldr	r0, [r7, #4]
 8004d6c:	f000 f828 	bl	8004dc0 <_lv_obj_get_ext_draw_size>
 8004d70:	60f8      	str	r0, [r7, #12]
    int32_t s_new = 0;
 8004d72:	2300      	movs	r3, #0
 8004d74:	60bb      	str	r3, [r7, #8]
    lv_obj_send_event(obj, LV_EVENT_REFR_EXT_DRAW_SIZE, &s_new);
 8004d76:	f107 0308 	add.w	r3, r7, #8
 8004d7a:	461a      	mov	r2, r3
 8004d7c:	2115      	movs	r1, #21
 8004d7e:	6878      	ldr	r0, [r7, #4]
 8004d80:	f000 f848 	bl	8004e14 <lv_obj_send_event>

    /*Store the result if the special attrs already allocated*/
    if(obj->spec_attr) {
 8004d84:	687b      	ldr	r3, [r7, #4]
 8004d86:	689b      	ldr	r3, [r3, #8]
 8004d88:	2b00      	cmp	r3, #0
 8004d8a:	d004      	beq.n	8004d96 <lv_obj_refresh_ext_draw_size+0x34>
        obj->spec_attr->ext_draw_size = s_new;
 8004d8c:	687b      	ldr	r3, [r7, #4]
 8004d8e:	689b      	ldr	r3, [r3, #8]
 8004d90:	68ba      	ldr	r2, [r7, #8]
 8004d92:	625a      	str	r2, [r3, #36]	@ 0x24
 8004d94:	e009      	b.n	8004daa <lv_obj_refresh_ext_draw_size+0x48>
    }
    /*Allocate spec. attrs. only if the result is not zero.
     *Zero is the default value if the spec. attr. are not defined.*/
    else if(s_new != 0) {
 8004d96:	68bb      	ldr	r3, [r7, #8]
 8004d98:	2b00      	cmp	r3, #0
 8004d9a:	d006      	beq.n	8004daa <lv_obj_refresh_ext_draw_size+0x48>
        lv_obj_allocate_spec_attr(obj);
 8004d9c:	6878      	ldr	r0, [r7, #4]
 8004d9e:	f7fe f81e 	bl	8002dde <lv_obj_allocate_spec_attr>
        obj->spec_attr->ext_draw_size = s_new;
 8004da2:	687b      	ldr	r3, [r7, #4]
 8004da4:	689b      	ldr	r3, [r3, #8]
 8004da6:	68ba      	ldr	r2, [r7, #8]
 8004da8:	625a      	str	r2, [r3, #36]	@ 0x24
    }

    if(s_new != s_old) lv_obj_invalidate(obj);
 8004daa:	68bb      	ldr	r3, [r7, #8]
 8004dac:	68fa      	ldr	r2, [r7, #12]
 8004dae:	429a      	cmp	r2, r3
 8004db0:	d002      	beq.n	8004db8 <lv_obj_refresh_ext_draw_size+0x56>
 8004db2:	6878      	ldr	r0, [r7, #4]
 8004db4:	f001 fc44 	bl	8006640 <lv_obj_invalidate>
}
 8004db8:	bf00      	nop
 8004dba:	3710      	adds	r7, #16
 8004dbc:	46bd      	mov	sp, r7
 8004dbe:	bd80      	pop	{r7, pc}

08004dc0 <_lv_obj_get_ext_draw_size>:

int32_t _lv_obj_get_ext_draw_size(const lv_obj_t * obj)
{
 8004dc0:	b480      	push	{r7}
 8004dc2:	b083      	sub	sp, #12
 8004dc4:	af00      	add	r7, sp, #0
 8004dc6:	6078      	str	r0, [r7, #4]
    if(obj->spec_attr) return obj->spec_attr->ext_draw_size;
 8004dc8:	687b      	ldr	r3, [r7, #4]
 8004dca:	689b      	ldr	r3, [r3, #8]
 8004dcc:	2b00      	cmp	r3, #0
 8004dce:	d003      	beq.n	8004dd8 <_lv_obj_get_ext_draw_size+0x18>
 8004dd0:	687b      	ldr	r3, [r7, #4]
 8004dd2:	689b      	ldr	r3, [r3, #8]
 8004dd4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8004dd6:	e000      	b.n	8004dda <_lv_obj_get_ext_draw_size+0x1a>
    else return 0;
 8004dd8:	2300      	movs	r3, #0
}
 8004dda:	4618      	mov	r0, r3
 8004ddc:	370c      	adds	r7, #12
 8004dde:	46bd      	mov	sp, r7
 8004de0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004de4:	4770      	bx	lr

08004de6 <_lv_obj_get_layer_type>:

lv_layer_type_t _lv_obj_get_layer_type(const lv_obj_t * obj)
{
 8004de6:	b480      	push	{r7}
 8004de8:	b083      	sub	sp, #12
 8004dea:	af00      	add	r7, sp, #0
 8004dec:	6078      	str	r0, [r7, #4]

    if(obj->spec_attr) return (lv_layer_type_t)obj->spec_attr->layer_type;
 8004dee:	687b      	ldr	r3, [r7, #4]
 8004df0:	689b      	ldr	r3, [r3, #8]
 8004df2:	2b00      	cmp	r3, #0
 8004df4:	d007      	beq.n	8004e06 <_lv_obj_get_layer_type+0x20>
 8004df6:	687b      	ldr	r3, [r7, #4]
 8004df8:	689b      	ldr	r3, [r3, #8]
 8004dfa:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 8004dfe:	f3c3 0381 	ubfx	r3, r3, #2, #2
 8004e02:	b2db      	uxtb	r3, r3
 8004e04:	e000      	b.n	8004e08 <_lv_obj_get_layer_type+0x22>
    else return LV_LAYER_TYPE_NONE;
 8004e06:	2300      	movs	r3, #0
}
 8004e08:	4618      	mov	r0, r3
 8004e0a:	370c      	adds	r7, #12
 8004e0c:	46bd      	mov	sp, r7
 8004e0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004e12:	4770      	bx	lr

08004e14 <lv_obj_send_event>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

lv_result_t lv_obj_send_event(lv_obj_t * obj, lv_event_code_t event_code, void * param)
{
 8004e14:	b580      	push	{r7, lr}
 8004e16:	b08c      	sub	sp, #48	@ 0x30
 8004e18:	af00      	add	r7, sp, #0
 8004e1a:	60f8      	str	r0, [r7, #12]
 8004e1c:	460b      	mov	r3, r1
 8004e1e:	607a      	str	r2, [r7, #4]
 8004e20:	817b      	strh	r3, [r7, #10]
    if(obj == NULL) return LV_RESULT_OK;
 8004e22:	68fb      	ldr	r3, [r7, #12]
 8004e24:	2b00      	cmp	r3, #0
 8004e26:	d101      	bne.n	8004e2c <lv_obj_send_event+0x18>
 8004e28:	2301      	movs	r3, #1
 8004e2a:	e02f      	b.n	8004e8c <lv_obj_send_event+0x78>

    LV_ASSERT_OBJ(obj, MY_CLASS);

    lv_event_t e;
    e.current_target = obj;
 8004e2c:	68fb      	ldr	r3, [r7, #12]
 8004e2e:	613b      	str	r3, [r7, #16]
    e.original_target = obj;
 8004e30:	68fb      	ldr	r3, [r7, #12]
 8004e32:	617b      	str	r3, [r7, #20]
    e.code = event_code;
 8004e34:	897b      	ldrh	r3, [r7, #10]
 8004e36:	833b      	strh	r3, [r7, #24]
    e.user_data = NULL;
 8004e38:	2300      	movs	r3, #0
 8004e3a:	61fb      	str	r3, [r7, #28]
    e.param = param;
 8004e3c:	687b      	ldr	r3, [r7, #4]
 8004e3e:	623b      	str	r3, [r7, #32]
    e.deleted = 0;
 8004e40:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8004e44:	f36f 0300 	bfc	r3, #0, #1
 8004e48:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
    e.stop_bubbling = 0;
 8004e4c:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8004e50:	f36f 0382 	bfc	r3, #2, #1
 8004e54:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
    e.stop_processing = 0;
 8004e58:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8004e5c:	f36f 0341 	bfc	r3, #1, #1
 8004e60:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28

    _lv_event_push(&e);
 8004e64:	f107 0310 	add.w	r3, r7, #16
 8004e68:	4618      	mov	r0, r3
 8004e6a:	f01d fc21 	bl	80226b0 <_lv_event_push>

    /*Send the event*/
    lv_result_t res = event_send_core(&e);
 8004e6e:	f107 0310 	add.w	r3, r7, #16
 8004e72:	4618      	mov	r0, r3
 8004e74:	f000 f8f2 	bl	800505c <event_send_core>
 8004e78:	4603      	mov	r3, r0
 8004e7a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

    /*Remove this element from the list*/
    _lv_event_pop(&e);
 8004e7e:	f107 0310 	add.w	r3, r7, #16
 8004e82:	4618      	mov	r0, r3
 8004e84:	f01d fc28 	bl	80226d8 <_lv_event_pop>

    return res;
 8004e88:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
 8004e8c:	4618      	mov	r0, r3
 8004e8e:	3730      	adds	r7, #48	@ 0x30
 8004e90:	46bd      	mov	sp, r7
 8004e92:	bd80      	pop	{r7, pc}

08004e94 <lv_obj_event_base>:

lv_result_t lv_obj_event_base(const lv_obj_class_t * class_p, lv_event_t * e)
{
 8004e94:	b580      	push	{r7, lr}
 8004e96:	b084      	sub	sp, #16
 8004e98:	af00      	add	r7, sp, #0
 8004e9a:	6078      	str	r0, [r7, #4]
 8004e9c:	6039      	str	r1, [r7, #0]
    const lv_obj_class_t * base;
    if(class_p == NULL) base = ((lv_obj_t *)e->current_target)->class_p;
 8004e9e:	687b      	ldr	r3, [r7, #4]
 8004ea0:	2b00      	cmp	r3, #0
 8004ea2:	d104      	bne.n	8004eae <lv_obj_event_base+0x1a>
 8004ea4:	683b      	ldr	r3, [r7, #0]
 8004ea6:	681b      	ldr	r3, [r3, #0]
 8004ea8:	681b      	ldr	r3, [r3, #0]
 8004eaa:	60fb      	str	r3, [r7, #12]
 8004eac:	e006      	b.n	8004ebc <lv_obj_event_base+0x28>
    else base = class_p->base_class;
 8004eae:	687b      	ldr	r3, [r7, #4]
 8004eb0:	681b      	ldr	r3, [r3, #0]
 8004eb2:	60fb      	str	r3, [r7, #12]

    /*Find a base in which call the ancestor's event handler_cb if set*/
    while(base && base->event_cb == NULL) base = base->base_class;
 8004eb4:	e002      	b.n	8004ebc <lv_obj_event_base+0x28>
 8004eb6:	68fb      	ldr	r3, [r7, #12]
 8004eb8:	681b      	ldr	r3, [r3, #0]
 8004eba:	60fb      	str	r3, [r7, #12]
 8004ebc:	68fb      	ldr	r3, [r7, #12]
 8004ebe:	2b00      	cmp	r3, #0
 8004ec0:	d003      	beq.n	8004eca <lv_obj_event_base+0x36>
 8004ec2:	68fb      	ldr	r3, [r7, #12]
 8004ec4:	68db      	ldr	r3, [r3, #12]
 8004ec6:	2b00      	cmp	r3, #0
 8004ec8:	d0f5      	beq.n	8004eb6 <lv_obj_event_base+0x22>

    if(base == NULL) return LV_RESULT_OK;
 8004eca:	68fb      	ldr	r3, [r7, #12]
 8004ecc:	2b00      	cmp	r3, #0
 8004ece:	d101      	bne.n	8004ed4 <lv_obj_event_base+0x40>
 8004ed0:	2301      	movs	r3, #1
 8004ed2:	e019      	b.n	8004f08 <lv_obj_event_base+0x74>
    if(base->event_cb == NULL) return LV_RESULT_OK;
 8004ed4:	68fb      	ldr	r3, [r7, #12]
 8004ed6:	68db      	ldr	r3, [r3, #12]
 8004ed8:	2b00      	cmp	r3, #0
 8004eda:	d101      	bne.n	8004ee0 <lv_obj_event_base+0x4c>
 8004edc:	2301      	movs	r3, #1
 8004ede:	e013      	b.n	8004f08 <lv_obj_event_base+0x74>

    /*Call the actual event callback*/
    e->user_data = NULL;
 8004ee0:	683b      	ldr	r3, [r7, #0]
 8004ee2:	2200      	movs	r2, #0
 8004ee4:	60da      	str	r2, [r3, #12]
    base->event_cb(base, e);
 8004ee6:	68fb      	ldr	r3, [r7, #12]
 8004ee8:	68db      	ldr	r3, [r3, #12]
 8004eea:	6839      	ldr	r1, [r7, #0]
 8004eec:	68f8      	ldr	r0, [r7, #12]
 8004eee:	4798      	blx	r3

    lv_result_t res = LV_RESULT_OK;
 8004ef0:	2301      	movs	r3, #1
 8004ef2:	72fb      	strb	r3, [r7, #11]
    /*Stop if the object is deleted*/
    if(e->deleted) res = LV_RESULT_INVALID;
 8004ef4:	683b      	ldr	r3, [r7, #0]
 8004ef6:	7e1b      	ldrb	r3, [r3, #24]
 8004ef8:	f003 0301 	and.w	r3, r3, #1
 8004efc:	b2db      	uxtb	r3, r3
 8004efe:	2b00      	cmp	r3, #0
 8004f00:	d001      	beq.n	8004f06 <lv_obj_event_base+0x72>
 8004f02:	2300      	movs	r3, #0
 8004f04:	72fb      	strb	r3, [r7, #11]

    return res;
 8004f06:	7afb      	ldrb	r3, [r7, #11]
}
 8004f08:	4618      	mov	r0, r3
 8004f0a:	3710      	adds	r7, #16
 8004f0c:	46bd      	mov	sp, r7
 8004f0e:	bd80      	pop	{r7, pc}

08004f10 <lv_event_get_indev>:
{
    return lv_event_get_target(e);
}

lv_indev_t * lv_event_get_indev(lv_event_t * e)
{
 8004f10:	b580      	push	{r7, lr}
 8004f12:	b082      	sub	sp, #8
 8004f14:	af00      	add	r7, sp, #0
 8004f16:	6078      	str	r0, [r7, #4]

    if(e->code == LV_EVENT_PRESSED ||
 8004f18:	687b      	ldr	r3, [r7, #4]
 8004f1a:	891b      	ldrh	r3, [r3, #8]
 8004f1c:	2b01      	cmp	r3, #1
 8004f1e:	d03b      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_PRESSING ||
 8004f20:	687b      	ldr	r3, [r7, #4]
 8004f22:	891b      	ldrh	r3, [r3, #8]
    if(e->code == LV_EVENT_PRESSED ||
 8004f24:	2b02      	cmp	r3, #2
 8004f26:	d037      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_PRESS_LOST ||
 8004f28:	687b      	ldr	r3, [r7, #4]
 8004f2a:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_PRESSING ||
 8004f2c:	2b03      	cmp	r3, #3
 8004f2e:	d033      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_SHORT_CLICKED ||
 8004f30:	687b      	ldr	r3, [r7, #4]
 8004f32:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_PRESS_LOST ||
 8004f34:	2b04      	cmp	r3, #4
 8004f36:	d02f      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_LONG_PRESSED ||
 8004f38:	687b      	ldr	r3, [r7, #4]
 8004f3a:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_SHORT_CLICKED ||
 8004f3c:	2b05      	cmp	r3, #5
 8004f3e:	d02b      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_LONG_PRESSED_REPEAT ||
 8004f40:	687b      	ldr	r3, [r7, #4]
 8004f42:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_LONG_PRESSED ||
 8004f44:	2b06      	cmp	r3, #6
 8004f46:	d027      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_CLICKED ||
 8004f48:	687b      	ldr	r3, [r7, #4]
 8004f4a:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_LONG_PRESSED_REPEAT ||
 8004f4c:	2b07      	cmp	r3, #7
 8004f4e:	d023      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_RELEASED ||
 8004f50:	687b      	ldr	r3, [r7, #4]
 8004f52:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_CLICKED ||
 8004f54:	2b08      	cmp	r3, #8
 8004f56:	d01f      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_SCROLL_BEGIN ||
 8004f58:	687b      	ldr	r3, [r7, #4]
 8004f5a:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_RELEASED ||
 8004f5c:	2b09      	cmp	r3, #9
 8004f5e:	d01b      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_SCROLL_END ||
 8004f60:	687b      	ldr	r3, [r7, #4]
 8004f62:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_SCROLL_BEGIN ||
 8004f64:	2b0b      	cmp	r3, #11
 8004f66:	d017      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_SCROLL ||
 8004f68:	687b      	ldr	r3, [r7, #4]
 8004f6a:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_SCROLL_END ||
 8004f6c:	2b0c      	cmp	r3, #12
 8004f6e:	d013      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_GESTURE ||
 8004f70:	687b      	ldr	r3, [r7, #4]
 8004f72:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_SCROLL ||
 8004f74:	2b0d      	cmp	r3, #13
 8004f76:	d00f      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_KEY ||
 8004f78:	687b      	ldr	r3, [r7, #4]
 8004f7a:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_GESTURE ||
 8004f7c:	2b0e      	cmp	r3, #14
 8004f7e:	d00b      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_FOCUSED ||
 8004f80:	687b      	ldr	r3, [r7, #4]
 8004f82:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_KEY ||
 8004f84:	2b0f      	cmp	r3, #15
 8004f86:	d007      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_DEFOCUSED ||
 8004f88:	687b      	ldr	r3, [r7, #4]
 8004f8a:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_FOCUSED ||
 8004f8c:	2b10      	cmp	r3, #16
 8004f8e:	d003      	beq.n	8004f98 <lv_event_get_indev+0x88>
       e->code == LV_EVENT_LEAVE) {
 8004f90:	687b      	ldr	r3, [r7, #4]
 8004f92:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_DEFOCUSED ||
 8004f94:	2b11      	cmp	r3, #17
 8004f96:	d104      	bne.n	8004fa2 <lv_event_get_indev+0x92>
        return lv_event_get_param(e);
 8004f98:	6878      	ldr	r0, [r7, #4]
 8004f9a:	f01d fc68 	bl	802286e <lv_event_get_param>
 8004f9e:	4603      	mov	r3, r0
 8004fa0:	e000      	b.n	8004fa4 <lv_event_get_indev+0x94>
    }
    else {
        LV_LOG_WARN("Not interpreted with this event code");
        return NULL;
 8004fa2:	2300      	movs	r3, #0
    }
}
 8004fa4:	4618      	mov	r0, r3
 8004fa6:	3708      	adds	r7, #8
 8004fa8:	46bd      	mov	sp, r7
 8004faa:	bd80      	pop	{r7, pc}

08004fac <lv_event_get_layer>:

lv_layer_t * lv_event_get_layer(lv_event_t * e)
{
 8004fac:	b580      	push	{r7, lr}
 8004fae:	b082      	sub	sp, #8
 8004fb0:	af00      	add	r7, sp, #0
 8004fb2:	6078      	str	r0, [r7, #4]
    if(e->code == LV_EVENT_DRAW_MAIN ||
 8004fb4:	687b      	ldr	r3, [r7, #4]
 8004fb6:	891b      	ldrh	r3, [r3, #8]
 8004fb8:	2b17      	cmp	r3, #23
 8004fba:	d013      	beq.n	8004fe4 <lv_event_get_layer+0x38>
       e->code == LV_EVENT_DRAW_MAIN_BEGIN ||
 8004fbc:	687b      	ldr	r3, [r7, #4]
 8004fbe:	891b      	ldrh	r3, [r3, #8]
    if(e->code == LV_EVENT_DRAW_MAIN ||
 8004fc0:	2b16      	cmp	r3, #22
 8004fc2:	d00f      	beq.n	8004fe4 <lv_event_get_layer+0x38>
       e->code == LV_EVENT_DRAW_MAIN_END ||
 8004fc4:	687b      	ldr	r3, [r7, #4]
 8004fc6:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_DRAW_MAIN_BEGIN ||
 8004fc8:	2b18      	cmp	r3, #24
 8004fca:	d00b      	beq.n	8004fe4 <lv_event_get_layer+0x38>
       e->code == LV_EVENT_DRAW_POST ||
 8004fcc:	687b      	ldr	r3, [r7, #4]
 8004fce:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_DRAW_MAIN_END ||
 8004fd0:	2b1a      	cmp	r3, #26
 8004fd2:	d007      	beq.n	8004fe4 <lv_event_get_layer+0x38>
       e->code == LV_EVENT_DRAW_POST_BEGIN ||
 8004fd4:	687b      	ldr	r3, [r7, #4]
 8004fd6:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_DRAW_POST ||
 8004fd8:	2b19      	cmp	r3, #25
 8004fda:	d003      	beq.n	8004fe4 <lv_event_get_layer+0x38>
       e->code == LV_EVENT_DRAW_POST_END) {
 8004fdc:	687b      	ldr	r3, [r7, #4]
 8004fde:	891b      	ldrh	r3, [r3, #8]
       e->code == LV_EVENT_DRAW_POST_BEGIN ||
 8004fe0:	2b1b      	cmp	r3, #27
 8004fe2:	d104      	bne.n	8004fee <lv_event_get_layer+0x42>
        return lv_event_get_param(e);
 8004fe4:	6878      	ldr	r0, [r7, #4]
 8004fe6:	f01d fc42 	bl	802286e <lv_event_get_param>
 8004fea:	4603      	mov	r3, r0
 8004fec:	e000      	b.n	8004ff0 <lv_event_get_layer+0x44>
    }
    else {
        LV_LOG_WARN("Not interpreted with this event code");
        return NULL;
 8004fee:	2300      	movs	r3, #0
    }
}
 8004ff0:	4618      	mov	r0, r3
 8004ff2:	3708      	adds	r7, #8
 8004ff4:	46bd      	mov	sp, r7
 8004ff6:	bd80      	pop	{r7, pc}

08004ff8 <lv_event_get_key>:
        return NULL;
    }
}

uint32_t lv_event_get_key(lv_event_t * e)
{
 8004ff8:	b580      	push	{r7, lr}
 8004ffa:	b084      	sub	sp, #16
 8004ffc:	af00      	add	r7, sp, #0
 8004ffe:	6078      	str	r0, [r7, #4]
    if(e->code == LV_EVENT_KEY) {
 8005000:	687b      	ldr	r3, [r7, #4]
 8005002:	891b      	ldrh	r3, [r3, #8]
 8005004:	2b0e      	cmp	r3, #14
 8005006:	d10b      	bne.n	8005020 <lv_event_get_key+0x28>
        uint32_t * k = lv_event_get_param(e);
 8005008:	6878      	ldr	r0, [r7, #4]
 800500a:	f01d fc30 	bl	802286e <lv_event_get_param>
 800500e:	60f8      	str	r0, [r7, #12]
        if(k) return *k;
 8005010:	68fb      	ldr	r3, [r7, #12]
 8005012:	2b00      	cmp	r3, #0
 8005014:	d002      	beq.n	800501c <lv_event_get_key+0x24>
 8005016:	68fb      	ldr	r3, [r7, #12]
 8005018:	681b      	ldr	r3, [r3, #0]
 800501a:	e002      	b.n	8005022 <lv_event_get_key+0x2a>
        else return 0;
 800501c:	2300      	movs	r3, #0
 800501e:	e000      	b.n	8005022 <lv_event_get_key+0x2a>
    }
    else {
        LV_LOG_WARN("Not interpreted with this event code");
        return 0;
 8005020:	2300      	movs	r3, #0
    }
}
 8005022:	4618      	mov	r0, r3
 8005024:	3710      	adds	r7, #16
 8005026:	46bd      	mov	sp, r7
 8005028:	bd80      	pop	{r7, pc}

0800502a <lv_event_set_ext_draw_size>:
        return NULL;
    }
}

void lv_event_set_ext_draw_size(lv_event_t * e, int32_t size)
{
 800502a:	b580      	push	{r7, lr}
 800502c:	b084      	sub	sp, #16
 800502e:	af00      	add	r7, sp, #0
 8005030:	6078      	str	r0, [r7, #4]
 8005032:	6039      	str	r1, [r7, #0]
    if(e->code == LV_EVENT_REFR_EXT_DRAW_SIZE) {
 8005034:	687b      	ldr	r3, [r7, #4]
 8005036:	891b      	ldrh	r3, [r3, #8]
 8005038:	2b15      	cmp	r3, #21
 800503a:	d10b      	bne.n	8005054 <lv_event_set_ext_draw_size+0x2a>
        int32_t * cur_size = lv_event_get_param(e);
 800503c:	6878      	ldr	r0, [r7, #4]
 800503e:	f01d fc16 	bl	802286e <lv_event_get_param>
 8005042:	60f8      	str	r0, [r7, #12]
        *cur_size = LV_MAX(*cur_size, size);
 8005044:	68fb      	ldr	r3, [r7, #12]
 8005046:	681a      	ldr	r2, [r3, #0]
 8005048:	683b      	ldr	r3, [r7, #0]
 800504a:	429a      	cmp	r2, r3
 800504c:	bfb8      	it	lt
 800504e:	461a      	movlt	r2, r3
 8005050:	68fb      	ldr	r3, [r7, #12]
 8005052:	601a      	str	r2, [r3, #0]
    }
    else {
        LV_LOG_WARN("Not interpreted with this event code");
    }
}
 8005054:	bf00      	nop
 8005056:	3710      	adds	r7, #16
 8005058:	46bd      	mov	sp, r7
 800505a:	bd80      	pop	{r7, pc}

0800505c <event_send_core>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static lv_result_t event_send_core(lv_event_t * e)
{
 800505c:	b580      	push	{r7, lr}
 800505e:	b088      	sub	sp, #32
 8005060:	af00      	add	r7, sp, #0
 8005062:	6078      	str	r0, [r7, #4]
    LV_TRACE_EVENT("Sending event %d to %p with %p param", e->code, (void *)e->original_target, e->param);

    /*Call the input device's feedback callback if set*/
    lv_indev_t * indev_act = lv_indev_active();
 8005064:	f017 fec2 	bl	801cdec <lv_indev_active>
 8005068:	61b8      	str	r0, [r7, #24]
    if(indev_act) {
 800506a:	69bb      	ldr	r3, [r7, #24]
 800506c:	2b00      	cmp	r3, #0
 800506e:	d011      	beq.n	8005094 <event_send_core+0x38>
        if(e->stop_processing) return LV_RESULT_OK;
 8005070:	687b      	ldr	r3, [r7, #4]
 8005072:	7e1b      	ldrb	r3, [r3, #24]
 8005074:	f003 0302 	and.w	r3, r3, #2
 8005078:	b2db      	uxtb	r3, r3
 800507a:	2b00      	cmp	r3, #0
 800507c:	d001      	beq.n	8005082 <event_send_core+0x26>
 800507e:	2301      	movs	r3, #1
 8005080:	e057      	b.n	8005132 <event_send_core+0xd6>
        if(e->deleted) return LV_RESULT_INVALID;
 8005082:	687b      	ldr	r3, [r7, #4]
 8005084:	7e1b      	ldrb	r3, [r3, #24]
 8005086:	f003 0301 	and.w	r3, r3, #1
 800508a:	b2db      	uxtb	r3, r3
 800508c:	2b00      	cmp	r3, #0
 800508e:	d001      	beq.n	8005094 <event_send_core+0x38>
 8005090:	2300      	movs	r3, #0
 8005092:	e04e      	b.n	8005132 <event_send_core+0xd6>
    }

    lv_obj_t * target = e->current_target;
 8005094:	687b      	ldr	r3, [r7, #4]
 8005096:	681b      	ldr	r3, [r3, #0]
 8005098:	617b      	str	r3, [r7, #20]
    lv_result_t res = LV_RESULT_OK;
 800509a:	2301      	movs	r3, #1
 800509c:	77fb      	strb	r3, [r7, #31]
    lv_event_list_t * list = target->spec_attr ?  &target->spec_attr->event_list : NULL;
 800509e:	697b      	ldr	r3, [r7, #20]
 80050a0:	689b      	ldr	r3, [r3, #8]
 80050a2:	2b00      	cmp	r3, #0
 80050a4:	d003      	beq.n	80050ae <event_send_core+0x52>
 80050a6:	697b      	ldr	r3, [r7, #20]
 80050a8:	689b      	ldr	r3, [r3, #8]
 80050aa:	3308      	adds	r3, #8
 80050ac:	e000      	b.n	80050b0 <event_send_core+0x54>
 80050ae:	2300      	movs	r3, #0
 80050b0:	613b      	str	r3, [r7, #16]

    res = lv_event_send(list, e, true);
 80050b2:	2201      	movs	r2, #1
 80050b4:	6879      	ldr	r1, [r7, #4]
 80050b6:	6938      	ldr	r0, [r7, #16]
 80050b8:	f01d fb1e 	bl	80226f8 <lv_event_send>
 80050bc:	4603      	mov	r3, r0
 80050be:	77fb      	strb	r3, [r7, #31]
    if(res != LV_RESULT_OK) return res;
 80050c0:	7ffb      	ldrb	r3, [r7, #31]
 80050c2:	2b01      	cmp	r3, #1
 80050c4:	d001      	beq.n	80050ca <event_send_core+0x6e>
 80050c6:	7ffb      	ldrb	r3, [r7, #31]
 80050c8:	e033      	b.n	8005132 <event_send_core+0xd6>

    res = lv_obj_event_base(NULL, e);
 80050ca:	6879      	ldr	r1, [r7, #4]
 80050cc:	2000      	movs	r0, #0
 80050ce:	f7ff fee1 	bl	8004e94 <lv_obj_event_base>
 80050d2:	4603      	mov	r3, r0
 80050d4:	77fb      	strb	r3, [r7, #31]
    if(res != LV_RESULT_OK) return res;
 80050d6:	7ffb      	ldrb	r3, [r7, #31]
 80050d8:	2b01      	cmp	r3, #1
 80050da:	d001      	beq.n	80050e0 <event_send_core+0x84>
 80050dc:	7ffb      	ldrb	r3, [r7, #31]
 80050de:	e028      	b.n	8005132 <event_send_core+0xd6>

    res = lv_event_send(list, e, false);
 80050e0:	2200      	movs	r2, #0
 80050e2:	6879      	ldr	r1, [r7, #4]
 80050e4:	6938      	ldr	r0, [r7, #16]
 80050e6:	f01d fb07 	bl	80226f8 <lv_event_send>
 80050ea:	4603      	mov	r3, r0
 80050ec:	77fb      	strb	r3, [r7, #31]
    if(res != LV_RESULT_OK) return res;
 80050ee:	7ffb      	ldrb	r3, [r7, #31]
 80050f0:	2b01      	cmp	r3, #1
 80050f2:	d001      	beq.n	80050f8 <event_send_core+0x9c>
 80050f4:	7ffb      	ldrb	r3, [r7, #31]
 80050f6:	e01c      	b.n	8005132 <event_send_core+0xd6>

    lv_obj_t * parent = lv_obj_get_parent(e->current_target);
 80050f8:	687b      	ldr	r3, [r7, #4]
 80050fa:	681b      	ldr	r3, [r3, #0]
 80050fc:	4618      	mov	r0, r3
 80050fe:	f005 fe99 	bl	800ae34 <lv_obj_get_parent>
 8005102:	60f8      	str	r0, [r7, #12]
    if(parent && event_is_bubbled(e)) {
 8005104:	68fb      	ldr	r3, [r7, #12]
 8005106:	2b00      	cmp	r3, #0
 8005108:	d012      	beq.n	8005130 <event_send_core+0xd4>
 800510a:	6878      	ldr	r0, [r7, #4]
 800510c:	f000 f816 	bl	800513c <event_is_bubbled>
 8005110:	4603      	mov	r3, r0
 8005112:	2b00      	cmp	r3, #0
 8005114:	d00c      	beq.n	8005130 <event_send_core+0xd4>
        e->current_target = parent;
 8005116:	687b      	ldr	r3, [r7, #4]
 8005118:	68fa      	ldr	r2, [r7, #12]
 800511a:	601a      	str	r2, [r3, #0]
        res = event_send_core(e);
 800511c:	6878      	ldr	r0, [r7, #4]
 800511e:	f7ff ff9d 	bl	800505c <event_send_core>
 8005122:	4603      	mov	r3, r0
 8005124:	77fb      	strb	r3, [r7, #31]
        if(res != LV_RESULT_OK) return res;
 8005126:	7ffb      	ldrb	r3, [r7, #31]
 8005128:	2b01      	cmp	r3, #1
 800512a:	d001      	beq.n	8005130 <event_send_core+0xd4>
 800512c:	7ffb      	ldrb	r3, [r7, #31]
 800512e:	e000      	b.n	8005132 <event_send_core+0xd6>
    }

    return res;
 8005130:	7ffb      	ldrb	r3, [r7, #31]
}
 8005132:	4618      	mov	r0, r3
 8005134:	3720      	adds	r7, #32
 8005136:	46bd      	mov	sp, r7
 8005138:	bd80      	pop	{r7, pc}
	...

0800513c <event_is_bubbled>:

static bool event_is_bubbled(lv_event_t * e)
{
 800513c:	b580      	push	{r7, lr}
 800513e:	b082      	sub	sp, #8
 8005140:	af00      	add	r7, sp, #0
 8005142:	6078      	str	r0, [r7, #4]
    if(e->stop_bubbling) return false;
 8005144:	687b      	ldr	r3, [r7, #4]
 8005146:	7e1b      	ldrb	r3, [r3, #24]
 8005148:	f003 0304 	and.w	r3, r3, #4
 800514c:	b2db      	uxtb	r3, r3
 800514e:	2b00      	cmp	r3, #0
 8005150:	d001      	beq.n	8005156 <event_is_bubbled+0x1a>
 8005152:	2300      	movs	r3, #0
 8005154:	e02f      	b.n	80051b6 <event_is_bubbled+0x7a>

    /*Event codes that always bubble*/
    switch(e->code) {
 8005156:	687b      	ldr	r3, [r7, #4]
 8005158:	891b      	ldrh	r3, [r3, #8]
 800515a:	3b25      	subs	r3, #37	@ 0x25
 800515c:	2b01      	cmp	r3, #1
 800515e:	d801      	bhi.n	8005164 <event_is_bubbled+0x28>
        case LV_EVENT_CHILD_CREATED:
        case LV_EVENT_CHILD_DELETED:
            return true;
 8005160:	2301      	movs	r3, #1
 8005162:	e028      	b.n	80051b6 <event_is_bubbled+0x7a>
        default:
            break;
 8005164:	bf00      	nop
    }

    /*Check other codes only if bubbling is enabled*/
    if(lv_obj_has_flag(e->current_target, LV_OBJ_FLAG_EVENT_BUBBLE) == false) return false;
 8005166:	687b      	ldr	r3, [r7, #4]
 8005168:	681b      	ldr	r3, [r3, #0]
 800516a:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 800516e:	4618      	mov	r0, r3
 8005170:	f7fd fded 	bl	8002d4e <lv_obj_has_flag>
 8005174:	4603      	mov	r3, r0
 8005176:	f083 0301 	eor.w	r3, r3, #1
 800517a:	b2db      	uxtb	r3, r3
 800517c:	2b00      	cmp	r3, #0
 800517e:	d001      	beq.n	8005184 <event_is_bubbled+0x48>
 8005180:	2300      	movs	r3, #0
 8005182:	e018      	b.n	80051b6 <event_is_bubbled+0x7a>

    switch(e->code) {
 8005184:	687b      	ldr	r3, [r7, #4]
 8005186:	891b      	ldrh	r3, [r3, #8]
 8005188:	3b12      	subs	r3, #18
 800518a:	2b1c      	cmp	r3, #28
 800518c:	bf8c      	ite	hi
 800518e:	2201      	movhi	r2, #1
 8005190:	2200      	movls	r2, #0
 8005192:	b2d2      	uxtb	r2, r2
 8005194:	2a00      	cmp	r2, #0
 8005196:	d10d      	bne.n	80051b4 <event_is_bubbled+0x78>
 8005198:	4a09      	ldr	r2, [pc, #36]	@ (80051c0 <event_is_bubbled+0x84>)
 800519a:	fa22 f303 	lsr.w	r3, r2, r3
 800519e:	f003 0301 	and.w	r3, r3, #1
 80051a2:	2b00      	cmp	r3, #0
 80051a4:	bf14      	ite	ne
 80051a6:	2301      	movne	r3, #1
 80051a8:	2300      	moveq	r3, #0
 80051aa:	b2db      	uxtb	r3, r3
 80051ac:	2b00      	cmp	r3, #0
 80051ae:	d001      	beq.n	80051b4 <event_is_bubbled+0x78>
        case LV_EVENT_CHILD_DELETED:
        case LV_EVENT_CHILD_CHANGED:
        case LV_EVENT_SIZE_CHANGED:
        case LV_EVENT_STYLE_CHANGED:
        case LV_EVENT_GET_SELF_SIZE:
            return false;
 80051b0:	2300      	movs	r3, #0
 80051b2:	e000      	b.n	80051b6 <event_is_bubbled+0x7a>
        default:
            return true;
 80051b4:	2301      	movs	r3, #1
    }
}
 80051b6:	4618      	mov	r0, r3
 80051b8:	3708      	adds	r7, #8
 80051ba:	46bd      	mov	sp, r7
 80051bc:	bd80      	pop	{r7, pc}
 80051be:	bf00      	nop
 80051c0:	161e27fd 	.word	0x161e27fd

080051c4 <lv_area_copy>:
{
 80051c4:	b480      	push	{r7}
 80051c6:	b083      	sub	sp, #12
 80051c8:	af00      	add	r7, sp, #0
 80051ca:	6078      	str	r0, [r7, #4]
 80051cc:	6039      	str	r1, [r7, #0]
    dest->x1 = src->x1;
 80051ce:	683b      	ldr	r3, [r7, #0]
 80051d0:	681a      	ldr	r2, [r3, #0]
 80051d2:	687b      	ldr	r3, [r7, #4]
 80051d4:	601a      	str	r2, [r3, #0]
    dest->y1 = src->y1;
 80051d6:	683b      	ldr	r3, [r7, #0]
 80051d8:	685a      	ldr	r2, [r3, #4]
 80051da:	687b      	ldr	r3, [r7, #4]
 80051dc:	605a      	str	r2, [r3, #4]
    dest->x2 = src->x2;
 80051de:	683b      	ldr	r3, [r7, #0]
 80051e0:	689a      	ldr	r2, [r3, #8]
 80051e2:	687b      	ldr	r3, [r7, #4]
 80051e4:	609a      	str	r2, [r3, #8]
    dest->y2 = src->y2;
 80051e6:	683b      	ldr	r3, [r7, #0]
 80051e8:	68da      	ldr	r2, [r3, #12]
 80051ea:	687b      	ldr	r3, [r7, #4]
 80051ec:	60da      	str	r2, [r3, #12]
}
 80051ee:	bf00      	nop
 80051f0:	370c      	adds	r7, #12
 80051f2:	46bd      	mov	sp, r7
 80051f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80051f8:	4770      	bx	lr

080051fa <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline int32_t lv_area_get_width(const lv_area_t * area_p)
{
 80051fa:	b480      	push	{r7}
 80051fc:	b083      	sub	sp, #12
 80051fe:	af00      	add	r7, sp, #0
 8005200:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 8005202:	687b      	ldr	r3, [r7, #4]
 8005204:	689a      	ldr	r2, [r3, #8]
 8005206:	687b      	ldr	r3, [r7, #4]
 8005208:	681b      	ldr	r3, [r3, #0]
 800520a:	1ad3      	subs	r3, r2, r3
 800520c:	3301      	adds	r3, #1
}
 800520e:	4618      	mov	r0, r3
 8005210:	370c      	adds	r7, #12
 8005212:	46bd      	mov	sp, r7
 8005214:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005218:	4770      	bx	lr

0800521a <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline int32_t lv_area_get_height(const lv_area_t * area_p)
{
 800521a:	b480      	push	{r7}
 800521c:	b083      	sub	sp, #12
 800521e:	af00      	add	r7, sp, #0
 8005220:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 8005222:	687b      	ldr	r3, [r7, #4]
 8005224:	68da      	ldr	r2, [r3, #12]
 8005226:	687b      	ldr	r3, [r7, #4]
 8005228:	685b      	ldr	r3, [r3, #4]
 800522a:	1ad3      	subs	r3, r2, r3
 800522c:	3301      	adds	r3, #1
}
 800522e:	4618      	mov	r0, r3
 8005230:	370c      	adds	r7, #12
 8005232:	46bd      	mov	sp, r7
 8005234:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005238:	4770      	bx	lr

0800523a <lv_obj_get_style_width>:
{
 800523a:	b580      	push	{r7, lr}
 800523c:	b084      	sub	sp, #16
 800523e:	af00      	add	r7, sp, #0
 8005240:	6078      	str	r0, [r7, #4]
 8005242:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_WIDTH);
 8005244:	2201      	movs	r2, #1
 8005246:	6839      	ldr	r1, [r7, #0]
 8005248:	6878      	ldr	r0, [r7, #4]
 800524a:	f004 fa6d 	bl	8009728 <lv_obj_get_style_prop>
 800524e:	4603      	mov	r3, r0
 8005250:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8005252:	68fb      	ldr	r3, [r7, #12]
}
 8005254:	4618      	mov	r0, r3
 8005256:	3710      	adds	r7, #16
 8005258:	46bd      	mov	sp, r7
 800525a:	bd80      	pop	{r7, pc}

0800525c <lv_obj_get_style_min_width>:
{
 800525c:	b580      	push	{r7, lr}
 800525e:	b084      	sub	sp, #16
 8005260:	af00      	add	r7, sp, #0
 8005262:	6078      	str	r0, [r7, #4]
 8005264:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MIN_WIDTH);
 8005266:	2204      	movs	r2, #4
 8005268:	6839      	ldr	r1, [r7, #0]
 800526a:	6878      	ldr	r0, [r7, #4]
 800526c:	f004 fa5c 	bl	8009728 <lv_obj_get_style_prop>
 8005270:	4603      	mov	r3, r0
 8005272:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8005274:	68fb      	ldr	r3, [r7, #12]
}
 8005276:	4618      	mov	r0, r3
 8005278:	3710      	adds	r7, #16
 800527a:	46bd      	mov	sp, r7
 800527c:	bd80      	pop	{r7, pc}

0800527e <lv_obj_get_style_max_width>:
{
 800527e:	b580      	push	{r7, lr}
 8005280:	b084      	sub	sp, #16
 8005282:	af00      	add	r7, sp, #0
 8005284:	6078      	str	r0, [r7, #4]
 8005286:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MAX_WIDTH);
 8005288:	2205      	movs	r2, #5
 800528a:	6839      	ldr	r1, [r7, #0]
 800528c:	6878      	ldr	r0, [r7, #4]
 800528e:	f004 fa4b 	bl	8009728 <lv_obj_get_style_prop>
 8005292:	4603      	mov	r3, r0
 8005294:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8005296:	68fb      	ldr	r3, [r7, #12]
}
 8005298:	4618      	mov	r0, r3
 800529a:	3710      	adds	r7, #16
 800529c:	46bd      	mov	sp, r7
 800529e:	bd80      	pop	{r7, pc}

080052a0 <lv_obj_get_style_height>:
{
 80052a0:	b580      	push	{r7, lr}
 80052a2:	b084      	sub	sp, #16
 80052a4:	af00      	add	r7, sp, #0
 80052a6:	6078      	str	r0, [r7, #4]
 80052a8:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_HEIGHT);
 80052aa:	2202      	movs	r2, #2
 80052ac:	6839      	ldr	r1, [r7, #0]
 80052ae:	6878      	ldr	r0, [r7, #4]
 80052b0:	f004 fa3a 	bl	8009728 <lv_obj_get_style_prop>
 80052b4:	4603      	mov	r3, r0
 80052b6:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80052b8:	68fb      	ldr	r3, [r7, #12]
}
 80052ba:	4618      	mov	r0, r3
 80052bc:	3710      	adds	r7, #16
 80052be:	46bd      	mov	sp, r7
 80052c0:	bd80      	pop	{r7, pc}

080052c2 <lv_obj_get_style_min_height>:
{
 80052c2:	b580      	push	{r7, lr}
 80052c4:	b084      	sub	sp, #16
 80052c6:	af00      	add	r7, sp, #0
 80052c8:	6078      	str	r0, [r7, #4]
 80052ca:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MIN_HEIGHT);
 80052cc:	2206      	movs	r2, #6
 80052ce:	6839      	ldr	r1, [r7, #0]
 80052d0:	6878      	ldr	r0, [r7, #4]
 80052d2:	f004 fa29 	bl	8009728 <lv_obj_get_style_prop>
 80052d6:	4603      	mov	r3, r0
 80052d8:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80052da:	68fb      	ldr	r3, [r7, #12]
}
 80052dc:	4618      	mov	r0, r3
 80052de:	3710      	adds	r7, #16
 80052e0:	46bd      	mov	sp, r7
 80052e2:	bd80      	pop	{r7, pc}

080052e4 <lv_obj_get_style_max_height>:
{
 80052e4:	b580      	push	{r7, lr}
 80052e6:	b084      	sub	sp, #16
 80052e8:	af00      	add	r7, sp, #0
 80052ea:	6078      	str	r0, [r7, #4]
 80052ec:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MAX_HEIGHT);
 80052ee:	2207      	movs	r2, #7
 80052f0:	6839      	ldr	r1, [r7, #0]
 80052f2:	6878      	ldr	r0, [r7, #4]
 80052f4:	f004 fa18 	bl	8009728 <lv_obj_get_style_prop>
 80052f8:	4603      	mov	r3, r0
 80052fa:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80052fc:	68fb      	ldr	r3, [r7, #12]
}
 80052fe:	4618      	mov	r0, r3
 8005300:	3710      	adds	r7, #16
 8005302:	46bd      	mov	sp, r7
 8005304:	bd80      	pop	{r7, pc}

08005306 <lv_obj_get_style_x>:
{
 8005306:	b580      	push	{r7, lr}
 8005308:	b084      	sub	sp, #16
 800530a:	af00      	add	r7, sp, #0
 800530c:	6078      	str	r0, [r7, #4]
 800530e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_X);
 8005310:	2208      	movs	r2, #8
 8005312:	6839      	ldr	r1, [r7, #0]
 8005314:	6878      	ldr	r0, [r7, #4]
 8005316:	f004 fa07 	bl	8009728 <lv_obj_get_style_prop>
 800531a:	4603      	mov	r3, r0
 800531c:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 800531e:	68fb      	ldr	r3, [r7, #12]
}
 8005320:	4618      	mov	r0, r3
 8005322:	3710      	adds	r7, #16
 8005324:	46bd      	mov	sp, r7
 8005326:	bd80      	pop	{r7, pc}

08005328 <lv_obj_get_style_y>:
{
 8005328:	b580      	push	{r7, lr}
 800532a:	b084      	sub	sp, #16
 800532c:	af00      	add	r7, sp, #0
 800532e:	6078      	str	r0, [r7, #4]
 8005330:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_Y);
 8005332:	2209      	movs	r2, #9
 8005334:	6839      	ldr	r1, [r7, #0]
 8005336:	6878      	ldr	r0, [r7, #4]
 8005338:	f004 f9f6 	bl	8009728 <lv_obj_get_style_prop>
 800533c:	4603      	mov	r3, r0
 800533e:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8005340:	68fb      	ldr	r3, [r7, #12]
}
 8005342:	4618      	mov	r0, r3
 8005344:	3710      	adds	r7, #16
 8005346:	46bd      	mov	sp, r7
 8005348:	bd80      	pop	{r7, pc}

0800534a <lv_obj_get_style_align>:
{
 800534a:	b580      	push	{r7, lr}
 800534c:	b084      	sub	sp, #16
 800534e:	af00      	add	r7, sp, #0
 8005350:	6078      	str	r0, [r7, #4]
 8005352:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ALIGN);
 8005354:	220a      	movs	r2, #10
 8005356:	6839      	ldr	r1, [r7, #0]
 8005358:	6878      	ldr	r0, [r7, #4]
 800535a:	f004 f9e5 	bl	8009728 <lv_obj_get_style_prop>
 800535e:	4603      	mov	r3, r0
 8005360:	60fb      	str	r3, [r7, #12]
    return (lv_align_t)v.num;
 8005362:	68fb      	ldr	r3, [r7, #12]
 8005364:	b2db      	uxtb	r3, r3
}
 8005366:	4618      	mov	r0, r3
 8005368:	3710      	adds	r7, #16
 800536a:	46bd      	mov	sp, r7
 800536c:	bd80      	pop	{r7, pc}

0800536e <lv_obj_get_style_translate_x>:
{
 800536e:	b580      	push	{r7, lr}
 8005370:	b084      	sub	sp, #16
 8005372:	af00      	add	r7, sp, #0
 8005374:	6078      	str	r0, [r7, #4]
 8005376:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSLATE_X);
 8005378:	226a      	movs	r2, #106	@ 0x6a
 800537a:	6839      	ldr	r1, [r7, #0]
 800537c:	6878      	ldr	r0, [r7, #4]
 800537e:	f004 f9d3 	bl	8009728 <lv_obj_get_style_prop>
 8005382:	4603      	mov	r3, r0
 8005384:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8005386:	68fb      	ldr	r3, [r7, #12]
}
 8005388:	4618      	mov	r0, r3
 800538a:	3710      	adds	r7, #16
 800538c:	46bd      	mov	sp, r7
 800538e:	bd80      	pop	{r7, pc}

08005390 <lv_obj_get_style_translate_y>:
{
 8005390:	b580      	push	{r7, lr}
 8005392:	b084      	sub	sp, #16
 8005394:	af00      	add	r7, sp, #0
 8005396:	6078      	str	r0, [r7, #4]
 8005398:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSLATE_Y);
 800539a:	226b      	movs	r2, #107	@ 0x6b
 800539c:	6839      	ldr	r1, [r7, #0]
 800539e:	6878      	ldr	r0, [r7, #4]
 80053a0:	f004 f9c2 	bl	8009728 <lv_obj_get_style_prop>
 80053a4:	4603      	mov	r3, r0
 80053a6:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80053a8:	68fb      	ldr	r3, [r7, #12]
}
 80053aa:	4618      	mov	r0, r3
 80053ac:	3710      	adds	r7, #16
 80053ae:	46bd      	mov	sp, r7
 80053b0:	bd80      	pop	{r7, pc}

080053b2 <lv_obj_get_style_transform_scale_x>:
{
 80053b2:	b580      	push	{r7, lr}
 80053b4:	b084      	sub	sp, #16
 80053b6:	af00      	add	r7, sp, #0
 80053b8:	6078      	str	r0, [r7, #4]
 80053ba:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_SCALE_X);
 80053bc:	226c      	movs	r2, #108	@ 0x6c
 80053be:	6839      	ldr	r1, [r7, #0]
 80053c0:	6878      	ldr	r0, [r7, #4]
 80053c2:	f004 f9b1 	bl	8009728 <lv_obj_get_style_prop>
 80053c6:	4603      	mov	r3, r0
 80053c8:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80053ca:	68fb      	ldr	r3, [r7, #12]
}
 80053cc:	4618      	mov	r0, r3
 80053ce:	3710      	adds	r7, #16
 80053d0:	46bd      	mov	sp, r7
 80053d2:	bd80      	pop	{r7, pc}

080053d4 <lv_obj_get_style_transform_scale_y>:
{
 80053d4:	b580      	push	{r7, lr}
 80053d6:	b084      	sub	sp, #16
 80053d8:	af00      	add	r7, sp, #0
 80053da:	6078      	str	r0, [r7, #4]
 80053dc:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_SCALE_Y);
 80053de:	226d      	movs	r2, #109	@ 0x6d
 80053e0:	6839      	ldr	r1, [r7, #0]
 80053e2:	6878      	ldr	r0, [r7, #4]
 80053e4:	f004 f9a0 	bl	8009728 <lv_obj_get_style_prop>
 80053e8:	4603      	mov	r3, r0
 80053ea:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80053ec:	68fb      	ldr	r3, [r7, #12]
}
 80053ee:	4618      	mov	r0, r3
 80053f0:	3710      	adds	r7, #16
 80053f2:	46bd      	mov	sp, r7
 80053f4:	bd80      	pop	{r7, pc}

080053f6 <lv_obj_get_style_transform_rotation>:
{
 80053f6:	b580      	push	{r7, lr}
 80053f8:	b084      	sub	sp, #16
 80053fa:	af00      	add	r7, sp, #0
 80053fc:	6078      	str	r0, [r7, #4]
 80053fe:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_ROTATION);
 8005400:	226e      	movs	r2, #110	@ 0x6e
 8005402:	6839      	ldr	r1, [r7, #0]
 8005404:	6878      	ldr	r0, [r7, #4]
 8005406:	f004 f98f 	bl	8009728 <lv_obj_get_style_prop>
 800540a:	4603      	mov	r3, r0
 800540c:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 800540e:	68fb      	ldr	r3, [r7, #12]
}
 8005410:	4618      	mov	r0, r3
 8005412:	3710      	adds	r7, #16
 8005414:	46bd      	mov	sp, r7
 8005416:	bd80      	pop	{r7, pc}

08005418 <lv_obj_get_style_transform_pivot_x>:
{
 8005418:	b580      	push	{r7, lr}
 800541a:	b084      	sub	sp, #16
 800541c:	af00      	add	r7, sp, #0
 800541e:	6078      	str	r0, [r7, #4]
 8005420:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_PIVOT_X);
 8005422:	226f      	movs	r2, #111	@ 0x6f
 8005424:	6839      	ldr	r1, [r7, #0]
 8005426:	6878      	ldr	r0, [r7, #4]
 8005428:	f004 f97e 	bl	8009728 <lv_obj_get_style_prop>
 800542c:	4603      	mov	r3, r0
 800542e:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8005430:	68fb      	ldr	r3, [r7, #12]
}
 8005432:	4618      	mov	r0, r3
 8005434:	3710      	adds	r7, #16
 8005436:	46bd      	mov	sp, r7
 8005438:	bd80      	pop	{r7, pc}

0800543a <lv_obj_get_style_transform_pivot_y>:
{
 800543a:	b580      	push	{r7, lr}
 800543c:	b084      	sub	sp, #16
 800543e:	af00      	add	r7, sp, #0
 8005440:	6078      	str	r0, [r7, #4]
 8005442:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_PIVOT_Y);
 8005444:	2270      	movs	r2, #112	@ 0x70
 8005446:	6839      	ldr	r1, [r7, #0]
 8005448:	6878      	ldr	r0, [r7, #4]
 800544a:	f004 f96d 	bl	8009728 <lv_obj_get_style_prop>
 800544e:	4603      	mov	r3, r0
 8005450:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8005452:	68fb      	ldr	r3, [r7, #12]
}
 8005454:	4618      	mov	r0, r3
 8005456:	3710      	adds	r7, #16
 8005458:	46bd      	mov	sp, r7
 800545a:	bd80      	pop	{r7, pc}

0800545c <lv_obj_get_style_pad_top>:
{
 800545c:	b580      	push	{r7, lr}
 800545e:	b084      	sub	sp, #16
 8005460:	af00      	add	r7, sp, #0
 8005462:	6078      	str	r0, [r7, #4]
 8005464:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_TOP);
 8005466:	2210      	movs	r2, #16
 8005468:	6839      	ldr	r1, [r7, #0]
 800546a:	6878      	ldr	r0, [r7, #4]
 800546c:	f004 f95c 	bl	8009728 <lv_obj_get_style_prop>
 8005470:	4603      	mov	r3, r0
 8005472:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8005474:	68fb      	ldr	r3, [r7, #12]
}
 8005476:	4618      	mov	r0, r3
 8005478:	3710      	adds	r7, #16
 800547a:	46bd      	mov	sp, r7
 800547c:	bd80      	pop	{r7, pc}

0800547e <lv_obj_get_style_pad_bottom>:
{
 800547e:	b580      	push	{r7, lr}
 8005480:	b084      	sub	sp, #16
 8005482:	af00      	add	r7, sp, #0
 8005484:	6078      	str	r0, [r7, #4]
 8005486:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_BOTTOM);
 8005488:	2211      	movs	r2, #17
 800548a:	6839      	ldr	r1, [r7, #0]
 800548c:	6878      	ldr	r0, [r7, #4]
 800548e:	f004 f94b 	bl	8009728 <lv_obj_get_style_prop>
 8005492:	4603      	mov	r3, r0
 8005494:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8005496:	68fb      	ldr	r3, [r7, #12]
}
 8005498:	4618      	mov	r0, r3
 800549a:	3710      	adds	r7, #16
 800549c:	46bd      	mov	sp, r7
 800549e:	bd80      	pop	{r7, pc}

080054a0 <lv_obj_get_style_pad_left>:
{
 80054a0:	b580      	push	{r7, lr}
 80054a2:	b084      	sub	sp, #16
 80054a4:	af00      	add	r7, sp, #0
 80054a6:	6078      	str	r0, [r7, #4]
 80054a8:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_LEFT);
 80054aa:	2212      	movs	r2, #18
 80054ac:	6839      	ldr	r1, [r7, #0]
 80054ae:	6878      	ldr	r0, [r7, #4]
 80054b0:	f004 f93a 	bl	8009728 <lv_obj_get_style_prop>
 80054b4:	4603      	mov	r3, r0
 80054b6:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80054b8:	68fb      	ldr	r3, [r7, #12]
}
 80054ba:	4618      	mov	r0, r3
 80054bc:	3710      	adds	r7, #16
 80054be:	46bd      	mov	sp, r7
 80054c0:	bd80      	pop	{r7, pc}

080054c2 <lv_obj_get_style_pad_right>:
{
 80054c2:	b580      	push	{r7, lr}
 80054c4:	b084      	sub	sp, #16
 80054c6:	af00      	add	r7, sp, #0
 80054c8:	6078      	str	r0, [r7, #4]
 80054ca:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_RIGHT);
 80054cc:	2213      	movs	r2, #19
 80054ce:	6839      	ldr	r1, [r7, #0]
 80054d0:	6878      	ldr	r0, [r7, #4]
 80054d2:	f004 f929 	bl	8009728 <lv_obj_get_style_prop>
 80054d6:	4603      	mov	r3, r0
 80054d8:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80054da:	68fb      	ldr	r3, [r7, #12]
}
 80054dc:	4618      	mov	r0, r3
 80054de:	3710      	adds	r7, #16
 80054e0:	46bd      	mov	sp, r7
 80054e2:	bd80      	pop	{r7, pc}

080054e4 <lv_obj_get_style_margin_top>:
{
 80054e4:	b580      	push	{r7, lr}
 80054e6:	b084      	sub	sp, #16
 80054e8:	af00      	add	r7, sp, #0
 80054ea:	6078      	str	r0, [r7, #4]
 80054ec:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_TOP);
 80054ee:	2218      	movs	r2, #24
 80054f0:	6839      	ldr	r1, [r7, #0]
 80054f2:	6878      	ldr	r0, [r7, #4]
 80054f4:	f004 f918 	bl	8009728 <lv_obj_get_style_prop>
 80054f8:	4603      	mov	r3, r0
 80054fa:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80054fc:	68fb      	ldr	r3, [r7, #12]
}
 80054fe:	4618      	mov	r0, r3
 8005500:	3710      	adds	r7, #16
 8005502:	46bd      	mov	sp, r7
 8005504:	bd80      	pop	{r7, pc}

08005506 <lv_obj_get_style_margin_bottom>:
{
 8005506:	b580      	push	{r7, lr}
 8005508:	b084      	sub	sp, #16
 800550a:	af00      	add	r7, sp, #0
 800550c:	6078      	str	r0, [r7, #4]
 800550e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_BOTTOM);
 8005510:	2219      	movs	r2, #25
 8005512:	6839      	ldr	r1, [r7, #0]
 8005514:	6878      	ldr	r0, [r7, #4]
 8005516:	f004 f907 	bl	8009728 <lv_obj_get_style_prop>
 800551a:	4603      	mov	r3, r0
 800551c:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 800551e:	68fb      	ldr	r3, [r7, #12]
}
 8005520:	4618      	mov	r0, r3
 8005522:	3710      	adds	r7, #16
 8005524:	46bd      	mov	sp, r7
 8005526:	bd80      	pop	{r7, pc}

08005528 <lv_obj_get_style_margin_left>:
{
 8005528:	b580      	push	{r7, lr}
 800552a:	b084      	sub	sp, #16
 800552c:	af00      	add	r7, sp, #0
 800552e:	6078      	str	r0, [r7, #4]
 8005530:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_LEFT);
 8005532:	221a      	movs	r2, #26
 8005534:	6839      	ldr	r1, [r7, #0]
 8005536:	6878      	ldr	r0, [r7, #4]
 8005538:	f004 f8f6 	bl	8009728 <lv_obj_get_style_prop>
 800553c:	4603      	mov	r3, r0
 800553e:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8005540:	68fb      	ldr	r3, [r7, #12]
}
 8005542:	4618      	mov	r0, r3
 8005544:	3710      	adds	r7, #16
 8005546:	46bd      	mov	sp, r7
 8005548:	bd80      	pop	{r7, pc}

0800554a <lv_obj_get_style_margin_right>:
{
 800554a:	b580      	push	{r7, lr}
 800554c:	b084      	sub	sp, #16
 800554e:	af00      	add	r7, sp, #0
 8005550:	6078      	str	r0, [r7, #4]
 8005552:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_RIGHT);
 8005554:	221b      	movs	r2, #27
 8005556:	6839      	ldr	r1, [r7, #0]
 8005558:	6878      	ldr	r0, [r7, #4]
 800555a:	f004 f8e5 	bl	8009728 <lv_obj_get_style_prop>
 800555e:	4603      	mov	r3, r0
 8005560:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8005562:	68fb      	ldr	r3, [r7, #12]
}
 8005564:	4618      	mov	r0, r3
 8005566:	3710      	adds	r7, #16
 8005568:	46bd      	mov	sp, r7
 800556a:	bd80      	pop	{r7, pc}

0800556c <lv_obj_get_style_border_width>:
{
 800556c:	b580      	push	{r7, lr}
 800556e:	b084      	sub	sp, #16
 8005570:	af00      	add	r7, sp, #0
 8005572:	6078      	str	r0, [r7, #4]
 8005574:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_WIDTH);
 8005576:	2230      	movs	r2, #48	@ 0x30
 8005578:	6839      	ldr	r1, [r7, #0]
 800557a:	6878      	ldr	r0, [r7, #4]
 800557c:	f004 f8d4 	bl	8009728 <lv_obj_get_style_prop>
 8005580:	4603      	mov	r3, r0
 8005582:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8005584:	68fb      	ldr	r3, [r7, #12]
}
 8005586:	4618      	mov	r0, r3
 8005588:	3710      	adds	r7, #16
 800558a:	46bd      	mov	sp, r7
 800558c:	bd80      	pop	{r7, pc}

0800558e <lv_obj_get_style_border_side>:
{
 800558e:	b580      	push	{r7, lr}
 8005590:	b084      	sub	sp, #16
 8005592:	af00      	add	r7, sp, #0
 8005594:	6078      	str	r0, [r7, #4]
 8005596:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_SIDE);
 8005598:	2234      	movs	r2, #52	@ 0x34
 800559a:	6839      	ldr	r1, [r7, #0]
 800559c:	6878      	ldr	r0, [r7, #4]
 800559e:	f004 f8c3 	bl	8009728 <lv_obj_get_style_prop>
 80055a2:	4603      	mov	r3, r0
 80055a4:	60fb      	str	r3, [r7, #12]
    return (lv_border_side_t)v.num;
 80055a6:	68fb      	ldr	r3, [r7, #12]
 80055a8:	b2db      	uxtb	r3, r3
}
 80055aa:	4618      	mov	r0, r3
 80055ac:	3710      	adds	r7, #16
 80055ae:	46bd      	mov	sp, r7
 80055b0:	bd80      	pop	{r7, pc}

080055b2 <lv_obj_get_style_layout>:
{
 80055b2:	b580      	push	{r7, lr}
 80055b4:	b084      	sub	sp, #16
 80055b6:	af00      	add	r7, sp, #0
 80055b8:	6078      	str	r0, [r7, #4]
 80055ba:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LAYOUT);
 80055bc:	2216      	movs	r2, #22
 80055be:	6839      	ldr	r1, [r7, #0]
 80055c0:	6878      	ldr	r0, [r7, #4]
 80055c2:	f004 f8b1 	bl	8009728 <lv_obj_get_style_prop>
 80055c6:	4603      	mov	r3, r0
 80055c8:	60fb      	str	r3, [r7, #12]
    return (uint16_t)v.num;
 80055ca:	68fb      	ldr	r3, [r7, #12]
 80055cc:	b29b      	uxth	r3, r3
}
 80055ce:	4618      	mov	r0, r3
 80055d0:	3710      	adds	r7, #16
 80055d2:	46bd      	mov	sp, r7
 80055d4:	bd80      	pop	{r7, pc}

080055d6 <lv_obj_get_style_base_dir>:

static inline lv_base_dir_t lv_obj_get_style_base_dir(const lv_obj_t * obj, uint32_t part)
{
 80055d6:	b580      	push	{r7, lr}
 80055d8:	b084      	sub	sp, #16
 80055da:	af00      	add	r7, sp, #0
 80055dc:	6078      	str	r0, [r7, #4]
 80055de:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BASE_DIR);
 80055e0:	2227      	movs	r2, #39	@ 0x27
 80055e2:	6839      	ldr	r1, [r7, #0]
 80055e4:	6878      	ldr	r0, [r7, #4]
 80055e6:	f004 f89f 	bl	8009728 <lv_obj_get_style_prop>
 80055ea:	4603      	mov	r3, r0
 80055ec:	60fb      	str	r3, [r7, #12]
    return (lv_base_dir_t)v.num;
 80055ee:	68fb      	ldr	r3, [r7, #12]
 80055f0:	b2db      	uxtb	r3, r3
}
 80055f2:	4618      	mov	r0, r3
 80055f4:	3710      	adds	r7, #16
 80055f6:	46bd      	mov	sp, r7
 80055f8:	bd80      	pop	{r7, pc}

080055fa <lv_obj_get_style_space_left>:
    lv_obj_set_style_transform_scale_x(obj, value, selector);
    lv_obj_set_style_transform_scale_y(obj, value, selector);
}

static inline int32_t lv_obj_get_style_space_left(const lv_obj_t * obj, uint32_t part)
{
 80055fa:	b580      	push	{r7, lr}
 80055fc:	b086      	sub	sp, #24
 80055fe:	af00      	add	r7, sp, #0
 8005600:	6078      	str	r0, [r7, #4]
 8005602:	6039      	str	r1, [r7, #0]
    int32_t padding = lv_obj_get_style_pad_left(obj, part);
 8005604:	6839      	ldr	r1, [r7, #0]
 8005606:	6878      	ldr	r0, [r7, #4]
 8005608:	f7ff ff4a 	bl	80054a0 <lv_obj_get_style_pad_left>
 800560c:	6178      	str	r0, [r7, #20]
    int32_t border_width = lv_obj_get_style_border_width(obj, part);
 800560e:	6839      	ldr	r1, [r7, #0]
 8005610:	6878      	ldr	r0, [r7, #4]
 8005612:	f7ff ffab 	bl	800556c <lv_obj_get_style_border_width>
 8005616:	6138      	str	r0, [r7, #16]
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
 8005618:	6839      	ldr	r1, [r7, #0]
 800561a:	6878      	ldr	r0, [r7, #4]
 800561c:	f7ff ffb7 	bl	800558e <lv_obj_get_style_border_side>
 8005620:	4603      	mov	r3, r0
 8005622:	73fb      	strb	r3, [r7, #15]
    return (border_side & LV_BORDER_SIDE_LEFT) ? padding + border_width : padding;
 8005624:	7bfb      	ldrb	r3, [r7, #15]
 8005626:	f003 0304 	and.w	r3, r3, #4
 800562a:	2b00      	cmp	r3, #0
 800562c:	d003      	beq.n	8005636 <lv_obj_get_style_space_left+0x3c>
 800562e:	697a      	ldr	r2, [r7, #20]
 8005630:	693b      	ldr	r3, [r7, #16]
 8005632:	4413      	add	r3, r2
 8005634:	e000      	b.n	8005638 <lv_obj_get_style_space_left+0x3e>
 8005636:	697b      	ldr	r3, [r7, #20]
}
 8005638:	4618      	mov	r0, r3
 800563a:	3718      	adds	r7, #24
 800563c:	46bd      	mov	sp, r7
 800563e:	bd80      	pop	{r7, pc}

08005640 <lv_obj_get_style_space_right>:

static inline int32_t lv_obj_get_style_space_right(const lv_obj_t * obj, uint32_t part)
{
 8005640:	b580      	push	{r7, lr}
 8005642:	b086      	sub	sp, #24
 8005644:	af00      	add	r7, sp, #0
 8005646:	6078      	str	r0, [r7, #4]
 8005648:	6039      	str	r1, [r7, #0]
    int32_t padding = lv_obj_get_style_pad_right(obj, part);
 800564a:	6839      	ldr	r1, [r7, #0]
 800564c:	6878      	ldr	r0, [r7, #4]
 800564e:	f7ff ff38 	bl	80054c2 <lv_obj_get_style_pad_right>
 8005652:	6178      	str	r0, [r7, #20]
    int32_t border_width = lv_obj_get_style_border_width(obj, part);
 8005654:	6839      	ldr	r1, [r7, #0]
 8005656:	6878      	ldr	r0, [r7, #4]
 8005658:	f7ff ff88 	bl	800556c <lv_obj_get_style_border_width>
 800565c:	6138      	str	r0, [r7, #16]
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
 800565e:	6839      	ldr	r1, [r7, #0]
 8005660:	6878      	ldr	r0, [r7, #4]
 8005662:	f7ff ff94 	bl	800558e <lv_obj_get_style_border_side>
 8005666:	4603      	mov	r3, r0
 8005668:	73fb      	strb	r3, [r7, #15]
    return (border_side & LV_BORDER_SIDE_RIGHT) ? padding + border_width : padding;
 800566a:	7bfb      	ldrb	r3, [r7, #15]
 800566c:	f003 0308 	and.w	r3, r3, #8
 8005670:	2b00      	cmp	r3, #0
 8005672:	d003      	beq.n	800567c <lv_obj_get_style_space_right+0x3c>
 8005674:	697a      	ldr	r2, [r7, #20]
 8005676:	693b      	ldr	r3, [r7, #16]
 8005678:	4413      	add	r3, r2
 800567a:	e000      	b.n	800567e <lv_obj_get_style_space_right+0x3e>
 800567c:	697b      	ldr	r3, [r7, #20]
}
 800567e:	4618      	mov	r0, r3
 8005680:	3718      	adds	r7, #24
 8005682:	46bd      	mov	sp, r7
 8005684:	bd80      	pop	{r7, pc}

08005686 <lv_obj_get_style_space_top>:

static inline int32_t lv_obj_get_style_space_top(const lv_obj_t * obj, uint32_t part)
{
 8005686:	b580      	push	{r7, lr}
 8005688:	b086      	sub	sp, #24
 800568a:	af00      	add	r7, sp, #0
 800568c:	6078      	str	r0, [r7, #4]
 800568e:	6039      	str	r1, [r7, #0]
    int32_t padding = lv_obj_get_style_pad_top(obj, part);
 8005690:	6839      	ldr	r1, [r7, #0]
 8005692:	6878      	ldr	r0, [r7, #4]
 8005694:	f7ff fee2 	bl	800545c <lv_obj_get_style_pad_top>
 8005698:	6178      	str	r0, [r7, #20]
    int32_t border_width = lv_obj_get_style_border_width(obj, part);
 800569a:	6839      	ldr	r1, [r7, #0]
 800569c:	6878      	ldr	r0, [r7, #4]
 800569e:	f7ff ff65 	bl	800556c <lv_obj_get_style_border_width>
 80056a2:	6138      	str	r0, [r7, #16]
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
 80056a4:	6839      	ldr	r1, [r7, #0]
 80056a6:	6878      	ldr	r0, [r7, #4]
 80056a8:	f7ff ff71 	bl	800558e <lv_obj_get_style_border_side>
 80056ac:	4603      	mov	r3, r0
 80056ae:	73fb      	strb	r3, [r7, #15]
    return (border_side & LV_BORDER_SIDE_TOP) ? padding + border_width : padding;
 80056b0:	7bfb      	ldrb	r3, [r7, #15]
 80056b2:	f003 0302 	and.w	r3, r3, #2
 80056b6:	2b00      	cmp	r3, #0
 80056b8:	d003      	beq.n	80056c2 <lv_obj_get_style_space_top+0x3c>
 80056ba:	697a      	ldr	r2, [r7, #20]
 80056bc:	693b      	ldr	r3, [r7, #16]
 80056be:	4413      	add	r3, r2
 80056c0:	e000      	b.n	80056c4 <lv_obj_get_style_space_top+0x3e>
 80056c2:	697b      	ldr	r3, [r7, #20]
}
 80056c4:	4618      	mov	r0, r3
 80056c6:	3718      	adds	r7, #24
 80056c8:	46bd      	mov	sp, r7
 80056ca:	bd80      	pop	{r7, pc}

080056cc <lv_obj_get_style_space_bottom>:

static inline int32_t lv_obj_get_style_space_bottom(const lv_obj_t * obj, uint32_t part)
{
 80056cc:	b580      	push	{r7, lr}
 80056ce:	b086      	sub	sp, #24
 80056d0:	af00      	add	r7, sp, #0
 80056d2:	6078      	str	r0, [r7, #4]
 80056d4:	6039      	str	r1, [r7, #0]
    int32_t padding = lv_obj_get_style_pad_bottom(obj, part);
 80056d6:	6839      	ldr	r1, [r7, #0]
 80056d8:	6878      	ldr	r0, [r7, #4]
 80056da:	f7ff fed0 	bl	800547e <lv_obj_get_style_pad_bottom>
 80056de:	6178      	str	r0, [r7, #20]
    int32_t border_width = lv_obj_get_style_border_width(obj, part);
 80056e0:	6839      	ldr	r1, [r7, #0]
 80056e2:	6878      	ldr	r0, [r7, #4]
 80056e4:	f7ff ff42 	bl	800556c <lv_obj_get_style_border_width>
 80056e8:	6138      	str	r0, [r7, #16]
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
 80056ea:	6839      	ldr	r1, [r7, #0]
 80056ec:	6878      	ldr	r0, [r7, #4]
 80056ee:	f7ff ff4e 	bl	800558e <lv_obj_get_style_border_side>
 80056f2:	4603      	mov	r3, r0
 80056f4:	73fb      	strb	r3, [r7, #15]
    return (border_side & LV_BORDER_SIDE_BOTTOM) ? padding + border_width : padding;
 80056f6:	7bfb      	ldrb	r3, [r7, #15]
 80056f8:	f003 0301 	and.w	r3, r3, #1
 80056fc:	2b00      	cmp	r3, #0
 80056fe:	d003      	beq.n	8005708 <lv_obj_get_style_space_bottom+0x3c>
 8005700:	697a      	ldr	r2, [r7, #20]
 8005702:	693b      	ldr	r3, [r7, #16]
 8005704:	4413      	add	r3, r2
 8005706:	e000      	b.n	800570a <lv_obj_get_style_space_bottom+0x3e>
 8005708:	697b      	ldr	r3, [r7, #20]
}
 800570a:	4618      	mov	r0, r3
 800570c:	3718      	adds	r7, #24
 800570e:	46bd      	mov	sp, r7
 8005710:	bd80      	pop	{r7, pc}

08005712 <lv_obj_get_style_transform_scale_x_safe>:

lv_text_align_t lv_obj_calculate_style_text_align(const lv_obj_t * obj, lv_part_t part, const char * txt);

static inline int32_t lv_obj_get_style_transform_scale_x_safe(const lv_obj_t * obj, uint32_t part)
{
 8005712:	b580      	push	{r7, lr}
 8005714:	b084      	sub	sp, #16
 8005716:	af00      	add	r7, sp, #0
 8005718:	6078      	str	r0, [r7, #4]
 800571a:	6039      	str	r1, [r7, #0]
    int16_t zoom = lv_obj_get_style_transform_scale_x(obj, part);
 800571c:	6839      	ldr	r1, [r7, #0]
 800571e:	6878      	ldr	r0, [r7, #4]
 8005720:	f7ff fe47 	bl	80053b2 <lv_obj_get_style_transform_scale_x>
 8005724:	4603      	mov	r3, r0
 8005726:	81fb      	strh	r3, [r7, #14]
    return zoom != 0 ? zoom : 1;
 8005728:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800572c:	2b00      	cmp	r3, #0
 800572e:	d002      	beq.n	8005736 <lv_obj_get_style_transform_scale_x_safe+0x24>
 8005730:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8005734:	e000      	b.n	8005738 <lv_obj_get_style_transform_scale_x_safe+0x26>
 8005736:	2301      	movs	r3, #1
}
 8005738:	4618      	mov	r0, r3
 800573a:	3710      	adds	r7, #16
 800573c:	46bd      	mov	sp, r7
 800573e:	bd80      	pop	{r7, pc}

08005740 <lv_obj_get_style_transform_scale_y_safe>:

static inline int32_t lv_obj_get_style_transform_scale_y_safe(const lv_obj_t * obj, uint32_t part)
{
 8005740:	b580      	push	{r7, lr}
 8005742:	b084      	sub	sp, #16
 8005744:	af00      	add	r7, sp, #0
 8005746:	6078      	str	r0, [r7, #4]
 8005748:	6039      	str	r1, [r7, #0]
    int16_t zoom = lv_obj_get_style_transform_scale_y(obj, part);
 800574a:	6839      	ldr	r1, [r7, #0]
 800574c:	6878      	ldr	r0, [r7, #4]
 800574e:	f7ff fe41 	bl	80053d4 <lv_obj_get_style_transform_scale_y>
 8005752:	4603      	mov	r3, r0
 8005754:	81fb      	strh	r3, [r7, #14]
    return zoom != 0 ? zoom : 1;
 8005756:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800575a:	2b00      	cmp	r3, #0
 800575c:	d002      	beq.n	8005764 <lv_obj_get_style_transform_scale_y_safe+0x24>
 800575e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8005762:	e000      	b.n	8005766 <lv_obj_get_style_transform_scale_y_safe+0x26>
 8005764:	2301      	movs	r3, #1
}
 8005766:	4618      	mov	r0, r3
 8005768:	3710      	adds	r7, #16
 800576a:	46bd      	mov	sp, r7
 800576c:	bd80      	pop	{r7, pc}

0800576e <lv_obj_set_pos>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_obj_set_pos(lv_obj_t * obj, int32_t x, int32_t y)
{
 800576e:	b580      	push	{r7, lr}
 8005770:	b084      	sub	sp, #16
 8005772:	af00      	add	r7, sp, #0
 8005774:	60f8      	str	r0, [r7, #12]
 8005776:	60b9      	str	r1, [r7, #8]
 8005778:	607a      	str	r2, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    lv_obj_set_x(obj, x);
 800577a:	68b9      	ldr	r1, [r7, #8]
 800577c:	68f8      	ldr	r0, [r7, #12]
 800577e:	f000 f808 	bl	8005792 <lv_obj_set_x>
    lv_obj_set_y(obj, y);
 8005782:	6879      	ldr	r1, [r7, #4]
 8005784:	68f8      	ldr	r0, [r7, #12]
 8005786:	f000 f825 	bl	80057d4 <lv_obj_set_y>
}
 800578a:	bf00      	nop
 800578c:	3710      	adds	r7, #16
 800578e:	46bd      	mov	sp, r7
 8005790:	bd80      	pop	{r7, pc}

08005792 <lv_obj_set_x>:

void lv_obj_set_x(lv_obj_t * obj, int32_t x)
{
 8005792:	b580      	push	{r7, lr}
 8005794:	b084      	sub	sp, #16
 8005796:	af00      	add	r7, sp, #0
 8005798:	6078      	str	r0, [r7, #4]
 800579a:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    lv_result_t res_x;
    lv_style_value_t v_x;

    res_x = lv_obj_get_local_style_prop(obj, LV_STYLE_X, &v_x, 0);
 800579c:	f107 0208 	add.w	r2, r7, #8
 80057a0:	2300      	movs	r3, #0
 80057a2:	2108      	movs	r1, #8
 80057a4:	6878      	ldr	r0, [r7, #4]
 80057a6:	f004 f818 	bl	80097da <lv_obj_get_local_style_prop>
 80057aa:	4603      	mov	r3, r0
 80057ac:	73fb      	strb	r3, [r7, #15]

    if((res_x == LV_RESULT_OK && v_x.num != x) || res_x == LV_RESULT_INVALID) {
 80057ae:	7bfb      	ldrb	r3, [r7, #15]
 80057b0:	2b01      	cmp	r3, #1
 80057b2:	d103      	bne.n	80057bc <lv_obj_set_x+0x2a>
 80057b4:	68bb      	ldr	r3, [r7, #8]
 80057b6:	683a      	ldr	r2, [r7, #0]
 80057b8:	429a      	cmp	r2, r3
 80057ba:	d102      	bne.n	80057c2 <lv_obj_set_x+0x30>
 80057bc:	7bfb      	ldrb	r3, [r7, #15]
 80057be:	2b00      	cmp	r3, #0
 80057c0:	d104      	bne.n	80057cc <lv_obj_set_x+0x3a>
        lv_obj_set_style_x(obj, x, 0);
 80057c2:	2200      	movs	r2, #0
 80057c4:	6839      	ldr	r1, [r7, #0]
 80057c6:	6878      	ldr	r0, [r7, #4]
 80057c8:	f005 fa72 	bl	800acb0 <lv_obj_set_style_x>
    }
}
 80057cc:	bf00      	nop
 80057ce:	3710      	adds	r7, #16
 80057d0:	46bd      	mov	sp, r7
 80057d2:	bd80      	pop	{r7, pc}

080057d4 <lv_obj_set_y>:

void lv_obj_set_y(lv_obj_t * obj, int32_t y)
{
 80057d4:	b580      	push	{r7, lr}
 80057d6:	b084      	sub	sp, #16
 80057d8:	af00      	add	r7, sp, #0
 80057da:	6078      	str	r0, [r7, #4]
 80057dc:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    lv_result_t res_y;
    lv_style_value_t v_y;

    res_y = lv_obj_get_local_style_prop(obj, LV_STYLE_Y, &v_y, 0);
 80057de:	f107 0208 	add.w	r2, r7, #8
 80057e2:	2300      	movs	r3, #0
 80057e4:	2109      	movs	r1, #9
 80057e6:	6878      	ldr	r0, [r7, #4]
 80057e8:	f003 fff7 	bl	80097da <lv_obj_get_local_style_prop>
 80057ec:	4603      	mov	r3, r0
 80057ee:	73fb      	strb	r3, [r7, #15]

    if((res_y == LV_RESULT_OK && v_y.num != y) || res_y == LV_RESULT_INVALID) {
 80057f0:	7bfb      	ldrb	r3, [r7, #15]
 80057f2:	2b01      	cmp	r3, #1
 80057f4:	d103      	bne.n	80057fe <lv_obj_set_y+0x2a>
 80057f6:	68bb      	ldr	r3, [r7, #8]
 80057f8:	683a      	ldr	r2, [r7, #0]
 80057fa:	429a      	cmp	r2, r3
 80057fc:	d102      	bne.n	8005804 <lv_obj_set_y+0x30>
 80057fe:	7bfb      	ldrb	r3, [r7, #15]
 8005800:	2b00      	cmp	r3, #0
 8005802:	d104      	bne.n	800580e <lv_obj_set_y+0x3a>
        lv_obj_set_style_y(obj, y, 0);
 8005804:	2200      	movs	r2, #0
 8005806:	6839      	ldr	r1, [r7, #0]
 8005808:	6878      	ldr	r0, [r7, #4]
 800580a:	f005 fa63 	bl	800acd4 <lv_obj_set_style_y>
    }
}
 800580e:	bf00      	nop
 8005810:	3710      	adds	r7, #16
 8005812:	46bd      	mov	sp, r7
 8005814:	bd80      	pop	{r7, pc}
	...

08005818 <lv_obj_refr_size>:

bool lv_obj_refr_size(lv_obj_t * obj)
{
 8005818:	b590      	push	{r4, r7, lr}
 800581a:	b097      	sub	sp, #92	@ 0x5c
 800581c:	af00      	add	r7, sp, #0
 800581e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    /*If the width or height is set by a layout do not modify them*/
    if(obj->w_layout && obj->h_layout) return false;
 8005820:	687b      	ldr	r3, [r7, #4]
 8005822:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 8005826:	f003 0308 	and.w	r3, r3, #8
 800582a:	b2db      	uxtb	r3, r3
 800582c:	2b00      	cmp	r3, #0
 800582e:	d009      	beq.n	8005844 <lv_obj_refr_size+0x2c>
 8005830:	687b      	ldr	r3, [r7, #4]
 8005832:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 8005836:	f003 0304 	and.w	r3, r3, #4
 800583a:	b2db      	uxtb	r3, r3
 800583c:	2b00      	cmp	r3, #0
 800583e:	d001      	beq.n	8005844 <lv_obj_refr_size+0x2c>
 8005840:	2300      	movs	r3, #0
 8005842:	e1cf      	b.n	8005be4 <lv_obj_refr_size+0x3cc>

    lv_obj_t * parent = lv_obj_get_parent(obj);
 8005844:	6878      	ldr	r0, [r7, #4]
 8005846:	f005 faf5 	bl	800ae34 <lv_obj_get_parent>
 800584a:	64f8      	str	r0, [r7, #76]	@ 0x4c
    if(parent == NULL) return false;
 800584c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800584e:	2b00      	cmp	r3, #0
 8005850:	d101      	bne.n	8005856 <lv_obj_refr_size+0x3e>
 8005852:	2300      	movs	r3, #0
 8005854:	e1c6      	b.n	8005be4 <lv_obj_refr_size+0x3cc>

    bool w_is_content = false;
 8005856:	2300      	movs	r3, #0
 8005858:	f887 304b 	strb.w	r3, [r7, #75]	@ 0x4b
    bool w_is_pct = false;
 800585c:	2300      	movs	r3, #0
 800585e:	f887 304a 	strb.w	r3, [r7, #74]	@ 0x4a

    int32_t w;
    if(obj->w_layout) {
 8005862:	687b      	ldr	r3, [r7, #4]
 8005864:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 8005868:	f003 0308 	and.w	r3, r3, #8
 800586c:	b2db      	uxtb	r3, r3
 800586e:	2b00      	cmp	r3, #0
 8005870:	d004      	beq.n	800587c <lv_obj_refr_size+0x64>
        w = lv_obj_get_width(obj);
 8005872:	6878      	ldr	r0, [r7, #4]
 8005874:	f000 fa5c 	bl	8005d30 <lv_obj_get_width>
 8005878:	6578      	str	r0, [r7, #84]	@ 0x54
 800587a:	e089      	b.n	8005990 <lv_obj_refr_size+0x178>
    }
    else {
        w = lv_obj_get_style_width(obj, LV_PART_MAIN);
 800587c:	2100      	movs	r1, #0
 800587e:	6878      	ldr	r0, [r7, #4]
 8005880:	f7ff fcdb 	bl	800523a <lv_obj_get_style_width>
 8005884:	6578      	str	r0, [r7, #84]	@ 0x54
        w_is_content = w == LV_SIZE_CONTENT;
 8005886:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8005888:	4a98      	ldr	r2, [pc, #608]	@ (8005aec <lv_obj_refr_size+0x2d4>)
 800588a:	4293      	cmp	r3, r2
 800588c:	bf0c      	ite	eq
 800588e:	2301      	moveq	r3, #1
 8005890:	2300      	movne	r3, #0
 8005892:	f887 304b 	strb.w	r3, [r7, #75]	@ 0x4b
        w_is_pct = LV_COORD_IS_PCT(w);
 8005896:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8005898:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 800589c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80058a0:	d107      	bne.n	80058b2 <lv_obj_refr_size+0x9a>
 80058a2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80058a4:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 80058a8:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 80058ac:	dc01      	bgt.n	80058b2 <lv_obj_refr_size+0x9a>
 80058ae:	2301      	movs	r3, #1
 80058b0:	e000      	b.n	80058b4 <lv_obj_refr_size+0x9c>
 80058b2:	2300      	movs	r3, #0
 80058b4:	f887 304a 	strb.w	r3, [r7, #74]	@ 0x4a
 80058b8:	f897 304a 	ldrb.w	r3, [r7, #74]	@ 0x4a
 80058bc:	f003 0301 	and.w	r3, r3, #1
 80058c0:	f887 304a 	strb.w	r3, [r7, #74]	@ 0x4a
        int32_t parent_w = lv_obj_get_content_width(parent);
 80058c4:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 80058c6:	f000 fa4f 	bl	8005d68 <lv_obj_get_content_width>
 80058ca:	6478      	str	r0, [r7, #68]	@ 0x44

        if(w_is_content) {
 80058cc:	f897 304b 	ldrb.w	r3, [r7, #75]	@ 0x4b
 80058d0:	2b00      	cmp	r3, #0
 80058d2:	d004      	beq.n	80058de <lv_obj_refr_size+0xc6>
            w = calc_content_width(obj);
 80058d4:	6878      	ldr	r0, [r7, #4]
 80058d6:	f001 f851 	bl	800697c <calc_content_width>
 80058da:	6578      	str	r0, [r7, #84]	@ 0x54
 80058dc:	e047      	b.n	800596e <lv_obj_refr_size+0x156>
        }
        else if(w_is_pct) {
 80058de:	f897 304a 	ldrb.w	r3, [r7, #74]	@ 0x4a
 80058e2:	2b00      	cmp	r3, #0
 80058e4:	d043      	beq.n	800596e <lv_obj_refr_size+0x156>
            /*If parent has content size and the child has pct size
             *a circular dependency will occur. To solve it keep child size at zero */
            if(parent->w_layout == 0 && lv_obj_get_style_width(parent, 0) == LV_SIZE_CONTENT) {
 80058e6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80058e8:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 80058ec:	f003 0308 	and.w	r3, r3, #8
 80058f0:	b2db      	uxtb	r3, r3
 80058f2:	2b00      	cmp	r3, #0
 80058f4:	d114      	bne.n	8005920 <lv_obj_refr_size+0x108>
 80058f6:	2100      	movs	r1, #0
 80058f8:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 80058fa:	f7ff fc9e 	bl	800523a <lv_obj_get_style_width>
 80058fe:	4603      	mov	r3, r0
 8005900:	4a7a      	ldr	r2, [pc, #488]	@ (8005aec <lv_obj_refr_size+0x2d4>)
 8005902:	4293      	cmp	r3, r2
 8005904:	d10c      	bne.n	8005920 <lv_obj_refr_size+0x108>
                w = lv_obj_get_style_space_left(obj, 0) + lv_obj_get_style_space_right(obj, 0);
 8005906:	2100      	movs	r1, #0
 8005908:	6878      	ldr	r0, [r7, #4]
 800590a:	f7ff fe76 	bl	80055fa <lv_obj_get_style_space_left>
 800590e:	4604      	mov	r4, r0
 8005910:	2100      	movs	r1, #0
 8005912:	6878      	ldr	r0, [r7, #4]
 8005914:	f7ff fe94 	bl	8005640 <lv_obj_get_style_space_right>
 8005918:	4603      	mov	r3, r0
 800591a:	4423      	add	r3, r4
 800591c:	657b      	str	r3, [r7, #84]	@ 0x54
 800591e:	e026      	b.n	800596e <lv_obj_refr_size+0x156>
            }
            else {
                w = (LV_COORD_GET_PCT(w) * parent_w) / 100;
 8005920:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8005922:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005926:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 800592a:	dd05      	ble.n	8005938 <lv_obj_refr_size+0x120>
 800592c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800592e:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005932:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 8005936:	e002      	b.n	800593e <lv_obj_refr_size+0x126>
 8005938:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800593a:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 800593e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8005940:	fb02 f303 	mul.w	r3, r2, r3
 8005944:	4a6a      	ldr	r2, [pc, #424]	@ (8005af0 <lv_obj_refr_size+0x2d8>)
 8005946:	fb82 1203 	smull	r1, r2, r2, r3
 800594a:	1152      	asrs	r2, r2, #5
 800594c:	17db      	asrs	r3, r3, #31
 800594e:	1ad3      	subs	r3, r2, r3
 8005950:	657b      	str	r3, [r7, #84]	@ 0x54
                w -= lv_obj_get_style_margin_left(obj, LV_PART_MAIN) + lv_obj_get_style_margin_right(obj, LV_PART_MAIN);
 8005952:	2100      	movs	r1, #0
 8005954:	6878      	ldr	r0, [r7, #4]
 8005956:	f7ff fde7 	bl	8005528 <lv_obj_get_style_margin_left>
 800595a:	4604      	mov	r4, r0
 800595c:	2100      	movs	r1, #0
 800595e:	6878      	ldr	r0, [r7, #4]
 8005960:	f7ff fdf3 	bl	800554a <lv_obj_get_style_margin_right>
 8005964:	4603      	mov	r3, r0
 8005966:	4423      	add	r3, r4
 8005968:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800596a:	1ad3      	subs	r3, r2, r3
 800596c:	657b      	str	r3, [r7, #84]	@ 0x54
            }
        }

        int32_t minw = lv_obj_get_style_min_width(obj, LV_PART_MAIN);
 800596e:	2100      	movs	r1, #0
 8005970:	6878      	ldr	r0, [r7, #4]
 8005972:	f7ff fc73 	bl	800525c <lv_obj_get_style_min_width>
 8005976:	6438      	str	r0, [r7, #64]	@ 0x40
        int32_t maxw = lv_obj_get_style_max_width(obj, LV_PART_MAIN);
 8005978:	2100      	movs	r1, #0
 800597a:	6878      	ldr	r0, [r7, #4]
 800597c:	f7ff fc7f 	bl	800527e <lv_obj_get_style_max_width>
 8005980:	63f8      	str	r0, [r7, #60]	@ 0x3c
        w = lv_clamp_width(w, minw, maxw, parent_w);
 8005982:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8005984:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8005986:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 8005988:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 800598a:	f000 ff33 	bl	80067f4 <lv_clamp_width>
 800598e:	6578      	str	r0, [r7, #84]	@ 0x54
    }

    int32_t h;
    bool h_is_content = false;
 8005990:	2300      	movs	r3, #0
 8005992:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
    bool h_is_pct = false;
 8005996:	2300      	movs	r3, #0
 8005998:	f887 303a 	strb.w	r3, [r7, #58]	@ 0x3a
    if(obj->h_layout) {
 800599c:	687b      	ldr	r3, [r7, #4]
 800599e:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 80059a2:	f003 0304 	and.w	r3, r3, #4
 80059a6:	b2db      	uxtb	r3, r3
 80059a8:	2b00      	cmp	r3, #0
 80059aa:	d004      	beq.n	80059b6 <lv_obj_refr_size+0x19e>
        h = lv_obj_get_height(obj);
 80059ac:	6878      	ldr	r0, [r7, #4]
 80059ae:	f000 f9cd 	bl	8005d4c <lv_obj_get_height>
 80059b2:	6538      	str	r0, [r7, #80]	@ 0x50
 80059b4:	e089      	b.n	8005aca <lv_obj_refr_size+0x2b2>
    }
    else {
        h = lv_obj_get_style_height(obj, LV_PART_MAIN);
 80059b6:	2100      	movs	r1, #0
 80059b8:	6878      	ldr	r0, [r7, #4]
 80059ba:	f7ff fc71 	bl	80052a0 <lv_obj_get_style_height>
 80059be:	6538      	str	r0, [r7, #80]	@ 0x50
        h_is_content = h == LV_SIZE_CONTENT;
 80059c0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80059c2:	4a4a      	ldr	r2, [pc, #296]	@ (8005aec <lv_obj_refr_size+0x2d4>)
 80059c4:	4293      	cmp	r3, r2
 80059c6:	bf0c      	ite	eq
 80059c8:	2301      	moveq	r3, #1
 80059ca:	2300      	movne	r3, #0
 80059cc:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
        h_is_pct = LV_COORD_IS_PCT(h);
 80059d0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80059d2:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 80059d6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80059da:	d107      	bne.n	80059ec <lv_obj_refr_size+0x1d4>
 80059dc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80059de:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 80059e2:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 80059e6:	dc01      	bgt.n	80059ec <lv_obj_refr_size+0x1d4>
 80059e8:	2301      	movs	r3, #1
 80059ea:	e000      	b.n	80059ee <lv_obj_refr_size+0x1d6>
 80059ec:	2300      	movs	r3, #0
 80059ee:	f887 303a 	strb.w	r3, [r7, #58]	@ 0x3a
 80059f2:	f897 303a 	ldrb.w	r3, [r7, #58]	@ 0x3a
 80059f6:	f003 0301 	and.w	r3, r3, #1
 80059fa:	f887 303a 	strb.w	r3, [r7, #58]	@ 0x3a
        int32_t parent_h = lv_obj_get_content_height(parent);
 80059fe:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8005a00:	f000 f9cc 	bl	8005d9c <lv_obj_get_content_height>
 8005a04:	6378      	str	r0, [r7, #52]	@ 0x34

        if(h_is_content) {
 8005a06:	f897 303b 	ldrb.w	r3, [r7, #59]	@ 0x3b
 8005a0a:	2b00      	cmp	r3, #0
 8005a0c:	d004      	beq.n	8005a18 <lv_obj_refr_size+0x200>
            h = calc_content_height(obj);
 8005a0e:	6878      	ldr	r0, [r7, #4]
 8005a10:	f001 f910 	bl	8006c34 <calc_content_height>
 8005a14:	6538      	str	r0, [r7, #80]	@ 0x50
 8005a16:	e047      	b.n	8005aa8 <lv_obj_refr_size+0x290>
        }
        else if(h_is_pct) {
 8005a18:	f897 303a 	ldrb.w	r3, [r7, #58]	@ 0x3a
 8005a1c:	2b00      	cmp	r3, #0
 8005a1e:	d043      	beq.n	8005aa8 <lv_obj_refr_size+0x290>
            /*If parent has content size and the child has pct size
             *a circular dependency will occur. To solve it keep child size at zero */
            if(parent->h_layout == 0 && lv_obj_get_style_height(parent, 0) == LV_SIZE_CONTENT) {
 8005a20:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8005a22:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 8005a26:	f003 0304 	and.w	r3, r3, #4
 8005a2a:	b2db      	uxtb	r3, r3
 8005a2c:	2b00      	cmp	r3, #0
 8005a2e:	d114      	bne.n	8005a5a <lv_obj_refr_size+0x242>
 8005a30:	2100      	movs	r1, #0
 8005a32:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8005a34:	f7ff fc34 	bl	80052a0 <lv_obj_get_style_height>
 8005a38:	4603      	mov	r3, r0
 8005a3a:	4a2c      	ldr	r2, [pc, #176]	@ (8005aec <lv_obj_refr_size+0x2d4>)
 8005a3c:	4293      	cmp	r3, r2
 8005a3e:	d10c      	bne.n	8005a5a <lv_obj_refr_size+0x242>
                h = lv_obj_get_style_space_top(obj, 0) + lv_obj_get_style_space_bottom(obj, 0);
 8005a40:	2100      	movs	r1, #0
 8005a42:	6878      	ldr	r0, [r7, #4]
 8005a44:	f7ff fe1f 	bl	8005686 <lv_obj_get_style_space_top>
 8005a48:	4604      	mov	r4, r0
 8005a4a:	2100      	movs	r1, #0
 8005a4c:	6878      	ldr	r0, [r7, #4]
 8005a4e:	f7ff fe3d 	bl	80056cc <lv_obj_get_style_space_bottom>
 8005a52:	4603      	mov	r3, r0
 8005a54:	4423      	add	r3, r4
 8005a56:	653b      	str	r3, [r7, #80]	@ 0x50
 8005a58:	e026      	b.n	8005aa8 <lv_obj_refr_size+0x290>
            }
            else {
                h = (LV_COORD_GET_PCT(h) * parent_h) / 100;
 8005a5a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8005a5c:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005a60:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8005a64:	dd05      	ble.n	8005a72 <lv_obj_refr_size+0x25a>
 8005a66:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8005a68:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005a6c:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 8005a70:	e002      	b.n	8005a78 <lv_obj_refr_size+0x260>
 8005a72:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8005a74:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005a78:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8005a7a:	fb02 f303 	mul.w	r3, r2, r3
 8005a7e:	4a1c      	ldr	r2, [pc, #112]	@ (8005af0 <lv_obj_refr_size+0x2d8>)
 8005a80:	fb82 1203 	smull	r1, r2, r2, r3
 8005a84:	1152      	asrs	r2, r2, #5
 8005a86:	17db      	asrs	r3, r3, #31
 8005a88:	1ad3      	subs	r3, r2, r3
 8005a8a:	653b      	str	r3, [r7, #80]	@ 0x50
                h -= lv_obj_get_style_margin_top(obj, LV_PART_MAIN) + lv_obj_get_style_margin_bottom(obj, LV_PART_MAIN);
 8005a8c:	2100      	movs	r1, #0
 8005a8e:	6878      	ldr	r0, [r7, #4]
 8005a90:	f7ff fd28 	bl	80054e4 <lv_obj_get_style_margin_top>
 8005a94:	4604      	mov	r4, r0
 8005a96:	2100      	movs	r1, #0
 8005a98:	6878      	ldr	r0, [r7, #4]
 8005a9a:	f7ff fd34 	bl	8005506 <lv_obj_get_style_margin_bottom>
 8005a9e:	4603      	mov	r3, r0
 8005aa0:	4423      	add	r3, r4
 8005aa2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8005aa4:	1ad3      	subs	r3, r2, r3
 8005aa6:	653b      	str	r3, [r7, #80]	@ 0x50
            }
        }

        int32_t minh = lv_obj_get_style_min_height(obj, LV_PART_MAIN);
 8005aa8:	2100      	movs	r1, #0
 8005aaa:	6878      	ldr	r0, [r7, #4]
 8005aac:	f7ff fc09 	bl	80052c2 <lv_obj_get_style_min_height>
 8005ab0:	6338      	str	r0, [r7, #48]	@ 0x30
        int32_t maxh = lv_obj_get_style_max_height(obj, LV_PART_MAIN);
 8005ab2:	2100      	movs	r1, #0
 8005ab4:	6878      	ldr	r0, [r7, #4]
 8005ab6:	f7ff fc15 	bl	80052e4 <lv_obj_get_style_max_height>
 8005aba:	62f8      	str	r0, [r7, #44]	@ 0x2c
        h = lv_clamp_height(h, minh, maxh, parent_h);
 8005abc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8005abe:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8005ac0:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8005ac2:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8005ac4:	f000 fef8 	bl	80068b8 <lv_clamp_height>
 8005ac8:	6538      	str	r0, [r7, #80]	@ 0x50
    }

    /*Do nothing if the size is not changed*/
    /*It is very important else recursive resizing can occur without size change*/
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) return false;
 8005aca:	6878      	ldr	r0, [r7, #4]
 8005acc:	f000 f930 	bl	8005d30 <lv_obj_get_width>
 8005ad0:	4602      	mov	r2, r0
 8005ad2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8005ad4:	4293      	cmp	r3, r2
 8005ad6:	d10d      	bne.n	8005af4 <lv_obj_refr_size+0x2dc>
 8005ad8:	6878      	ldr	r0, [r7, #4]
 8005ada:	f000 f937 	bl	8005d4c <lv_obj_get_height>
 8005ade:	4602      	mov	r2, r0
 8005ae0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8005ae2:	4293      	cmp	r3, r2
 8005ae4:	d106      	bne.n	8005af4 <lv_obj_refr_size+0x2dc>
 8005ae6:	2300      	movs	r3, #0
 8005ae8:	e07c      	b.n	8005be4 <lv_obj_refr_size+0x3cc>
 8005aea:	bf00      	nop
 8005aec:	200007d1 	.word	0x200007d1
 8005af0:	51eb851f 	.word	0x51eb851f

    /*Invalidate the original area*/
    lv_obj_invalidate(obj);
 8005af4:	6878      	ldr	r0, [r7, #4]
 8005af6:	f000 fda3 	bl	8006640 <lv_obj_invalidate>

    /*Save the original coordinates*/
    lv_area_t ori;
    lv_obj_get_coords(obj, &ori);
 8005afa:	f107 0318 	add.w	r3, r7, #24
 8005afe:	4619      	mov	r1, r3
 8005b00:	6878      	ldr	r0, [r7, #4]
 8005b02:	f000 f906 	bl	8005d12 <lv_obj_get_coords>

    /*Check if the object inside the parent or not*/
    lv_area_t parent_fit_area;
    lv_obj_get_content_coords(parent, &parent_fit_area);
 8005b06:	f107 0308 	add.w	r3, r7, #8
 8005b0a:	4619      	mov	r1, r3
 8005b0c:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8005b0e:	f000 f95f 	bl	8005dd0 <lv_obj_get_content_coords>

    /*If the object is already out of the parent and its position is changes
     *surely the scrollbars also changes so invalidate them*/
    bool on1 = _lv_area_is_in(&ori, &parent_fit_area, 0);
 8005b12:	f107 0108 	add.w	r1, r7, #8
 8005b16:	f107 0318 	add.w	r3, r7, #24
 8005b1a:	2200      	movs	r2, #0
 8005b1c:	4618      	mov	r0, r3
 8005b1e:	f01c f837 	bl	8021b90 <_lv_area_is_in>
 8005b22:	4603      	mov	r3, r0
 8005b24:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
    if(!on1) lv_obj_scrollbar_invalidate(parent);
 8005b28:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 8005b2c:	f083 0301 	eor.w	r3, r3, #1
 8005b30:	b2db      	uxtb	r3, r3
 8005b32:	2b00      	cmp	r3, #0
 8005b34:	d002      	beq.n	8005b3c <lv_obj_refr_size+0x324>
 8005b36:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8005b38:	f002 fd08 	bl	800854c <lv_obj_scrollbar_invalidate>

    /*Set the length and height
     *Be sure the content is not scrolled in an invalid position on the new size*/
    obj->coords.y2 = obj->coords.y1 + h - 1;
 8005b3c:	687b      	ldr	r3, [r7, #4]
 8005b3e:	699a      	ldr	r2, [r3, #24]
 8005b40:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8005b42:	4413      	add	r3, r2
 8005b44:	1e5a      	subs	r2, r3, #1
 8005b46:	687b      	ldr	r3, [r7, #4]
 8005b48:	621a      	str	r2, [r3, #32]
    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) == LV_BASE_DIR_RTL) {
 8005b4a:	2100      	movs	r1, #0
 8005b4c:	6878      	ldr	r0, [r7, #4]
 8005b4e:	f7ff fd42 	bl	80055d6 <lv_obj_get_style_base_dir>
 8005b52:	4603      	mov	r3, r0
 8005b54:	2b01      	cmp	r3, #1
 8005b56:	d107      	bne.n	8005b68 <lv_obj_refr_size+0x350>
        obj->coords.x1 = obj->coords.x2 - w + 1;
 8005b58:	687b      	ldr	r3, [r7, #4]
 8005b5a:	69da      	ldr	r2, [r3, #28]
 8005b5c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8005b5e:	1ad3      	subs	r3, r2, r3
 8005b60:	1c5a      	adds	r2, r3, #1
 8005b62:	687b      	ldr	r3, [r7, #4]
 8005b64:	615a      	str	r2, [r3, #20]
 8005b66:	e006      	b.n	8005b76 <lv_obj_refr_size+0x35e>
    }
    else {
        obj->coords.x2 = obj->coords.x1 + w - 1;
 8005b68:	687b      	ldr	r3, [r7, #4]
 8005b6a:	695a      	ldr	r2, [r3, #20]
 8005b6c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8005b6e:	4413      	add	r3, r2
 8005b70:	1e5a      	subs	r2, r3, #1
 8005b72:	687b      	ldr	r3, [r7, #4]
 8005b74:	61da      	str	r2, [r3, #28]
    }

    /*Call the ancestor's event handler to the object with its new coordinates*/
    lv_obj_send_event(obj, LV_EVENT_SIZE_CHANGED, &ori);
 8005b76:	f107 0318 	add.w	r3, r7, #24
 8005b7a:	461a      	mov	r2, r3
 8005b7c:	212b      	movs	r1, #43	@ 0x2b
 8005b7e:	6878      	ldr	r0, [r7, #4]
 8005b80:	f7ff f948 	bl	8004e14 <lv_obj_send_event>

    /*Call the ancestor's event handler to the parent too*/
    lv_obj_send_event(parent, LV_EVENT_CHILD_CHANGED, obj);
 8005b84:	687a      	ldr	r2, [r7, #4]
 8005b86:	2124      	movs	r1, #36	@ 0x24
 8005b88:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8005b8a:	f7ff f943 	bl	8004e14 <lv_obj_send_event>

    /*Invalidate the new area*/
    lv_obj_invalidate(obj);
 8005b8e:	6878      	ldr	r0, [r7, #4]
 8005b90:	f000 fd56 	bl	8006640 <lv_obj_invalidate>

    obj->readjust_scroll_after_layout = 1;
 8005b94:	687a      	ldr	r2, [r7, #4]
 8005b96:	f892 302a 	ldrb.w	r3, [r2, #42]	@ 0x2a
 8005b9a:	f043 0302 	orr.w	r3, r3, #2
 8005b9e:	f882 302a 	strb.w	r3, [r2, #42]	@ 0x2a

    /*If the object was out of the parent invalidate the new scrollbar area too.
     *If it wasn't out of the parent but out now, also invalidate the scrollbars*/
    bool on2 = _lv_area_is_in(&obj->coords, &parent_fit_area, 0);
 8005ba2:	687b      	ldr	r3, [r7, #4]
 8005ba4:	3314      	adds	r3, #20
 8005ba6:	f107 0108 	add.w	r1, r7, #8
 8005baa:	2200      	movs	r2, #0
 8005bac:	4618      	mov	r0, r3
 8005bae:	f01b ffef 	bl	8021b90 <_lv_area_is_in>
 8005bb2:	4603      	mov	r3, r0
 8005bb4:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
    if(on1 || (!on1 && on2)) lv_obj_scrollbar_invalidate(parent);
 8005bb8:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 8005bbc:	2b00      	cmp	r3, #0
 8005bbe:	d10a      	bne.n	8005bd6 <lv_obj_refr_size+0x3be>
 8005bc0:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 8005bc4:	f083 0301 	eor.w	r3, r3, #1
 8005bc8:	b2db      	uxtb	r3, r3
 8005bca:	2b00      	cmp	r3, #0
 8005bcc:	d006      	beq.n	8005bdc <lv_obj_refr_size+0x3c4>
 8005bce:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 8005bd2:	2b00      	cmp	r3, #0
 8005bd4:	d002      	beq.n	8005bdc <lv_obj_refr_size+0x3c4>
 8005bd6:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8005bd8:	f002 fcb8 	bl	800854c <lv_obj_scrollbar_invalidate>

    lv_obj_refresh_ext_draw_size(obj);
 8005bdc:	6878      	ldr	r0, [r7, #4]
 8005bde:	f7ff f8c0 	bl	8004d62 <lv_obj_refresh_ext_draw_size>

    return true;
 8005be2:	2301      	movs	r3, #1
}
 8005be4:	4618      	mov	r0, r3
 8005be6:	375c      	adds	r7, #92	@ 0x5c
 8005be8:	46bd      	mov	sp, r7
 8005bea:	bd90      	pop	{r4, r7, pc}

08005bec <lv_obj_is_layout_positioned>:

    lv_obj_mark_layout_as_dirty(obj);
}

bool lv_obj_is_layout_positioned(const lv_obj_t * obj)
{
 8005bec:	b580      	push	{r7, lr}
 8005bee:	b084      	sub	sp, #16
 8005bf0:	af00      	add	r7, sp, #0
 8005bf2:	6078      	str	r0, [r7, #4]
    if(lv_obj_has_flag_any(obj, LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_FLOATING)) return false;
 8005bf4:	4910      	ldr	r1, [pc, #64]	@ (8005c38 <lv_obj_is_layout_positioned+0x4c>)
 8005bf6:	6878      	ldr	r0, [r7, #4]
 8005bf8:	f7fd f8be 	bl	8002d78 <lv_obj_has_flag_any>
 8005bfc:	4603      	mov	r3, r0
 8005bfe:	2b00      	cmp	r3, #0
 8005c00:	d001      	beq.n	8005c06 <lv_obj_is_layout_positioned+0x1a>
 8005c02:	2300      	movs	r3, #0
 8005c04:	e014      	b.n	8005c30 <lv_obj_is_layout_positioned+0x44>

    lv_obj_t * parent = lv_obj_get_parent(obj);
 8005c06:	6878      	ldr	r0, [r7, #4]
 8005c08:	f005 f914 	bl	800ae34 <lv_obj_get_parent>
 8005c0c:	60f8      	str	r0, [r7, #12]
    if(parent == NULL) return false;
 8005c0e:	68fb      	ldr	r3, [r7, #12]
 8005c10:	2b00      	cmp	r3, #0
 8005c12:	d101      	bne.n	8005c18 <lv_obj_is_layout_positioned+0x2c>
 8005c14:	2300      	movs	r3, #0
 8005c16:	e00b      	b.n	8005c30 <lv_obj_is_layout_positioned+0x44>

    uint32_t layout = lv_obj_get_style_layout(parent, LV_PART_MAIN);
 8005c18:	2100      	movs	r1, #0
 8005c1a:	68f8      	ldr	r0, [r7, #12]
 8005c1c:	f7ff fcc9 	bl	80055b2 <lv_obj_get_style_layout>
 8005c20:	4603      	mov	r3, r0
 8005c22:	60bb      	str	r3, [r7, #8]
    if(layout) return true;
 8005c24:	68bb      	ldr	r3, [r7, #8]
 8005c26:	2b00      	cmp	r3, #0
 8005c28:	d001      	beq.n	8005c2e <lv_obj_is_layout_positioned+0x42>
 8005c2a:	2301      	movs	r3, #1
 8005c2c:	e000      	b.n	8005c30 <lv_obj_is_layout_positioned+0x44>
    else return false;
 8005c2e:	2300      	movs	r3, #0
}
 8005c30:	4618      	mov	r0, r3
 8005c32:	3710      	adds	r7, #16
 8005c34:	46bd      	mov	sp, r7
 8005c36:	bd80      	pop	{r7, pc}
 8005c38:	00060001 	.word	0x00060001

08005c3c <lv_obj_mark_layout_as_dirty>:

void lv_obj_mark_layout_as_dirty(lv_obj_t * obj)
{
 8005c3c:	b580      	push	{r7, lr}
 8005c3e:	b084      	sub	sp, #16
 8005c40:	af00      	add	r7, sp, #0
 8005c42:	6078      	str	r0, [r7, #4]
    obj->layout_inv = 1;
 8005c44:	687a      	ldr	r2, [r7, #4]
 8005c46:	f892 302a 	ldrb.w	r3, [r2, #42]	@ 0x2a
 8005c4a:	f043 0301 	orr.w	r3, r3, #1
 8005c4e:	f882 302a 	strb.w	r3, [r2, #42]	@ 0x2a

    /*Mark the screen as dirty too to mark that there is something to do on this screen*/
    lv_obj_t * scr = lv_obj_get_screen(obj);
 8005c52:	6878      	ldr	r0, [r7, #4]
 8005c54:	f005 f89b 	bl	800ad8e <lv_obj_get_screen>
 8005c58:	60f8      	str	r0, [r7, #12]
    scr->scr_layout_inv = 1;
 8005c5a:	68fa      	ldr	r2, [r7, #12]
 8005c5c:	f892 302a 	ldrb.w	r3, [r2, #42]	@ 0x2a
 8005c60:	f043 0304 	orr.w	r3, r3, #4
 8005c64:	f882 302a 	strb.w	r3, [r2, #42]	@ 0x2a

    /*Make the display refreshing*/
    lv_display_t * disp = lv_obj_get_display(scr);
 8005c68:	68f8      	ldr	r0, [r7, #12]
 8005c6a:	f005 f8a5 	bl	800adb8 <lv_obj_get_display>
 8005c6e:	60b8      	str	r0, [r7, #8]
    lv_display_send_event(disp, LV_EVENT_REFR_REQUEST, NULL);
 8005c70:	2200      	movs	r2, #0
 8005c72:	2132      	movs	r1, #50	@ 0x32
 8005c74:	68b8      	ldr	r0, [r7, #8]
 8005c76:	f005 fb34 	bl	800b2e2 <lv_display_send_event>
}
 8005c7a:	bf00      	nop
 8005c7c:	3710      	adds	r7, #16
 8005c7e:	46bd      	mov	sp, r7
 8005c80:	bd80      	pop	{r7, pc}
	...

08005c84 <lv_obj_update_layout>:

void lv_obj_update_layout(const lv_obj_t * obj)
{
 8005c84:	b580      	push	{r7, lr}
 8005c86:	b084      	sub	sp, #16
 8005c88:	af00      	add	r7, sp, #0
 8005c8a:	6078      	str	r0, [r7, #4]
    if(update_layout_mutex) {
 8005c8c:	4b14      	ldr	r3, [pc, #80]	@ (8005ce0 <lv_obj_update_layout+0x5c>)
 8005c8e:	f893 3060 	ldrb.w	r3, [r3, #96]	@ 0x60
 8005c92:	2b00      	cmp	r3, #0
 8005c94:	d11f      	bne.n	8005cd6 <lv_obj_update_layout+0x52>
        LV_LOG_TRACE("Already running, returning");
        return;
    }
    LV_PROFILER_BEGIN;
    update_layout_mutex = true;
 8005c96:	4b12      	ldr	r3, [pc, #72]	@ (8005ce0 <lv_obj_update_layout+0x5c>)
 8005c98:	2201      	movs	r2, #1
 8005c9a:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60

    lv_obj_t * scr = lv_obj_get_screen(obj);
 8005c9e:	6878      	ldr	r0, [r7, #4]
 8005ca0:	f005 f875 	bl	800ad8e <lv_obj_get_screen>
 8005ca4:	60f8      	str	r0, [r7, #12]
    /*Repeat until there are no more layout invalidations*/
    while(scr->scr_layout_inv) {
 8005ca6:	e009      	b.n	8005cbc <lv_obj_update_layout+0x38>
        LV_LOG_TRACE("Layout update begin");
        scr->scr_layout_inv = 0;
 8005ca8:	68fa      	ldr	r2, [r7, #12]
 8005caa:	f892 302a 	ldrb.w	r3, [r2, #42]	@ 0x2a
 8005cae:	f36f 0382 	bfc	r3, #2, #1
 8005cb2:	f882 302a 	strb.w	r3, [r2, #42]	@ 0x2a
        layout_update_core(scr);
 8005cb6:	68f8      	ldr	r0, [r7, #12]
 8005cb8:	f001 f870 	bl	8006d9c <layout_update_core>
    while(scr->scr_layout_inv) {
 8005cbc:	68fb      	ldr	r3, [r7, #12]
 8005cbe:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
 8005cc2:	f003 0304 	and.w	r3, r3, #4
 8005cc6:	b2db      	uxtb	r3, r3
 8005cc8:	2b00      	cmp	r3, #0
 8005cca:	d1ed      	bne.n	8005ca8 <lv_obj_update_layout+0x24>
        LV_LOG_TRACE("Layout update end");
    }

    update_layout_mutex = false;
 8005ccc:	4b04      	ldr	r3, [pc, #16]	@ (8005ce0 <lv_obj_update_layout+0x5c>)
 8005cce:	2200      	movs	r2, #0
 8005cd0:	f883 2060 	strb.w	r2, [r3, #96]	@ 0x60
 8005cd4:	e000      	b.n	8005cd8 <lv_obj_update_layout+0x54>
        return;
 8005cd6:	bf00      	nop
    LV_PROFILER_END;
}
 8005cd8:	3710      	adds	r7, #16
 8005cda:	46bd      	mov	sp, r7
 8005cdc:	bd80      	pop	{r7, pc}
 8005cde:	bf00      	nop
 8005ce0:	2000009c 	.word	0x2000009c

08005ce4 <lv_obj_align>:
{
    lv_obj_set_style_align(obj, align, 0);
}

void lv_obj_align(lv_obj_t * obj, lv_align_t align, int32_t x_ofs, int32_t y_ofs)
{
 8005ce4:	b580      	push	{r7, lr}
 8005ce6:	b084      	sub	sp, #16
 8005ce8:	af00      	add	r7, sp, #0
 8005cea:	60f8      	str	r0, [r7, #12]
 8005cec:	607a      	str	r2, [r7, #4]
 8005cee:	603b      	str	r3, [r7, #0]
 8005cf0:	460b      	mov	r3, r1
 8005cf2:	72fb      	strb	r3, [r7, #11]
    lv_obj_set_style_align(obj, align, 0);
 8005cf4:	7afb      	ldrb	r3, [r7, #11]
 8005cf6:	2200      	movs	r2, #0
 8005cf8:	4619      	mov	r1, r3
 8005cfa:	68f8      	ldr	r0, [r7, #12]
 8005cfc:	f004 fffc 	bl	800acf8 <lv_obj_set_style_align>
    lv_obj_set_pos(obj, x_ofs, y_ofs);
 8005d00:	683a      	ldr	r2, [r7, #0]
 8005d02:	6879      	ldr	r1, [r7, #4]
 8005d04:	68f8      	ldr	r0, [r7, #12]
 8005d06:	f7ff fd32 	bl	800576e <lv_obj_set_pos>
}
 8005d0a:	bf00      	nop
 8005d0c:	3710      	adds	r7, #16
 8005d0e:	46bd      	mov	sp, r7
 8005d10:	bd80      	pop	{r7, pc}

08005d12 <lv_obj_get_coords>:
    lv_obj_set_pos(obj, x, y);

}

void lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * coords)
{
 8005d12:	b580      	push	{r7, lr}
 8005d14:	b082      	sub	sp, #8
 8005d16:	af00      	add	r7, sp, #0
 8005d18:	6078      	str	r0, [r7, #4]
 8005d1a:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    lv_area_copy(coords, &obj->coords);
 8005d1c:	687b      	ldr	r3, [r7, #4]
 8005d1e:	3314      	adds	r3, #20
 8005d20:	4619      	mov	r1, r3
 8005d22:	6838      	ldr	r0, [r7, #0]
 8005d24:	f7ff fa4e 	bl	80051c4 <lv_area_copy>
}
 8005d28:	bf00      	nop
 8005d2a:	3708      	adds	r7, #8
 8005d2c:	46bd      	mov	sp, r7
 8005d2e:	bd80      	pop	{r7, pc}

08005d30 <lv_obj_get_width>:
{
    return lv_obj_get_style_y(obj, LV_PART_MAIN);
}

int32_t lv_obj_get_width(const lv_obj_t * obj)
{
 8005d30:	b580      	push	{r7, lr}
 8005d32:	b082      	sub	sp, #8
 8005d34:	af00      	add	r7, sp, #0
 8005d36:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    return lv_area_get_width(&obj->coords);
 8005d38:	687b      	ldr	r3, [r7, #4]
 8005d3a:	3314      	adds	r3, #20
 8005d3c:	4618      	mov	r0, r3
 8005d3e:	f7ff fa5c 	bl	80051fa <lv_area_get_width>
 8005d42:	4603      	mov	r3, r0
}
 8005d44:	4618      	mov	r0, r3
 8005d46:	3708      	adds	r7, #8
 8005d48:	46bd      	mov	sp, r7
 8005d4a:	bd80      	pop	{r7, pc}

08005d4c <lv_obj_get_height>:

int32_t lv_obj_get_height(const lv_obj_t * obj)
{
 8005d4c:	b580      	push	{r7, lr}
 8005d4e:	b082      	sub	sp, #8
 8005d50:	af00      	add	r7, sp, #0
 8005d52:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    return lv_area_get_height(&obj->coords);
 8005d54:	687b      	ldr	r3, [r7, #4]
 8005d56:	3314      	adds	r3, #20
 8005d58:	4618      	mov	r0, r3
 8005d5a:	f7ff fa5e 	bl	800521a <lv_area_get_height>
 8005d5e:	4603      	mov	r3, r0
}
 8005d60:	4618      	mov	r0, r3
 8005d62:	3708      	adds	r7, #8
 8005d64:	46bd      	mov	sp, r7
 8005d66:	bd80      	pop	{r7, pc}

08005d68 <lv_obj_get_content_width>:

int32_t lv_obj_get_content_width(const lv_obj_t * obj)
{
 8005d68:	b580      	push	{r7, lr}
 8005d6a:	b084      	sub	sp, #16
 8005d6c:	af00      	add	r7, sp, #0
 8005d6e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    int32_t left = lv_obj_get_style_space_left(obj, LV_PART_MAIN);
 8005d70:	2100      	movs	r1, #0
 8005d72:	6878      	ldr	r0, [r7, #4]
 8005d74:	f7ff fc41 	bl	80055fa <lv_obj_get_style_space_left>
 8005d78:	60f8      	str	r0, [r7, #12]
    int32_t right = lv_obj_get_style_space_right(obj, LV_PART_MAIN);
 8005d7a:	2100      	movs	r1, #0
 8005d7c:	6878      	ldr	r0, [r7, #4]
 8005d7e:	f7ff fc5f 	bl	8005640 <lv_obj_get_style_space_right>
 8005d82:	60b8      	str	r0, [r7, #8]

    return lv_obj_get_width(obj) - left - right;
 8005d84:	6878      	ldr	r0, [r7, #4]
 8005d86:	f7ff ffd3 	bl	8005d30 <lv_obj_get_width>
 8005d8a:	4602      	mov	r2, r0
 8005d8c:	68fb      	ldr	r3, [r7, #12]
 8005d8e:	1ad2      	subs	r2, r2, r3
 8005d90:	68bb      	ldr	r3, [r7, #8]
 8005d92:	1ad3      	subs	r3, r2, r3
}
 8005d94:	4618      	mov	r0, r3
 8005d96:	3710      	adds	r7, #16
 8005d98:	46bd      	mov	sp, r7
 8005d9a:	bd80      	pop	{r7, pc}

08005d9c <lv_obj_get_content_height>:

int32_t lv_obj_get_content_height(const lv_obj_t * obj)
{
 8005d9c:	b580      	push	{r7, lr}
 8005d9e:	b084      	sub	sp, #16
 8005da0:	af00      	add	r7, sp, #0
 8005da2:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    int32_t top = lv_obj_get_style_space_top(obj, LV_PART_MAIN);
 8005da4:	2100      	movs	r1, #0
 8005da6:	6878      	ldr	r0, [r7, #4]
 8005da8:	f7ff fc6d 	bl	8005686 <lv_obj_get_style_space_top>
 8005dac:	60f8      	str	r0, [r7, #12]
    int32_t bottom = lv_obj_get_style_space_bottom(obj, LV_PART_MAIN);
 8005dae:	2100      	movs	r1, #0
 8005db0:	6878      	ldr	r0, [r7, #4]
 8005db2:	f7ff fc8b 	bl	80056cc <lv_obj_get_style_space_bottom>
 8005db6:	60b8      	str	r0, [r7, #8]

    return lv_obj_get_height(obj) - top - bottom;
 8005db8:	6878      	ldr	r0, [r7, #4]
 8005dba:	f7ff ffc7 	bl	8005d4c <lv_obj_get_height>
 8005dbe:	4602      	mov	r2, r0
 8005dc0:	68fb      	ldr	r3, [r7, #12]
 8005dc2:	1ad2      	subs	r2, r2, r3
 8005dc4:	68bb      	ldr	r3, [r7, #8]
 8005dc6:	1ad3      	subs	r3, r2, r3
}
 8005dc8:	4618      	mov	r0, r3
 8005dca:	3710      	adds	r7, #16
 8005dcc:	46bd      	mov	sp, r7
 8005dce:	bd80      	pop	{r7, pc}

08005dd0 <lv_obj_get_content_coords>:

void lv_obj_get_content_coords(const lv_obj_t * obj, lv_area_t * area)
{
 8005dd0:	b580      	push	{r7, lr}
 8005dd2:	b082      	sub	sp, #8
 8005dd4:	af00      	add	r7, sp, #0
 8005dd6:	6078      	str	r0, [r7, #4]
 8005dd8:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    lv_obj_get_coords(obj, area);
 8005dda:	6839      	ldr	r1, [r7, #0]
 8005ddc:	6878      	ldr	r0, [r7, #4]
 8005dde:	f7ff ff98 	bl	8005d12 <lv_obj_get_coords>
    area->x1 += lv_obj_get_style_space_left(obj, LV_PART_MAIN);
 8005de2:	2100      	movs	r1, #0
 8005de4:	6878      	ldr	r0, [r7, #4]
 8005de6:	f7ff fc08 	bl	80055fa <lv_obj_get_style_space_left>
 8005dea:	4602      	mov	r2, r0
 8005dec:	683b      	ldr	r3, [r7, #0]
 8005dee:	681b      	ldr	r3, [r3, #0]
 8005df0:	441a      	add	r2, r3
 8005df2:	683b      	ldr	r3, [r7, #0]
 8005df4:	601a      	str	r2, [r3, #0]
    area->x2 -= lv_obj_get_style_space_right(obj, LV_PART_MAIN);
 8005df6:	2100      	movs	r1, #0
 8005df8:	6878      	ldr	r0, [r7, #4]
 8005dfa:	f7ff fc21 	bl	8005640 <lv_obj_get_style_space_right>
 8005dfe:	4602      	mov	r2, r0
 8005e00:	683b      	ldr	r3, [r7, #0]
 8005e02:	689b      	ldr	r3, [r3, #8]
 8005e04:	1a9a      	subs	r2, r3, r2
 8005e06:	683b      	ldr	r3, [r7, #0]
 8005e08:	609a      	str	r2, [r3, #8]
    area->y1 += lv_obj_get_style_space_top(obj, LV_PART_MAIN);
 8005e0a:	2100      	movs	r1, #0
 8005e0c:	6878      	ldr	r0, [r7, #4]
 8005e0e:	f7ff fc3a 	bl	8005686 <lv_obj_get_style_space_top>
 8005e12:	4602      	mov	r2, r0
 8005e14:	683b      	ldr	r3, [r7, #0]
 8005e16:	685b      	ldr	r3, [r3, #4]
 8005e18:	441a      	add	r2, r3
 8005e1a:	683b      	ldr	r3, [r7, #0]
 8005e1c:	605a      	str	r2, [r3, #4]
    area->y2 -= lv_obj_get_style_space_bottom(obj, LV_PART_MAIN);
 8005e1e:	2100      	movs	r1, #0
 8005e20:	6878      	ldr	r0, [r7, #4]
 8005e22:	f7ff fc53 	bl	80056cc <lv_obj_get_style_space_bottom>
 8005e26:	4602      	mov	r2, r0
 8005e28:	683b      	ldr	r3, [r7, #0]
 8005e2a:	68db      	ldr	r3, [r3, #12]
 8005e2c:	1a9a      	subs	r2, r3, r2
 8005e2e:	683b      	ldr	r3, [r7, #0]
 8005e30:	60da      	str	r2, [r3, #12]

}
 8005e32:	bf00      	nop
 8005e34:	3708      	adds	r7, #8
 8005e36:	46bd      	mov	sp, r7
 8005e38:	bd80      	pop	{r7, pc}
	...

08005e3c <lv_obj_get_self_width>:

int32_t lv_obj_get_self_width(const lv_obj_t * obj)
{
 8005e3c:	b580      	push	{r7, lr}
 8005e3e:	b084      	sub	sp, #16
 8005e40:	af00      	add	r7, sp, #0
 8005e42:	6078      	str	r0, [r7, #4]
    lv_point_t p = {0, LV_COORD_MIN};
 8005e44:	2300      	movs	r3, #0
 8005e46:	60bb      	str	r3, [r7, #8]
 8005e48:	4b06      	ldr	r3, [pc, #24]	@ (8005e64 <lv_obj_get_self_width+0x28>)
 8005e4a:	60fb      	str	r3, [r7, #12]
    lv_obj_send_event((lv_obj_t *)obj, LV_EVENT_GET_SELF_SIZE, &p);
 8005e4c:	f107 0308 	add.w	r3, r7, #8
 8005e50:	461a      	mov	r2, r3
 8005e52:	212e      	movs	r1, #46	@ 0x2e
 8005e54:	6878      	ldr	r0, [r7, #4]
 8005e56:	f7fe ffdd 	bl	8004e14 <lv_obj_send_event>
    return p.x;
 8005e5a:	68bb      	ldr	r3, [r7, #8]
}
 8005e5c:	4618      	mov	r0, r3
 8005e5e:	3710      	adds	r7, #16
 8005e60:	46bd      	mov	sp, r7
 8005e62:	bd80      	pop	{r7, pc}
 8005e64:	e0000001 	.word	0xe0000001

08005e68 <lv_obj_get_self_height>:

int32_t lv_obj_get_self_height(const lv_obj_t * obj)
{
 8005e68:	b580      	push	{r7, lr}
 8005e6a:	b084      	sub	sp, #16
 8005e6c:	af00      	add	r7, sp, #0
 8005e6e:	6078      	str	r0, [r7, #4]
    lv_point_t p = {LV_COORD_MIN, 0};
 8005e70:	4b07      	ldr	r3, [pc, #28]	@ (8005e90 <lv_obj_get_self_height+0x28>)
 8005e72:	60bb      	str	r3, [r7, #8]
 8005e74:	2300      	movs	r3, #0
 8005e76:	60fb      	str	r3, [r7, #12]
    lv_obj_send_event((lv_obj_t *)obj, LV_EVENT_GET_SELF_SIZE, &p);
 8005e78:	f107 0308 	add.w	r3, r7, #8
 8005e7c:	461a      	mov	r2, r3
 8005e7e:	212e      	movs	r1, #46	@ 0x2e
 8005e80:	6878      	ldr	r0, [r7, #4]
 8005e82:	f7fe ffc7 	bl	8004e14 <lv_obj_send_event>
    return p.y;
 8005e86:	68fb      	ldr	r3, [r7, #12]
}
 8005e88:	4618      	mov	r0, r3
 8005e8a:	3710      	adds	r7, #16
 8005e8c:	46bd      	mov	sp, r7
 8005e8e:	bd80      	pop	{r7, pc}
 8005e90:	e0000001 	.word	0xe0000001

08005e94 <lv_obj_refresh_self_size>:

bool lv_obj_refresh_self_size(lv_obj_t * obj)
{
 8005e94:	b580      	push	{r7, lr}
 8005e96:	b084      	sub	sp, #16
 8005e98:	af00      	add	r7, sp, #0
 8005e9a:	6078      	str	r0, [r7, #4]
    int32_t w_set = lv_obj_get_style_width(obj, LV_PART_MAIN);
 8005e9c:	2100      	movs	r1, #0
 8005e9e:	6878      	ldr	r0, [r7, #4]
 8005ea0:	f7ff f9cb 	bl	800523a <lv_obj_get_style_width>
 8005ea4:	60f8      	str	r0, [r7, #12]
    int32_t h_set = lv_obj_get_style_height(obj, LV_PART_MAIN);
 8005ea6:	2100      	movs	r1, #0
 8005ea8:	6878      	ldr	r0, [r7, #4]
 8005eaa:	f7ff f9f9 	bl	80052a0 <lv_obj_get_style_height>
 8005eae:	60b8      	str	r0, [r7, #8]
    if(w_set != LV_SIZE_CONTENT && h_set != LV_SIZE_CONTENT) return false;
 8005eb0:	68fb      	ldr	r3, [r7, #12]
 8005eb2:	4a08      	ldr	r2, [pc, #32]	@ (8005ed4 <lv_obj_refresh_self_size+0x40>)
 8005eb4:	4293      	cmp	r3, r2
 8005eb6:	d005      	beq.n	8005ec4 <lv_obj_refresh_self_size+0x30>
 8005eb8:	68bb      	ldr	r3, [r7, #8]
 8005eba:	4a06      	ldr	r2, [pc, #24]	@ (8005ed4 <lv_obj_refresh_self_size+0x40>)
 8005ebc:	4293      	cmp	r3, r2
 8005ebe:	d001      	beq.n	8005ec4 <lv_obj_refresh_self_size+0x30>
 8005ec0:	2300      	movs	r3, #0
 8005ec2:	e003      	b.n	8005ecc <lv_obj_refresh_self_size+0x38>

    lv_obj_mark_layout_as_dirty(obj);
 8005ec4:	6878      	ldr	r0, [r7, #4]
 8005ec6:	f7ff feb9 	bl	8005c3c <lv_obj_mark_layout_as_dirty>
    return true;
 8005eca:	2301      	movs	r3, #1
}
 8005ecc:	4618      	mov	r0, r3
 8005ece:	3710      	adds	r7, #16
 8005ed0:	46bd      	mov	sp, r7
 8005ed2:	bd80      	pop	{r7, pc}
 8005ed4:	200007d1 	.word	0x200007d1

08005ed8 <lv_obj_refr_pos>:

void lv_obj_refr_pos(lv_obj_t * obj)
{
 8005ed8:	b580      	push	{r7, lr}
 8005eda:	b08c      	sub	sp, #48	@ 0x30
 8005edc:	af00      	add	r7, sp, #0
 8005ede:	6078      	str	r0, [r7, #4]
    if(lv_obj_is_layout_positioned(obj)) return;
 8005ee0:	6878      	ldr	r0, [r7, #4]
 8005ee2:	f7ff fe83 	bl	8005bec <lv_obj_is_layout_positioned>
 8005ee6:	4603      	mov	r3, r0
 8005ee8:	2b00      	cmp	r3, #0
 8005eea:	f040 8184 	bne.w	80061f6 <lv_obj_refr_pos+0x31e>

    lv_obj_t * parent = lv_obj_get_parent(obj);
 8005eee:	6878      	ldr	r0, [r7, #4]
 8005ef0:	f004 ffa0 	bl	800ae34 <lv_obj_get_parent>
 8005ef4:	61b8      	str	r0, [r7, #24]
    int32_t x = lv_obj_get_style_x(obj, LV_PART_MAIN);
 8005ef6:	2100      	movs	r1, #0
 8005ef8:	6878      	ldr	r0, [r7, #4]
 8005efa:	f7ff fa04 	bl	8005306 <lv_obj_get_style_x>
 8005efe:	62f8      	str	r0, [r7, #44]	@ 0x2c
    int32_t y = lv_obj_get_style_y(obj, LV_PART_MAIN);
 8005f00:	2100      	movs	r1, #0
 8005f02:	6878      	ldr	r0, [r7, #4]
 8005f04:	f7ff fa10 	bl	8005328 <lv_obj_get_style_y>
 8005f08:	62b8      	str	r0, [r7, #40]	@ 0x28

    if(parent == NULL) {
 8005f0a:	69bb      	ldr	r3, [r7, #24]
 8005f0c:	2b00      	cmp	r3, #0
 8005f0e:	d105      	bne.n	8005f1c <lv_obj_refr_pos+0x44>
        lv_obj_move_to(obj, x, y);
 8005f10:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8005f12:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8005f14:	6878      	ldr	r0, [r7, #4]
 8005f16:	f000 f975 	bl	8006204 <lv_obj_move_to>
        return;
 8005f1a:	e16d      	b.n	80061f8 <lv_obj_refr_pos+0x320>
    }

    /*Handle percentage value*/
    int32_t pw = lv_obj_get_content_width(parent);
 8005f1c:	69b8      	ldr	r0, [r7, #24]
 8005f1e:	f7ff ff23 	bl	8005d68 <lv_obj_get_content_width>
 8005f22:	6178      	str	r0, [r7, #20]
    int32_t ph = lv_obj_get_content_height(parent);
 8005f24:	69b8      	ldr	r0, [r7, #24]
 8005f26:	f7ff ff39 	bl	8005d9c <lv_obj_get_content_height>
 8005f2a:	6138      	str	r0, [r7, #16]
    if(LV_COORD_IS_PCT(x)) x = (pw * LV_COORD_GET_PCT(x)) / 100;
 8005f2c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8005f2e:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 8005f32:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8005f36:	d11e      	bne.n	8005f76 <lv_obj_refr_pos+0x9e>
 8005f38:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8005f3a:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005f3e:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 8005f42:	dc18      	bgt.n	8005f76 <lv_obj_refr_pos+0x9e>
 8005f44:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8005f46:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005f4a:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8005f4e:	dd05      	ble.n	8005f5c <lv_obj_refr_pos+0x84>
 8005f50:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8005f52:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005f56:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 8005f5a:	e002      	b.n	8005f62 <lv_obj_refr_pos+0x8a>
 8005f5c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8005f5e:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005f62:	697a      	ldr	r2, [r7, #20]
 8005f64:	fb02 f303 	mul.w	r3, r2, r3
 8005f68:	4aa5      	ldr	r2, [pc, #660]	@ (8006200 <lv_obj_refr_pos+0x328>)
 8005f6a:	fb82 1203 	smull	r1, r2, r2, r3
 8005f6e:	1152      	asrs	r2, r2, #5
 8005f70:	17db      	asrs	r3, r3, #31
 8005f72:	1ad3      	subs	r3, r2, r3
 8005f74:	62fb      	str	r3, [r7, #44]	@ 0x2c
    if(LV_COORD_IS_PCT(y)) y = (ph * LV_COORD_GET_PCT(y)) / 100;
 8005f76:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8005f78:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 8005f7c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8005f80:	d11e      	bne.n	8005fc0 <lv_obj_refr_pos+0xe8>
 8005f82:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8005f84:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005f88:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 8005f8c:	dc18      	bgt.n	8005fc0 <lv_obj_refr_pos+0xe8>
 8005f8e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8005f90:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005f94:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8005f98:	dd05      	ble.n	8005fa6 <lv_obj_refr_pos+0xce>
 8005f9a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8005f9c:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005fa0:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 8005fa4:	e002      	b.n	8005fac <lv_obj_refr_pos+0xd4>
 8005fa6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8005fa8:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005fac:	693a      	ldr	r2, [r7, #16]
 8005fae:	fb02 f303 	mul.w	r3, r2, r3
 8005fb2:	4a93      	ldr	r2, [pc, #588]	@ (8006200 <lv_obj_refr_pos+0x328>)
 8005fb4:	fb82 1203 	smull	r1, r2, r2, r3
 8005fb8:	1152      	asrs	r2, r2, #5
 8005fba:	17db      	asrs	r3, r3, #31
 8005fbc:	1ad3      	subs	r3, r2, r3
 8005fbe:	62bb      	str	r3, [r7, #40]	@ 0x28

    /*Handle percentage value of translate*/
    int32_t tr_x = lv_obj_get_style_translate_x(obj, LV_PART_MAIN);
 8005fc0:	2100      	movs	r1, #0
 8005fc2:	6878      	ldr	r0, [r7, #4]
 8005fc4:	f7ff f9d3 	bl	800536e <lv_obj_get_style_translate_x>
 8005fc8:	6278      	str	r0, [r7, #36]	@ 0x24
    int32_t tr_y = lv_obj_get_style_translate_y(obj, LV_PART_MAIN);
 8005fca:	2100      	movs	r1, #0
 8005fcc:	6878      	ldr	r0, [r7, #4]
 8005fce:	f7ff f9df 	bl	8005390 <lv_obj_get_style_translate_y>
 8005fd2:	6238      	str	r0, [r7, #32]
    int32_t w = lv_obj_get_width(obj);
 8005fd4:	6878      	ldr	r0, [r7, #4]
 8005fd6:	f7ff feab 	bl	8005d30 <lv_obj_get_width>
 8005fda:	60f8      	str	r0, [r7, #12]
    int32_t h = lv_obj_get_height(obj);
 8005fdc:	6878      	ldr	r0, [r7, #4]
 8005fde:	f7ff feb5 	bl	8005d4c <lv_obj_get_height>
 8005fe2:	60b8      	str	r0, [r7, #8]
    if(LV_COORD_IS_PCT(tr_x)) tr_x = (w * LV_COORD_GET_PCT(tr_x)) / 100;
 8005fe4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005fe6:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 8005fea:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8005fee:	d11e      	bne.n	800602e <lv_obj_refr_pos+0x156>
 8005ff0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005ff2:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8005ff6:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 8005ffa:	dc18      	bgt.n	800602e <lv_obj_refr_pos+0x156>
 8005ffc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8005ffe:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006002:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8006006:	dd05      	ble.n	8006014 <lv_obj_refr_pos+0x13c>
 8006008:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800600a:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 800600e:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 8006012:	e002      	b.n	800601a <lv_obj_refr_pos+0x142>
 8006014:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006016:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 800601a:	68fa      	ldr	r2, [r7, #12]
 800601c:	fb02 f303 	mul.w	r3, r2, r3
 8006020:	4a77      	ldr	r2, [pc, #476]	@ (8006200 <lv_obj_refr_pos+0x328>)
 8006022:	fb82 1203 	smull	r1, r2, r2, r3
 8006026:	1152      	asrs	r2, r2, #5
 8006028:	17db      	asrs	r3, r3, #31
 800602a:	1ad3      	subs	r3, r2, r3
 800602c:	627b      	str	r3, [r7, #36]	@ 0x24
    if(LV_COORD_IS_PCT(tr_y)) tr_y = (h * LV_COORD_GET_PCT(tr_y)) / 100;
 800602e:	6a3b      	ldr	r3, [r7, #32]
 8006030:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 8006034:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8006038:	d11e      	bne.n	8006078 <lv_obj_refr_pos+0x1a0>
 800603a:	6a3b      	ldr	r3, [r7, #32]
 800603c:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006040:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 8006044:	dc18      	bgt.n	8006078 <lv_obj_refr_pos+0x1a0>
 8006046:	6a3b      	ldr	r3, [r7, #32]
 8006048:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 800604c:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8006050:	dd05      	ble.n	800605e <lv_obj_refr_pos+0x186>
 8006052:	6a3b      	ldr	r3, [r7, #32]
 8006054:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006058:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 800605c:	e002      	b.n	8006064 <lv_obj_refr_pos+0x18c>
 800605e:	6a3b      	ldr	r3, [r7, #32]
 8006060:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006064:	68ba      	ldr	r2, [r7, #8]
 8006066:	fb02 f303 	mul.w	r3, r2, r3
 800606a:	4a65      	ldr	r2, [pc, #404]	@ (8006200 <lv_obj_refr_pos+0x328>)
 800606c:	fb82 1203 	smull	r1, r2, r2, r3
 8006070:	1152      	asrs	r2, r2, #5
 8006072:	17db      	asrs	r3, r3, #31
 8006074:	1ad3      	subs	r3, r2, r3
 8006076:	623b      	str	r3, [r7, #32]

    /*Use the translation*/
    x += tr_x;
 8006078:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800607a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800607c:	4413      	add	r3, r2
 800607e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    y += tr_y;
 8006080:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8006082:	6a3b      	ldr	r3, [r7, #32]
 8006084:	4413      	add	r3, r2
 8006086:	62bb      	str	r3, [r7, #40]	@ 0x28

    lv_align_t align = lv_obj_get_style_align(obj, LV_PART_MAIN);
 8006088:	2100      	movs	r1, #0
 800608a:	6878      	ldr	r0, [r7, #4]
 800608c:	f7ff f95d 	bl	800534a <lv_obj_get_style_align>
 8006090:	4603      	mov	r3, r0
 8006092:	77fb      	strb	r3, [r7, #31]

    if(align == LV_ALIGN_DEFAULT) {
 8006094:	7ffb      	ldrb	r3, [r7, #31]
 8006096:	2b00      	cmp	r3, #0
 8006098:	d10b      	bne.n	80060b2 <lv_obj_refr_pos+0x1da>
        if(lv_obj_get_style_base_dir(parent, LV_PART_MAIN) == LV_BASE_DIR_RTL) align = LV_ALIGN_TOP_RIGHT;
 800609a:	2100      	movs	r1, #0
 800609c:	69b8      	ldr	r0, [r7, #24]
 800609e:	f7ff fa9a 	bl	80055d6 <lv_obj_get_style_base_dir>
 80060a2:	4603      	mov	r3, r0
 80060a4:	2b01      	cmp	r3, #1
 80060a6:	d102      	bne.n	80060ae <lv_obj_refr_pos+0x1d6>
 80060a8:	2303      	movs	r3, #3
 80060aa:	77fb      	strb	r3, [r7, #31]
 80060ac:	e001      	b.n	80060b2 <lv_obj_refr_pos+0x1da>
        else align = LV_ALIGN_TOP_LEFT;
 80060ae:	2301      	movs	r3, #1
 80060b0:	77fb      	strb	r3, [r7, #31]
    }

    switch(align) {
 80060b2:	7ffb      	ldrb	r3, [r7, #31]
 80060b4:	3b01      	subs	r3, #1
 80060b6:	2b08      	cmp	r3, #8
 80060b8:	f200 8096 	bhi.w	80061e8 <lv_obj_refr_pos+0x310>
 80060bc:	a201      	add	r2, pc, #4	@ (adr r2, 80060c4 <lv_obj_refr_pos+0x1ec>)
 80060be:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80060c2:	bf00      	nop
 80060c4:	080061e9 	.word	0x080061e9
 80060c8:	080060e9 	.word	0x080060e9
 80060cc:	08006107 	.word	0x08006107
 80060d0:	08006133 	.word	0x08006133
 80060d4:	08006141 	.word	0x08006141
 80060d8:	0800616b 	.word	0x0800616b
 80060dc:	08006115 	.word	0x08006115
 80060e0:	08006185 	.word	0x08006185
 80060e4:	080061af 	.word	0x080061af
        case LV_ALIGN_TOP_LEFT:
            break;
        case LV_ALIGN_TOP_MID:
            x += pw / 2 - w / 2;
 80060e8:	697b      	ldr	r3, [r7, #20]
 80060ea:	0fda      	lsrs	r2, r3, #31
 80060ec:	4413      	add	r3, r2
 80060ee:	105b      	asrs	r3, r3, #1
 80060f0:	4619      	mov	r1, r3
 80060f2:	68fb      	ldr	r3, [r7, #12]
 80060f4:	0fda      	lsrs	r2, r3, #31
 80060f6:	4413      	add	r3, r2
 80060f8:	105b      	asrs	r3, r3, #1
 80060fa:	425b      	negs	r3, r3
 80060fc:	440b      	add	r3, r1
 80060fe:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8006100:	4413      	add	r3, r2
 8006102:	62fb      	str	r3, [r7, #44]	@ 0x2c
            break;
 8006104:	e071      	b.n	80061ea <lv_obj_refr_pos+0x312>
        case LV_ALIGN_TOP_RIGHT:
            x += pw - w;
 8006106:	697a      	ldr	r2, [r7, #20]
 8006108:	68fb      	ldr	r3, [r7, #12]
 800610a:	1ad3      	subs	r3, r2, r3
 800610c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800610e:	4413      	add	r3, r2
 8006110:	62fb      	str	r3, [r7, #44]	@ 0x2c
            break;
 8006112:	e06a      	b.n	80061ea <lv_obj_refr_pos+0x312>
        case LV_ALIGN_LEFT_MID:
            y += ph / 2 - h / 2;
 8006114:	693b      	ldr	r3, [r7, #16]
 8006116:	0fda      	lsrs	r2, r3, #31
 8006118:	4413      	add	r3, r2
 800611a:	105b      	asrs	r3, r3, #1
 800611c:	4619      	mov	r1, r3
 800611e:	68bb      	ldr	r3, [r7, #8]
 8006120:	0fda      	lsrs	r2, r3, #31
 8006122:	4413      	add	r3, r2
 8006124:	105b      	asrs	r3, r3, #1
 8006126:	425b      	negs	r3, r3
 8006128:	440b      	add	r3, r1
 800612a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800612c:	4413      	add	r3, r2
 800612e:	62bb      	str	r3, [r7, #40]	@ 0x28
            break;
 8006130:	e05b      	b.n	80061ea <lv_obj_refr_pos+0x312>
        case LV_ALIGN_BOTTOM_LEFT:
            y += ph - h;
 8006132:	693a      	ldr	r2, [r7, #16]
 8006134:	68bb      	ldr	r3, [r7, #8]
 8006136:	1ad3      	subs	r3, r2, r3
 8006138:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800613a:	4413      	add	r3, r2
 800613c:	62bb      	str	r3, [r7, #40]	@ 0x28
            break;
 800613e:	e054      	b.n	80061ea <lv_obj_refr_pos+0x312>
        case LV_ALIGN_BOTTOM_MID:
            x += pw / 2 - w / 2;
 8006140:	697b      	ldr	r3, [r7, #20]
 8006142:	0fda      	lsrs	r2, r3, #31
 8006144:	4413      	add	r3, r2
 8006146:	105b      	asrs	r3, r3, #1
 8006148:	4619      	mov	r1, r3
 800614a:	68fb      	ldr	r3, [r7, #12]
 800614c:	0fda      	lsrs	r2, r3, #31
 800614e:	4413      	add	r3, r2
 8006150:	105b      	asrs	r3, r3, #1
 8006152:	425b      	negs	r3, r3
 8006154:	440b      	add	r3, r1
 8006156:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8006158:	4413      	add	r3, r2
 800615a:	62fb      	str	r3, [r7, #44]	@ 0x2c
            y += ph - h;
 800615c:	693a      	ldr	r2, [r7, #16]
 800615e:	68bb      	ldr	r3, [r7, #8]
 8006160:	1ad3      	subs	r3, r2, r3
 8006162:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8006164:	4413      	add	r3, r2
 8006166:	62bb      	str	r3, [r7, #40]	@ 0x28
            break;
 8006168:	e03f      	b.n	80061ea <lv_obj_refr_pos+0x312>
        case LV_ALIGN_BOTTOM_RIGHT:
            x += pw - w;
 800616a:	697a      	ldr	r2, [r7, #20]
 800616c:	68fb      	ldr	r3, [r7, #12]
 800616e:	1ad3      	subs	r3, r2, r3
 8006170:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8006172:	4413      	add	r3, r2
 8006174:	62fb      	str	r3, [r7, #44]	@ 0x2c
            y += ph - h;
 8006176:	693a      	ldr	r2, [r7, #16]
 8006178:	68bb      	ldr	r3, [r7, #8]
 800617a:	1ad3      	subs	r3, r2, r3
 800617c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800617e:	4413      	add	r3, r2
 8006180:	62bb      	str	r3, [r7, #40]	@ 0x28
            break;
 8006182:	e032      	b.n	80061ea <lv_obj_refr_pos+0x312>
        case LV_ALIGN_RIGHT_MID:
            x += pw - w;
 8006184:	697a      	ldr	r2, [r7, #20]
 8006186:	68fb      	ldr	r3, [r7, #12]
 8006188:	1ad3      	subs	r3, r2, r3
 800618a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800618c:	4413      	add	r3, r2
 800618e:	62fb      	str	r3, [r7, #44]	@ 0x2c
            y += ph / 2 - h / 2;
 8006190:	693b      	ldr	r3, [r7, #16]
 8006192:	0fda      	lsrs	r2, r3, #31
 8006194:	4413      	add	r3, r2
 8006196:	105b      	asrs	r3, r3, #1
 8006198:	4619      	mov	r1, r3
 800619a:	68bb      	ldr	r3, [r7, #8]
 800619c:	0fda      	lsrs	r2, r3, #31
 800619e:	4413      	add	r3, r2
 80061a0:	105b      	asrs	r3, r3, #1
 80061a2:	425b      	negs	r3, r3
 80061a4:	440b      	add	r3, r1
 80061a6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80061a8:	4413      	add	r3, r2
 80061aa:	62bb      	str	r3, [r7, #40]	@ 0x28
            break;
 80061ac:	e01d      	b.n	80061ea <lv_obj_refr_pos+0x312>
        case LV_ALIGN_CENTER:
            x += pw / 2 - w / 2;
 80061ae:	697b      	ldr	r3, [r7, #20]
 80061b0:	0fda      	lsrs	r2, r3, #31
 80061b2:	4413      	add	r3, r2
 80061b4:	105b      	asrs	r3, r3, #1
 80061b6:	4619      	mov	r1, r3
 80061b8:	68fb      	ldr	r3, [r7, #12]
 80061ba:	0fda      	lsrs	r2, r3, #31
 80061bc:	4413      	add	r3, r2
 80061be:	105b      	asrs	r3, r3, #1
 80061c0:	425b      	negs	r3, r3
 80061c2:	440b      	add	r3, r1
 80061c4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80061c6:	4413      	add	r3, r2
 80061c8:	62fb      	str	r3, [r7, #44]	@ 0x2c
            y += ph / 2 - h / 2;
 80061ca:	693b      	ldr	r3, [r7, #16]
 80061cc:	0fda      	lsrs	r2, r3, #31
 80061ce:	4413      	add	r3, r2
 80061d0:	105b      	asrs	r3, r3, #1
 80061d2:	4619      	mov	r1, r3
 80061d4:	68bb      	ldr	r3, [r7, #8]
 80061d6:	0fda      	lsrs	r2, r3, #31
 80061d8:	4413      	add	r3, r2
 80061da:	105b      	asrs	r3, r3, #1
 80061dc:	425b      	negs	r3, r3
 80061de:	440b      	add	r3, r1
 80061e0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80061e2:	4413      	add	r3, r2
 80061e4:	62bb      	str	r3, [r7, #40]	@ 0x28
            break;
 80061e6:	e000      	b.n	80061ea <lv_obj_refr_pos+0x312>
        default:
            break;
 80061e8:	bf00      	nop
    }

    lv_obj_move_to(obj, x, y);
 80061ea:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80061ec:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80061ee:	6878      	ldr	r0, [r7, #4]
 80061f0:	f000 f808 	bl	8006204 <lv_obj_move_to>
 80061f4:	e000      	b.n	80061f8 <lv_obj_refr_pos+0x320>
    if(lv_obj_is_layout_positioned(obj)) return;
 80061f6:	bf00      	nop
}
 80061f8:	3730      	adds	r7, #48	@ 0x30
 80061fa:	46bd      	mov	sp, r7
 80061fc:	bd80      	pop	{r7, pc}
 80061fe:	bf00      	nop
 8006200:	51eb851f 	.word	0x51eb851f

08006204 <lv_obj_move_to>:

void lv_obj_move_to(lv_obj_t * obj, int32_t x, int32_t y)
{
 8006204:	b590      	push	{r4, r7, lr}
 8006206:	b093      	sub	sp, #76	@ 0x4c
 8006208:	af00      	add	r7, sp, #0
 800620a:	60f8      	str	r0, [r7, #12]
 800620c:	60b9      	str	r1, [r7, #8]
 800620e:	607a      	str	r2, [r7, #4]
    /*Convert x and y to absolute coordinates*/
    lv_obj_t * parent = obj->parent;
 8006210:	68fb      	ldr	r3, [r7, #12]
 8006212:	685b      	ldr	r3, [r3, #4]
 8006214:	643b      	str	r3, [r7, #64]	@ 0x40

    if(parent) {
 8006216:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8006218:	2b00      	cmp	r3, #0
 800621a:	d036      	beq.n	800628a <lv_obj_move_to+0x86>
        if(lv_obj_has_flag(obj, LV_OBJ_FLAG_FLOATING)) {
 800621c:	f44f 2180 	mov.w	r1, #262144	@ 0x40000
 8006220:	68f8      	ldr	r0, [r7, #12]
 8006222:	f7fc fd94 	bl	8002d4e <lv_obj_has_flag>
 8006226:	4603      	mov	r3, r0
 8006228:	2b00      	cmp	r3, #0
 800622a:	d00a      	beq.n	8006242 <lv_obj_move_to+0x3e>
            x += parent->coords.x1;
 800622c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800622e:	695b      	ldr	r3, [r3, #20]
 8006230:	68ba      	ldr	r2, [r7, #8]
 8006232:	4413      	add	r3, r2
 8006234:	60bb      	str	r3, [r7, #8]
            y += parent->coords.y1;
 8006236:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8006238:	699b      	ldr	r3, [r3, #24]
 800623a:	687a      	ldr	r2, [r7, #4]
 800623c:	4413      	add	r3, r2
 800623e:	607b      	str	r3, [r7, #4]
 8006240:	e013      	b.n	800626a <lv_obj_move_to+0x66>
        }
        else {
            x += parent->coords.x1 - lv_obj_get_scroll_x(parent);
 8006242:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8006244:	695c      	ldr	r4, [r3, #20]
 8006246:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8006248:	f001 f8f8 	bl	800743c <lv_obj_get_scroll_x>
 800624c:	4603      	mov	r3, r0
 800624e:	1ae3      	subs	r3, r4, r3
 8006250:	68ba      	ldr	r2, [r7, #8]
 8006252:	4413      	add	r3, r2
 8006254:	60bb      	str	r3, [r7, #8]
            y += parent->coords.y1 - lv_obj_get_scroll_y(parent);
 8006256:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8006258:	699c      	ldr	r4, [r3, #24]
 800625a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800625c:	f001 f902 	bl	8007464 <lv_obj_get_scroll_y>
 8006260:	4603      	mov	r3, r0
 8006262:	1ae3      	subs	r3, r4, r3
 8006264:	687a      	ldr	r2, [r7, #4]
 8006266:	4413      	add	r3, r2
 8006268:	607b      	str	r3, [r7, #4]
        }

        x += lv_obj_get_style_space_left(parent, LV_PART_MAIN);
 800626a:	2100      	movs	r1, #0
 800626c:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800626e:	f7ff f9c4 	bl	80055fa <lv_obj_get_style_space_left>
 8006272:	4602      	mov	r2, r0
 8006274:	68bb      	ldr	r3, [r7, #8]
 8006276:	4413      	add	r3, r2
 8006278:	60bb      	str	r3, [r7, #8]
        y += lv_obj_get_style_space_top(parent, LV_PART_MAIN);
 800627a:	2100      	movs	r1, #0
 800627c:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800627e:	f7ff fa02 	bl	8005686 <lv_obj_get_style_space_top>
 8006282:	4602      	mov	r2, r0
 8006284:	687b      	ldr	r3, [r7, #4]
 8006286:	4413      	add	r3, r2
 8006288:	607b      	str	r3, [r7, #4]
    }

    /*Calculate and set the movement*/
    lv_point_t diff;
    diff.x = x - obj->coords.x1;
 800628a:	68fb      	ldr	r3, [r7, #12]
 800628c:	695b      	ldr	r3, [r3, #20]
 800628e:	68ba      	ldr	r2, [r7, #8]
 8006290:	1ad3      	subs	r3, r2, r3
 8006292:	637b      	str	r3, [r7, #52]	@ 0x34
    diff.y = y - obj->coords.y1;
 8006294:	68fb      	ldr	r3, [r7, #12]
 8006296:	699b      	ldr	r3, [r3, #24]
 8006298:	687a      	ldr	r2, [r7, #4]
 800629a:	1ad3      	subs	r3, r2, r3
 800629c:	63bb      	str	r3, [r7, #56]	@ 0x38

    /*Do nothing if the position is not changed*/
    /*It is very important else recursive positioning can
     *occur without position change*/
    if(diff.x == 0 && diff.y == 0) return;
 800629e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80062a0:	2b00      	cmp	r3, #0
 80062a2:	d102      	bne.n	80062aa <lv_obj_move_to+0xa6>
 80062a4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80062a6:	2b00      	cmp	r3, #0
 80062a8:	d073      	beq.n	8006392 <lv_obj_move_to+0x18e>

    /*Invalidate the original area*/
    lv_obj_invalidate(obj);
 80062aa:	68f8      	ldr	r0, [r7, #12]
 80062ac:	f000 f9c8 	bl	8006640 <lv_obj_invalidate>

    /*Save the original coordinates*/
    lv_area_t ori;
    lv_obj_get_coords(obj, &ori);
 80062b0:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80062b4:	4619      	mov	r1, r3
 80062b6:	68f8      	ldr	r0, [r7, #12]
 80062b8:	f7ff fd2b 	bl	8005d12 <lv_obj_get_coords>

    /*Check if the object inside the parent or not*/
    lv_area_t parent_fit_area;
    bool on1 = false;
 80062bc:	2300      	movs	r3, #0
 80062be:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
    if(parent) {
 80062c2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80062c4:	2b00      	cmp	r3, #0
 80062c6:	d01a      	beq.n	80062fe <lv_obj_move_to+0xfa>
        lv_obj_get_content_coords(parent, &parent_fit_area);
 80062c8:	f107 0314 	add.w	r3, r7, #20
 80062cc:	4619      	mov	r1, r3
 80062ce:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 80062d0:	f7ff fd7e 	bl	8005dd0 <lv_obj_get_content_coords>

        /*If the object is already out of the parent and its position is changes
         *surely the scrollbars also changes so invalidate them*/
        on1 = _lv_area_is_in(&ori, &parent_fit_area, 0);
 80062d4:	f107 0114 	add.w	r1, r7, #20
 80062d8:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80062dc:	2200      	movs	r2, #0
 80062de:	4618      	mov	r0, r3
 80062e0:	f01b fc56 	bl	8021b90 <_lv_area_is_in>
 80062e4:	4603      	mov	r3, r0
 80062e6:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
        if(!on1) lv_obj_scrollbar_invalidate(parent);
 80062ea:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80062ee:	f083 0301 	eor.w	r3, r3, #1
 80062f2:	b2db      	uxtb	r3, r3
 80062f4:	2b00      	cmp	r3, #0
 80062f6:	d002      	beq.n	80062fe <lv_obj_move_to+0xfa>
 80062f8:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 80062fa:	f002 f927 	bl	800854c <lv_obj_scrollbar_invalidate>
    }

    obj->coords.x1 += diff.x;
 80062fe:	68fb      	ldr	r3, [r7, #12]
 8006300:	695a      	ldr	r2, [r3, #20]
 8006302:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8006304:	441a      	add	r2, r3
 8006306:	68fb      	ldr	r3, [r7, #12]
 8006308:	615a      	str	r2, [r3, #20]
    obj->coords.y1 += diff.y;
 800630a:	68fb      	ldr	r3, [r7, #12]
 800630c:	699a      	ldr	r2, [r3, #24]
 800630e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8006310:	441a      	add	r2, r3
 8006312:	68fb      	ldr	r3, [r7, #12]
 8006314:	619a      	str	r2, [r3, #24]
    obj->coords.x2 += diff.x;
 8006316:	68fb      	ldr	r3, [r7, #12]
 8006318:	69da      	ldr	r2, [r3, #28]
 800631a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800631c:	441a      	add	r2, r3
 800631e:	68fb      	ldr	r3, [r7, #12]
 8006320:	61da      	str	r2, [r3, #28]
    obj->coords.y2 += diff.y;
 8006322:	68fb      	ldr	r3, [r7, #12]
 8006324:	6a1a      	ldr	r2, [r3, #32]
 8006326:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8006328:	441a      	add	r2, r3
 800632a:	68fb      	ldr	r3, [r7, #12]
 800632c:	621a      	str	r2, [r3, #32]

    lv_obj_move_children_by(obj, diff.x, diff.y, false);
 800632e:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8006330:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8006332:	2300      	movs	r3, #0
 8006334:	68f8      	ldr	r0, [r7, #12]
 8006336:	f000 f830 	bl	800639a <lv_obj_move_children_by>

    /*Call the ancestor's event handler to the parent too*/
    if(parent) lv_obj_send_event(parent, LV_EVENT_CHILD_CHANGED, obj);
 800633a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800633c:	2b00      	cmp	r3, #0
 800633e:	d004      	beq.n	800634a <lv_obj_move_to+0x146>
 8006340:	68fa      	ldr	r2, [r7, #12]
 8006342:	2124      	movs	r1, #36	@ 0x24
 8006344:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8006346:	f7fe fd65 	bl	8004e14 <lv_obj_send_event>

    /*Invalidate the new area*/
    lv_obj_invalidate(obj);
 800634a:	68f8      	ldr	r0, [r7, #12]
 800634c:	f000 f978 	bl	8006640 <lv_obj_invalidate>

    /*If the object was out of the parent invalidate the new scrollbar area too.
     *If it wasn't out of the parent but out now, also invalidate the scrollbars*/
    if(parent) {
 8006350:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8006352:	2b00      	cmp	r3, #0
 8006354:	d01e      	beq.n	8006394 <lv_obj_move_to+0x190>
        bool on2 = _lv_area_is_in(&obj->coords, &parent_fit_area, 0);
 8006356:	68fb      	ldr	r3, [r7, #12]
 8006358:	3314      	adds	r3, #20
 800635a:	f107 0114 	add.w	r1, r7, #20
 800635e:	2200      	movs	r2, #0
 8006360:	4618      	mov	r0, r3
 8006362:	f01b fc15 	bl	8021b90 <_lv_area_is_in>
 8006366:	4603      	mov	r3, r0
 8006368:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
        if(on1 || (!on1 && on2)) lv_obj_scrollbar_invalidate(parent);
 800636c:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 8006370:	2b00      	cmp	r3, #0
 8006372:	d10a      	bne.n	800638a <lv_obj_move_to+0x186>
 8006374:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 8006378:	f083 0301 	eor.w	r3, r3, #1
 800637c:	b2db      	uxtb	r3, r3
 800637e:	2b00      	cmp	r3, #0
 8006380:	d008      	beq.n	8006394 <lv_obj_move_to+0x190>
 8006382:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 8006386:	2b00      	cmp	r3, #0
 8006388:	d004      	beq.n	8006394 <lv_obj_move_to+0x190>
 800638a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800638c:	f002 f8de 	bl	800854c <lv_obj_scrollbar_invalidate>
 8006390:	e000      	b.n	8006394 <lv_obj_move_to+0x190>
    if(diff.x == 0 && diff.y == 0) return;
 8006392:	bf00      	nop
    }
}
 8006394:	374c      	adds	r7, #76	@ 0x4c
 8006396:	46bd      	mov	sp, r7
 8006398:	bd90      	pop	{r4, r7, pc}

0800639a <lv_obj_move_children_by>:

void lv_obj_move_children_by(lv_obj_t * obj, int32_t x_diff, int32_t y_diff, bool ignore_floating)
{
 800639a:	b580      	push	{r7, lr}
 800639c:	b088      	sub	sp, #32
 800639e:	af00      	add	r7, sp, #0
 80063a0:	60f8      	str	r0, [r7, #12]
 80063a2:	60b9      	str	r1, [r7, #8]
 80063a4:	607a      	str	r2, [r7, #4]
 80063a6:	70fb      	strb	r3, [r7, #3]
    uint32_t i;
    uint32_t child_cnt = lv_obj_get_child_count(obj);
 80063a8:	68f8      	ldr	r0, [r7, #12]
 80063aa:	f004 fd89 	bl	800aec0 <lv_obj_get_child_count>
 80063ae:	61b8      	str	r0, [r7, #24]
    for(i = 0; i < child_cnt; i++) {
 80063b0:	2300      	movs	r3, #0
 80063b2:	61fb      	str	r3, [r7, #28]
 80063b4:	e035      	b.n	8006422 <lv_obj_move_children_by+0x88>
        lv_obj_t * child = obj->spec_attr->children[i];
 80063b6:	68fb      	ldr	r3, [r7, #12]
 80063b8:	689b      	ldr	r3, [r3, #8]
 80063ba:	681a      	ldr	r2, [r3, #0]
 80063bc:	69fb      	ldr	r3, [r7, #28]
 80063be:	009b      	lsls	r3, r3, #2
 80063c0:	4413      	add	r3, r2
 80063c2:	681b      	ldr	r3, [r3, #0]
 80063c4:	617b      	str	r3, [r7, #20]
        if(ignore_floating && lv_obj_has_flag(child, LV_OBJ_FLAG_FLOATING)) continue;
 80063c6:	78fb      	ldrb	r3, [r7, #3]
 80063c8:	2b00      	cmp	r3, #0
 80063ca:	d007      	beq.n	80063dc <lv_obj_move_children_by+0x42>
 80063cc:	f44f 2180 	mov.w	r1, #262144	@ 0x40000
 80063d0:	6978      	ldr	r0, [r7, #20]
 80063d2:	f7fc fcbc 	bl	8002d4e <lv_obj_has_flag>
 80063d6:	4603      	mov	r3, r0
 80063d8:	2b00      	cmp	r3, #0
 80063da:	d11e      	bne.n	800641a <lv_obj_move_children_by+0x80>
        child->coords.x1 += x_diff;
 80063dc:	697b      	ldr	r3, [r7, #20]
 80063de:	695a      	ldr	r2, [r3, #20]
 80063e0:	68bb      	ldr	r3, [r7, #8]
 80063e2:	441a      	add	r2, r3
 80063e4:	697b      	ldr	r3, [r7, #20]
 80063e6:	615a      	str	r2, [r3, #20]
        child->coords.y1 += y_diff;
 80063e8:	697b      	ldr	r3, [r7, #20]
 80063ea:	699a      	ldr	r2, [r3, #24]
 80063ec:	687b      	ldr	r3, [r7, #4]
 80063ee:	441a      	add	r2, r3
 80063f0:	697b      	ldr	r3, [r7, #20]
 80063f2:	619a      	str	r2, [r3, #24]
        child->coords.x2 += x_diff;
 80063f4:	697b      	ldr	r3, [r7, #20]
 80063f6:	69da      	ldr	r2, [r3, #28]
 80063f8:	68bb      	ldr	r3, [r7, #8]
 80063fa:	441a      	add	r2, r3
 80063fc:	697b      	ldr	r3, [r7, #20]
 80063fe:	61da      	str	r2, [r3, #28]
        child->coords.y2 += y_diff;
 8006400:	697b      	ldr	r3, [r7, #20]
 8006402:	6a1a      	ldr	r2, [r3, #32]
 8006404:	687b      	ldr	r3, [r7, #4]
 8006406:	441a      	add	r2, r3
 8006408:	697b      	ldr	r3, [r7, #20]
 800640a:	621a      	str	r2, [r3, #32]

        lv_obj_move_children_by(child, x_diff, y_diff, false);
 800640c:	2300      	movs	r3, #0
 800640e:	687a      	ldr	r2, [r7, #4]
 8006410:	68b9      	ldr	r1, [r7, #8]
 8006412:	6978      	ldr	r0, [r7, #20]
 8006414:	f7ff ffc1 	bl	800639a <lv_obj_move_children_by>
 8006418:	e000      	b.n	800641c <lv_obj_move_children_by+0x82>
        if(ignore_floating && lv_obj_has_flag(child, LV_OBJ_FLAG_FLOATING)) continue;
 800641a:	bf00      	nop
    for(i = 0; i < child_cnt; i++) {
 800641c:	69fb      	ldr	r3, [r7, #28]
 800641e:	3301      	adds	r3, #1
 8006420:	61fb      	str	r3, [r7, #28]
 8006422:	69fa      	ldr	r2, [r7, #28]
 8006424:	69bb      	ldr	r3, [r7, #24]
 8006426:	429a      	cmp	r2, r3
 8006428:	d3c5      	bcc.n	80063b6 <lv_obj_move_children_by+0x1c>
    }
}
 800642a:	bf00      	nop
 800642c:	bf00      	nop
 800642e:	3720      	adds	r7, #32
 8006430:	46bd      	mov	sp, r7
 8006432:	bd80      	pop	{r7, pc}

08006434 <lv_obj_transform_point>:

void lv_obj_transform_point(const lv_obj_t * obj, lv_point_t * p, bool recursive, bool inv)
{
 8006434:	b580      	push	{r7, lr}
 8006436:	b086      	sub	sp, #24
 8006438:	af00      	add	r7, sp, #0
 800643a:	60f8      	str	r0, [r7, #12]
 800643c:	60b9      	str	r1, [r7, #8]
 800643e:	4611      	mov	r1, r2
 8006440:	461a      	mov	r2, r3
 8006442:	460b      	mov	r3, r1
 8006444:	71fb      	strb	r3, [r7, #7]
 8006446:	4613      	mov	r3, r2
 8006448:	71bb      	strb	r3, [r7, #6]
    if(obj) {
 800644a:	68fb      	ldr	r3, [r7, #12]
 800644c:	2b00      	cmp	r3, #0
 800644e:	d036      	beq.n	80064be <lv_obj_transform_point+0x8a>
        lv_layer_type_t layer_type = _lv_obj_get_layer_type(obj);
 8006450:	68f8      	ldr	r0, [r7, #12]
 8006452:	f7fe fcc8 	bl	8004de6 <_lv_obj_get_layer_type>
 8006456:	4603      	mov	r3, r0
 8006458:	75fb      	strb	r3, [r7, #23]
        bool do_tranf = layer_type == LV_LAYER_TYPE_TRANSFORM;
 800645a:	7dfb      	ldrb	r3, [r7, #23]
 800645c:	2b02      	cmp	r3, #2
 800645e:	bf0c      	ite	eq
 8006460:	2301      	moveq	r3, #1
 8006462:	2300      	movne	r3, #0
 8006464:	75bb      	strb	r3, [r7, #22]
        if(inv) {
 8006466:	79bb      	ldrb	r3, [r7, #6]
 8006468:	2b00      	cmp	r3, #0
 800646a:	d014      	beq.n	8006496 <lv_obj_transform_point+0x62>
            if(recursive) lv_obj_transform_point(lv_obj_get_parent(obj), p, recursive, inv);
 800646c:	79fb      	ldrb	r3, [r7, #7]
 800646e:	2b00      	cmp	r3, #0
 8006470:	d007      	beq.n	8006482 <lv_obj_transform_point+0x4e>
 8006472:	68f8      	ldr	r0, [r7, #12]
 8006474:	f004 fcde 	bl	800ae34 <lv_obj_get_parent>
 8006478:	79bb      	ldrb	r3, [r7, #6]
 800647a:	79fa      	ldrb	r2, [r7, #7]
 800647c:	68b9      	ldr	r1, [r7, #8]
 800647e:	f7ff ffd9 	bl	8006434 <lv_obj_transform_point>
            if(do_tranf) transform_point(obj, p, inv);
 8006482:	7dbb      	ldrb	r3, [r7, #22]
 8006484:	2b00      	cmp	r3, #0
 8006486:	d01a      	beq.n	80064be <lv_obj_transform_point+0x8a>
 8006488:	79bb      	ldrb	r3, [r7, #6]
 800648a:	461a      	mov	r2, r3
 800648c:	68b9      	ldr	r1, [r7, #8]
 800648e:	68f8      	ldr	r0, [r7, #12]
 8006490:	f000 fcd4 	bl	8006e3c <transform_point>
        else {
            if(do_tranf) transform_point(obj, p, inv);
            if(recursive) lv_obj_transform_point(lv_obj_get_parent(obj), p, recursive, inv);
        }
    }
}
 8006494:	e013      	b.n	80064be <lv_obj_transform_point+0x8a>
            if(do_tranf) transform_point(obj, p, inv);
 8006496:	7dbb      	ldrb	r3, [r7, #22]
 8006498:	2b00      	cmp	r3, #0
 800649a:	d005      	beq.n	80064a8 <lv_obj_transform_point+0x74>
 800649c:	79bb      	ldrb	r3, [r7, #6]
 800649e:	461a      	mov	r2, r3
 80064a0:	68b9      	ldr	r1, [r7, #8]
 80064a2:	68f8      	ldr	r0, [r7, #12]
 80064a4:	f000 fcca 	bl	8006e3c <transform_point>
            if(recursive) lv_obj_transform_point(lv_obj_get_parent(obj), p, recursive, inv);
 80064a8:	79fb      	ldrb	r3, [r7, #7]
 80064aa:	2b00      	cmp	r3, #0
 80064ac:	d007      	beq.n	80064be <lv_obj_transform_point+0x8a>
 80064ae:	68f8      	ldr	r0, [r7, #12]
 80064b0:	f004 fcc0 	bl	800ae34 <lv_obj_get_parent>
 80064b4:	79bb      	ldrb	r3, [r7, #6]
 80064b6:	79fa      	ldrb	r2, [r7, #7]
 80064b8:	68b9      	ldr	r1, [r7, #8]
 80064ba:	f7ff ffbb 	bl	8006434 <lv_obj_transform_point>
}
 80064be:	bf00      	nop
 80064c0:	3718      	adds	r7, #24
 80064c2:	46bd      	mov	sp, r7
 80064c4:	bd80      	pop	{r7, pc}

080064c6 <lv_obj_get_transformed_area>:

void lv_obj_get_transformed_area(const lv_obj_t * obj, lv_area_t * area, bool recursive,
                                 bool inv)
{
 80064c6:	b580      	push	{r7, lr}
 80064c8:	b08c      	sub	sp, #48	@ 0x30
 80064ca:	af00      	add	r7, sp, #0
 80064cc:	60f8      	str	r0, [r7, #12]
 80064ce:	60b9      	str	r1, [r7, #8]
 80064d0:	4611      	mov	r1, r2
 80064d2:	461a      	mov	r2, r3
 80064d4:	460b      	mov	r3, r1
 80064d6:	71fb      	strb	r3, [r7, #7]
 80064d8:	4613      	mov	r3, r2
 80064da:	71bb      	strb	r3, [r7, #6]
    lv_point_t p[4] = {
        {area->x1, area->y1},
 80064dc:	68bb      	ldr	r3, [r7, #8]
 80064de:	681b      	ldr	r3, [r3, #0]
    lv_point_t p[4] = {
 80064e0:	613b      	str	r3, [r7, #16]
        {area->x1, area->y1},
 80064e2:	68bb      	ldr	r3, [r7, #8]
 80064e4:	685b      	ldr	r3, [r3, #4]
    lv_point_t p[4] = {
 80064e6:	617b      	str	r3, [r7, #20]
        {area->x1, area->y2},
 80064e8:	68bb      	ldr	r3, [r7, #8]
 80064ea:	681b      	ldr	r3, [r3, #0]
    lv_point_t p[4] = {
 80064ec:	61bb      	str	r3, [r7, #24]
        {area->x1, area->y2},
 80064ee:	68bb      	ldr	r3, [r7, #8]
 80064f0:	68db      	ldr	r3, [r3, #12]
    lv_point_t p[4] = {
 80064f2:	61fb      	str	r3, [r7, #28]
        {area->x2, area->y1},
 80064f4:	68bb      	ldr	r3, [r7, #8]
 80064f6:	689b      	ldr	r3, [r3, #8]
    lv_point_t p[4] = {
 80064f8:	623b      	str	r3, [r7, #32]
        {area->x2, area->y1},
 80064fa:	68bb      	ldr	r3, [r7, #8]
 80064fc:	685b      	ldr	r3, [r3, #4]
    lv_point_t p[4] = {
 80064fe:	627b      	str	r3, [r7, #36]	@ 0x24
        {area->x2, area->y2},
 8006500:	68bb      	ldr	r3, [r7, #8]
 8006502:	689b      	ldr	r3, [r3, #8]
    lv_point_t p[4] = {
 8006504:	62bb      	str	r3, [r7, #40]	@ 0x28
        {area->x2, area->y2},
 8006506:	68bb      	ldr	r3, [r7, #8]
 8006508:	68db      	ldr	r3, [r3, #12]
    lv_point_t p[4] = {
 800650a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    };

    lv_obj_transform_point(obj, &p[0], recursive, inv);
 800650c:	79bb      	ldrb	r3, [r7, #6]
 800650e:	79fa      	ldrb	r2, [r7, #7]
 8006510:	f107 0110 	add.w	r1, r7, #16
 8006514:	68f8      	ldr	r0, [r7, #12]
 8006516:	f7ff ff8d 	bl	8006434 <lv_obj_transform_point>
    lv_obj_transform_point(obj, &p[1], recursive, inv);
 800651a:	79b8      	ldrb	r0, [r7, #6]
 800651c:	79fa      	ldrb	r2, [r7, #7]
 800651e:	f107 0310 	add.w	r3, r7, #16
 8006522:	f103 0108 	add.w	r1, r3, #8
 8006526:	4603      	mov	r3, r0
 8006528:	68f8      	ldr	r0, [r7, #12]
 800652a:	f7ff ff83 	bl	8006434 <lv_obj_transform_point>
    lv_obj_transform_point(obj, &p[2], recursive, inv);
 800652e:	79b8      	ldrb	r0, [r7, #6]
 8006530:	79fa      	ldrb	r2, [r7, #7]
 8006532:	f107 0310 	add.w	r3, r7, #16
 8006536:	f103 0110 	add.w	r1, r3, #16
 800653a:	4603      	mov	r3, r0
 800653c:	68f8      	ldr	r0, [r7, #12]
 800653e:	f7ff ff79 	bl	8006434 <lv_obj_transform_point>
    lv_obj_transform_point(obj, &p[3], recursive, inv);
 8006542:	79b8      	ldrb	r0, [r7, #6]
 8006544:	79fa      	ldrb	r2, [r7, #7]
 8006546:	f107 0310 	add.w	r3, r7, #16
 800654a:	f103 0118 	add.w	r1, r3, #24
 800654e:	4603      	mov	r3, r0
 8006550:	68f8      	ldr	r0, [r7, #12]
 8006552:	f7ff ff6f 	bl	8006434 <lv_obj_transform_point>

    area->x1 = LV_MIN4(p[0].x, p[1].x, p[2].x, p[3].x);
 8006556:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8006558:	6a3b      	ldr	r3, [r7, #32]
 800655a:	429a      	cmp	r2, r3
 800655c:	bfa8      	it	ge
 800655e:	461a      	movge	r2, r3
 8006560:	69b9      	ldr	r1, [r7, #24]
 8006562:	693b      	ldr	r3, [r7, #16]
 8006564:	428b      	cmp	r3, r1
 8006566:	bfa8      	it	ge
 8006568:	460b      	movge	r3, r1
 800656a:	429a      	cmp	r2, r3
 800656c:	bfa8      	it	ge
 800656e:	461a      	movge	r2, r3
 8006570:	68bb      	ldr	r3, [r7, #8]
 8006572:	601a      	str	r2, [r3, #0]
    area->x2 = LV_MAX4(p[0].x, p[1].x, p[2].x, p[3].x);
 8006574:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8006576:	6a3b      	ldr	r3, [r7, #32]
 8006578:	429a      	cmp	r2, r3
 800657a:	bfb8      	it	lt
 800657c:	461a      	movlt	r2, r3
 800657e:	69b9      	ldr	r1, [r7, #24]
 8006580:	693b      	ldr	r3, [r7, #16]
 8006582:	428b      	cmp	r3, r1
 8006584:	bfb8      	it	lt
 8006586:	460b      	movlt	r3, r1
 8006588:	429a      	cmp	r2, r3
 800658a:	bfb8      	it	lt
 800658c:	461a      	movlt	r2, r3
 800658e:	68bb      	ldr	r3, [r7, #8]
 8006590:	609a      	str	r2, [r3, #8]
    area->y1 = LV_MIN4(p[0].y, p[1].y, p[2].y, p[3].y);
 8006592:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8006594:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006596:	429a      	cmp	r2, r3
 8006598:	bfa8      	it	ge
 800659a:	461a      	movge	r2, r3
 800659c:	69f9      	ldr	r1, [r7, #28]
 800659e:	697b      	ldr	r3, [r7, #20]
 80065a0:	428b      	cmp	r3, r1
 80065a2:	bfa8      	it	ge
 80065a4:	460b      	movge	r3, r1
 80065a6:	429a      	cmp	r2, r3
 80065a8:	bfa8      	it	ge
 80065aa:	461a      	movge	r2, r3
 80065ac:	68bb      	ldr	r3, [r7, #8]
 80065ae:	605a      	str	r2, [r3, #4]
    area->y2 = LV_MAX4(p[0].y, p[1].y, p[2].y, p[3].y);
 80065b0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80065b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80065b4:	429a      	cmp	r2, r3
 80065b6:	bfb8      	it	lt
 80065b8:	461a      	movlt	r2, r3
 80065ba:	69f9      	ldr	r1, [r7, #28]
 80065bc:	697b      	ldr	r3, [r7, #20]
 80065be:	428b      	cmp	r3, r1
 80065c0:	bfb8      	it	lt
 80065c2:	460b      	movlt	r3, r1
 80065c4:	429a      	cmp	r2, r3
 80065c6:	bfb8      	it	lt
 80065c8:	461a      	movlt	r2, r3
 80065ca:	68bb      	ldr	r3, [r7, #8]
 80065cc:	60da      	str	r2, [r3, #12]
}
 80065ce:	bf00      	nop
 80065d0:	3730      	adds	r7, #48	@ 0x30
 80065d2:	46bd      	mov	sp, r7
 80065d4:	bd80      	pop	{r7, pc}

080065d6 <lv_obj_invalidate_area>:

void lv_obj_invalidate_area(const lv_obj_t * obj, const lv_area_t * area)
{
 80065d6:	b580      	push	{r7, lr}
 80065d8:	b088      	sub	sp, #32
 80065da:	af00      	add	r7, sp, #0
 80065dc:	6078      	str	r0, [r7, #4]
 80065de:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    lv_display_t * disp   = lv_obj_get_display(obj);
 80065e0:	6878      	ldr	r0, [r7, #4]
 80065e2:	f004 fbe9 	bl	800adb8 <lv_obj_get_display>
 80065e6:	61f8      	str	r0, [r7, #28]
    if(!lv_display_is_invalidation_enabled(disp)) return;
 80065e8:	69f8      	ldr	r0, [r7, #28]
 80065ea:	f004 fecc 	bl	800b386 <lv_display_is_invalidation_enabled>
 80065ee:	4603      	mov	r3, r0
 80065f0:	f083 0301 	eor.w	r3, r3, #1
 80065f4:	b2db      	uxtb	r3, r3
 80065f6:	2b00      	cmp	r3, #0
 80065f8:	d11c      	bne.n	8006634 <lv_obj_invalidate_area+0x5e>

    lv_area_t area_tmp;
    lv_area_copy(&area_tmp, area);
 80065fa:	f107 030c 	add.w	r3, r7, #12
 80065fe:	6839      	ldr	r1, [r7, #0]
 8006600:	4618      	mov	r0, r3
 8006602:	f7fe fddf 	bl	80051c4 <lv_area_copy>
    if(!lv_obj_area_is_visible(obj, &area_tmp)) return;
 8006606:	f107 030c 	add.w	r3, r7, #12
 800660a:	4619      	mov	r1, r3
 800660c:	6878      	ldr	r0, [r7, #4]
 800660e:	f000 f842 	bl	8006696 <lv_obj_area_is_visible>
 8006612:	4603      	mov	r3, r0
 8006614:	f083 0301 	eor.w	r3, r3, #1
 8006618:	b2db      	uxtb	r3, r3
 800661a:	2b00      	cmp	r3, #0
 800661c:	d10c      	bne.n	8006638 <lv_obj_invalidate_area+0x62>

    _lv_inv_area(lv_obj_get_display(obj),  &area_tmp);
 800661e:	6878      	ldr	r0, [r7, #4]
 8006620:	f004 fbca 	bl	800adb8 <lv_obj_get_display>
 8006624:	4602      	mov	r2, r0
 8006626:	f107 030c 	add.w	r3, r7, #12
 800662a:	4619      	mov	r1, r3
 800662c:	4610      	mov	r0, r2
 800662e:	f004 fc7c 	bl	800af2a <_lv_inv_area>
 8006632:	e002      	b.n	800663a <lv_obj_invalidate_area+0x64>
    if(!lv_display_is_invalidation_enabled(disp)) return;
 8006634:	bf00      	nop
 8006636:	e000      	b.n	800663a <lv_obj_invalidate_area+0x64>
    if(!lv_obj_area_is_visible(obj, &area_tmp)) return;
 8006638:	bf00      	nop
}
 800663a:	3720      	adds	r7, #32
 800663c:	46bd      	mov	sp, r7
 800663e:	bd80      	pop	{r7, pc}

08006640 <lv_obj_invalidate>:

void lv_obj_invalidate(const lv_obj_t * obj)
{
 8006640:	b580      	push	{r7, lr}
 8006642:	b088      	sub	sp, #32
 8006644:	af00      	add	r7, sp, #0
 8006646:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    /*Truncate the area to the object*/
    lv_area_t obj_coords;
    int32_t ext_size = _lv_obj_get_ext_draw_size(obj);
 8006648:	6878      	ldr	r0, [r7, #4]
 800664a:	f7fe fbb9 	bl	8004dc0 <_lv_obj_get_ext_draw_size>
 800664e:	61f8      	str	r0, [r7, #28]
    lv_area_copy(&obj_coords, &obj->coords);
 8006650:	687b      	ldr	r3, [r7, #4]
 8006652:	f103 0214 	add.w	r2, r3, #20
 8006656:	f107 030c 	add.w	r3, r7, #12
 800665a:	4611      	mov	r1, r2
 800665c:	4618      	mov	r0, r3
 800665e:	f7fe fdb1 	bl	80051c4 <lv_area_copy>
    obj_coords.x1 -= ext_size;
 8006662:	68fa      	ldr	r2, [r7, #12]
 8006664:	69fb      	ldr	r3, [r7, #28]
 8006666:	1ad3      	subs	r3, r2, r3
 8006668:	60fb      	str	r3, [r7, #12]
    obj_coords.y1 -= ext_size;
 800666a:	693a      	ldr	r2, [r7, #16]
 800666c:	69fb      	ldr	r3, [r7, #28]
 800666e:	1ad3      	subs	r3, r2, r3
 8006670:	613b      	str	r3, [r7, #16]
    obj_coords.x2 += ext_size;
 8006672:	697a      	ldr	r2, [r7, #20]
 8006674:	69fb      	ldr	r3, [r7, #28]
 8006676:	4413      	add	r3, r2
 8006678:	617b      	str	r3, [r7, #20]
    obj_coords.y2 += ext_size;
 800667a:	69ba      	ldr	r2, [r7, #24]
 800667c:	69fb      	ldr	r3, [r7, #28]
 800667e:	4413      	add	r3, r2
 8006680:	61bb      	str	r3, [r7, #24]

    lv_obj_invalidate_area(obj, &obj_coords);
 8006682:	f107 030c 	add.w	r3, r7, #12
 8006686:	4619      	mov	r1, r3
 8006688:	6878      	ldr	r0, [r7, #4]
 800668a:	f7ff ffa4 	bl	80065d6 <lv_obj_invalidate_area>
}
 800668e:	bf00      	nop
 8006690:	3720      	adds	r7, #32
 8006692:	46bd      	mov	sp, r7
 8006694:	bd80      	pop	{r7, pc}

08006696 <lv_obj_area_is_visible>:

bool lv_obj_area_is_visible(const lv_obj_t * obj, lv_area_t * area)
{
 8006696:	b590      	push	{r4, r7, lr}
 8006698:	b091      	sub	sp, #68	@ 0x44
 800669a:	af00      	add	r7, sp, #0
 800669c:	6078      	str	r0, [r7, #4]
 800669e:	6039      	str	r1, [r7, #0]
    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_HIDDEN)) return false;
 80066a0:	2101      	movs	r1, #1
 80066a2:	6878      	ldr	r0, [r7, #4]
 80066a4:	f7fc fb53 	bl	8002d4e <lv_obj_has_flag>
 80066a8:	4603      	mov	r3, r0
 80066aa:	2b00      	cmp	r3, #0
 80066ac:	d001      	beq.n	80066b2 <lv_obj_area_is_visible+0x1c>
 80066ae:	2300      	movs	r3, #0
 80066b0:	e09b      	b.n	80067ea <lv_obj_area_is_visible+0x154>

    /*Invalidate the object only if it belongs to the current or previous or one of the layers'*/
    lv_obj_t * obj_scr = lv_obj_get_screen(obj);
 80066b2:	6878      	ldr	r0, [r7, #4]
 80066b4:	f004 fb6b 	bl	800ad8e <lv_obj_get_screen>
 80066b8:	63b8      	str	r0, [r7, #56]	@ 0x38
    lv_display_t * disp   = lv_obj_get_display(obj_scr);
 80066ba:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 80066bc:	f004 fb7c 	bl	800adb8 <lv_obj_get_display>
 80066c0:	6378      	str	r0, [r7, #52]	@ 0x34
    if(obj_scr != lv_display_get_screen_active(disp) &&
 80066c2:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80066c4:	f004 fd9f 	bl	800b206 <lv_display_get_screen_active>
 80066c8:	4602      	mov	r2, r0
 80066ca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80066cc:	4293      	cmp	r3, r2
 80066ce:	d01d      	beq.n	800670c <lv_obj_area_is_visible+0x76>
       obj_scr != lv_display_get_screen_prev(disp) &&
 80066d0:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80066d2:	f004 fdae 	bl	800b232 <lv_display_get_screen_prev>
 80066d6:	4602      	mov	r2, r0
    if(obj_scr != lv_display_get_screen_active(disp) &&
 80066d8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80066da:	4293      	cmp	r3, r2
 80066dc:	d016      	beq.n	800670c <lv_obj_area_is_visible+0x76>
       obj_scr != lv_display_get_layer_bottom(disp) &&
 80066de:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80066e0:	f004 fde9 	bl	800b2b6 <lv_display_get_layer_bottom>
 80066e4:	4602      	mov	r2, r0
       obj_scr != lv_display_get_screen_prev(disp) &&
 80066e6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80066e8:	4293      	cmp	r3, r2
 80066ea:	d00f      	beq.n	800670c <lv_obj_area_is_visible+0x76>
       obj_scr != lv_display_get_layer_top(disp) &&
 80066ec:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80066ee:	f004 fdb6 	bl	800b25e <lv_display_get_layer_top>
 80066f2:	4602      	mov	r2, r0
       obj_scr != lv_display_get_layer_bottom(disp) &&
 80066f4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80066f6:	4293      	cmp	r3, r2
 80066f8:	d008      	beq.n	800670c <lv_obj_area_is_visible+0x76>
       obj_scr != lv_display_get_layer_sys(disp)) {
 80066fa:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80066fc:	f004 fdc5 	bl	800b28a <lv_display_get_layer_sys>
 8006700:	4602      	mov	r2, r0
       obj_scr != lv_display_get_layer_top(disp) &&
 8006702:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8006704:	4293      	cmp	r3, r2
 8006706:	d001      	beq.n	800670c <lv_obj_area_is_visible+0x76>
        return false;
 8006708:	2300      	movs	r3, #0
 800670a:	e06e      	b.n	80067ea <lv_obj_area_is_visible+0x154>
    }

    /*Truncate the area to the object*/
    lv_area_t obj_coords;
    int32_t ext_size = _lv_obj_get_ext_draw_size(obj);
 800670c:	6878      	ldr	r0, [r7, #4]
 800670e:	f7fe fb57 	bl	8004dc0 <_lv_obj_get_ext_draw_size>
 8006712:	6338      	str	r0, [r7, #48]	@ 0x30
    lv_area_copy(&obj_coords, &obj->coords);
 8006714:	687b      	ldr	r3, [r7, #4]
 8006716:	f103 0214 	add.w	r2, r3, #20
 800671a:	f107 031c 	add.w	r3, r7, #28
 800671e:	4611      	mov	r1, r2
 8006720:	4618      	mov	r0, r3
 8006722:	f7fe fd4f 	bl	80051c4 <lv_area_copy>
    lv_area_increase(&obj_coords, ext_size, ext_size);
 8006726:	f107 031c 	add.w	r3, r7, #28
 800672a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800672c:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 800672e:	4618      	mov	r0, r3
 8006730:	f01b f8c2 	bl	80218b8 <lv_area_increase>

    /*The area is not on the object*/
    if(!_lv_area_intersect(area, area, &obj_coords)) return false;
 8006734:	f107 031c 	add.w	r3, r7, #28
 8006738:	461a      	mov	r2, r3
 800673a:	6839      	ldr	r1, [r7, #0]
 800673c:	6838      	ldr	r0, [r7, #0]
 800673e:	f01b f903 	bl	8021948 <_lv_area_intersect>
 8006742:	4603      	mov	r3, r0
 8006744:	f083 0301 	eor.w	r3, r3, #1
 8006748:	b2db      	uxtb	r3, r3
 800674a:	2b00      	cmp	r3, #0
 800674c:	d001      	beq.n	8006752 <lv_obj_area_is_visible+0xbc>
 800674e:	2300      	movs	r3, #0
 8006750:	e04b      	b.n	80067ea <lv_obj_area_is_visible+0x154>

    lv_obj_get_transformed_area(obj, area, true, false);
 8006752:	2300      	movs	r3, #0
 8006754:	2201      	movs	r2, #1
 8006756:	6839      	ldr	r1, [r7, #0]
 8006758:	6878      	ldr	r0, [r7, #4]
 800675a:	f7ff feb4 	bl	80064c6 <lv_obj_get_transformed_area>

    /*Truncate recursively to the parents*/
    lv_obj_t * parent = lv_obj_get_parent(obj);
 800675e:	6878      	ldr	r0, [r7, #4]
 8006760:	f004 fb68 	bl	800ae34 <lv_obj_get_parent>
 8006764:	63f8      	str	r0, [r7, #60]	@ 0x3c
    while(parent != NULL) {
 8006766:	e03c      	b.n	80067e2 <lv_obj_area_is_visible+0x14c>
        /*If the parent is hidden then the child is hidden and won't be drawn*/
        if(lv_obj_has_flag(parent, LV_OBJ_FLAG_HIDDEN)) return false;
 8006768:	2101      	movs	r1, #1
 800676a:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 800676c:	f7fc faef 	bl	8002d4e <lv_obj_has_flag>
 8006770:	4603      	mov	r3, r0
 8006772:	2b00      	cmp	r3, #0
 8006774:	d001      	beq.n	800677a <lv_obj_area_is_visible+0xe4>
 8006776:	2300      	movs	r3, #0
 8006778:	e037      	b.n	80067ea <lv_obj_area_is_visible+0x154>

        /*Truncate to the parent and if no common parts break*/
        lv_area_t parent_coords = parent->coords;
 800677a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800677c:	f107 040c 	add.w	r4, r7, #12
 8006780:	3314      	adds	r3, #20
 8006782:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8006784:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        if(lv_obj_has_flag(parent, LV_OBJ_FLAG_OVERFLOW_VISIBLE)) {
 8006788:	f44f 1180 	mov.w	r1, #1048576	@ 0x100000
 800678c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 800678e:	f7fc fade 	bl	8002d4e <lv_obj_has_flag>
 8006792:	4603      	mov	r3, r0
 8006794:	2b00      	cmp	r3, #0
 8006796:	d00a      	beq.n	80067ae <lv_obj_area_is_visible+0x118>
            int32_t parent_ext_size = _lv_obj_get_ext_draw_size(parent);
 8006798:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 800679a:	f7fe fb11 	bl	8004dc0 <_lv_obj_get_ext_draw_size>
 800679e:	62f8      	str	r0, [r7, #44]	@ 0x2c
            lv_area_increase(&parent_coords, parent_ext_size, parent_ext_size);
 80067a0:	f107 030c 	add.w	r3, r7, #12
 80067a4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80067a6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80067a8:	4618      	mov	r0, r3
 80067aa:	f01b f885 	bl	80218b8 <lv_area_increase>
        }

        lv_obj_get_transformed_area(parent, &parent_coords, true, false);
 80067ae:	f107 010c 	add.w	r1, r7, #12
 80067b2:	2300      	movs	r3, #0
 80067b4:	2201      	movs	r2, #1
 80067b6:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80067b8:	f7ff fe85 	bl	80064c6 <lv_obj_get_transformed_area>
        if(!_lv_area_intersect(area, area, &parent_coords)) return false;
 80067bc:	f107 030c 	add.w	r3, r7, #12
 80067c0:	461a      	mov	r2, r3
 80067c2:	6839      	ldr	r1, [r7, #0]
 80067c4:	6838      	ldr	r0, [r7, #0]
 80067c6:	f01b f8bf 	bl	8021948 <_lv_area_intersect>
 80067ca:	4603      	mov	r3, r0
 80067cc:	f083 0301 	eor.w	r3, r3, #1
 80067d0:	b2db      	uxtb	r3, r3
 80067d2:	2b00      	cmp	r3, #0
 80067d4:	d001      	beq.n	80067da <lv_obj_area_is_visible+0x144>
 80067d6:	2300      	movs	r3, #0
 80067d8:	e007      	b.n	80067ea <lv_obj_area_is_visible+0x154>

        parent = lv_obj_get_parent(parent);
 80067da:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80067dc:	f004 fb2a 	bl	800ae34 <lv_obj_get_parent>
 80067e0:	63f8      	str	r0, [r7, #60]	@ 0x3c
    while(parent != NULL) {
 80067e2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80067e4:	2b00      	cmp	r3, #0
 80067e6:	d1bf      	bne.n	8006768 <lv_obj_area_is_visible+0xd2>
    }

    return true;
 80067e8:	2301      	movs	r3, #1
}
 80067ea:	4618      	mov	r0, r3
 80067ec:	3744      	adds	r7, #68	@ 0x44
 80067ee:	46bd      	mov	sp, r7
 80067f0:	bd90      	pop	{r4, r7, pc}
	...

080067f4 <lv_clamp_width>:

    return res;
}

int32_t lv_clamp_width(int32_t width, int32_t min_width, int32_t max_width, int32_t ref_width)
{
 80067f4:	b480      	push	{r7}
 80067f6:	b085      	sub	sp, #20
 80067f8:	af00      	add	r7, sp, #0
 80067fa:	60f8      	str	r0, [r7, #12]
 80067fc:	60b9      	str	r1, [r7, #8]
 80067fe:	607a      	str	r2, [r7, #4]
 8006800:	603b      	str	r3, [r7, #0]
    if(LV_COORD_IS_PCT(min_width)) min_width = (ref_width * LV_COORD_GET_PCT(min_width)) / 100;
 8006802:	68bb      	ldr	r3, [r7, #8]
 8006804:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 8006808:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800680c:	d11e      	bne.n	800684c <lv_clamp_width+0x58>
 800680e:	68bb      	ldr	r3, [r7, #8]
 8006810:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006814:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 8006818:	dc18      	bgt.n	800684c <lv_clamp_width+0x58>
 800681a:	68bb      	ldr	r3, [r7, #8]
 800681c:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006820:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8006824:	dd05      	ble.n	8006832 <lv_clamp_width+0x3e>
 8006826:	68bb      	ldr	r3, [r7, #8]
 8006828:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 800682c:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 8006830:	e002      	b.n	8006838 <lv_clamp_width+0x44>
 8006832:	68bb      	ldr	r3, [r7, #8]
 8006834:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006838:	683a      	ldr	r2, [r7, #0]
 800683a:	fb02 f303 	mul.w	r3, r2, r3
 800683e:	4a1d      	ldr	r2, [pc, #116]	@ (80068b4 <lv_clamp_width+0xc0>)
 8006840:	fb82 1203 	smull	r1, r2, r2, r3
 8006844:	1152      	asrs	r2, r2, #5
 8006846:	17db      	asrs	r3, r3, #31
 8006848:	1ad3      	subs	r3, r2, r3
 800684a:	60bb      	str	r3, [r7, #8]
    if(LV_COORD_IS_PCT(max_width)) max_width = (ref_width * LV_COORD_GET_PCT(max_width)) / 100;
 800684c:	687b      	ldr	r3, [r7, #4]
 800684e:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 8006852:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8006856:	d11e      	bne.n	8006896 <lv_clamp_width+0xa2>
 8006858:	687b      	ldr	r3, [r7, #4]
 800685a:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 800685e:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 8006862:	dc18      	bgt.n	8006896 <lv_clamp_width+0xa2>
 8006864:	687b      	ldr	r3, [r7, #4]
 8006866:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 800686a:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 800686e:	dd05      	ble.n	800687c <lv_clamp_width+0x88>
 8006870:	687b      	ldr	r3, [r7, #4]
 8006872:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006876:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 800687a:	e002      	b.n	8006882 <lv_clamp_width+0x8e>
 800687c:	687b      	ldr	r3, [r7, #4]
 800687e:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006882:	683a      	ldr	r2, [r7, #0]
 8006884:	fb02 f303 	mul.w	r3, r2, r3
 8006888:	4a0a      	ldr	r2, [pc, #40]	@ (80068b4 <lv_clamp_width+0xc0>)
 800688a:	fb82 1203 	smull	r1, r2, r2, r3
 800688e:	1152      	asrs	r2, r2, #5
 8006890:	17db      	asrs	r3, r3, #31
 8006892:	1ad3      	subs	r3, r2, r3
 8006894:	607b      	str	r3, [r7, #4]
    return LV_CLAMP(min_width, width, max_width);
 8006896:	687a      	ldr	r2, [r7, #4]
 8006898:	68fb      	ldr	r3, [r7, #12]
 800689a:	429a      	cmp	r2, r3
 800689c:	bfa8      	it	ge
 800689e:	461a      	movge	r2, r3
 80068a0:	68bb      	ldr	r3, [r7, #8]
 80068a2:	4293      	cmp	r3, r2
 80068a4:	bfb8      	it	lt
 80068a6:	4613      	movlt	r3, r2
}
 80068a8:	4618      	mov	r0, r3
 80068aa:	3714      	adds	r7, #20
 80068ac:	46bd      	mov	sp, r7
 80068ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80068b2:	4770      	bx	lr
 80068b4:	51eb851f 	.word	0x51eb851f

080068b8 <lv_clamp_height>:

int32_t lv_clamp_height(int32_t height, int32_t min_height, int32_t max_height, int32_t ref_height)
{
 80068b8:	b480      	push	{r7}
 80068ba:	b085      	sub	sp, #20
 80068bc:	af00      	add	r7, sp, #0
 80068be:	60f8      	str	r0, [r7, #12]
 80068c0:	60b9      	str	r1, [r7, #8]
 80068c2:	607a      	str	r2, [r7, #4]
 80068c4:	603b      	str	r3, [r7, #0]
    if(LV_COORD_IS_PCT(min_height)) min_height = (ref_height * LV_COORD_GET_PCT(min_height)) / 100;
 80068c6:	68bb      	ldr	r3, [r7, #8]
 80068c8:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 80068cc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80068d0:	d11e      	bne.n	8006910 <lv_clamp_height+0x58>
 80068d2:	68bb      	ldr	r3, [r7, #8]
 80068d4:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 80068d8:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 80068dc:	dc18      	bgt.n	8006910 <lv_clamp_height+0x58>
 80068de:	68bb      	ldr	r3, [r7, #8]
 80068e0:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 80068e4:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 80068e8:	dd05      	ble.n	80068f6 <lv_clamp_height+0x3e>
 80068ea:	68bb      	ldr	r3, [r7, #8]
 80068ec:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 80068f0:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 80068f4:	e002      	b.n	80068fc <lv_clamp_height+0x44>
 80068f6:	68bb      	ldr	r3, [r7, #8]
 80068f8:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 80068fc:	683a      	ldr	r2, [r7, #0]
 80068fe:	fb02 f303 	mul.w	r3, r2, r3
 8006902:	4a1d      	ldr	r2, [pc, #116]	@ (8006978 <lv_clamp_height+0xc0>)
 8006904:	fb82 1203 	smull	r1, r2, r2, r3
 8006908:	1152      	asrs	r2, r2, #5
 800690a:	17db      	asrs	r3, r3, #31
 800690c:	1ad3      	subs	r3, r2, r3
 800690e:	60bb      	str	r3, [r7, #8]
    if(LV_COORD_IS_PCT(max_height)) max_height = (ref_height * LV_COORD_GET_PCT(max_height)) / 100;
 8006910:	687b      	ldr	r3, [r7, #4]
 8006912:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 8006916:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800691a:	d11e      	bne.n	800695a <lv_clamp_height+0xa2>
 800691c:	687b      	ldr	r3, [r7, #4]
 800691e:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006922:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 8006926:	dc18      	bgt.n	800695a <lv_clamp_height+0xa2>
 8006928:	687b      	ldr	r3, [r7, #4]
 800692a:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 800692e:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8006932:	dd05      	ble.n	8006940 <lv_clamp_height+0x88>
 8006934:	687b      	ldr	r3, [r7, #4]
 8006936:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 800693a:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 800693e:	e002      	b.n	8006946 <lv_clamp_height+0x8e>
 8006940:	687b      	ldr	r3, [r7, #4]
 8006942:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006946:	683a      	ldr	r2, [r7, #0]
 8006948:	fb02 f303 	mul.w	r3, r2, r3
 800694c:	4a0a      	ldr	r2, [pc, #40]	@ (8006978 <lv_clamp_height+0xc0>)
 800694e:	fb82 1203 	smull	r1, r2, r2, r3
 8006952:	1152      	asrs	r2, r2, #5
 8006954:	17db      	asrs	r3, r3, #31
 8006956:	1ad3      	subs	r3, r2, r3
 8006958:	607b      	str	r3, [r7, #4]
    return LV_CLAMP(min_height, height, max_height);
 800695a:	687a      	ldr	r2, [r7, #4]
 800695c:	68fb      	ldr	r3, [r7, #12]
 800695e:	429a      	cmp	r2, r3
 8006960:	bfa8      	it	ge
 8006962:	461a      	movge	r2, r3
 8006964:	68bb      	ldr	r3, [r7, #8]
 8006966:	4293      	cmp	r3, r2
 8006968:	bfb8      	it	lt
 800696a:	4613      	movlt	r3, r2
}
 800696c:	4618      	mov	r0, r3
 800696e:	3714      	adds	r7, #20
 8006970:	46bd      	mov	sp, r7
 8006972:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006976:	4770      	bx	lr
 8006978:	51eb851f 	.word	0x51eb851f

0800697c <calc_content_width>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static int32_t calc_content_width(lv_obj_t * obj)
{
 800697c:	b580      	push	{r7, lr}
 800697e:	b090      	sub	sp, #64	@ 0x40
 8006980:	af00      	add	r7, sp, #0
 8006982:	6078      	str	r0, [r7, #4]
    int32_t scroll_x_tmp = lv_obj_get_scroll_x(obj);
 8006984:	6878      	ldr	r0, [r7, #4]
 8006986:	f000 fd59 	bl	800743c <lv_obj_get_scroll_x>
 800698a:	62f8      	str	r0, [r7, #44]	@ 0x2c
    if(obj->spec_attr) obj->spec_attr->scroll.x = 0;
 800698c:	687b      	ldr	r3, [r7, #4]
 800698e:	689b      	ldr	r3, [r3, #8]
 8006990:	2b00      	cmp	r3, #0
 8006992:	d003      	beq.n	800699c <calc_content_width+0x20>
 8006994:	687b      	ldr	r3, [r7, #4]
 8006996:	689b      	ldr	r3, [r3, #8]
 8006998:	2200      	movs	r2, #0
 800699a:	619a      	str	r2, [r3, #24]

    int32_t space_right = lv_obj_get_style_space_right(obj, LV_PART_MAIN);
 800699c:	2100      	movs	r1, #0
 800699e:	6878      	ldr	r0, [r7, #4]
 80069a0:	f7fe fe4e 	bl	8005640 <lv_obj_get_style_space_right>
 80069a4:	62b8      	str	r0, [r7, #40]	@ 0x28
    int32_t space_left = lv_obj_get_style_space_left(obj, LV_PART_MAIN);
 80069a6:	2100      	movs	r1, #0
 80069a8:	6878      	ldr	r0, [r7, #4]
 80069aa:	f7fe fe26 	bl	80055fa <lv_obj_get_style_space_left>
 80069ae:	6278      	str	r0, [r7, #36]	@ 0x24

    int32_t self_w;
    self_w = lv_obj_get_self_width(obj) + space_left + space_right;
 80069b0:	6878      	ldr	r0, [r7, #4]
 80069b2:	f7ff fa43 	bl	8005e3c <lv_obj_get_self_width>
 80069b6:	4602      	mov	r2, r0
 80069b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80069ba:	4413      	add	r3, r2
 80069bc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80069be:	4413      	add	r3, r2
 80069c0:	623b      	str	r3, [r7, #32]

    int32_t child_res = LV_COORD_MIN;
 80069c2:	4b9a      	ldr	r3, [pc, #616]	@ (8006c2c <calc_content_width+0x2b0>)
 80069c4:	63fb      	str	r3, [r7, #60]	@ 0x3c
    uint32_t i;
    uint32_t child_cnt = lv_obj_get_child_count(obj);
 80069c6:	6878      	ldr	r0, [r7, #4]
 80069c8:	f004 fa7a 	bl	800aec0 <lv_obj_get_child_count>
 80069cc:	61f8      	str	r0, [r7, #28]
    /*With RTL find the left most coordinate*/
    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) == LV_BASE_DIR_RTL) {
 80069ce:	2100      	movs	r1, #0
 80069d0:	6878      	ldr	r0, [r7, #4]
 80069d2:	f7fe fe00 	bl	80055d6 <lv_obj_get_style_base_dir>
 80069d6:	4603      	mov	r3, r0
 80069d8:	2b01      	cmp	r3, #1
 80069da:	f040 8089 	bne.w	8006af0 <calc_content_width+0x174>
        for(i = 0; i < child_cnt; i++) {
 80069de:	2300      	movs	r3, #0
 80069e0:	63bb      	str	r3, [r7, #56]	@ 0x38
 80069e2:	e077      	b.n	8006ad4 <calc_content_width+0x158>
            int32_t child_res_tmp = LV_COORD_MIN;
 80069e4:	4b91      	ldr	r3, [pc, #580]	@ (8006c2c <calc_content_width+0x2b0>)
 80069e6:	637b      	str	r3, [r7, #52]	@ 0x34
            lv_obj_t * child = obj->spec_attr->children[i];
 80069e8:	687b      	ldr	r3, [r7, #4]
 80069ea:	689b      	ldr	r3, [r3, #8]
 80069ec:	681a      	ldr	r2, [r3, #0]
 80069ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80069f0:	009b      	lsls	r3, r3, #2
 80069f2:	4413      	add	r3, r2
 80069f4:	681b      	ldr	r3, [r3, #0]
 80069f6:	613b      	str	r3, [r7, #16]
            if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 80069f8:	498d      	ldr	r1, [pc, #564]	@ (8006c30 <calc_content_width+0x2b4>)
 80069fa:	6938      	ldr	r0, [r7, #16]
 80069fc:	f7fc f9bc 	bl	8002d78 <lv_obj_has_flag_any>
 8006a00:	4603      	mov	r3, r0
 8006a02:	2b00      	cmp	r3, #0
 8006a04:	d162      	bne.n	8006acc <calc_content_width+0x150>

            if(!lv_obj_is_layout_positioned(child)) {
 8006a06:	6938      	ldr	r0, [r7, #16]
 8006a08:	f7ff f8f0 	bl	8005bec <lv_obj_is_layout_positioned>
 8006a0c:	4603      	mov	r3, r0
 8006a0e:	f083 0301 	eor.w	r3, r3, #1
 8006a12:	b2db      	uxtb	r3, r3
 8006a14:	2b00      	cmp	r3, #0
 8006a16:	d03b      	beq.n	8006a90 <calc_content_width+0x114>
                lv_align_t align = lv_obj_get_style_align(child, 0);
 8006a18:	2100      	movs	r1, #0
 8006a1a:	6938      	ldr	r0, [r7, #16]
 8006a1c:	f7fe fc95 	bl	800534a <lv_obj_get_style_align>
 8006a20:	4603      	mov	r3, r0
 8006a22:	73fb      	strb	r3, [r7, #15]
                switch(align) {
 8006a24:	7bfb      	ldrb	r3, [r7, #15]
 8006a26:	2b08      	cmp	r3, #8
 8006a28:	bf8c      	ite	hi
 8006a2a:	2201      	movhi	r2, #1
 8006a2c:	2200      	movls	r2, #0
 8006a2e:	b2d2      	uxtb	r2, r2
 8006a30:	2a00      	cmp	r2, #0
 8006a32:	d114      	bne.n	8006a5e <calc_content_width+0xe2>
 8006a34:	f240 1249 	movw	r2, #329	@ 0x149
 8006a38:	fa22 f303 	lsr.w	r3, r2, r3
 8006a3c:	f003 0301 	and.w	r3, r3, #1
 8006a40:	2b00      	cmp	r3, #0
 8006a42:	bf14      	ite	ne
 8006a44:	2301      	movne	r3, #1
 8006a46:	2300      	moveq	r3, #0
 8006a48:	b2db      	uxtb	r3, r3
 8006a4a:	2b00      	cmp	r3, #0
 8006a4c:	d007      	beq.n	8006a5e <calc_content_width+0xe2>
                    case LV_ALIGN_DEFAULT:
                    case LV_ALIGN_TOP_RIGHT:
                    case LV_ALIGN_BOTTOM_RIGHT:
                    case LV_ALIGN_RIGHT_MID:
                        /*Normal right aligns. Other are ignored due to possible circular dependencies*/
                        child_res_tmp = obj->coords.x2 - child->coords.x1 + 1;
 8006a4e:	687b      	ldr	r3, [r7, #4]
 8006a50:	69da      	ldr	r2, [r3, #28]
 8006a52:	693b      	ldr	r3, [r7, #16]
 8006a54:	695b      	ldr	r3, [r3, #20]
 8006a56:	1ad3      	subs	r3, r2, r3
 8006a58:	3301      	adds	r3, #1
 8006a5a:	637b      	str	r3, [r7, #52]	@ 0x34
                        break;
 8006a5c:	e021      	b.n	8006aa2 <calc_content_width+0x126>
                    default:
                        /* Consider other cases only if x=0 and use the width of the object.
                         * With x!=0 circular dependency could occur. */
                        if(lv_obj_get_style_x(child, 0) == 0) {
 8006a5e:	2100      	movs	r1, #0
 8006a60:	6938      	ldr	r0, [r7, #16]
 8006a62:	f7fe fc50 	bl	8005306 <lv_obj_get_style_x>
 8006a66:	4603      	mov	r3, r0
 8006a68:	2b00      	cmp	r3, #0
 8006a6a:	d119      	bne.n	8006aa0 <calc_content_width+0x124>
                            child_res_tmp = lv_area_get_width(&child->coords) + space_right;
 8006a6c:	693b      	ldr	r3, [r7, #16]
 8006a6e:	3314      	adds	r3, #20
 8006a70:	4618      	mov	r0, r3
 8006a72:	f7fe fbc2 	bl	80051fa <lv_area_get_width>
 8006a76:	4602      	mov	r2, r0
 8006a78:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006a7a:	4413      	add	r3, r2
 8006a7c:	637b      	str	r3, [r7, #52]	@ 0x34
                            child_res_tmp += lv_obj_get_style_margin_left(child, LV_PART_MAIN);
 8006a7e:	2100      	movs	r1, #0
 8006a80:	6938      	ldr	r0, [r7, #16]
 8006a82:	f7fe fd51 	bl	8005528 <lv_obj_get_style_margin_left>
 8006a86:	4602      	mov	r2, r0
 8006a88:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8006a8a:	4413      	add	r3, r2
 8006a8c:	637b      	str	r3, [r7, #52]	@ 0x34
                        }
                        break;
 8006a8e:	e007      	b.n	8006aa0 <calc_content_width+0x124>
                }
            }
            else {
                child_res_tmp = obj->coords.x2 - child->coords.x1 + 1;
 8006a90:	687b      	ldr	r3, [r7, #4]
 8006a92:	69da      	ldr	r2, [r3, #28]
 8006a94:	693b      	ldr	r3, [r7, #16]
 8006a96:	695b      	ldr	r3, [r3, #20]
 8006a98:	1ad3      	subs	r3, r2, r3
 8006a9a:	3301      	adds	r3, #1
 8006a9c:	637b      	str	r3, [r7, #52]	@ 0x34
 8006a9e:	e000      	b.n	8006aa2 <calc_content_width+0x126>
                        break;
 8006aa0:	bf00      	nop
            }
            child_res = LV_MAX(child_res, child_res_tmp + lv_obj_get_style_margin_left(child, LV_PART_MAIN));
 8006aa2:	2100      	movs	r1, #0
 8006aa4:	6938      	ldr	r0, [r7, #16]
 8006aa6:	f7fe fd3f 	bl	8005528 <lv_obj_get_style_margin_left>
 8006aaa:	4602      	mov	r2, r0
 8006aac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8006aae:	4413      	add	r3, r2
 8006ab0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8006ab2:	429a      	cmp	r2, r3
 8006ab4:	dc07      	bgt.n	8006ac6 <calc_content_width+0x14a>
 8006ab6:	2100      	movs	r1, #0
 8006ab8:	6938      	ldr	r0, [r7, #16]
 8006aba:	f7fe fd35 	bl	8005528 <lv_obj_get_style_margin_left>
 8006abe:	4602      	mov	r2, r0
 8006ac0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8006ac2:	4413      	add	r3, r2
 8006ac4:	e000      	b.n	8006ac8 <calc_content_width+0x14c>
 8006ac6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8006ac8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8006aca:	e000      	b.n	8006ace <calc_content_width+0x152>
            if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 8006acc:	bf00      	nop
        for(i = 0; i < child_cnt; i++) {
 8006ace:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8006ad0:	3301      	adds	r3, #1
 8006ad2:	63bb      	str	r3, [r7, #56]	@ 0x38
 8006ad4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8006ad6:	69fb      	ldr	r3, [r7, #28]
 8006ad8:	429a      	cmp	r2, r3
 8006ada:	d383      	bcc.n	80069e4 <calc_content_width+0x68>
        }
        if(child_res != LV_COORD_MIN) {
 8006adc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8006ade:	4a53      	ldr	r2, [pc, #332]	@ (8006c2c <calc_content_width+0x2b0>)
 8006ae0:	4293      	cmp	r3, r2
 8006ae2:	f000 808b 	beq.w	8006bfc <calc_content_width+0x280>
            child_res += space_left;
 8006ae6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8006ae8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006aea:	4413      	add	r3, r2
 8006aec:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8006aee:	e085      	b.n	8006bfc <calc_content_width+0x280>
        }
    }
    /*Else find the right most coordinate*/
    else {
        for(i = 0; i < child_cnt; i++) {
 8006af0:	2300      	movs	r3, #0
 8006af2:	63bb      	str	r3, [r7, #56]	@ 0x38
 8006af4:	e076      	b.n	8006be4 <calc_content_width+0x268>
            int32_t child_res_tmp = LV_COORD_MIN;
 8006af6:	4b4d      	ldr	r3, [pc, #308]	@ (8006c2c <calc_content_width+0x2b0>)
 8006af8:	633b      	str	r3, [r7, #48]	@ 0x30
            lv_obj_t * child = obj->spec_attr->children[i];
 8006afa:	687b      	ldr	r3, [r7, #4]
 8006afc:	689b      	ldr	r3, [r3, #8]
 8006afe:	681a      	ldr	r2, [r3, #0]
 8006b00:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8006b02:	009b      	lsls	r3, r3, #2
 8006b04:	4413      	add	r3, r2
 8006b06:	681b      	ldr	r3, [r3, #0]
 8006b08:	61bb      	str	r3, [r7, #24]
            if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 8006b0a:	4949      	ldr	r1, [pc, #292]	@ (8006c30 <calc_content_width+0x2b4>)
 8006b0c:	69b8      	ldr	r0, [r7, #24]
 8006b0e:	f7fc f933 	bl	8002d78 <lv_obj_has_flag_any>
 8006b12:	4603      	mov	r3, r0
 8006b14:	2b00      	cmp	r3, #0
 8006b16:	d161      	bne.n	8006bdc <calc_content_width+0x260>

            if(!lv_obj_is_layout_positioned(child)) {
 8006b18:	69b8      	ldr	r0, [r7, #24]
 8006b1a:	f7ff f867 	bl	8005bec <lv_obj_is_layout_positioned>
 8006b1e:	4603      	mov	r3, r0
 8006b20:	f083 0301 	eor.w	r3, r3, #1
 8006b24:	b2db      	uxtb	r3, r3
 8006b26:	2b00      	cmp	r3, #0
 8006b28:	d03a      	beq.n	8006ba0 <calc_content_width+0x224>
                lv_align_t align = lv_obj_get_style_align(child, 0);
 8006b2a:	2100      	movs	r1, #0
 8006b2c:	69b8      	ldr	r0, [r7, #24]
 8006b2e:	f7fe fc0c 	bl	800534a <lv_obj_get_style_align>
 8006b32:	4603      	mov	r3, r0
 8006b34:	75fb      	strb	r3, [r7, #23]
                switch(align) {
 8006b36:	7dfb      	ldrb	r3, [r7, #23]
 8006b38:	2b07      	cmp	r3, #7
 8006b3a:	bf8c      	ite	hi
 8006b3c:	2201      	movhi	r2, #1
 8006b3e:	2200      	movls	r2, #0
 8006b40:	b2d2      	uxtb	r2, r2
 8006b42:	2a00      	cmp	r2, #0
 8006b44:	d113      	bne.n	8006b6e <calc_content_width+0x1f2>
 8006b46:	2293      	movs	r2, #147	@ 0x93
 8006b48:	fa22 f303 	lsr.w	r3, r2, r3
 8006b4c:	f003 0301 	and.w	r3, r3, #1
 8006b50:	2b00      	cmp	r3, #0
 8006b52:	bf14      	ite	ne
 8006b54:	2301      	movne	r3, #1
 8006b56:	2300      	moveq	r3, #0
 8006b58:	b2db      	uxtb	r3, r3
 8006b5a:	2b00      	cmp	r3, #0
 8006b5c:	d007      	beq.n	8006b6e <calc_content_width+0x1f2>
                    case LV_ALIGN_DEFAULT:
                    case LV_ALIGN_TOP_LEFT:
                    case LV_ALIGN_BOTTOM_LEFT:
                    case LV_ALIGN_LEFT_MID:
                        /*Normal left aligns.*/
                        child_res_tmp = child->coords.x2 - obj->coords.x1 + 1;
 8006b5e:	69bb      	ldr	r3, [r7, #24]
 8006b60:	69da      	ldr	r2, [r3, #28]
 8006b62:	687b      	ldr	r3, [r7, #4]
 8006b64:	695b      	ldr	r3, [r3, #20]
 8006b66:	1ad3      	subs	r3, r2, r3
 8006b68:	3301      	adds	r3, #1
 8006b6a:	633b      	str	r3, [r7, #48]	@ 0x30
                        break;
 8006b6c:	e021      	b.n	8006bb2 <calc_content_width+0x236>
                    default:
                        /* Consider other cases only if x=0 and use the width of the object.
                         * With x!=0 circular dependency could occur. */
                        if(lv_obj_get_style_y(child, 0) == 0) {
 8006b6e:	2100      	movs	r1, #0
 8006b70:	69b8      	ldr	r0, [r7, #24]
 8006b72:	f7fe fbd9 	bl	8005328 <lv_obj_get_style_y>
 8006b76:	4603      	mov	r3, r0
 8006b78:	2b00      	cmp	r3, #0
 8006b7a:	d119      	bne.n	8006bb0 <calc_content_width+0x234>
                            child_res_tmp = lv_area_get_width(&child->coords) + space_left;
 8006b7c:	69bb      	ldr	r3, [r7, #24]
 8006b7e:	3314      	adds	r3, #20
 8006b80:	4618      	mov	r0, r3
 8006b82:	f7fe fb3a 	bl	80051fa <lv_area_get_width>
 8006b86:	4602      	mov	r2, r0
 8006b88:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006b8a:	4413      	add	r3, r2
 8006b8c:	633b      	str	r3, [r7, #48]	@ 0x30
                            child_res_tmp += lv_obj_get_style_margin_right(child, LV_PART_MAIN);
 8006b8e:	2100      	movs	r1, #0
 8006b90:	69b8      	ldr	r0, [r7, #24]
 8006b92:	f7fe fcda 	bl	800554a <lv_obj_get_style_margin_right>
 8006b96:	4602      	mov	r2, r0
 8006b98:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8006b9a:	4413      	add	r3, r2
 8006b9c:	633b      	str	r3, [r7, #48]	@ 0x30
                        }
                        break;
 8006b9e:	e007      	b.n	8006bb0 <calc_content_width+0x234>
                }
            }
            else {
                child_res_tmp = child->coords.x2 - obj->coords.x1 + 1;
 8006ba0:	69bb      	ldr	r3, [r7, #24]
 8006ba2:	69da      	ldr	r2, [r3, #28]
 8006ba4:	687b      	ldr	r3, [r7, #4]
 8006ba6:	695b      	ldr	r3, [r3, #20]
 8006ba8:	1ad3      	subs	r3, r2, r3
 8006baa:	3301      	adds	r3, #1
 8006bac:	633b      	str	r3, [r7, #48]	@ 0x30
 8006bae:	e000      	b.n	8006bb2 <calc_content_width+0x236>
                        break;
 8006bb0:	bf00      	nop
            }

            child_res = LV_MAX(child_res, child_res_tmp + lv_obj_get_style_margin_right(child, LV_PART_MAIN));
 8006bb2:	2100      	movs	r1, #0
 8006bb4:	69b8      	ldr	r0, [r7, #24]
 8006bb6:	f7fe fcc8 	bl	800554a <lv_obj_get_style_margin_right>
 8006bba:	4602      	mov	r2, r0
 8006bbc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8006bbe:	4413      	add	r3, r2
 8006bc0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8006bc2:	429a      	cmp	r2, r3
 8006bc4:	dc07      	bgt.n	8006bd6 <calc_content_width+0x25a>
 8006bc6:	2100      	movs	r1, #0
 8006bc8:	69b8      	ldr	r0, [r7, #24]
 8006bca:	f7fe fcbe 	bl	800554a <lv_obj_get_style_margin_right>
 8006bce:	4602      	mov	r2, r0
 8006bd0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8006bd2:	4413      	add	r3, r2
 8006bd4:	e000      	b.n	8006bd8 <calc_content_width+0x25c>
 8006bd6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8006bd8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8006bda:	e000      	b.n	8006bde <calc_content_width+0x262>
            if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 8006bdc:	bf00      	nop
        for(i = 0; i < child_cnt; i++) {
 8006bde:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8006be0:	3301      	adds	r3, #1
 8006be2:	63bb      	str	r3, [r7, #56]	@ 0x38
 8006be4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8006be6:	69fb      	ldr	r3, [r7, #28]
 8006be8:	429a      	cmp	r2, r3
 8006bea:	d384      	bcc.n	8006af6 <calc_content_width+0x17a>
        }

        if(child_res != LV_COORD_MIN) {
 8006bec:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8006bee:	4a0f      	ldr	r2, [pc, #60]	@ (8006c2c <calc_content_width+0x2b0>)
 8006bf0:	4293      	cmp	r3, r2
 8006bf2:	d003      	beq.n	8006bfc <calc_content_width+0x280>
            child_res += space_right;
 8006bf4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8006bf6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006bf8:	4413      	add	r3, r2
 8006bfa:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
    }

    if(obj->spec_attr) obj->spec_attr->scroll.x = -scroll_x_tmp;
 8006bfc:	687b      	ldr	r3, [r7, #4]
 8006bfe:	689b      	ldr	r3, [r3, #8]
 8006c00:	2b00      	cmp	r3, #0
 8006c02:	d004      	beq.n	8006c0e <calc_content_width+0x292>
 8006c04:	687b      	ldr	r3, [r7, #4]
 8006c06:	689b      	ldr	r3, [r3, #8]
 8006c08:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8006c0a:	4252      	negs	r2, r2
 8006c0c:	619a      	str	r2, [r3, #24]

    if(child_res == LV_COORD_MIN) return self_w;
 8006c0e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8006c10:	4a06      	ldr	r2, [pc, #24]	@ (8006c2c <calc_content_width+0x2b0>)
 8006c12:	4293      	cmp	r3, r2
 8006c14:	d101      	bne.n	8006c1a <calc_content_width+0x29e>
 8006c16:	6a3b      	ldr	r3, [r7, #32]
 8006c18:	e004      	b.n	8006c24 <calc_content_width+0x2a8>
    return LV_MAX(child_res, self_w);
 8006c1a:	6a3a      	ldr	r2, [r7, #32]
 8006c1c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8006c1e:	4293      	cmp	r3, r2
 8006c20:	bfb8      	it	lt
 8006c22:	4613      	movlt	r3, r2
}
 8006c24:	4618      	mov	r0, r3
 8006c26:	3740      	adds	r7, #64	@ 0x40
 8006c28:	46bd      	mov	sp, r7
 8006c2a:	bd80      	pop	{r7, pc}
 8006c2c:	e0000001 	.word	0xe0000001
 8006c30:	00040001 	.word	0x00040001

08006c34 <calc_content_height>:

static int32_t calc_content_height(lv_obj_t * obj)
{
 8006c34:	b580      	push	{r7, lr}
 8006c36:	b08c      	sub	sp, #48	@ 0x30
 8006c38:	af00      	add	r7, sp, #0
 8006c3a:	6078      	str	r0, [r7, #4]
    int32_t scroll_y_tmp = lv_obj_get_scroll_y(obj);
 8006c3c:	6878      	ldr	r0, [r7, #4]
 8006c3e:	f000 fc11 	bl	8007464 <lv_obj_get_scroll_y>
 8006c42:	6238      	str	r0, [r7, #32]
    if(obj->spec_attr) obj->spec_attr->scroll.y = 0;
 8006c44:	687b      	ldr	r3, [r7, #4]
 8006c46:	689b      	ldr	r3, [r3, #8]
 8006c48:	2b00      	cmp	r3, #0
 8006c4a:	d003      	beq.n	8006c54 <calc_content_height+0x20>
 8006c4c:	687b      	ldr	r3, [r7, #4]
 8006c4e:	689b      	ldr	r3, [r3, #8]
 8006c50:	2200      	movs	r2, #0
 8006c52:	61da      	str	r2, [r3, #28]

    int32_t space_top = lv_obj_get_style_space_top(obj, LV_PART_MAIN);
 8006c54:	2100      	movs	r1, #0
 8006c56:	6878      	ldr	r0, [r7, #4]
 8006c58:	f7fe fd15 	bl	8005686 <lv_obj_get_style_space_top>
 8006c5c:	61f8      	str	r0, [r7, #28]
    int32_t space_bottom = lv_obj_get_style_space_bottom(obj, LV_PART_MAIN);
 8006c5e:	2100      	movs	r1, #0
 8006c60:	6878      	ldr	r0, [r7, #4]
 8006c62:	f7fe fd33 	bl	80056cc <lv_obj_get_style_space_bottom>
 8006c66:	61b8      	str	r0, [r7, #24]

    int32_t self_h;
    self_h = lv_obj_get_self_height(obj) + space_top + space_bottom;
 8006c68:	6878      	ldr	r0, [r7, #4]
 8006c6a:	f7ff f8fd 	bl	8005e68 <lv_obj_get_self_height>
 8006c6e:	4602      	mov	r2, r0
 8006c70:	69fb      	ldr	r3, [r7, #28]
 8006c72:	4413      	add	r3, r2
 8006c74:	69ba      	ldr	r2, [r7, #24]
 8006c76:	4413      	add	r3, r2
 8006c78:	617b      	str	r3, [r7, #20]

    int32_t child_res = LV_COORD_MIN;
 8006c7a:	4b46      	ldr	r3, [pc, #280]	@ (8006d94 <calc_content_height+0x160>)
 8006c7c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    uint32_t i;
    uint32_t child_cnt = lv_obj_get_child_count(obj);
 8006c7e:	6878      	ldr	r0, [r7, #4]
 8006c80:	f004 f91e 	bl	800aec0 <lv_obj_get_child_count>
 8006c84:	6138      	str	r0, [r7, #16]
    for(i = 0; i < child_cnt; i++) {
 8006c86:	2300      	movs	r3, #0
 8006c88:	62bb      	str	r3, [r7, #40]	@ 0x28
 8006c8a:	e065      	b.n	8006d58 <calc_content_height+0x124>
        int32_t child_res_tmp = LV_COORD_MIN;
 8006c8c:	4b41      	ldr	r3, [pc, #260]	@ (8006d94 <calc_content_height+0x160>)
 8006c8e:	627b      	str	r3, [r7, #36]	@ 0x24
        lv_obj_t * child = obj->spec_attr->children[i];
 8006c90:	687b      	ldr	r3, [r7, #4]
 8006c92:	689b      	ldr	r3, [r3, #8]
 8006c94:	681a      	ldr	r2, [r3, #0]
 8006c96:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006c98:	009b      	lsls	r3, r3, #2
 8006c9a:	4413      	add	r3, r2
 8006c9c:	681b      	ldr	r3, [r3, #0]
 8006c9e:	60fb      	str	r3, [r7, #12]
        if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 8006ca0:	493d      	ldr	r1, [pc, #244]	@ (8006d98 <calc_content_height+0x164>)
 8006ca2:	68f8      	ldr	r0, [r7, #12]
 8006ca4:	f7fc f868 	bl	8002d78 <lv_obj_has_flag_any>
 8006ca8:	4603      	mov	r3, r0
 8006caa:	2b00      	cmp	r3, #0
 8006cac:	d150      	bne.n	8006d50 <calc_content_height+0x11c>

        if(!lv_obj_is_layout_positioned(child)) {
 8006cae:	68f8      	ldr	r0, [r7, #12]
 8006cb0:	f7fe ff9c 	bl	8005bec <lv_obj_is_layout_positioned>
 8006cb4:	4603      	mov	r3, r0
 8006cb6:	f083 0301 	eor.w	r3, r3, #1
 8006cba:	b2db      	uxtb	r3, r3
 8006cbc:	2b00      	cmp	r3, #0
 8006cbe:	d029      	beq.n	8006d14 <calc_content_height+0xe0>
            lv_align_t align = lv_obj_get_style_align(child, 0);
 8006cc0:	2100      	movs	r1, #0
 8006cc2:	68f8      	ldr	r0, [r7, #12]
 8006cc4:	f7fe fb41 	bl	800534a <lv_obj_get_style_align>
 8006cc8:	4603      	mov	r3, r0
 8006cca:	72fb      	strb	r3, [r7, #11]
            switch(align) {
 8006ccc:	7afb      	ldrb	r3, [r7, #11]
 8006cce:	2b03      	cmp	r3, #3
 8006cd0:	d807      	bhi.n	8006ce2 <calc_content_height+0xae>
                case LV_ALIGN_DEFAULT:
                case LV_ALIGN_TOP_RIGHT:
                case LV_ALIGN_TOP_MID:
                case LV_ALIGN_TOP_LEFT:
                    /*Normal top aligns. */
                    child_res_tmp = child->coords.y2 - obj->coords.y1 + 1;
 8006cd2:	68fb      	ldr	r3, [r7, #12]
 8006cd4:	6a1a      	ldr	r2, [r3, #32]
 8006cd6:	687b      	ldr	r3, [r7, #4]
 8006cd8:	699b      	ldr	r3, [r3, #24]
 8006cda:	1ad3      	subs	r3, r2, r3
 8006cdc:	3301      	adds	r3, #1
 8006cde:	627b      	str	r3, [r7, #36]	@ 0x24
                    break;
 8006ce0:	e021      	b.n	8006d26 <calc_content_height+0xf2>
                default:
                    /* Consider other cases only if y=0 and use the height of the object.
                     * With y!=0 circular dependency could occur. */
                    if(lv_obj_get_style_y(child, 0) == 0) {
 8006ce2:	2100      	movs	r1, #0
 8006ce4:	68f8      	ldr	r0, [r7, #12]
 8006ce6:	f7fe fb1f 	bl	8005328 <lv_obj_get_style_y>
 8006cea:	4603      	mov	r3, r0
 8006cec:	2b00      	cmp	r3, #0
 8006cee:	d119      	bne.n	8006d24 <calc_content_height+0xf0>
                        child_res_tmp = lv_area_get_height(&child->coords) + space_top;
 8006cf0:	68fb      	ldr	r3, [r7, #12]
 8006cf2:	3314      	adds	r3, #20
 8006cf4:	4618      	mov	r0, r3
 8006cf6:	f7fe fa90 	bl	800521a <lv_area_get_height>
 8006cfa:	4602      	mov	r2, r0
 8006cfc:	69fb      	ldr	r3, [r7, #28]
 8006cfe:	4413      	add	r3, r2
 8006d00:	627b      	str	r3, [r7, #36]	@ 0x24
                        child_res_tmp += lv_obj_get_style_margin_top(child, LV_PART_MAIN);
 8006d02:	2100      	movs	r1, #0
 8006d04:	68f8      	ldr	r0, [r7, #12]
 8006d06:	f7fe fbed 	bl	80054e4 <lv_obj_get_style_margin_top>
 8006d0a:	4602      	mov	r2, r0
 8006d0c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006d0e:	4413      	add	r3, r2
 8006d10:	627b      	str	r3, [r7, #36]	@ 0x24
                    }
                    break;
 8006d12:	e007      	b.n	8006d24 <calc_content_height+0xf0>
            }
        }
        else {
            child_res_tmp = child->coords.y2 - obj->coords.y1 + 1;
 8006d14:	68fb      	ldr	r3, [r7, #12]
 8006d16:	6a1a      	ldr	r2, [r3, #32]
 8006d18:	687b      	ldr	r3, [r7, #4]
 8006d1a:	699b      	ldr	r3, [r3, #24]
 8006d1c:	1ad3      	subs	r3, r2, r3
 8006d1e:	3301      	adds	r3, #1
 8006d20:	627b      	str	r3, [r7, #36]	@ 0x24
 8006d22:	e000      	b.n	8006d26 <calc_content_height+0xf2>
                    break;
 8006d24:	bf00      	nop
        }

        child_res = LV_MAX(child_res, child_res_tmp + lv_obj_get_style_margin_bottom(child, LV_PART_MAIN));
 8006d26:	2100      	movs	r1, #0
 8006d28:	68f8      	ldr	r0, [r7, #12]
 8006d2a:	f7fe fbec 	bl	8005506 <lv_obj_get_style_margin_bottom>
 8006d2e:	4602      	mov	r2, r0
 8006d30:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006d32:	4413      	add	r3, r2
 8006d34:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8006d36:	429a      	cmp	r2, r3
 8006d38:	dc07      	bgt.n	8006d4a <calc_content_height+0x116>
 8006d3a:	2100      	movs	r1, #0
 8006d3c:	68f8      	ldr	r0, [r7, #12]
 8006d3e:	f7fe fbe2 	bl	8005506 <lv_obj_get_style_margin_bottom>
 8006d42:	4602      	mov	r2, r0
 8006d44:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006d46:	4413      	add	r3, r2
 8006d48:	e000      	b.n	8006d4c <calc_content_height+0x118>
 8006d4a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006d4c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8006d4e:	e000      	b.n	8006d52 <calc_content_height+0x11e>
        if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 8006d50:	bf00      	nop
    for(i = 0; i < child_cnt; i++) {
 8006d52:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006d54:	3301      	adds	r3, #1
 8006d56:	62bb      	str	r3, [r7, #40]	@ 0x28
 8006d58:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8006d5a:	693b      	ldr	r3, [r7, #16]
 8006d5c:	429a      	cmp	r2, r3
 8006d5e:	d395      	bcc.n	8006c8c <calc_content_height+0x58>
    }

    if(obj->spec_attr) obj->spec_attr->scroll.y = -scroll_y_tmp;
 8006d60:	687b      	ldr	r3, [r7, #4]
 8006d62:	689b      	ldr	r3, [r3, #8]
 8006d64:	2b00      	cmp	r3, #0
 8006d66:	d004      	beq.n	8006d72 <calc_content_height+0x13e>
 8006d68:	687b      	ldr	r3, [r7, #4]
 8006d6a:	689b      	ldr	r3, [r3, #8]
 8006d6c:	6a3a      	ldr	r2, [r7, #32]
 8006d6e:	4252      	negs	r2, r2
 8006d70:	61da      	str	r2, [r3, #28]

    if(child_res == LV_COORD_MIN) return self_h;
 8006d72:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8006d74:	4a07      	ldr	r2, [pc, #28]	@ (8006d94 <calc_content_height+0x160>)
 8006d76:	4293      	cmp	r3, r2
 8006d78:	d101      	bne.n	8006d7e <calc_content_height+0x14a>
 8006d7a:	697b      	ldr	r3, [r7, #20]
 8006d7c:	e006      	b.n	8006d8c <calc_content_height+0x158>
    return LV_MAX(self_h, child_res + space_bottom);
 8006d7e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8006d80:	69bb      	ldr	r3, [r7, #24]
 8006d82:	441a      	add	r2, r3
 8006d84:	697b      	ldr	r3, [r7, #20]
 8006d86:	4293      	cmp	r3, r2
 8006d88:	bfb8      	it	lt
 8006d8a:	4613      	movlt	r3, r2
}
 8006d8c:	4618      	mov	r0, r3
 8006d8e:	3730      	adds	r7, #48	@ 0x30
 8006d90:	46bd      	mov	sp, r7
 8006d92:	bd80      	pop	{r7, pc}
 8006d94:	e0000001 	.word	0xe0000001
 8006d98:	00040001 	.word	0x00040001

08006d9c <layout_update_core>:

static void layout_update_core(lv_obj_t * obj)
{
 8006d9c:	b580      	push	{r7, lr}
 8006d9e:	b086      	sub	sp, #24
 8006da0:	af00      	add	r7, sp, #0
 8006da2:	6078      	str	r0, [r7, #4]
    uint32_t i;
    uint32_t child_cnt = lv_obj_get_child_count(obj);
 8006da4:	6878      	ldr	r0, [r7, #4]
 8006da6:	f004 f88b 	bl	800aec0 <lv_obj_get_child_count>
 8006daa:	6138      	str	r0, [r7, #16]
    for(i = 0; i < child_cnt; i++) {
 8006dac:	2300      	movs	r3, #0
 8006dae:	617b      	str	r3, [r7, #20]
 8006db0:	e00d      	b.n	8006dce <layout_update_core+0x32>
        lv_obj_t * child = obj->spec_attr->children[i];
 8006db2:	687b      	ldr	r3, [r7, #4]
 8006db4:	689b      	ldr	r3, [r3, #8]
 8006db6:	681a      	ldr	r2, [r3, #0]
 8006db8:	697b      	ldr	r3, [r7, #20]
 8006dba:	009b      	lsls	r3, r3, #2
 8006dbc:	4413      	add	r3, r2
 8006dbe:	681b      	ldr	r3, [r3, #0]
 8006dc0:	60fb      	str	r3, [r7, #12]
        layout_update_core(child);
 8006dc2:	68f8      	ldr	r0, [r7, #12]
 8006dc4:	f7ff ffea 	bl	8006d9c <layout_update_core>
    for(i = 0; i < child_cnt; i++) {
 8006dc8:	697b      	ldr	r3, [r7, #20]
 8006dca:	3301      	adds	r3, #1
 8006dcc:	617b      	str	r3, [r7, #20]
 8006dce:	697a      	ldr	r2, [r7, #20]
 8006dd0:	693b      	ldr	r3, [r7, #16]
 8006dd2:	429a      	cmp	r2, r3
 8006dd4:	d3ed      	bcc.n	8006db2 <layout_update_core+0x16>
    }

    if(obj->layout_inv) {
 8006dd6:	687b      	ldr	r3, [r7, #4]
 8006dd8:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
 8006ddc:	f003 0301 	and.w	r3, r3, #1
 8006de0:	b2db      	uxtb	r3, r3
 8006de2:	2b00      	cmp	r3, #0
 8006de4:	d012      	beq.n	8006e0c <layout_update_core+0x70>
        obj->layout_inv = 0;
 8006de6:	687a      	ldr	r2, [r7, #4]
 8006de8:	f892 302a 	ldrb.w	r3, [r2, #42]	@ 0x2a
 8006dec:	f36f 0300 	bfc	r3, #0, #1
 8006df0:	f882 302a 	strb.w	r3, [r2, #42]	@ 0x2a
        lv_obj_refr_size(obj);
 8006df4:	6878      	ldr	r0, [r7, #4]
 8006df6:	f7fe fd0f 	bl	8005818 <lv_obj_refr_size>
        lv_obj_refr_pos(obj);
 8006dfa:	6878      	ldr	r0, [r7, #4]
 8006dfc:	f7ff f86c 	bl	8005ed8 <lv_obj_refr_pos>

        if(child_cnt > 0) {
 8006e00:	693b      	ldr	r3, [r7, #16]
 8006e02:	2b00      	cmp	r3, #0
 8006e04:	d002      	beq.n	8006e0c <layout_update_core+0x70>
            _lv_layout_apply(obj);
 8006e06:	6878      	ldr	r0, [r7, #4]
 8006e08:	f018 fe74 	bl	801faf4 <_lv_layout_apply>
        }
    }

    if(obj->readjust_scroll_after_layout) {
 8006e0c:	687b      	ldr	r3, [r7, #4]
 8006e0e:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
 8006e12:	f003 0302 	and.w	r3, r3, #2
 8006e16:	b2db      	uxtb	r3, r3
 8006e18:	2b00      	cmp	r3, #0
 8006e1a:	d00a      	beq.n	8006e32 <layout_update_core+0x96>
        obj->readjust_scroll_after_layout = 0;
 8006e1c:	687a      	ldr	r2, [r7, #4]
 8006e1e:	f892 302a 	ldrb.w	r3, [r2, #42]	@ 0x2a
 8006e22:	f36f 0341 	bfc	r3, #1, #1
 8006e26:	f882 302a 	strb.w	r3, [r2, #42]	@ 0x2a
        lv_obj_readjust_scroll(obj, LV_ANIM_OFF);
 8006e2a:	2100      	movs	r1, #0
 8006e2c:	6878      	ldr	r0, [r7, #4]
 8006e2e:	f001 fbca 	bl	80085c6 <lv_obj_readjust_scroll>
    }
}
 8006e32:	bf00      	nop
 8006e34:	3718      	adds	r7, #24
 8006e36:	46bd      	mov	sp, r7
 8006e38:	bd80      	pop	{r7, pc}
	...

08006e3c <transform_point>:

static void transform_point(const lv_obj_t * obj, lv_point_t * p, bool inv)
{
 8006e3c:	b590      	push	{r4, r7, lr}
 8006e3e:	b08d      	sub	sp, #52	@ 0x34
 8006e40:	af02      	add	r7, sp, #8
 8006e42:	60f8      	str	r0, [r7, #12]
 8006e44:	60b9      	str	r1, [r7, #8]
 8006e46:	4613      	mov	r3, r2
 8006e48:	71fb      	strb	r3, [r7, #7]
    int32_t angle = lv_obj_get_style_transform_rotation(obj, 0);
 8006e4a:	2100      	movs	r1, #0
 8006e4c:	68f8      	ldr	r0, [r7, #12]
 8006e4e:	f7fe fad2 	bl	80053f6 <lv_obj_get_style_transform_rotation>
 8006e52:	6278      	str	r0, [r7, #36]	@ 0x24
    int32_t scale_x = lv_obj_get_style_transform_scale_x_safe(obj, 0);
 8006e54:	2100      	movs	r1, #0
 8006e56:	68f8      	ldr	r0, [r7, #12]
 8006e58:	f7fe fc5b 	bl	8005712 <lv_obj_get_style_transform_scale_x_safe>
 8006e5c:	6238      	str	r0, [r7, #32]
    int32_t scale_y = lv_obj_get_style_transform_scale_y_safe(obj, 0);
 8006e5e:	2100      	movs	r1, #0
 8006e60:	68f8      	ldr	r0, [r7, #12]
 8006e62:	f7fe fc6d 	bl	8005740 <lv_obj_get_style_transform_scale_y_safe>
 8006e66:	61f8      	str	r0, [r7, #28]

    if(angle == 0 && scale_x == LV_SCALE_NONE && scale_y == LV_SCALE_NONE) return;
 8006e68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006e6a:	2b00      	cmp	r3, #0
 8006e6c:	d108      	bne.n	8006e80 <transform_point+0x44>
 8006e6e:	6a3b      	ldr	r3, [r7, #32]
 8006e70:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8006e74:	d104      	bne.n	8006e80 <transform_point+0x44>
 8006e76:	69fb      	ldr	r3, [r7, #28]
 8006e78:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8006e7c:	f000 8093 	beq.w	8006fa6 <transform_point+0x16a>

    lv_point_t pivot = {
        .x = lv_obj_get_style_transform_pivot_x(obj, 0),
 8006e80:	2100      	movs	r1, #0
 8006e82:	68f8      	ldr	r0, [r7, #12]
 8006e84:	f7fe fac8 	bl	8005418 <lv_obj_get_style_transform_pivot_x>
 8006e88:	4603      	mov	r3, r0
    lv_point_t pivot = {
 8006e8a:	617b      	str	r3, [r7, #20]
        .y = lv_obj_get_style_transform_pivot_y(obj, 0)
 8006e8c:	2100      	movs	r1, #0
 8006e8e:	68f8      	ldr	r0, [r7, #12]
 8006e90:	f7fe fad3 	bl	800543a <lv_obj_get_style_transform_pivot_y>
 8006e94:	4603      	mov	r3, r0
    lv_point_t pivot = {
 8006e96:	61bb      	str	r3, [r7, #24]
    };

    if(LV_COORD_IS_PCT(pivot.x)) {
 8006e98:	697b      	ldr	r3, [r7, #20]
 8006e9a:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 8006e9e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8006ea2:	d123      	bne.n	8006eec <transform_point+0xb0>
 8006ea4:	697b      	ldr	r3, [r7, #20]
 8006ea6:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006eaa:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 8006eae:	dc1d      	bgt.n	8006eec <transform_point+0xb0>
        pivot.x = (LV_COORD_GET_PCT(pivot.x) * lv_area_get_width(&obj->coords)) / 100;
 8006eb0:	697b      	ldr	r3, [r7, #20]
 8006eb2:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006eb6:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8006eba:	dd05      	ble.n	8006ec8 <transform_point+0x8c>
 8006ebc:	697b      	ldr	r3, [r7, #20]
 8006ebe:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006ec2:	f5c3 747a 	rsb	r4, r3, #1000	@ 0x3e8
 8006ec6:	e002      	b.n	8006ece <transform_point+0x92>
 8006ec8:	697b      	ldr	r3, [r7, #20]
 8006eca:	f023 44c0 	bic.w	r4, r3, #1610612736	@ 0x60000000
 8006ece:	68fb      	ldr	r3, [r7, #12]
 8006ed0:	3314      	adds	r3, #20
 8006ed2:	4618      	mov	r0, r3
 8006ed4:	f7fe f991 	bl	80051fa <lv_area_get_width>
 8006ed8:	4603      	mov	r3, r0
 8006eda:	fb04 f303 	mul.w	r3, r4, r3
 8006ede:	4a34      	ldr	r2, [pc, #208]	@ (8006fb0 <transform_point+0x174>)
 8006ee0:	fb82 1203 	smull	r1, r2, r2, r3
 8006ee4:	1152      	asrs	r2, r2, #5
 8006ee6:	17db      	asrs	r3, r3, #31
 8006ee8:	1ad3      	subs	r3, r2, r3
 8006eea:	617b      	str	r3, [r7, #20]
    }
    if(LV_COORD_IS_PCT(pivot.y)) {
 8006eec:	69bb      	ldr	r3, [r7, #24]
 8006eee:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 8006ef2:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8006ef6:	d123      	bne.n	8006f40 <transform_point+0x104>
 8006ef8:	69bb      	ldr	r3, [r7, #24]
 8006efa:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006efe:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 8006f02:	dc1d      	bgt.n	8006f40 <transform_point+0x104>
        pivot.y = (LV_COORD_GET_PCT(pivot.y) * lv_area_get_height(&obj->coords)) / 100;
 8006f04:	69bb      	ldr	r3, [r7, #24]
 8006f06:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006f0a:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8006f0e:	dd05      	ble.n	8006f1c <transform_point+0xe0>
 8006f10:	69bb      	ldr	r3, [r7, #24]
 8006f12:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8006f16:	f5c3 747a 	rsb	r4, r3, #1000	@ 0x3e8
 8006f1a:	e002      	b.n	8006f22 <transform_point+0xe6>
 8006f1c:	69bb      	ldr	r3, [r7, #24]
 8006f1e:	f023 44c0 	bic.w	r4, r3, #1610612736	@ 0x60000000
 8006f22:	68fb      	ldr	r3, [r7, #12]
 8006f24:	3314      	adds	r3, #20
 8006f26:	4618      	mov	r0, r3
 8006f28:	f7fe f977 	bl	800521a <lv_area_get_height>
 8006f2c:	4603      	mov	r3, r0
 8006f2e:	fb04 f303 	mul.w	r3, r4, r3
 8006f32:	4a1f      	ldr	r2, [pc, #124]	@ (8006fb0 <transform_point+0x174>)
 8006f34:	fb82 1203 	smull	r1, r2, r2, r3
 8006f38:	1152      	asrs	r2, r2, #5
 8006f3a:	17db      	asrs	r3, r3, #31
 8006f3c:	1ad3      	subs	r3, r2, r3
 8006f3e:	61bb      	str	r3, [r7, #24]
    }

    pivot.x = obj->coords.x1 + pivot.x;
 8006f40:	68fb      	ldr	r3, [r7, #12]
 8006f42:	695a      	ldr	r2, [r3, #20]
 8006f44:	697b      	ldr	r3, [r7, #20]
 8006f46:	4413      	add	r3, r2
 8006f48:	617b      	str	r3, [r7, #20]
    pivot.y = obj->coords.y1 + pivot.y;
 8006f4a:	68fb      	ldr	r3, [r7, #12]
 8006f4c:	699a      	ldr	r2, [r3, #24]
 8006f4e:	69bb      	ldr	r3, [r7, #24]
 8006f50:	4413      	add	r3, r2
 8006f52:	61bb      	str	r3, [r7, #24]

    if(inv) {
 8006f54:	79fb      	ldrb	r3, [r7, #7]
 8006f56:	2b00      	cmp	r3, #0
 8006f58:	d00e      	beq.n	8006f78 <transform_point+0x13c>
        angle = -angle;
 8006f5a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8006f5c:	425b      	negs	r3, r3
 8006f5e:	627b      	str	r3, [r7, #36]	@ 0x24
        scale_x = (256 * 256) / scale_x;
 8006f60:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 8006f64:	6a3b      	ldr	r3, [r7, #32]
 8006f66:	fb92 f3f3 	sdiv	r3, r2, r3
 8006f6a:	623b      	str	r3, [r7, #32]
        scale_y = (256 * 256) / scale_y;
 8006f6c:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 8006f70:	69fb      	ldr	r3, [r7, #28]
 8006f72:	fb92 f3f3 	sdiv	r3, r2, r3
 8006f76:	61fb      	str	r3, [r7, #28]
    }

    lv_point_transform(p, angle, scale_x, scale_y, &pivot, !inv);
 8006f78:	79fb      	ldrb	r3, [r7, #7]
 8006f7a:	2b00      	cmp	r3, #0
 8006f7c:	bf14      	ite	ne
 8006f7e:	2301      	movne	r3, #1
 8006f80:	2300      	moveq	r3, #0
 8006f82:	b2db      	uxtb	r3, r3
 8006f84:	f083 0301 	eor.w	r3, r3, #1
 8006f88:	b2db      	uxtb	r3, r3
 8006f8a:	f003 0301 	and.w	r3, r3, #1
 8006f8e:	b2db      	uxtb	r3, r3
 8006f90:	9301      	str	r3, [sp, #4]
 8006f92:	f107 0314 	add.w	r3, r7, #20
 8006f96:	9300      	str	r3, [sp, #0]
 8006f98:	69fb      	ldr	r3, [r7, #28]
 8006f9a:	6a3a      	ldr	r2, [r7, #32]
 8006f9c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8006f9e:	68b8      	ldr	r0, [r7, #8]
 8006fa0:	f01b f8f2 	bl	8022188 <lv_point_transform>
 8006fa4:	e000      	b.n	8006fa8 <transform_point+0x16c>
    if(angle == 0 && scale_x == LV_SCALE_NONE && scale_y == LV_SCALE_NONE) return;
 8006fa6:	bf00      	nop
}
 8006fa8:	372c      	adds	r7, #44	@ 0x2c
 8006faa:	46bd      	mov	sp, r7
 8006fac:	bd90      	pop	{r4, r7, pc}
 8006fae:	bf00      	nop
 8006fb0:	51eb851f 	.word	0x51eb851f

08006fb4 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline int32_t lv_area_get_width(const lv_area_t * area_p)
{
 8006fb4:	b480      	push	{r7}
 8006fb6:	b083      	sub	sp, #12
 8006fb8:	af00      	add	r7, sp, #0
 8006fba:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 8006fbc:	687b      	ldr	r3, [r7, #4]
 8006fbe:	689a      	ldr	r2, [r3, #8]
 8006fc0:	687b      	ldr	r3, [r7, #4]
 8006fc2:	681b      	ldr	r3, [r3, #0]
 8006fc4:	1ad3      	subs	r3, r2, r3
 8006fc6:	3301      	adds	r3, #1
}
 8006fc8:	4618      	mov	r0, r3
 8006fca:	370c      	adds	r7, #12
 8006fcc:	46bd      	mov	sp, r7
 8006fce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006fd2:	4770      	bx	lr

08006fd4 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline int32_t lv_area_get_height(const lv_area_t * area_p)
{
 8006fd4:	b480      	push	{r7}
 8006fd6:	b083      	sub	sp, #12
 8006fd8:	af00      	add	r7, sp, #0
 8006fda:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 8006fdc:	687b      	ldr	r3, [r7, #4]
 8006fde:	68da      	ldr	r2, [r3, #12]
 8006fe0:	687b      	ldr	r3, [r7, #4]
 8006fe2:	685b      	ldr	r3, [r3, #4]
 8006fe4:	1ad3      	subs	r3, r2, r3
 8006fe6:	3301      	adds	r3, #1
}
 8006fe8:	4618      	mov	r0, r3
 8006fea:	370c      	adds	r7, #12
 8006fec:	46bd      	mov	sp, r7
 8006fee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ff2:	4770      	bx	lr

08006ff4 <lv_anim_set_var>:
 * Set a variable to animate
 * @param a     pointer to an initialized `lv_anim_t` variable
 * @param var   pointer to a variable to animate
 */
static inline void lv_anim_set_var(lv_anim_t * a, void * var)
{
 8006ff4:	b480      	push	{r7}
 8006ff6:	b083      	sub	sp, #12
 8006ff8:	af00      	add	r7, sp, #0
 8006ffa:	6078      	str	r0, [r7, #4]
 8006ffc:	6039      	str	r1, [r7, #0]
    a->var = var;
 8006ffe:	687b      	ldr	r3, [r7, #4]
 8007000:	683a      	ldr	r2, [r7, #0]
 8007002:	601a      	str	r2, [r3, #0]
}
 8007004:	bf00      	nop
 8007006:	370c      	adds	r7, #12
 8007008:	46bd      	mov	sp, r7
 800700a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800700e:	4770      	bx	lr

08007010 <lv_anim_set_exec_cb>:
 * @param exec_cb   a function to execute during animation
 *                  LVGL's built-in functions can be used.
 *                  E.g. lv_obj_set_x
 */
static inline void lv_anim_set_exec_cb(lv_anim_t * a, lv_anim_exec_xcb_t exec_cb)
{
 8007010:	b480      	push	{r7}
 8007012:	b083      	sub	sp, #12
 8007014:	af00      	add	r7, sp, #0
 8007016:	6078      	str	r0, [r7, #4]
 8007018:	6039      	str	r1, [r7, #0]
    a->exec_cb = exec_cb;
 800701a:	687b      	ldr	r3, [r7, #4]
 800701c:	683a      	ldr	r2, [r7, #0]
 800701e:	605a      	str	r2, [r3, #4]
}
 8007020:	bf00      	nop
 8007022:	370c      	adds	r7, #12
 8007024:	46bd      	mov	sp, r7
 8007026:	f85d 7b04 	ldr.w	r7, [sp], #4
 800702a:	4770      	bx	lr

0800702c <lv_anim_set_duration>:
 * Set the duration of an animation
 * @param a         pointer to an initialized `lv_anim_t` variable
 * @param duration  duration of the animation in milliseconds
 */
static inline void lv_anim_set_duration(lv_anim_t * a, uint32_t duration)
{
 800702c:	b480      	push	{r7}
 800702e:	b083      	sub	sp, #12
 8007030:	af00      	add	r7, sp, #0
 8007032:	6078      	str	r0, [r7, #4]
 8007034:	6039      	str	r1, [r7, #0]
    a->duration = duration;
 8007036:	683a      	ldr	r2, [r7, #0]
 8007038:	687b      	ldr	r3, [r7, #4]
 800703a:	631a      	str	r2, [r3, #48]	@ 0x30
}
 800703c:	bf00      	nop
 800703e:	370c      	adds	r7, #12
 8007040:	46bd      	mov	sp, r7
 8007042:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007046:	4770      	bx	lr

08007048 <lv_anim_set_values>:
 * @param a         pointer to an initialized `lv_anim_t` variable
 * @param start     the start value
 * @param end       the end value
 */
static inline void lv_anim_set_values(lv_anim_t * a, int32_t start, int32_t end)
{
 8007048:	b480      	push	{r7}
 800704a:	b085      	sub	sp, #20
 800704c:	af00      	add	r7, sp, #0
 800704e:	60f8      	str	r0, [r7, #12]
 8007050:	60b9      	str	r1, [r7, #8]
 8007052:	607a      	str	r2, [r7, #4]
    a->start_value = start;
 8007054:	68fb      	ldr	r3, [r7, #12]
 8007056:	68ba      	ldr	r2, [r7, #8]
 8007058:	625a      	str	r2, [r3, #36]	@ 0x24
    a->current_value = INT32_MIN;
 800705a:	68fb      	ldr	r3, [r7, #12]
 800705c:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
 8007060:	629a      	str	r2, [r3, #40]	@ 0x28
    a->end_value = end;
 8007062:	68fb      	ldr	r3, [r7, #12]
 8007064:	687a      	ldr	r2, [r7, #4]
 8007066:	62da      	str	r2, [r3, #44]	@ 0x2c
}
 8007068:	bf00      	nop
 800706a:	3714      	adds	r7, #20
 800706c:	46bd      	mov	sp, r7
 800706e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007072:	4770      	bx	lr

08007074 <lv_anim_set_path_cb>:
 * Set the path (curve) of the animation.
 * @param a         pointer to an initialized `lv_anim_t` variable
 * @param path_cb a function to set the current value of the animation.
 */
static inline void lv_anim_set_path_cb(lv_anim_t * a, lv_anim_path_cb_t path_cb)
{
 8007074:	b480      	push	{r7}
 8007076:	b083      	sub	sp, #12
 8007078:	af00      	add	r7, sp, #0
 800707a:	6078      	str	r0, [r7, #4]
 800707c:	6039      	str	r1, [r7, #0]
    a->path_cb = path_cb;
 800707e:	687b      	ldr	r3, [r7, #4]
 8007080:	683a      	ldr	r2, [r7, #0]
 8007082:	621a      	str	r2, [r3, #32]
}
 8007084:	bf00      	nop
 8007086:	370c      	adds	r7, #12
 8007088:	46bd      	mov	sp, r7
 800708a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800708e:	4770      	bx	lr

08007090 <lv_anim_set_completed_cb>:
 * Set a function call when the animation is completed
 * @param a             pointer to an initialized `lv_anim_t` variable
 * @param completed_cb  a function call when the animation is fully completed
 */
static inline void lv_anim_set_completed_cb(lv_anim_t * a, lv_anim_completed_cb_t completed_cb)
{
 8007090:	b480      	push	{r7}
 8007092:	b083      	sub	sp, #12
 8007094:	af00      	add	r7, sp, #0
 8007096:	6078      	str	r0, [r7, #4]
 8007098:	6039      	str	r1, [r7, #0]
    a->completed_cb = completed_cb;
 800709a:	687b      	ldr	r3, [r7, #4]
 800709c:	683a      	ldr	r2, [r7, #0]
 800709e:	611a      	str	r2, [r3, #16]
}
 80070a0:	bf00      	nop
 80070a2:	370c      	adds	r7, #12
 80070a4:	46bd      	mov	sp, r7
 80070a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80070aa:	4770      	bx	lr

080070ac <lv_obj_get_style_width>:
{
 80070ac:	b580      	push	{r7, lr}
 80070ae:	b084      	sub	sp, #16
 80070b0:	af00      	add	r7, sp, #0
 80070b2:	6078      	str	r0, [r7, #4]
 80070b4:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_WIDTH);
 80070b6:	2201      	movs	r2, #1
 80070b8:	6839      	ldr	r1, [r7, #0]
 80070ba:	6878      	ldr	r0, [r7, #4]
 80070bc:	f002 fb34 	bl	8009728 <lv_obj_get_style_prop>
 80070c0:	4603      	mov	r3, r0
 80070c2:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80070c4:	68fb      	ldr	r3, [r7, #12]
}
 80070c6:	4618      	mov	r0, r3
 80070c8:	3710      	adds	r7, #16
 80070ca:	46bd      	mov	sp, r7
 80070cc:	bd80      	pop	{r7, pc}

080070ce <lv_obj_get_style_pad_top>:
{
 80070ce:	b580      	push	{r7, lr}
 80070d0:	b084      	sub	sp, #16
 80070d2:	af00      	add	r7, sp, #0
 80070d4:	6078      	str	r0, [r7, #4]
 80070d6:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_TOP);
 80070d8:	2210      	movs	r2, #16
 80070da:	6839      	ldr	r1, [r7, #0]
 80070dc:	6878      	ldr	r0, [r7, #4]
 80070de:	f002 fb23 	bl	8009728 <lv_obj_get_style_prop>
 80070e2:	4603      	mov	r3, r0
 80070e4:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80070e6:	68fb      	ldr	r3, [r7, #12]
}
 80070e8:	4618      	mov	r0, r3
 80070ea:	3710      	adds	r7, #16
 80070ec:	46bd      	mov	sp, r7
 80070ee:	bd80      	pop	{r7, pc}

080070f0 <lv_obj_get_style_pad_bottom>:
{
 80070f0:	b580      	push	{r7, lr}
 80070f2:	b084      	sub	sp, #16
 80070f4:	af00      	add	r7, sp, #0
 80070f6:	6078      	str	r0, [r7, #4]
 80070f8:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_BOTTOM);
 80070fa:	2211      	movs	r2, #17
 80070fc:	6839      	ldr	r1, [r7, #0]
 80070fe:	6878      	ldr	r0, [r7, #4]
 8007100:	f002 fb12 	bl	8009728 <lv_obj_get_style_prop>
 8007104:	4603      	mov	r3, r0
 8007106:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8007108:	68fb      	ldr	r3, [r7, #12]
}
 800710a:	4618      	mov	r0, r3
 800710c:	3710      	adds	r7, #16
 800710e:	46bd      	mov	sp, r7
 8007110:	bd80      	pop	{r7, pc}

08007112 <lv_obj_get_style_pad_left>:
{
 8007112:	b580      	push	{r7, lr}
 8007114:	b084      	sub	sp, #16
 8007116:	af00      	add	r7, sp, #0
 8007118:	6078      	str	r0, [r7, #4]
 800711a:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_LEFT);
 800711c:	2212      	movs	r2, #18
 800711e:	6839      	ldr	r1, [r7, #0]
 8007120:	6878      	ldr	r0, [r7, #4]
 8007122:	f002 fb01 	bl	8009728 <lv_obj_get_style_prop>
 8007126:	4603      	mov	r3, r0
 8007128:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 800712a:	68fb      	ldr	r3, [r7, #12]
}
 800712c:	4618      	mov	r0, r3
 800712e:	3710      	adds	r7, #16
 8007130:	46bd      	mov	sp, r7
 8007132:	bd80      	pop	{r7, pc}

08007134 <lv_obj_get_style_pad_right>:
{
 8007134:	b580      	push	{r7, lr}
 8007136:	b084      	sub	sp, #16
 8007138:	af00      	add	r7, sp, #0
 800713a:	6078      	str	r0, [r7, #4]
 800713c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_RIGHT);
 800713e:	2213      	movs	r2, #19
 8007140:	6839      	ldr	r1, [r7, #0]
 8007142:	6878      	ldr	r0, [r7, #4]
 8007144:	f002 faf0 	bl	8009728 <lv_obj_get_style_prop>
 8007148:	4603      	mov	r3, r0
 800714a:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 800714c:	68fb      	ldr	r3, [r7, #12]
}
 800714e:	4618      	mov	r0, r3
 8007150:	3710      	adds	r7, #16
 8007152:	46bd      	mov	sp, r7
 8007154:	bd80      	pop	{r7, pc}

08007156 <lv_obj_get_style_margin_bottom>:
{
 8007156:	b580      	push	{r7, lr}
 8007158:	b084      	sub	sp, #16
 800715a:	af00      	add	r7, sp, #0
 800715c:	6078      	str	r0, [r7, #4]
 800715e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_BOTTOM);
 8007160:	2219      	movs	r2, #25
 8007162:	6839      	ldr	r1, [r7, #0]
 8007164:	6878      	ldr	r0, [r7, #4]
 8007166:	f002 fadf 	bl	8009728 <lv_obj_get_style_prop>
 800716a:	4603      	mov	r3, r0
 800716c:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 800716e:	68fb      	ldr	r3, [r7, #12]
}
 8007170:	4618      	mov	r0, r3
 8007172:	3710      	adds	r7, #16
 8007174:	46bd      	mov	sp, r7
 8007176:	bd80      	pop	{r7, pc}

08007178 <lv_obj_get_style_margin_left>:
{
 8007178:	b580      	push	{r7, lr}
 800717a:	b084      	sub	sp, #16
 800717c:	af00      	add	r7, sp, #0
 800717e:	6078      	str	r0, [r7, #4]
 8007180:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_LEFT);
 8007182:	221a      	movs	r2, #26
 8007184:	6839      	ldr	r1, [r7, #0]
 8007186:	6878      	ldr	r0, [r7, #4]
 8007188:	f002 face 	bl	8009728 <lv_obj_get_style_prop>
 800718c:	4603      	mov	r3, r0
 800718e:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8007190:	68fb      	ldr	r3, [r7, #12]
}
 8007192:	4618      	mov	r0, r3
 8007194:	3710      	adds	r7, #16
 8007196:	46bd      	mov	sp, r7
 8007198:	bd80      	pop	{r7, pc}

0800719a <lv_obj_get_style_margin_right>:
{
 800719a:	b580      	push	{r7, lr}
 800719c:	b084      	sub	sp, #16
 800719e:	af00      	add	r7, sp, #0
 80071a0:	6078      	str	r0, [r7, #4]
 80071a2:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_RIGHT);
 80071a4:	221b      	movs	r2, #27
 80071a6:	6839      	ldr	r1, [r7, #0]
 80071a8:	6878      	ldr	r0, [r7, #4]
 80071aa:	f002 fabd 	bl	8009728 <lv_obj_get_style_prop>
 80071ae:	4603      	mov	r3, r0
 80071b0:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80071b2:	68fb      	ldr	r3, [r7, #12]
}
 80071b4:	4618      	mov	r0, r3
 80071b6:	3710      	adds	r7, #16
 80071b8:	46bd      	mov	sp, r7
 80071ba:	bd80      	pop	{r7, pc}

080071bc <lv_obj_get_style_bg_opa>:
{
 80071bc:	b580      	push	{r7, lr}
 80071be:	b084      	sub	sp, #16
 80071c0:	af00      	add	r7, sp, #0
 80071c2:	6078      	str	r0, [r7, #4]
 80071c4:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_OPA);
 80071c6:	221d      	movs	r2, #29
 80071c8:	6839      	ldr	r1, [r7, #0]
 80071ca:	6878      	ldr	r0, [r7, #4]
 80071cc:	f002 faac 	bl	8009728 <lv_obj_get_style_prop>
 80071d0:	4603      	mov	r3, r0
 80071d2:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 80071d4:	68fb      	ldr	r3, [r7, #12]
 80071d6:	b2db      	uxtb	r3, r3
}
 80071d8:	4618      	mov	r0, r3
 80071da:	3710      	adds	r7, #16
 80071dc:	46bd      	mov	sp, r7
 80071de:	bd80      	pop	{r7, pc}

080071e0 <lv_obj_get_style_border_opa>:
{
 80071e0:	b580      	push	{r7, lr}
 80071e2:	b084      	sub	sp, #16
 80071e4:	af00      	add	r7, sp, #0
 80071e6:	6078      	str	r0, [r7, #4]
 80071e8:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_OPA);
 80071ea:	2232      	movs	r2, #50	@ 0x32
 80071ec:	6839      	ldr	r1, [r7, #0]
 80071ee:	6878      	ldr	r0, [r7, #4]
 80071f0:	f002 fa9a 	bl	8009728 <lv_obj_get_style_prop>
 80071f4:	4603      	mov	r3, r0
 80071f6:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 80071f8:	68fb      	ldr	r3, [r7, #12]
 80071fa:	b2db      	uxtb	r3, r3
}
 80071fc:	4618      	mov	r0, r3
 80071fe:	3710      	adds	r7, #16
 8007200:	46bd      	mov	sp, r7
 8007202:	bd80      	pop	{r7, pc}

08007204 <lv_obj_get_style_border_width>:
{
 8007204:	b580      	push	{r7, lr}
 8007206:	b084      	sub	sp, #16
 8007208:	af00      	add	r7, sp, #0
 800720a:	6078      	str	r0, [r7, #4]
 800720c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_WIDTH);
 800720e:	2230      	movs	r2, #48	@ 0x30
 8007210:	6839      	ldr	r1, [r7, #0]
 8007212:	6878      	ldr	r0, [r7, #4]
 8007214:	f002 fa88 	bl	8009728 <lv_obj_get_style_prop>
 8007218:	4603      	mov	r3, r0
 800721a:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 800721c:	68fb      	ldr	r3, [r7, #12]
}
 800721e:	4618      	mov	r0, r3
 8007220:	3710      	adds	r7, #16
 8007222:	46bd      	mov	sp, r7
 8007224:	bd80      	pop	{r7, pc}

08007226 <lv_obj_get_style_border_side>:
{
 8007226:	b580      	push	{r7, lr}
 8007228:	b084      	sub	sp, #16
 800722a:	af00      	add	r7, sp, #0
 800722c:	6078      	str	r0, [r7, #4]
 800722e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_SIDE);
 8007230:	2234      	movs	r2, #52	@ 0x34
 8007232:	6839      	ldr	r1, [r7, #0]
 8007234:	6878      	ldr	r0, [r7, #4]
 8007236:	f002 fa77 	bl	8009728 <lv_obj_get_style_prop>
 800723a:	4603      	mov	r3, r0
 800723c:	60fb      	str	r3, [r7, #12]
    return (lv_border_side_t)v.num;
 800723e:	68fb      	ldr	r3, [r7, #12]
 8007240:	b2db      	uxtb	r3, r3
}
 8007242:	4618      	mov	r0, r3
 8007244:	3710      	adds	r7, #16
 8007246:	46bd      	mov	sp, r7
 8007248:	bd80      	pop	{r7, pc}

0800724a <lv_obj_get_style_base_dir>:
{
 800724a:	b580      	push	{r7, lr}
 800724c:	b084      	sub	sp, #16
 800724e:	af00      	add	r7, sp, #0
 8007250:	6078      	str	r0, [r7, #4]
 8007252:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BASE_DIR);
 8007254:	2227      	movs	r2, #39	@ 0x27
 8007256:	6839      	ldr	r1, [r7, #0]
 8007258:	6878      	ldr	r0, [r7, #4]
 800725a:	f002 fa65 	bl	8009728 <lv_obj_get_style_prop>
 800725e:	4603      	mov	r3, r0
 8007260:	60fb      	str	r3, [r7, #12]
    return (lv_base_dir_t)v.num;
 8007262:	68fb      	ldr	r3, [r7, #12]
 8007264:	b2db      	uxtb	r3, r3
}
 8007266:	4618      	mov	r0, r3
 8007268:	3710      	adds	r7, #16
 800726a:	46bd      	mov	sp, r7
 800726c:	bd80      	pop	{r7, pc}

0800726e <lv_obj_get_style_space_left>:
{
 800726e:	b580      	push	{r7, lr}
 8007270:	b086      	sub	sp, #24
 8007272:	af00      	add	r7, sp, #0
 8007274:	6078      	str	r0, [r7, #4]
 8007276:	6039      	str	r1, [r7, #0]
    int32_t padding = lv_obj_get_style_pad_left(obj, part);
 8007278:	6839      	ldr	r1, [r7, #0]
 800727a:	6878      	ldr	r0, [r7, #4]
 800727c:	f7ff ff49 	bl	8007112 <lv_obj_get_style_pad_left>
 8007280:	6178      	str	r0, [r7, #20]
    int32_t border_width = lv_obj_get_style_border_width(obj, part);
 8007282:	6839      	ldr	r1, [r7, #0]
 8007284:	6878      	ldr	r0, [r7, #4]
 8007286:	f7ff ffbd 	bl	8007204 <lv_obj_get_style_border_width>
 800728a:	6138      	str	r0, [r7, #16]
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
 800728c:	6839      	ldr	r1, [r7, #0]
 800728e:	6878      	ldr	r0, [r7, #4]
 8007290:	f7ff ffc9 	bl	8007226 <lv_obj_get_style_border_side>
 8007294:	4603      	mov	r3, r0
 8007296:	73fb      	strb	r3, [r7, #15]
    return (border_side & LV_BORDER_SIDE_LEFT) ? padding + border_width : padding;
 8007298:	7bfb      	ldrb	r3, [r7, #15]
 800729a:	f003 0304 	and.w	r3, r3, #4
 800729e:	2b00      	cmp	r3, #0
 80072a0:	d003      	beq.n	80072aa <lv_obj_get_style_space_left+0x3c>
 80072a2:	697a      	ldr	r2, [r7, #20]
 80072a4:	693b      	ldr	r3, [r7, #16]
 80072a6:	4413      	add	r3, r2
 80072a8:	e000      	b.n	80072ac <lv_obj_get_style_space_left+0x3e>
 80072aa:	697b      	ldr	r3, [r7, #20]
}
 80072ac:	4618      	mov	r0, r3
 80072ae:	3718      	adds	r7, #24
 80072b0:	46bd      	mov	sp, r7
 80072b2:	bd80      	pop	{r7, pc}

080072b4 <lv_obj_get_style_space_right>:
{
 80072b4:	b580      	push	{r7, lr}
 80072b6:	b086      	sub	sp, #24
 80072b8:	af00      	add	r7, sp, #0
 80072ba:	6078      	str	r0, [r7, #4]
 80072bc:	6039      	str	r1, [r7, #0]
    int32_t padding = lv_obj_get_style_pad_right(obj, part);
 80072be:	6839      	ldr	r1, [r7, #0]
 80072c0:	6878      	ldr	r0, [r7, #4]
 80072c2:	f7ff ff37 	bl	8007134 <lv_obj_get_style_pad_right>
 80072c6:	6178      	str	r0, [r7, #20]
    int32_t border_width = lv_obj_get_style_border_width(obj, part);
 80072c8:	6839      	ldr	r1, [r7, #0]
 80072ca:	6878      	ldr	r0, [r7, #4]
 80072cc:	f7ff ff9a 	bl	8007204 <lv_obj_get_style_border_width>
 80072d0:	6138      	str	r0, [r7, #16]
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
 80072d2:	6839      	ldr	r1, [r7, #0]
 80072d4:	6878      	ldr	r0, [r7, #4]
 80072d6:	f7ff ffa6 	bl	8007226 <lv_obj_get_style_border_side>
 80072da:	4603      	mov	r3, r0
 80072dc:	73fb      	strb	r3, [r7, #15]
    return (border_side & LV_BORDER_SIDE_RIGHT) ? padding + border_width : padding;
 80072de:	7bfb      	ldrb	r3, [r7, #15]
 80072e0:	f003 0308 	and.w	r3, r3, #8
 80072e4:	2b00      	cmp	r3, #0
 80072e6:	d003      	beq.n	80072f0 <lv_obj_get_style_space_right+0x3c>
 80072e8:	697a      	ldr	r2, [r7, #20]
 80072ea:	693b      	ldr	r3, [r7, #16]
 80072ec:	4413      	add	r3, r2
 80072ee:	e000      	b.n	80072f2 <lv_obj_get_style_space_right+0x3e>
 80072f0:	697b      	ldr	r3, [r7, #20]
}
 80072f2:	4618      	mov	r0, r3
 80072f4:	3718      	adds	r7, #24
 80072f6:	46bd      	mov	sp, r7
 80072f8:	bd80      	pop	{r7, pc}

080072fa <lv_obj_get_style_space_top>:
{
 80072fa:	b580      	push	{r7, lr}
 80072fc:	b086      	sub	sp, #24
 80072fe:	af00      	add	r7, sp, #0
 8007300:	6078      	str	r0, [r7, #4]
 8007302:	6039      	str	r1, [r7, #0]
    int32_t padding = lv_obj_get_style_pad_top(obj, part);
 8007304:	6839      	ldr	r1, [r7, #0]
 8007306:	6878      	ldr	r0, [r7, #4]
 8007308:	f7ff fee1 	bl	80070ce <lv_obj_get_style_pad_top>
 800730c:	6178      	str	r0, [r7, #20]
    int32_t border_width = lv_obj_get_style_border_width(obj, part);
 800730e:	6839      	ldr	r1, [r7, #0]
 8007310:	6878      	ldr	r0, [r7, #4]
 8007312:	f7ff ff77 	bl	8007204 <lv_obj_get_style_border_width>
 8007316:	6138      	str	r0, [r7, #16]
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
 8007318:	6839      	ldr	r1, [r7, #0]
 800731a:	6878      	ldr	r0, [r7, #4]
 800731c:	f7ff ff83 	bl	8007226 <lv_obj_get_style_border_side>
 8007320:	4603      	mov	r3, r0
 8007322:	73fb      	strb	r3, [r7, #15]
    return (border_side & LV_BORDER_SIDE_TOP) ? padding + border_width : padding;
 8007324:	7bfb      	ldrb	r3, [r7, #15]
 8007326:	f003 0302 	and.w	r3, r3, #2
 800732a:	2b00      	cmp	r3, #0
 800732c:	d003      	beq.n	8007336 <lv_obj_get_style_space_top+0x3c>
 800732e:	697a      	ldr	r2, [r7, #20]
 8007330:	693b      	ldr	r3, [r7, #16]
 8007332:	4413      	add	r3, r2
 8007334:	e000      	b.n	8007338 <lv_obj_get_style_space_top+0x3e>
 8007336:	697b      	ldr	r3, [r7, #20]
}
 8007338:	4618      	mov	r0, r3
 800733a:	3718      	adds	r7, #24
 800733c:	46bd      	mov	sp, r7
 800733e:	bd80      	pop	{r7, pc}

08007340 <lv_obj_get_style_space_bottom>:
{
 8007340:	b580      	push	{r7, lr}
 8007342:	b086      	sub	sp, #24
 8007344:	af00      	add	r7, sp, #0
 8007346:	6078      	str	r0, [r7, #4]
 8007348:	6039      	str	r1, [r7, #0]
    int32_t padding = lv_obj_get_style_pad_bottom(obj, part);
 800734a:	6839      	ldr	r1, [r7, #0]
 800734c:	6878      	ldr	r0, [r7, #4]
 800734e:	f7ff fecf 	bl	80070f0 <lv_obj_get_style_pad_bottom>
 8007352:	6178      	str	r0, [r7, #20]
    int32_t border_width = lv_obj_get_style_border_width(obj, part);
 8007354:	6839      	ldr	r1, [r7, #0]
 8007356:	6878      	ldr	r0, [r7, #4]
 8007358:	f7ff ff54 	bl	8007204 <lv_obj_get_style_border_width>
 800735c:	6138      	str	r0, [r7, #16]
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
 800735e:	6839      	ldr	r1, [r7, #0]
 8007360:	6878      	ldr	r0, [r7, #4]
 8007362:	f7ff ff60 	bl	8007226 <lv_obj_get_style_border_side>
 8007366:	4603      	mov	r3, r0
 8007368:	73fb      	strb	r3, [r7, #15]
    return (border_side & LV_BORDER_SIDE_BOTTOM) ? padding + border_width : padding;
 800736a:	7bfb      	ldrb	r3, [r7, #15]
 800736c:	f003 0301 	and.w	r3, r3, #1
 8007370:	2b00      	cmp	r3, #0
 8007372:	d003      	beq.n	800737c <lv_obj_get_style_space_bottom+0x3c>
 8007374:	697a      	ldr	r2, [r7, #20]
 8007376:	693b      	ldr	r3, [r7, #16]
 8007378:	4413      	add	r3, r2
 800737a:	e000      	b.n	800737e <lv_obj_get_style_space_bottom+0x3e>
 800737c:	697b      	ldr	r3, [r7, #20]
}
 800737e:	4618      	mov	r0, r3
 8007380:	3718      	adds	r7, #24
 8007382:	46bd      	mov	sp, r7
 8007384:	bd80      	pop	{r7, pc}

08007386 <lv_obj_get_scrollbar_mode>:
/*=====================
 * Getter functions
 *====================*/

lv_scrollbar_mode_t lv_obj_get_scrollbar_mode(const lv_obj_t * obj)
{
 8007386:	b480      	push	{r7}
 8007388:	b083      	sub	sp, #12
 800738a:	af00      	add	r7, sp, #0
 800738c:	6078      	str	r0, [r7, #4]
    if(obj->spec_attr) return obj->spec_attr->scrollbar_mode;
 800738e:	687b      	ldr	r3, [r7, #4]
 8007390:	689b      	ldr	r3, [r3, #8]
 8007392:	2b00      	cmp	r3, #0
 8007394:	d007      	beq.n	80073a6 <lv_obj_get_scrollbar_mode+0x20>
 8007396:	687b      	ldr	r3, [r7, #4]
 8007398:	689b      	ldr	r3, [r3, #8]
 800739a:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
 800739e:	f3c3 0301 	ubfx	r3, r3, #0, #2
 80073a2:	b2db      	uxtb	r3, r3
 80073a4:	e000      	b.n	80073a8 <lv_obj_get_scrollbar_mode+0x22>
    else return LV_SCROLLBAR_MODE_AUTO;
 80073a6:	2303      	movs	r3, #3
}
 80073a8:	4618      	mov	r0, r3
 80073aa:	370c      	adds	r7, #12
 80073ac:	46bd      	mov	sp, r7
 80073ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80073b2:	4770      	bx	lr

080073b4 <lv_obj_get_scroll_dir>:

lv_dir_t lv_obj_get_scroll_dir(const lv_obj_t * obj)
{
 80073b4:	b480      	push	{r7}
 80073b6:	b083      	sub	sp, #12
 80073b8:	af00      	add	r7, sp, #0
 80073ba:	6078      	str	r0, [r7, #4]
    if(obj->spec_attr) return obj->spec_attr->scroll_dir;
 80073bc:	687b      	ldr	r3, [r7, #4]
 80073be:	689b      	ldr	r3, [r3, #8]
 80073c0:	2b00      	cmp	r3, #0
 80073c2:	d006      	beq.n	80073d2 <lv_obj_get_scroll_dir+0x1e>
 80073c4:	687b      	ldr	r3, [r7, #4]
 80073c6:	689b      	ldr	r3, [r3, #8]
 80073c8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80073ca:	f3c3 1383 	ubfx	r3, r3, #6, #4
 80073ce:	b2db      	uxtb	r3, r3
 80073d0:	e000      	b.n	80073d4 <lv_obj_get_scroll_dir+0x20>
    else return LV_DIR_ALL;
 80073d2:	230f      	movs	r3, #15
}
 80073d4:	4618      	mov	r0, r3
 80073d6:	370c      	adds	r7, #12
 80073d8:	46bd      	mov	sp, r7
 80073da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80073de:	4770      	bx	lr

080073e0 <lv_obj_get_scroll_snap_x>:

lv_scroll_snap_t lv_obj_get_scroll_snap_x(const lv_obj_t * obj)
{
 80073e0:	b480      	push	{r7}
 80073e2:	b083      	sub	sp, #12
 80073e4:	af00      	add	r7, sp, #0
 80073e6:	6078      	str	r0, [r7, #4]
    if(obj->spec_attr) return obj->spec_attr->scroll_snap_x;
 80073e8:	687b      	ldr	r3, [r7, #4]
 80073ea:	689b      	ldr	r3, [r3, #8]
 80073ec:	2b00      	cmp	r3, #0
 80073ee:	d007      	beq.n	8007400 <lv_obj_get_scroll_snap_x+0x20>
 80073f0:	687b      	ldr	r3, [r7, #4]
 80073f2:	689b      	ldr	r3, [r3, #8]
 80073f4:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
 80073f8:	f3c3 0381 	ubfx	r3, r3, #2, #2
 80073fc:	b2db      	uxtb	r3, r3
 80073fe:	e000      	b.n	8007402 <lv_obj_get_scroll_snap_x+0x22>
    else return LV_SCROLL_SNAP_NONE;
 8007400:	2300      	movs	r3, #0
}
 8007402:	4618      	mov	r0, r3
 8007404:	370c      	adds	r7, #12
 8007406:	46bd      	mov	sp, r7
 8007408:	f85d 7b04 	ldr.w	r7, [sp], #4
 800740c:	4770      	bx	lr

0800740e <lv_obj_get_scroll_snap_y>:

lv_scroll_snap_t lv_obj_get_scroll_snap_y(const lv_obj_t * obj)
{
 800740e:	b480      	push	{r7}
 8007410:	b083      	sub	sp, #12
 8007412:	af00      	add	r7, sp, #0
 8007414:	6078      	str	r0, [r7, #4]
    if(obj->spec_attr) return obj->spec_attr->scroll_snap_y;
 8007416:	687b      	ldr	r3, [r7, #4]
 8007418:	689b      	ldr	r3, [r3, #8]
 800741a:	2b00      	cmp	r3, #0
 800741c:	d007      	beq.n	800742e <lv_obj_get_scroll_snap_y+0x20>
 800741e:	687b      	ldr	r3, [r7, #4]
 8007420:	689b      	ldr	r3, [r3, #8]
 8007422:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
 8007426:	f3c3 1301 	ubfx	r3, r3, #4, #2
 800742a:	b2db      	uxtb	r3, r3
 800742c:	e000      	b.n	8007430 <lv_obj_get_scroll_snap_y+0x22>
    else return LV_SCROLL_SNAP_NONE;
 800742e:	2300      	movs	r3, #0
}
 8007430:	4618      	mov	r0, r3
 8007432:	370c      	adds	r7, #12
 8007434:	46bd      	mov	sp, r7
 8007436:	f85d 7b04 	ldr.w	r7, [sp], #4
 800743a:	4770      	bx	lr

0800743c <lv_obj_get_scroll_x>:

int32_t lv_obj_get_scroll_x(const lv_obj_t * obj)
{
 800743c:	b480      	push	{r7}
 800743e:	b083      	sub	sp, #12
 8007440:	af00      	add	r7, sp, #0
 8007442:	6078      	str	r0, [r7, #4]
    if(obj->spec_attr == NULL) return 0;
 8007444:	687b      	ldr	r3, [r7, #4]
 8007446:	689b      	ldr	r3, [r3, #8]
 8007448:	2b00      	cmp	r3, #0
 800744a:	d101      	bne.n	8007450 <lv_obj_get_scroll_x+0x14>
 800744c:	2300      	movs	r3, #0
 800744e:	e003      	b.n	8007458 <lv_obj_get_scroll_x+0x1c>
    return -obj->spec_attr->scroll.x;
 8007450:	687b      	ldr	r3, [r7, #4]
 8007452:	689b      	ldr	r3, [r3, #8]
 8007454:	699b      	ldr	r3, [r3, #24]
 8007456:	425b      	negs	r3, r3
}
 8007458:	4618      	mov	r0, r3
 800745a:	370c      	adds	r7, #12
 800745c:	46bd      	mov	sp, r7
 800745e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007462:	4770      	bx	lr

08007464 <lv_obj_get_scroll_y>:

int32_t lv_obj_get_scroll_y(const lv_obj_t * obj)
{
 8007464:	b480      	push	{r7}
 8007466:	b083      	sub	sp, #12
 8007468:	af00      	add	r7, sp, #0
 800746a:	6078      	str	r0, [r7, #4]
    if(obj->spec_attr == NULL) return 0;
 800746c:	687b      	ldr	r3, [r7, #4]
 800746e:	689b      	ldr	r3, [r3, #8]
 8007470:	2b00      	cmp	r3, #0
 8007472:	d101      	bne.n	8007478 <lv_obj_get_scroll_y+0x14>
 8007474:	2300      	movs	r3, #0
 8007476:	e003      	b.n	8007480 <lv_obj_get_scroll_y+0x1c>
    return -obj->spec_attr->scroll.y;
 8007478:	687b      	ldr	r3, [r7, #4]
 800747a:	689b      	ldr	r3, [r3, #8]
 800747c:	69db      	ldr	r3, [r3, #28]
 800747e:	425b      	negs	r3, r3
}
 8007480:	4618      	mov	r0, r3
 8007482:	370c      	adds	r7, #12
 8007484:	46bd      	mov	sp, r7
 8007486:	f85d 7b04 	ldr.w	r7, [sp], #4
 800748a:	4770      	bx	lr

0800748c <lv_obj_get_scroll_top>:

int32_t lv_obj_get_scroll_top(lv_obj_t * obj)
{
 800748c:	b480      	push	{r7}
 800748e:	b083      	sub	sp, #12
 8007490:	af00      	add	r7, sp, #0
 8007492:	6078      	str	r0, [r7, #4]
    if(obj->spec_attr == NULL) return 0;
 8007494:	687b      	ldr	r3, [r7, #4]
 8007496:	689b      	ldr	r3, [r3, #8]
 8007498:	2b00      	cmp	r3, #0
 800749a:	d101      	bne.n	80074a0 <lv_obj_get_scroll_top+0x14>
 800749c:	2300      	movs	r3, #0
 800749e:	e003      	b.n	80074a8 <lv_obj_get_scroll_top+0x1c>
    return -obj->spec_attr->scroll.y;
 80074a0:	687b      	ldr	r3, [r7, #4]
 80074a2:	689b      	ldr	r3, [r3, #8]
 80074a4:	69db      	ldr	r3, [r3, #28]
 80074a6:	425b      	negs	r3, r3
}
 80074a8:	4618      	mov	r0, r3
 80074aa:	370c      	adds	r7, #12
 80074ac:	46bd      	mov	sp, r7
 80074ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80074b2:	4770      	bx	lr

080074b4 <lv_obj_get_scroll_bottom>:

int32_t lv_obj_get_scroll_bottom(lv_obj_t * obj)
{
 80074b4:	b590      	push	{r4, r7, lr}
 80074b6:	b08b      	sub	sp, #44	@ 0x2c
 80074b8:	af00      	add	r7, sp, #0
 80074ba:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    int32_t child_res = LV_COORD_MIN;
 80074bc:	4b31      	ldr	r3, [pc, #196]	@ (8007584 <lv_obj_get_scroll_bottom+0xd0>)
 80074be:	627b      	str	r3, [r7, #36]	@ 0x24
    uint32_t i;
    uint32_t child_cnt = lv_obj_get_child_count(obj);
 80074c0:	6878      	ldr	r0, [r7, #4]
 80074c2:	f003 fcfd 	bl	800aec0 <lv_obj_get_child_count>
 80074c6:	61f8      	str	r0, [r7, #28]
    for(i = 0; i < child_cnt; i++) {
 80074c8:	2300      	movs	r3, #0
 80074ca:	623b      	str	r3, [r7, #32]
 80074cc:	e022      	b.n	8007514 <lv_obj_get_scroll_bottom+0x60>
        lv_obj_t * child = obj->spec_attr->children[i];
 80074ce:	687b      	ldr	r3, [r7, #4]
 80074d0:	689b      	ldr	r3, [r3, #8]
 80074d2:	681a      	ldr	r2, [r3, #0]
 80074d4:	6a3b      	ldr	r3, [r7, #32]
 80074d6:	009b      	lsls	r3, r3, #2
 80074d8:	4413      	add	r3, r2
 80074da:	681b      	ldr	r3, [r3, #0]
 80074dc:	60fb      	str	r3, [r7, #12]
        if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 80074de:	492a      	ldr	r1, [pc, #168]	@ (8007588 <lv_obj_get_scroll_bottom+0xd4>)
 80074e0:	68f8      	ldr	r0, [r7, #12]
 80074e2:	f7fb fc49 	bl	8002d78 <lv_obj_has_flag_any>
 80074e6:	4603      	mov	r3, r0
 80074e8:	2b00      	cmp	r3, #0
 80074ea:	d10f      	bne.n	800750c <lv_obj_get_scroll_bottom+0x58>

        int32_t tmp_y = child->coords.y2 + lv_obj_get_style_margin_bottom(child, LV_PART_MAIN);
 80074ec:	68fb      	ldr	r3, [r7, #12]
 80074ee:	6a1c      	ldr	r4, [r3, #32]
 80074f0:	2100      	movs	r1, #0
 80074f2:	68f8      	ldr	r0, [r7, #12]
 80074f4:	f7ff fe2f 	bl	8007156 <lv_obj_get_style_margin_bottom>
 80074f8:	4603      	mov	r3, r0
 80074fa:	4423      	add	r3, r4
 80074fc:	60bb      	str	r3, [r7, #8]
        child_res = LV_MAX(child_res, tmp_y);
 80074fe:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8007500:	68bb      	ldr	r3, [r7, #8]
 8007502:	4293      	cmp	r3, r2
 8007504:	bfb8      	it	lt
 8007506:	4613      	movlt	r3, r2
 8007508:	627b      	str	r3, [r7, #36]	@ 0x24
 800750a:	e000      	b.n	800750e <lv_obj_get_scroll_bottom+0x5a>
        if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 800750c:	bf00      	nop
    for(i = 0; i < child_cnt; i++) {
 800750e:	6a3b      	ldr	r3, [r7, #32]
 8007510:	3301      	adds	r3, #1
 8007512:	623b      	str	r3, [r7, #32]
 8007514:	6a3a      	ldr	r2, [r7, #32]
 8007516:	69fb      	ldr	r3, [r7, #28]
 8007518:	429a      	cmp	r2, r3
 800751a:	d3d8      	bcc.n	80074ce <lv_obj_get_scroll_bottom+0x1a>
    }

    int32_t space_top = lv_obj_get_style_space_top(obj, LV_PART_MAIN);
 800751c:	2100      	movs	r1, #0
 800751e:	6878      	ldr	r0, [r7, #4]
 8007520:	f7ff feeb 	bl	80072fa <lv_obj_get_style_space_top>
 8007524:	61b8      	str	r0, [r7, #24]
    int32_t space_bottom = lv_obj_get_style_space_bottom(obj, LV_PART_MAIN);
 8007526:	2100      	movs	r1, #0
 8007528:	6878      	ldr	r0, [r7, #4]
 800752a:	f7ff ff09 	bl	8007340 <lv_obj_get_style_space_bottom>
 800752e:	6178      	str	r0, [r7, #20]

    if(child_res != LV_COORD_MIN) {
 8007530:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007532:	4a14      	ldr	r2, [pc, #80]	@ (8007584 <lv_obj_get_scroll_bottom+0xd0>)
 8007534:	4293      	cmp	r3, r2
 8007536:	d006      	beq.n	8007546 <lv_obj_get_scroll_bottom+0x92>
        child_res -= (obj->coords.y2 - space_bottom);
 8007538:	687b      	ldr	r3, [r7, #4]
 800753a:	6a1a      	ldr	r2, [r3, #32]
 800753c:	697b      	ldr	r3, [r7, #20]
 800753e:	1ad3      	subs	r3, r2, r3
 8007540:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8007542:	1ad3      	subs	r3, r2, r3
 8007544:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    int32_t self_h = lv_obj_get_self_height(obj);
 8007546:	6878      	ldr	r0, [r7, #4]
 8007548:	f7fe fc8e 	bl	8005e68 <lv_obj_get_self_height>
 800754c:	6138      	str	r0, [r7, #16]
    self_h = self_h - (lv_obj_get_height(obj) - space_top - space_bottom);
 800754e:	6878      	ldr	r0, [r7, #4]
 8007550:	f7fe fbfc 	bl	8005d4c <lv_obj_get_height>
 8007554:	4602      	mov	r2, r0
 8007556:	69bb      	ldr	r3, [r7, #24]
 8007558:	1ad2      	subs	r2, r2, r3
 800755a:	697b      	ldr	r3, [r7, #20]
 800755c:	1ad3      	subs	r3, r2, r3
 800755e:	693a      	ldr	r2, [r7, #16]
 8007560:	1ad3      	subs	r3, r2, r3
 8007562:	613b      	str	r3, [r7, #16]
    self_h -= lv_obj_get_scroll_y(obj);
 8007564:	6878      	ldr	r0, [r7, #4]
 8007566:	f7ff ff7d 	bl	8007464 <lv_obj_get_scroll_y>
 800756a:	4602      	mov	r2, r0
 800756c:	693b      	ldr	r3, [r7, #16]
 800756e:	1a9b      	subs	r3, r3, r2
 8007570:	613b      	str	r3, [r7, #16]
    return LV_MAX(child_res, self_h);
 8007572:	693a      	ldr	r2, [r7, #16]
 8007574:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007576:	4293      	cmp	r3, r2
 8007578:	bfb8      	it	lt
 800757a:	4613      	movlt	r3, r2
}
 800757c:	4618      	mov	r0, r3
 800757e:	372c      	adds	r7, #44	@ 0x2c
 8007580:	46bd      	mov	sp, r7
 8007582:	bd90      	pop	{r4, r7, pc}
 8007584:	e0000001 	.word	0xe0000001
 8007588:	00040001 	.word	0x00040001

0800758c <lv_obj_get_scroll_left>:

int32_t lv_obj_get_scroll_left(lv_obj_t * obj)
{
 800758c:	b590      	push	{r4, r7, lr}
 800758e:	b08d      	sub	sp, #52	@ 0x34
 8007590:	af00      	add	r7, sp, #0
 8007592:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    /*Normally can't scroll the object out on the left.
     *So simply use the current scroll position as "left size"*/
    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) != LV_BASE_DIR_RTL) {
 8007594:	2100      	movs	r1, #0
 8007596:	6878      	ldr	r0, [r7, #4]
 8007598:	f7ff fe57 	bl	800724a <lv_obj_get_style_base_dir>
 800759c:	4603      	mov	r3, r0
 800759e:	2b01      	cmp	r3, #1
 80075a0:	d00a      	beq.n	80075b8 <lv_obj_get_scroll_left+0x2c>
        if(obj->spec_attr == NULL) return 0;
 80075a2:	687b      	ldr	r3, [r7, #4]
 80075a4:	689b      	ldr	r3, [r3, #8]
 80075a6:	2b00      	cmp	r3, #0
 80075a8:	d101      	bne.n	80075ae <lv_obj_get_scroll_left+0x22>
 80075aa:	2300      	movs	r3, #0
 80075ac:	e06d      	b.n	800768a <lv_obj_get_scroll_left+0xfe>
        return -obj->spec_attr->scroll.x;
 80075ae:	687b      	ldr	r3, [r7, #4]
 80075b0:	689b      	ldr	r3, [r3, #8]
 80075b2:	699b      	ldr	r3, [r3, #24]
 80075b4:	425b      	negs	r3, r3
 80075b6:	e068      	b.n	800768a <lv_obj_get_scroll_left+0xfe>
    }

    /*With RTL base direction scrolling the left is normal so find the left most coordinate*/
    int32_t space_right = lv_obj_get_style_space_right(obj, LV_PART_MAIN);
 80075b8:	2100      	movs	r1, #0
 80075ba:	6878      	ldr	r0, [r7, #4]
 80075bc:	f7ff fe7a 	bl	80072b4 <lv_obj_get_style_space_right>
 80075c0:	6238      	str	r0, [r7, #32]
    int32_t space_left = lv_obj_get_style_space_left(obj, LV_PART_MAIN);
 80075c2:	2100      	movs	r1, #0
 80075c4:	6878      	ldr	r0, [r7, #4]
 80075c6:	f7ff fe52 	bl	800726e <lv_obj_get_style_space_left>
 80075ca:	61f8      	str	r0, [r7, #28]

    int32_t child_res = 0;
 80075cc:	2300      	movs	r3, #0
 80075ce:	62fb      	str	r3, [r7, #44]	@ 0x2c

    uint32_t i;
    int32_t x1 = LV_COORD_MAX;
 80075d0:	f06f 4360 	mvn.w	r3, #3758096384	@ 0xe0000000
 80075d4:	627b      	str	r3, [r7, #36]	@ 0x24
    uint32_t child_cnt = lv_obj_get_child_count(obj);
 80075d6:	6878      	ldr	r0, [r7, #4]
 80075d8:	f003 fc72 	bl	800aec0 <lv_obj_get_child_count>
 80075dc:	61b8      	str	r0, [r7, #24]
    for(i = 0; i < child_cnt; i++) {
 80075de:	2300      	movs	r3, #0
 80075e0:	62bb      	str	r3, [r7, #40]	@ 0x28
 80075e2:	e022      	b.n	800762a <lv_obj_get_scroll_left+0x9e>
        lv_obj_t * child = obj->spec_attr->children[i];
 80075e4:	687b      	ldr	r3, [r7, #4]
 80075e6:	689b      	ldr	r3, [r3, #8]
 80075e8:	681a      	ldr	r2, [r3, #0]
 80075ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80075ec:	009b      	lsls	r3, r3, #2
 80075ee:	4413      	add	r3, r2
 80075f0:	681b      	ldr	r3, [r3, #0]
 80075f2:	613b      	str	r3, [r7, #16]
        if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 80075f4:	4927      	ldr	r1, [pc, #156]	@ (8007694 <lv_obj_get_scroll_left+0x108>)
 80075f6:	6938      	ldr	r0, [r7, #16]
 80075f8:	f7fb fbbe 	bl	8002d78 <lv_obj_has_flag_any>
 80075fc:	4603      	mov	r3, r0
 80075fe:	2b00      	cmp	r3, #0
 8007600:	d10f      	bne.n	8007622 <lv_obj_get_scroll_left+0x96>

        int32_t tmp_x = child->coords.x1 - lv_obj_get_style_margin_left(child, LV_PART_MAIN);
 8007602:	693b      	ldr	r3, [r7, #16]
 8007604:	695c      	ldr	r4, [r3, #20]
 8007606:	2100      	movs	r1, #0
 8007608:	6938      	ldr	r0, [r7, #16]
 800760a:	f7ff fdb5 	bl	8007178 <lv_obj_get_style_margin_left>
 800760e:	4603      	mov	r3, r0
 8007610:	1ae3      	subs	r3, r4, r3
 8007612:	60fb      	str	r3, [r7, #12]
        x1 = LV_MIN(x1, tmp_x);
 8007614:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8007616:	68fb      	ldr	r3, [r7, #12]
 8007618:	4293      	cmp	r3, r2
 800761a:	bfa8      	it	ge
 800761c:	4613      	movge	r3, r2
 800761e:	627b      	str	r3, [r7, #36]	@ 0x24
 8007620:	e000      	b.n	8007624 <lv_obj_get_scroll_left+0x98>
        if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 8007622:	bf00      	nop
    for(i = 0; i < child_cnt; i++) {
 8007624:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007626:	3301      	adds	r3, #1
 8007628:	62bb      	str	r3, [r7, #40]	@ 0x28
 800762a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800762c:	69bb      	ldr	r3, [r7, #24]
 800762e:	429a      	cmp	r2, r3
 8007630:	d3d8      	bcc.n	80075e4 <lv_obj_get_scroll_left+0x58>
    }

    if(x1 != LV_COORD_MAX) {
 8007632:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007634:	f06f 4260 	mvn.w	r2, #3758096384	@ 0xe0000000
 8007638:	4293      	cmp	r3, r2
 800763a:	d009      	beq.n	8007650 <lv_obj_get_scroll_left+0xc4>
        child_res = x1;
 800763c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800763e:	62fb      	str	r3, [r7, #44]	@ 0x2c
        child_res = (obj->coords.x1 + space_left) - child_res;
 8007640:	687b      	ldr	r3, [r7, #4]
 8007642:	695a      	ldr	r2, [r3, #20]
 8007644:	69fb      	ldr	r3, [r7, #28]
 8007646:	441a      	add	r2, r3
 8007648:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800764a:	1ad3      	subs	r3, r2, r3
 800764c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800764e:	e001      	b.n	8007654 <lv_obj_get_scroll_left+0xc8>
    }
    else {
        child_res = LV_COORD_MIN;
 8007650:	4b11      	ldr	r3, [pc, #68]	@ (8007698 <lv_obj_get_scroll_left+0x10c>)
 8007652:	62fb      	str	r3, [r7, #44]	@ 0x2c
    }

    int32_t self_w = lv_obj_get_self_width(obj);
 8007654:	6878      	ldr	r0, [r7, #4]
 8007656:	f7fe fbf1 	bl	8005e3c <lv_obj_get_self_width>
 800765a:	6178      	str	r0, [r7, #20]
    self_w = self_w - (lv_obj_get_width(obj) - space_right - space_left);
 800765c:	6878      	ldr	r0, [r7, #4]
 800765e:	f7fe fb67 	bl	8005d30 <lv_obj_get_width>
 8007662:	4602      	mov	r2, r0
 8007664:	6a3b      	ldr	r3, [r7, #32]
 8007666:	1ad2      	subs	r2, r2, r3
 8007668:	69fb      	ldr	r3, [r7, #28]
 800766a:	1ad3      	subs	r3, r2, r3
 800766c:	697a      	ldr	r2, [r7, #20]
 800766e:	1ad3      	subs	r3, r2, r3
 8007670:	617b      	str	r3, [r7, #20]
    self_w += lv_obj_get_scroll_x(obj);
 8007672:	6878      	ldr	r0, [r7, #4]
 8007674:	f7ff fee2 	bl	800743c <lv_obj_get_scroll_x>
 8007678:	4602      	mov	r2, r0
 800767a:	697b      	ldr	r3, [r7, #20]
 800767c:	4413      	add	r3, r2
 800767e:	617b      	str	r3, [r7, #20]

    return LV_MAX(child_res, self_w);
 8007680:	697a      	ldr	r2, [r7, #20]
 8007682:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007684:	4293      	cmp	r3, r2
 8007686:	bfb8      	it	lt
 8007688:	4613      	movlt	r3, r2
}
 800768a:	4618      	mov	r0, r3
 800768c:	3734      	adds	r7, #52	@ 0x34
 800768e:	46bd      	mov	sp, r7
 8007690:	bd90      	pop	{r4, r7, pc}
 8007692:	bf00      	nop
 8007694:	00040001 	.word	0x00040001
 8007698:	e0000001 	.word	0xe0000001

0800769c <lv_obj_get_scroll_right>:

int32_t lv_obj_get_scroll_right(lv_obj_t * obj)
{
 800769c:	b590      	push	{r4, r7, lr}
 800769e:	b08b      	sub	sp, #44	@ 0x2c
 80076a0:	af00      	add	r7, sp, #0
 80076a2:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    /*With RTL base dir can't scroll to the object out on the right.
     *So simply use the current scroll position as "right size"*/
    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) == LV_BASE_DIR_RTL) {
 80076a4:	2100      	movs	r1, #0
 80076a6:	6878      	ldr	r0, [r7, #4]
 80076a8:	f7ff fdcf 	bl	800724a <lv_obj_get_style_base_dir>
 80076ac:	4603      	mov	r3, r0
 80076ae:	2b01      	cmp	r3, #1
 80076b0:	d109      	bne.n	80076c6 <lv_obj_get_scroll_right+0x2a>
        if(obj->spec_attr == NULL) return 0;
 80076b2:	687b      	ldr	r3, [r7, #4]
 80076b4:	689b      	ldr	r3, [r3, #8]
 80076b6:	2b00      	cmp	r3, #0
 80076b8:	d101      	bne.n	80076be <lv_obj_get_scroll_right+0x22>
 80076ba:	2300      	movs	r3, #0
 80076bc:	e063      	b.n	8007786 <lv_obj_get_scroll_right+0xea>
        return obj->spec_attr->scroll.x;
 80076be:	687b      	ldr	r3, [r7, #4]
 80076c0:	689b      	ldr	r3, [r3, #8]
 80076c2:	699b      	ldr	r3, [r3, #24]
 80076c4:	e05f      	b.n	8007786 <lv_obj_get_scroll_right+0xea>
    }

    /*With other base direction (LTR) scrolling to the right is normal so find the right most coordinate*/
    int32_t child_res = LV_COORD_MIN;
 80076c6:	4b32      	ldr	r3, [pc, #200]	@ (8007790 <lv_obj_get_scroll_right+0xf4>)
 80076c8:	627b      	str	r3, [r7, #36]	@ 0x24
    uint32_t i;
    uint32_t child_cnt = lv_obj_get_child_count(obj);
 80076ca:	6878      	ldr	r0, [r7, #4]
 80076cc:	f003 fbf8 	bl	800aec0 <lv_obj_get_child_count>
 80076d0:	61f8      	str	r0, [r7, #28]
    for(i = 0; i < child_cnt; i++) {
 80076d2:	2300      	movs	r3, #0
 80076d4:	623b      	str	r3, [r7, #32]
 80076d6:	e022      	b.n	800771e <lv_obj_get_scroll_right+0x82>
        lv_obj_t * child = obj->spec_attr->children[i];
 80076d8:	687b      	ldr	r3, [r7, #4]
 80076da:	689b      	ldr	r3, [r3, #8]
 80076dc:	681a      	ldr	r2, [r3, #0]
 80076de:	6a3b      	ldr	r3, [r7, #32]
 80076e0:	009b      	lsls	r3, r3, #2
 80076e2:	4413      	add	r3, r2
 80076e4:	681b      	ldr	r3, [r3, #0]
 80076e6:	60fb      	str	r3, [r7, #12]
        if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 80076e8:	492a      	ldr	r1, [pc, #168]	@ (8007794 <lv_obj_get_scroll_right+0xf8>)
 80076ea:	68f8      	ldr	r0, [r7, #12]
 80076ec:	f7fb fb44 	bl	8002d78 <lv_obj_has_flag_any>
 80076f0:	4603      	mov	r3, r0
 80076f2:	2b00      	cmp	r3, #0
 80076f4:	d10f      	bne.n	8007716 <lv_obj_get_scroll_right+0x7a>

        int32_t tmp_x = child->coords.x2 + lv_obj_get_style_margin_right(child, LV_PART_MAIN);
 80076f6:	68fb      	ldr	r3, [r7, #12]
 80076f8:	69dc      	ldr	r4, [r3, #28]
 80076fa:	2100      	movs	r1, #0
 80076fc:	68f8      	ldr	r0, [r7, #12]
 80076fe:	f7ff fd4c 	bl	800719a <lv_obj_get_style_margin_right>
 8007702:	4603      	mov	r3, r0
 8007704:	4423      	add	r3, r4
 8007706:	60bb      	str	r3, [r7, #8]
        child_res = LV_MAX(child_res, tmp_x);
 8007708:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800770a:	68bb      	ldr	r3, [r7, #8]
 800770c:	4293      	cmp	r3, r2
 800770e:	bfb8      	it	lt
 8007710:	4613      	movlt	r3, r2
 8007712:	627b      	str	r3, [r7, #36]	@ 0x24
 8007714:	e000      	b.n	8007718 <lv_obj_get_scroll_right+0x7c>
        if(lv_obj_has_flag_any(child,  LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 8007716:	bf00      	nop
    for(i = 0; i < child_cnt; i++) {
 8007718:	6a3b      	ldr	r3, [r7, #32]
 800771a:	3301      	adds	r3, #1
 800771c:	623b      	str	r3, [r7, #32]
 800771e:	6a3a      	ldr	r2, [r7, #32]
 8007720:	69fb      	ldr	r3, [r7, #28]
 8007722:	429a      	cmp	r2, r3
 8007724:	d3d8      	bcc.n	80076d8 <lv_obj_get_scroll_right+0x3c>
    }

    int32_t space_right = lv_obj_get_style_space_right(obj, LV_PART_MAIN);
 8007726:	2100      	movs	r1, #0
 8007728:	6878      	ldr	r0, [r7, #4]
 800772a:	f7ff fdc3 	bl	80072b4 <lv_obj_get_style_space_right>
 800772e:	61b8      	str	r0, [r7, #24]
    int32_t space_left = lv_obj_get_style_space_left(obj, LV_PART_MAIN);
 8007730:	2100      	movs	r1, #0
 8007732:	6878      	ldr	r0, [r7, #4]
 8007734:	f7ff fd9b 	bl	800726e <lv_obj_get_style_space_left>
 8007738:	6178      	str	r0, [r7, #20]

    if(child_res != LV_COORD_MIN) {
 800773a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800773c:	4a14      	ldr	r2, [pc, #80]	@ (8007790 <lv_obj_get_scroll_right+0xf4>)
 800773e:	4293      	cmp	r3, r2
 8007740:	d006      	beq.n	8007750 <lv_obj_get_scroll_right+0xb4>
        child_res -= (obj->coords.x2 - space_right);
 8007742:	687b      	ldr	r3, [r7, #4]
 8007744:	69da      	ldr	r2, [r3, #28]
 8007746:	69bb      	ldr	r3, [r7, #24]
 8007748:	1ad3      	subs	r3, r2, r3
 800774a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800774c:	1ad3      	subs	r3, r2, r3
 800774e:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    int32_t self_w;
    self_w = lv_obj_get_self_width(obj);
 8007750:	6878      	ldr	r0, [r7, #4]
 8007752:	f7fe fb73 	bl	8005e3c <lv_obj_get_self_width>
 8007756:	6138      	str	r0, [r7, #16]
    self_w = self_w - (lv_obj_get_width(obj) - space_right - space_left);
 8007758:	6878      	ldr	r0, [r7, #4]
 800775a:	f7fe fae9 	bl	8005d30 <lv_obj_get_width>
 800775e:	4602      	mov	r2, r0
 8007760:	69bb      	ldr	r3, [r7, #24]
 8007762:	1ad2      	subs	r2, r2, r3
 8007764:	697b      	ldr	r3, [r7, #20]
 8007766:	1ad3      	subs	r3, r2, r3
 8007768:	693a      	ldr	r2, [r7, #16]
 800776a:	1ad3      	subs	r3, r2, r3
 800776c:	613b      	str	r3, [r7, #16]
    self_w -= lv_obj_get_scroll_x(obj);
 800776e:	6878      	ldr	r0, [r7, #4]
 8007770:	f7ff fe64 	bl	800743c <lv_obj_get_scroll_x>
 8007774:	4602      	mov	r2, r0
 8007776:	693b      	ldr	r3, [r7, #16]
 8007778:	1a9b      	subs	r3, r3, r2
 800777a:	613b      	str	r3, [r7, #16]
    return LV_MAX(child_res, self_w);
 800777c:	693a      	ldr	r2, [r7, #16]
 800777e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007780:	4293      	cmp	r3, r2
 8007782:	bfb8      	it	lt
 8007784:	4613      	movlt	r3, r2
}
 8007786:	4618      	mov	r0, r3
 8007788:	372c      	adds	r7, #44	@ 0x2c
 800778a:	46bd      	mov	sp, r7
 800778c:	bd90      	pop	{r4, r7, pc}
 800778e:	bf00      	nop
 8007790:	e0000001 	.word	0xe0000001
 8007794:	00040001 	.word	0x00040001

08007798 <lv_obj_scroll_by_bounded>:
/*=====================
 * Other functions
 *====================*/

void lv_obj_scroll_by_bounded(lv_obj_t * obj, int32_t dx, int32_t dy, lv_anim_enable_t anim_en)
{
 8007798:	b590      	push	{r4, r7, lr}
 800779a:	b08d      	sub	sp, #52	@ 0x34
 800779c:	af00      	add	r7, sp, #0
 800779e:	60f8      	str	r0, [r7, #12]
 80077a0:	60b9      	str	r1, [r7, #8]
 80077a2:	607a      	str	r2, [r7, #4]
 80077a4:	70fb      	strb	r3, [r7, #3]
    if(dx == 0 && dy == 0) return;
 80077a6:	68bb      	ldr	r3, [r7, #8]
 80077a8:	2b00      	cmp	r3, #0
 80077aa:	d103      	bne.n	80077b4 <lv_obj_scroll_by_bounded+0x1c>
 80077ac:	687b      	ldr	r3, [r7, #4]
 80077ae:	2b00      	cmp	r3, #0
 80077b0:	f000 808f 	beq.w	80078d2 <lv_obj_scroll_by_bounded+0x13a>

    /*We need to know the final sizes for bound check*/
    lv_obj_update_layout(obj);
 80077b4:	68f8      	ldr	r0, [r7, #12]
 80077b6:	f7fe fa65 	bl	8005c84 <lv_obj_update_layout>

    /*Don't let scroll more than naturally possible by the size of the content*/
    int32_t x_current = -lv_obj_get_scroll_x(obj);
 80077ba:	68f8      	ldr	r0, [r7, #12]
 80077bc:	f7ff fe3e 	bl	800743c <lv_obj_get_scroll_x>
 80077c0:	4603      	mov	r3, r0
 80077c2:	425b      	negs	r3, r3
 80077c4:	61bb      	str	r3, [r7, #24]
    int32_t x_bounded = x_current + dx;
 80077c6:	69ba      	ldr	r2, [r7, #24]
 80077c8:	68bb      	ldr	r3, [r7, #8]
 80077ca:	4413      	add	r3, r2
 80077cc:	62fb      	str	r3, [r7, #44]	@ 0x2c

    if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) != LV_BASE_DIR_RTL) {
 80077ce:	2100      	movs	r1, #0
 80077d0:	68f8      	ldr	r0, [r7, #12]
 80077d2:	f7ff fd3a 	bl	800724a <lv_obj_get_style_base_dir>
 80077d6:	4603      	mov	r3, r0
 80077d8:	2b01      	cmp	r3, #1
 80077da:	d01f      	beq.n	800781c <lv_obj_scroll_by_bounded+0x84>
        if(x_bounded > 0) x_bounded = 0;
 80077dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80077de:	2b00      	cmp	r3, #0
 80077e0:	dd01      	ble.n	80077e6 <lv_obj_scroll_by_bounded+0x4e>
 80077e2:	2300      	movs	r3, #0
 80077e4:	62fb      	str	r3, [r7, #44]	@ 0x2c
        if(x_bounded < 0) {
 80077e6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80077e8:	2b00      	cmp	r3, #0
 80077ea:	da34      	bge.n	8007856 <lv_obj_scroll_by_bounded+0xbe>
            int32_t  scroll_max = lv_obj_get_scroll_left(obj) + lv_obj_get_scroll_right(obj);
 80077ec:	68f8      	ldr	r0, [r7, #12]
 80077ee:	f7ff fecd 	bl	800758c <lv_obj_get_scroll_left>
 80077f2:	4604      	mov	r4, r0
 80077f4:	68f8      	ldr	r0, [r7, #12]
 80077f6:	f7ff ff51 	bl	800769c <lv_obj_get_scroll_right>
 80077fa:	4603      	mov	r3, r0
 80077fc:	4423      	add	r3, r4
 80077fe:	62bb      	str	r3, [r7, #40]	@ 0x28
            if(scroll_max < 0) scroll_max = 0;
 8007800:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007802:	2b00      	cmp	r3, #0
 8007804:	da01      	bge.n	800780a <lv_obj_scroll_by_bounded+0x72>
 8007806:	2300      	movs	r3, #0
 8007808:	62bb      	str	r3, [r7, #40]	@ 0x28

            if(x_bounded < -scroll_max) x_bounded = -scroll_max;
 800780a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800780c:	425b      	negs	r3, r3
 800780e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8007810:	429a      	cmp	r2, r3
 8007812:	da20      	bge.n	8007856 <lv_obj_scroll_by_bounded+0xbe>
 8007814:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007816:	425b      	negs	r3, r3
 8007818:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800781a:	e01c      	b.n	8007856 <lv_obj_scroll_by_bounded+0xbe>
        }
    }
    else {
        if(x_bounded < 0) x_bounded = 0;
 800781c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800781e:	2b00      	cmp	r3, #0
 8007820:	da01      	bge.n	8007826 <lv_obj_scroll_by_bounded+0x8e>
 8007822:	2300      	movs	r3, #0
 8007824:	62fb      	str	r3, [r7, #44]	@ 0x2c
        if(x_bounded > 0) {
 8007826:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007828:	2b00      	cmp	r3, #0
 800782a:	dd14      	ble.n	8007856 <lv_obj_scroll_by_bounded+0xbe>
            int32_t  scroll_max = lv_obj_get_scroll_left(obj) + lv_obj_get_scroll_right(obj);
 800782c:	68f8      	ldr	r0, [r7, #12]
 800782e:	f7ff fead 	bl	800758c <lv_obj_get_scroll_left>
 8007832:	4604      	mov	r4, r0
 8007834:	68f8      	ldr	r0, [r7, #12]
 8007836:	f7ff ff31 	bl	800769c <lv_obj_get_scroll_right>
 800783a:	4603      	mov	r3, r0
 800783c:	4423      	add	r3, r4
 800783e:	627b      	str	r3, [r7, #36]	@ 0x24
            if(scroll_max < 0) scroll_max = 0;
 8007840:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007842:	2b00      	cmp	r3, #0
 8007844:	da01      	bge.n	800784a <lv_obj_scroll_by_bounded+0xb2>
 8007846:	2300      	movs	r3, #0
 8007848:	627b      	str	r3, [r7, #36]	@ 0x24

            if(x_bounded > scroll_max) x_bounded = scroll_max;
 800784a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800784c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800784e:	429a      	cmp	r2, r3
 8007850:	dd01      	ble.n	8007856 <lv_obj_scroll_by_bounded+0xbe>
 8007852:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007854:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }
    }

    /*Don't let scroll more than naturally possible by the size of the content*/
    int32_t y_current = -lv_obj_get_scroll_y(obj);
 8007856:	68f8      	ldr	r0, [r7, #12]
 8007858:	f7ff fe04 	bl	8007464 <lv_obj_get_scroll_y>
 800785c:	4603      	mov	r3, r0
 800785e:	425b      	negs	r3, r3
 8007860:	617b      	str	r3, [r7, #20]
    int32_t y_bounded = y_current + dy;
 8007862:	697a      	ldr	r2, [r7, #20]
 8007864:	687b      	ldr	r3, [r7, #4]
 8007866:	4413      	add	r3, r2
 8007868:	623b      	str	r3, [r7, #32]

    if(y_bounded > 0) y_bounded = 0;
 800786a:	6a3b      	ldr	r3, [r7, #32]
 800786c:	2b00      	cmp	r3, #0
 800786e:	dd01      	ble.n	8007874 <lv_obj_scroll_by_bounded+0xdc>
 8007870:	2300      	movs	r3, #0
 8007872:	623b      	str	r3, [r7, #32]
    if(y_bounded < 0) {
 8007874:	6a3b      	ldr	r3, [r7, #32]
 8007876:	2b00      	cmp	r3, #0
 8007878:	da16      	bge.n	80078a8 <lv_obj_scroll_by_bounded+0x110>
        int32_t  scroll_max = lv_obj_get_scroll_top(obj) + lv_obj_get_scroll_bottom(obj);
 800787a:	68f8      	ldr	r0, [r7, #12]
 800787c:	f7ff fe06 	bl	800748c <lv_obj_get_scroll_top>
 8007880:	4604      	mov	r4, r0
 8007882:	68f8      	ldr	r0, [r7, #12]
 8007884:	f7ff fe16 	bl	80074b4 <lv_obj_get_scroll_bottom>
 8007888:	4603      	mov	r3, r0
 800788a:	4423      	add	r3, r4
 800788c:	61fb      	str	r3, [r7, #28]
        if(scroll_max < 0) scroll_max = 0;
 800788e:	69fb      	ldr	r3, [r7, #28]
 8007890:	2b00      	cmp	r3, #0
 8007892:	da01      	bge.n	8007898 <lv_obj_scroll_by_bounded+0x100>
 8007894:	2300      	movs	r3, #0
 8007896:	61fb      	str	r3, [r7, #28]
        if(y_bounded < -scroll_max) y_bounded = -scroll_max;
 8007898:	69fb      	ldr	r3, [r7, #28]
 800789a:	425b      	negs	r3, r3
 800789c:	6a3a      	ldr	r2, [r7, #32]
 800789e:	429a      	cmp	r2, r3
 80078a0:	da02      	bge.n	80078a8 <lv_obj_scroll_by_bounded+0x110>
 80078a2:	69fb      	ldr	r3, [r7, #28]
 80078a4:	425b      	negs	r3, r3
 80078a6:	623b      	str	r3, [r7, #32]
    }

    dx = x_bounded - x_current;
 80078a8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80078aa:	69bb      	ldr	r3, [r7, #24]
 80078ac:	1ad3      	subs	r3, r2, r3
 80078ae:	60bb      	str	r3, [r7, #8]
    dy = y_bounded - y_current;
 80078b0:	6a3a      	ldr	r2, [r7, #32]
 80078b2:	697b      	ldr	r3, [r7, #20]
 80078b4:	1ad3      	subs	r3, r2, r3
 80078b6:	607b      	str	r3, [r7, #4]
    if(dx || dy) {
 80078b8:	68bb      	ldr	r3, [r7, #8]
 80078ba:	2b00      	cmp	r3, #0
 80078bc:	d102      	bne.n	80078c4 <lv_obj_scroll_by_bounded+0x12c>
 80078be:	687b      	ldr	r3, [r7, #4]
 80078c0:	2b00      	cmp	r3, #0
 80078c2:	d007      	beq.n	80078d4 <lv_obj_scroll_by_bounded+0x13c>
        lv_obj_scroll_by(obj, dx, dy, anim_en);
 80078c4:	78fb      	ldrb	r3, [r7, #3]
 80078c6:	687a      	ldr	r2, [r7, #4]
 80078c8:	68b9      	ldr	r1, [r7, #8]
 80078ca:	68f8      	ldr	r0, [r7, #12]
 80078cc:	f000 f806 	bl	80078dc <lv_obj_scroll_by>
 80078d0:	e000      	b.n	80078d4 <lv_obj_scroll_by_bounded+0x13c>
    if(dx == 0 && dy == 0) return;
 80078d2:	bf00      	nop
    }
}
 80078d4:	3734      	adds	r7, #52	@ 0x34
 80078d6:	46bd      	mov	sp, r7
 80078d8:	bd90      	pop	{r4, r7, pc}
	...

080078dc <lv_obj_scroll_by>:

void lv_obj_scroll_by(lv_obj_t * obj, int32_t dx, int32_t dy, lv_anim_enable_t anim_en)
{
 80078dc:	b580      	push	{r7, lr}
 80078de:	b0a2      	sub	sp, #136	@ 0x88
 80078e0:	af00      	add	r7, sp, #0
 80078e2:	60f8      	str	r0, [r7, #12]
 80078e4:	60b9      	str	r1, [r7, #8]
 80078e6:	607a      	str	r2, [r7, #4]
 80078e8:	70fb      	strb	r3, [r7, #3]
    if(dx == 0 && dy == 0) return;
 80078ea:	68bb      	ldr	r3, [r7, #8]
 80078ec:	2b00      	cmp	r3, #0
 80078ee:	d103      	bne.n	80078f8 <lv_obj_scroll_by+0x1c>
 80078f0:	687b      	ldr	r3, [r7, #4]
 80078f2:	2b00      	cmp	r3, #0
 80078f4:	f000 80cd 	beq.w	8007a92 <lv_obj_scroll_by+0x1b6>
    if(anim_en == LV_ANIM_ON) {
 80078f8:	78fb      	ldrb	r3, [r7, #3]
 80078fa:	2b01      	cmp	r3, #1
 80078fc:	f040 809d 	bne.w	8007a3a <lv_obj_scroll_by+0x15e>
        lv_display_t * d = lv_obj_get_display(obj);
 8007900:	68f8      	ldr	r0, [r7, #12]
 8007902:	f003 fa59 	bl	800adb8 <lv_obj_get_display>
 8007906:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
        lv_anim_t a;
        lv_anim_init(&a);
 800790a:	f107 0310 	add.w	r3, r7, #16
 800790e:	4618      	mov	r0, r3
 8007910:	f019 fb12 	bl	8020f38 <lv_anim_init>
        lv_anim_set_var(&a, obj);
 8007914:	f107 0310 	add.w	r3, r7, #16
 8007918:	68f9      	ldr	r1, [r7, #12]
 800791a:	4618      	mov	r0, r3
 800791c:	f7ff fb6a 	bl	8006ff4 <lv_anim_set_var>
        lv_anim_set_completed_cb(&a, scroll_completed_completed_cb);
 8007920:	f107 0310 	add.w	r3, r7, #16
 8007924:	4961      	ldr	r1, [pc, #388]	@ (8007aac <lv_obj_scroll_by+0x1d0>)
 8007926:	4618      	mov	r0, r3
 8007928:	f7ff fbb2 	bl	8007090 <lv_anim_set_completed_cb>

        if(dx) {
 800792c:	68bb      	ldr	r3, [r7, #8]
 800792e:	2b00      	cmp	r3, #0
 8007930:	d03f      	beq.n	80079b2 <lv_obj_scroll_by+0xd6>
            uint32_t t = lv_anim_speed_clamped((lv_display_get_horizontal_resolution(d)) >> 1, SCROLL_ANIM_TIME_MIN,
 8007932:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 8007936:	f003 fbf7 	bl	800b128 <lv_display_get_horizontal_resolution>
 800793a:	4603      	mov	r3, r0
 800793c:	105b      	asrs	r3, r3, #1
 800793e:	f44f 72c8 	mov.w	r2, #400	@ 0x190
 8007942:	21c8      	movs	r1, #200	@ 0xc8
 8007944:	4618      	mov	r0, r3
 8007946:	f019 fc0d 	bl	8021164 <lv_anim_speed_clamped>
 800794a:	67f8      	str	r0, [r7, #124]	@ 0x7c
                                               SCROLL_ANIM_TIME_MAX);
            lv_anim_set_duration(&a, t);
 800794c:	f107 0310 	add.w	r3, r7, #16
 8007950:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
 8007952:	4618      	mov	r0, r3
 8007954:	f7ff fb6a 	bl	800702c <lv_anim_set_duration>
            int32_t sx = lv_obj_get_scroll_x(obj);
 8007958:	68f8      	ldr	r0, [r7, #12]
 800795a:	f7ff fd6f 	bl	800743c <lv_obj_get_scroll_x>
 800795e:	67b8      	str	r0, [r7, #120]	@ 0x78
            lv_anim_set_values(&a, -sx, -sx + dx);
 8007960:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8007962:	4259      	negs	r1, r3
 8007964:	68ba      	ldr	r2, [r7, #8]
 8007966:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8007968:	1ad2      	subs	r2, r2, r3
 800796a:	f107 0310 	add.w	r3, r7, #16
 800796e:	4618      	mov	r0, r3
 8007970:	f7ff fb6a 	bl	8007048 <lv_anim_set_values>
            lv_anim_set_exec_cb(&a, scroll_x_anim);
 8007974:	f107 0310 	add.w	r3, r7, #16
 8007978:	494d      	ldr	r1, [pc, #308]	@ (8007ab0 <lv_obj_scroll_by+0x1d4>)
 800797a:	4618      	mov	r0, r3
 800797c:	f7ff fb48 	bl	8007010 <lv_anim_set_exec_cb>
            lv_anim_set_path_cb(&a, lv_anim_path_ease_out);
 8007980:	f107 0310 	add.w	r3, r7, #16
 8007984:	494b      	ldr	r1, [pc, #300]	@ (8007ab4 <lv_obj_scroll_by+0x1d8>)
 8007986:	4618      	mov	r0, r3
 8007988:	f7ff fb74 	bl	8007074 <lv_anim_set_path_cb>

            lv_result_t res;
            res = lv_obj_send_event(obj, LV_EVENT_SCROLL_BEGIN, &a);
 800798c:	f107 0310 	add.w	r3, r7, #16
 8007990:	461a      	mov	r2, r3
 8007992:	2109      	movs	r1, #9
 8007994:	68f8      	ldr	r0, [r7, #12]
 8007996:	f7fd fa3d 	bl	8004e14 <lv_obj_send_event>
 800799a:	4603      	mov	r3, r0
 800799c:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
            if(res != LV_RESULT_OK) return;
 80079a0:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 80079a4:	2b01      	cmp	r3, #1
 80079a6:	d176      	bne.n	8007a96 <lv_obj_scroll_by+0x1ba>
            lv_anim_start(&a);
 80079a8:	f107 0310 	add.w	r3, r7, #16
 80079ac:	4618      	mov	r0, r3
 80079ae:	f019 fae9 	bl	8020f84 <lv_anim_start>
        }

        if(dy) {
 80079b2:	687b      	ldr	r3, [r7, #4]
 80079b4:	2b00      	cmp	r3, #0
 80079b6:	d075      	beq.n	8007aa4 <lv_obj_scroll_by+0x1c8>
            uint32_t t = lv_anim_speed_clamped((lv_display_get_vertical_resolution(d)) >> 1, SCROLL_ANIM_TIME_MIN,
 80079b8:	f8d7 0080 	ldr.w	r0, [r7, #128]	@ 0x80
 80079bc:	f003 fbd6 	bl	800b16c <lv_display_get_vertical_resolution>
 80079c0:	4603      	mov	r3, r0
 80079c2:	105b      	asrs	r3, r3, #1
 80079c4:	f44f 72c8 	mov.w	r2, #400	@ 0x190
 80079c8:	21c8      	movs	r1, #200	@ 0xc8
 80079ca:	4618      	mov	r0, r3
 80079cc:	f019 fbca 	bl	8021164 <lv_anim_speed_clamped>
 80079d0:	6738      	str	r0, [r7, #112]	@ 0x70
                                               SCROLL_ANIM_TIME_MAX);
            lv_anim_set_duration(&a, t);
 80079d2:	f107 0310 	add.w	r3, r7, #16
 80079d6:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 80079d8:	4618      	mov	r0, r3
 80079da:	f7ff fb27 	bl	800702c <lv_anim_set_duration>
            int32_t sy = lv_obj_get_scroll_y(obj);
 80079de:	68f8      	ldr	r0, [r7, #12]
 80079e0:	f7ff fd40 	bl	8007464 <lv_obj_get_scroll_y>
 80079e4:	66f8      	str	r0, [r7, #108]	@ 0x6c
            lv_anim_set_values(&a, -sy, -sy + dy);
 80079e6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80079e8:	4259      	negs	r1, r3
 80079ea:	687a      	ldr	r2, [r7, #4]
 80079ec:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80079ee:	1ad2      	subs	r2, r2, r3
 80079f0:	f107 0310 	add.w	r3, r7, #16
 80079f4:	4618      	mov	r0, r3
 80079f6:	f7ff fb27 	bl	8007048 <lv_anim_set_values>
            lv_anim_set_exec_cb(&a,  scroll_y_anim);
 80079fa:	f107 0310 	add.w	r3, r7, #16
 80079fe:	492e      	ldr	r1, [pc, #184]	@ (8007ab8 <lv_obj_scroll_by+0x1dc>)
 8007a00:	4618      	mov	r0, r3
 8007a02:	f7ff fb05 	bl	8007010 <lv_anim_set_exec_cb>
            lv_anim_set_path_cb(&a, lv_anim_path_ease_out);
 8007a06:	f107 0310 	add.w	r3, r7, #16
 8007a0a:	492a      	ldr	r1, [pc, #168]	@ (8007ab4 <lv_obj_scroll_by+0x1d8>)
 8007a0c:	4618      	mov	r0, r3
 8007a0e:	f7ff fb31 	bl	8007074 <lv_anim_set_path_cb>

            lv_result_t res;
            res = lv_obj_send_event(obj, LV_EVENT_SCROLL_BEGIN, &a);
 8007a12:	f107 0310 	add.w	r3, r7, #16
 8007a16:	461a      	mov	r2, r3
 8007a18:	2109      	movs	r1, #9
 8007a1a:	68f8      	ldr	r0, [r7, #12]
 8007a1c:	f7fd f9fa 	bl	8004e14 <lv_obj_send_event>
 8007a20:	4603      	mov	r3, r0
 8007a22:	f887 306b 	strb.w	r3, [r7, #107]	@ 0x6b
            if(res != LV_RESULT_OK) return;
 8007a26:	f897 306b 	ldrb.w	r3, [r7, #107]	@ 0x6b
 8007a2a:	2b01      	cmp	r3, #1
 8007a2c:	d135      	bne.n	8007a9a <lv_obj_scroll_by+0x1be>
            lv_anim_start(&a);
 8007a2e:	f107 0310 	add.w	r3, r7, #16
 8007a32:	4618      	mov	r0, r3
 8007a34:	f019 faa6 	bl	8020f84 <lv_anim_start>
 8007a38:	e034      	b.n	8007aa4 <lv_obj_scroll_by+0x1c8>
        }
    }
    else {
        /*Remove pending animations*/
        lv_anim_delete(obj, scroll_y_anim);
 8007a3a:	491f      	ldr	r1, [pc, #124]	@ (8007ab8 <lv_obj_scroll_by+0x1dc>)
 8007a3c:	68f8      	ldr	r0, [r7, #12]
 8007a3e:	f019 fb1d 	bl	802107c <lv_anim_delete>
        lv_anim_delete(obj, scroll_x_anim);
 8007a42:	491b      	ldr	r1, [pc, #108]	@ (8007ab0 <lv_obj_scroll_by+0x1d4>)
 8007a44:	68f8      	ldr	r0, [r7, #12]
 8007a46:	f019 fb19 	bl	802107c <lv_anim_delete>

        lv_result_t res;
        res = lv_obj_send_event(obj, LV_EVENT_SCROLL_BEGIN, NULL);
 8007a4a:	2200      	movs	r2, #0
 8007a4c:	2109      	movs	r1, #9
 8007a4e:	68f8      	ldr	r0, [r7, #12]
 8007a50:	f7fd f9e0 	bl	8004e14 <lv_obj_send_event>
 8007a54:	4603      	mov	r3, r0
 8007a56:	f887 3087 	strb.w	r3, [r7, #135]	@ 0x87
        if(res != LV_RESULT_OK) return;
 8007a5a:	f897 3087 	ldrb.w	r3, [r7, #135]	@ 0x87
 8007a5e:	2b01      	cmp	r3, #1
 8007a60:	d11d      	bne.n	8007a9e <lv_obj_scroll_by+0x1c2>

        res = _lv_obj_scroll_by_raw(obj, dx, dy);
 8007a62:	687a      	ldr	r2, [r7, #4]
 8007a64:	68b9      	ldr	r1, [r7, #8]
 8007a66:	68f8      	ldr	r0, [r7, #12]
 8007a68:	f000 f893 	bl	8007b92 <_lv_obj_scroll_by_raw>
 8007a6c:	4603      	mov	r3, r0
 8007a6e:	f887 3087 	strb.w	r3, [r7, #135]	@ 0x87
        if(res != LV_RESULT_OK) return;
 8007a72:	f897 3087 	ldrb.w	r3, [r7, #135]	@ 0x87
 8007a76:	2b01      	cmp	r3, #1
 8007a78:	d113      	bne.n	8007aa2 <lv_obj_scroll_by+0x1c6>

        res = lv_obj_send_event(obj, LV_EVENT_SCROLL_END, NULL);
 8007a7a:	2200      	movs	r2, #0
 8007a7c:	210b      	movs	r1, #11
 8007a7e:	68f8      	ldr	r0, [r7, #12]
 8007a80:	f7fd f9c8 	bl	8004e14 <lv_obj_send_event>
 8007a84:	4603      	mov	r3, r0
 8007a86:	f887 3087 	strb.w	r3, [r7, #135]	@ 0x87
        if(res != LV_RESULT_OK) return;
 8007a8a:	f897 3087 	ldrb.w	r3, [r7, #135]	@ 0x87
 8007a8e:	2b01      	cmp	r3, #1
 8007a90:	e008      	b.n	8007aa4 <lv_obj_scroll_by+0x1c8>
    if(dx == 0 && dy == 0) return;
 8007a92:	bf00      	nop
 8007a94:	e006      	b.n	8007aa4 <lv_obj_scroll_by+0x1c8>
            if(res != LV_RESULT_OK) return;
 8007a96:	bf00      	nop
 8007a98:	e004      	b.n	8007aa4 <lv_obj_scroll_by+0x1c8>
            if(res != LV_RESULT_OK) return;
 8007a9a:	bf00      	nop
 8007a9c:	e002      	b.n	8007aa4 <lv_obj_scroll_by+0x1c8>
        if(res != LV_RESULT_OK) return;
 8007a9e:	bf00      	nop
 8007aa0:	e000      	b.n	8007aa4 <lv_obj_scroll_by+0x1c8>
        if(res != LV_RESULT_OK) return;
 8007aa2:	bf00      	nop
    }
}
 8007aa4:	3788      	adds	r7, #136	@ 0x88
 8007aa6:	46bd      	mov	sp, r7
 8007aa8:	bd80      	pop	{r7, pc}
 8007aaa:	bf00      	nop
 8007aac:	080086e5 	.word	0x080086e5
 8007ab0:	08008695 	.word	0x08008695
 8007ab4:	08021239 	.word	0x08021239
 8007ab8:	080086bd 	.word	0x080086bd

08007abc <lv_obj_scroll_to_x>:
    lv_obj_scroll_to_x(obj, x, anim_en);
    lv_obj_scroll_to_y(obj, y, anim_en);
}

void lv_obj_scroll_to_x(lv_obj_t * obj, int32_t x, lv_anim_enable_t anim_en)
{
 8007abc:	b580      	push	{r7, lr}
 8007abe:	b086      	sub	sp, #24
 8007ac0:	af00      	add	r7, sp, #0
 8007ac2:	60f8      	str	r0, [r7, #12]
 8007ac4:	60b9      	str	r1, [r7, #8]
 8007ac6:	4613      	mov	r3, r2
 8007ac8:	71fb      	strb	r3, [r7, #7]
    lv_anim_delete(obj, scroll_x_anim);
 8007aca:	490b      	ldr	r1, [pc, #44]	@ (8007af8 <lv_obj_scroll_to_x+0x3c>)
 8007acc:	68f8      	ldr	r0, [r7, #12]
 8007ace:	f019 fad5 	bl	802107c <lv_anim_delete>

    int32_t scroll_x = lv_obj_get_scroll_x(obj);
 8007ad2:	68f8      	ldr	r0, [r7, #12]
 8007ad4:	f7ff fcb2 	bl	800743c <lv_obj_get_scroll_x>
 8007ad8:	6178      	str	r0, [r7, #20]
    int32_t diff = -x + scroll_x;
 8007ada:	697a      	ldr	r2, [r7, #20]
 8007adc:	68bb      	ldr	r3, [r7, #8]
 8007ade:	1ad3      	subs	r3, r2, r3
 8007ae0:	613b      	str	r3, [r7, #16]

    lv_obj_scroll_by_bounded(obj, diff, 0, anim_en);
 8007ae2:	79fb      	ldrb	r3, [r7, #7]
 8007ae4:	2200      	movs	r2, #0
 8007ae6:	6939      	ldr	r1, [r7, #16]
 8007ae8:	68f8      	ldr	r0, [r7, #12]
 8007aea:	f7ff fe55 	bl	8007798 <lv_obj_scroll_by_bounded>
}
 8007aee:	bf00      	nop
 8007af0:	3718      	adds	r7, #24
 8007af2:	46bd      	mov	sp, r7
 8007af4:	bd80      	pop	{r7, pc}
 8007af6:	bf00      	nop
 8007af8:	08008695 	.word	0x08008695

08007afc <lv_obj_scroll_to_y>:

void lv_obj_scroll_to_y(lv_obj_t * obj, int32_t y, lv_anim_enable_t anim_en)
{
 8007afc:	b580      	push	{r7, lr}
 8007afe:	b086      	sub	sp, #24
 8007b00:	af00      	add	r7, sp, #0
 8007b02:	60f8      	str	r0, [r7, #12]
 8007b04:	60b9      	str	r1, [r7, #8]
 8007b06:	4613      	mov	r3, r2
 8007b08:	71fb      	strb	r3, [r7, #7]
    lv_anim_delete(obj, scroll_y_anim);
 8007b0a:	490b      	ldr	r1, [pc, #44]	@ (8007b38 <lv_obj_scroll_to_y+0x3c>)
 8007b0c:	68f8      	ldr	r0, [r7, #12]
 8007b0e:	f019 fab5 	bl	802107c <lv_anim_delete>

    int32_t scroll_y = lv_obj_get_scroll_y(obj);
 8007b12:	68f8      	ldr	r0, [r7, #12]
 8007b14:	f7ff fca6 	bl	8007464 <lv_obj_get_scroll_y>
 8007b18:	6178      	str	r0, [r7, #20]
    int32_t diff = -y + scroll_y;
 8007b1a:	697a      	ldr	r2, [r7, #20]
 8007b1c:	68bb      	ldr	r3, [r7, #8]
 8007b1e:	1ad3      	subs	r3, r2, r3
 8007b20:	613b      	str	r3, [r7, #16]

    lv_obj_scroll_by_bounded(obj, 0, diff, anim_en);
 8007b22:	79fb      	ldrb	r3, [r7, #7]
 8007b24:	693a      	ldr	r2, [r7, #16]
 8007b26:	2100      	movs	r1, #0
 8007b28:	68f8      	ldr	r0, [r7, #12]
 8007b2a:	f7ff fe35 	bl	8007798 <lv_obj_scroll_by_bounded>
}
 8007b2e:	bf00      	nop
 8007b30:	3718      	adds	r7, #24
 8007b32:	46bd      	mov	sp, r7
 8007b34:	bd80      	pop	{r7, pc}
 8007b36:	bf00      	nop
 8007b38:	080086bd 	.word	0x080086bd

08007b3c <lv_obj_scroll_to_view_recursive>:
    lv_point_t p = {0, 0};
    scroll_area_into_view(&obj->coords, obj, &p, anim_en);
}

void lv_obj_scroll_to_view_recursive(lv_obj_t * obj, lv_anim_enable_t anim_en)
{
 8007b3c:	b580      	push	{r7, lr}
 8007b3e:	b086      	sub	sp, #24
 8007b40:	af00      	add	r7, sp, #0
 8007b42:	6078      	str	r0, [r7, #4]
 8007b44:	460b      	mov	r3, r1
 8007b46:	70fb      	strb	r3, [r7, #3]
    /*Be sure the screens layout is correct*/
    lv_obj_update_layout(obj);
 8007b48:	6878      	ldr	r0, [r7, #4]
 8007b4a:	f7fe f89b 	bl	8005c84 <lv_obj_update_layout>

    lv_point_t p = {0, 0};
 8007b4e:	2300      	movs	r3, #0
 8007b50:	60bb      	str	r3, [r7, #8]
 8007b52:	2300      	movs	r3, #0
 8007b54:	60fb      	str	r3, [r7, #12]
    lv_obj_t * child = obj;
 8007b56:	687b      	ldr	r3, [r7, #4]
 8007b58:	617b      	str	r3, [r7, #20]
    lv_obj_t * parent = lv_obj_get_parent(child);
 8007b5a:	6978      	ldr	r0, [r7, #20]
 8007b5c:	f003 f96a 	bl	800ae34 <lv_obj_get_parent>
 8007b60:	6138      	str	r0, [r7, #16]
    while(parent) {
 8007b62:	e00e      	b.n	8007b82 <lv_obj_scroll_to_view_recursive+0x46>
        scroll_area_into_view(&obj->coords, child, &p, anim_en);
 8007b64:	687b      	ldr	r3, [r7, #4]
 8007b66:	f103 0014 	add.w	r0, r3, #20
 8007b6a:	78fb      	ldrb	r3, [r7, #3]
 8007b6c:	f107 0208 	add.w	r2, r7, #8
 8007b70:	6979      	ldr	r1, [r7, #20]
 8007b72:	f000 fdc7 	bl	8008704 <scroll_area_into_view>
        child = parent;
 8007b76:	693b      	ldr	r3, [r7, #16]
 8007b78:	617b      	str	r3, [r7, #20]
        parent = lv_obj_get_parent(parent);
 8007b7a:	6938      	ldr	r0, [r7, #16]
 8007b7c:	f003 f95a 	bl	800ae34 <lv_obj_get_parent>
 8007b80:	6138      	str	r0, [r7, #16]
    while(parent) {
 8007b82:	693b      	ldr	r3, [r7, #16]
 8007b84:	2b00      	cmp	r3, #0
 8007b86:	d1ed      	bne.n	8007b64 <lv_obj_scroll_to_view_recursive+0x28>
    }
}
 8007b88:	bf00      	nop
 8007b8a:	bf00      	nop
 8007b8c:	3718      	adds	r7, #24
 8007b8e:	46bd      	mov	sp, r7
 8007b90:	bd80      	pop	{r7, pc}

08007b92 <_lv_obj_scroll_by_raw>:

lv_result_t _lv_obj_scroll_by_raw(lv_obj_t * obj, int32_t x, int32_t y)
{
 8007b92:	b580      	push	{r7, lr}
 8007b94:	b086      	sub	sp, #24
 8007b96:	af00      	add	r7, sp, #0
 8007b98:	60f8      	str	r0, [r7, #12]
 8007b9a:	60b9      	str	r1, [r7, #8]
 8007b9c:	607a      	str	r2, [r7, #4]
    if(x == 0 && y == 0) return LV_RESULT_OK;
 8007b9e:	68bb      	ldr	r3, [r7, #8]
 8007ba0:	2b00      	cmp	r3, #0
 8007ba2:	d104      	bne.n	8007bae <_lv_obj_scroll_by_raw+0x1c>
 8007ba4:	687b      	ldr	r3, [r7, #4]
 8007ba6:	2b00      	cmp	r3, #0
 8007ba8:	d101      	bne.n	8007bae <_lv_obj_scroll_by_raw+0x1c>
 8007baa:	2301      	movs	r3, #1
 8007bac:	e028      	b.n	8007c00 <_lv_obj_scroll_by_raw+0x6e>

    lv_obj_allocate_spec_attr(obj);
 8007bae:	68f8      	ldr	r0, [r7, #12]
 8007bb0:	f7fb f915 	bl	8002dde <lv_obj_allocate_spec_attr>

    obj->spec_attr->scroll.x += x;
 8007bb4:	68fb      	ldr	r3, [r7, #12]
 8007bb6:	689b      	ldr	r3, [r3, #8]
 8007bb8:	6999      	ldr	r1, [r3, #24]
 8007bba:	68fb      	ldr	r3, [r7, #12]
 8007bbc:	689b      	ldr	r3, [r3, #8]
 8007bbe:	68ba      	ldr	r2, [r7, #8]
 8007bc0:	440a      	add	r2, r1
 8007bc2:	619a      	str	r2, [r3, #24]
    obj->spec_attr->scroll.y += y;
 8007bc4:	68fb      	ldr	r3, [r7, #12]
 8007bc6:	689b      	ldr	r3, [r3, #8]
 8007bc8:	69d9      	ldr	r1, [r3, #28]
 8007bca:	68fb      	ldr	r3, [r7, #12]
 8007bcc:	689b      	ldr	r3, [r3, #8]
 8007bce:	687a      	ldr	r2, [r7, #4]
 8007bd0:	440a      	add	r2, r1
 8007bd2:	61da      	str	r2, [r3, #28]

    lv_obj_move_children_by(obj, x, y, true);
 8007bd4:	2301      	movs	r3, #1
 8007bd6:	687a      	ldr	r2, [r7, #4]
 8007bd8:	68b9      	ldr	r1, [r7, #8]
 8007bda:	68f8      	ldr	r0, [r7, #12]
 8007bdc:	f7fe fbdd 	bl	800639a <lv_obj_move_children_by>
    lv_result_t res = lv_obj_send_event(obj, LV_EVENT_SCROLL, NULL);
 8007be0:	2200      	movs	r2, #0
 8007be2:	210c      	movs	r1, #12
 8007be4:	68f8      	ldr	r0, [r7, #12]
 8007be6:	f7fd f915 	bl	8004e14 <lv_obj_send_event>
 8007bea:	4603      	mov	r3, r0
 8007bec:	75fb      	strb	r3, [r7, #23]
    if(res != LV_RESULT_OK) return res;
 8007bee:	7dfb      	ldrb	r3, [r7, #23]
 8007bf0:	2b01      	cmp	r3, #1
 8007bf2:	d001      	beq.n	8007bf8 <_lv_obj_scroll_by_raw+0x66>
 8007bf4:	7dfb      	ldrb	r3, [r7, #23]
 8007bf6:	e003      	b.n	8007c00 <_lv_obj_scroll_by_raw+0x6e>
    lv_obj_invalidate(obj);
 8007bf8:	68f8      	ldr	r0, [r7, #12]
 8007bfa:	f7fe fd21 	bl	8006640 <lv_obj_invalidate>
    return LV_RESULT_OK;
 8007bfe:	2301      	movs	r3, #1
}
 8007c00:	4618      	mov	r0, r3
 8007c02:	3718      	adds	r7, #24
 8007c04:	46bd      	mov	sp, r7
 8007c06:	bd80      	pop	{r7, pc}

08007c08 <lv_obj_get_scrollbar_area>:
    lv_indev_scroll_get_snap_dist(obj, &p);
    lv_obj_scroll_by(obj, p.x, p.y, anim_en);
}

void lv_obj_get_scrollbar_area(lv_obj_t * obj, lv_area_t * hor_area, lv_area_t * ver_area)
{
 8007c08:	b590      	push	{r4, r7, lr}
 8007c0a:	b0a1      	sub	sp, #132	@ 0x84
 8007c0c:	af02      	add	r7, sp, #8
 8007c0e:	60f8      	str	r0, [r7, #12]
 8007c10:	60b9      	str	r1, [r7, #8]
 8007c12:	607a      	str	r2, [r7, #4]
    lv_area_set(hor_area, 0, 0, -1, -1);
 8007c14:	f04f 33ff 	mov.w	r3, #4294967295
 8007c18:	9300      	str	r3, [sp, #0]
 8007c1a:	f04f 33ff 	mov.w	r3, #4294967295
 8007c1e:	2200      	movs	r2, #0
 8007c20:	2100      	movs	r1, #0
 8007c22:	68b8      	ldr	r0, [r7, #8]
 8007c24:	f019 fdf0 	bl	8021808 <lv_area_set>
    lv_area_set(ver_area, 0, 0, -1, -1);
 8007c28:	f04f 33ff 	mov.w	r3, #4294967295
 8007c2c:	9300      	str	r3, [sp, #0]
 8007c2e:	f04f 33ff 	mov.w	r3, #4294967295
 8007c32:	2200      	movs	r2, #0
 8007c34:	2100      	movs	r1, #0
 8007c36:	6878      	ldr	r0, [r7, #4]
 8007c38:	f019 fde6 	bl	8021808 <lv_area_set>

    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_SCROLLABLE) == false) return;
 8007c3c:	2110      	movs	r1, #16
 8007c3e:	68f8      	ldr	r0, [r7, #12]
 8007c40:	f7fb f885 	bl	8002d4e <lv_obj_has_flag>
 8007c44:	4603      	mov	r3, r0
 8007c46:	f083 0301 	eor.w	r3, r3, #1
 8007c4a:	b2db      	uxtb	r3, r3
 8007c4c:	2b00      	cmp	r3, #0
 8007c4e:	f040 846e 	bne.w	800852e <lv_obj_get_scrollbar_area+0x926>

    lv_dir_t sm = lv_obj_get_scrollbar_mode(obj);
 8007c52:	68f8      	ldr	r0, [r7, #12]
 8007c54:	f7ff fb97 	bl	8007386 <lv_obj_get_scrollbar_mode>
 8007c58:	4603      	mov	r3, r0
 8007c5a:	f887 3071 	strb.w	r3, [r7, #113]	@ 0x71
    if(sm == LV_SCROLLBAR_MODE_OFF)  return;
 8007c5e:	f897 3071 	ldrb.w	r3, [r7, #113]	@ 0x71
 8007c62:	2b00      	cmp	r3, #0
 8007c64:	f000 8465 	beq.w	8008532 <lv_obj_get_scrollbar_area+0x92a>

    /*If there is no indev scrolling this object but `mode==active` return*/
    lv_indev_t * indev = lv_indev_get_next(NULL);
 8007c68:	2000      	movs	r0, #0
 8007c6a:	f015 f8a7 	bl	801cdbc <lv_indev_get_next>
 8007c6e:	6778      	str	r0, [r7, #116]	@ 0x74
    if(sm == LV_SCROLLBAR_MODE_ACTIVE) {
 8007c70:	f897 3071 	ldrb.w	r3, [r7, #113]	@ 0x71
 8007c74:	2b02      	cmp	r3, #2
 8007c76:	d114      	bne.n	8007ca2 <lv_obj_get_scrollbar_area+0x9a>
        while(indev) {
 8007c78:	e00a      	b.n	8007c90 <lv_obj_get_scrollbar_area+0x88>
            if(lv_indev_get_scroll_obj(indev) == obj) break;
 8007c7a:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8007c7c:	f015 f92b 	bl	801ced6 <lv_indev_get_scroll_obj>
 8007c80:	4602      	mov	r2, r0
 8007c82:	68fb      	ldr	r3, [r7, #12]
 8007c84:	4293      	cmp	r3, r2
 8007c86:	d007      	beq.n	8007c98 <lv_obj_get_scrollbar_area+0x90>
            indev = lv_indev_get_next(indev);
 8007c88:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8007c8a:	f015 f897 	bl	801cdbc <lv_indev_get_next>
 8007c8e:	6778      	str	r0, [r7, #116]	@ 0x74
        while(indev) {
 8007c90:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8007c92:	2b00      	cmp	r3, #0
 8007c94:	d1f1      	bne.n	8007c7a <lv_obj_get_scrollbar_area+0x72>
 8007c96:	e000      	b.n	8007c9a <lv_obj_get_scrollbar_area+0x92>
            if(lv_indev_get_scroll_obj(indev) == obj) break;
 8007c98:	bf00      	nop
        }
        if(indev == NULL)  return;
 8007c9a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8007c9c:	2b00      	cmp	r3, #0
 8007c9e:	f000 844a 	beq.w	8008536 <lv_obj_get_scrollbar_area+0x92e>
    }

    int32_t st = lv_obj_get_scroll_top(obj);
 8007ca2:	68f8      	ldr	r0, [r7, #12]
 8007ca4:	f7ff fbf2 	bl	800748c <lv_obj_get_scroll_top>
 8007ca8:	66f8      	str	r0, [r7, #108]	@ 0x6c
    int32_t sb = lv_obj_get_scroll_bottom(obj);
 8007caa:	68f8      	ldr	r0, [r7, #12]
 8007cac:	f7ff fc02 	bl	80074b4 <lv_obj_get_scroll_bottom>
 8007cb0:	66b8      	str	r0, [r7, #104]	@ 0x68
    int32_t sl = lv_obj_get_scroll_left(obj);
 8007cb2:	68f8      	ldr	r0, [r7, #12]
 8007cb4:	f7ff fc6a 	bl	800758c <lv_obj_get_scroll_left>
 8007cb8:	6678      	str	r0, [r7, #100]	@ 0x64
    int32_t sr = lv_obj_get_scroll_right(obj);
 8007cba:	68f8      	ldr	r0, [r7, #12]
 8007cbc:	f7ff fcee 	bl	800769c <lv_obj_get_scroll_right>
 8007cc0:	6638      	str	r0, [r7, #96]	@ 0x60

    lv_dir_t dir = lv_obj_get_scroll_dir(obj);
 8007cc2:	68f8      	ldr	r0, [r7, #12]
 8007cc4:	f7ff fb76 	bl	80073b4 <lv_obj_get_scroll_dir>
 8007cc8:	4603      	mov	r3, r0
 8007cca:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f

    bool ver_draw = false;
 8007cce:	2300      	movs	r3, #0
 8007cd0:	f887 3073 	strb.w	r3, [r7, #115]	@ 0x73
    if((dir & LV_DIR_VER) &&
 8007cd4:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 8007cd8:	f003 030c 	and.w	r3, r3, #12
 8007cdc:	2b00      	cmp	r3, #0
 8007cde:	d01a      	beq.n	8007d16 <lv_obj_get_scrollbar_area+0x10e>
 8007ce0:	f897 3071 	ldrb.w	r3, [r7, #113]	@ 0x71
 8007ce4:	2b01      	cmp	r3, #1
 8007ce6:	d013      	beq.n	8007d10 <lv_obj_get_scrollbar_area+0x108>
       ((sm == LV_SCROLLBAR_MODE_ON) ||
 8007ce8:	f897 3071 	ldrb.w	r3, [r7, #113]	@ 0x71
 8007cec:	2b03      	cmp	r3, #3
 8007cee:	d105      	bne.n	8007cfc <lv_obj_get_scrollbar_area+0xf4>
        (sm == LV_SCROLLBAR_MODE_AUTO && (st > 0 || sb > 0)) ||
 8007cf0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8007cf2:	2b00      	cmp	r3, #0
 8007cf4:	dc0c      	bgt.n	8007d10 <lv_obj_get_scrollbar_area+0x108>
 8007cf6:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8007cf8:	2b00      	cmp	r3, #0
 8007cfa:	dc09      	bgt.n	8007d10 <lv_obj_get_scrollbar_area+0x108>
 8007cfc:	f897 3071 	ldrb.w	r3, [r7, #113]	@ 0x71
 8007d00:	2b02      	cmp	r3, #2
 8007d02:	d108      	bne.n	8007d16 <lv_obj_get_scrollbar_area+0x10e>
        (sm == LV_SCROLLBAR_MODE_ACTIVE && lv_indev_get_scroll_dir(indev) == LV_DIR_VER))) {
 8007d04:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8007d06:	f015 f8c7 	bl	801ce98 <lv_indev_get_scroll_dir>
 8007d0a:	4603      	mov	r3, r0
 8007d0c:	2b0c      	cmp	r3, #12
 8007d0e:	d102      	bne.n	8007d16 <lv_obj_get_scrollbar_area+0x10e>
        ver_draw = true;
 8007d10:	2301      	movs	r3, #1
 8007d12:	f887 3073 	strb.w	r3, [r7, #115]	@ 0x73
    }

    bool hor_draw = false;
 8007d16:	2300      	movs	r3, #0
 8007d18:	f887 3072 	strb.w	r3, [r7, #114]	@ 0x72
    if((dir & LV_DIR_HOR) &&
 8007d1c:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 8007d20:	f003 0303 	and.w	r3, r3, #3
 8007d24:	2b00      	cmp	r3, #0
 8007d26:	d01a      	beq.n	8007d5e <lv_obj_get_scrollbar_area+0x156>
 8007d28:	f897 3071 	ldrb.w	r3, [r7, #113]	@ 0x71
 8007d2c:	2b01      	cmp	r3, #1
 8007d2e:	d013      	beq.n	8007d58 <lv_obj_get_scrollbar_area+0x150>
       ((sm == LV_SCROLLBAR_MODE_ON) ||
 8007d30:	f897 3071 	ldrb.w	r3, [r7, #113]	@ 0x71
 8007d34:	2b03      	cmp	r3, #3
 8007d36:	d105      	bne.n	8007d44 <lv_obj_get_scrollbar_area+0x13c>
        (sm == LV_SCROLLBAR_MODE_AUTO && (sl > 0 || sr > 0)) ||
 8007d38:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8007d3a:	2b00      	cmp	r3, #0
 8007d3c:	dc0c      	bgt.n	8007d58 <lv_obj_get_scrollbar_area+0x150>
 8007d3e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8007d40:	2b00      	cmp	r3, #0
 8007d42:	dc09      	bgt.n	8007d58 <lv_obj_get_scrollbar_area+0x150>
 8007d44:	f897 3071 	ldrb.w	r3, [r7, #113]	@ 0x71
 8007d48:	2b02      	cmp	r3, #2
 8007d4a:	d108      	bne.n	8007d5e <lv_obj_get_scrollbar_area+0x156>
        (sm == LV_SCROLLBAR_MODE_ACTIVE && lv_indev_get_scroll_dir(indev) == LV_DIR_HOR))) {
 8007d4c:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 8007d4e:	f015 f8a3 	bl	801ce98 <lv_indev_get_scroll_dir>
 8007d52:	4603      	mov	r3, r0
 8007d54:	2b03      	cmp	r3, #3
 8007d56:	d102      	bne.n	8007d5e <lv_obj_get_scrollbar_area+0x156>
        hor_draw = true;
 8007d58:	2301      	movs	r3, #1
 8007d5a:	f887 3072 	strb.w	r3, [r7, #114]	@ 0x72
    }

    if(!hor_draw && !ver_draw) return;
 8007d5e:	f897 3072 	ldrb.w	r3, [r7, #114]	@ 0x72
 8007d62:	f083 0301 	eor.w	r3, r3, #1
 8007d66:	b2db      	uxtb	r3, r3
 8007d68:	2b00      	cmp	r3, #0
 8007d6a:	d007      	beq.n	8007d7c <lv_obj_get_scrollbar_area+0x174>
 8007d6c:	f897 3073 	ldrb.w	r3, [r7, #115]	@ 0x73
 8007d70:	f083 0301 	eor.w	r3, r3, #1
 8007d74:	b2db      	uxtb	r3, r3
 8007d76:	2b00      	cmp	r3, #0
 8007d78:	f040 83df 	bne.w	800853a <lv_obj_get_scrollbar_area+0x932>

    bool rtl = lv_obj_get_style_base_dir(obj, LV_PART_SCROLLBAR) == LV_BASE_DIR_RTL;
 8007d7c:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8007d80:	68f8      	ldr	r0, [r7, #12]
 8007d82:	f7ff fa62 	bl	800724a <lv_obj_get_style_base_dir>
 8007d86:	4603      	mov	r3, r0
 8007d88:	2b01      	cmp	r3, #1
 8007d8a:	bf0c      	ite	eq
 8007d8c:	2301      	moveq	r3, #1
 8007d8e:	2300      	movne	r3, #0
 8007d90:	f887 305e 	strb.w	r3, [r7, #94]	@ 0x5e

    int32_t top_space = lv_obj_get_style_pad_top(obj, LV_PART_SCROLLBAR);
 8007d94:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8007d98:	68f8      	ldr	r0, [r7, #12]
 8007d9a:	f7ff f998 	bl	80070ce <lv_obj_get_style_pad_top>
 8007d9e:	65b8      	str	r0, [r7, #88]	@ 0x58
    int32_t bottom_space = lv_obj_get_style_pad_bottom(obj, LV_PART_SCROLLBAR);
 8007da0:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8007da4:	68f8      	ldr	r0, [r7, #12]
 8007da6:	f7ff f9a3 	bl	80070f0 <lv_obj_get_style_pad_bottom>
 8007daa:	6578      	str	r0, [r7, #84]	@ 0x54
    int32_t left_space = lv_obj_get_style_pad_left(obj, LV_PART_SCROLLBAR);
 8007dac:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8007db0:	68f8      	ldr	r0, [r7, #12]
 8007db2:	f7ff f9ae 	bl	8007112 <lv_obj_get_style_pad_left>
 8007db6:	6538      	str	r0, [r7, #80]	@ 0x50
    int32_t right_space = lv_obj_get_style_pad_right(obj, LV_PART_SCROLLBAR);
 8007db8:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8007dbc:	68f8      	ldr	r0, [r7, #12]
 8007dbe:	f7ff f9b9 	bl	8007134 <lv_obj_get_style_pad_right>
 8007dc2:	64f8      	str	r0, [r7, #76]	@ 0x4c
    int32_t thickness = lv_obj_get_style_width(obj, LV_PART_SCROLLBAR);
 8007dc4:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8007dc8:	68f8      	ldr	r0, [r7, #12]
 8007dca:	f7ff f96f 	bl	80070ac <lv_obj_get_style_width>
 8007dce:	64b8      	str	r0, [r7, #72]	@ 0x48

    int32_t obj_h = lv_obj_get_height(obj);
 8007dd0:	68f8      	ldr	r0, [r7, #12]
 8007dd2:	f7fd ffbb 	bl	8005d4c <lv_obj_get_height>
 8007dd6:	6478      	str	r0, [r7, #68]	@ 0x44
    int32_t obj_w = lv_obj_get_width(obj);
 8007dd8:	68f8      	ldr	r0, [r7, #12]
 8007dda:	f7fd ffa9 	bl	8005d30 <lv_obj_get_width>
 8007dde:	6438      	str	r0, [r7, #64]	@ 0x40

    /*Space required for the vertical and horizontal scrollbars*/
    int32_t ver_reg_space = ver_draw ? thickness : 0;
 8007de0:	f897 3073 	ldrb.w	r3, [r7, #115]	@ 0x73
 8007de4:	2b00      	cmp	r3, #0
 8007de6:	d001      	beq.n	8007dec <lv_obj_get_scrollbar_area+0x1e4>
 8007de8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8007dea:	e000      	b.n	8007dee <lv_obj_get_scrollbar_area+0x1e6>
 8007dec:	2300      	movs	r3, #0
 8007dee:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int32_t hor_req_space = hor_draw ? thickness : 0;
 8007df0:	f897 3072 	ldrb.w	r3, [r7, #114]	@ 0x72
 8007df4:	2b00      	cmp	r3, #0
 8007df6:	d001      	beq.n	8007dfc <lv_obj_get_scrollbar_area+0x1f4>
 8007df8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8007dfa:	e000      	b.n	8007dfe <lv_obj_get_scrollbar_area+0x1f6>
 8007dfc:	2300      	movs	r3, #0
 8007dfe:	63bb      	str	r3, [r7, #56]	@ 0x38
    int32_t rem;

    if(lv_obj_get_style_bg_opa(obj, LV_PART_SCROLLBAR) < LV_OPA_MIN &&
 8007e00:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8007e04:	68f8      	ldr	r0, [r7, #12]
 8007e06:	f7ff f9d9 	bl	80071bc <lv_obj_get_style_bg_opa>
 8007e0a:	4603      	mov	r3, r0
 8007e0c:	2b01      	cmp	r3, #1
 8007e0e:	d808      	bhi.n	8007e22 <lv_obj_get_scrollbar_area+0x21a>
       lv_obj_get_style_border_opa(obj, LV_PART_SCROLLBAR) < LV_OPA_MIN) {
 8007e10:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8007e14:	68f8      	ldr	r0, [r7, #12]
 8007e16:	f7ff f9e3 	bl	80071e0 <lv_obj_get_style_border_opa>
 8007e1a:	4603      	mov	r3, r0
    if(lv_obj_get_style_bg_opa(obj, LV_PART_SCROLLBAR) < LV_OPA_MIN &&
 8007e1c:	2b01      	cmp	r3, #1
 8007e1e:	f240 838e 	bls.w	800853e <lv_obj_get_scrollbar_area+0x936>
        return;
    }

    /*Draw vertical scrollbar if the mode is ON or can be scrolled in this direction*/
    int32_t content_h = obj_h + st + sb;
 8007e22:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8007e24:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8007e26:	4413      	add	r3, r2
 8007e28:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8007e2a:	4413      	add	r3, r2
 8007e2c:	637b      	str	r3, [r7, #52]	@ 0x34
    if(ver_draw && content_h) {
 8007e2e:	f897 3073 	ldrb.w	r3, [r7, #115]	@ 0x73
 8007e32:	2b00      	cmp	r3, #0
 8007e34:	f000 8155 	beq.w	80080e2 <lv_obj_get_scrollbar_area+0x4da>
 8007e38:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8007e3a:	2b00      	cmp	r3, #0
 8007e3c:	f000 8151 	beq.w	80080e2 <lv_obj_get_scrollbar_area+0x4da>
        ver_area->y1 = obj->coords.y1;
 8007e40:	68fb      	ldr	r3, [r7, #12]
 8007e42:	699a      	ldr	r2, [r3, #24]
 8007e44:	687b      	ldr	r3, [r7, #4]
 8007e46:	605a      	str	r2, [r3, #4]
        ver_area->y2 = obj->coords.y2;
 8007e48:	68fb      	ldr	r3, [r7, #12]
 8007e4a:	6a1a      	ldr	r2, [r3, #32]
 8007e4c:	687b      	ldr	r3, [r7, #4]
 8007e4e:	60da      	str	r2, [r3, #12]
        if(rtl) {
 8007e50:	f897 305e 	ldrb.w	r3, [r7, #94]	@ 0x5e
 8007e54:	2b00      	cmp	r3, #0
 8007e56:	d00d      	beq.n	8007e74 <lv_obj_get_scrollbar_area+0x26c>
            ver_area->x1 = obj->coords.x1 + left_space;
 8007e58:	68fb      	ldr	r3, [r7, #12]
 8007e5a:	695a      	ldr	r2, [r3, #20]
 8007e5c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8007e5e:	441a      	add	r2, r3
 8007e60:	687b      	ldr	r3, [r7, #4]
 8007e62:	601a      	str	r2, [r3, #0]
            ver_area->x2 = ver_area->x1 + thickness - 1;
 8007e64:	687b      	ldr	r3, [r7, #4]
 8007e66:	681a      	ldr	r2, [r3, #0]
 8007e68:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8007e6a:	4413      	add	r3, r2
 8007e6c:	1e5a      	subs	r2, r3, #1
 8007e6e:	687b      	ldr	r3, [r7, #4]
 8007e70:	609a      	str	r2, [r3, #8]
 8007e72:	e00c      	b.n	8007e8e <lv_obj_get_scrollbar_area+0x286>
        }
        else {
            ver_area->x2 = obj->coords.x2 - right_space;
 8007e74:	68fb      	ldr	r3, [r7, #12]
 8007e76:	69da      	ldr	r2, [r3, #28]
 8007e78:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8007e7a:	1ad2      	subs	r2, r2, r3
 8007e7c:	687b      	ldr	r3, [r7, #4]
 8007e7e:	609a      	str	r2, [r3, #8]
            ver_area->x1 = ver_area->x2 - thickness + 1;
 8007e80:	687b      	ldr	r3, [r7, #4]
 8007e82:	689a      	ldr	r2, [r3, #8]
 8007e84:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8007e86:	1ad3      	subs	r3, r2, r3
 8007e88:	1c5a      	adds	r2, r3, #1
 8007e8a:	687b      	ldr	r3, [r7, #4]
 8007e8c:	601a      	str	r2, [r3, #0]
        }

        int32_t sb_h = ((obj_h - top_space - bottom_space - hor_req_space) * obj_h) / content_h;
 8007e8e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8007e90:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8007e92:	1ad2      	subs	r2, r2, r3
 8007e94:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8007e96:	1ad2      	subs	r2, r2, r3
 8007e98:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8007e9a:	1ad3      	subs	r3, r2, r3
 8007e9c:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8007e9e:	fb03 f202 	mul.w	r2, r3, r2
 8007ea2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8007ea4:	fb92 f3f3 	sdiv	r3, r2, r3
 8007ea8:	633b      	str	r3, [r7, #48]	@ 0x30
        sb_h = LV_MAX(sb_h, SCROLLBAR_MIN_SIZE);
 8007eaa:	2000      	movs	r0, #0
 8007eac:	f003 f980 	bl	800b1b0 <lv_display_get_dpi>
 8007eb0:	4602      	mov	r2, r0
 8007eb2:	4613      	mov	r3, r2
 8007eb4:	009b      	lsls	r3, r3, #2
 8007eb6:	4413      	add	r3, r2
 8007eb8:	005b      	lsls	r3, r3, #1
 8007eba:	2bef      	cmp	r3, #239	@ 0xef
 8007ebc:	dd0f      	ble.n	8007ede <lv_obj_get_scrollbar_area+0x2d6>
 8007ebe:	2000      	movs	r0, #0
 8007ec0:	f003 f976 	bl	800b1b0 <lv_display_get_dpi>
 8007ec4:	4602      	mov	r2, r0
 8007ec6:	4613      	mov	r3, r2
 8007ec8:	009b      	lsls	r3, r3, #2
 8007eca:	4413      	add	r3, r2
 8007ecc:	005b      	lsls	r3, r3, #1
 8007ece:	3350      	adds	r3, #80	@ 0x50
 8007ed0:	4aaa      	ldr	r2, [pc, #680]	@ (800817c <lv_obj_get_scrollbar_area+0x574>)
 8007ed2:	fb82 1203 	smull	r1, r2, r2, r3
 8007ed6:	1192      	asrs	r2, r2, #6
 8007ed8:	17db      	asrs	r3, r3, #31
 8007eda:	1ad3      	subs	r3, r2, r3
 8007edc:	e000      	b.n	8007ee0 <lv_obj_get_scrollbar_area+0x2d8>
 8007ede:	2301      	movs	r3, #1
 8007ee0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8007ee2:	4293      	cmp	r3, r2
 8007ee4:	db1b      	blt.n	8007f1e <lv_obj_get_scrollbar_area+0x316>
 8007ee6:	2000      	movs	r0, #0
 8007ee8:	f003 f962 	bl	800b1b0 <lv_display_get_dpi>
 8007eec:	4602      	mov	r2, r0
 8007eee:	4613      	mov	r3, r2
 8007ef0:	009b      	lsls	r3, r3, #2
 8007ef2:	4413      	add	r3, r2
 8007ef4:	005b      	lsls	r3, r3, #1
 8007ef6:	2bef      	cmp	r3, #239	@ 0xef
 8007ef8:	dd0f      	ble.n	8007f1a <lv_obj_get_scrollbar_area+0x312>
 8007efa:	2000      	movs	r0, #0
 8007efc:	f003 f958 	bl	800b1b0 <lv_display_get_dpi>
 8007f00:	4602      	mov	r2, r0
 8007f02:	4613      	mov	r3, r2
 8007f04:	009b      	lsls	r3, r3, #2
 8007f06:	4413      	add	r3, r2
 8007f08:	005b      	lsls	r3, r3, #1
 8007f0a:	3350      	adds	r3, #80	@ 0x50
 8007f0c:	4a9b      	ldr	r2, [pc, #620]	@ (800817c <lv_obj_get_scrollbar_area+0x574>)
 8007f0e:	fb82 1203 	smull	r1, r2, r2, r3
 8007f12:	1192      	asrs	r2, r2, #6
 8007f14:	17db      	asrs	r3, r3, #31
 8007f16:	1ad3      	subs	r3, r2, r3
 8007f18:	e002      	b.n	8007f20 <lv_obj_get_scrollbar_area+0x318>
 8007f1a:	2301      	movs	r3, #1
 8007f1c:	e000      	b.n	8007f20 <lv_obj_get_scrollbar_area+0x318>
 8007f1e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8007f20:	633b      	str	r3, [r7, #48]	@ 0x30
        rem = (obj_h - top_space - bottom_space - hor_req_space) -
 8007f22:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8007f24:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8007f26:	1ad2      	subs	r2, r2, r3
 8007f28:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8007f2a:	1ad2      	subs	r2, r2, r3
 8007f2c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8007f2e:	1ad2      	subs	r2, r2, r3
 8007f30:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8007f32:	1ad3      	subs	r3, r2, r3
 8007f34:	62fb      	str	r3, [r7, #44]	@ 0x2c
              sb_h;  /*Remaining size from the scrollbar track that is not the scrollbar itself*/
        int32_t scroll_h = content_h - obj_h; /*The size of the content which can be really scrolled*/
 8007f36:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8007f38:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8007f3a:	1ad3      	subs	r3, r2, r3
 8007f3c:	62bb      	str	r3, [r7, #40]	@ 0x28
        if(scroll_h <= 0) {
 8007f3e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007f40:	2b00      	cmp	r3, #0
 8007f42:	dc0f      	bgt.n	8007f64 <lv_obj_get_scrollbar_area+0x35c>
            ver_area->y1 = obj->coords.y1 + top_space;
 8007f44:	68fb      	ldr	r3, [r7, #12]
 8007f46:	699a      	ldr	r2, [r3, #24]
 8007f48:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8007f4a:	441a      	add	r2, r3
 8007f4c:	687b      	ldr	r3, [r7, #4]
 8007f4e:	605a      	str	r2, [r3, #4]
            ver_area->y2 = obj->coords.y2 - bottom_space - hor_req_space - 1;
 8007f50:	68fb      	ldr	r3, [r7, #12]
 8007f52:	6a1a      	ldr	r2, [r3, #32]
 8007f54:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8007f56:	1ad2      	subs	r2, r2, r3
 8007f58:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8007f5a:	1ad3      	subs	r3, r2, r3
 8007f5c:	1e5a      	subs	r2, r3, #1
 8007f5e:	687b      	ldr	r3, [r7, #4]
 8007f60:	60da      	str	r2, [r3, #12]
 8007f62:	e0be      	b.n	80080e2 <lv_obj_get_scrollbar_area+0x4da>
        }
        else {
            int32_t sb_y = (rem * sb) / scroll_h;
 8007f64:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007f66:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8007f68:	fb03 f202 	mul.w	r2, r3, r2
 8007f6c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007f6e:	fb92 f3f3 	sdiv	r3, r2, r3
 8007f72:	627b      	str	r3, [r7, #36]	@ 0x24
            sb_y = rem - sb_y;
 8007f74:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8007f76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007f78:	1ad3      	subs	r3, r2, r3
 8007f7a:	627b      	str	r3, [r7, #36]	@ 0x24

            ver_area->y1 = obj->coords.y1 + sb_y + top_space;
 8007f7c:	68fb      	ldr	r3, [r7, #12]
 8007f7e:	699a      	ldr	r2, [r3, #24]
 8007f80:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007f82:	441a      	add	r2, r3
 8007f84:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8007f86:	441a      	add	r2, r3
 8007f88:	687b      	ldr	r3, [r7, #4]
 8007f8a:	605a      	str	r2, [r3, #4]
            ver_area->y2 = ver_area->y1 + sb_h - 1;
 8007f8c:	687b      	ldr	r3, [r7, #4]
 8007f8e:	685a      	ldr	r2, [r3, #4]
 8007f90:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8007f92:	4413      	add	r3, r2
 8007f94:	1e5a      	subs	r2, r3, #1
 8007f96:	687b      	ldr	r3, [r7, #4]
 8007f98:	60da      	str	r2, [r3, #12]
            if(ver_area->y1 < obj->coords.y1 + top_space) {
 8007f9a:	687b      	ldr	r3, [r7, #4]
 8007f9c:	685a      	ldr	r2, [r3, #4]
 8007f9e:	68fb      	ldr	r3, [r7, #12]
 8007fa0:	6999      	ldr	r1, [r3, #24]
 8007fa2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8007fa4:	440b      	add	r3, r1
 8007fa6:	429a      	cmp	r2, r3
 8007fa8:	da47      	bge.n	800803a <lv_obj_get_scrollbar_area+0x432>
                ver_area->y1 = obj->coords.y1 + top_space;
 8007faa:	68fb      	ldr	r3, [r7, #12]
 8007fac:	699a      	ldr	r2, [r3, #24]
 8007fae:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8007fb0:	441a      	add	r2, r3
 8007fb2:	687b      	ldr	r3, [r7, #4]
 8007fb4:	605a      	str	r2, [r3, #4]
                if(ver_area->y1 + SCROLLBAR_MIN_SIZE > ver_area->y2) {
 8007fb6:	687b      	ldr	r3, [r7, #4]
 8007fb8:	685c      	ldr	r4, [r3, #4]
 8007fba:	2000      	movs	r0, #0
 8007fbc:	f003 f8f8 	bl	800b1b0 <lv_display_get_dpi>
 8007fc0:	4602      	mov	r2, r0
 8007fc2:	4613      	mov	r3, r2
 8007fc4:	009b      	lsls	r3, r3, #2
 8007fc6:	4413      	add	r3, r2
 8007fc8:	005b      	lsls	r3, r3, #1
 8007fca:	2bef      	cmp	r3, #239	@ 0xef
 8007fcc:	dd0f      	ble.n	8007fee <lv_obj_get_scrollbar_area+0x3e6>
 8007fce:	2000      	movs	r0, #0
 8007fd0:	f003 f8ee 	bl	800b1b0 <lv_display_get_dpi>
 8007fd4:	4602      	mov	r2, r0
 8007fd6:	4613      	mov	r3, r2
 8007fd8:	009b      	lsls	r3, r3, #2
 8007fda:	4413      	add	r3, r2
 8007fdc:	005b      	lsls	r3, r3, #1
 8007fde:	3350      	adds	r3, #80	@ 0x50
 8007fe0:	4a66      	ldr	r2, [pc, #408]	@ (800817c <lv_obj_get_scrollbar_area+0x574>)
 8007fe2:	fb82 1203 	smull	r1, r2, r2, r3
 8007fe6:	1192      	asrs	r2, r2, #6
 8007fe8:	17db      	asrs	r3, r3, #31
 8007fea:	1ad3      	subs	r3, r2, r3
 8007fec:	e000      	b.n	8007ff0 <lv_obj_get_scrollbar_area+0x3e8>
 8007fee:	2301      	movs	r3, #1
 8007ff0:	191a      	adds	r2, r3, r4
 8007ff2:	687b      	ldr	r3, [r7, #4]
 8007ff4:	68db      	ldr	r3, [r3, #12]
 8007ff6:	429a      	cmp	r2, r3
 8007ff8:	dd1f      	ble.n	800803a <lv_obj_get_scrollbar_area+0x432>
                    ver_area->y2 = ver_area->y1 + SCROLLBAR_MIN_SIZE;
 8007ffa:	687b      	ldr	r3, [r7, #4]
 8007ffc:	685c      	ldr	r4, [r3, #4]
 8007ffe:	2000      	movs	r0, #0
 8008000:	f003 f8d6 	bl	800b1b0 <lv_display_get_dpi>
 8008004:	4602      	mov	r2, r0
 8008006:	4613      	mov	r3, r2
 8008008:	009b      	lsls	r3, r3, #2
 800800a:	4413      	add	r3, r2
 800800c:	005b      	lsls	r3, r3, #1
 800800e:	2bef      	cmp	r3, #239	@ 0xef
 8008010:	dd0f      	ble.n	8008032 <lv_obj_get_scrollbar_area+0x42a>
 8008012:	2000      	movs	r0, #0
 8008014:	f003 f8cc 	bl	800b1b0 <lv_display_get_dpi>
 8008018:	4602      	mov	r2, r0
 800801a:	4613      	mov	r3, r2
 800801c:	009b      	lsls	r3, r3, #2
 800801e:	4413      	add	r3, r2
 8008020:	005b      	lsls	r3, r3, #1
 8008022:	3350      	adds	r3, #80	@ 0x50
 8008024:	4a55      	ldr	r2, [pc, #340]	@ (800817c <lv_obj_get_scrollbar_area+0x574>)
 8008026:	fb82 1203 	smull	r1, r2, r2, r3
 800802a:	1192      	asrs	r2, r2, #6
 800802c:	17db      	asrs	r3, r3, #31
 800802e:	1ad3      	subs	r3, r2, r3
 8008030:	e000      	b.n	8008034 <lv_obj_get_scrollbar_area+0x42c>
 8008032:	2301      	movs	r3, #1
 8008034:	191a      	adds	r2, r3, r4
 8008036:	687b      	ldr	r3, [r7, #4]
 8008038:	60da      	str	r2, [r3, #12]
                }
            }
            if(ver_area->y2 > obj->coords.y2 - hor_req_space - bottom_space) {
 800803a:	687b      	ldr	r3, [r7, #4]
 800803c:	68da      	ldr	r2, [r3, #12]
 800803e:	68fb      	ldr	r3, [r7, #12]
 8008040:	6a19      	ldr	r1, [r3, #32]
 8008042:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8008044:	1ac9      	subs	r1, r1, r3
 8008046:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8008048:	1acb      	subs	r3, r1, r3
 800804a:	429a      	cmp	r2, r3
 800804c:	dd49      	ble.n	80080e2 <lv_obj_get_scrollbar_area+0x4da>
                ver_area->y2 = obj->coords.y2 - hor_req_space - bottom_space;
 800804e:	68fb      	ldr	r3, [r7, #12]
 8008050:	6a1a      	ldr	r2, [r3, #32]
 8008052:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8008054:	1ad2      	subs	r2, r2, r3
 8008056:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8008058:	1ad2      	subs	r2, r2, r3
 800805a:	687b      	ldr	r3, [r7, #4]
 800805c:	60da      	str	r2, [r3, #12]
                if(ver_area->y2 - SCROLLBAR_MIN_SIZE < ver_area->y1) {
 800805e:	687b      	ldr	r3, [r7, #4]
 8008060:	68dc      	ldr	r4, [r3, #12]
 8008062:	2000      	movs	r0, #0
 8008064:	f003 f8a4 	bl	800b1b0 <lv_display_get_dpi>
 8008068:	4602      	mov	r2, r0
 800806a:	4613      	mov	r3, r2
 800806c:	009b      	lsls	r3, r3, #2
 800806e:	4413      	add	r3, r2
 8008070:	005b      	lsls	r3, r3, #1
 8008072:	2bef      	cmp	r3, #239	@ 0xef
 8008074:	dd0f      	ble.n	8008096 <lv_obj_get_scrollbar_area+0x48e>
 8008076:	2000      	movs	r0, #0
 8008078:	f003 f89a 	bl	800b1b0 <lv_display_get_dpi>
 800807c:	4602      	mov	r2, r0
 800807e:	4613      	mov	r3, r2
 8008080:	009b      	lsls	r3, r3, #2
 8008082:	4413      	add	r3, r2
 8008084:	005b      	lsls	r3, r3, #1
 8008086:	3350      	adds	r3, #80	@ 0x50
 8008088:	4a3c      	ldr	r2, [pc, #240]	@ (800817c <lv_obj_get_scrollbar_area+0x574>)
 800808a:	fb82 1203 	smull	r1, r2, r2, r3
 800808e:	1192      	asrs	r2, r2, #6
 8008090:	17db      	asrs	r3, r3, #31
 8008092:	1ad3      	subs	r3, r2, r3
 8008094:	e000      	b.n	8008098 <lv_obj_get_scrollbar_area+0x490>
 8008096:	2301      	movs	r3, #1
 8008098:	1ae2      	subs	r2, r4, r3
 800809a:	687b      	ldr	r3, [r7, #4]
 800809c:	685b      	ldr	r3, [r3, #4]
 800809e:	429a      	cmp	r2, r3
 80080a0:	da1f      	bge.n	80080e2 <lv_obj_get_scrollbar_area+0x4da>
                    ver_area->y1 = ver_area->y2 - SCROLLBAR_MIN_SIZE;
 80080a2:	687b      	ldr	r3, [r7, #4]
 80080a4:	68dc      	ldr	r4, [r3, #12]
 80080a6:	2000      	movs	r0, #0
 80080a8:	f003 f882 	bl	800b1b0 <lv_display_get_dpi>
 80080ac:	4602      	mov	r2, r0
 80080ae:	4613      	mov	r3, r2
 80080b0:	009b      	lsls	r3, r3, #2
 80080b2:	4413      	add	r3, r2
 80080b4:	005b      	lsls	r3, r3, #1
 80080b6:	2bef      	cmp	r3, #239	@ 0xef
 80080b8:	dd0f      	ble.n	80080da <lv_obj_get_scrollbar_area+0x4d2>
 80080ba:	2000      	movs	r0, #0
 80080bc:	f003 f878 	bl	800b1b0 <lv_display_get_dpi>
 80080c0:	4602      	mov	r2, r0
 80080c2:	4613      	mov	r3, r2
 80080c4:	009b      	lsls	r3, r3, #2
 80080c6:	4413      	add	r3, r2
 80080c8:	005b      	lsls	r3, r3, #1
 80080ca:	3350      	adds	r3, #80	@ 0x50
 80080cc:	4a2b      	ldr	r2, [pc, #172]	@ (800817c <lv_obj_get_scrollbar_area+0x574>)
 80080ce:	fb82 1203 	smull	r1, r2, r2, r3
 80080d2:	1192      	asrs	r2, r2, #6
 80080d4:	17db      	asrs	r3, r3, #31
 80080d6:	1ad3      	subs	r3, r2, r3
 80080d8:	e000      	b.n	80080dc <lv_obj_get_scrollbar_area+0x4d4>
 80080da:	2301      	movs	r3, #1
 80080dc:	1ae2      	subs	r2, r4, r3
 80080de:	687b      	ldr	r3, [r7, #4]
 80080e0:	605a      	str	r2, [r3, #4]
            }
        }
    }

    /*Draw horizontal scrollbar if the mode is ON or can be scrolled in this direction*/
    int32_t content_w = obj_w + sl + sr;
 80080e2:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80080e4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80080e6:	4413      	add	r3, r2
 80080e8:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80080ea:	4413      	add	r3, r2
 80080ec:	623b      	str	r3, [r7, #32]
    if(hor_draw && content_w) {
 80080ee:	f897 3072 	ldrb.w	r3, [r7, #114]	@ 0x72
 80080f2:	2b00      	cmp	r3, #0
 80080f4:	f000 8224 	beq.w	8008540 <lv_obj_get_scrollbar_area+0x938>
 80080f8:	6a3b      	ldr	r3, [r7, #32]
 80080fa:	2b00      	cmp	r3, #0
 80080fc:	f000 8220 	beq.w	8008540 <lv_obj_get_scrollbar_area+0x938>
        hor_area->y2 = obj->coords.y2 - bottom_space;
 8008100:	68fb      	ldr	r3, [r7, #12]
 8008102:	6a1a      	ldr	r2, [r3, #32]
 8008104:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8008106:	1ad2      	subs	r2, r2, r3
 8008108:	68bb      	ldr	r3, [r7, #8]
 800810a:	60da      	str	r2, [r3, #12]
        hor_area->y1 = hor_area->y2 - thickness + 1;
 800810c:	68bb      	ldr	r3, [r7, #8]
 800810e:	68da      	ldr	r2, [r3, #12]
 8008110:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8008112:	1ad3      	subs	r3, r2, r3
 8008114:	1c5a      	adds	r2, r3, #1
 8008116:	68bb      	ldr	r3, [r7, #8]
 8008118:	605a      	str	r2, [r3, #4]
        hor_area->x1 = obj->coords.x1;
 800811a:	68fb      	ldr	r3, [r7, #12]
 800811c:	695a      	ldr	r2, [r3, #20]
 800811e:	68bb      	ldr	r3, [r7, #8]
 8008120:	601a      	str	r2, [r3, #0]
        hor_area->x2 = obj->coords.x2;
 8008122:	68fb      	ldr	r3, [r7, #12]
 8008124:	69da      	ldr	r2, [r3, #28]
 8008126:	68bb      	ldr	r3, [r7, #8]
 8008128:	609a      	str	r2, [r3, #8]

        int32_t sb_w = ((obj_w - left_space - right_space - ver_reg_space) * obj_w) / content_w;
 800812a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800812c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800812e:	1ad2      	subs	r2, r2, r3
 8008130:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8008132:	1ad2      	subs	r2, r2, r3
 8008134:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8008136:	1ad3      	subs	r3, r2, r3
 8008138:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800813a:	fb03 f202 	mul.w	r2, r3, r2
 800813e:	6a3b      	ldr	r3, [r7, #32]
 8008140:	fb92 f3f3 	sdiv	r3, r2, r3
 8008144:	61fb      	str	r3, [r7, #28]
        sb_w = LV_MAX(sb_w, SCROLLBAR_MIN_SIZE);
 8008146:	2000      	movs	r0, #0
 8008148:	f003 f832 	bl	800b1b0 <lv_display_get_dpi>
 800814c:	4602      	mov	r2, r0
 800814e:	4613      	mov	r3, r2
 8008150:	009b      	lsls	r3, r3, #2
 8008152:	4413      	add	r3, r2
 8008154:	005b      	lsls	r3, r3, #1
 8008156:	2bef      	cmp	r3, #239	@ 0xef
 8008158:	dd12      	ble.n	8008180 <lv_obj_get_scrollbar_area+0x578>
 800815a:	2000      	movs	r0, #0
 800815c:	f003 f828 	bl	800b1b0 <lv_display_get_dpi>
 8008160:	4602      	mov	r2, r0
 8008162:	4613      	mov	r3, r2
 8008164:	009b      	lsls	r3, r3, #2
 8008166:	4413      	add	r3, r2
 8008168:	005b      	lsls	r3, r3, #1
 800816a:	3350      	adds	r3, #80	@ 0x50
 800816c:	4a03      	ldr	r2, [pc, #12]	@ (800817c <lv_obj_get_scrollbar_area+0x574>)
 800816e:	fb82 1203 	smull	r1, r2, r2, r3
 8008172:	1192      	asrs	r2, r2, #6
 8008174:	17db      	asrs	r3, r3, #31
 8008176:	1ad3      	subs	r3, r2, r3
 8008178:	e003      	b.n	8008182 <lv_obj_get_scrollbar_area+0x57a>
 800817a:	bf00      	nop
 800817c:	66666667 	.word	0x66666667
 8008180:	2301      	movs	r3, #1
 8008182:	69fa      	ldr	r2, [r7, #28]
 8008184:	4293      	cmp	r3, r2
 8008186:	db1b      	blt.n	80081c0 <lv_obj_get_scrollbar_area+0x5b8>
 8008188:	2000      	movs	r0, #0
 800818a:	f003 f811 	bl	800b1b0 <lv_display_get_dpi>
 800818e:	4602      	mov	r2, r0
 8008190:	4613      	mov	r3, r2
 8008192:	009b      	lsls	r3, r3, #2
 8008194:	4413      	add	r3, r2
 8008196:	005b      	lsls	r3, r3, #1
 8008198:	2bef      	cmp	r3, #239	@ 0xef
 800819a:	dd0f      	ble.n	80081bc <lv_obj_get_scrollbar_area+0x5b4>
 800819c:	2000      	movs	r0, #0
 800819e:	f003 f807 	bl	800b1b0 <lv_display_get_dpi>
 80081a2:	4602      	mov	r2, r0
 80081a4:	4613      	mov	r3, r2
 80081a6:	009b      	lsls	r3, r3, #2
 80081a8:	4413      	add	r3, r2
 80081aa:	005b      	lsls	r3, r3, #1
 80081ac:	3350      	adds	r3, #80	@ 0x50
 80081ae:	4aa1      	ldr	r2, [pc, #644]	@ (8008434 <lv_obj_get_scrollbar_area+0x82c>)
 80081b0:	fb82 1203 	smull	r1, r2, r2, r3
 80081b4:	1192      	asrs	r2, r2, #6
 80081b6:	17db      	asrs	r3, r3, #31
 80081b8:	1ad3      	subs	r3, r2, r3
 80081ba:	e002      	b.n	80081c2 <lv_obj_get_scrollbar_area+0x5ba>
 80081bc:	2301      	movs	r3, #1
 80081be:	e000      	b.n	80081c2 <lv_obj_get_scrollbar_area+0x5ba>
 80081c0:	69fb      	ldr	r3, [r7, #28]
 80081c2:	61fb      	str	r3, [r7, #28]
        rem = (obj_w - left_space - right_space - ver_reg_space) -
 80081c4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80081c6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80081c8:	1ad2      	subs	r2, r2, r3
 80081ca:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80081cc:	1ad2      	subs	r2, r2, r3
 80081ce:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80081d0:	1ad2      	subs	r2, r2, r3
 80081d2:	69fb      	ldr	r3, [r7, #28]
 80081d4:	1ad3      	subs	r3, r2, r3
 80081d6:	62fb      	str	r3, [r7, #44]	@ 0x2c
              sb_w;  /*Remaining size from the scrollbar track that is not the scrollbar itself*/
        int32_t scroll_w = content_w - obj_w; /*The size of the content which can be really scrolled*/
 80081d8:	6a3a      	ldr	r2, [r7, #32]
 80081da:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80081dc:	1ad3      	subs	r3, r2, r3
 80081de:	61bb      	str	r3, [r7, #24]
        if(scroll_w <= 0) {
 80081e0:	69bb      	ldr	r3, [r7, #24]
 80081e2:	2b00      	cmp	r3, #0
 80081e4:	dc23      	bgt.n	800822e <lv_obj_get_scrollbar_area+0x626>
            if(rtl) {
 80081e6:	f897 305e 	ldrb.w	r3, [r7, #94]	@ 0x5e
 80081ea:	2b00      	cmp	r3, #0
 80081ec:	d00f      	beq.n	800820e <lv_obj_get_scrollbar_area+0x606>
                hor_area->x1 = obj->coords.x1 + left_space + ver_reg_space - 1;
 80081ee:	68fb      	ldr	r3, [r7, #12]
 80081f0:	695a      	ldr	r2, [r3, #20]
 80081f2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80081f4:	441a      	add	r2, r3
 80081f6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80081f8:	4413      	add	r3, r2
 80081fa:	1e5a      	subs	r2, r3, #1
 80081fc:	68bb      	ldr	r3, [r7, #8]
 80081fe:	601a      	str	r2, [r3, #0]
                hor_area->x2 = obj->coords.x2 - right_space;
 8008200:	68fb      	ldr	r3, [r7, #12]
 8008202:	69da      	ldr	r2, [r3, #28]
 8008204:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8008206:	1ad2      	subs	r2, r2, r3
 8008208:	68bb      	ldr	r3, [r7, #8]
 800820a:	609a      	str	r2, [r3, #8]
 800820c:	e198      	b.n	8008540 <lv_obj_get_scrollbar_area+0x938>
            }
            else {
                hor_area->x1 = obj->coords.x1 + left_space;
 800820e:	68fb      	ldr	r3, [r7, #12]
 8008210:	695a      	ldr	r2, [r3, #20]
 8008212:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8008214:	441a      	add	r2, r3
 8008216:	68bb      	ldr	r3, [r7, #8]
 8008218:	601a      	str	r2, [r3, #0]
                hor_area->x2 = obj->coords.x2 - right_space - ver_reg_space - 1;
 800821a:	68fb      	ldr	r3, [r7, #12]
 800821c:	69da      	ldr	r2, [r3, #28]
 800821e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8008220:	1ad2      	subs	r2, r2, r3
 8008222:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8008224:	1ad3      	subs	r3, r2, r3
 8008226:	1e5a      	subs	r2, r3, #1
 8008228:	68bb      	ldr	r3, [r7, #8]
 800822a:	609a      	str	r2, [r3, #8]
 800822c:	e188      	b.n	8008540 <lv_obj_get_scrollbar_area+0x938>
            }
        }
        else {
            int32_t sb_x = (rem * sr) / scroll_w;
 800822e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8008230:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8008232:	fb03 f202 	mul.w	r2, r3, r2
 8008236:	69bb      	ldr	r3, [r7, #24]
 8008238:	fb92 f3f3 	sdiv	r3, r2, r3
 800823c:	617b      	str	r3, [r7, #20]
            sb_x = rem - sb_x;
 800823e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8008240:	697b      	ldr	r3, [r7, #20]
 8008242:	1ad3      	subs	r3, r2, r3
 8008244:	617b      	str	r3, [r7, #20]

            if(rtl) {
 8008246:	f897 305e 	ldrb.w	r3, [r7, #94]	@ 0x5e
 800824a:	2b00      	cmp	r3, #0
 800824c:	f000 80b8 	beq.w	80083c0 <lv_obj_get_scrollbar_area+0x7b8>
                hor_area->x1 = obj->coords.x1 + sb_x + left_space + ver_reg_space;
 8008250:	68fb      	ldr	r3, [r7, #12]
 8008252:	695a      	ldr	r2, [r3, #20]
 8008254:	697b      	ldr	r3, [r7, #20]
 8008256:	441a      	add	r2, r3
 8008258:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800825a:	441a      	add	r2, r3
 800825c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800825e:	441a      	add	r2, r3
 8008260:	68bb      	ldr	r3, [r7, #8]
 8008262:	601a      	str	r2, [r3, #0]
                hor_area->x2 = hor_area->x1 + sb_w - 1;
 8008264:	68bb      	ldr	r3, [r7, #8]
 8008266:	681a      	ldr	r2, [r3, #0]
 8008268:	69fb      	ldr	r3, [r7, #28]
 800826a:	4413      	add	r3, r2
 800826c:	1e5a      	subs	r2, r3, #1
 800826e:	68bb      	ldr	r3, [r7, #8]
 8008270:	609a      	str	r2, [r3, #8]
                if(hor_area->x1 < obj->coords.x1 + left_space + ver_reg_space) {
 8008272:	68bb      	ldr	r3, [r7, #8]
 8008274:	681a      	ldr	r2, [r3, #0]
 8008276:	68fb      	ldr	r3, [r7, #12]
 8008278:	6959      	ldr	r1, [r3, #20]
 800827a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800827c:	4419      	add	r1, r3
 800827e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8008280:	440b      	add	r3, r1
 8008282:	429a      	cmp	r2, r3
 8008284:	da49      	bge.n	800831a <lv_obj_get_scrollbar_area+0x712>
                    hor_area->x1 = obj->coords.x1 + left_space + ver_reg_space;
 8008286:	68fb      	ldr	r3, [r7, #12]
 8008288:	695a      	ldr	r2, [r3, #20]
 800828a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800828c:	441a      	add	r2, r3
 800828e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8008290:	441a      	add	r2, r3
 8008292:	68bb      	ldr	r3, [r7, #8]
 8008294:	601a      	str	r2, [r3, #0]
                    if(hor_area->x1 + SCROLLBAR_MIN_SIZE > hor_area->x2) {
 8008296:	68bb      	ldr	r3, [r7, #8]
 8008298:	681c      	ldr	r4, [r3, #0]
 800829a:	2000      	movs	r0, #0
 800829c:	f002 ff88 	bl	800b1b0 <lv_display_get_dpi>
 80082a0:	4602      	mov	r2, r0
 80082a2:	4613      	mov	r3, r2
 80082a4:	009b      	lsls	r3, r3, #2
 80082a6:	4413      	add	r3, r2
 80082a8:	005b      	lsls	r3, r3, #1
 80082aa:	2bef      	cmp	r3, #239	@ 0xef
 80082ac:	dd0f      	ble.n	80082ce <lv_obj_get_scrollbar_area+0x6c6>
 80082ae:	2000      	movs	r0, #0
 80082b0:	f002 ff7e 	bl	800b1b0 <lv_display_get_dpi>
 80082b4:	4602      	mov	r2, r0
 80082b6:	4613      	mov	r3, r2
 80082b8:	009b      	lsls	r3, r3, #2
 80082ba:	4413      	add	r3, r2
 80082bc:	005b      	lsls	r3, r3, #1
 80082be:	3350      	adds	r3, #80	@ 0x50
 80082c0:	4a5c      	ldr	r2, [pc, #368]	@ (8008434 <lv_obj_get_scrollbar_area+0x82c>)
 80082c2:	fb82 1203 	smull	r1, r2, r2, r3
 80082c6:	1192      	asrs	r2, r2, #6
 80082c8:	17db      	asrs	r3, r3, #31
 80082ca:	1ad3      	subs	r3, r2, r3
 80082cc:	e000      	b.n	80082d0 <lv_obj_get_scrollbar_area+0x6c8>
 80082ce:	2301      	movs	r3, #1
 80082d0:	191a      	adds	r2, r3, r4
 80082d2:	68bb      	ldr	r3, [r7, #8]
 80082d4:	689b      	ldr	r3, [r3, #8]
 80082d6:	429a      	cmp	r2, r3
 80082d8:	dd1f      	ble.n	800831a <lv_obj_get_scrollbar_area+0x712>
                        hor_area->x2 = hor_area->x1 + SCROLLBAR_MIN_SIZE;
 80082da:	68bb      	ldr	r3, [r7, #8]
 80082dc:	681c      	ldr	r4, [r3, #0]
 80082de:	2000      	movs	r0, #0
 80082e0:	f002 ff66 	bl	800b1b0 <lv_display_get_dpi>
 80082e4:	4602      	mov	r2, r0
 80082e6:	4613      	mov	r3, r2
 80082e8:	009b      	lsls	r3, r3, #2
 80082ea:	4413      	add	r3, r2
 80082ec:	005b      	lsls	r3, r3, #1
 80082ee:	2bef      	cmp	r3, #239	@ 0xef
 80082f0:	dd0f      	ble.n	8008312 <lv_obj_get_scrollbar_area+0x70a>
 80082f2:	2000      	movs	r0, #0
 80082f4:	f002 ff5c 	bl	800b1b0 <lv_display_get_dpi>
 80082f8:	4602      	mov	r2, r0
 80082fa:	4613      	mov	r3, r2
 80082fc:	009b      	lsls	r3, r3, #2
 80082fe:	4413      	add	r3, r2
 8008300:	005b      	lsls	r3, r3, #1
 8008302:	3350      	adds	r3, #80	@ 0x50
 8008304:	4a4b      	ldr	r2, [pc, #300]	@ (8008434 <lv_obj_get_scrollbar_area+0x82c>)
 8008306:	fb82 1203 	smull	r1, r2, r2, r3
 800830a:	1192      	asrs	r2, r2, #6
 800830c:	17db      	asrs	r3, r3, #31
 800830e:	1ad3      	subs	r3, r2, r3
 8008310:	e000      	b.n	8008314 <lv_obj_get_scrollbar_area+0x70c>
 8008312:	2301      	movs	r3, #1
 8008314:	191a      	adds	r2, r3, r4
 8008316:	68bb      	ldr	r3, [r7, #8]
 8008318:	609a      	str	r2, [r3, #8]
                    }
                }
                if(hor_area->x2 > obj->coords.x2 - right_space) {
 800831a:	68bb      	ldr	r3, [r7, #8]
 800831c:	689a      	ldr	r2, [r3, #8]
 800831e:	68fb      	ldr	r3, [r7, #12]
 8008320:	69d9      	ldr	r1, [r3, #28]
 8008322:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8008324:	1acb      	subs	r3, r1, r3
 8008326:	429a      	cmp	r2, r3
 8008328:	f340 810a 	ble.w	8008540 <lv_obj_get_scrollbar_area+0x938>
                    hor_area->x2 = obj->coords.x2 - right_space;
 800832c:	68fb      	ldr	r3, [r7, #12]
 800832e:	69da      	ldr	r2, [r3, #28]
 8008330:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8008332:	1ad2      	subs	r2, r2, r3
 8008334:	68bb      	ldr	r3, [r7, #8]
 8008336:	609a      	str	r2, [r3, #8]
                    if(hor_area->x2 - SCROLLBAR_MIN_SIZE < hor_area->x1) {
 8008338:	68bb      	ldr	r3, [r7, #8]
 800833a:	689c      	ldr	r4, [r3, #8]
 800833c:	2000      	movs	r0, #0
 800833e:	f002 ff37 	bl	800b1b0 <lv_display_get_dpi>
 8008342:	4602      	mov	r2, r0
 8008344:	4613      	mov	r3, r2
 8008346:	009b      	lsls	r3, r3, #2
 8008348:	4413      	add	r3, r2
 800834a:	005b      	lsls	r3, r3, #1
 800834c:	2bef      	cmp	r3, #239	@ 0xef
 800834e:	dd0f      	ble.n	8008370 <lv_obj_get_scrollbar_area+0x768>
 8008350:	2000      	movs	r0, #0
 8008352:	f002 ff2d 	bl	800b1b0 <lv_display_get_dpi>
 8008356:	4602      	mov	r2, r0
 8008358:	4613      	mov	r3, r2
 800835a:	009b      	lsls	r3, r3, #2
 800835c:	4413      	add	r3, r2
 800835e:	005b      	lsls	r3, r3, #1
 8008360:	3350      	adds	r3, #80	@ 0x50
 8008362:	4a34      	ldr	r2, [pc, #208]	@ (8008434 <lv_obj_get_scrollbar_area+0x82c>)
 8008364:	fb82 1203 	smull	r1, r2, r2, r3
 8008368:	1192      	asrs	r2, r2, #6
 800836a:	17db      	asrs	r3, r3, #31
 800836c:	1ad3      	subs	r3, r2, r3
 800836e:	e000      	b.n	8008372 <lv_obj_get_scrollbar_area+0x76a>
 8008370:	2301      	movs	r3, #1
 8008372:	1ae2      	subs	r2, r4, r3
 8008374:	68bb      	ldr	r3, [r7, #8]
 8008376:	681b      	ldr	r3, [r3, #0]
 8008378:	429a      	cmp	r2, r3
 800837a:	f280 80e1 	bge.w	8008540 <lv_obj_get_scrollbar_area+0x938>
                        hor_area->x1 = hor_area->x2 - SCROLLBAR_MIN_SIZE;
 800837e:	68bb      	ldr	r3, [r7, #8]
 8008380:	689c      	ldr	r4, [r3, #8]
 8008382:	2000      	movs	r0, #0
 8008384:	f002 ff14 	bl	800b1b0 <lv_display_get_dpi>
 8008388:	4602      	mov	r2, r0
 800838a:	4613      	mov	r3, r2
 800838c:	009b      	lsls	r3, r3, #2
 800838e:	4413      	add	r3, r2
 8008390:	005b      	lsls	r3, r3, #1
 8008392:	2bef      	cmp	r3, #239	@ 0xef
 8008394:	dd0f      	ble.n	80083b6 <lv_obj_get_scrollbar_area+0x7ae>
 8008396:	2000      	movs	r0, #0
 8008398:	f002 ff0a 	bl	800b1b0 <lv_display_get_dpi>
 800839c:	4602      	mov	r2, r0
 800839e:	4613      	mov	r3, r2
 80083a0:	009b      	lsls	r3, r3, #2
 80083a2:	4413      	add	r3, r2
 80083a4:	005b      	lsls	r3, r3, #1
 80083a6:	3350      	adds	r3, #80	@ 0x50
 80083a8:	4a22      	ldr	r2, [pc, #136]	@ (8008434 <lv_obj_get_scrollbar_area+0x82c>)
 80083aa:	fb82 1203 	smull	r1, r2, r2, r3
 80083ae:	1192      	asrs	r2, r2, #6
 80083b0:	17db      	asrs	r3, r3, #31
 80083b2:	1ad3      	subs	r3, r2, r3
 80083b4:	e000      	b.n	80083b8 <lv_obj_get_scrollbar_area+0x7b0>
 80083b6:	2301      	movs	r3, #1
 80083b8:	1ae2      	subs	r2, r4, r3
 80083ba:	68bb      	ldr	r3, [r7, #8]
 80083bc:	601a      	str	r2, [r3, #0]
 80083be:	e0bf      	b.n	8008540 <lv_obj_get_scrollbar_area+0x938>
                    }
                }
            }
            else {
                hor_area->x1 = obj->coords.x1 + sb_x + left_space;
 80083c0:	68fb      	ldr	r3, [r7, #12]
 80083c2:	695a      	ldr	r2, [r3, #20]
 80083c4:	697b      	ldr	r3, [r7, #20]
 80083c6:	441a      	add	r2, r3
 80083c8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80083ca:	441a      	add	r2, r3
 80083cc:	68bb      	ldr	r3, [r7, #8]
 80083ce:	601a      	str	r2, [r3, #0]
                hor_area->x2 = hor_area->x1 + sb_w - 1;
 80083d0:	68bb      	ldr	r3, [r7, #8]
 80083d2:	681a      	ldr	r2, [r3, #0]
 80083d4:	69fb      	ldr	r3, [r7, #28]
 80083d6:	4413      	add	r3, r2
 80083d8:	1e5a      	subs	r2, r3, #1
 80083da:	68bb      	ldr	r3, [r7, #8]
 80083dc:	609a      	str	r2, [r3, #8]
                if(hor_area->x1 < obj->coords.x1 + left_space) {
 80083de:	68bb      	ldr	r3, [r7, #8]
 80083e0:	681a      	ldr	r2, [r3, #0]
 80083e2:	68fb      	ldr	r3, [r7, #12]
 80083e4:	6959      	ldr	r1, [r3, #20]
 80083e6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80083e8:	440b      	add	r3, r1
 80083ea:	429a      	cmp	r2, r3
 80083ec:	da4a      	bge.n	8008484 <lv_obj_get_scrollbar_area+0x87c>
                    hor_area->x1 = obj->coords.x1 + left_space;
 80083ee:	68fb      	ldr	r3, [r7, #12]
 80083f0:	695a      	ldr	r2, [r3, #20]
 80083f2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80083f4:	441a      	add	r2, r3
 80083f6:	68bb      	ldr	r3, [r7, #8]
 80083f8:	601a      	str	r2, [r3, #0]
                    if(hor_area->x1 + SCROLLBAR_MIN_SIZE > hor_area->x2) {
 80083fa:	68bb      	ldr	r3, [r7, #8]
 80083fc:	681c      	ldr	r4, [r3, #0]
 80083fe:	2000      	movs	r0, #0
 8008400:	f002 fed6 	bl	800b1b0 <lv_display_get_dpi>
 8008404:	4602      	mov	r2, r0
 8008406:	4613      	mov	r3, r2
 8008408:	009b      	lsls	r3, r3, #2
 800840a:	4413      	add	r3, r2
 800840c:	005b      	lsls	r3, r3, #1
 800840e:	2bef      	cmp	r3, #239	@ 0xef
 8008410:	dd12      	ble.n	8008438 <lv_obj_get_scrollbar_area+0x830>
 8008412:	2000      	movs	r0, #0
 8008414:	f002 fecc 	bl	800b1b0 <lv_display_get_dpi>
 8008418:	4602      	mov	r2, r0
 800841a:	4613      	mov	r3, r2
 800841c:	009b      	lsls	r3, r3, #2
 800841e:	4413      	add	r3, r2
 8008420:	005b      	lsls	r3, r3, #1
 8008422:	3350      	adds	r3, #80	@ 0x50
 8008424:	4a03      	ldr	r2, [pc, #12]	@ (8008434 <lv_obj_get_scrollbar_area+0x82c>)
 8008426:	fb82 1203 	smull	r1, r2, r2, r3
 800842a:	1192      	asrs	r2, r2, #6
 800842c:	17db      	asrs	r3, r3, #31
 800842e:	1ad3      	subs	r3, r2, r3
 8008430:	e003      	b.n	800843a <lv_obj_get_scrollbar_area+0x832>
 8008432:	bf00      	nop
 8008434:	66666667 	.word	0x66666667
 8008438:	2301      	movs	r3, #1
 800843a:	191a      	adds	r2, r3, r4
 800843c:	68bb      	ldr	r3, [r7, #8]
 800843e:	689b      	ldr	r3, [r3, #8]
 8008440:	429a      	cmp	r2, r3
 8008442:	dd1f      	ble.n	8008484 <lv_obj_get_scrollbar_area+0x87c>
                        hor_area->x2 = hor_area->x1 + SCROLLBAR_MIN_SIZE;
 8008444:	68bb      	ldr	r3, [r7, #8]
 8008446:	681c      	ldr	r4, [r3, #0]
 8008448:	2000      	movs	r0, #0
 800844a:	f002 feb1 	bl	800b1b0 <lv_display_get_dpi>
 800844e:	4602      	mov	r2, r0
 8008450:	4613      	mov	r3, r2
 8008452:	009b      	lsls	r3, r3, #2
 8008454:	4413      	add	r3, r2
 8008456:	005b      	lsls	r3, r3, #1
 8008458:	2bef      	cmp	r3, #239	@ 0xef
 800845a:	dd0f      	ble.n	800847c <lv_obj_get_scrollbar_area+0x874>
 800845c:	2000      	movs	r0, #0
 800845e:	f002 fea7 	bl	800b1b0 <lv_display_get_dpi>
 8008462:	4602      	mov	r2, r0
 8008464:	4613      	mov	r3, r2
 8008466:	009b      	lsls	r3, r3, #2
 8008468:	4413      	add	r3, r2
 800846a:	005b      	lsls	r3, r3, #1
 800846c:	3350      	adds	r3, #80	@ 0x50
 800846e:	4a36      	ldr	r2, [pc, #216]	@ (8008548 <lv_obj_get_scrollbar_area+0x940>)
 8008470:	fb82 1203 	smull	r1, r2, r2, r3
 8008474:	1192      	asrs	r2, r2, #6
 8008476:	17db      	asrs	r3, r3, #31
 8008478:	1ad3      	subs	r3, r2, r3
 800847a:	e000      	b.n	800847e <lv_obj_get_scrollbar_area+0x876>
 800847c:	2301      	movs	r3, #1
 800847e:	191a      	adds	r2, r3, r4
 8008480:	68bb      	ldr	r3, [r7, #8]
 8008482:	609a      	str	r2, [r3, #8]
                    }
                }
                if(hor_area->x2 > obj->coords.x2 - ver_reg_space - right_space) {
 8008484:	68bb      	ldr	r3, [r7, #8]
 8008486:	689a      	ldr	r2, [r3, #8]
 8008488:	68fb      	ldr	r3, [r7, #12]
 800848a:	69d9      	ldr	r1, [r3, #28]
 800848c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800848e:	1ac9      	subs	r1, r1, r3
 8008490:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8008492:	1acb      	subs	r3, r1, r3
 8008494:	429a      	cmp	r2, r3
 8008496:	dd53      	ble.n	8008540 <lv_obj_get_scrollbar_area+0x938>
                    hor_area->x2 = obj->coords.x2 - ver_reg_space - right_space;
 8008498:	68fb      	ldr	r3, [r7, #12]
 800849a:	69da      	ldr	r2, [r3, #28]
 800849c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800849e:	1ad2      	subs	r2, r2, r3
 80084a0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80084a2:	1ad2      	subs	r2, r2, r3
 80084a4:	68bb      	ldr	r3, [r7, #8]
 80084a6:	609a      	str	r2, [r3, #8]
                    if(hor_area->x2 - SCROLLBAR_MIN_SIZE < hor_area->x1) {
 80084a8:	68bb      	ldr	r3, [r7, #8]
 80084aa:	689c      	ldr	r4, [r3, #8]
 80084ac:	2000      	movs	r0, #0
 80084ae:	f002 fe7f 	bl	800b1b0 <lv_display_get_dpi>
 80084b2:	4602      	mov	r2, r0
 80084b4:	4613      	mov	r3, r2
 80084b6:	009b      	lsls	r3, r3, #2
 80084b8:	4413      	add	r3, r2
 80084ba:	005b      	lsls	r3, r3, #1
 80084bc:	2bef      	cmp	r3, #239	@ 0xef
 80084be:	dd0f      	ble.n	80084e0 <lv_obj_get_scrollbar_area+0x8d8>
 80084c0:	2000      	movs	r0, #0
 80084c2:	f002 fe75 	bl	800b1b0 <lv_display_get_dpi>
 80084c6:	4602      	mov	r2, r0
 80084c8:	4613      	mov	r3, r2
 80084ca:	009b      	lsls	r3, r3, #2
 80084cc:	4413      	add	r3, r2
 80084ce:	005b      	lsls	r3, r3, #1
 80084d0:	3350      	adds	r3, #80	@ 0x50
 80084d2:	4a1d      	ldr	r2, [pc, #116]	@ (8008548 <lv_obj_get_scrollbar_area+0x940>)
 80084d4:	fb82 1203 	smull	r1, r2, r2, r3
 80084d8:	1192      	asrs	r2, r2, #6
 80084da:	17db      	asrs	r3, r3, #31
 80084dc:	1ad3      	subs	r3, r2, r3
 80084de:	e000      	b.n	80084e2 <lv_obj_get_scrollbar_area+0x8da>
 80084e0:	2301      	movs	r3, #1
 80084e2:	1ae2      	subs	r2, r4, r3
 80084e4:	68bb      	ldr	r3, [r7, #8]
 80084e6:	681b      	ldr	r3, [r3, #0]
 80084e8:	429a      	cmp	r2, r3
 80084ea:	da29      	bge.n	8008540 <lv_obj_get_scrollbar_area+0x938>
                        hor_area->x1 = hor_area->x2 - SCROLLBAR_MIN_SIZE;
 80084ec:	68bb      	ldr	r3, [r7, #8]
 80084ee:	689c      	ldr	r4, [r3, #8]
 80084f0:	2000      	movs	r0, #0
 80084f2:	f002 fe5d 	bl	800b1b0 <lv_display_get_dpi>
 80084f6:	4602      	mov	r2, r0
 80084f8:	4613      	mov	r3, r2
 80084fa:	009b      	lsls	r3, r3, #2
 80084fc:	4413      	add	r3, r2
 80084fe:	005b      	lsls	r3, r3, #1
 8008500:	2bef      	cmp	r3, #239	@ 0xef
 8008502:	dd0f      	ble.n	8008524 <lv_obj_get_scrollbar_area+0x91c>
 8008504:	2000      	movs	r0, #0
 8008506:	f002 fe53 	bl	800b1b0 <lv_display_get_dpi>
 800850a:	4602      	mov	r2, r0
 800850c:	4613      	mov	r3, r2
 800850e:	009b      	lsls	r3, r3, #2
 8008510:	4413      	add	r3, r2
 8008512:	005b      	lsls	r3, r3, #1
 8008514:	3350      	adds	r3, #80	@ 0x50
 8008516:	4a0c      	ldr	r2, [pc, #48]	@ (8008548 <lv_obj_get_scrollbar_area+0x940>)
 8008518:	fb82 1203 	smull	r1, r2, r2, r3
 800851c:	1192      	asrs	r2, r2, #6
 800851e:	17db      	asrs	r3, r3, #31
 8008520:	1ad3      	subs	r3, r2, r3
 8008522:	e000      	b.n	8008526 <lv_obj_get_scrollbar_area+0x91e>
 8008524:	2301      	movs	r3, #1
 8008526:	1ae2      	subs	r2, r4, r3
 8008528:	68bb      	ldr	r3, [r7, #8]
 800852a:	601a      	str	r2, [r3, #0]
 800852c:	e008      	b.n	8008540 <lv_obj_get_scrollbar_area+0x938>
    if(lv_obj_has_flag(obj, LV_OBJ_FLAG_SCROLLABLE) == false) return;
 800852e:	bf00      	nop
 8008530:	e006      	b.n	8008540 <lv_obj_get_scrollbar_area+0x938>
    if(sm == LV_SCROLLBAR_MODE_OFF)  return;
 8008532:	bf00      	nop
 8008534:	e004      	b.n	8008540 <lv_obj_get_scrollbar_area+0x938>
        if(indev == NULL)  return;
 8008536:	bf00      	nop
 8008538:	e002      	b.n	8008540 <lv_obj_get_scrollbar_area+0x938>
    if(!hor_draw && !ver_draw) return;
 800853a:	bf00      	nop
 800853c:	e000      	b.n	8008540 <lv_obj_get_scrollbar_area+0x938>
        return;
 800853e:	bf00      	nop
                    }
                }
            }
        }
    }
}
 8008540:	377c      	adds	r7, #124	@ 0x7c
 8008542:	46bd      	mov	sp, r7
 8008544:	bd90      	pop	{r4, r7, pc}
 8008546:	bf00      	nop
 8008548:	66666667 	.word	0x66666667

0800854c <lv_obj_scrollbar_invalidate>:

void lv_obj_scrollbar_invalidate(lv_obj_t * obj)
{
 800854c:	b580      	push	{r7, lr}
 800854e:	b08a      	sub	sp, #40	@ 0x28
 8008550:	af00      	add	r7, sp, #0
 8008552:	6078      	str	r0, [r7, #4]
    lv_area_t hor_area;
    lv_area_t ver_area;
    lv_obj_get_scrollbar_area(obj, &hor_area, &ver_area);
 8008554:	f107 0208 	add.w	r2, r7, #8
 8008558:	f107 0318 	add.w	r3, r7, #24
 800855c:	4619      	mov	r1, r3
 800855e:	6878      	ldr	r0, [r7, #4]
 8008560:	f7ff fb52 	bl	8007c08 <lv_obj_get_scrollbar_area>

    if(lv_area_get_size(&hor_area) <= 0 && lv_area_get_size(&ver_area) <= 0) return;
 8008564:	f107 0318 	add.w	r3, r7, #24
 8008568:	4618      	mov	r0, r3
 800856a:	f019 f98a 	bl	8021882 <lv_area_get_size>
 800856e:	4603      	mov	r3, r0
 8008570:	2b00      	cmp	r3, #0
 8008572:	d107      	bne.n	8008584 <lv_obj_scrollbar_invalidate+0x38>
 8008574:	f107 0308 	add.w	r3, r7, #8
 8008578:	4618      	mov	r0, r3
 800857a:	f019 f982 	bl	8021882 <lv_area_get_size>
 800857e:	4603      	mov	r3, r0
 8008580:	2b00      	cmp	r3, #0
 8008582:	d01c      	beq.n	80085be <lv_obj_scrollbar_invalidate+0x72>

    if(lv_area_get_size(&hor_area) > 0) lv_obj_invalidate_area(obj, &hor_area);
 8008584:	f107 0318 	add.w	r3, r7, #24
 8008588:	4618      	mov	r0, r3
 800858a:	f019 f97a 	bl	8021882 <lv_area_get_size>
 800858e:	4603      	mov	r3, r0
 8008590:	2b00      	cmp	r3, #0
 8008592:	d005      	beq.n	80085a0 <lv_obj_scrollbar_invalidate+0x54>
 8008594:	f107 0318 	add.w	r3, r7, #24
 8008598:	4619      	mov	r1, r3
 800859a:	6878      	ldr	r0, [r7, #4]
 800859c:	f7fe f81b 	bl	80065d6 <lv_obj_invalidate_area>
    if(lv_area_get_size(&ver_area) > 0) lv_obj_invalidate_area(obj, &ver_area);
 80085a0:	f107 0308 	add.w	r3, r7, #8
 80085a4:	4618      	mov	r0, r3
 80085a6:	f019 f96c 	bl	8021882 <lv_area_get_size>
 80085aa:	4603      	mov	r3, r0
 80085ac:	2b00      	cmp	r3, #0
 80085ae:	d007      	beq.n	80085c0 <lv_obj_scrollbar_invalidate+0x74>
 80085b0:	f107 0308 	add.w	r3, r7, #8
 80085b4:	4619      	mov	r1, r3
 80085b6:	6878      	ldr	r0, [r7, #4]
 80085b8:	f7fe f80d 	bl	80065d6 <lv_obj_invalidate_area>
 80085bc:	e000      	b.n	80085c0 <lv_obj_scrollbar_invalidate+0x74>
    if(lv_area_get_size(&hor_area) <= 0 && lv_area_get_size(&ver_area) <= 0) return;
 80085be:	bf00      	nop
}
 80085c0:	3728      	adds	r7, #40	@ 0x28
 80085c2:	46bd      	mov	sp, r7
 80085c4:	bd80      	pop	{r7, pc}

080085c6 <lv_obj_readjust_scroll>:

void lv_obj_readjust_scroll(lv_obj_t * obj, lv_anim_enable_t anim_en)
{
 80085c6:	b580      	push	{r7, lr}
 80085c8:	b086      	sub	sp, #24
 80085ca:	af00      	add	r7, sp, #0
 80085cc:	6078      	str	r0, [r7, #4]
 80085ce:	460b      	mov	r3, r1
 80085d0:	70fb      	strb	r3, [r7, #3]
    /*Be sure the bottom side is not remains scrolled in*/
    /*With snapping the content can't be scrolled in*/
    if(lv_obj_get_scroll_snap_y(obj) == LV_SCROLL_SNAP_NONE) {
 80085d2:	6878      	ldr	r0, [r7, #4]
 80085d4:	f7fe ff1b 	bl	800740e <lv_obj_get_scroll_snap_y>
 80085d8:	4603      	mov	r3, r0
 80085da:	2b00      	cmp	r3, #0
 80085dc:	d11a      	bne.n	8008614 <lv_obj_readjust_scroll+0x4e>
        int32_t st = lv_obj_get_scroll_top(obj);
 80085de:	6878      	ldr	r0, [r7, #4]
 80085e0:	f7fe ff54 	bl	800748c <lv_obj_get_scroll_top>
 80085e4:	6178      	str	r0, [r7, #20]
        int32_t sb = lv_obj_get_scroll_bottom(obj);
 80085e6:	6878      	ldr	r0, [r7, #4]
 80085e8:	f7fe ff64 	bl	80074b4 <lv_obj_get_scroll_bottom>
 80085ec:	6138      	str	r0, [r7, #16]
        if(sb < 0 && st > 0) {
 80085ee:	693b      	ldr	r3, [r7, #16]
 80085f0:	2b00      	cmp	r3, #0
 80085f2:	da0f      	bge.n	8008614 <lv_obj_readjust_scroll+0x4e>
 80085f4:	697b      	ldr	r3, [r7, #20]
 80085f6:	2b00      	cmp	r3, #0
 80085f8:	dd0c      	ble.n	8008614 <lv_obj_readjust_scroll+0x4e>
            sb = LV_MIN(st, -sb);
 80085fa:	693b      	ldr	r3, [r7, #16]
 80085fc:	425b      	negs	r3, r3
 80085fe:	697a      	ldr	r2, [r7, #20]
 8008600:	4293      	cmp	r3, r2
 8008602:	bfa8      	it	ge
 8008604:	4613      	movge	r3, r2
 8008606:	613b      	str	r3, [r7, #16]
            lv_obj_scroll_by(obj, 0, sb, anim_en);
 8008608:	78fb      	ldrb	r3, [r7, #3]
 800860a:	693a      	ldr	r2, [r7, #16]
 800860c:	2100      	movs	r1, #0
 800860e:	6878      	ldr	r0, [r7, #4]
 8008610:	f7ff f964 	bl	80078dc <lv_obj_scroll_by>
        }
    }

    if(lv_obj_get_scroll_snap_x(obj) == LV_SCROLL_SNAP_NONE) {
 8008614:	6878      	ldr	r0, [r7, #4]
 8008616:	f7fe fee3 	bl	80073e0 <lv_obj_get_scroll_snap_x>
 800861a:	4603      	mov	r3, r0
 800861c:	2b00      	cmp	r3, #0
 800861e:	d135      	bne.n	800868c <lv_obj_readjust_scroll+0xc6>
        int32_t sl = lv_obj_get_scroll_left(obj);
 8008620:	6878      	ldr	r0, [r7, #4]
 8008622:	f7fe ffb3 	bl	800758c <lv_obj_get_scroll_left>
 8008626:	60f8      	str	r0, [r7, #12]
        int32_t sr = lv_obj_get_scroll_right(obj);
 8008628:	6878      	ldr	r0, [r7, #4]
 800862a:	f7ff f837 	bl	800769c <lv_obj_get_scroll_right>
 800862e:	60b8      	str	r0, [r7, #8]
        if(lv_obj_get_style_base_dir(obj, LV_PART_MAIN) != LV_BASE_DIR_RTL) {
 8008630:	2100      	movs	r1, #0
 8008632:	6878      	ldr	r0, [r7, #4]
 8008634:	f7fe fe09 	bl	800724a <lv_obj_get_style_base_dir>
 8008638:	4603      	mov	r3, r0
 800863a:	2b01      	cmp	r3, #1
 800863c:	d013      	beq.n	8008666 <lv_obj_readjust_scroll+0xa0>
            /*Be sure the left side is not remains scrolled in*/
            if(sr < 0 && sl > 0) {
 800863e:	68bb      	ldr	r3, [r7, #8]
 8008640:	2b00      	cmp	r3, #0
 8008642:	da23      	bge.n	800868c <lv_obj_readjust_scroll+0xc6>
 8008644:	68fb      	ldr	r3, [r7, #12]
 8008646:	2b00      	cmp	r3, #0
 8008648:	dd20      	ble.n	800868c <lv_obj_readjust_scroll+0xc6>
                sr = LV_MIN(sl, -sr);
 800864a:	68bb      	ldr	r3, [r7, #8]
 800864c:	425b      	negs	r3, r3
 800864e:	68fa      	ldr	r2, [r7, #12]
 8008650:	4293      	cmp	r3, r2
 8008652:	bfa8      	it	ge
 8008654:	4613      	movge	r3, r2
 8008656:	60bb      	str	r3, [r7, #8]
                lv_obj_scroll_by(obj, sr, 0, anim_en);
 8008658:	78fb      	ldrb	r3, [r7, #3]
 800865a:	2200      	movs	r2, #0
 800865c:	68b9      	ldr	r1, [r7, #8]
 800865e:	6878      	ldr	r0, [r7, #4]
 8008660:	f7ff f93c 	bl	80078dc <lv_obj_scroll_by>
                sr = LV_MIN(sr, -sl);
                lv_obj_scroll_by(obj, sl, 0, anim_en);
            }
        }
    }
}
 8008664:	e012      	b.n	800868c <lv_obj_readjust_scroll+0xc6>
            if(sl < 0 && sr > 0) {
 8008666:	68fb      	ldr	r3, [r7, #12]
 8008668:	2b00      	cmp	r3, #0
 800866a:	da0f      	bge.n	800868c <lv_obj_readjust_scroll+0xc6>
 800866c:	68bb      	ldr	r3, [r7, #8]
 800866e:	2b00      	cmp	r3, #0
 8008670:	dd0c      	ble.n	800868c <lv_obj_readjust_scroll+0xc6>
                sr = LV_MIN(sr, -sl);
 8008672:	68fb      	ldr	r3, [r7, #12]
 8008674:	425b      	negs	r3, r3
 8008676:	68ba      	ldr	r2, [r7, #8]
 8008678:	4293      	cmp	r3, r2
 800867a:	bfa8      	it	ge
 800867c:	4613      	movge	r3, r2
 800867e:	60bb      	str	r3, [r7, #8]
                lv_obj_scroll_by(obj, sl, 0, anim_en);
 8008680:	78fb      	ldrb	r3, [r7, #3]
 8008682:	2200      	movs	r2, #0
 8008684:	68f9      	ldr	r1, [r7, #12]
 8008686:	6878      	ldr	r0, [r7, #4]
 8008688:	f7ff f928 	bl	80078dc <lv_obj_scroll_by>
}
 800868c:	bf00      	nop
 800868e:	3718      	adds	r7, #24
 8008690:	46bd      	mov	sp, r7
 8008692:	bd80      	pop	{r7, pc}

08008694 <scroll_x_anim>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void scroll_x_anim(void * obj, int32_t v)
{
 8008694:	b580      	push	{r7, lr}
 8008696:	b082      	sub	sp, #8
 8008698:	af00      	add	r7, sp, #0
 800869a:	6078      	str	r0, [r7, #4]
 800869c:	6039      	str	r1, [r7, #0]
    _lv_obj_scroll_by_raw(obj, v + lv_obj_get_scroll_x(obj), 0);
 800869e:	6878      	ldr	r0, [r7, #4]
 80086a0:	f7fe fecc 	bl	800743c <lv_obj_get_scroll_x>
 80086a4:	4602      	mov	r2, r0
 80086a6:	683b      	ldr	r3, [r7, #0]
 80086a8:	4413      	add	r3, r2
 80086aa:	2200      	movs	r2, #0
 80086ac:	4619      	mov	r1, r3
 80086ae:	6878      	ldr	r0, [r7, #4]
 80086b0:	f7ff fa6f 	bl	8007b92 <_lv_obj_scroll_by_raw>
}
 80086b4:	bf00      	nop
 80086b6:	3708      	adds	r7, #8
 80086b8:	46bd      	mov	sp, r7
 80086ba:	bd80      	pop	{r7, pc}

080086bc <scroll_y_anim>:

static void scroll_y_anim(void * obj, int32_t v)
{
 80086bc:	b580      	push	{r7, lr}
 80086be:	b082      	sub	sp, #8
 80086c0:	af00      	add	r7, sp, #0
 80086c2:	6078      	str	r0, [r7, #4]
 80086c4:	6039      	str	r1, [r7, #0]
    _lv_obj_scroll_by_raw(obj, 0, v + lv_obj_get_scroll_y(obj));
 80086c6:	6878      	ldr	r0, [r7, #4]
 80086c8:	f7fe fecc 	bl	8007464 <lv_obj_get_scroll_y>
 80086cc:	4602      	mov	r2, r0
 80086ce:	683b      	ldr	r3, [r7, #0]
 80086d0:	4413      	add	r3, r2
 80086d2:	461a      	mov	r2, r3
 80086d4:	2100      	movs	r1, #0
 80086d6:	6878      	ldr	r0, [r7, #4]
 80086d8:	f7ff fa5b 	bl	8007b92 <_lv_obj_scroll_by_raw>
}
 80086dc:	bf00      	nop
 80086de:	3708      	adds	r7, #8
 80086e0:	46bd      	mov	sp, r7
 80086e2:	bd80      	pop	{r7, pc}

080086e4 <scroll_completed_completed_cb>:

static void scroll_completed_completed_cb(lv_anim_t * a)
{
 80086e4:	b580      	push	{r7, lr}
 80086e6:	b082      	sub	sp, #8
 80086e8:	af00      	add	r7, sp, #0
 80086ea:	6078      	str	r0, [r7, #4]
    lv_obj_send_event(a->var, LV_EVENT_SCROLL_END, NULL);
 80086ec:	687b      	ldr	r3, [r7, #4]
 80086ee:	681b      	ldr	r3, [r3, #0]
 80086f0:	2200      	movs	r2, #0
 80086f2:	210b      	movs	r1, #11
 80086f4:	4618      	mov	r0, r3
 80086f6:	f7fc fb8d 	bl	8004e14 <lv_obj_send_event>
}
 80086fa:	bf00      	nop
 80086fc:	3708      	adds	r7, #8
 80086fe:	46bd      	mov	sp, r7
 8008700:	bd80      	pop	{r7, pc}
	...

08008704 <scroll_area_into_view>:

static void scroll_area_into_view(const lv_area_t * area, lv_obj_t * child, lv_point_t * scroll_value,
                                  lv_anim_enable_t anim_en)
{
 8008704:	b580      	push	{r7, lr}
 8008706:	b09c      	sub	sp, #112	@ 0x70
 8008708:	af00      	add	r7, sp, #0
 800870a:	60f8      	str	r0, [r7, #12]
 800870c:	60b9      	str	r1, [r7, #8]
 800870e:	607a      	str	r2, [r7, #4]
 8008710:	70fb      	strb	r3, [r7, #3]
    lv_obj_t * parent = lv_obj_get_parent(child);
 8008712:	68b8      	ldr	r0, [r7, #8]
 8008714:	f002 fb8e 	bl	800ae34 <lv_obj_get_parent>
 8008718:	6638      	str	r0, [r7, #96]	@ 0x60
    if(!lv_obj_has_flag(parent, LV_OBJ_FLAG_SCROLLABLE)) return;
 800871a:	2110      	movs	r1, #16
 800871c:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 800871e:	f7fa fb16 	bl	8002d4e <lv_obj_has_flag>
 8008722:	4603      	mov	r3, r0
 8008724:	f083 0301 	eor.w	r3, r3, #1
 8008728:	b2db      	uxtb	r3, r3
 800872a:	2b00      	cmp	r3, #0
 800872c:	f040 81d3 	bne.w	8008ad6 <scroll_area_into_view+0x3d2>

    lv_dir_t scroll_dir = lv_obj_get_scroll_dir(parent);
 8008730:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8008732:	f7fe fe3f 	bl	80073b4 <lv_obj_get_scroll_dir>
 8008736:	4603      	mov	r3, r0
 8008738:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
    int32_t snap_goal = 0;
 800873c:	2300      	movs	r3, #0
 800873e:	65bb      	str	r3, [r7, #88]	@ 0x58
    int32_t act = 0;
 8008740:	2300      	movs	r3, #0
 8008742:	657b      	str	r3, [r7, #84]	@ 0x54
    const lv_area_t * area_tmp;

    int32_t y_scroll = 0;
 8008744:	2300      	movs	r3, #0
 8008746:	66bb      	str	r3, [r7, #104]	@ 0x68
    lv_scroll_snap_t snap_y = lv_obj_get_scroll_snap_y(parent);
 8008748:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 800874a:	f7fe fe60 	bl	800740e <lv_obj_get_scroll_snap_y>
 800874e:	4603      	mov	r3, r0
 8008750:	f887 3053 	strb.w	r3, [r7, #83]	@ 0x53
    if(snap_y != LV_SCROLL_SNAP_NONE) area_tmp = &child->coords;
 8008754:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 8008758:	2b00      	cmp	r3, #0
 800875a:	d003      	beq.n	8008764 <scroll_area_into_view+0x60>
 800875c:	68bb      	ldr	r3, [r7, #8]
 800875e:	3314      	adds	r3, #20
 8008760:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8008762:	e001      	b.n	8008768 <scroll_area_into_view+0x64>
    else area_tmp = area;
 8008764:	68fb      	ldr	r3, [r7, #12]
 8008766:	66fb      	str	r3, [r7, #108]	@ 0x6c

    int32_t stop = lv_obj_get_style_space_top(parent, LV_PART_MAIN);
 8008768:	2100      	movs	r1, #0
 800876a:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 800876c:	f7fe fdc5 	bl	80072fa <lv_obj_get_style_space_top>
 8008770:	64f8      	str	r0, [r7, #76]	@ 0x4c
    int32_t sbottom = lv_obj_get_style_space_bottom(parent, LV_PART_MAIN);
 8008772:	2100      	movs	r1, #0
 8008774:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8008776:	f7fe fde3 	bl	8007340 <lv_obj_get_style_space_bottom>
 800877a:	64b8      	str	r0, [r7, #72]	@ 0x48
    int32_t top_diff = parent->coords.y1 + stop - area_tmp->y1 - scroll_value->y;
 800877c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800877e:	699a      	ldr	r2, [r3, #24]
 8008780:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8008782:	441a      	add	r2, r3
 8008784:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8008786:	685b      	ldr	r3, [r3, #4]
 8008788:	1ad2      	subs	r2, r2, r3
 800878a:	687b      	ldr	r3, [r7, #4]
 800878c:	685b      	ldr	r3, [r3, #4]
 800878e:	1ad3      	subs	r3, r2, r3
 8008790:	647b      	str	r3, [r7, #68]	@ 0x44
    int32_t bottom_diff = -(parent->coords.y2 - sbottom - area_tmp->y2 - scroll_value->y);
 8008792:	687b      	ldr	r3, [r7, #4]
 8008794:	685a      	ldr	r2, [r3, #4]
 8008796:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008798:	6a19      	ldr	r1, [r3, #32]
 800879a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800879c:	1ac9      	subs	r1, r1, r3
 800879e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80087a0:	68db      	ldr	r3, [r3, #12]
 80087a2:	1acb      	subs	r3, r1, r3
 80087a4:	1ad3      	subs	r3, r2, r3
 80087a6:	643b      	str	r3, [r7, #64]	@ 0x40
    int32_t parent_h = lv_obj_get_height(parent) - stop - sbottom;
 80087a8:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80087aa:	f7fd facf 	bl	8005d4c <lv_obj_get_height>
 80087ae:	4602      	mov	r2, r0
 80087b0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80087b2:	1ad2      	subs	r2, r2, r3
 80087b4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80087b6:	1ad3      	subs	r3, r2, r3
 80087b8:	63fb      	str	r3, [r7, #60]	@ 0x3c
    if((top_diff >= 0 && bottom_diff >= 0)) y_scroll = 0;
 80087ba:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80087bc:	2b00      	cmp	r3, #0
 80087be:	db05      	blt.n	80087cc <scroll_area_into_view+0xc8>
 80087c0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80087c2:	2b00      	cmp	r3, #0
 80087c4:	db02      	blt.n	80087cc <scroll_area_into_view+0xc8>
 80087c6:	2300      	movs	r3, #0
 80087c8:	66bb      	str	r3, [r7, #104]	@ 0x68
 80087ca:	e021      	b.n	8008810 <scroll_area_into_view+0x10c>
    else if(top_diff > 0) {
 80087cc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80087ce:	2b00      	cmp	r3, #0
 80087d0:	dd0d      	ble.n	80087ee <scroll_area_into_view+0xea>
        y_scroll = top_diff;
 80087d2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80087d4:	66bb      	str	r3, [r7, #104]	@ 0x68
        /*Do not let scrolling in*/
        int32_t st = lv_obj_get_scroll_top(parent);
 80087d6:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80087d8:	f7fe fe58 	bl	800748c <lv_obj_get_scroll_top>
 80087dc:	6378      	str	r0, [r7, #52]	@ 0x34
        if(st - y_scroll < 0) y_scroll = 0;
 80087de:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80087e0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80087e2:	1ad3      	subs	r3, r2, r3
 80087e4:	2b00      	cmp	r3, #0
 80087e6:	da13      	bge.n	8008810 <scroll_area_into_view+0x10c>
 80087e8:	2300      	movs	r3, #0
 80087ea:	66bb      	str	r3, [r7, #104]	@ 0x68
 80087ec:	e010      	b.n	8008810 <scroll_area_into_view+0x10c>
    }
    else if(bottom_diff > 0) {
 80087ee:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80087f0:	2b00      	cmp	r3, #0
 80087f2:	dd0d      	ble.n	8008810 <scroll_area_into_view+0x10c>
        y_scroll = -bottom_diff;
 80087f4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80087f6:	425b      	negs	r3, r3
 80087f8:	66bb      	str	r3, [r7, #104]	@ 0x68
        /*Do not let scrolling in*/
        int32_t sb = lv_obj_get_scroll_bottom(parent);
 80087fa:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80087fc:	f7fe fe5a 	bl	80074b4 <lv_obj_get_scroll_bottom>
 8008800:	63b8      	str	r0, [r7, #56]	@ 0x38
        if(sb + y_scroll < 0) y_scroll = 0;
 8008802:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8008804:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8008806:	4413      	add	r3, r2
 8008808:	2b00      	cmp	r3, #0
 800880a:	da01      	bge.n	8008810 <scroll_area_into_view+0x10c>
 800880c:	2300      	movs	r3, #0
 800880e:	66bb      	str	r3, [r7, #104]	@ 0x68
    }

    switch(snap_y) {
 8008810:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 8008814:	2b03      	cmp	r3, #3
 8008816:	d028      	beq.n	800886a <scroll_area_into_view+0x166>
 8008818:	2b03      	cmp	r3, #3
 800881a:	dc45      	bgt.n	80088a8 <scroll_area_into_view+0x1a4>
 800881c:	2b01      	cmp	r3, #1
 800881e:	d002      	beq.n	8008826 <scroll_area_into_view+0x122>
 8008820:	2b02      	cmp	r3, #2
 8008822:	d011      	beq.n	8008848 <scroll_area_into_view+0x144>
 8008824:	e040      	b.n	80088a8 <scroll_area_into_view+0x1a4>
        case LV_SCROLL_SNAP_START:
            snap_goal = parent->coords.y1 + stop;
 8008826:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8008828:	699b      	ldr	r3, [r3, #24]
 800882a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800882c:	4413      	add	r3, r2
 800882e:	65bb      	str	r3, [r7, #88]	@ 0x58
            act = area_tmp->y1 + y_scroll;
 8008830:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8008832:	685b      	ldr	r3, [r3, #4]
 8008834:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8008836:	4413      	add	r3, r2
 8008838:	657b      	str	r3, [r7, #84]	@ 0x54
            y_scroll += snap_goal - act;
 800883a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 800883c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800883e:	1ad3      	subs	r3, r2, r3
 8008840:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8008842:	4413      	add	r3, r2
 8008844:	66bb      	str	r3, [r7, #104]	@ 0x68
            break;
 8008846:	e02f      	b.n	80088a8 <scroll_area_into_view+0x1a4>
        case LV_SCROLL_SNAP_END:
            snap_goal = parent->coords.y2 - sbottom;
 8008848:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800884a:	6a1a      	ldr	r2, [r3, #32]
 800884c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800884e:	1ad3      	subs	r3, r2, r3
 8008850:	65bb      	str	r3, [r7, #88]	@ 0x58
            act = area_tmp->y2 + y_scroll;
 8008852:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8008854:	68db      	ldr	r3, [r3, #12]
 8008856:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8008858:	4413      	add	r3, r2
 800885a:	657b      	str	r3, [r7, #84]	@ 0x54
            y_scroll += snap_goal - act;
 800885c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 800885e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8008860:	1ad3      	subs	r3, r2, r3
 8008862:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8008864:	4413      	add	r3, r2
 8008866:	66bb      	str	r3, [r7, #104]	@ 0x68
            break;
 8008868:	e01e      	b.n	80088a8 <scroll_area_into_view+0x1a4>
        case LV_SCROLL_SNAP_CENTER:
            snap_goal = parent->coords.y1 + stop + parent_h / 2;
 800886a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800886c:	699a      	ldr	r2, [r3, #24]
 800886e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8008870:	441a      	add	r2, r3
 8008872:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8008874:	0fd9      	lsrs	r1, r3, #31
 8008876:	440b      	add	r3, r1
 8008878:	105b      	asrs	r3, r3, #1
 800887a:	4413      	add	r3, r2
 800887c:	65bb      	str	r3, [r7, #88]	@ 0x58
            act = lv_area_get_height(area_tmp) / 2 + area_tmp->y1 + y_scroll;
 800887e:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 8008880:	f7fe fba8 	bl	8006fd4 <lv_area_get_height>
 8008884:	4603      	mov	r3, r0
 8008886:	0fda      	lsrs	r2, r3, #31
 8008888:	4413      	add	r3, r2
 800888a:	105b      	asrs	r3, r3, #1
 800888c:	461a      	mov	r2, r3
 800888e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8008890:	685b      	ldr	r3, [r3, #4]
 8008892:	4413      	add	r3, r2
 8008894:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8008896:	4413      	add	r3, r2
 8008898:	657b      	str	r3, [r7, #84]	@ 0x54
            y_scroll += snap_goal - act;
 800889a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 800889c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800889e:	1ad3      	subs	r3, r2, r3
 80088a0:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80088a2:	4413      	add	r3, r2
 80088a4:	66bb      	str	r3, [r7, #104]	@ 0x68
            break;
 80088a6:	bf00      	nop
    }

    int32_t x_scroll = 0;
 80088a8:	2300      	movs	r3, #0
 80088aa:	667b      	str	r3, [r7, #100]	@ 0x64
    lv_scroll_snap_t snap_x = lv_obj_get_scroll_snap_x(parent);
 80088ac:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80088ae:	f7fe fd97 	bl	80073e0 <lv_obj_get_scroll_snap_x>
 80088b2:	4603      	mov	r3, r0
 80088b4:	f887 3033 	strb.w	r3, [r7, #51]	@ 0x33
    if(snap_x != LV_SCROLL_SNAP_NONE) area_tmp = &child->coords;
 80088b8:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 80088bc:	2b00      	cmp	r3, #0
 80088be:	d003      	beq.n	80088c8 <scroll_area_into_view+0x1c4>
 80088c0:	68bb      	ldr	r3, [r7, #8]
 80088c2:	3314      	adds	r3, #20
 80088c4:	66fb      	str	r3, [r7, #108]	@ 0x6c
 80088c6:	e001      	b.n	80088cc <scroll_area_into_view+0x1c8>
    else area_tmp = area;
 80088c8:	68fb      	ldr	r3, [r7, #12]
 80088ca:	66fb      	str	r3, [r7, #108]	@ 0x6c

    int32_t sleft = lv_obj_get_style_space_left(parent, LV_PART_MAIN);
 80088cc:	2100      	movs	r1, #0
 80088ce:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80088d0:	f7fe fccd 	bl	800726e <lv_obj_get_style_space_left>
 80088d4:	62f8      	str	r0, [r7, #44]	@ 0x2c
    int32_t sright = lv_obj_get_style_space_right(parent, LV_PART_MAIN);
 80088d6:	2100      	movs	r1, #0
 80088d8:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 80088da:	f7fe fceb 	bl	80072b4 <lv_obj_get_style_space_right>
 80088de:	62b8      	str	r0, [r7, #40]	@ 0x28
    int32_t left_diff = parent->coords.x1 + sleft - area_tmp->x1 - scroll_value->x;
 80088e0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80088e2:	695a      	ldr	r2, [r3, #20]
 80088e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80088e6:	441a      	add	r2, r3
 80088e8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80088ea:	681b      	ldr	r3, [r3, #0]
 80088ec:	1ad2      	subs	r2, r2, r3
 80088ee:	687b      	ldr	r3, [r7, #4]
 80088f0:	681b      	ldr	r3, [r3, #0]
 80088f2:	1ad3      	subs	r3, r2, r3
 80088f4:	627b      	str	r3, [r7, #36]	@ 0x24
    int32_t right_diff = -(parent->coords.x2 - sright - area_tmp->x2 - scroll_value->x);
 80088f6:	687b      	ldr	r3, [r7, #4]
 80088f8:	681a      	ldr	r2, [r3, #0]
 80088fa:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80088fc:	69d9      	ldr	r1, [r3, #28]
 80088fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8008900:	1ac9      	subs	r1, r1, r3
 8008902:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8008904:	689b      	ldr	r3, [r3, #8]
 8008906:	1acb      	subs	r3, r1, r3
 8008908:	1ad3      	subs	r3, r2, r3
 800890a:	623b      	str	r3, [r7, #32]
    if((left_diff >= 0 && right_diff >= 0)) x_scroll = 0;
 800890c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800890e:	2b00      	cmp	r3, #0
 8008910:	db05      	blt.n	800891e <scroll_area_into_view+0x21a>
 8008912:	6a3b      	ldr	r3, [r7, #32]
 8008914:	2b00      	cmp	r3, #0
 8008916:	db02      	blt.n	800891e <scroll_area_into_view+0x21a>
 8008918:	2300      	movs	r3, #0
 800891a:	667b      	str	r3, [r7, #100]	@ 0x64
 800891c:	e021      	b.n	8008962 <scroll_area_into_view+0x25e>
    else if(left_diff > 0) {
 800891e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008920:	2b00      	cmp	r3, #0
 8008922:	dd0d      	ble.n	8008940 <scroll_area_into_view+0x23c>
        x_scroll = left_diff;
 8008924:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008926:	667b      	str	r3, [r7, #100]	@ 0x64
        /*Do not let scrolling in*/
        int32_t sl = lv_obj_get_scroll_left(parent);
 8008928:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 800892a:	f7fe fe2f 	bl	800758c <lv_obj_get_scroll_left>
 800892e:	61b8      	str	r0, [r7, #24]
        if(sl - x_scroll < 0) x_scroll = 0;
 8008930:	69ba      	ldr	r2, [r7, #24]
 8008932:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008934:	1ad3      	subs	r3, r2, r3
 8008936:	2b00      	cmp	r3, #0
 8008938:	da13      	bge.n	8008962 <scroll_area_into_view+0x25e>
 800893a:	2300      	movs	r3, #0
 800893c:	667b      	str	r3, [r7, #100]	@ 0x64
 800893e:	e010      	b.n	8008962 <scroll_area_into_view+0x25e>
    }
    else if(right_diff > 0) {
 8008940:	6a3b      	ldr	r3, [r7, #32]
 8008942:	2b00      	cmp	r3, #0
 8008944:	dd0d      	ble.n	8008962 <scroll_area_into_view+0x25e>
        x_scroll = -right_diff;
 8008946:	6a3b      	ldr	r3, [r7, #32]
 8008948:	425b      	negs	r3, r3
 800894a:	667b      	str	r3, [r7, #100]	@ 0x64
        /*Do not let scrolling in*/
        int32_t sr = lv_obj_get_scroll_right(parent);
 800894c:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 800894e:	f7fe fea5 	bl	800769c <lv_obj_get_scroll_right>
 8008952:	61f8      	str	r0, [r7, #28]
        if(sr + x_scroll < 0) x_scroll = 0;
 8008954:	69fa      	ldr	r2, [r7, #28]
 8008956:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008958:	4413      	add	r3, r2
 800895a:	2b00      	cmp	r3, #0
 800895c:	da01      	bge.n	8008962 <scroll_area_into_view+0x25e>
 800895e:	2300      	movs	r3, #0
 8008960:	667b      	str	r3, [r7, #100]	@ 0x64
    }

    int32_t parent_w = lv_obj_get_width(parent) - sleft - sright;
 8008962:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8008964:	f7fd f9e4 	bl	8005d30 <lv_obj_get_width>
 8008968:	4602      	mov	r2, r0
 800896a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800896c:	1ad2      	subs	r2, r2, r3
 800896e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8008970:	1ad3      	subs	r3, r2, r3
 8008972:	617b      	str	r3, [r7, #20]
    switch(snap_x) {
 8008974:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 8008978:	2b03      	cmp	r3, #3
 800897a:	d028      	beq.n	80089ce <scroll_area_into_view+0x2ca>
 800897c:	2b03      	cmp	r3, #3
 800897e:	dc45      	bgt.n	8008a0c <scroll_area_into_view+0x308>
 8008980:	2b01      	cmp	r3, #1
 8008982:	d002      	beq.n	800898a <scroll_area_into_view+0x286>
 8008984:	2b02      	cmp	r3, #2
 8008986:	d011      	beq.n	80089ac <scroll_area_into_view+0x2a8>
 8008988:	e040      	b.n	8008a0c <scroll_area_into_view+0x308>
        case LV_SCROLL_SNAP_START:
            snap_goal = parent->coords.x1 + sleft;
 800898a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800898c:	695b      	ldr	r3, [r3, #20]
 800898e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8008990:	4413      	add	r3, r2
 8008992:	65bb      	str	r3, [r7, #88]	@ 0x58
            act = area_tmp->x1 + x_scroll;
 8008994:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8008996:	681b      	ldr	r3, [r3, #0]
 8008998:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 800899a:	4413      	add	r3, r2
 800899c:	657b      	str	r3, [r7, #84]	@ 0x54
            x_scroll += snap_goal - act;
 800899e:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80089a0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80089a2:	1ad3      	subs	r3, r2, r3
 80089a4:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80089a6:	4413      	add	r3, r2
 80089a8:	667b      	str	r3, [r7, #100]	@ 0x64
            break;
 80089aa:	e02f      	b.n	8008a0c <scroll_area_into_view+0x308>
        case LV_SCROLL_SNAP_END:
            snap_goal = parent->coords.x2 - sright;
 80089ac:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80089ae:	69da      	ldr	r2, [r3, #28]
 80089b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80089b2:	1ad3      	subs	r3, r2, r3
 80089b4:	65bb      	str	r3, [r7, #88]	@ 0x58
            act = area_tmp->x2 + x_scroll;
 80089b6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80089b8:	689b      	ldr	r3, [r3, #8]
 80089ba:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80089bc:	4413      	add	r3, r2
 80089be:	657b      	str	r3, [r7, #84]	@ 0x54
            x_scroll += snap_goal - act;
 80089c0:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80089c2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80089c4:	1ad3      	subs	r3, r2, r3
 80089c6:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80089c8:	4413      	add	r3, r2
 80089ca:	667b      	str	r3, [r7, #100]	@ 0x64
            break;
 80089cc:	e01e      	b.n	8008a0c <scroll_area_into_view+0x308>
        case LV_SCROLL_SNAP_CENTER:
            snap_goal = parent->coords.x1 + sleft + parent_w / 2;
 80089ce:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80089d0:	695a      	ldr	r2, [r3, #20]
 80089d2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80089d4:	441a      	add	r2, r3
 80089d6:	697b      	ldr	r3, [r7, #20]
 80089d8:	0fd9      	lsrs	r1, r3, #31
 80089da:	440b      	add	r3, r1
 80089dc:	105b      	asrs	r3, r3, #1
 80089de:	4413      	add	r3, r2
 80089e0:	65bb      	str	r3, [r7, #88]	@ 0x58
            act = lv_area_get_width(area_tmp) / 2 + area_tmp->x1 + x_scroll;
 80089e2:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 80089e4:	f7fe fae6 	bl	8006fb4 <lv_area_get_width>
 80089e8:	4603      	mov	r3, r0
 80089ea:	0fda      	lsrs	r2, r3, #31
 80089ec:	4413      	add	r3, r2
 80089ee:	105b      	asrs	r3, r3, #1
 80089f0:	461a      	mov	r2, r3
 80089f2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80089f4:	681b      	ldr	r3, [r3, #0]
 80089f6:	4413      	add	r3, r2
 80089f8:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80089fa:	4413      	add	r3, r2
 80089fc:	657b      	str	r3, [r7, #84]	@ 0x54
            x_scroll += snap_goal - act;
 80089fe:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8008a00:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8008a02:	1ad3      	subs	r3, r2, r3
 8008a04:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8008a06:	4413      	add	r3, r2
 8008a08:	667b      	str	r3, [r7, #100]	@ 0x64
            break;
 8008a0a:	bf00      	nop
    }

    /*Remove any pending scroll animations.*/
    bool y_del = lv_anim_delete(parent, scroll_y_anim);
 8008a0c:	4935      	ldr	r1, [pc, #212]	@ (8008ae4 <scroll_area_into_view+0x3e0>)
 8008a0e:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8008a10:	f018 fb34 	bl	802107c <lv_anim_delete>
 8008a14:	4603      	mov	r3, r0
 8008a16:	74fb      	strb	r3, [r7, #19]
    bool x_del = lv_anim_delete(parent, scroll_x_anim);
 8008a18:	4933      	ldr	r1, [pc, #204]	@ (8008ae8 <scroll_area_into_view+0x3e4>)
 8008a1a:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8008a1c:	f018 fb2e 	bl	802107c <lv_anim_delete>
 8008a20:	4603      	mov	r3, r0
 8008a22:	74bb      	strb	r3, [r7, #18]
    if(y_del || x_del) {
 8008a24:	7cfb      	ldrb	r3, [r7, #19]
 8008a26:	2b00      	cmp	r3, #0
 8008a28:	d102      	bne.n	8008a30 <scroll_area_into_view+0x32c>
 8008a2a:	7cbb      	ldrb	r3, [r7, #18]
 8008a2c:	2b00      	cmp	r3, #0
 8008a2e:	d009      	beq.n	8008a44 <scroll_area_into_view+0x340>
        lv_result_t res;
        res = lv_obj_send_event(parent, LV_EVENT_SCROLL_END, NULL);
 8008a30:	2200      	movs	r2, #0
 8008a32:	210b      	movs	r1, #11
 8008a34:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8008a36:	f7fc f9ed 	bl	8004e14 <lv_obj_send_event>
 8008a3a:	4603      	mov	r3, r0
 8008a3c:	747b      	strb	r3, [r7, #17]
        if(res != LV_RESULT_OK) return;
 8008a3e:	7c7b      	ldrb	r3, [r7, #17]
 8008a40:	2b01      	cmp	r3, #1
 8008a42:	d14a      	bne.n	8008ada <scroll_area_into_view+0x3d6>
    }

    if((scroll_dir & LV_DIR_LEFT) == 0 && x_scroll < 0) x_scroll = 0;
 8008a44:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 8008a48:	f003 0301 	and.w	r3, r3, #1
 8008a4c:	2b00      	cmp	r3, #0
 8008a4e:	d104      	bne.n	8008a5a <scroll_area_into_view+0x356>
 8008a50:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008a52:	2b00      	cmp	r3, #0
 8008a54:	da01      	bge.n	8008a5a <scroll_area_into_view+0x356>
 8008a56:	2300      	movs	r3, #0
 8008a58:	667b      	str	r3, [r7, #100]	@ 0x64
    if((scroll_dir & LV_DIR_RIGHT) == 0 && x_scroll > 0) x_scroll = 0;
 8008a5a:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 8008a5e:	f003 0302 	and.w	r3, r3, #2
 8008a62:	2b00      	cmp	r3, #0
 8008a64:	d104      	bne.n	8008a70 <scroll_area_into_view+0x36c>
 8008a66:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008a68:	2b00      	cmp	r3, #0
 8008a6a:	dd01      	ble.n	8008a70 <scroll_area_into_view+0x36c>
 8008a6c:	2300      	movs	r3, #0
 8008a6e:	667b      	str	r3, [r7, #100]	@ 0x64
    if((scroll_dir & LV_DIR_TOP) == 0 && y_scroll < 0) y_scroll = 0;
 8008a70:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 8008a74:	f003 0304 	and.w	r3, r3, #4
 8008a78:	2b00      	cmp	r3, #0
 8008a7a:	d104      	bne.n	8008a86 <scroll_area_into_view+0x382>
 8008a7c:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8008a7e:	2b00      	cmp	r3, #0
 8008a80:	da01      	bge.n	8008a86 <scroll_area_into_view+0x382>
 8008a82:	2300      	movs	r3, #0
 8008a84:	66bb      	str	r3, [r7, #104]	@ 0x68
    if((scroll_dir & LV_DIR_BOTTOM) == 0 && y_scroll > 0) y_scroll = 0;
 8008a86:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 8008a8a:	f003 0308 	and.w	r3, r3, #8
 8008a8e:	2b00      	cmp	r3, #0
 8008a90:	d104      	bne.n	8008a9c <scroll_area_into_view+0x398>
 8008a92:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8008a94:	2b00      	cmp	r3, #0
 8008a96:	dd01      	ble.n	8008a9c <scroll_area_into_view+0x398>
 8008a98:	2300      	movs	r3, #0
 8008a9a:	66bb      	str	r3, [r7, #104]	@ 0x68

    scroll_value->x += anim_en == LV_ANIM_OFF ? 0 : x_scroll;
 8008a9c:	687b      	ldr	r3, [r7, #4]
 8008a9e:	681a      	ldr	r2, [r3, #0]
 8008aa0:	78fb      	ldrb	r3, [r7, #3]
 8008aa2:	2b00      	cmp	r3, #0
 8008aa4:	d001      	beq.n	8008aaa <scroll_area_into_view+0x3a6>
 8008aa6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8008aa8:	e000      	b.n	8008aac <scroll_area_into_view+0x3a8>
 8008aaa:	2300      	movs	r3, #0
 8008aac:	441a      	add	r2, r3
 8008aae:	687b      	ldr	r3, [r7, #4]
 8008ab0:	601a      	str	r2, [r3, #0]
    scroll_value->y += anim_en == LV_ANIM_OFF ? 0 : y_scroll;
 8008ab2:	687b      	ldr	r3, [r7, #4]
 8008ab4:	685a      	ldr	r2, [r3, #4]
 8008ab6:	78fb      	ldrb	r3, [r7, #3]
 8008ab8:	2b00      	cmp	r3, #0
 8008aba:	d001      	beq.n	8008ac0 <scroll_area_into_view+0x3bc>
 8008abc:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8008abe:	e000      	b.n	8008ac2 <scroll_area_into_view+0x3be>
 8008ac0:	2300      	movs	r3, #0
 8008ac2:	441a      	add	r2, r3
 8008ac4:	687b      	ldr	r3, [r7, #4]
 8008ac6:	605a      	str	r2, [r3, #4]
    lv_obj_scroll_by(parent, x_scroll, y_scroll, anim_en);
 8008ac8:	78fb      	ldrb	r3, [r7, #3]
 8008aca:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8008acc:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 8008ace:	6e38      	ldr	r0, [r7, #96]	@ 0x60
 8008ad0:	f7fe ff04 	bl	80078dc <lv_obj_scroll_by>
 8008ad4:	e002      	b.n	8008adc <scroll_area_into_view+0x3d8>
    if(!lv_obj_has_flag(parent, LV_OBJ_FLAG_SCROLLABLE)) return;
 8008ad6:	bf00      	nop
 8008ad8:	e000      	b.n	8008adc <scroll_area_into_view+0x3d8>
        if(res != LV_RESULT_OK) return;
 8008ada:	bf00      	nop
}
 8008adc:	3770      	adds	r7, #112	@ 0x70
 8008ade:	46bd      	mov	sp, r7
 8008ae0:	bd80      	pop	{r7, pc}
 8008ae2:	bf00      	nop
 8008ae4:	080086bd 	.word	0x080086bd
 8008ae8:	08008695 	.word	0x08008695

08008aec <lv_color_to_int>:
 * Convert an RGB888 color to an integer
 * @param c     an RGB888 color
 * @return      `c` as an integer
 */
static inline uint32_t lv_color_to_int(lv_color_t c)
{
 8008aec:	b480      	push	{r7}
 8008aee:	b085      	sub	sp, #20
 8008af0:	af00      	add	r7, sp, #0
 8008af2:	6078      	str	r0, [r7, #4]
    uint8_t * tmp = (uint8_t *) &c;
 8008af4:	1d3b      	adds	r3, r7, #4
 8008af6:	60fb      	str	r3, [r7, #12]
    return tmp[0] + (tmp[1] << 8) + (tmp[2] << 16);
 8008af8:	68fb      	ldr	r3, [r7, #12]
 8008afa:	781b      	ldrb	r3, [r3, #0]
 8008afc:	461a      	mov	r2, r3
 8008afe:	68fb      	ldr	r3, [r7, #12]
 8008b00:	3301      	adds	r3, #1
 8008b02:	781b      	ldrb	r3, [r3, #0]
 8008b04:	021b      	lsls	r3, r3, #8
 8008b06:	441a      	add	r2, r3
 8008b08:	68fb      	ldr	r3, [r7, #12]
 8008b0a:	3302      	adds	r3, #2
 8008b0c:	781b      	ldrb	r3, [r3, #0]
 8008b0e:	041b      	lsls	r3, r3, #16
 8008b10:	4413      	add	r3, r2
}
 8008b12:	4618      	mov	r0, r3
 8008b14:	3714      	adds	r7, #20
 8008b16:	46bd      	mov	sp, r7
 8008b18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b1c:	4770      	bx	lr

08008b1e <lv_color_eq>:
 * @param c1    the first color
 * @param c2    the second color
 * @return      true: equal
 */
static inline bool lv_color_eq(lv_color_t c1, lv_color_t c2)
{
 8008b1e:	b590      	push	{r4, r7, lr}
 8008b20:	b083      	sub	sp, #12
 8008b22:	af00      	add	r7, sp, #0
 8008b24:	6078      	str	r0, [r7, #4]
 8008b26:	6039      	str	r1, [r7, #0]
    return lv_color_to_int(c1) == lv_color_to_int(c2);
 8008b28:	6878      	ldr	r0, [r7, #4]
 8008b2a:	f7ff ffdf 	bl	8008aec <lv_color_to_int>
 8008b2e:	4604      	mov	r4, r0
 8008b30:	6838      	ldr	r0, [r7, #0]
 8008b32:	f7ff ffdb 	bl	8008aec <lv_color_to_int>
 8008b36:	4603      	mov	r3, r0
 8008b38:	429c      	cmp	r4, r3
 8008b3a:	bf0c      	ite	eq
 8008b3c:	2301      	moveq	r3, #1
 8008b3e:	2300      	movne	r3, #0
 8008b40:	b2db      	uxtb	r3, r3
}
 8008b42:	4618      	mov	r0, r3
 8008b44:	370c      	adds	r7, #12
 8008b46:	46bd      	mov	sp, r7
 8008b48:	bd90      	pop	{r4, r7, pc}

08008b4a <lv_color_mix>:
 * @param c2 the second color to mix (usually the background)
 * @param mix The ratio of the colors. 0: full `c2`, 255: full `c1`, 127: half `c1` and half`c2`
 * @return the mixed color
 */
static inline lv_color_t LV_ATTRIBUTE_FAST_MEM lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
 8008b4a:	b480      	push	{r7}
 8008b4c:	b087      	sub	sp, #28
 8008b4e:	af00      	add	r7, sp, #0
 8008b50:	60f8      	str	r0, [r7, #12]
 8008b52:	60b9      	str	r1, [r7, #8]
 8008b54:	4613      	mov	r3, r2
 8008b56:	71fb      	strb	r3, [r7, #7]
    lv_color_t ret;

    ret.red = LV_UDIV255((uint16_t)c1.red * mix + c2.red * (255 - mix) + LV_COLOR_MIX_ROUND_OFS);
 8008b58:	7bbb      	ldrb	r3, [r7, #14]
 8008b5a:	461a      	mov	r2, r3
 8008b5c:	79fb      	ldrb	r3, [r7, #7]
 8008b5e:	fb03 f202 	mul.w	r2, r3, r2
 8008b62:	7abb      	ldrb	r3, [r7, #10]
 8008b64:	4619      	mov	r1, r3
 8008b66:	79fb      	ldrb	r3, [r7, #7]
 8008b68:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 8008b6c:	fb01 f303 	mul.w	r3, r1, r3
 8008b70:	4413      	add	r3, r2
 8008b72:	461a      	mov	r2, r3
 8008b74:	4613      	mov	r3, r2
 8008b76:	021b      	lsls	r3, r3, #8
 8008b78:	4413      	add	r3, r2
 8008b7a:	01db      	lsls	r3, r3, #7
 8008b7c:	4413      	add	r3, r2
 8008b7e:	0ddb      	lsrs	r3, r3, #23
 8008b80:	b2db      	uxtb	r3, r3
 8008b82:	74bb      	strb	r3, [r7, #18]
    ret.green = LV_UDIV255((uint16_t)c1.green * mix + c2.green * (255 - mix) + LV_COLOR_MIX_ROUND_OFS);
 8008b84:	7b7b      	ldrb	r3, [r7, #13]
 8008b86:	461a      	mov	r2, r3
 8008b88:	79fb      	ldrb	r3, [r7, #7]
 8008b8a:	fb03 f202 	mul.w	r2, r3, r2
 8008b8e:	7a7b      	ldrb	r3, [r7, #9]
 8008b90:	4619      	mov	r1, r3
 8008b92:	79fb      	ldrb	r3, [r7, #7]
 8008b94:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 8008b98:	fb01 f303 	mul.w	r3, r1, r3
 8008b9c:	4413      	add	r3, r2
 8008b9e:	461a      	mov	r2, r3
 8008ba0:	4613      	mov	r3, r2
 8008ba2:	021b      	lsls	r3, r3, #8
 8008ba4:	4413      	add	r3, r2
 8008ba6:	01db      	lsls	r3, r3, #7
 8008ba8:	4413      	add	r3, r2
 8008baa:	0ddb      	lsrs	r3, r3, #23
 8008bac:	b2db      	uxtb	r3, r3
 8008bae:	747b      	strb	r3, [r7, #17]
    ret.blue = LV_UDIV255((uint16_t)c1.blue * mix + c2.blue * (255 - mix) + LV_COLOR_MIX_ROUND_OFS);
 8008bb0:	7b3b      	ldrb	r3, [r7, #12]
 8008bb2:	461a      	mov	r2, r3
 8008bb4:	79fb      	ldrb	r3, [r7, #7]
 8008bb6:	fb03 f202 	mul.w	r2, r3, r2
 8008bba:	7a3b      	ldrb	r3, [r7, #8]
 8008bbc:	4619      	mov	r1, r3
 8008bbe:	79fb      	ldrb	r3, [r7, #7]
 8008bc0:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 8008bc4:	fb01 f303 	mul.w	r3, r1, r3
 8008bc8:	4413      	add	r3, r2
 8008bca:	461a      	mov	r2, r3
 8008bcc:	4613      	mov	r3, r2
 8008bce:	021b      	lsls	r3, r3, #8
 8008bd0:	4413      	add	r3, r2
 8008bd2:	01db      	lsls	r3, r3, #7
 8008bd4:	4413      	add	r3, r2
 8008bd6:	0ddb      	lsrs	r3, r3, #23
 8008bd8:	b2db      	uxtb	r3, r3
 8008bda:	743b      	strb	r3, [r7, #16]
    return ret;
 8008bdc:	f107 0314 	add.w	r3, r7, #20
 8008be0:	f107 0210 	add.w	r2, r7, #16
 8008be4:	6812      	ldr	r2, [r2, #0]
 8008be6:	4611      	mov	r1, r2
 8008be8:	8019      	strh	r1, [r3, #0]
 8008bea:	3302      	adds	r3, #2
 8008bec:	0c12      	lsrs	r2, r2, #16
 8008bee:	701a      	strb	r2, [r3, #0]
 8008bf0:	2300      	movs	r3, #0
 8008bf2:	7d3a      	ldrb	r2, [r7, #20]
 8008bf4:	f362 0307 	bfi	r3, r2, #0, #8
 8008bf8:	7d7a      	ldrb	r2, [r7, #21]
 8008bfa:	f362 230f 	bfi	r3, r2, #8, #8
 8008bfe:	7dba      	ldrb	r2, [r7, #22]
 8008c00:	f362 4317 	bfi	r3, r2, #16, #8
}
 8008c04:	4618      	mov	r0, r3
 8008c06:	371c      	adds	r7, #28
 8008c08:	46bd      	mov	sp, r7
 8008c0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c0e:	4770      	bx	lr

08008c10 <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 8008c10:	b580      	push	{r7, lr}
 8008c12:	b082      	sub	sp, #8
 8008c14:	af00      	add	r7, sp, #0
 8008c16:	6078      	str	r0, [r7, #4]
 8008c18:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 8008c1a:	683a      	ldr	r2, [r7, #0]
 8008c1c:	2100      	movs	r1, #0
 8008c1e:	6878      	ldr	r0, [r7, #4]
 8008c20:	f01c f8ff 	bl	8024e22 <lv_memset>
}
 8008c24:	bf00      	nop
 8008c26:	3708      	adds	r7, #8
 8008c28:	46bd      	mov	sp, r7
 8008c2a:	bd80      	pop	{r7, pc}

08008c2c <lv_anim_set_var>:
{
 8008c2c:	b480      	push	{r7}
 8008c2e:	b083      	sub	sp, #12
 8008c30:	af00      	add	r7, sp, #0
 8008c32:	6078      	str	r0, [r7, #4]
 8008c34:	6039      	str	r1, [r7, #0]
    a->var = var;
 8008c36:	687b      	ldr	r3, [r7, #4]
 8008c38:	683a      	ldr	r2, [r7, #0]
 8008c3a:	601a      	str	r2, [r3, #0]
}
 8008c3c:	bf00      	nop
 8008c3e:	370c      	adds	r7, #12
 8008c40:	46bd      	mov	sp, r7
 8008c42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c46:	4770      	bx	lr

08008c48 <lv_anim_set_exec_cb>:
{
 8008c48:	b480      	push	{r7}
 8008c4a:	b083      	sub	sp, #12
 8008c4c:	af00      	add	r7, sp, #0
 8008c4e:	6078      	str	r0, [r7, #4]
 8008c50:	6039      	str	r1, [r7, #0]
    a->exec_cb = exec_cb;
 8008c52:	687b      	ldr	r3, [r7, #4]
 8008c54:	683a      	ldr	r2, [r7, #0]
 8008c56:	605a      	str	r2, [r3, #4]
}
 8008c58:	bf00      	nop
 8008c5a:	370c      	adds	r7, #12
 8008c5c:	46bd      	mov	sp, r7
 8008c5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c62:	4770      	bx	lr

08008c64 <lv_anim_set_duration>:
{
 8008c64:	b480      	push	{r7}
 8008c66:	b083      	sub	sp, #12
 8008c68:	af00      	add	r7, sp, #0
 8008c6a:	6078      	str	r0, [r7, #4]
 8008c6c:	6039      	str	r1, [r7, #0]
    a->duration = duration;
 8008c6e:	683a      	ldr	r2, [r7, #0]
 8008c70:	687b      	ldr	r3, [r7, #4]
 8008c72:	631a      	str	r2, [r3, #48]	@ 0x30
}
 8008c74:	bf00      	nop
 8008c76:	370c      	adds	r7, #12
 8008c78:	46bd      	mov	sp, r7
 8008c7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c7e:	4770      	bx	lr

08008c80 <lv_anim_set_delay>:
{
 8008c80:	b480      	push	{r7}
 8008c82:	b083      	sub	sp, #12
 8008c84:	af00      	add	r7, sp, #0
 8008c86:	6078      	str	r0, [r7, #4]
 8008c88:	6039      	str	r1, [r7, #0]
    a->act_time = -(int32_t)(delay);
 8008c8a:	683b      	ldr	r3, [r7, #0]
 8008c8c:	425a      	negs	r2, r3
 8008c8e:	687b      	ldr	r3, [r7, #4]
 8008c90:	635a      	str	r2, [r3, #52]	@ 0x34
}
 8008c92:	bf00      	nop
 8008c94:	370c      	adds	r7, #12
 8008c96:	46bd      	mov	sp, r7
 8008c98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c9c:	4770      	bx	lr

08008c9e <lv_anim_set_values>:
{
 8008c9e:	b480      	push	{r7}
 8008ca0:	b085      	sub	sp, #20
 8008ca2:	af00      	add	r7, sp, #0
 8008ca4:	60f8      	str	r0, [r7, #12]
 8008ca6:	60b9      	str	r1, [r7, #8]
 8008ca8:	607a      	str	r2, [r7, #4]
    a->start_value = start;
 8008caa:	68fb      	ldr	r3, [r7, #12]
 8008cac:	68ba      	ldr	r2, [r7, #8]
 8008cae:	625a      	str	r2, [r3, #36]	@ 0x24
    a->current_value = INT32_MIN;
 8008cb0:	68fb      	ldr	r3, [r7, #12]
 8008cb2:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
 8008cb6:	629a      	str	r2, [r3, #40]	@ 0x28
    a->end_value = end;
 8008cb8:	68fb      	ldr	r3, [r7, #12]
 8008cba:	687a      	ldr	r2, [r7, #4]
 8008cbc:	62da      	str	r2, [r3, #44]	@ 0x2c
}
 8008cbe:	bf00      	nop
 8008cc0:	3714      	adds	r7, #20
 8008cc2:	46bd      	mov	sp, r7
 8008cc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008cc8:	4770      	bx	lr

08008cca <lv_anim_set_path_cb>:
{
 8008cca:	b480      	push	{r7}
 8008ccc:	b083      	sub	sp, #12
 8008cce:	af00      	add	r7, sp, #0
 8008cd0:	6078      	str	r0, [r7, #4]
 8008cd2:	6039      	str	r1, [r7, #0]
    a->path_cb = path_cb;
 8008cd4:	687b      	ldr	r3, [r7, #4]
 8008cd6:	683a      	ldr	r2, [r7, #0]
 8008cd8:	621a      	str	r2, [r3, #32]
}
 8008cda:	bf00      	nop
 8008cdc:	370c      	adds	r7, #12
 8008cde:	46bd      	mov	sp, r7
 8008ce0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ce4:	4770      	bx	lr

08008ce6 <lv_anim_set_start_cb>:
{
 8008ce6:	b480      	push	{r7}
 8008ce8:	b083      	sub	sp, #12
 8008cea:	af00      	add	r7, sp, #0
 8008cec:	6078      	str	r0, [r7, #4]
 8008cee:	6039      	str	r1, [r7, #0]
    a->start_cb = start_cb;
 8008cf0:	687b      	ldr	r3, [r7, #4]
 8008cf2:	683a      	ldr	r2, [r7, #0]
 8008cf4:	60da      	str	r2, [r3, #12]
}
 8008cf6:	bf00      	nop
 8008cf8:	370c      	adds	r7, #12
 8008cfa:	46bd      	mov	sp, r7
 8008cfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d00:	4770      	bx	lr

08008d02 <lv_anim_set_completed_cb>:
{
 8008d02:	b480      	push	{r7}
 8008d04:	b083      	sub	sp, #12
 8008d06:	af00      	add	r7, sp, #0
 8008d08:	6078      	str	r0, [r7, #4]
 8008d0a:	6039      	str	r1, [r7, #0]
    a->completed_cb = completed_cb;
 8008d0c:	687b      	ldr	r3, [r7, #4]
 8008d0e:	683a      	ldr	r2, [r7, #0]
 8008d10:	611a      	str	r2, [r3, #16]
}
 8008d12:	bf00      	nop
 8008d14:	370c      	adds	r7, #12
 8008d16:	46bd      	mov	sp, r7
 8008d18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d1c:	4770      	bx	lr

08008d1e <lv_anim_set_early_apply>:
 * @param a         pointer to an initialized `lv_anim_t` variable
 * @param en        true: apply the start value immediately in `lv_anim_start`;
 *                  false: apply the start value only when `delay` ms is elapsed and the animations really starts
 */
static inline void lv_anim_set_early_apply(lv_anim_t * a, bool en)
{
 8008d1e:	b480      	push	{r7}
 8008d20:	b083      	sub	sp, #12
 8008d22:	af00      	add	r7, sp, #0
 8008d24:	6078      	str	r0, [r7, #4]
 8008d26:	460b      	mov	r3, r1
 8008d28:	70fb      	strb	r3, [r7, #3]
    a->early_apply = en;
 8008d2a:	687a      	ldr	r2, [r7, #4]
 8008d2c:	f892 304e 	ldrb.w	r3, [r2, #78]	@ 0x4e
 8008d30:	78f9      	ldrb	r1, [r7, #3]
 8008d32:	f361 0300 	bfi	r3, r1, #0, #1
 8008d36:	f882 304e 	strb.w	r3, [r2, #78]	@ 0x4e
}
 8008d3a:	bf00      	nop
 8008d3c:	370c      	adds	r7, #12
 8008d3e:	46bd      	mov	sp, r7
 8008d40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d44:	4770      	bx	lr

08008d46 <lv_anim_set_user_data>:
 * Set the custom user data field of the animation.
 * @param a           pointer to an initialized `lv_anim_t` variable
 * @param user_data   pointer to the new user_data.
 */
static inline void lv_anim_set_user_data(lv_anim_t * a, void * user_data)
{
 8008d46:	b480      	push	{r7}
 8008d48:	b083      	sub	sp, #12
 8008d4a:	af00      	add	r7, sp, #0
 8008d4c:	6078      	str	r0, [r7, #4]
 8008d4e:	6039      	str	r1, [r7, #0]
    a->user_data = user_data;
 8008d50:	687b      	ldr	r3, [r7, #4]
 8008d52:	683a      	ldr	r2, [r7, #0]
 8008d54:	61da      	str	r2, [r3, #28]
}
 8008d56:	bf00      	nop
 8008d58:	370c      	adds	r7, #12
 8008d5a:	46bd      	mov	sp, r7
 8008d5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d60:	4770      	bx	lr

08008d62 <lv_bidi_calculate_align>:
 * @param align     For LV_TEXT_ALIGN_AUTO give LV_TEXT_ALIGN_LEFT else leave unchanged, write back the calculated align here
 * @param base_dir  Unused
 * @param txt       Unused
 */
static inline void lv_bidi_calculate_align(lv_text_align_t * align, lv_base_dir_t * base_dir, const char * txt)
{
 8008d62:	b480      	push	{r7}
 8008d64:	b085      	sub	sp, #20
 8008d66:	af00      	add	r7, sp, #0
 8008d68:	60f8      	str	r0, [r7, #12]
 8008d6a:	60b9      	str	r1, [r7, #8]
 8008d6c:	607a      	str	r2, [r7, #4]
    LV_UNUSED(txt);
    LV_UNUSED(base_dir);
    if(*align == LV_TEXT_ALIGN_AUTO) * align = LV_TEXT_ALIGN_LEFT;
 8008d6e:	68fb      	ldr	r3, [r7, #12]
 8008d70:	781b      	ldrb	r3, [r3, #0]
 8008d72:	2b00      	cmp	r3, #0
 8008d74:	d102      	bne.n	8008d7c <lv_bidi_calculate_align+0x1a>
 8008d76:	68fb      	ldr	r3, [r7, #12]
 8008d78:	2201      	movs	r2, #1
 8008d7a:	701a      	strb	r2, [r3, #0]
}
 8008d7c:	bf00      	nop
 8008d7e:	3714      	adds	r7, #20
 8008d80:	46bd      	mov	sp, r7
 8008d82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d86:	4770      	bx	lr

08008d88 <lv_style_is_const>:
{
 8008d88:	b480      	push	{r7}
 8008d8a:	b083      	sub	sp, #12
 8008d8c:	af00      	add	r7, sp, #0
 8008d8e:	6078      	str	r0, [r7, #4]
    if(style->prop_cnt == 255) return true;
 8008d90:	687b      	ldr	r3, [r7, #4]
 8008d92:	7a1b      	ldrb	r3, [r3, #8]
 8008d94:	2bff      	cmp	r3, #255	@ 0xff
 8008d96:	d101      	bne.n	8008d9c <lv_style_is_const+0x14>
 8008d98:	2301      	movs	r3, #1
 8008d9a:	e000      	b.n	8008d9e <lv_style_is_const+0x16>
    return false;
 8008d9c:	2300      	movs	r3, #0
}
 8008d9e:	4618      	mov	r0, r3
 8008da0:	370c      	adds	r7, #12
 8008da2:	46bd      	mov	sp, r7
 8008da4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008da8:	4770      	bx	lr

08008daa <lv_style_get_prop_inlined>:
{
 8008daa:	b580      	push	{r7, lr}
 8008dac:	b08a      	sub	sp, #40	@ 0x28
 8008dae:	af00      	add	r7, sp, #0
 8008db0:	60f8      	str	r0, [r7, #12]
 8008db2:	460b      	mov	r3, r1
 8008db4:	607a      	str	r2, [r7, #4]
 8008db6:	72fb      	strb	r3, [r7, #11]
    if(lv_style_is_const(style)) {
 8008db8:	68f8      	ldr	r0, [r7, #12]
 8008dba:	f7ff ffe5 	bl	8008d88 <lv_style_is_const>
 8008dbe:	4603      	mov	r3, r0
 8008dc0:	2b00      	cmp	r3, #0
 8008dc2:	d022      	beq.n	8008e0a <lv_style_get_prop_inlined+0x60>
        lv_style_const_prop_t * props = (lv_style_const_prop_t *)style->values_and_props;
 8008dc4:	68fb      	ldr	r3, [r7, #12]
 8008dc6:	681b      	ldr	r3, [r3, #0]
 8008dc8:	617b      	str	r3, [r7, #20]
        for(i = 0; props[i].prop_ptr; i++) {
 8008dca:	2300      	movs	r3, #0
 8008dcc:	627b      	str	r3, [r7, #36]	@ 0x24
 8008dce:	e014      	b.n	8008dfa <lv_style_get_prop_inlined+0x50>
            if(*props[i].prop_ptr == prop) {
 8008dd0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008dd2:	00db      	lsls	r3, r3, #3
 8008dd4:	697a      	ldr	r2, [r7, #20]
 8008dd6:	4413      	add	r3, r2
 8008dd8:	681b      	ldr	r3, [r3, #0]
 8008dda:	781b      	ldrb	r3, [r3, #0]
 8008ddc:	7afa      	ldrb	r2, [r7, #11]
 8008dde:	429a      	cmp	r2, r3
 8008de0:	d108      	bne.n	8008df4 <lv_style_get_prop_inlined+0x4a>
                *value = props[i].value;
 8008de2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008de4:	00db      	lsls	r3, r3, #3
 8008de6:	697a      	ldr	r2, [r7, #20]
 8008de8:	441a      	add	r2, r3
 8008dea:	687b      	ldr	r3, [r7, #4]
 8008dec:	6852      	ldr	r2, [r2, #4]
 8008dee:	601a      	str	r2, [r3, #0]
                return LV_STYLE_RES_FOUND;
 8008df0:	2301      	movs	r3, #1
 8008df2:	e031      	b.n	8008e58 <lv_style_get_prop_inlined+0xae>
        for(i = 0; props[i].prop_ptr; i++) {
 8008df4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008df6:	3301      	adds	r3, #1
 8008df8:	627b      	str	r3, [r7, #36]	@ 0x24
 8008dfa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8008dfc:	00db      	lsls	r3, r3, #3
 8008dfe:	697a      	ldr	r2, [r7, #20]
 8008e00:	4413      	add	r3, r2
 8008e02:	681b      	ldr	r3, [r3, #0]
 8008e04:	2b00      	cmp	r3, #0
 8008e06:	d1e3      	bne.n	8008dd0 <lv_style_get_prop_inlined+0x26>
 8008e08:	e025      	b.n	8008e56 <lv_style_get_prop_inlined+0xac>
        lv_style_prop_t * props = (lv_style_prop_t *)style->values_and_props + style->prop_cnt * sizeof(lv_style_value_t);
 8008e0a:	68fb      	ldr	r3, [r7, #12]
 8008e0c:	681a      	ldr	r2, [r3, #0]
 8008e0e:	68fb      	ldr	r3, [r7, #12]
 8008e10:	7a1b      	ldrb	r3, [r3, #8]
 8008e12:	009b      	lsls	r3, r3, #2
 8008e14:	4413      	add	r3, r2
 8008e16:	61fb      	str	r3, [r7, #28]
        for(i = 0; i < style->prop_cnt; i++) {
 8008e18:	2300      	movs	r3, #0
 8008e1a:	623b      	str	r3, [r7, #32]
 8008e1c:	e015      	b.n	8008e4a <lv_style_get_prop_inlined+0xa0>
            if(props[i] == prop) {
 8008e1e:	69fa      	ldr	r2, [r7, #28]
 8008e20:	6a3b      	ldr	r3, [r7, #32]
 8008e22:	4413      	add	r3, r2
 8008e24:	781b      	ldrb	r3, [r3, #0]
 8008e26:	7afa      	ldrb	r2, [r7, #11]
 8008e28:	429a      	cmp	r2, r3
 8008e2a:	d10b      	bne.n	8008e44 <lv_style_get_prop_inlined+0x9a>
                lv_style_value_t * values = (lv_style_value_t *)style->values_and_props;
 8008e2c:	68fb      	ldr	r3, [r7, #12]
 8008e2e:	681b      	ldr	r3, [r3, #0]
 8008e30:	61bb      	str	r3, [r7, #24]
                *value = values[i];
 8008e32:	6a3b      	ldr	r3, [r7, #32]
 8008e34:	009b      	lsls	r3, r3, #2
 8008e36:	69ba      	ldr	r2, [r7, #24]
 8008e38:	441a      	add	r2, r3
 8008e3a:	687b      	ldr	r3, [r7, #4]
 8008e3c:	6812      	ldr	r2, [r2, #0]
 8008e3e:	601a      	str	r2, [r3, #0]
                return LV_STYLE_RES_FOUND;
 8008e40:	2301      	movs	r3, #1
 8008e42:	e009      	b.n	8008e58 <lv_style_get_prop_inlined+0xae>
        for(i = 0; i < style->prop_cnt; i++) {
 8008e44:	6a3b      	ldr	r3, [r7, #32]
 8008e46:	3301      	adds	r3, #1
 8008e48:	623b      	str	r3, [r7, #32]
 8008e4a:	68fb      	ldr	r3, [r7, #12]
 8008e4c:	7a1b      	ldrb	r3, [r3, #8]
 8008e4e:	461a      	mov	r2, r3
 8008e50:	6a3b      	ldr	r3, [r7, #32]
 8008e52:	4293      	cmp	r3, r2
 8008e54:	d3e3      	bcc.n	8008e1e <lv_style_get_prop_inlined+0x74>
    return LV_STYLE_RES_NOT_FOUND;
 8008e56:	2300      	movs	r3, #0
}
 8008e58:	4618      	mov	r0, r3
 8008e5a:	3728      	adds	r7, #40	@ 0x28
 8008e5c:	46bd      	mov	sp, r7
 8008e5e:	bd80      	pop	{r7, pc}

08008e60 <_lv_style_get_prop_group>:
 * It allows early skipping the style if the property is not exists in the style at all.
 * @param prop a style property
 * @return the group [0..30] 30 means all the custom properties with index > 120
 */
static inline uint32_t _lv_style_get_prop_group(lv_style_prop_t prop)
{
 8008e60:	b480      	push	{r7}
 8008e62:	b085      	sub	sp, #20
 8008e64:	af00      	add	r7, sp, #0
 8008e66:	4603      	mov	r3, r0
 8008e68:	71fb      	strb	r3, [r7, #7]
    uint32_t group = prop >> 2;
 8008e6a:	79fb      	ldrb	r3, [r7, #7]
 8008e6c:	089b      	lsrs	r3, r3, #2
 8008e6e:	b2db      	uxtb	r3, r3
 8008e70:	60fb      	str	r3, [r7, #12]
    if(group > 30) group = 31;    /*The MSB marks all the custom properties*/
 8008e72:	68fb      	ldr	r3, [r7, #12]
 8008e74:	2b1e      	cmp	r3, #30
 8008e76:	d901      	bls.n	8008e7c <_lv_style_get_prop_group+0x1c>
 8008e78:	231f      	movs	r3, #31
 8008e7a:	60fb      	str	r3, [r7, #12]
    return group;
 8008e7c:	68fb      	ldr	r3, [r7, #12]

}
 8008e7e:	4618      	mov	r0, r3
 8008e80:	3714      	adds	r7, #20
 8008e82:	46bd      	mov	sp, r7
 8008e84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008e88:	4770      	bx	lr

08008e8a <lv_style_prop_has_flag>:
 * @param prop Property ID
 * @param flag Flag
 * @return true if the flag is set for this property
 */
static inline bool lv_style_prop_has_flag(lv_style_prop_t prop, uint8_t flag)
{
 8008e8a:	b580      	push	{r7, lr}
 8008e8c:	b082      	sub	sp, #8
 8008e8e:	af00      	add	r7, sp, #0
 8008e90:	4603      	mov	r3, r0
 8008e92:	460a      	mov	r2, r1
 8008e94:	71fb      	strb	r3, [r7, #7]
 8008e96:	4613      	mov	r3, r2
 8008e98:	71bb      	strb	r3, [r7, #6]
    return _lv_style_prop_lookup_flags(prop) & flag;
 8008e9a:	79fb      	ldrb	r3, [r7, #7]
 8008e9c:	4618      	mov	r0, r3
 8008e9e:	f01a fe75 	bl	8023b8c <_lv_style_prop_lookup_flags>
 8008ea2:	4603      	mov	r3, r0
 8008ea4:	461a      	mov	r2, r3
 8008ea6:	79bb      	ldrb	r3, [r7, #6]
 8008ea8:	4013      	ands	r3, r2
 8008eaa:	b2db      	uxtb	r3, r3
 8008eac:	2b00      	cmp	r3, #0
 8008eae:	bf14      	ite	ne
 8008eb0:	2301      	movne	r3, #1
 8008eb2:	2300      	moveq	r3, #0
 8008eb4:	b2db      	uxtb	r3, r3
}
 8008eb6:	4618      	mov	r0, r3
 8008eb8:	3708      	adds	r7, #8
 8008eba:	46bd      	mov	sp, r7
 8008ebc:	bd80      	pop	{r7, pc}

08008ebe <lv_obj_style_get_selector_state>:
{
 8008ebe:	b480      	push	{r7}
 8008ec0:	b083      	sub	sp, #12
 8008ec2:	af00      	add	r7, sp, #0
 8008ec4:	6078      	str	r0, [r7, #4]
    return selector & 0xFFFF;
 8008ec6:	687b      	ldr	r3, [r7, #4]
 8008ec8:	b29b      	uxth	r3, r3
}
 8008eca:	4618      	mov	r0, r3
 8008ecc:	370c      	adds	r7, #12
 8008ece:	46bd      	mov	sp, r7
 8008ed0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ed4:	4770      	bx	lr

08008ed6 <lv_obj_style_get_selector_part>:
{
 8008ed6:	b480      	push	{r7}
 8008ed8:	b083      	sub	sp, #12
 8008eda:	af00      	add	r7, sp, #0
 8008edc:	6078      	str	r0, [r7, #4]
    return selector & 0xFF0000;
 8008ede:	687b      	ldr	r3, [r7, #4]
 8008ee0:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
}
 8008ee4:	4618      	mov	r0, r3
 8008ee6:	370c      	adds	r7, #12
 8008ee8:	46bd      	mov	sp, r7
 8008eea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008eee:	4770      	bx	lr

08008ef0 <lv_obj_get_style_width>:
{
 8008ef0:	b580      	push	{r7, lr}
 8008ef2:	b084      	sub	sp, #16
 8008ef4:	af00      	add	r7, sp, #0
 8008ef6:	6078      	str	r0, [r7, #4]
 8008ef8:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_WIDTH);
 8008efa:	2201      	movs	r2, #1
 8008efc:	6839      	ldr	r1, [r7, #0]
 8008efe:	6878      	ldr	r0, [r7, #4]
 8008f00:	f000 fc12 	bl	8009728 <lv_obj_get_style_prop>
 8008f04:	4603      	mov	r3, r0
 8008f06:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8008f08:	68fb      	ldr	r3, [r7, #12]
}
 8008f0a:	4618      	mov	r0, r3
 8008f0c:	3710      	adds	r7, #16
 8008f0e:	46bd      	mov	sp, r7
 8008f10:	bd80      	pop	{r7, pc}

08008f12 <lv_obj_get_style_height>:
{
 8008f12:	b580      	push	{r7, lr}
 8008f14:	b084      	sub	sp, #16
 8008f16:	af00      	add	r7, sp, #0
 8008f18:	6078      	str	r0, [r7, #4]
 8008f1a:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_HEIGHT);
 8008f1c:	2202      	movs	r2, #2
 8008f1e:	6839      	ldr	r1, [r7, #0]
 8008f20:	6878      	ldr	r0, [r7, #4]
 8008f22:	f000 fc01 	bl	8009728 <lv_obj_get_style_prop>
 8008f26:	4603      	mov	r3, r0
 8008f28:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8008f2a:	68fb      	ldr	r3, [r7, #12]
}
 8008f2c:	4618      	mov	r0, r3
 8008f2e:	3710      	adds	r7, #16
 8008f30:	46bd      	mov	sp, r7
 8008f32:	bd80      	pop	{r7, pc}

08008f34 <lv_obj_get_style_transform_scale_x>:
{
 8008f34:	b580      	push	{r7, lr}
 8008f36:	b084      	sub	sp, #16
 8008f38:	af00      	add	r7, sp, #0
 8008f3a:	6078      	str	r0, [r7, #4]
 8008f3c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_SCALE_X);
 8008f3e:	226c      	movs	r2, #108	@ 0x6c
 8008f40:	6839      	ldr	r1, [r7, #0]
 8008f42:	6878      	ldr	r0, [r7, #4]
 8008f44:	f000 fbf0 	bl	8009728 <lv_obj_get_style_prop>
 8008f48:	4603      	mov	r3, r0
 8008f4a:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8008f4c:	68fb      	ldr	r3, [r7, #12]
}
 8008f4e:	4618      	mov	r0, r3
 8008f50:	3710      	adds	r7, #16
 8008f52:	46bd      	mov	sp, r7
 8008f54:	bd80      	pop	{r7, pc}

08008f56 <lv_obj_get_style_transform_scale_y>:
{
 8008f56:	b580      	push	{r7, lr}
 8008f58:	b084      	sub	sp, #16
 8008f5a:	af00      	add	r7, sp, #0
 8008f5c:	6078      	str	r0, [r7, #4]
 8008f5e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_SCALE_Y);
 8008f60:	226d      	movs	r2, #109	@ 0x6d
 8008f62:	6839      	ldr	r1, [r7, #0]
 8008f64:	6878      	ldr	r0, [r7, #4]
 8008f66:	f000 fbdf 	bl	8009728 <lv_obj_get_style_prop>
 8008f6a:	4603      	mov	r3, r0
 8008f6c:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8008f6e:	68fb      	ldr	r3, [r7, #12]
}
 8008f70:	4618      	mov	r0, r3
 8008f72:	3710      	adds	r7, #16
 8008f74:	46bd      	mov	sp, r7
 8008f76:	bd80      	pop	{r7, pc}

08008f78 <lv_obj_get_style_transform_rotation>:
{
 8008f78:	b580      	push	{r7, lr}
 8008f7a:	b084      	sub	sp, #16
 8008f7c:	af00      	add	r7, sp, #0
 8008f7e:	6078      	str	r0, [r7, #4]
 8008f80:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_ROTATION);
 8008f82:	226e      	movs	r2, #110	@ 0x6e
 8008f84:	6839      	ldr	r1, [r7, #0]
 8008f86:	6878      	ldr	r0, [r7, #4]
 8008f88:	f000 fbce 	bl	8009728 <lv_obj_get_style_prop>
 8008f8c:	4603      	mov	r3, r0
 8008f8e:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8008f90:	68fb      	ldr	r3, [r7, #12]
}
 8008f92:	4618      	mov	r0, r3
 8008f94:	3710      	adds	r7, #16
 8008f96:	46bd      	mov	sp, r7
 8008f98:	bd80      	pop	{r7, pc}

08008f9a <lv_obj_get_style_transform_skew_x>:
{
 8008f9a:	b580      	push	{r7, lr}
 8008f9c:	b084      	sub	sp, #16
 8008f9e:	af00      	add	r7, sp, #0
 8008fa0:	6078      	str	r0, [r7, #4]
 8008fa2:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_SKEW_X);
 8008fa4:	2271      	movs	r2, #113	@ 0x71
 8008fa6:	6839      	ldr	r1, [r7, #0]
 8008fa8:	6878      	ldr	r0, [r7, #4]
 8008faa:	f000 fbbd 	bl	8009728 <lv_obj_get_style_prop>
 8008fae:	4603      	mov	r3, r0
 8008fb0:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8008fb2:	68fb      	ldr	r3, [r7, #12]
}
 8008fb4:	4618      	mov	r0, r3
 8008fb6:	3710      	adds	r7, #16
 8008fb8:	46bd      	mov	sp, r7
 8008fba:	bd80      	pop	{r7, pc}

08008fbc <lv_obj_get_style_transform_skew_y>:
{
 8008fbc:	b580      	push	{r7, lr}
 8008fbe:	b084      	sub	sp, #16
 8008fc0:	af00      	add	r7, sp, #0
 8008fc2:	6078      	str	r0, [r7, #4]
 8008fc4:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_SKEW_Y);
 8008fc6:	2272      	movs	r2, #114	@ 0x72
 8008fc8:	6839      	ldr	r1, [r7, #0]
 8008fca:	6878      	ldr	r0, [r7, #4]
 8008fcc:	f000 fbac 	bl	8009728 <lv_obj_get_style_prop>
 8008fd0:	4603      	mov	r3, r0
 8008fd2:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8008fd4:	68fb      	ldr	r3, [r7, #12]
}
 8008fd6:	4618      	mov	r0, r3
 8008fd8:	3710      	adds	r7, #16
 8008fda:	46bd      	mov	sp, r7
 8008fdc:	bd80      	pop	{r7, pc}

08008fde <lv_obj_get_style_text_align>:
{
 8008fde:	b580      	push	{r7, lr}
 8008fe0:	b084      	sub	sp, #16
 8008fe2:	af00      	add	r7, sp, #0
 8008fe4:	6078      	str	r0, [r7, #4]
 8008fe6:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_ALIGN);
 8008fe8:	225e      	movs	r2, #94	@ 0x5e
 8008fea:	6839      	ldr	r1, [r7, #0]
 8008fec:	6878      	ldr	r0, [r7, #4]
 8008fee:	f000 fb9b 	bl	8009728 <lv_obj_get_style_prop>
 8008ff2:	4603      	mov	r3, r0
 8008ff4:	60fb      	str	r3, [r7, #12]
    return (lv_text_align_t)v.num;
 8008ff6:	68fb      	ldr	r3, [r7, #12]
 8008ff8:	b2db      	uxtb	r3, r3
}
 8008ffa:	4618      	mov	r0, r3
 8008ffc:	3710      	adds	r7, #16
 8008ffe:	46bd      	mov	sp, r7
 8009000:	bd80      	pop	{r7, pc}

08009002 <lv_obj_get_style_opa>:
{
 8009002:	b580      	push	{r7, lr}
 8009004:	b084      	sub	sp, #16
 8009006:	af00      	add	r7, sp, #0
 8009008:	6078      	str	r0, [r7, #4]
 800900a:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OPA);
 800900c:	225f      	movs	r2, #95	@ 0x5f
 800900e:	6839      	ldr	r1, [r7, #0]
 8009010:	6878      	ldr	r0, [r7, #4]
 8009012:	f000 fb89 	bl	8009728 <lv_obj_get_style_prop>
 8009016:	4603      	mov	r3, r0
 8009018:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 800901a:	68fb      	ldr	r3, [r7, #12]
 800901c:	b2db      	uxtb	r3, r3
}
 800901e:	4618      	mov	r0, r3
 8009020:	3710      	adds	r7, #16
 8009022:	46bd      	mov	sp, r7
 8009024:	bd80      	pop	{r7, pc}

08009026 <lv_obj_get_style_opa_layered>:
{
 8009026:	b580      	push	{r7, lr}
 8009028:	b084      	sub	sp, #16
 800902a:	af00      	add	r7, sp, #0
 800902c:	6078      	str	r0, [r7, #4]
 800902e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_OPA_LAYERED);
 8009030:	2260      	movs	r2, #96	@ 0x60
 8009032:	6839      	ldr	r1, [r7, #0]
 8009034:	6878      	ldr	r0, [r7, #4]
 8009036:	f000 fb77 	bl	8009728 <lv_obj_get_style_prop>
 800903a:	4603      	mov	r3, r0
 800903c:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 800903e:	68fb      	ldr	r3, [r7, #12]
 8009040:	b2db      	uxtb	r3, r3
}
 8009042:	4618      	mov	r0, r3
 8009044:	3710      	adds	r7, #16
 8009046:	46bd      	mov	sp, r7
 8009048:	bd80      	pop	{r7, pc}

0800904a <lv_obj_get_style_color_filter_dsc>:
{
 800904a:	b580      	push	{r7, lr}
 800904c:	b084      	sub	sp, #16
 800904e:	af00      	add	r7, sp, #0
 8009050:	6078      	str	r0, [r7, #4]
 8009052:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_COLOR_FILTER_DSC);
 8009054:	2261      	movs	r2, #97	@ 0x61
 8009056:	6839      	ldr	r1, [r7, #0]
 8009058:	6878      	ldr	r0, [r7, #4]
 800905a:	f000 fb65 	bl	8009728 <lv_obj_get_style_prop>
 800905e:	4603      	mov	r3, r0
 8009060:	60fb      	str	r3, [r7, #12]
    return (const lv_color_filter_dsc_t *)v.ptr;
 8009062:	68fb      	ldr	r3, [r7, #12]
}
 8009064:	4618      	mov	r0, r3
 8009066:	3710      	adds	r7, #16
 8009068:	46bd      	mov	sp, r7
 800906a:	bd80      	pop	{r7, pc}

0800906c <lv_obj_get_style_color_filter_opa>:
{
 800906c:	b580      	push	{r7, lr}
 800906e:	b084      	sub	sp, #16
 8009070:	af00      	add	r7, sp, #0
 8009072:	6078      	str	r0, [r7, #4]
 8009074:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_COLOR_FILTER_OPA);
 8009076:	2262      	movs	r2, #98	@ 0x62
 8009078:	6839      	ldr	r1, [r7, #0]
 800907a:	6878      	ldr	r0, [r7, #4]
 800907c:	f000 fb54 	bl	8009728 <lv_obj_get_style_prop>
 8009080:	4603      	mov	r3, r0
 8009082:	60fb      	str	r3, [r7, #12]
    return (lv_opa_t)v.num;
 8009084:	68fb      	ldr	r3, [r7, #12]
 8009086:	b2db      	uxtb	r3, r3
}
 8009088:	4618      	mov	r0, r3
 800908a:	3710      	adds	r7, #16
 800908c:	46bd      	mov	sp, r7
 800908e:	bd80      	pop	{r7, pc}

08009090 <lv_obj_get_style_blend_mode>:
{
 8009090:	b580      	push	{r7, lr}
 8009092:	b084      	sub	sp, #16
 8009094:	af00      	add	r7, sp, #0
 8009096:	6078      	str	r0, [r7, #4]
 8009098:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BLEND_MODE);
 800909a:	2267      	movs	r2, #103	@ 0x67
 800909c:	6839      	ldr	r1, [r7, #0]
 800909e:	6878      	ldr	r0, [r7, #4]
 80090a0:	f000 fb42 	bl	8009728 <lv_obj_get_style_prop>
 80090a4:	4603      	mov	r3, r0
 80090a6:	60fb      	str	r3, [r7, #12]
    return (lv_blend_mode_t)v.num;
 80090a8:	68fb      	ldr	r3, [r7, #12]
 80090aa:	b2db      	uxtb	r3, r3
}
 80090ac:	4618      	mov	r0, r3
 80090ae:	3710      	adds	r7, #16
 80090b0:	46bd      	mov	sp, r7
 80090b2:	bd80      	pop	{r7, pc}

080090b4 <lv_obj_get_style_base_dir>:
{
 80090b4:	b580      	push	{r7, lr}
 80090b6:	b084      	sub	sp, #16
 80090b8:	af00      	add	r7, sp, #0
 80090ba:	6078      	str	r0, [r7, #4]
 80090bc:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BASE_DIR);
 80090be:	2227      	movs	r2, #39	@ 0x27
 80090c0:	6839      	ldr	r1, [r7, #0]
 80090c2:	6878      	ldr	r0, [r7, #4]
 80090c4:	f000 fb30 	bl	8009728 <lv_obj_get_style_prop>
 80090c8:	4603      	mov	r3, r0
 80090ca:	60fb      	str	r3, [r7, #12]
    return (lv_base_dir_t)v.num;
 80090cc:	68fb      	ldr	r3, [r7, #12]
 80090ce:	b2db      	uxtb	r3, r3
}
 80090d0:	4618      	mov	r0, r3
 80090d2:	3710      	adds	r7, #16
 80090d4:	46bd      	mov	sp, r7
 80090d6:	bd80      	pop	{r7, pc}

080090d8 <lv_obj_get_style_bitmap_mask_src>:

static inline const lv_image_dsc_t * lv_obj_get_style_bitmap_mask_src(const lv_obj_t * obj, uint32_t part)
{
 80090d8:	b580      	push	{r7, lr}
 80090da:	b084      	sub	sp, #16
 80090dc:	af00      	add	r7, sp, #0
 80090de:	6078      	str	r0, [r7, #4]
 80090e0:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BITMAP_MASK_SRC);
 80090e2:	2273      	movs	r2, #115	@ 0x73
 80090e4:	6839      	ldr	r1, [r7, #0]
 80090e6:	6878      	ldr	r0, [r7, #4]
 80090e8:	f000 fb1e 	bl	8009728 <lv_obj_get_style_prop>
 80090ec:	4603      	mov	r3, r0
 80090ee:	60fb      	str	r3, [r7, #12]
    return (const lv_image_dsc_t *)v.ptr;
 80090f0:	68fb      	ldr	r3, [r7, #12]
}
 80090f2:	4618      	mov	r0, r3
 80090f4:	3710      	adds	r7, #16
 80090f6:	46bd      	mov	sp, r7
 80090f8:	bd80      	pop	{r7, pc}
	...

080090fc <_lv_obj_style_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void _lv_obj_style_init(void)
{
 80090fc:	b580      	push	{r7, lr}
 80090fe:	af00      	add	r7, sp, #0
    _lv_ll_init(style_trans_ll_p, sizeof(trans_t));
 8009100:	2114      	movs	r1, #20
 8009102:	4802      	ldr	r0, [pc, #8]	@ (800910c <_lv_obj_style_init+0x10>)
 8009104:	f019 ff85 	bl	8023012 <_lv_ll_init>
}
 8009108:	bf00      	nop
 800910a:	bd80      	pop	{r7, pc}
 800910c:	200000b4 	.word	0x200000b4

08009110 <lv_obj_remove_style>:
    }
    return replaced;
}

void lv_obj_remove_style(lv_obj_t * obj, const lv_style_t * style, lv_style_selector_t selector)
{
 8009110:	b580      	push	{r7, lr}
 8009112:	b08c      	sub	sp, #48	@ 0x30
 8009114:	af00      	add	r7, sp, #0
 8009116:	60f8      	str	r0, [r7, #12]
 8009118:	60b9      	str	r1, [r7, #8]
 800911a:	607a      	str	r2, [r7, #4]
    lv_state_t state = lv_obj_style_get_selector_state(selector);
 800911c:	6878      	ldr	r0, [r7, #4]
 800911e:	f7ff fece 	bl	8008ebe <lv_obj_style_get_selector_state>
 8009122:	4603      	mov	r3, r0
 8009124:	83fb      	strh	r3, [r7, #30]
    lv_part_t part = lv_obj_style_get_selector_part(selector);
 8009126:	6878      	ldr	r0, [r7, #4]
 8009128:	f7ff fed5 	bl	8008ed6 <lv_obj_style_get_selector_part>
 800912c:	61b8      	str	r0, [r7, #24]
    lv_style_prop_t prop = LV_STYLE_PROP_ANY;
 800912e:	23ff      	movs	r3, #255	@ 0xff
 8009130:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if(style && style->prop_cnt == 0) prop = LV_STYLE_PROP_INV;
 8009134:	68bb      	ldr	r3, [r7, #8]
 8009136:	2b00      	cmp	r3, #0
 8009138:	d006      	beq.n	8009148 <lv_obj_remove_style+0x38>
 800913a:	68bb      	ldr	r3, [r7, #8]
 800913c:	7a1b      	ldrb	r3, [r3, #8]
 800913e:	2b00      	cmp	r3, #0
 8009140:	d102      	bne.n	8009148 <lv_obj_remove_style+0x38>
 8009142:	2300      	movs	r3, #0
 8009144:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

    if(style && part == LV_PART_MAIN && style_has_flag(style, LV_STYLE_PROP_FLAG_TRANSFORM)) {
 8009148:	68bb      	ldr	r3, [r7, #8]
 800914a:	2b00      	cmp	r3, #0
 800914c:	d00c      	beq.n	8009168 <lv_obj_remove_style+0x58>
 800914e:	69bb      	ldr	r3, [r7, #24]
 8009150:	2b00      	cmp	r3, #0
 8009152:	d109      	bne.n	8009168 <lv_obj_remove_style+0x58>
 8009154:	2120      	movs	r1, #32
 8009156:	68b8      	ldr	r0, [r7, #8]
 8009158:	f001 fcc2 	bl	800aae0 <style_has_flag>
 800915c:	4603      	mov	r3, r0
 800915e:	2b00      	cmp	r3, #0
 8009160:	d002      	beq.n	8009168 <lv_obj_remove_style+0x58>
        lv_obj_invalidate(obj);
 8009162:	68f8      	ldr	r0, [r7, #12]
 8009164:	f7fd fa6c 	bl	8006640 <lv_obj_invalidate>
    }

    uint32_t i = 0;
 8009168:	2300      	movs	r3, #0
 800916a:	62bb      	str	r3, [r7, #40]	@ 0x28
    bool deleted = false;
 800916c:	2300      	movs	r3, #0
 800916e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    while(i <  obj->style_cnt) {
 8009172:	e0c0      	b.n	80092f6 <lv_obj_remove_style+0x1e6>
        lv_state_t state_act = lv_obj_style_get_selector_state(obj->styles[i].selector);
 8009174:	68fb      	ldr	r3, [r7, #12]
 8009176:	68da      	ldr	r2, [r3, #12]
 8009178:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800917a:	00db      	lsls	r3, r3, #3
 800917c:	4413      	add	r3, r2
 800917e:	685b      	ldr	r3, [r3, #4]
 8009180:	f3c3 0317 	ubfx	r3, r3, #0, #24
 8009184:	4618      	mov	r0, r3
 8009186:	f7ff fe9a 	bl	8008ebe <lv_obj_style_get_selector_state>
 800918a:	4603      	mov	r3, r0
 800918c:	82fb      	strh	r3, [r7, #22]
        lv_part_t part_act = lv_obj_style_get_selector_part(obj->styles[i].selector);
 800918e:	68fb      	ldr	r3, [r7, #12]
 8009190:	68da      	ldr	r2, [r3, #12]
 8009192:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009194:	00db      	lsls	r3, r3, #3
 8009196:	4413      	add	r3, r2
 8009198:	685b      	ldr	r3, [r3, #4]
 800919a:	f3c3 0317 	ubfx	r3, r3, #0, #24
 800919e:	4618      	mov	r0, r3
 80091a0:	f7ff fe99 	bl	8008ed6 <lv_obj_style_get_selector_part>
 80091a4:	6138      	str	r0, [r7, #16]
        if((state != LV_STATE_ANY && state_act != state) ||
 80091a6:	8bfb      	ldrh	r3, [r7, #30]
 80091a8:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80091ac:	4293      	cmp	r3, r2
 80091ae:	d003      	beq.n	80091b8 <lv_obj_remove_style+0xa8>
 80091b0:	8afa      	ldrh	r2, [r7, #22]
 80091b2:	8bfb      	ldrh	r3, [r7, #30]
 80091b4:	429a      	cmp	r2, r3
 80091b6:	d113      	bne.n	80091e0 <lv_obj_remove_style+0xd0>
 80091b8:	69bb      	ldr	r3, [r7, #24]
 80091ba:	f5b3 2f70 	cmp.w	r3, #983040	@ 0xf0000
 80091be:	d003      	beq.n	80091c8 <lv_obj_remove_style+0xb8>
           (part != LV_PART_ANY && part_act != part) ||
 80091c0:	693a      	ldr	r2, [r7, #16]
 80091c2:	69bb      	ldr	r3, [r7, #24]
 80091c4:	429a      	cmp	r2, r3
 80091c6:	d10b      	bne.n	80091e0 <lv_obj_remove_style+0xd0>
 80091c8:	68bb      	ldr	r3, [r7, #8]
 80091ca:	2b00      	cmp	r3, #0
 80091cc:	d00c      	beq.n	80091e8 <lv_obj_remove_style+0xd8>
           (style != NULL && style != obj->styles[i].style)) {
 80091ce:	68fb      	ldr	r3, [r7, #12]
 80091d0:	68da      	ldr	r2, [r3, #12]
 80091d2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80091d4:	00db      	lsls	r3, r3, #3
 80091d6:	4413      	add	r3, r2
 80091d8:	681b      	ldr	r3, [r3, #0]
 80091da:	68ba      	ldr	r2, [r7, #8]
 80091dc:	429a      	cmp	r2, r3
 80091de:	d003      	beq.n	80091e8 <lv_obj_remove_style+0xd8>
            i++;
 80091e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80091e2:	3301      	adds	r3, #1
 80091e4:	62bb      	str	r3, [r7, #40]	@ 0x28
            continue;
 80091e6:	e086      	b.n	80092f6 <lv_obj_remove_style+0x1e6>
        }

        if(obj->styles[i].is_trans) {
 80091e8:	68fb      	ldr	r3, [r7, #12]
 80091ea:	68da      	ldr	r2, [r3, #12]
 80091ec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80091ee:	00db      	lsls	r3, r3, #3
 80091f0:	4413      	add	r3, r2
 80091f2:	79db      	ldrb	r3, [r3, #7]
 80091f4:	f003 0302 	and.w	r3, r3, #2
 80091f8:	b2db      	uxtb	r3, r3
 80091fa:	2b00      	cmp	r3, #0
 80091fc:	d005      	beq.n	800920a <lv_obj_remove_style+0xfa>
            trans_delete(obj, part, LV_STYLE_PROP_ANY, NULL);
 80091fe:	2300      	movs	r3, #0
 8009200:	22ff      	movs	r2, #255	@ 0xff
 8009202:	69b9      	ldr	r1, [r7, #24]
 8009204:	68f8      	ldr	r0, [r7, #12]
 8009206:	f001 f967 	bl	800a4d8 <trans_delete>
        }

        if(obj->styles[i].is_local || obj->styles[i].is_trans) {
 800920a:	68fb      	ldr	r3, [r7, #12]
 800920c:	68da      	ldr	r2, [r3, #12]
 800920e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009210:	00db      	lsls	r3, r3, #3
 8009212:	4413      	add	r3, r2
 8009214:	79db      	ldrb	r3, [r3, #7]
 8009216:	f003 0301 	and.w	r3, r3, #1
 800921a:	b2db      	uxtb	r3, r3
 800921c:	2b00      	cmp	r3, #0
 800921e:	d10a      	bne.n	8009236 <lv_obj_remove_style+0x126>
 8009220:	68fb      	ldr	r3, [r7, #12]
 8009222:	68da      	ldr	r2, [r3, #12]
 8009224:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009226:	00db      	lsls	r3, r3, #3
 8009228:	4413      	add	r3, r2
 800922a:	79db      	ldrb	r3, [r3, #7]
 800922c:	f003 0302 	and.w	r3, r3, #2
 8009230:	b2db      	uxtb	r3, r3
 8009232:	2b00      	cmp	r3, #0
 8009234:	d020      	beq.n	8009278 <lv_obj_remove_style+0x168>
            if(obj->styles[i].style) lv_style_reset((lv_style_t *)obj->styles[i].style);
 8009236:	68fb      	ldr	r3, [r7, #12]
 8009238:	68da      	ldr	r2, [r3, #12]
 800923a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800923c:	00db      	lsls	r3, r3, #3
 800923e:	4413      	add	r3, r2
 8009240:	681b      	ldr	r3, [r3, #0]
 8009242:	2b00      	cmp	r3, #0
 8009244:	d008      	beq.n	8009258 <lv_obj_remove_style+0x148>
 8009246:	68fb      	ldr	r3, [r7, #12]
 8009248:	68da      	ldr	r2, [r3, #12]
 800924a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800924c:	00db      	lsls	r3, r3, #3
 800924e:	4413      	add	r3, r2
 8009250:	681b      	ldr	r3, [r3, #0]
 8009252:	4618      	mov	r0, r3
 8009254:	f01a fb3b 	bl	80238ce <lv_style_reset>
            lv_free((lv_style_t *)obj->styles[i].style);
 8009258:	68fb      	ldr	r3, [r7, #12]
 800925a:	68da      	ldr	r2, [r3, #12]
 800925c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800925e:	00db      	lsls	r3, r3, #3
 8009260:	4413      	add	r3, r2
 8009262:	681b      	ldr	r3, [r3, #0]
 8009264:	4618      	mov	r0, r3
 8009266:	f01c fde7 	bl	8025e38 <lv_free>
            obj->styles[i].style = NULL;
 800926a:	68fb      	ldr	r3, [r7, #12]
 800926c:	68da      	ldr	r2, [r3, #12]
 800926e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009270:	00db      	lsls	r3, r3, #3
 8009272:	4413      	add	r3, r2
 8009274:	2200      	movs	r2, #0
 8009276:	601a      	str	r2, [r3, #0]
        }

        /*Shift the styles after `i` by one*/
        uint32_t j;
        for(j = i; j < (uint32_t)obj->style_cnt - 1 ; j++) {
 8009278:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800927a:	623b      	str	r3, [r7, #32]
 800927c:	e012      	b.n	80092a4 <lv_obj_remove_style+0x194>
            obj->styles[j] = obj->styles[j + 1];
 800927e:	68fb      	ldr	r3, [r7, #12]
 8009280:	68da      	ldr	r2, [r3, #12]
 8009282:	6a3b      	ldr	r3, [r7, #32]
 8009284:	3301      	adds	r3, #1
 8009286:	00db      	lsls	r3, r3, #3
 8009288:	18d1      	adds	r1, r2, r3
 800928a:	68fb      	ldr	r3, [r7, #12]
 800928c:	68da      	ldr	r2, [r3, #12]
 800928e:	6a3b      	ldr	r3, [r7, #32]
 8009290:	00db      	lsls	r3, r3, #3
 8009292:	4413      	add	r3, r2
 8009294:	460a      	mov	r2, r1
 8009296:	e892 0003 	ldmia.w	r2, {r0, r1}
 800929a:	e883 0003 	stmia.w	r3, {r0, r1}
        for(j = i; j < (uint32_t)obj->style_cnt - 1 ; j++) {
 800929e:	6a3b      	ldr	r3, [r7, #32]
 80092a0:	3301      	adds	r3, #1
 80092a2:	623b      	str	r3, [r7, #32]
 80092a4:	68fb      	ldr	r3, [r7, #12]
 80092a6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80092a8:	f3c3 1305 	ubfx	r3, r3, #4, #6
 80092ac:	b2db      	uxtb	r3, r3
 80092ae:	3b01      	subs	r3, #1
 80092b0:	6a3a      	ldr	r2, [r7, #32]
 80092b2:	429a      	cmp	r2, r3
 80092b4:	d3e3      	bcc.n	800927e <lv_obj_remove_style+0x16e>
        }

        obj->style_cnt--;
 80092b6:	68fb      	ldr	r3, [r7, #12]
 80092b8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80092ba:	f3c3 1305 	ubfx	r3, r3, #4, #6
 80092be:	b2db      	uxtb	r3, r3
 80092c0:	333f      	adds	r3, #63	@ 0x3f
 80092c2:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 80092c6:	b2d9      	uxtb	r1, r3
 80092c8:	68fa      	ldr	r2, [r7, #12]
 80092ca:	8d53      	ldrh	r3, [r2, #42]	@ 0x2a
 80092cc:	f361 1309 	bfi	r3, r1, #4, #6
 80092d0:	8553      	strh	r3, [r2, #42]	@ 0x2a
        obj->styles = lv_realloc(obj->styles, obj->style_cnt * sizeof(_lv_obj_style_t));
 80092d2:	68fb      	ldr	r3, [r7, #12]
 80092d4:	68da      	ldr	r2, [r3, #12]
 80092d6:	68fb      	ldr	r3, [r7, #12]
 80092d8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80092da:	f3c3 1305 	ubfx	r3, r3, #4, #6
 80092de:	b2db      	uxtb	r3, r3
 80092e0:	00db      	lsls	r3, r3, #3
 80092e2:	4619      	mov	r1, r3
 80092e4:	4610      	mov	r0, r2
 80092e6:	f01c fdbf 	bl	8025e68 <lv_realloc>
 80092ea:	4602      	mov	r2, r0
 80092ec:	68fb      	ldr	r3, [r7, #12]
 80092ee:	60da      	str	r2, [r3, #12]

        deleted = true;
 80092f0:	2301      	movs	r3, #1
 80092f2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    while(i <  obj->style_cnt) {
 80092f6:	68fb      	ldr	r3, [r7, #12]
 80092f8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80092fa:	f3c3 1305 	ubfx	r3, r3, #4, #6
 80092fe:	b2db      	uxtb	r3, r3
 8009300:	461a      	mov	r2, r3
 8009302:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009304:	4293      	cmp	r3, r2
 8009306:	f4ff af35 	bcc.w	8009174 <lv_obj_remove_style+0x64>
        /*The style from the current `i` index is removed, so `i` points to the next style.
         *Therefore it doesn't needs to be incremented*/
    }

    if(deleted && prop != LV_STYLE_PROP_INV) {
 800930a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800930e:	2b00      	cmp	r3, #0
 8009310:	d00e      	beq.n	8009330 <lv_obj_remove_style+0x220>
 8009312:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8009316:	2b00      	cmp	r3, #0
 8009318:	d00a      	beq.n	8009330 <lv_obj_remove_style+0x220>
        full_cache_refresh(obj, part);
 800931a:	69b9      	ldr	r1, [r7, #24]
 800931c:	68f8      	ldr	r0, [r7, #12]
 800931e:	f001 fbd4 	bl	800aaca <full_cache_refresh>
        lv_obj_refresh_style(obj, part, prop);
 8009322:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8009326:	461a      	mov	r2, r3
 8009328:	69b9      	ldr	r1, [r7, #24]
 800932a:	68f8      	ldr	r0, [r7, #12]
 800932c:	f000 f814 	bl	8009358 <lv_obj_refresh_style>
    }
}
 8009330:	bf00      	nop
 8009332:	3730      	adds	r7, #48	@ 0x30
 8009334:	46bd      	mov	sp, r7
 8009336:	bd80      	pop	{r7, pc}

08009338 <lv_obj_remove_style_all>:

void lv_obj_remove_style_all(lv_obj_t * obj)
{
 8009338:	b580      	push	{r7, lr}
 800933a:	b082      	sub	sp, #8
 800933c:	af00      	add	r7, sp, #0
 800933e:	6078      	str	r0, [r7, #4]
    lv_obj_remove_style(obj, NULL, LV_PART_ANY | LV_STATE_ANY);
 8009340:	4a04      	ldr	r2, [pc, #16]	@ (8009354 <lv_obj_remove_style_all+0x1c>)
 8009342:	2100      	movs	r1, #0
 8009344:	6878      	ldr	r0, [r7, #4]
 8009346:	f7ff fee3 	bl	8009110 <lv_obj_remove_style>
}
 800934a:	bf00      	nop
 800934c:	3708      	adds	r7, #8
 800934e:	46bd      	mov	sp, r7
 8009350:	bd80      	pop	{r7, pc}
 8009352:	bf00      	nop
 8009354:	000fffff 	.word	0x000fffff

08009358 <lv_obj_refresh_style>:
        d = lv_display_get_next(d);
    }
}

void lv_obj_refresh_style(lv_obj_t * obj, lv_style_selector_t selector, lv_style_prop_t prop)
{
 8009358:	b580      	push	{r7, lr}
 800935a:	b088      	sub	sp, #32
 800935c:	af00      	add	r7, sp, #0
 800935e:	60f8      	str	r0, [r7, #12]
 8009360:	60b9      	str	r1, [r7, #8]
 8009362:	4613      	mov	r3, r2
 8009364:	71fb      	strb	r3, [r7, #7]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    if(!style_refr) return;
 8009366:	4b5d      	ldr	r3, [pc, #372]	@ (80094dc <lv_obj_refresh_style+0x184>)
 8009368:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 800936c:	f083 0301 	eor.w	r3, r3, #1
 8009370:	b2db      	uxtb	r3, r3
 8009372:	2b00      	cmp	r3, #0
 8009374:	f040 80ae 	bne.w	80094d4 <lv_obj_refresh_style+0x17c>

    lv_obj_invalidate(obj);
 8009378:	68f8      	ldr	r0, [r7, #12]
 800937a:	f7fd f961 	bl	8006640 <lv_obj_invalidate>

    lv_part_t part = lv_obj_style_get_selector_part(selector);
 800937e:	68b8      	ldr	r0, [r7, #8]
 8009380:	f7ff fda9 	bl	8008ed6 <lv_obj_style_get_selector_part>
 8009384:	61f8      	str	r0, [r7, #28]

    bool is_layout_refr = lv_style_prop_has_flag(prop, LV_STYLE_PROP_FLAG_LAYOUT_UPDATE);
 8009386:	79fb      	ldrb	r3, [r7, #7]
 8009388:	2104      	movs	r1, #4
 800938a:	4618      	mov	r0, r3
 800938c:	f7ff fd7d 	bl	8008e8a <lv_style_prop_has_flag>
 8009390:	4603      	mov	r3, r0
 8009392:	76fb      	strb	r3, [r7, #27]
    bool is_ext_draw = lv_style_prop_has_flag(prop, LV_STYLE_PROP_FLAG_EXT_DRAW_UPDATE);
 8009394:	79fb      	ldrb	r3, [r7, #7]
 8009396:	2102      	movs	r1, #2
 8009398:	4618      	mov	r0, r3
 800939a:	f7ff fd76 	bl	8008e8a <lv_style_prop_has_flag>
 800939e:	4603      	mov	r3, r0
 80093a0:	76bb      	strb	r3, [r7, #26]
    bool is_inheritable = lv_style_prop_has_flag(prop, LV_STYLE_PROP_FLAG_INHERITABLE);
 80093a2:	79fb      	ldrb	r3, [r7, #7]
 80093a4:	2101      	movs	r1, #1
 80093a6:	4618      	mov	r0, r3
 80093a8:	f7ff fd6f 	bl	8008e8a <lv_style_prop_has_flag>
 80093ac:	4603      	mov	r3, r0
 80093ae:	767b      	strb	r3, [r7, #25]
    bool is_layer_refr = lv_style_prop_has_flag(prop, LV_STYLE_PROP_FLAG_LAYER_UPDATE);
 80093b0:	79fb      	ldrb	r3, [r7, #7]
 80093b2:	2110      	movs	r1, #16
 80093b4:	4618      	mov	r0, r3
 80093b6:	f7ff fd68 	bl	8008e8a <lv_style_prop_has_flag>
 80093ba:	4603      	mov	r3, r0
 80093bc:	763b      	strb	r3, [r7, #24]

    if(is_layout_refr) {
 80093be:	7efb      	ldrb	r3, [r7, #27]
 80093c0:	2b00      	cmp	r3, #0
 80093c2:	d01e      	beq.n	8009402 <lv_obj_refresh_style+0xaa>
        if(part == LV_PART_ANY ||
 80093c4:	69fb      	ldr	r3, [r7, #28]
 80093c6:	f5b3 2f70 	cmp.w	r3, #983040	@ 0xf0000
 80093ca:	d012      	beq.n	80093f2 <lv_obj_refresh_style+0x9a>
 80093cc:	69fb      	ldr	r3, [r7, #28]
 80093ce:	2b00      	cmp	r3, #0
 80093d0:	d00f      	beq.n	80093f2 <lv_obj_refresh_style+0x9a>
           part == LV_PART_MAIN ||
           lv_obj_get_style_height(obj, 0) == LV_SIZE_CONTENT ||
 80093d2:	2100      	movs	r1, #0
 80093d4:	68f8      	ldr	r0, [r7, #12]
 80093d6:	f7ff fd9c 	bl	8008f12 <lv_obj_get_style_height>
 80093da:	4603      	mov	r3, r0
           part == LV_PART_MAIN ||
 80093dc:	4a40      	ldr	r2, [pc, #256]	@ (80094e0 <lv_obj_refresh_style+0x188>)
 80093de:	4293      	cmp	r3, r2
 80093e0:	d007      	beq.n	80093f2 <lv_obj_refresh_style+0x9a>
           lv_obj_get_style_width(obj, 0) == LV_SIZE_CONTENT) {
 80093e2:	2100      	movs	r1, #0
 80093e4:	68f8      	ldr	r0, [r7, #12]
 80093e6:	f7ff fd83 	bl	8008ef0 <lv_obj_get_style_width>
 80093ea:	4603      	mov	r3, r0
           lv_obj_get_style_height(obj, 0) == LV_SIZE_CONTENT ||
 80093ec:	4a3c      	ldr	r2, [pc, #240]	@ (80094e0 <lv_obj_refresh_style+0x188>)
 80093ee:	4293      	cmp	r3, r2
 80093f0:	d107      	bne.n	8009402 <lv_obj_refresh_style+0xaa>
            lv_obj_send_event(obj, LV_EVENT_STYLE_CHANGED, NULL);
 80093f2:	2200      	movs	r2, #0
 80093f4:	212c      	movs	r1, #44	@ 0x2c
 80093f6:	68f8      	ldr	r0, [r7, #12]
 80093f8:	f7fb fd0c 	bl	8004e14 <lv_obj_send_event>
            lv_obj_mark_layout_as_dirty(obj);
 80093fc:	68f8      	ldr	r0, [r7, #12]
 80093fe:	f7fc fc1d 	bl	8005c3c <lv_obj_mark_layout_as_dirty>
        }
    }
    if((part == LV_PART_ANY || part == LV_PART_MAIN) && (prop == LV_STYLE_PROP_ANY || is_layout_refr)) {
 8009402:	69fb      	ldr	r3, [r7, #28]
 8009404:	f5b3 2f70 	cmp.w	r3, #983040	@ 0xf0000
 8009408:	d002      	beq.n	8009410 <lv_obj_refresh_style+0xb8>
 800940a:	69fb      	ldr	r3, [r7, #28]
 800940c:	2b00      	cmp	r3, #0
 800940e:	d10f      	bne.n	8009430 <lv_obj_refresh_style+0xd8>
 8009410:	79fb      	ldrb	r3, [r7, #7]
 8009412:	2bff      	cmp	r3, #255	@ 0xff
 8009414:	d002      	beq.n	800941c <lv_obj_refresh_style+0xc4>
 8009416:	7efb      	ldrb	r3, [r7, #27]
 8009418:	2b00      	cmp	r3, #0
 800941a:	d009      	beq.n	8009430 <lv_obj_refresh_style+0xd8>
        lv_obj_t * parent = lv_obj_get_parent(obj);
 800941c:	68f8      	ldr	r0, [r7, #12]
 800941e:	f001 fd09 	bl	800ae34 <lv_obj_get_parent>
 8009422:	6178      	str	r0, [r7, #20]
        if(parent) lv_obj_mark_layout_as_dirty(parent);
 8009424:	697b      	ldr	r3, [r7, #20]
 8009426:	2b00      	cmp	r3, #0
 8009428:	d002      	beq.n	8009430 <lv_obj_refresh_style+0xd8>
 800942a:	6978      	ldr	r0, [r7, #20]
 800942c:	f7fc fc06 	bl	8005c3c <lv_obj_mark_layout_as_dirty>
    }

    /*Cache the layer type*/
    if((part == LV_PART_ANY || part == LV_PART_MAIN) && is_layer_refr) {
 8009430:	69fb      	ldr	r3, [r7, #28]
 8009432:	f5b3 2f70 	cmp.w	r3, #983040	@ 0xf0000
 8009436:	d002      	beq.n	800943e <lv_obj_refresh_style+0xe6>
 8009438:	69fb      	ldr	r3, [r7, #28]
 800943a:	2b00      	cmp	r3, #0
 800943c:	d12a      	bne.n	8009494 <lv_obj_refresh_style+0x13c>
 800943e:	7e3b      	ldrb	r3, [r7, #24]
 8009440:	2b00      	cmp	r3, #0
 8009442:	d027      	beq.n	8009494 <lv_obj_refresh_style+0x13c>
        lv_layer_type_t layer_type = calculate_layer_type(obj);
 8009444:	68f8      	ldr	r0, [r7, #12]
 8009446:	f001 faed 	bl	800aa24 <calculate_layer_type>
 800944a:	4603      	mov	r3, r0
 800944c:	74fb      	strb	r3, [r7, #19]
        if(obj->spec_attr) obj->spec_attr->layer_type = layer_type;
 800944e:	68fb      	ldr	r3, [r7, #12]
 8009450:	689b      	ldr	r3, [r3, #8]
 8009452:	2b00      	cmp	r3, #0
 8009454:	d00c      	beq.n	8009470 <lv_obj_refresh_style+0x118>
 8009456:	68fb      	ldr	r3, [r7, #12]
 8009458:	689a      	ldr	r2, [r3, #8]
 800945a:	7cfb      	ldrb	r3, [r7, #19]
 800945c:	f003 0303 	and.w	r3, r3, #3
 8009460:	b2d9      	uxtb	r1, r3
 8009462:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 8009466:	f361 0383 	bfi	r3, r1, #2, #2
 800946a:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
 800946e:	e011      	b.n	8009494 <lv_obj_refresh_style+0x13c>
        else if(layer_type != LV_LAYER_TYPE_NONE) {
 8009470:	7cfb      	ldrb	r3, [r7, #19]
 8009472:	2b00      	cmp	r3, #0
 8009474:	d00e      	beq.n	8009494 <lv_obj_refresh_style+0x13c>
            lv_obj_allocate_spec_attr(obj);
 8009476:	68f8      	ldr	r0, [r7, #12]
 8009478:	f7f9 fcb1 	bl	8002dde <lv_obj_allocate_spec_attr>
            obj->spec_attr->layer_type = layer_type;
 800947c:	68fb      	ldr	r3, [r7, #12]
 800947e:	689a      	ldr	r2, [r3, #8]
 8009480:	7cfb      	ldrb	r3, [r7, #19]
 8009482:	f003 0303 	and.w	r3, r3, #3
 8009486:	b2d9      	uxtb	r1, r3
 8009488:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 800948c:	f361 0383 	bfi	r3, r1, #2, #2
 8009490:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
        }
    }

    if(prop == LV_STYLE_PROP_ANY || is_ext_draw) {
 8009494:	79fb      	ldrb	r3, [r7, #7]
 8009496:	2bff      	cmp	r3, #255	@ 0xff
 8009498:	d002      	beq.n	80094a0 <lv_obj_refresh_style+0x148>
 800949a:	7ebb      	ldrb	r3, [r7, #26]
 800949c:	2b00      	cmp	r3, #0
 800949e:	d002      	beq.n	80094a6 <lv_obj_refresh_style+0x14e>
        lv_obj_refresh_ext_draw_size(obj);
 80094a0:	68f8      	ldr	r0, [r7, #12]
 80094a2:	f7fb fc5e 	bl	8004d62 <lv_obj_refresh_ext_draw_size>
    }
    lv_obj_invalidate(obj);
 80094a6:	68f8      	ldr	r0, [r7, #12]
 80094a8:	f7fd f8ca 	bl	8006640 <lv_obj_invalidate>

    if(prop == LV_STYLE_PROP_ANY || (is_inheritable && (is_ext_draw || is_layout_refr))) {
 80094ac:	79fb      	ldrb	r3, [r7, #7]
 80094ae:	2bff      	cmp	r3, #255	@ 0xff
 80094b0:	d008      	beq.n	80094c4 <lv_obj_refresh_style+0x16c>
 80094b2:	7e7b      	ldrb	r3, [r7, #25]
 80094b4:	2b00      	cmp	r3, #0
 80094b6:	d00e      	beq.n	80094d6 <lv_obj_refresh_style+0x17e>
 80094b8:	7ebb      	ldrb	r3, [r7, #26]
 80094ba:	2b00      	cmp	r3, #0
 80094bc:	d102      	bne.n	80094c4 <lv_obj_refresh_style+0x16c>
 80094be:	7efb      	ldrb	r3, [r7, #27]
 80094c0:	2b00      	cmp	r3, #0
 80094c2:	d008      	beq.n	80094d6 <lv_obj_refresh_style+0x17e>
        if(part != LV_PART_SCROLLBAR) {
 80094c4:	69fb      	ldr	r3, [r7, #28]
 80094c6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80094ca:	d004      	beq.n	80094d6 <lv_obj_refresh_style+0x17e>
            refresh_children_style(obj);
 80094cc:	68f8      	ldr	r0, [r7, #12]
 80094ce:	f000 ffd6 	bl	800a47e <refresh_children_style>
 80094d2:	e000      	b.n	80094d6 <lv_obj_refresh_style+0x17e>
    if(!style_refr) return;
 80094d4:	bf00      	nop
        }
    }
}
 80094d6:	3720      	adds	r7, #32
 80094d8:	46bd      	mov	sp, r7
 80094da:	bd80      	pop	{r7, pc}
 80094dc:	2000009c 	.word	0x2000009c
 80094e0:	200007d1 	.word	0x200007d1

080094e4 <lv_obj_enable_style_refresh>:

void lv_obj_enable_style_refresh(bool en)
{
 80094e4:	b480      	push	{r7}
 80094e6:	b083      	sub	sp, #12
 80094e8:	af00      	add	r7, sp, #0
 80094ea:	4603      	mov	r3, r0
 80094ec:	71fb      	strb	r3, [r7, #7]
    style_refr = en;
 80094ee:	4a05      	ldr	r2, [pc, #20]	@ (8009504 <lv_obj_enable_style_refresh+0x20>)
 80094f0:	79fb      	ldrb	r3, [r7, #7]
 80094f2:	f882 3024 	strb.w	r3, [r2, #36]	@ 0x24
}
 80094f6:	bf00      	nop
 80094f8:	370c      	adds	r7, #12
 80094fa:	46bd      	mov	sp, r7
 80094fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009500:	4770      	bx	lr
 8009502:	bf00      	nop
 8009504:	2000009c 	.word	0x2000009c

08009508 <lv_style_prop_get_default_inlined>:

static inline lv_style_value_t lv_style_prop_get_default_inlined(lv_style_prop_t prop)
{
 8009508:	b480      	push	{r7}
 800950a:	b08f      	sub	sp, #60	@ 0x3c
 800950c:	af00      	add	r7, sp, #0
 800950e:	4603      	mov	r3, r0
 8009510:	71fb      	strb	r3, [r7, #7]
    const lv_color_t black = LV_COLOR_MAKE(0x00, 0x00, 0x00);
 8009512:	2300      	movs	r3, #0
 8009514:	f887 3030 	strb.w	r3, [r7, #48]	@ 0x30
 8009518:	2300      	movs	r3, #0
 800951a:	f887 3031 	strb.w	r3, [r7, #49]	@ 0x31
 800951e:	2300      	movs	r3, #0
 8009520:	f887 3032 	strb.w	r3, [r7, #50]	@ 0x32
    const lv_color_t white = LV_COLOR_MAKE(0xff, 0xff, 0xff);
    switch(prop) {
 8009524:	79fb      	ldrb	r3, [r7, #7]
 8009526:	2b6d      	cmp	r3, #109	@ 0x6d
 8009528:	f300 80ea 	bgt.w	8009700 <lv_style_prop_get_default_inlined+0x1f8>
 800952c:	2b59      	cmp	r3, #89	@ 0x59
 800952e:	da0a      	bge.n	8009546 <lv_style_prop_get_default_inlined+0x3e>
 8009530:	2b58      	cmp	r3, #88	@ 0x58
 8009532:	f300 80e5 	bgt.w	8009700 <lv_style_prop_get_default_inlined+0x1f8>
 8009536:	2b3a      	cmp	r3, #58	@ 0x3a
 8009538:	da36      	bge.n	80095a8 <lv_style_prop_get_default_inlined+0xa0>
 800953a:	2b22      	cmp	r3, #34	@ 0x22
 800953c:	f300 80ae 	bgt.w	800969c <lv_style_prop_get_default_inlined+0x194>
 8009540:	2b05      	cmp	r3, #5
 8009542:	da69      	bge.n	8009618 <lv_style_prop_get_default_inlined+0x110>
 8009544:	e0dc      	b.n	8009700 <lv_style_prop_get_default_inlined+0x1f8>
 8009546:	3b59      	subs	r3, #89	@ 0x59
 8009548:	2b14      	cmp	r3, #20
 800954a:	f200 80d9 	bhi.w	8009700 <lv_style_prop_get_default_inlined+0x1f8>
 800954e:	a201      	add	r2, pc, #4	@ (adr r2, 8009554 <lv_style_prop_get_default_inlined+0x4c>)
 8009550:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009554:	080096e1 	.word	0x080096e1
 8009558:	080096f3 	.word	0x080096f3
 800955c:	08009701 	.word	0x08009701
 8009560:	08009701 	.word	0x08009701
 8009564:	08009701 	.word	0x08009701
 8009568:	08009701 	.word	0x08009701
 800956c:	080096e1 	.word	0x080096e1
 8009570:	080096e1 	.word	0x080096e1
 8009574:	08009701 	.word	0x08009701
 8009578:	08009701 	.word	0x08009701
 800957c:	08009701 	.word	0x08009701
 8009580:	08009701 	.word	0x08009701
 8009584:	08009701 	.word	0x08009701
 8009588:	08009701 	.word	0x08009701
 800958c:	08009701 	.word	0x08009701
 8009590:	08009701 	.word	0x08009701
 8009594:	08009701 	.word	0x08009701
 8009598:	08009701 	.word	0x08009701
 800959c:	08009701 	.word	0x08009701
 80095a0:	080096a7 	.word	0x080096a7
 80095a4:	080096a7 	.word	0x080096a7
 80095a8:	3b3a      	subs	r3, #58	@ 0x3a
 80095aa:	2201      	movs	r2, #1
 80095ac:	409a      	lsls	r2, r3
 80095ae:	4b59      	ldr	r3, [pc, #356]	@ (8009714 <lv_style_prop_get_default_inlined+0x20c>)
 80095b0:	4013      	ands	r3, r2
 80095b2:	2b00      	cmp	r3, #0
 80095b4:	bf14      	ite	ne
 80095b6:	2301      	movne	r3, #1
 80095b8:	2300      	moveq	r3, #0
 80095ba:	b2db      	uxtb	r3, r3
 80095bc:	2b00      	cmp	r3, #0
 80095be:	f040 808f 	bne.w	80096e0 <lv_style_prop_get_default_inlined+0x1d8>
 80095c2:	4b55      	ldr	r3, [pc, #340]	@ (8009718 <lv_style_prop_get_default_inlined+0x210>)
 80095c4:	4013      	ands	r3, r2
 80095c6:	2b00      	cmp	r3, #0
 80095c8:	bf14      	ite	ne
 80095ca:	2301      	movne	r3, #1
 80095cc:	2300      	moveq	r3, #0
 80095ce:	b2db      	uxtb	r3, r3
 80095d0:	2b00      	cmp	r3, #0
 80095d2:	d179      	bne.n	80096c8 <lv_style_prop_get_default_inlined+0x1c0>
 80095d4:	e094      	b.n	8009700 <lv_style_prop_get_default_inlined+0x1f8>
 80095d6:	3b23      	subs	r3, #35	@ 0x23
 80095d8:	2201      	movs	r2, #1
 80095da:	fa02 f303 	lsl.w	r3, r2, r3
 80095de:	f248 0246 	movw	r2, #32838	@ 0x8046
 80095e2:	401a      	ands	r2, r3
 80095e4:	2a00      	cmp	r2, #0
 80095e6:	bf14      	ite	ne
 80095e8:	2201      	movne	r2, #1
 80095ea:	2200      	moveq	r2, #0
 80095ec:	b2d2      	uxtb	r2, r2
 80095ee:	2a00      	cmp	r2, #0
 80095f0:	d176      	bne.n	80096e0 <lv_style_prop_get_default_inlined+0x1d8>
 80095f2:	4a4a      	ldr	r2, [pc, #296]	@ (800971c <lv_style_prop_get_default_inlined+0x214>)
 80095f4:	401a      	ands	r2, r3
 80095f6:	2a00      	cmp	r2, #0
 80095f8:	bf14      	ite	ne
 80095fa:	2201      	movne	r2, #1
 80095fc:	2200      	moveq	r2, #0
 80095fe:	b2d2      	uxtb	r2, r2
 8009600:	2a00      	cmp	r2, #0
 8009602:	d161      	bne.n	80096c8 <lv_style_prop_get_default_inlined+0x1c0>
 8009604:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8009608:	2b00      	cmp	r3, #0
 800960a:	bf14      	ite	ne
 800960c:	2301      	movne	r3, #1
 800960e:	2300      	moveq	r3, #0
 8009610:	b2db      	uxtb	r3, r3
 8009612:	2b00      	cmp	r3, #0
 8009614:	d16a      	bne.n	80096ec <lv_style_prop_get_default_inlined+0x1e4>
 8009616:	e073      	b.n	8009700 <lv_style_prop_get_default_inlined+0x1f8>
 8009618:	3b05      	subs	r3, #5
 800961a:	2b1d      	cmp	r3, #29
 800961c:	d870      	bhi.n	8009700 <lv_style_prop_get_default_inlined+0x1f8>
 800961e:	a201      	add	r2, pc, #4	@ (adr r2, 8009624 <lv_style_prop_get_default_inlined+0x11c>)
 8009620:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009624:	080096f9 	.word	0x080096f9
 8009628:	08009701 	.word	0x08009701
 800962c:	080096f9 	.word	0x080096f9
 8009630:	08009701 	.word	0x08009701
 8009634:	08009701 	.word	0x08009701
 8009638:	08009701 	.word	0x08009701
 800963c:	08009701 	.word	0x08009701
 8009640:	08009701 	.word	0x08009701
 8009644:	08009701 	.word	0x08009701
 8009648:	08009701 	.word	0x08009701
 800964c:	08009701 	.word	0x08009701
 8009650:	08009701 	.word	0x08009701
 8009654:	08009701 	.word	0x08009701
 8009658:	08009701 	.word	0x08009701
 800965c:	08009701 	.word	0x08009701
 8009660:	08009701 	.word	0x08009701
 8009664:	08009701 	.word	0x08009701
 8009668:	08009701 	.word	0x08009701
 800966c:	08009701 	.word	0x08009701
 8009670:	08009701 	.word	0x08009701
 8009674:	08009701 	.word	0x08009701
 8009678:	08009701 	.word	0x08009701
 800967c:	08009701 	.word	0x08009701
 8009680:	080096af 	.word	0x080096af
 8009684:	08009701 	.word	0x08009701
 8009688:	08009701 	.word	0x08009701
 800968c:	08009701 	.word	0x08009701
 8009690:	08009701 	.word	0x08009701
 8009694:	08009701 	.word	0x08009701
 8009698:	080096e7 	.word	0x080096e7
 800969c:	2b39      	cmp	r3, #57	@ 0x39
 800969e:	dc2f      	bgt.n	8009700 <lv_style_prop_get_default_inlined+0x1f8>
 80096a0:	2b23      	cmp	r3, #35	@ 0x23
 80096a2:	da98      	bge.n	80095d6 <lv_style_prop_get_default_inlined+0xce>
 80096a4:	e02c      	b.n	8009700 <lv_style_prop_get_default_inlined+0x1f8>
        case LV_STYLE_TRANSFORM_SCALE_X:
        case LV_STYLE_TRANSFORM_SCALE_Y:
            return (lv_style_value_t) {
 80096a6:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80096aa:	637b      	str	r3, [r7, #52]	@ 0x34
 80096ac:	e02a      	b.n	8009704 <lv_style_prop_get_default_inlined+0x1fc>
                .num = LV_SCALE_NONE
            };
        case LV_STYLE_BG_COLOR:
            return (lv_style_value_t) {
 80096ae:	2300      	movs	r3, #0
 80096b0:	637b      	str	r3, [r7, #52]	@ 0x34
 80096b2:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 80096b6:	f107 0230 	add.w	r2, r7, #48	@ 0x30
 80096ba:	6812      	ldr	r2, [r2, #0]
 80096bc:	4611      	mov	r1, r2
 80096be:	8019      	strh	r1, [r3, #0]
 80096c0:	3302      	adds	r3, #2
 80096c2:	0c12      	lsrs	r2, r2, #16
 80096c4:	701a      	strb	r2, [r3, #0]
 80096c6:	e01d      	b.n	8009704 <lv_style_prop_get_default_inlined+0x1fc>
        case LV_STYLE_OUTLINE_COLOR:
        case LV_STYLE_ARC_COLOR:
        case LV_STYLE_LINE_COLOR:
        case LV_STYLE_TEXT_COLOR:
        case LV_STYLE_IMAGE_RECOLOR:
            return (lv_style_value_t) {
 80096c8:	2300      	movs	r3, #0
 80096ca:	637b      	str	r3, [r7, #52]	@ 0x34
 80096cc:	4a14      	ldr	r2, [pc, #80]	@ (8009720 <lv_style_prop_get_default_inlined+0x218>)
 80096ce:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 80096d2:	6812      	ldr	r2, [r2, #0]
 80096d4:	4611      	mov	r1, r2
 80096d6:	8019      	strh	r1, [r3, #0]
 80096d8:	3302      	adds	r3, #2
 80096da:	0c12      	lsrs	r2, r2, #16
 80096dc:	701a      	strb	r2, [r3, #0]
 80096de:	e011      	b.n	8009704 <lv_style_prop_get_default_inlined+0x1fc>
        case LV_STYLE_BG_IMAGE_OPA:
        case LV_STYLE_OUTLINE_OPA:
        case LV_STYLE_SHADOW_OPA:
        case LV_STYLE_LINE_OPA:
        case LV_STYLE_ARC_OPA:
            return (lv_style_value_t) {
 80096e0:	23ff      	movs	r3, #255	@ 0xff
 80096e2:	637b      	str	r3, [r7, #52]	@ 0x34
 80096e4:	e00e      	b.n	8009704 <lv_style_prop_get_default_inlined+0x1fc>
                .num = LV_OPA_COVER
            };
        case LV_STYLE_BG_GRAD_STOP:
            return (lv_style_value_t) {
 80096e6:	23ff      	movs	r3, #255	@ 0xff
 80096e8:	637b      	str	r3, [r7, #52]	@ 0x34
 80096ea:	e00b      	b.n	8009704 <lv_style_prop_get_default_inlined+0x1fc>
                .num = 255
            };
        case LV_STYLE_BORDER_SIDE:
            return (lv_style_value_t) {
 80096ec:	230f      	movs	r3, #15
 80096ee:	637b      	str	r3, [r7, #52]	@ 0x34
 80096f0:	e008      	b.n	8009704 <lv_style_prop_get_default_inlined+0x1fc>
                .num = LV_BORDER_SIDE_FULL
            };
        case LV_STYLE_TEXT_FONT:
            return (lv_style_value_t) {
 80096f2:	4b0c      	ldr	r3, [pc, #48]	@ (8009724 <lv_style_prop_get_default_inlined+0x21c>)
 80096f4:	637b      	str	r3, [r7, #52]	@ 0x34
 80096f6:	e005      	b.n	8009704 <lv_style_prop_get_default_inlined+0x1fc>
                .ptr = LV_FONT_DEFAULT
            };
        case LV_STYLE_MAX_WIDTH:
        case LV_STYLE_MAX_HEIGHT:
            return (lv_style_value_t) {
 80096f8:	f06f 4360 	mvn.w	r3, #3758096384	@ 0xe0000000
 80096fc:	637b      	str	r3, [r7, #52]	@ 0x34
 80096fe:	e001      	b.n	8009704 <lv_style_prop_get_default_inlined+0x1fc>
                .num = LV_COORD_MAX
            };
        default:
            return (lv_style_value_t) {
 8009700:	2300      	movs	r3, #0
 8009702:	637b      	str	r3, [r7, #52]	@ 0x34
                .ptr = 0
            };
    }
}
 8009704:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009706:	4618      	mov	r0, r3
 8009708:	373c      	adds	r7, #60	@ 0x3c
 800970a:	46bd      	mov	sp, r7
 800970c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009710:	4770      	bx	lr
 8009712:	bf00      	nop
 8009714:	02080411 	.word	0x02080411
 8009718:	41040808 	.word	0x41040808
 800971c:	00404001 	.word	0x00404001
 8009720:	08027bf0 	.word	0x08027bf0
 8009724:	0802b154 	.word	0x0802b154

08009728 <lv_obj_get_style_prop>:

lv_style_value_t lv_obj_get_style_prop(const lv_obj_t * obj, lv_part_t part, lv_style_prop_t prop)
{
 8009728:	b580      	push	{r7, lr}
 800972a:	b088      	sub	sp, #32
 800972c:	af00      	add	r7, sp, #0
 800972e:	60f8      	str	r0, [r7, #12]
 8009730:	60b9      	str	r1, [r7, #8]
 8009732:	4613      	mov	r3, r2
 8009734:	71fb      	strb	r3, [r7, #7]
    LV_ASSERT_NULL(obj)
 8009736:	68fb      	ldr	r3, [r7, #12]
 8009738:	2b00      	cmp	r3, #0
 800973a:	d101      	bne.n	8009740 <lv_obj_get_style_prop+0x18>
 800973c:	bf00      	nop
 800973e:	e7fd      	b.n	800973c <lv_obj_get_style_prop+0x14>

    lv_style_selector_t selector = part | obj->state;
 8009740:	68fb      	ldr	r3, [r7, #12]
 8009742:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8009744:	461a      	mov	r2, r3
 8009746:	68bb      	ldr	r3, [r7, #8]
 8009748:	4313      	orrs	r3, r2
 800974a:	61fb      	str	r3, [r7, #28]
    lv_style_value_t value_act = { .ptr = NULL };
 800974c:	2300      	movs	r3, #0
 800974e:	613b      	str	r3, [r7, #16]
    lv_style_res_t found;

    found = get_selector_style_prop(obj, selector, prop, &value_act);
 8009750:	f107 0310 	add.w	r3, r7, #16
 8009754:	79fa      	ldrb	r2, [r7, #7]
 8009756:	69f9      	ldr	r1, [r7, #28]
 8009758:	68f8      	ldr	r0, [r7, #12]
 800975a:	f001 fa15 	bl	800ab88 <get_selector_style_prop>
 800975e:	4603      	mov	r3, r0
 8009760:	76fb      	strb	r3, [r7, #27]
    if(found == LV_STYLE_RES_FOUND) return value_act;
 8009762:	7efb      	ldrb	r3, [r7, #27]
 8009764:	2b01      	cmp	r3, #1
 8009766:	d102      	bne.n	800976e <lv_obj_get_style_prop+0x46>
 8009768:	693b      	ldr	r3, [r7, #16]
 800976a:	617b      	str	r3, [r7, #20]
 800976c:	e005      	b.n	800977a <lv_obj_get_style_prop+0x52>

    return lv_style_prop_get_default_inlined(prop);
 800976e:	79fb      	ldrb	r3, [r7, #7]
 8009770:	4618      	mov	r0, r3
 8009772:	f7ff fec9 	bl	8009508 <lv_style_prop_get_default_inlined>
 8009776:	4603      	mov	r3, r0
 8009778:	617b      	str	r3, [r7, #20]
}
 800977a:	697b      	ldr	r3, [r7, #20]
 800977c:	4618      	mov	r0, r3
 800977e:	3720      	adds	r7, #32
 8009780:	46bd      	mov	sp, r7
 8009782:	bd80      	pop	{r7, pc}

08009784 <lv_obj_set_local_style_prop>:
    return false;
}

void lv_obj_set_local_style_prop(lv_obj_t * obj, lv_style_prop_t prop, lv_style_value_t value,
                                 lv_style_selector_t selector)
{
 8009784:	b580      	push	{r7, lr}
 8009786:	b086      	sub	sp, #24
 8009788:	af00      	add	r7, sp, #0
 800978a:	60f8      	str	r0, [r7, #12]
 800978c:	607a      	str	r2, [r7, #4]
 800978e:	603b      	str	r3, [r7, #0]
 8009790:	460b      	mov	r3, r1
 8009792:	72fb      	strb	r3, [r7, #11]
    lv_style_t * style = get_local_style(obj, selector);
 8009794:	6839      	ldr	r1, [r7, #0]
 8009796:	68f8      	ldr	r0, [r7, #12]
 8009798:	f000 fc0f 	bl	8009fba <get_local_style>
 800979c:	6178      	str	r0, [r7, #20]
    if(selector == LV_PART_MAIN && lv_style_prop_has_flag(prop, LV_STYLE_PROP_FLAG_TRANSFORM)) {
 800979e:	683b      	ldr	r3, [r7, #0]
 80097a0:	2b00      	cmp	r3, #0
 80097a2:	d10a      	bne.n	80097ba <lv_obj_set_local_style_prop+0x36>
 80097a4:	7afb      	ldrb	r3, [r7, #11]
 80097a6:	2120      	movs	r1, #32
 80097a8:	4618      	mov	r0, r3
 80097aa:	f7ff fb6e 	bl	8008e8a <lv_style_prop_has_flag>
 80097ae:	4603      	mov	r3, r0
 80097b0:	2b00      	cmp	r3, #0
 80097b2:	d002      	beq.n	80097ba <lv_obj_set_local_style_prop+0x36>
        lv_obj_invalidate(obj);
 80097b4:	68f8      	ldr	r0, [r7, #12]
 80097b6:	f7fc ff43 	bl	8006640 <lv_obj_invalidate>
    }

    lv_style_set_prop(style, prop, value);
 80097ba:	7afb      	ldrb	r3, [r7, #11]
 80097bc:	687a      	ldr	r2, [r7, #4]
 80097be:	4619      	mov	r1, r3
 80097c0:	6978      	ldr	r0, [r7, #20]
 80097c2:	f01a f923 	bl	8023a0c <lv_style_set_prop>
    else {
        obj->style_other_prop_is_set |= prop_shifted;
    }
#endif

    lv_obj_refresh_style(obj, selector, prop);
 80097c6:	7afb      	ldrb	r3, [r7, #11]
 80097c8:	461a      	mov	r2, r3
 80097ca:	6839      	ldr	r1, [r7, #0]
 80097cc:	68f8      	ldr	r0, [r7, #12]
 80097ce:	f7ff fdc3 	bl	8009358 <lv_obj_refresh_style>
}
 80097d2:	bf00      	nop
 80097d4:	3718      	adds	r7, #24
 80097d6:	46bd      	mov	sp, r7
 80097d8:	bd80      	pop	{r7, pc}

080097da <lv_obj_get_local_style_prop>:

lv_style_res_t lv_obj_get_local_style_prop(lv_obj_t * obj, lv_style_prop_t prop, lv_style_value_t * value,
                                           lv_style_selector_t selector)
{
 80097da:	b580      	push	{r7, lr}
 80097dc:	b086      	sub	sp, #24
 80097de:	af00      	add	r7, sp, #0
 80097e0:	60f8      	str	r0, [r7, #12]
 80097e2:	607a      	str	r2, [r7, #4]
 80097e4:	603b      	str	r3, [r7, #0]
 80097e6:	460b      	mov	r3, r1
 80097e8:	72fb      	strb	r3, [r7, #11]
    uint32_t i;
    for(i = 0; i < obj->style_cnt; i++) {
 80097ea:	2300      	movs	r3, #0
 80097ec:	617b      	str	r3, [r7, #20]
 80097ee:	e026      	b.n	800983e <lv_obj_get_local_style_prop+0x64>
        if(obj->styles[i].is_local &&
 80097f0:	68fb      	ldr	r3, [r7, #12]
 80097f2:	68da      	ldr	r2, [r3, #12]
 80097f4:	697b      	ldr	r3, [r7, #20]
 80097f6:	00db      	lsls	r3, r3, #3
 80097f8:	4413      	add	r3, r2
 80097fa:	79db      	ldrb	r3, [r3, #7]
 80097fc:	f003 0301 	and.w	r3, r3, #1
 8009800:	b2db      	uxtb	r3, r3
 8009802:	2b00      	cmp	r3, #0
 8009804:	d018      	beq.n	8009838 <lv_obj_get_local_style_prop+0x5e>
           obj->styles[i].selector == selector) {
 8009806:	68fb      	ldr	r3, [r7, #12]
 8009808:	68da      	ldr	r2, [r3, #12]
 800980a:	697b      	ldr	r3, [r7, #20]
 800980c:	00db      	lsls	r3, r3, #3
 800980e:	4413      	add	r3, r2
 8009810:	685b      	ldr	r3, [r3, #4]
 8009812:	f3c3 0317 	ubfx	r3, r3, #0, #24
 8009816:	461a      	mov	r2, r3
        if(obj->styles[i].is_local &&
 8009818:	683b      	ldr	r3, [r7, #0]
 800981a:	4293      	cmp	r3, r2
 800981c:	d10c      	bne.n	8009838 <lv_obj_get_local_style_prop+0x5e>
            return lv_style_get_prop(obj->styles[i].style, prop, value);
 800981e:	68fb      	ldr	r3, [r7, #12]
 8009820:	68da      	ldr	r2, [r3, #12]
 8009822:	697b      	ldr	r3, [r7, #20]
 8009824:	00db      	lsls	r3, r3, #3
 8009826:	4413      	add	r3, r2
 8009828:	681b      	ldr	r3, [r3, #0]
 800982a:	7af9      	ldrb	r1, [r7, #11]
 800982c:	687a      	ldr	r2, [r7, #4]
 800982e:	4618      	mov	r0, r3
 8009830:	f01a f989 	bl	8023b46 <lv_style_get_prop>
 8009834:	4603      	mov	r3, r0
 8009836:	e00c      	b.n	8009852 <lv_obj_get_local_style_prop+0x78>
    for(i = 0; i < obj->style_cnt; i++) {
 8009838:	697b      	ldr	r3, [r7, #20]
 800983a:	3301      	adds	r3, #1
 800983c:	617b      	str	r3, [r7, #20]
 800983e:	68fb      	ldr	r3, [r7, #12]
 8009840:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8009842:	f3c3 1305 	ubfx	r3, r3, #4, #6
 8009846:	b2db      	uxtb	r3, r3
 8009848:	461a      	mov	r2, r3
 800984a:	697b      	ldr	r3, [r7, #20]
 800984c:	4293      	cmp	r3, r2
 800984e:	d3cf      	bcc.n	80097f0 <lv_obj_get_local_style_prop+0x16>
        }
    }

    return LV_STYLE_RES_NOT_FOUND;
 8009850:	2300      	movs	r3, #0
}
 8009852:	4618      	mov	r0, r3
 8009854:	3718      	adds	r7, #24
 8009856:	46bd      	mov	sp, r7
 8009858:	bd80      	pop	{r7, pc}
	...

0800985c <_lv_obj_style_create_transition>:
    return res;
}

void _lv_obj_style_create_transition(lv_obj_t * obj, lv_part_t part, lv_state_t prev_state, lv_state_t new_state,
                                     const _lv_obj_style_transition_dsc_t * tr_dsc)
{
 800985c:	b580      	push	{r7, lr}
 800985e:	b0a0      	sub	sp, #128	@ 0x80
 8009860:	af00      	add	r7, sp, #0
 8009862:	60f8      	str	r0, [r7, #12]
 8009864:	60b9      	str	r1, [r7, #8]
 8009866:	4611      	mov	r1, r2
 8009868:	461a      	mov	r2, r3
 800986a:	460b      	mov	r3, r1
 800986c:	80fb      	strh	r3, [r7, #6]
 800986e:	4613      	mov	r3, r2
 8009870:	80bb      	strh	r3, [r7, #4]
    trans_t * tr;

    /*Get the previous and current values*/
    obj->skip_trans = 1;
 8009872:	68fa      	ldr	r2, [r7, #12]
 8009874:	f892 302a 	ldrb.w	r3, [r2, #42]	@ 0x2a
 8009878:	f043 0308 	orr.w	r3, r3, #8
 800987c:	f882 302a 	strb.w	r3, [r2, #42]	@ 0x2a
    obj->state = prev_state;
 8009880:	68fb      	ldr	r3, [r7, #12]
 8009882:	88fa      	ldrh	r2, [r7, #6]
 8009884:	851a      	strh	r2, [r3, #40]	@ 0x28
    lv_style_value_t v1 = lv_obj_get_style_prop(obj, part, tr_dsc->prop);
 8009886:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800988a:	7a1b      	ldrb	r3, [r3, #8]
 800988c:	461a      	mov	r2, r3
 800988e:	68b9      	ldr	r1, [r7, #8]
 8009890:	68f8      	ldr	r0, [r7, #12]
 8009892:	f7ff ff49 	bl	8009728 <lv_obj_get_style_prop>
 8009896:	4603      	mov	r3, r0
 8009898:	66fb      	str	r3, [r7, #108]	@ 0x6c
    obj->state = new_state;
 800989a:	68fb      	ldr	r3, [r7, #12]
 800989c:	88ba      	ldrh	r2, [r7, #4]
 800989e:	851a      	strh	r2, [r3, #40]	@ 0x28
    lv_style_value_t v2 = lv_obj_get_style_prop(obj, part, tr_dsc->prop);
 80098a0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80098a4:	7a1b      	ldrb	r3, [r3, #8]
 80098a6:	461a      	mov	r2, r3
 80098a8:	68b9      	ldr	r1, [r7, #8]
 80098aa:	68f8      	ldr	r0, [r7, #12]
 80098ac:	f7ff ff3c 	bl	8009728 <lv_obj_get_style_prop>
 80098b0:	4603      	mov	r3, r0
 80098b2:	66bb      	str	r3, [r7, #104]	@ 0x68
    obj->skip_trans = 0;
 80098b4:	68fa      	ldr	r2, [r7, #12]
 80098b6:	f892 302a 	ldrb.w	r3, [r2, #42]	@ 0x2a
 80098ba:	f36f 03c3 	bfc	r3, #3, #1
 80098be:	f882 302a 	strb.w	r3, [r2, #42]	@ 0x2a

    if(v1.ptr == v2.ptr && v1.num == v2.num && lv_color_eq(v1.color, v2.color))  return;
 80098c2:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80098c4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80098c6:	429a      	cmp	r2, r3
 80098c8:	d10b      	bne.n	80098e2 <_lv_obj_style_create_transition+0x86>
 80098ca:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80098cc:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80098ce:	429a      	cmp	r2, r3
 80098d0:	d107      	bne.n	80098e2 <_lv_obj_style_create_transition+0x86>
 80098d2:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 80098d4:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 80098d6:	f7ff f922 	bl	8008b1e <lv_color_eq>
 80098da:	4603      	mov	r3, r0
 80098dc:	2b00      	cmp	r3, #0
 80098de:	f040 80ce 	bne.w	8009a7e <_lv_obj_style_create_transition+0x222>
    obj->state = prev_state;
 80098e2:	68fb      	ldr	r3, [r7, #12]
 80098e4:	88fa      	ldrh	r2, [r7, #6]
 80098e6:	851a      	strh	r2, [r3, #40]	@ 0x28
    v1 = lv_obj_get_style_prop(obj, part, tr_dsc->prop);
 80098e8:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80098ec:	7a1b      	ldrb	r3, [r3, #8]
 80098ee:	461a      	mov	r2, r3
 80098f0:	68b9      	ldr	r1, [r7, #8]
 80098f2:	68f8      	ldr	r0, [r7, #12]
 80098f4:	f7ff ff18 	bl	8009728 <lv_obj_get_style_prop>
 80098f8:	4603      	mov	r3, r0
 80098fa:	66fb      	str	r3, [r7, #108]	@ 0x6c
    obj->state = new_state;
 80098fc:	68fb      	ldr	r3, [r7, #12]
 80098fe:	88ba      	ldrh	r2, [r7, #4]
 8009900:	851a      	strh	r2, [r3, #40]	@ 0x28

    _lv_obj_style_t * style_trans = get_trans_style(obj, part);
 8009902:	68b9      	ldr	r1, [r7, #8]
 8009904:	68f8      	ldr	r0, [r7, #12]
 8009906:	f000 fc2d 	bl	800a164 <get_trans_style>
 800990a:	67f8      	str	r0, [r7, #124]	@ 0x7c
    lv_style_set_prop((lv_style_t *)style_trans->style, tr_dsc->prop, v1);  /*Be sure `trans_style` has a valid value*/
 800990c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800990e:	6818      	ldr	r0, [r3, #0]
 8009910:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8009914:	7a1b      	ldrb	r3, [r3, #8]
 8009916:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8009918:	4619      	mov	r1, r3
 800991a:	f01a f877 	bl	8023a0c <lv_style_set_prop>

    if(tr_dsc->prop == LV_STYLE_RADIUS) {
 800991e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8009922:	7a1b      	ldrb	r3, [r3, #8]
 8009924:	2b0c      	cmp	r3, #12
 8009926:	d137      	bne.n	8009998 <_lv_obj_style_create_transition+0x13c>
        if(v1.num == LV_RADIUS_CIRCLE || v2.num == LV_RADIUS_CIRCLE) {
 8009928:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800992a:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 800992e:	4293      	cmp	r3, r2
 8009930:	d004      	beq.n	800993c <_lv_obj_style_create_transition+0xe0>
 8009932:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8009934:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 8009938:	4293      	cmp	r3, r2
 800993a:	d12d      	bne.n	8009998 <_lv_obj_style_create_transition+0x13c>
            int32_t whalf = lv_obj_get_width(obj) / 2;
 800993c:	68f8      	ldr	r0, [r7, #12]
 800993e:	f7fc f9f7 	bl	8005d30 <lv_obj_get_width>
 8009942:	4603      	mov	r3, r0
 8009944:	0fda      	lsrs	r2, r3, #31
 8009946:	4413      	add	r3, r2
 8009948:	105b      	asrs	r3, r3, #1
 800994a:	67bb      	str	r3, [r7, #120]	@ 0x78
            int32_t hhalf = lv_obj_get_height(obj) / 2;
 800994c:	68f8      	ldr	r0, [r7, #12]
 800994e:	f7fc f9fd 	bl	8005d4c <lv_obj_get_height>
 8009952:	4603      	mov	r3, r0
 8009954:	0fda      	lsrs	r2, r3, #31
 8009956:	4413      	add	r3, r2
 8009958:	105b      	asrs	r3, r3, #1
 800995a:	677b      	str	r3, [r7, #116]	@ 0x74
            if(v1.num == LV_RADIUS_CIRCLE) v1.num = LV_MIN(whalf + 1, hhalf + 1);
 800995c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800995e:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 8009962:	4293      	cmp	r3, r2
 8009964:	d109      	bne.n	800997a <_lv_obj_style_create_transition+0x11e>
 8009966:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 8009968:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800996a:	429a      	cmp	r2, r3
 800996c:	da02      	bge.n	8009974 <_lv_obj_style_create_transition+0x118>
 800996e:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8009970:	3301      	adds	r3, #1
 8009972:	e001      	b.n	8009978 <_lv_obj_style_create_transition+0x11c>
 8009974:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009976:	3301      	adds	r3, #1
 8009978:	66fb      	str	r3, [r7, #108]	@ 0x6c
            if(v2.num == LV_RADIUS_CIRCLE) v2.num = LV_MIN(whalf + 1, hhalf + 1);
 800997a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800997c:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 8009980:	4293      	cmp	r3, r2
 8009982:	d109      	bne.n	8009998 <_lv_obj_style_create_transition+0x13c>
 8009984:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 8009986:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009988:	429a      	cmp	r2, r3
 800998a:	da02      	bge.n	8009992 <_lv_obj_style_create_transition+0x136>
 800998c:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 800998e:	3301      	adds	r3, #1
 8009990:	e001      	b.n	8009996 <_lv_obj_style_create_transition+0x13a>
 8009992:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8009994:	3301      	adds	r3, #1
 8009996:	66bb      	str	r3, [r7, #104]	@ 0x68
        }
    }

    tr = _lv_ll_ins_head(style_trans_ll_p);
 8009998:	483c      	ldr	r0, [pc, #240]	@ (8009a8c <_lv_obj_style_create_transition+0x230>)
 800999a:	f019 fb53 	bl	8023044 <_lv_ll_ins_head>
 800999e:	6738      	str	r0, [r7, #112]	@ 0x70
    LV_ASSERT_MALLOC(tr);
 80099a0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80099a2:	2b00      	cmp	r3, #0
 80099a4:	d101      	bne.n	80099aa <_lv_obj_style_create_transition+0x14e>
 80099a6:	bf00      	nop
 80099a8:	e7fd      	b.n	80099a6 <_lv_obj_style_create_transition+0x14a>
    if(tr == NULL) return;
 80099aa:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80099ac:	2b00      	cmp	r3, #0
 80099ae:	d068      	beq.n	8009a82 <_lv_obj_style_create_transition+0x226>
    tr->start_value = v1;
 80099b0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80099b2:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80099b4:	60da      	str	r2, [r3, #12]
    tr->end_value = v2;
 80099b6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80099b8:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80099ba:	611a      	str	r2, [r3, #16]
    tr->obj = obj;
 80099bc:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80099be:	68fa      	ldr	r2, [r7, #12]
 80099c0:	601a      	str	r2, [r3, #0]
    tr->prop = tr_dsc->prop;
 80099c2:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 80099c6:	7a1a      	ldrb	r2, [r3, #8]
 80099c8:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80099ca:	711a      	strb	r2, [r3, #4]
    tr->selector = part;
 80099cc:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80099ce:	68ba      	ldr	r2, [r7, #8]
 80099d0:	609a      	str	r2, [r3, #8]

    lv_anim_t a;
    lv_anim_init(&a);
 80099d2:	f107 0310 	add.w	r3, r7, #16
 80099d6:	4618      	mov	r0, r3
 80099d8:	f017 faae 	bl	8020f38 <lv_anim_init>
    lv_anim_set_var(&a, tr);
 80099dc:	f107 0310 	add.w	r3, r7, #16
 80099e0:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 80099e2:	4618      	mov	r0, r3
 80099e4:	f7ff f922 	bl	8008c2c <lv_anim_set_var>
    lv_anim_set_exec_cb(&a, trans_anim_cb);
 80099e8:	f107 0310 	add.w	r3, r7, #16
 80099ec:	4928      	ldr	r1, [pc, #160]	@ (8009a90 <_lv_obj_style_create_transition+0x234>)
 80099ee:	4618      	mov	r0, r3
 80099f0:	f7ff f92a 	bl	8008c48 <lv_anim_set_exec_cb>
    lv_anim_set_start_cb(&a, trans_anim_start_cb);
 80099f4:	f107 0310 	add.w	r3, r7, #16
 80099f8:	4926      	ldr	r1, [pc, #152]	@ (8009a94 <_lv_obj_style_create_transition+0x238>)
 80099fa:	4618      	mov	r0, r3
 80099fc:	f7ff f973 	bl	8008ce6 <lv_anim_set_start_cb>
    lv_anim_set_completed_cb(&a, trans_anim_completed_cb);
 8009a00:	f107 0310 	add.w	r3, r7, #16
 8009a04:	4924      	ldr	r1, [pc, #144]	@ (8009a98 <_lv_obj_style_create_transition+0x23c>)
 8009a06:	4618      	mov	r0, r3
 8009a08:	f7ff f97b 	bl	8008d02 <lv_anim_set_completed_cb>
    lv_anim_set_values(&a, 0x00, 0xFF);
 8009a0c:	f107 0310 	add.w	r3, r7, #16
 8009a10:	22ff      	movs	r2, #255	@ 0xff
 8009a12:	2100      	movs	r1, #0
 8009a14:	4618      	mov	r0, r3
 8009a16:	f7ff f942 	bl	8008c9e <lv_anim_set_values>
    lv_anim_set_duration(&a, tr_dsc->time);
 8009a1a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8009a1e:	881b      	ldrh	r3, [r3, #0]
 8009a20:	461a      	mov	r2, r3
 8009a22:	f107 0310 	add.w	r3, r7, #16
 8009a26:	4611      	mov	r1, r2
 8009a28:	4618      	mov	r0, r3
 8009a2a:	f7ff f91b 	bl	8008c64 <lv_anim_set_duration>
    lv_anim_set_delay(&a, tr_dsc->delay);
 8009a2e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8009a32:	885b      	ldrh	r3, [r3, #2]
 8009a34:	461a      	mov	r2, r3
 8009a36:	f107 0310 	add.w	r3, r7, #16
 8009a3a:	4611      	mov	r1, r2
 8009a3c:	4618      	mov	r0, r3
 8009a3e:	f7ff f91f 	bl	8008c80 <lv_anim_set_delay>
    lv_anim_set_path_cb(&a, tr_dsc->path_cb);
 8009a42:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8009a46:	68da      	ldr	r2, [r3, #12]
 8009a48:	f107 0310 	add.w	r3, r7, #16
 8009a4c:	4611      	mov	r1, r2
 8009a4e:	4618      	mov	r0, r3
 8009a50:	f7ff f93b 	bl	8008cca <lv_anim_set_path_cb>
    lv_anim_set_early_apply(&a, false);
 8009a54:	f107 0310 	add.w	r3, r7, #16
 8009a58:	2100      	movs	r1, #0
 8009a5a:	4618      	mov	r0, r3
 8009a5c:	f7ff f95f 	bl	8008d1e <lv_anim_set_early_apply>
    lv_anim_set_user_data(&a, tr_dsc->user_data);
 8009a60:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8009a64:	691a      	ldr	r2, [r3, #16]
 8009a66:	f107 0310 	add.w	r3, r7, #16
 8009a6a:	4611      	mov	r1, r2
 8009a6c:	4618      	mov	r0, r3
 8009a6e:	f7ff f96a 	bl	8008d46 <lv_anim_set_user_data>
    lv_anim_start(&a);
 8009a72:	f107 0310 	add.w	r3, r7, #16
 8009a76:	4618      	mov	r0, r3
 8009a78:	f017 fa84 	bl	8020f84 <lv_anim_start>
 8009a7c:	e002      	b.n	8009a84 <_lv_obj_style_create_transition+0x228>
    if(v1.ptr == v2.ptr && v1.num == v2.num && lv_color_eq(v1.color, v2.color))  return;
 8009a7e:	bf00      	nop
 8009a80:	e000      	b.n	8009a84 <_lv_obj_style_create_transition+0x228>
    if(tr == NULL) return;
 8009a82:	bf00      	nop
}
 8009a84:	3780      	adds	r7, #128	@ 0x80
 8009a86:	46bd      	mov	sp, r7
 8009a88:	bd80      	pop	{r7, pc}
 8009a8a:	bf00      	nop
 8009a8c:	200000b4 	.word	0x200000b4
 8009a90:	0800a5d9 	.word	0x0800a5d9
 8009a94:	0800a879 	.word	0x0800a879
 8009a98:	0800a8f5 	.word	0x0800a8f5

08009a9c <_lv_obj_style_apply_color_filter>:

lv_style_value_t _lv_obj_style_apply_color_filter(const lv_obj_t * obj, uint32_t part, lv_style_value_t v)
{
 8009a9c:	b580      	push	{r7, lr}
 8009a9e:	b088      	sub	sp, #32
 8009aa0:	af00      	add	r7, sp, #0
 8009aa2:	60f8      	str	r0, [r7, #12]
 8009aa4:	60b9      	str	r1, [r7, #8]
 8009aa6:	607a      	str	r2, [r7, #4]
    if(obj == NULL) return v;
 8009aa8:	68fb      	ldr	r3, [r7, #12]
 8009aaa:	2b00      	cmp	r3, #0
 8009aac:	d102      	bne.n	8009ab4 <_lv_obj_style_apply_color_filter+0x18>
 8009aae:	687b      	ldr	r3, [r7, #4]
 8009ab0:	617b      	str	r3, [r7, #20]
 8009ab2:	e025      	b.n	8009b00 <_lv_obj_style_apply_color_filter+0x64>
    const lv_color_filter_dsc_t * f = lv_obj_get_style_color_filter_dsc(obj, part);
 8009ab4:	68b9      	ldr	r1, [r7, #8]
 8009ab6:	68f8      	ldr	r0, [r7, #12]
 8009ab8:	f7ff fac7 	bl	800904a <lv_obj_get_style_color_filter_dsc>
 8009abc:	61f8      	str	r0, [r7, #28]
    if(f && f->filter_cb) {
 8009abe:	69fb      	ldr	r3, [r7, #28]
 8009ac0:	2b00      	cmp	r3, #0
 8009ac2:	d01b      	beq.n	8009afc <_lv_obj_style_apply_color_filter+0x60>
 8009ac4:	69fb      	ldr	r3, [r7, #28]
 8009ac6:	681b      	ldr	r3, [r3, #0]
 8009ac8:	2b00      	cmp	r3, #0
 8009aca:	d017      	beq.n	8009afc <_lv_obj_style_apply_color_filter+0x60>
        lv_opa_t f_opa = lv_obj_get_style_color_filter_opa(obj, part);
 8009acc:	68b9      	ldr	r1, [r7, #8]
 8009ace:	68f8      	ldr	r0, [r7, #12]
 8009ad0:	f7ff facc 	bl	800906c <lv_obj_get_style_color_filter_opa>
 8009ad4:	4603      	mov	r3, r0
 8009ad6:	76fb      	strb	r3, [r7, #27]
        if(f_opa != 0) v.color = f->filter_cb(f, v.color, f_opa);
 8009ad8:	7efb      	ldrb	r3, [r7, #27]
 8009ada:	2b00      	cmp	r3, #0
 8009adc:	d00e      	beq.n	8009afc <_lv_obj_style_apply_color_filter+0x60>
 8009ade:	69fb      	ldr	r3, [r7, #28]
 8009ae0:	681b      	ldr	r3, [r3, #0]
 8009ae2:	7efa      	ldrb	r2, [r7, #27]
 8009ae4:	6879      	ldr	r1, [r7, #4]
 8009ae6:	69f8      	ldr	r0, [r7, #28]
 8009ae8:	4798      	blx	r3
 8009aea:	4603      	mov	r3, r0
 8009aec:	461a      	mov	r2, r3
 8009aee:	713a      	strb	r2, [r7, #4]
 8009af0:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8009af4:	717a      	strb	r2, [r7, #5]
 8009af6:	f3c3 4307 	ubfx	r3, r3, #16, #8
 8009afa:	71bb      	strb	r3, [r7, #6]
    }
    return v;
 8009afc:	687b      	ldr	r3, [r7, #4]
 8009afe:	617b      	str	r3, [r7, #20]
}
 8009b00:	697b      	ldr	r3, [r7, #20]
 8009b02:	4618      	mov	r0, r3
 8009b04:	3720      	adds	r7, #32
 8009b06:	46bd      	mov	sp, r7
 8009b08:	bd80      	pop	{r7, pc}

08009b0a <_lv_obj_style_state_compare>:

_lv_style_state_cmp_t _lv_obj_style_state_compare(lv_obj_t * obj, lv_state_t state1, lv_state_t state2)
{
 8009b0a:	b580      	push	{r7, lr}
 8009b0c:	b088      	sub	sp, #32
 8009b0e:	af00      	add	r7, sp, #0
 8009b10:	6078      	str	r0, [r7, #4]
 8009b12:	460b      	mov	r3, r1
 8009b14:	807b      	strh	r3, [r7, #2]
 8009b16:	4613      	mov	r3, r2
 8009b18:	803b      	strh	r3, [r7, #0]
    _lv_style_state_cmp_t res = _LV_STYLE_STATE_CMP_SAME;
 8009b1a:	2300      	movs	r3, #0
 8009b1c:	77fb      	strb	r3, [r7, #31]

    /*Are there any new styles for the new state?*/
    uint32_t i;
    for(i = 0; i < obj->style_cnt; i++) {
 8009b1e:	2300      	movs	r3, #0
 8009b20:	61bb      	str	r3, [r7, #24]
 8009b22:	e1cc      	b.n	8009ebe <_lv_obj_style_state_compare+0x3b4>
        if(obj->styles[i].is_trans) continue;
 8009b24:	687b      	ldr	r3, [r7, #4]
 8009b26:	68da      	ldr	r2, [r3, #12]
 8009b28:	69bb      	ldr	r3, [r7, #24]
 8009b2a:	00db      	lsls	r3, r3, #3
 8009b2c:	4413      	add	r3, r2
 8009b2e:	79db      	ldrb	r3, [r3, #7]
 8009b30:	f003 0302 	and.w	r3, r3, #2
 8009b34:	b2db      	uxtb	r3, r3
 8009b36:	2b00      	cmp	r3, #0
 8009b38:	f040 81bd 	bne.w	8009eb6 <_lv_obj_style_state_compare+0x3ac>

        lv_state_t state_act = lv_obj_style_get_selector_state(obj->styles[i].selector);
 8009b3c:	687b      	ldr	r3, [r7, #4]
 8009b3e:	68da      	ldr	r2, [r3, #12]
 8009b40:	69bb      	ldr	r3, [r7, #24]
 8009b42:	00db      	lsls	r3, r3, #3
 8009b44:	4413      	add	r3, r2
 8009b46:	685b      	ldr	r3, [r3, #4]
 8009b48:	f3c3 0317 	ubfx	r3, r3, #0, #24
 8009b4c:	4618      	mov	r0, r3
 8009b4e:	f7ff f9b6 	bl	8008ebe <lv_obj_style_get_selector_state>
 8009b52:	4603      	mov	r3, r0
 8009b54:	82bb      	strh	r3, [r7, #20]
        /*The style is valid for a state but not the other*/
        bool valid1 = state_act & (~state1) ? false : true;
 8009b56:	8aba      	ldrh	r2, [r7, #20]
 8009b58:	887b      	ldrh	r3, [r7, #2]
 8009b5a:	43db      	mvns	r3, r3
 8009b5c:	4013      	ands	r3, r2
 8009b5e:	2b00      	cmp	r3, #0
 8009b60:	bf0c      	ite	eq
 8009b62:	2301      	moveq	r3, #1
 8009b64:	2300      	movne	r3, #0
 8009b66:	74fb      	strb	r3, [r7, #19]
        bool valid2 = state_act & (~state2) ? false : true;
 8009b68:	8aba      	ldrh	r2, [r7, #20]
 8009b6a:	883b      	ldrh	r3, [r7, #0]
 8009b6c:	43db      	mvns	r3, r3
 8009b6e:	4013      	ands	r3, r2
 8009b70:	2b00      	cmp	r3, #0
 8009b72:	bf0c      	ite	eq
 8009b74:	2301      	moveq	r3, #1
 8009b76:	2300      	movne	r3, #0
 8009b78:	74bb      	strb	r3, [r7, #18]
        if(valid1 != valid2) {
 8009b7a:	7cfa      	ldrb	r2, [r7, #19]
 8009b7c:	7cbb      	ldrb	r3, [r7, #18]
 8009b7e:	429a      	cmp	r2, r3
 8009b80:	f000 819a 	beq.w	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            const lv_style_t * style = obj->styles[i].style;
 8009b84:	687b      	ldr	r3, [r7, #4]
 8009b86:	68da      	ldr	r2, [r3, #12]
 8009b88:	69bb      	ldr	r3, [r7, #24]
 8009b8a:	00db      	lsls	r3, r3, #3
 8009b8c:	4413      	add	r3, r2
 8009b8e:	681b      	ldr	r3, [r3, #0]
 8009b90:	60fb      	str	r3, [r7, #12]
            lv_style_value_t v;
            /*If there is layout difference on the main part, return immediately. There is no more serious difference*/
            bool layout_diff = false;
 8009b92:	2300      	movs	r3, #0
 8009b94:	75fb      	strb	r3, [r7, #23]
            if(lv_style_get_prop(style, LV_STYLE_PAD_TOP, &v))layout_diff = true;
 8009b96:	f107 0308 	add.w	r3, r7, #8
 8009b9a:	461a      	mov	r2, r3
 8009b9c:	2110      	movs	r1, #16
 8009b9e:	68f8      	ldr	r0, [r7, #12]
 8009ba0:	f019 ffd1 	bl	8023b46 <lv_style_get_prop>
 8009ba4:	4603      	mov	r3, r0
 8009ba6:	2b00      	cmp	r3, #0
 8009ba8:	d002      	beq.n	8009bb0 <_lv_obj_style_state_compare+0xa6>
 8009baa:	2301      	movs	r3, #1
 8009bac:	75fb      	strb	r3, [r7, #23]
 8009bae:	e0c1      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_PAD_BOTTOM, &v)) layout_diff = true;
 8009bb0:	f107 0308 	add.w	r3, r7, #8
 8009bb4:	461a      	mov	r2, r3
 8009bb6:	2111      	movs	r1, #17
 8009bb8:	68f8      	ldr	r0, [r7, #12]
 8009bba:	f019 ffc4 	bl	8023b46 <lv_style_get_prop>
 8009bbe:	4603      	mov	r3, r0
 8009bc0:	2b00      	cmp	r3, #0
 8009bc2:	d002      	beq.n	8009bca <_lv_obj_style_state_compare+0xc0>
 8009bc4:	2301      	movs	r3, #1
 8009bc6:	75fb      	strb	r3, [r7, #23]
 8009bc8:	e0b4      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_PAD_LEFT, &v)) layout_diff = true;
 8009bca:	f107 0308 	add.w	r3, r7, #8
 8009bce:	461a      	mov	r2, r3
 8009bd0:	2112      	movs	r1, #18
 8009bd2:	68f8      	ldr	r0, [r7, #12]
 8009bd4:	f019 ffb7 	bl	8023b46 <lv_style_get_prop>
 8009bd8:	4603      	mov	r3, r0
 8009bda:	2b00      	cmp	r3, #0
 8009bdc:	d002      	beq.n	8009be4 <_lv_obj_style_state_compare+0xda>
 8009bde:	2301      	movs	r3, #1
 8009be0:	75fb      	strb	r3, [r7, #23]
 8009be2:	e0a7      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_PAD_RIGHT, &v)) layout_diff = true;
 8009be4:	f107 0308 	add.w	r3, r7, #8
 8009be8:	461a      	mov	r2, r3
 8009bea:	2113      	movs	r1, #19
 8009bec:	68f8      	ldr	r0, [r7, #12]
 8009bee:	f019 ffaa 	bl	8023b46 <lv_style_get_prop>
 8009bf2:	4603      	mov	r3, r0
 8009bf4:	2b00      	cmp	r3, #0
 8009bf6:	d002      	beq.n	8009bfe <_lv_obj_style_state_compare+0xf4>
 8009bf8:	2301      	movs	r3, #1
 8009bfa:	75fb      	strb	r3, [r7, #23]
 8009bfc:	e09a      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_PAD_COLUMN, &v)) layout_diff = true;
 8009bfe:	f107 0308 	add.w	r3, r7, #8
 8009c02:	461a      	mov	r2, r3
 8009c04:	2115      	movs	r1, #21
 8009c06:	68f8      	ldr	r0, [r7, #12]
 8009c08:	f019 ff9d 	bl	8023b46 <lv_style_get_prop>
 8009c0c:	4603      	mov	r3, r0
 8009c0e:	2b00      	cmp	r3, #0
 8009c10:	d002      	beq.n	8009c18 <_lv_obj_style_state_compare+0x10e>
 8009c12:	2301      	movs	r3, #1
 8009c14:	75fb      	strb	r3, [r7, #23]
 8009c16:	e08d      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_PAD_ROW, &v)) layout_diff = true;
 8009c18:	f107 0308 	add.w	r3, r7, #8
 8009c1c:	461a      	mov	r2, r3
 8009c1e:	2114      	movs	r1, #20
 8009c20:	68f8      	ldr	r0, [r7, #12]
 8009c22:	f019 ff90 	bl	8023b46 <lv_style_get_prop>
 8009c26:	4603      	mov	r3, r0
 8009c28:	2b00      	cmp	r3, #0
 8009c2a:	d002      	beq.n	8009c32 <_lv_obj_style_state_compare+0x128>
 8009c2c:	2301      	movs	r3, #1
 8009c2e:	75fb      	strb	r3, [r7, #23]
 8009c30:	e080      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_LAYOUT, &v)) layout_diff = true;
 8009c32:	f107 0308 	add.w	r3, r7, #8
 8009c36:	461a      	mov	r2, r3
 8009c38:	2116      	movs	r1, #22
 8009c3a:	68f8      	ldr	r0, [r7, #12]
 8009c3c:	f019 ff83 	bl	8023b46 <lv_style_get_prop>
 8009c40:	4603      	mov	r3, r0
 8009c42:	2b00      	cmp	r3, #0
 8009c44:	d002      	beq.n	8009c4c <_lv_obj_style_state_compare+0x142>
 8009c46:	2301      	movs	r3, #1
 8009c48:	75fb      	strb	r3, [r7, #23]
 8009c4a:	e073      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_TRANSLATE_X, &v)) layout_diff = true;
 8009c4c:	f107 0308 	add.w	r3, r7, #8
 8009c50:	461a      	mov	r2, r3
 8009c52:	216a      	movs	r1, #106	@ 0x6a
 8009c54:	68f8      	ldr	r0, [r7, #12]
 8009c56:	f019 ff76 	bl	8023b46 <lv_style_get_prop>
 8009c5a:	4603      	mov	r3, r0
 8009c5c:	2b00      	cmp	r3, #0
 8009c5e:	d002      	beq.n	8009c66 <_lv_obj_style_state_compare+0x15c>
 8009c60:	2301      	movs	r3, #1
 8009c62:	75fb      	strb	r3, [r7, #23]
 8009c64:	e066      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_TRANSLATE_Y, &v)) layout_diff = true;
 8009c66:	f107 0308 	add.w	r3, r7, #8
 8009c6a:	461a      	mov	r2, r3
 8009c6c:	216b      	movs	r1, #107	@ 0x6b
 8009c6e:	68f8      	ldr	r0, [r7, #12]
 8009c70:	f019 ff69 	bl	8023b46 <lv_style_get_prop>
 8009c74:	4603      	mov	r3, r0
 8009c76:	2b00      	cmp	r3, #0
 8009c78:	d002      	beq.n	8009c80 <_lv_obj_style_state_compare+0x176>
 8009c7a:	2301      	movs	r3, #1
 8009c7c:	75fb      	strb	r3, [r7, #23]
 8009c7e:	e059      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_WIDTH, &v)) layout_diff = true;
 8009c80:	f107 0308 	add.w	r3, r7, #8
 8009c84:	461a      	mov	r2, r3
 8009c86:	2101      	movs	r1, #1
 8009c88:	68f8      	ldr	r0, [r7, #12]
 8009c8a:	f019 ff5c 	bl	8023b46 <lv_style_get_prop>
 8009c8e:	4603      	mov	r3, r0
 8009c90:	2b00      	cmp	r3, #0
 8009c92:	d002      	beq.n	8009c9a <_lv_obj_style_state_compare+0x190>
 8009c94:	2301      	movs	r3, #1
 8009c96:	75fb      	strb	r3, [r7, #23]
 8009c98:	e04c      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_HEIGHT, &v)) layout_diff = true;
 8009c9a:	f107 0308 	add.w	r3, r7, #8
 8009c9e:	461a      	mov	r2, r3
 8009ca0:	2102      	movs	r1, #2
 8009ca2:	68f8      	ldr	r0, [r7, #12]
 8009ca4:	f019 ff4f 	bl	8023b46 <lv_style_get_prop>
 8009ca8:	4603      	mov	r3, r0
 8009caa:	2b00      	cmp	r3, #0
 8009cac:	d002      	beq.n	8009cb4 <_lv_obj_style_state_compare+0x1aa>
 8009cae:	2301      	movs	r3, #1
 8009cb0:	75fb      	strb	r3, [r7, #23]
 8009cb2:	e03f      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_MIN_WIDTH, &v)) layout_diff = true;
 8009cb4:	f107 0308 	add.w	r3, r7, #8
 8009cb8:	461a      	mov	r2, r3
 8009cba:	2104      	movs	r1, #4
 8009cbc:	68f8      	ldr	r0, [r7, #12]
 8009cbe:	f019 ff42 	bl	8023b46 <lv_style_get_prop>
 8009cc2:	4603      	mov	r3, r0
 8009cc4:	2b00      	cmp	r3, #0
 8009cc6:	d002      	beq.n	8009cce <_lv_obj_style_state_compare+0x1c4>
 8009cc8:	2301      	movs	r3, #1
 8009cca:	75fb      	strb	r3, [r7, #23]
 8009ccc:	e032      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_MAX_WIDTH, &v)) layout_diff = true;
 8009cce:	f107 0308 	add.w	r3, r7, #8
 8009cd2:	461a      	mov	r2, r3
 8009cd4:	2105      	movs	r1, #5
 8009cd6:	68f8      	ldr	r0, [r7, #12]
 8009cd8:	f019 ff35 	bl	8023b46 <lv_style_get_prop>
 8009cdc:	4603      	mov	r3, r0
 8009cde:	2b00      	cmp	r3, #0
 8009ce0:	d002      	beq.n	8009ce8 <_lv_obj_style_state_compare+0x1de>
 8009ce2:	2301      	movs	r3, #1
 8009ce4:	75fb      	strb	r3, [r7, #23]
 8009ce6:	e025      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_MIN_HEIGHT, &v)) layout_diff = true;
 8009ce8:	f107 0308 	add.w	r3, r7, #8
 8009cec:	461a      	mov	r2, r3
 8009cee:	2106      	movs	r1, #6
 8009cf0:	68f8      	ldr	r0, [r7, #12]
 8009cf2:	f019 ff28 	bl	8023b46 <lv_style_get_prop>
 8009cf6:	4603      	mov	r3, r0
 8009cf8:	2b00      	cmp	r3, #0
 8009cfa:	d002      	beq.n	8009d02 <_lv_obj_style_state_compare+0x1f8>
 8009cfc:	2301      	movs	r3, #1
 8009cfe:	75fb      	strb	r3, [r7, #23]
 8009d00:	e018      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_MAX_HEIGHT, &v)) layout_diff = true;
 8009d02:	f107 0308 	add.w	r3, r7, #8
 8009d06:	461a      	mov	r2, r3
 8009d08:	2107      	movs	r1, #7
 8009d0a:	68f8      	ldr	r0, [r7, #12]
 8009d0c:	f019 ff1b 	bl	8023b46 <lv_style_get_prop>
 8009d10:	4603      	mov	r3, r0
 8009d12:	2b00      	cmp	r3, #0
 8009d14:	d002      	beq.n	8009d1c <_lv_obj_style_state_compare+0x212>
 8009d16:	2301      	movs	r3, #1
 8009d18:	75fb      	strb	r3, [r7, #23]
 8009d1a:	e00b      	b.n	8009d34 <_lv_obj_style_state_compare+0x22a>
            else if(lv_style_get_prop(style, LV_STYLE_BORDER_WIDTH, &v)) layout_diff = true;
 8009d1c:	f107 0308 	add.w	r3, r7, #8
 8009d20:	461a      	mov	r2, r3
 8009d22:	2130      	movs	r1, #48	@ 0x30
 8009d24:	68f8      	ldr	r0, [r7, #12]
 8009d26:	f019 ff0e 	bl	8023b46 <lv_style_get_prop>
 8009d2a:	4603      	mov	r3, r0
 8009d2c:	2b00      	cmp	r3, #0
 8009d2e:	d001      	beq.n	8009d34 <_lv_obj_style_state_compare+0x22a>
 8009d30:	2301      	movs	r3, #1
 8009d32:	75fb      	strb	r3, [r7, #23]

            if(layout_diff) {
 8009d34:	7dfb      	ldrb	r3, [r7, #23]
 8009d36:	2b00      	cmp	r3, #0
 8009d38:	d001      	beq.n	8009d3e <_lv_obj_style_state_compare+0x234>
                return _LV_STYLE_STATE_CMP_DIFF_LAYOUT;
 8009d3a:	2303      	movs	r3, #3
 8009d3c:	e0ca      	b.n	8009ed4 <_lv_obj_style_state_compare+0x3ca>
            }

            /*Check for draw pad changes*/
            if(lv_style_get_prop(style, LV_STYLE_TRANSFORM_WIDTH, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009d3e:	f107 0308 	add.w	r3, r7, #8
 8009d42:	461a      	mov	r2, r3
 8009d44:	2168      	movs	r1, #104	@ 0x68
 8009d46:	68f8      	ldr	r0, [r7, #12]
 8009d48:	f019 fefd 	bl	8023b46 <lv_style_get_prop>
 8009d4c:	4603      	mov	r3, r0
 8009d4e:	2b00      	cmp	r3, #0
 8009d50:	d002      	beq.n	8009d58 <_lv_obj_style_state_compare+0x24e>
 8009d52:	2302      	movs	r3, #2
 8009d54:	77fb      	strb	r3, [r7, #31]
 8009d56:	e0af      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_TRANSFORM_HEIGHT, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009d58:	f107 0308 	add.w	r3, r7, #8
 8009d5c:	461a      	mov	r2, r3
 8009d5e:	2169      	movs	r1, #105	@ 0x69
 8009d60:	68f8      	ldr	r0, [r7, #12]
 8009d62:	f019 fef0 	bl	8023b46 <lv_style_get_prop>
 8009d66:	4603      	mov	r3, r0
 8009d68:	2b00      	cmp	r3, #0
 8009d6a:	d002      	beq.n	8009d72 <_lv_obj_style_state_compare+0x268>
 8009d6c:	2302      	movs	r3, #2
 8009d6e:	77fb      	strb	r3, [r7, #31]
 8009d70:	e0a2      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_TRANSFORM_ROTATION, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009d72:	f107 0308 	add.w	r3, r7, #8
 8009d76:	461a      	mov	r2, r3
 8009d78:	216e      	movs	r1, #110	@ 0x6e
 8009d7a:	68f8      	ldr	r0, [r7, #12]
 8009d7c:	f019 fee3 	bl	8023b46 <lv_style_get_prop>
 8009d80:	4603      	mov	r3, r0
 8009d82:	2b00      	cmp	r3, #0
 8009d84:	d002      	beq.n	8009d8c <_lv_obj_style_state_compare+0x282>
 8009d86:	2302      	movs	r3, #2
 8009d88:	77fb      	strb	r3, [r7, #31]
 8009d8a:	e095      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_TRANSFORM_SCALE_X, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009d8c:	f107 0308 	add.w	r3, r7, #8
 8009d90:	461a      	mov	r2, r3
 8009d92:	216c      	movs	r1, #108	@ 0x6c
 8009d94:	68f8      	ldr	r0, [r7, #12]
 8009d96:	f019 fed6 	bl	8023b46 <lv_style_get_prop>
 8009d9a:	4603      	mov	r3, r0
 8009d9c:	2b00      	cmp	r3, #0
 8009d9e:	d002      	beq.n	8009da6 <_lv_obj_style_state_compare+0x29c>
 8009da0:	2302      	movs	r3, #2
 8009da2:	77fb      	strb	r3, [r7, #31]
 8009da4:	e088      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_TRANSFORM_SCALE_Y, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009da6:	f107 0308 	add.w	r3, r7, #8
 8009daa:	461a      	mov	r2, r3
 8009dac:	216d      	movs	r1, #109	@ 0x6d
 8009dae:	68f8      	ldr	r0, [r7, #12]
 8009db0:	f019 fec9 	bl	8023b46 <lv_style_get_prop>
 8009db4:	4603      	mov	r3, r0
 8009db6:	2b00      	cmp	r3, #0
 8009db8:	d002      	beq.n	8009dc0 <_lv_obj_style_state_compare+0x2b6>
 8009dba:	2302      	movs	r3, #2
 8009dbc:	77fb      	strb	r3, [r7, #31]
 8009dbe:	e07b      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_OUTLINE_OPA, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009dc0:	f107 0308 	add.w	r3, r7, #8
 8009dc4:	461a      	mov	r2, r3
 8009dc6:	213a      	movs	r1, #58	@ 0x3a
 8009dc8:	68f8      	ldr	r0, [r7, #12]
 8009dca:	f019 febc 	bl	8023b46 <lv_style_get_prop>
 8009dce:	4603      	mov	r3, r0
 8009dd0:	2b00      	cmp	r3, #0
 8009dd2:	d002      	beq.n	8009dda <_lv_obj_style_state_compare+0x2d0>
 8009dd4:	2302      	movs	r3, #2
 8009dd6:	77fb      	strb	r3, [r7, #31]
 8009dd8:	e06e      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_OUTLINE_PAD, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009dda:	f107 0308 	add.w	r3, r7, #8
 8009dde:	461a      	mov	r2, r3
 8009de0:	213b      	movs	r1, #59	@ 0x3b
 8009de2:	68f8      	ldr	r0, [r7, #12]
 8009de4:	f019 feaf 	bl	8023b46 <lv_style_get_prop>
 8009de8:	4603      	mov	r3, r0
 8009dea:	2b00      	cmp	r3, #0
 8009dec:	d002      	beq.n	8009df4 <_lv_obj_style_state_compare+0x2ea>
 8009dee:	2302      	movs	r3, #2
 8009df0:	77fb      	strb	r3, [r7, #31]
 8009df2:	e061      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_OUTLINE_WIDTH, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009df4:	f107 0308 	add.w	r3, r7, #8
 8009df8:	461a      	mov	r2, r3
 8009dfa:	2138      	movs	r1, #56	@ 0x38
 8009dfc:	68f8      	ldr	r0, [r7, #12]
 8009dfe:	f019 fea2 	bl	8023b46 <lv_style_get_prop>
 8009e02:	4603      	mov	r3, r0
 8009e04:	2b00      	cmp	r3, #0
 8009e06:	d002      	beq.n	8009e0e <_lv_obj_style_state_compare+0x304>
 8009e08:	2302      	movs	r3, #2
 8009e0a:	77fb      	strb	r3, [r7, #31]
 8009e0c:	e054      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_SHADOW_WIDTH, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009e0e:	f107 0308 	add.w	r3, r7, #8
 8009e12:	461a      	mov	r2, r3
 8009e14:	213c      	movs	r1, #60	@ 0x3c
 8009e16:	68f8      	ldr	r0, [r7, #12]
 8009e18:	f019 fe95 	bl	8023b46 <lv_style_get_prop>
 8009e1c:	4603      	mov	r3, r0
 8009e1e:	2b00      	cmp	r3, #0
 8009e20:	d002      	beq.n	8009e28 <_lv_obj_style_state_compare+0x31e>
 8009e22:	2302      	movs	r3, #2
 8009e24:	77fb      	strb	r3, [r7, #31]
 8009e26:	e047      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_SHADOW_OPA, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009e28:	f107 0308 	add.w	r3, r7, #8
 8009e2c:	461a      	mov	r2, r3
 8009e2e:	213e      	movs	r1, #62	@ 0x3e
 8009e30:	68f8      	ldr	r0, [r7, #12]
 8009e32:	f019 fe88 	bl	8023b46 <lv_style_get_prop>
 8009e36:	4603      	mov	r3, r0
 8009e38:	2b00      	cmp	r3, #0
 8009e3a:	d002      	beq.n	8009e42 <_lv_obj_style_state_compare+0x338>
 8009e3c:	2302      	movs	r3, #2
 8009e3e:	77fb      	strb	r3, [r7, #31]
 8009e40:	e03a      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_SHADOW_OFFSET_X, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009e42:	f107 0308 	add.w	r3, r7, #8
 8009e46:	461a      	mov	r2, r3
 8009e48:	2140      	movs	r1, #64	@ 0x40
 8009e4a:	68f8      	ldr	r0, [r7, #12]
 8009e4c:	f019 fe7b 	bl	8023b46 <lv_style_get_prop>
 8009e50:	4603      	mov	r3, r0
 8009e52:	2b00      	cmp	r3, #0
 8009e54:	d002      	beq.n	8009e5c <_lv_obj_style_state_compare+0x352>
 8009e56:	2302      	movs	r3, #2
 8009e58:	77fb      	strb	r3, [r7, #31]
 8009e5a:	e02d      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_SHADOW_OFFSET_Y, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009e5c:	f107 0308 	add.w	r3, r7, #8
 8009e60:	461a      	mov	r2, r3
 8009e62:	2141      	movs	r1, #65	@ 0x41
 8009e64:	68f8      	ldr	r0, [r7, #12]
 8009e66:	f019 fe6e 	bl	8023b46 <lv_style_get_prop>
 8009e6a:	4603      	mov	r3, r0
 8009e6c:	2b00      	cmp	r3, #0
 8009e6e:	d002      	beq.n	8009e76 <_lv_obj_style_state_compare+0x36c>
 8009e70:	2302      	movs	r3, #2
 8009e72:	77fb      	strb	r3, [r7, #31]
 8009e74:	e020      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_SHADOW_SPREAD, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009e76:	f107 0308 	add.w	r3, r7, #8
 8009e7a:	461a      	mov	r2, r3
 8009e7c:	2142      	movs	r1, #66	@ 0x42
 8009e7e:	68f8      	ldr	r0, [r7, #12]
 8009e80:	f019 fe61 	bl	8023b46 <lv_style_get_prop>
 8009e84:	4603      	mov	r3, r0
 8009e86:	2b00      	cmp	r3, #0
 8009e88:	d002      	beq.n	8009e90 <_lv_obj_style_state_compare+0x386>
 8009e8a:	2302      	movs	r3, #2
 8009e8c:	77fb      	strb	r3, [r7, #31]
 8009e8e:	e013      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(lv_style_get_prop(style, LV_STYLE_LINE_WIDTH, &v)) res = _LV_STYLE_STATE_CMP_DIFF_DRAW_PAD;
 8009e90:	f107 0308 	add.w	r3, r7, #8
 8009e94:	461a      	mov	r2, r3
 8009e96:	2148      	movs	r1, #72	@ 0x48
 8009e98:	68f8      	ldr	r0, [r7, #12]
 8009e9a:	f019 fe54 	bl	8023b46 <lv_style_get_prop>
 8009e9e:	4603      	mov	r3, r0
 8009ea0:	2b00      	cmp	r3, #0
 8009ea2:	d002      	beq.n	8009eaa <_lv_obj_style_state_compare+0x3a0>
 8009ea4:	2302      	movs	r3, #2
 8009ea6:	77fb      	strb	r3, [r7, #31]
 8009ea8:	e006      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
            else if(res == _LV_STYLE_STATE_CMP_SAME) res = _LV_STYLE_STATE_CMP_DIFF_REDRAW;
 8009eaa:	7ffb      	ldrb	r3, [r7, #31]
 8009eac:	2b00      	cmp	r3, #0
 8009eae:	d103      	bne.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
 8009eb0:	2301      	movs	r3, #1
 8009eb2:	77fb      	strb	r3, [r7, #31]
 8009eb4:	e000      	b.n	8009eb8 <_lv_obj_style_state_compare+0x3ae>
        if(obj->styles[i].is_trans) continue;
 8009eb6:	bf00      	nop
    for(i = 0; i < obj->style_cnt; i++) {
 8009eb8:	69bb      	ldr	r3, [r7, #24]
 8009eba:	3301      	adds	r3, #1
 8009ebc:	61bb      	str	r3, [r7, #24]
 8009ebe:	687b      	ldr	r3, [r7, #4]
 8009ec0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8009ec2:	f3c3 1305 	ubfx	r3, r3, #4, #6
 8009ec6:	b2db      	uxtb	r3, r3
 8009ec8:	461a      	mov	r2, r3
 8009eca:	69bb      	ldr	r3, [r7, #24]
 8009ecc:	4293      	cmp	r3, r2
 8009ece:	f4ff ae29 	bcc.w	8009b24 <_lv_obj_style_state_compare+0x1a>
        }
    }

    return res;
 8009ed2:	7ffb      	ldrb	r3, [r7, #31]
}
 8009ed4:	4618      	mov	r0, r3
 8009ed6:	3720      	adds	r7, #32
 8009ed8:	46bd      	mov	sp, r7
 8009eda:	bd80      	pop	{r7, pc}

08009edc <lv_obj_calculate_style_text_align>:
    lv_anim_set_delay(&a, delay);
    lv_anim_start(&a);
}

lv_text_align_t lv_obj_calculate_style_text_align(const lv_obj_t * obj, lv_part_t part, const char * txt)
{
 8009edc:	b580      	push	{r7, lr}
 8009ede:	b086      	sub	sp, #24
 8009ee0:	af00      	add	r7, sp, #0
 8009ee2:	60f8      	str	r0, [r7, #12]
 8009ee4:	60b9      	str	r1, [r7, #8]
 8009ee6:	607a      	str	r2, [r7, #4]
    lv_text_align_t align = lv_obj_get_style_text_align(obj, part);
 8009ee8:	68b9      	ldr	r1, [r7, #8]
 8009eea:	68f8      	ldr	r0, [r7, #12]
 8009eec:	f7ff f877 	bl	8008fde <lv_obj_get_style_text_align>
 8009ef0:	4603      	mov	r3, r0
 8009ef2:	75fb      	strb	r3, [r7, #23]
    lv_base_dir_t base_dir = lv_obj_get_style_base_dir(obj, part);
 8009ef4:	68b9      	ldr	r1, [r7, #8]
 8009ef6:	68f8      	ldr	r0, [r7, #12]
 8009ef8:	f7ff f8dc 	bl	80090b4 <lv_obj_get_style_base_dir>
 8009efc:	4603      	mov	r3, r0
 8009efe:	75bb      	strb	r3, [r7, #22]
    lv_bidi_calculate_align(&align, &base_dir, txt);
 8009f00:	f107 0116 	add.w	r1, r7, #22
 8009f04:	f107 0317 	add.w	r3, r7, #23
 8009f08:	687a      	ldr	r2, [r7, #4]
 8009f0a:	4618      	mov	r0, r3
 8009f0c:	f7fe ff29 	bl	8008d62 <lv_bidi_calculate_align>
    return align;
 8009f10:	7dfb      	ldrb	r3, [r7, #23]
}
 8009f12:	4618      	mov	r0, r3
 8009f14:	3718      	adds	r7, #24
 8009f16:	46bd      	mov	sp, r7
 8009f18:	bd80      	pop	{r7, pc}

08009f1a <lv_obj_get_style_opa_recursive>:

lv_opa_t lv_obj_get_style_opa_recursive(const lv_obj_t * obj, lv_part_t part)
{
 8009f1a:	b580      	push	{r7, lr}
 8009f1c:	b084      	sub	sp, #16
 8009f1e:	af00      	add	r7, sp, #0
 8009f20:	6078      	str	r0, [r7, #4]
 8009f22:	6039      	str	r1, [r7, #0]

    lv_opa_t opa_obj = lv_obj_get_style_opa(obj, part);
 8009f24:	6839      	ldr	r1, [r7, #0]
 8009f26:	6878      	ldr	r0, [r7, #4]
 8009f28:	f7ff f86b 	bl	8009002 <lv_obj_get_style_opa>
 8009f2c:	4603      	mov	r3, r0
 8009f2e:	73bb      	strb	r3, [r7, #14]
    if(opa_obj <= LV_OPA_MIN) return LV_OPA_TRANSP;
 8009f30:	7bbb      	ldrb	r3, [r7, #14]
 8009f32:	2b02      	cmp	r3, #2
 8009f34:	d801      	bhi.n	8009f3a <lv_obj_get_style_opa_recursive+0x20>
 8009f36:	2300      	movs	r3, #0
 8009f38:	e03b      	b.n	8009fb2 <lv_obj_get_style_opa_recursive+0x98>

    lv_opa_t opa_final = LV_OPA_COVER;
 8009f3a:	23ff      	movs	r3, #255	@ 0xff
 8009f3c:	73fb      	strb	r3, [r7, #15]
    if(opa_obj < LV_OPA_MAX) {
 8009f3e:	7bbb      	ldrb	r3, [r7, #14]
 8009f40:	2bfc      	cmp	r3, #252	@ 0xfc
 8009f42:	d805      	bhi.n	8009f50 <lv_obj_get_style_opa_recursive+0x36>
        opa_final = LV_OPA_MIX2(opa_final, opa_obj);
 8009f44:	7bfb      	ldrb	r3, [r7, #15]
 8009f46:	7bba      	ldrb	r2, [r7, #14]
 8009f48:	fb02 f303 	mul.w	r3, r2, r3
 8009f4c:	121b      	asrs	r3, r3, #8
 8009f4e:	73fb      	strb	r3, [r7, #15]
    }

    if(part != LV_PART_MAIN) {
 8009f50:	683b      	ldr	r3, [r7, #0]
 8009f52:	2b00      	cmp	r3, #0
 8009f54:	d002      	beq.n	8009f5c <lv_obj_get_style_opa_recursive+0x42>
        part = LV_PART_MAIN;
 8009f56:	2300      	movs	r3, #0
 8009f58:	603b      	str	r3, [r7, #0]
 8009f5a:	e01c      	b.n	8009f96 <lv_obj_get_style_opa_recursive+0x7c>
    }
    else {
        obj = lv_obj_get_parent(obj);
 8009f5c:	6878      	ldr	r0, [r7, #4]
 8009f5e:	f000 ff69 	bl	800ae34 <lv_obj_get_parent>
 8009f62:	6078      	str	r0, [r7, #4]
    }

    while(obj) {
 8009f64:	e017      	b.n	8009f96 <lv_obj_get_style_opa_recursive+0x7c>
        opa_obj = lv_obj_get_style_opa(obj, part);
 8009f66:	6839      	ldr	r1, [r7, #0]
 8009f68:	6878      	ldr	r0, [r7, #4]
 8009f6a:	f7ff f84a 	bl	8009002 <lv_obj_get_style_opa>
 8009f6e:	4603      	mov	r3, r0
 8009f70:	73bb      	strb	r3, [r7, #14]
        if(opa_obj <= LV_OPA_MIN) return LV_OPA_TRANSP;
 8009f72:	7bbb      	ldrb	r3, [r7, #14]
 8009f74:	2b02      	cmp	r3, #2
 8009f76:	d801      	bhi.n	8009f7c <lv_obj_get_style_opa_recursive+0x62>
 8009f78:	2300      	movs	r3, #0
 8009f7a:	e01a      	b.n	8009fb2 <lv_obj_get_style_opa_recursive+0x98>
        if(opa_obj < LV_OPA_MAX) {
 8009f7c:	7bbb      	ldrb	r3, [r7, #14]
 8009f7e:	2bfc      	cmp	r3, #252	@ 0xfc
 8009f80:	d805      	bhi.n	8009f8e <lv_obj_get_style_opa_recursive+0x74>
            opa_final = LV_OPA_MIX2(opa_final, opa_obj);
 8009f82:	7bfb      	ldrb	r3, [r7, #15]
 8009f84:	7bba      	ldrb	r2, [r7, #14]
 8009f86:	fb02 f303 	mul.w	r3, r2, r3
 8009f8a:	121b      	asrs	r3, r3, #8
 8009f8c:	73fb      	strb	r3, [r7, #15]
        }

        obj = lv_obj_get_parent(obj);
 8009f8e:	6878      	ldr	r0, [r7, #4]
 8009f90:	f000 ff50 	bl	800ae34 <lv_obj_get_parent>
 8009f94:	6078      	str	r0, [r7, #4]
    while(obj) {
 8009f96:	687b      	ldr	r3, [r7, #4]
 8009f98:	2b00      	cmp	r3, #0
 8009f9a:	d1e4      	bne.n	8009f66 <lv_obj_get_style_opa_recursive+0x4c>
    }

    if(opa_final <= LV_OPA_MIN) return LV_OPA_TRANSP;
 8009f9c:	7bfb      	ldrb	r3, [r7, #15]
 8009f9e:	2b02      	cmp	r3, #2
 8009fa0:	d801      	bhi.n	8009fa6 <lv_obj_get_style_opa_recursive+0x8c>
 8009fa2:	2300      	movs	r3, #0
 8009fa4:	e005      	b.n	8009fb2 <lv_obj_get_style_opa_recursive+0x98>
    if(opa_final >= LV_OPA_MAX) return LV_OPA_COVER;
 8009fa6:	7bfb      	ldrb	r3, [r7, #15]
 8009fa8:	2bfc      	cmp	r3, #252	@ 0xfc
 8009faa:	d901      	bls.n	8009fb0 <lv_obj_get_style_opa_recursive+0x96>
 8009fac:	23ff      	movs	r3, #255	@ 0xff
 8009fae:	e000      	b.n	8009fb2 <lv_obj_get_style_opa_recursive+0x98>
    return opa_final;
 8009fb0:	7bfb      	ldrb	r3, [r7, #15]
}
 8009fb2:	4618      	mov	r0, r3
 8009fb4:	3710      	adds	r7, #16
 8009fb6:	46bd      	mov	sp, r7
 8009fb8:	bd80      	pop	{r7, pc}

08009fba <get_local_style>:
 * @param obj pointer to an object
 * @param selector OR-ed value of parts and state for which the style should be get
 * @return pointer to the local style
 */
static lv_style_t * get_local_style(lv_obj_t * obj, lv_style_selector_t selector)
{
 8009fba:	b590      	push	{r4, r7, lr}
 8009fbc:	b085      	sub	sp, #20
 8009fbe:	af00      	add	r7, sp, #0
 8009fc0:	6078      	str	r0, [r7, #4]
 8009fc2:	6039      	str	r1, [r7, #0]
    uint32_t i;
    for(i = 0; i < obj->style_cnt; i++) {
 8009fc4:	2300      	movs	r3, #0
 8009fc6:	60fb      	str	r3, [r7, #12]
 8009fc8:	e020      	b.n	800a00c <get_local_style+0x52>
        if(obj->styles[i].is_local &&
 8009fca:	687b      	ldr	r3, [r7, #4]
 8009fcc:	68da      	ldr	r2, [r3, #12]
 8009fce:	68fb      	ldr	r3, [r7, #12]
 8009fd0:	00db      	lsls	r3, r3, #3
 8009fd2:	4413      	add	r3, r2
 8009fd4:	79db      	ldrb	r3, [r3, #7]
 8009fd6:	f003 0301 	and.w	r3, r3, #1
 8009fda:	b2db      	uxtb	r3, r3
 8009fdc:	2b00      	cmp	r3, #0
 8009fde:	d012      	beq.n	800a006 <get_local_style+0x4c>
           obj->styles[i].selector == selector) {
 8009fe0:	687b      	ldr	r3, [r7, #4]
 8009fe2:	68da      	ldr	r2, [r3, #12]
 8009fe4:	68fb      	ldr	r3, [r7, #12]
 8009fe6:	00db      	lsls	r3, r3, #3
 8009fe8:	4413      	add	r3, r2
 8009fea:	685b      	ldr	r3, [r3, #4]
 8009fec:	f3c3 0317 	ubfx	r3, r3, #0, #24
 8009ff0:	461a      	mov	r2, r3
        if(obj->styles[i].is_local &&
 8009ff2:	683b      	ldr	r3, [r7, #0]
 8009ff4:	4293      	cmp	r3, r2
 8009ff6:	d106      	bne.n	800a006 <get_local_style+0x4c>
            return (lv_style_t *)obj->styles[i].style;
 8009ff8:	687b      	ldr	r3, [r7, #4]
 8009ffa:	68da      	ldr	r2, [r3, #12]
 8009ffc:	68fb      	ldr	r3, [r7, #12]
 8009ffe:	00db      	lsls	r3, r3, #3
 800a000:	4413      	add	r3, r2
 800a002:	681b      	ldr	r3, [r3, #0]
 800a004:	e0aa      	b.n	800a15c <get_local_style+0x1a2>
    for(i = 0; i < obj->style_cnt; i++) {
 800a006:	68fb      	ldr	r3, [r7, #12]
 800a008:	3301      	adds	r3, #1
 800a00a:	60fb      	str	r3, [r7, #12]
 800a00c:	687b      	ldr	r3, [r7, #4]
 800a00e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a010:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a014:	b2db      	uxtb	r3, r3
 800a016:	461a      	mov	r2, r3
 800a018:	68fb      	ldr	r3, [r7, #12]
 800a01a:	4293      	cmp	r3, r2
 800a01c:	d3d5      	bcc.n	8009fca <get_local_style+0x10>
        }
    }

    obj->style_cnt++;
 800a01e:	687b      	ldr	r3, [r7, #4]
 800a020:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a022:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a026:	b2db      	uxtb	r3, r3
 800a028:	3301      	adds	r3, #1
 800a02a:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800a02e:	b2d9      	uxtb	r1, r3
 800a030:	687a      	ldr	r2, [r7, #4]
 800a032:	8d53      	ldrh	r3, [r2, #42]	@ 0x2a
 800a034:	f361 1309 	bfi	r3, r1, #4, #6
 800a038:	8553      	strh	r3, [r2, #42]	@ 0x2a
    LV_ASSERT(obj->style_cnt != 0);
 800a03a:	687b      	ldr	r3, [r7, #4]
 800a03c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a03e:	f403 737c 	and.w	r3, r3, #1008	@ 0x3f0
 800a042:	b29b      	uxth	r3, r3
 800a044:	2b00      	cmp	r3, #0
 800a046:	d101      	bne.n	800a04c <get_local_style+0x92>
 800a048:	bf00      	nop
 800a04a:	e7fd      	b.n	800a048 <get_local_style+0x8e>
    obj->styles = lv_realloc(obj->styles, obj->style_cnt * sizeof(_lv_obj_style_t));
 800a04c:	687b      	ldr	r3, [r7, #4]
 800a04e:	68da      	ldr	r2, [r3, #12]
 800a050:	687b      	ldr	r3, [r7, #4]
 800a052:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a054:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a058:	b2db      	uxtb	r3, r3
 800a05a:	00db      	lsls	r3, r3, #3
 800a05c:	4619      	mov	r1, r3
 800a05e:	4610      	mov	r0, r2
 800a060:	f01b ff02 	bl	8025e68 <lv_realloc>
 800a064:	4602      	mov	r2, r0
 800a066:	687b      	ldr	r3, [r7, #4]
 800a068:	60da      	str	r2, [r3, #12]
    LV_ASSERT_MALLOC(obj->styles);
 800a06a:	687b      	ldr	r3, [r7, #4]
 800a06c:	68db      	ldr	r3, [r3, #12]
 800a06e:	2b00      	cmp	r3, #0
 800a070:	d101      	bne.n	800a076 <get_local_style+0xbc>
 800a072:	bf00      	nop
 800a074:	e7fd      	b.n	800a072 <get_local_style+0xb8>

    for(i = obj->style_cnt - 1; i > 0 ; i--) {
 800a076:	687b      	ldr	r3, [r7, #4]
 800a078:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a07a:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a07e:	b2db      	uxtb	r3, r3
 800a080:	3b01      	subs	r3, #1
 800a082:	60fb      	str	r3, [r7, #12]
 800a084:	e030      	b.n	800a0e8 <get_local_style+0x12e>
        /*Copy only normal styles (not local and transition).
         *The new local style will be added as the last local style*/
        if(obj->styles[i - 1].is_local || obj->styles[i - 1].is_trans) break;
 800a086:	687b      	ldr	r3, [r7, #4]
 800a088:	68da      	ldr	r2, [r3, #12]
 800a08a:	68fb      	ldr	r3, [r7, #12]
 800a08c:	f103 5300 	add.w	r3, r3, #536870912	@ 0x20000000
 800a090:	3b01      	subs	r3, #1
 800a092:	00db      	lsls	r3, r3, #3
 800a094:	4413      	add	r3, r2
 800a096:	79db      	ldrb	r3, [r3, #7]
 800a098:	f003 0301 	and.w	r3, r3, #1
 800a09c:	b2db      	uxtb	r3, r3
 800a09e:	2b00      	cmp	r3, #0
 800a0a0:	d125      	bne.n	800a0ee <get_local_style+0x134>
 800a0a2:	687b      	ldr	r3, [r7, #4]
 800a0a4:	68da      	ldr	r2, [r3, #12]
 800a0a6:	68fb      	ldr	r3, [r7, #12]
 800a0a8:	f103 5300 	add.w	r3, r3, #536870912	@ 0x20000000
 800a0ac:	3b01      	subs	r3, #1
 800a0ae:	00db      	lsls	r3, r3, #3
 800a0b0:	4413      	add	r3, r2
 800a0b2:	79db      	ldrb	r3, [r3, #7]
 800a0b4:	f003 0302 	and.w	r3, r3, #2
 800a0b8:	b2db      	uxtb	r3, r3
 800a0ba:	2b00      	cmp	r3, #0
 800a0bc:	d117      	bne.n	800a0ee <get_local_style+0x134>
        obj->styles[i] = obj->styles[i - 1];
 800a0be:	687b      	ldr	r3, [r7, #4]
 800a0c0:	68da      	ldr	r2, [r3, #12]
 800a0c2:	68fb      	ldr	r3, [r7, #12]
 800a0c4:	f103 5300 	add.w	r3, r3, #536870912	@ 0x20000000
 800a0c8:	3b01      	subs	r3, #1
 800a0ca:	00db      	lsls	r3, r3, #3
 800a0cc:	18d1      	adds	r1, r2, r3
 800a0ce:	687b      	ldr	r3, [r7, #4]
 800a0d0:	68da      	ldr	r2, [r3, #12]
 800a0d2:	68fb      	ldr	r3, [r7, #12]
 800a0d4:	00db      	lsls	r3, r3, #3
 800a0d6:	4413      	add	r3, r2
 800a0d8:	460a      	mov	r2, r1
 800a0da:	e892 0003 	ldmia.w	r2, {r0, r1}
 800a0de:	e883 0003 	stmia.w	r3, {r0, r1}
    for(i = obj->style_cnt - 1; i > 0 ; i--) {
 800a0e2:	68fb      	ldr	r3, [r7, #12]
 800a0e4:	3b01      	subs	r3, #1
 800a0e6:	60fb      	str	r3, [r7, #12]
 800a0e8:	68fb      	ldr	r3, [r7, #12]
 800a0ea:	2b00      	cmp	r3, #0
 800a0ec:	d1cb      	bne.n	800a086 <get_local_style+0xcc>
    }

    lv_memzero(&obj->styles[i], sizeof(_lv_obj_style_t));
 800a0ee:	687b      	ldr	r3, [r7, #4]
 800a0f0:	68da      	ldr	r2, [r3, #12]
 800a0f2:	68fb      	ldr	r3, [r7, #12]
 800a0f4:	00db      	lsls	r3, r3, #3
 800a0f6:	4413      	add	r3, r2
 800a0f8:	2108      	movs	r1, #8
 800a0fa:	4618      	mov	r0, r3
 800a0fc:	f7fe fd88 	bl	8008c10 <lv_memzero>
    obj->styles[i].style = lv_malloc(sizeof(lv_style_t));
 800a100:	687b      	ldr	r3, [r7, #4]
 800a102:	68da      	ldr	r2, [r3, #12]
 800a104:	68fb      	ldr	r3, [r7, #12]
 800a106:	00db      	lsls	r3, r3, #3
 800a108:	18d4      	adds	r4, r2, r3
 800a10a:	200c      	movs	r0, #12
 800a10c:	f01b fe5c 	bl	8025dc8 <lv_malloc>
 800a110:	4603      	mov	r3, r0
 800a112:	6023      	str	r3, [r4, #0]
    lv_style_init((lv_style_t *)obj->styles[i].style);
 800a114:	687b      	ldr	r3, [r7, #4]
 800a116:	68da      	ldr	r2, [r3, #12]
 800a118:	68fb      	ldr	r3, [r7, #12]
 800a11a:	00db      	lsls	r3, r3, #3
 800a11c:	4413      	add	r3, r2
 800a11e:	681b      	ldr	r3, [r3, #0]
 800a120:	4618      	mov	r0, r3
 800a122:	f019 fbc8 	bl	80238b6 <lv_style_init>

    obj->styles[i].is_local = 1;
 800a126:	687b      	ldr	r3, [r7, #4]
 800a128:	68da      	ldr	r2, [r3, #12]
 800a12a:	68fb      	ldr	r3, [r7, #12]
 800a12c:	00db      	lsls	r3, r3, #3
 800a12e:	441a      	add	r2, r3
 800a130:	79d3      	ldrb	r3, [r2, #7]
 800a132:	f043 0301 	orr.w	r3, r3, #1
 800a136:	71d3      	strb	r3, [r2, #7]
    obj->styles[i].selector = selector;
 800a138:	687b      	ldr	r3, [r7, #4]
 800a13a:	68da      	ldr	r2, [r3, #12]
 800a13c:	68fb      	ldr	r3, [r7, #12]
 800a13e:	00db      	lsls	r3, r3, #3
 800a140:	441a      	add	r2, r3
 800a142:	683b      	ldr	r3, [r7, #0]
 800a144:	f023 417f 	bic.w	r1, r3, #4278190080	@ 0xff000000
 800a148:	6853      	ldr	r3, [r2, #4]
 800a14a:	f361 0317 	bfi	r3, r1, #0, #24
 800a14e:	6053      	str	r3, [r2, #4]
    return (lv_style_t *)obj->styles[i].style;
 800a150:	687b      	ldr	r3, [r7, #4]
 800a152:	68da      	ldr	r2, [r3, #12]
 800a154:	68fb      	ldr	r3, [r7, #12]
 800a156:	00db      	lsls	r3, r3, #3
 800a158:	4413      	add	r3, r2
 800a15a:	681b      	ldr	r3, [r3, #0]
}
 800a15c:	4618      	mov	r0, r3
 800a15e:	3714      	adds	r7, #20
 800a160:	46bd      	mov	sp, r7
 800a162:	bd90      	pop	{r4, r7, pc}

0800a164 <get_trans_style>:
 * @param obj   pointer to an object
 * @param selector OR-ed value of parts and state for which the style should be get
 * @return pointer to the transition style
 */
static _lv_obj_style_t * get_trans_style(lv_obj_t * obj,  lv_style_selector_t selector)
{
 800a164:	b590      	push	{r4, r7, lr}
 800a166:	b085      	sub	sp, #20
 800a168:	af00      	add	r7, sp, #0
 800a16a:	6078      	str	r0, [r7, #4]
 800a16c:	6039      	str	r1, [r7, #0]
    uint32_t i;
    for(i = 0; i < obj->style_cnt; i++) {
 800a16e:	2300      	movs	r3, #0
 800a170:	60fb      	str	r3, [r7, #12]
 800a172:	e019      	b.n	800a1a8 <get_trans_style+0x44>
        if(obj->styles[i].is_trans && obj->styles[i].selector == selector) break;
 800a174:	687b      	ldr	r3, [r7, #4]
 800a176:	68da      	ldr	r2, [r3, #12]
 800a178:	68fb      	ldr	r3, [r7, #12]
 800a17a:	00db      	lsls	r3, r3, #3
 800a17c:	4413      	add	r3, r2
 800a17e:	79db      	ldrb	r3, [r3, #7]
 800a180:	f003 0302 	and.w	r3, r3, #2
 800a184:	b2db      	uxtb	r3, r3
 800a186:	2b00      	cmp	r3, #0
 800a188:	d00b      	beq.n	800a1a2 <get_trans_style+0x3e>
 800a18a:	687b      	ldr	r3, [r7, #4]
 800a18c:	68da      	ldr	r2, [r3, #12]
 800a18e:	68fb      	ldr	r3, [r7, #12]
 800a190:	00db      	lsls	r3, r3, #3
 800a192:	4413      	add	r3, r2
 800a194:	685b      	ldr	r3, [r3, #4]
 800a196:	f3c3 0317 	ubfx	r3, r3, #0, #24
 800a19a:	461a      	mov	r2, r3
 800a19c:	683b      	ldr	r3, [r7, #0]
 800a19e:	4293      	cmp	r3, r2
 800a1a0:	d00c      	beq.n	800a1bc <get_trans_style+0x58>
    for(i = 0; i < obj->style_cnt; i++) {
 800a1a2:	68fb      	ldr	r3, [r7, #12]
 800a1a4:	3301      	adds	r3, #1
 800a1a6:	60fb      	str	r3, [r7, #12]
 800a1a8:	687b      	ldr	r3, [r7, #4]
 800a1aa:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a1ac:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a1b0:	b2db      	uxtb	r3, r3
 800a1b2:	461a      	mov	r2, r3
 800a1b4:	68fb      	ldr	r3, [r7, #12]
 800a1b6:	4293      	cmp	r3, r2
 800a1b8:	d3dc      	bcc.n	800a174 <get_trans_style+0x10>
 800a1ba:	e000      	b.n	800a1be <get_trans_style+0x5a>
        if(obj->styles[i].is_trans && obj->styles[i].selector == selector) break;
 800a1bc:	bf00      	nop
    }

    /*Already have a transition style for it*/
    if(i != obj->style_cnt) return &obj->styles[i];
 800a1be:	687b      	ldr	r3, [r7, #4]
 800a1c0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a1c2:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a1c6:	b2db      	uxtb	r3, r3
 800a1c8:	461a      	mov	r2, r3
 800a1ca:	68fb      	ldr	r3, [r7, #12]
 800a1cc:	4293      	cmp	r3, r2
 800a1ce:	d005      	beq.n	800a1dc <get_trans_style+0x78>
 800a1d0:	687b      	ldr	r3, [r7, #4]
 800a1d2:	68da      	ldr	r2, [r3, #12]
 800a1d4:	68fb      	ldr	r3, [r7, #12]
 800a1d6:	00db      	lsls	r3, r3, #3
 800a1d8:	4413      	add	r3, r2
 800a1da:	e069      	b.n	800a2b0 <get_trans_style+0x14c>

    obj->style_cnt++;
 800a1dc:	687b      	ldr	r3, [r7, #4]
 800a1de:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a1e0:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a1e4:	b2db      	uxtb	r3, r3
 800a1e6:	3301      	adds	r3, #1
 800a1e8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800a1ec:	b2d9      	uxtb	r1, r3
 800a1ee:	687a      	ldr	r2, [r7, #4]
 800a1f0:	8d53      	ldrh	r3, [r2, #42]	@ 0x2a
 800a1f2:	f361 1309 	bfi	r3, r1, #4, #6
 800a1f6:	8553      	strh	r3, [r2, #42]	@ 0x2a
    LV_ASSERT(obj->style_cnt != 0);
 800a1f8:	687b      	ldr	r3, [r7, #4]
 800a1fa:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a1fc:	f403 737c 	and.w	r3, r3, #1008	@ 0x3f0
 800a200:	b29b      	uxth	r3, r3
 800a202:	2b00      	cmp	r3, #0
 800a204:	d101      	bne.n	800a20a <get_trans_style+0xa6>
 800a206:	bf00      	nop
 800a208:	e7fd      	b.n	800a206 <get_trans_style+0xa2>
    obj->styles = lv_realloc(obj->styles, obj->style_cnt * sizeof(_lv_obj_style_t));
 800a20a:	687b      	ldr	r3, [r7, #4]
 800a20c:	68da      	ldr	r2, [r3, #12]
 800a20e:	687b      	ldr	r3, [r7, #4]
 800a210:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a212:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a216:	b2db      	uxtb	r3, r3
 800a218:	00db      	lsls	r3, r3, #3
 800a21a:	4619      	mov	r1, r3
 800a21c:	4610      	mov	r0, r2
 800a21e:	f01b fe23 	bl	8025e68 <lv_realloc>
 800a222:	4602      	mov	r2, r0
 800a224:	687b      	ldr	r3, [r7, #4]
 800a226:	60da      	str	r2, [r3, #12]

    for(i = obj->style_cnt - 1; i > 0 ; i--) {
 800a228:	687b      	ldr	r3, [r7, #4]
 800a22a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a22c:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a230:	b2db      	uxtb	r3, r3
 800a232:	3b01      	subs	r3, #1
 800a234:	60fb      	str	r3, [r7, #12]
 800a236:	e014      	b.n	800a262 <get_trans_style+0xfe>
        obj->styles[i] = obj->styles[i - 1];
 800a238:	687b      	ldr	r3, [r7, #4]
 800a23a:	68da      	ldr	r2, [r3, #12]
 800a23c:	68fb      	ldr	r3, [r7, #12]
 800a23e:	f103 5300 	add.w	r3, r3, #536870912	@ 0x20000000
 800a242:	3b01      	subs	r3, #1
 800a244:	00db      	lsls	r3, r3, #3
 800a246:	18d1      	adds	r1, r2, r3
 800a248:	687b      	ldr	r3, [r7, #4]
 800a24a:	68da      	ldr	r2, [r3, #12]
 800a24c:	68fb      	ldr	r3, [r7, #12]
 800a24e:	00db      	lsls	r3, r3, #3
 800a250:	4413      	add	r3, r2
 800a252:	460a      	mov	r2, r1
 800a254:	e892 0003 	ldmia.w	r2, {r0, r1}
 800a258:	e883 0003 	stmia.w	r3, {r0, r1}
    for(i = obj->style_cnt - 1; i > 0 ; i--) {
 800a25c:	68fb      	ldr	r3, [r7, #12]
 800a25e:	3b01      	subs	r3, #1
 800a260:	60fb      	str	r3, [r7, #12]
 800a262:	68fb      	ldr	r3, [r7, #12]
 800a264:	2b00      	cmp	r3, #0
 800a266:	d1e7      	bne.n	800a238 <get_trans_style+0xd4>
    }

    lv_memzero(&obj->styles[0], sizeof(_lv_obj_style_t));
 800a268:	687b      	ldr	r3, [r7, #4]
 800a26a:	68db      	ldr	r3, [r3, #12]
 800a26c:	2108      	movs	r1, #8
 800a26e:	4618      	mov	r0, r3
 800a270:	f7fe fcce 	bl	8008c10 <lv_memzero>
    obj->styles[0].style = lv_malloc(sizeof(lv_style_t));
 800a274:	687b      	ldr	r3, [r7, #4]
 800a276:	68dc      	ldr	r4, [r3, #12]
 800a278:	200c      	movs	r0, #12
 800a27a:	f01b fda5 	bl	8025dc8 <lv_malloc>
 800a27e:	4603      	mov	r3, r0
 800a280:	6023      	str	r3, [r4, #0]
    lv_style_init((lv_style_t *)obj->styles[0].style);
 800a282:	687b      	ldr	r3, [r7, #4]
 800a284:	68db      	ldr	r3, [r3, #12]
 800a286:	681b      	ldr	r3, [r3, #0]
 800a288:	4618      	mov	r0, r3
 800a28a:	f019 fb14 	bl	80238b6 <lv_style_init>

    obj->styles[0].is_trans = 1;
 800a28e:	687b      	ldr	r3, [r7, #4]
 800a290:	68da      	ldr	r2, [r3, #12]
 800a292:	79d3      	ldrb	r3, [r2, #7]
 800a294:	f043 0302 	orr.w	r3, r3, #2
 800a298:	71d3      	strb	r3, [r2, #7]
    obj->styles[0].selector = selector;
 800a29a:	687b      	ldr	r3, [r7, #4]
 800a29c:	68da      	ldr	r2, [r3, #12]
 800a29e:	683b      	ldr	r3, [r7, #0]
 800a2a0:	f023 417f 	bic.w	r1, r3, #4278190080	@ 0xff000000
 800a2a4:	6853      	ldr	r3, [r2, #4]
 800a2a6:	f361 0317 	bfi	r3, r1, #0, #24
 800a2aa:	6053      	str	r3, [r2, #4]
    return &obj->styles[0];
 800a2ac:	687b      	ldr	r3, [r7, #4]
 800a2ae:	68db      	ldr	r3, [r3, #12]
}
 800a2b0:	4618      	mov	r0, r3
 800a2b2:	3714      	adds	r7, #20
 800a2b4:	46bd      	mov	sp, r7
 800a2b6:	bd90      	pop	{r4, r7, pc}

0800a2b8 <get_prop_core>:

static lv_style_res_t get_prop_core(const lv_obj_t * obj, lv_style_selector_t selector, lv_style_prop_t prop,
                                    lv_style_value_t * v)
{
 800a2b8:	b580      	push	{r7, lr}
 800a2ba:	b090      	sub	sp, #64	@ 0x40
 800a2bc:	af00      	add	r7, sp, #0
 800a2be:	60f8      	str	r0, [r7, #12]
 800a2c0:	60b9      	str	r1, [r7, #8]
 800a2c2:	603b      	str	r3, [r7, #0]
 800a2c4:	4613      	mov	r3, r2
 800a2c6:	71fb      	strb	r3, [r7, #7]

    const uint32_t group = (uint32_t)1 << _lv_style_get_prop_group(prop);
 800a2c8:	79fb      	ldrb	r3, [r7, #7]
 800a2ca:	4618      	mov	r0, r3
 800a2cc:	f7fe fdc8 	bl	8008e60 <_lv_style_get_prop_group>
 800a2d0:	4603      	mov	r3, r0
 800a2d2:	2201      	movs	r2, #1
 800a2d4:	fa02 f303 	lsl.w	r3, r2, r3
 800a2d8:	637b      	str	r3, [r7, #52]	@ 0x34
    const lv_part_t part = lv_obj_style_get_selector_part(selector);
 800a2da:	68b8      	ldr	r0, [r7, #8]
 800a2dc:	f7fe fdfb 	bl	8008ed6 <lv_obj_style_get_selector_part>
 800a2e0:	6338      	str	r0, [r7, #48]	@ 0x30
    const lv_state_t state = lv_obj_style_get_selector_state(selector);
 800a2e2:	68b8      	ldr	r0, [r7, #8]
 800a2e4:	f7fe fdeb 	bl	8008ebe <lv_obj_style_get_selector_state>
 800a2e8:	4603      	mov	r3, r0
 800a2ea:	85fb      	strh	r3, [r7, #46]	@ 0x2e
    const lv_state_t state_inv = ~state;
 800a2ec:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 800a2ee:	43db      	mvns	r3, r3
 800a2f0:	85bb      	strh	r3, [r7, #44]	@ 0x2c
    const bool skip_trans = obj->skip_trans;
 800a2f2:	68fb      	ldr	r3, [r7, #12]
 800a2f4:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
 800a2f8:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800a2fc:	b2db      	uxtb	r3, r3
 800a2fe:	2b00      	cmp	r3, #0
 800a300:	bf14      	ite	ne
 800a302:	2301      	movne	r3, #1
 800a304:	2300      	moveq	r3, #0
 800a306:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
    int32_t weight = -1;
 800a30a:	f04f 33ff 	mov.w	r3, #4294967295
 800a30e:	63fb      	str	r3, [r7, #60]	@ 0x3c
    lv_style_res_t found;
    uint32_t i;
    for(i = 0; i < obj->style_cnt; i++) {
 800a310:	2300      	movs	r3, #0
 800a312:	63bb      	str	r3, [r7, #56]	@ 0x38
 800a314:	e03d      	b.n	800a392 <get_prop_core+0xda>
        _lv_obj_style_t * obj_style = &obj->styles[i];
 800a316:	68fb      	ldr	r3, [r7, #12]
 800a318:	68da      	ldr	r2, [r3, #12]
 800a31a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a31c:	00db      	lsls	r3, r3, #3
 800a31e:	4413      	add	r3, r2
 800a320:	627b      	str	r3, [r7, #36]	@ 0x24
        if(obj_style->is_trans == false) break;
 800a322:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a324:	79db      	ldrb	r3, [r3, #7]
 800a326:	f003 0302 	and.w	r3, r3, #2
 800a32a:	b2db      	uxtb	r3, r3
 800a32c:	2b00      	cmp	r3, #0
 800a32e:	d03a      	beq.n	800a3a6 <get_prop_core+0xee>
        if(skip_trans) continue;
 800a330:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800a334:	2b00      	cmp	r3, #0
 800a336:	d124      	bne.n	800a382 <get_prop_core+0xca>

        lv_part_t part_act = lv_obj_style_get_selector_part(obj->styles[i].selector);
 800a338:	68fb      	ldr	r3, [r7, #12]
 800a33a:	68da      	ldr	r2, [r3, #12]
 800a33c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a33e:	00db      	lsls	r3, r3, #3
 800a340:	4413      	add	r3, r2
 800a342:	685b      	ldr	r3, [r3, #4]
 800a344:	f3c3 0317 	ubfx	r3, r3, #0, #24
 800a348:	4618      	mov	r0, r3
 800a34a:	f7fe fdc4 	bl	8008ed6 <lv_obj_style_get_selector_part>
 800a34e:	6238      	str	r0, [r7, #32]

        if(part_act != part) continue;
 800a350:	6a3a      	ldr	r2, [r7, #32]
 800a352:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800a354:	429a      	cmp	r2, r3
 800a356:	d116      	bne.n	800a386 <get_prop_core+0xce>
        if((obj_style->style->has_group & group) == 0) continue;
 800a358:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a35a:	681b      	ldr	r3, [r3, #0]
 800a35c:	685a      	ldr	r2, [r3, #4]
 800a35e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800a360:	4013      	ands	r3, r2
 800a362:	2b00      	cmp	r3, #0
 800a364:	d011      	beq.n	800a38a <get_prop_core+0xd2>
        found = lv_style_get_prop_inlined(obj_style->style, prop, v);
 800a366:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a368:	681b      	ldr	r3, [r3, #0]
 800a36a:	79f9      	ldrb	r1, [r7, #7]
 800a36c:	683a      	ldr	r2, [r7, #0]
 800a36e:	4618      	mov	r0, r3
 800a370:	f7fe fd1b 	bl	8008daa <lv_style_get_prop_inlined>
 800a374:	4603      	mov	r3, r0
 800a376:	77fb      	strb	r3, [r7, #31]
        if(found == LV_STYLE_RES_FOUND) {
 800a378:	7ffb      	ldrb	r3, [r7, #31]
 800a37a:	2b01      	cmp	r3, #1
 800a37c:	d106      	bne.n	800a38c <get_prop_core+0xd4>
            return LV_STYLE_RES_FOUND;
 800a37e:	2301      	movs	r3, #1
 800a380:	e079      	b.n	800a476 <get_prop_core+0x1be>
        if(skip_trans) continue;
 800a382:	bf00      	nop
 800a384:	e002      	b.n	800a38c <get_prop_core+0xd4>
        if(part_act != part) continue;
 800a386:	bf00      	nop
 800a388:	e000      	b.n	800a38c <get_prop_core+0xd4>
        if((obj_style->style->has_group & group) == 0) continue;
 800a38a:	bf00      	nop
    for(i = 0; i < obj->style_cnt; i++) {
 800a38c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a38e:	3301      	adds	r3, #1
 800a390:	63bb      	str	r3, [r7, #56]	@ 0x38
 800a392:	68fb      	ldr	r3, [r7, #12]
 800a394:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a396:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a39a:	b2db      	uxtb	r3, r3
 800a39c:	461a      	mov	r2, r3
 800a39e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a3a0:	4293      	cmp	r3, r2
 800a3a2:	d3b8      	bcc.n	800a316 <get_prop_core+0x5e>
 800a3a4:	e058      	b.n	800a458 <get_prop_core+0x1a0>
        if(obj_style->is_trans == false) break;
 800a3a6:	bf00      	nop
        }
    }

    for(; i < obj->style_cnt; i++) {
 800a3a8:	e056      	b.n	800a458 <get_prop_core+0x1a0>
        if((obj->styles[i].style->has_group & group) == 0) continue;
 800a3aa:	68fb      	ldr	r3, [r7, #12]
 800a3ac:	68da      	ldr	r2, [r3, #12]
 800a3ae:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a3b0:	00db      	lsls	r3, r3, #3
 800a3b2:	4413      	add	r3, r2
 800a3b4:	681b      	ldr	r3, [r3, #0]
 800a3b6:	685a      	ldr	r2, [r3, #4]
 800a3b8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800a3ba:	4013      	ands	r3, r2
 800a3bc:	2b00      	cmp	r3, #0
 800a3be:	d041      	beq.n	800a444 <get_prop_core+0x18c>
        _lv_obj_style_t * obj_style = &obj->styles[i];
 800a3c0:	68fb      	ldr	r3, [r7, #12]
 800a3c2:	68da      	ldr	r2, [r3, #12]
 800a3c4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a3c6:	00db      	lsls	r3, r3, #3
 800a3c8:	4413      	add	r3, r2
 800a3ca:	61bb      	str	r3, [r7, #24]
        lv_part_t part_act = lv_obj_style_get_selector_part(obj->styles[i].selector);
 800a3cc:	68fb      	ldr	r3, [r7, #12]
 800a3ce:	68da      	ldr	r2, [r3, #12]
 800a3d0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a3d2:	00db      	lsls	r3, r3, #3
 800a3d4:	4413      	add	r3, r2
 800a3d6:	685b      	ldr	r3, [r3, #4]
 800a3d8:	f3c3 0317 	ubfx	r3, r3, #0, #24
 800a3dc:	4618      	mov	r0, r3
 800a3de:	f7fe fd7a 	bl	8008ed6 <lv_obj_style_get_selector_part>
 800a3e2:	6178      	str	r0, [r7, #20]
        if(part_act != part) continue;
 800a3e4:	697a      	ldr	r2, [r7, #20]
 800a3e6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800a3e8:	429a      	cmp	r2, r3
 800a3ea:	d12d      	bne.n	800a448 <get_prop_core+0x190>

        /*Be sure the style not specifies other state than the requested.
         *E.g. For HOVER+PRESS object state, HOVER style only is OK, but HOVER+FOCUS style is not*/
        lv_state_t state_act = lv_obj_style_get_selector_state(obj->styles[i].selector);
 800a3ec:	68fb      	ldr	r3, [r7, #12]
 800a3ee:	68da      	ldr	r2, [r3, #12]
 800a3f0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a3f2:	00db      	lsls	r3, r3, #3
 800a3f4:	4413      	add	r3, r2
 800a3f6:	685b      	ldr	r3, [r3, #4]
 800a3f8:	f3c3 0317 	ubfx	r3, r3, #0, #24
 800a3fc:	4618      	mov	r0, r3
 800a3fe:	f7fe fd5e 	bl	8008ebe <lv_obj_style_get_selector_state>
 800a402:	4603      	mov	r3, r0
 800a404:	827b      	strh	r3, [r7, #18]
        if((state_act & state_inv)) continue;
 800a406:	8a7a      	ldrh	r2, [r7, #18]
 800a408:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 800a40a:	4013      	ands	r3, r2
 800a40c:	b29b      	uxth	r3, r3
 800a40e:	2b00      	cmp	r3, #0
 800a410:	d11c      	bne.n	800a44c <get_prop_core+0x194>

        /*Check only better candidates*/
        if(state_act <= weight) continue;
 800a412:	8a7b      	ldrh	r3, [r7, #18]
 800a414:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800a416:	429a      	cmp	r2, r3
 800a418:	da1a      	bge.n	800a450 <get_prop_core+0x198>

        found = lv_style_get_prop_inlined(obj_style->style, prop, v);
 800a41a:	69bb      	ldr	r3, [r7, #24]
 800a41c:	681b      	ldr	r3, [r3, #0]
 800a41e:	79f9      	ldrb	r1, [r7, #7]
 800a420:	683a      	ldr	r2, [r7, #0]
 800a422:	4618      	mov	r0, r3
 800a424:	f7fe fcc1 	bl	8008daa <lv_style_get_prop_inlined>
 800a428:	4603      	mov	r3, r0
 800a42a:	77fb      	strb	r3, [r7, #31]
        if(found == LV_STYLE_RES_FOUND) {
 800a42c:	7ffb      	ldrb	r3, [r7, #31]
 800a42e:	2b01      	cmp	r3, #1
 800a430:	d10f      	bne.n	800a452 <get_prop_core+0x19a>
            if(state_act == state) {
 800a432:	8a7a      	ldrh	r2, [r7, #18]
 800a434:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 800a436:	429a      	cmp	r2, r3
 800a438:	d101      	bne.n	800a43e <get_prop_core+0x186>
                return LV_STYLE_RES_FOUND;
 800a43a:	2301      	movs	r3, #1
 800a43c:	e01b      	b.n	800a476 <get_prop_core+0x1be>
            }
            weight = state_act;
 800a43e:	8a7b      	ldrh	r3, [r7, #18]
 800a440:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800a442:	e006      	b.n	800a452 <get_prop_core+0x19a>
        if((obj->styles[i].style->has_group & group) == 0) continue;
 800a444:	bf00      	nop
 800a446:	e004      	b.n	800a452 <get_prop_core+0x19a>
        if(part_act != part) continue;
 800a448:	bf00      	nop
 800a44a:	e002      	b.n	800a452 <get_prop_core+0x19a>
        if((state_act & state_inv)) continue;
 800a44c:	bf00      	nop
 800a44e:	e000      	b.n	800a452 <get_prop_core+0x19a>
        if(state_act <= weight) continue;
 800a450:	bf00      	nop
    for(; i < obj->style_cnt; i++) {
 800a452:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a454:	3301      	adds	r3, #1
 800a456:	63bb      	str	r3, [r7, #56]	@ 0x38
 800a458:	68fb      	ldr	r3, [r7, #12]
 800a45a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a45c:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a460:	b2db      	uxtb	r3, r3
 800a462:	461a      	mov	r2, r3
 800a464:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a466:	4293      	cmp	r3, r2
 800a468:	d39f      	bcc.n	800a3aa <get_prop_core+0xf2>
        }
    }

    if(weight >= 0) return LV_STYLE_RES_FOUND;
 800a46a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800a46c:	2b00      	cmp	r3, #0
 800a46e:	db01      	blt.n	800a474 <get_prop_core+0x1bc>
 800a470:	2301      	movs	r3, #1
 800a472:	e000      	b.n	800a476 <get_prop_core+0x1be>
    else return LV_STYLE_RES_NOT_FOUND;
 800a474:	2300      	movs	r3, #0
}
 800a476:	4618      	mov	r0, r3
 800a478:	3740      	adds	r7, #64	@ 0x40
 800a47a:	46bd      	mov	sp, r7
 800a47c:	bd80      	pop	{r7, pc}

0800a47e <refresh_children_style>:
 * Recursively refresh the style of the children. Go deeper until a not NULL style is found
 * because the NULL styles are inherited from the parent
 * @param obj pointer to an object
 */
static void refresh_children_style(lv_obj_t * obj)
{
 800a47e:	b580      	push	{r7, lr}
 800a480:	b086      	sub	sp, #24
 800a482:	af00      	add	r7, sp, #0
 800a484:	6078      	str	r0, [r7, #4]
    uint32_t i;
    uint32_t child_cnt = lv_obj_get_child_count(obj);
 800a486:	6878      	ldr	r0, [r7, #4]
 800a488:	f000 fd1a 	bl	800aec0 <lv_obj_get_child_count>
 800a48c:	6138      	str	r0, [r7, #16]
    for(i = 0; i < child_cnt; i++) {
 800a48e:	2300      	movs	r3, #0
 800a490:	617b      	str	r3, [r7, #20]
 800a492:	e018      	b.n	800a4c6 <refresh_children_style+0x48>
        lv_obj_t * child = obj->spec_attr->children[i];
 800a494:	687b      	ldr	r3, [r7, #4]
 800a496:	689b      	ldr	r3, [r3, #8]
 800a498:	681a      	ldr	r2, [r3, #0]
 800a49a:	697b      	ldr	r3, [r7, #20]
 800a49c:	009b      	lsls	r3, r3, #2
 800a49e:	4413      	add	r3, r2
 800a4a0:	681b      	ldr	r3, [r3, #0]
 800a4a2:	60fb      	str	r3, [r7, #12]
        lv_obj_invalidate(child);
 800a4a4:	68f8      	ldr	r0, [r7, #12]
 800a4a6:	f7fc f8cb 	bl	8006640 <lv_obj_invalidate>
        lv_obj_send_event(child, LV_EVENT_STYLE_CHANGED, NULL);
 800a4aa:	2200      	movs	r2, #0
 800a4ac:	212c      	movs	r1, #44	@ 0x2c
 800a4ae:	68f8      	ldr	r0, [r7, #12]
 800a4b0:	f7fa fcb0 	bl	8004e14 <lv_obj_send_event>
        lv_obj_invalidate(child);
 800a4b4:	68f8      	ldr	r0, [r7, #12]
 800a4b6:	f7fc f8c3 	bl	8006640 <lv_obj_invalidate>

        refresh_children_style(child); /*Check children too*/
 800a4ba:	68f8      	ldr	r0, [r7, #12]
 800a4bc:	f7ff ffdf 	bl	800a47e <refresh_children_style>
    for(i = 0; i < child_cnt; i++) {
 800a4c0:	697b      	ldr	r3, [r7, #20]
 800a4c2:	3301      	adds	r3, #1
 800a4c4:	617b      	str	r3, [r7, #20]
 800a4c6:	697a      	ldr	r2, [r7, #20]
 800a4c8:	693b      	ldr	r3, [r7, #16]
 800a4ca:	429a      	cmp	r2, r3
 800a4cc:	d3e2      	bcc.n	800a494 <refresh_children_style+0x16>
    }
}
 800a4ce:	bf00      	nop
 800a4d0:	bf00      	nop
 800a4d2:	3718      	adds	r7, #24
 800a4d4:	46bd      	mov	sp, r7
 800a4d6:	bd80      	pop	{r7, pc}

0800a4d8 <trans_delete>:
 * @param part a part of object or 0xFF to remove from all parts
 * @param prop a property or 0xFF to remove all properties
 * @param tr_limit delete transitions only "older" than this. `NULL` if not used
 */
static bool trans_delete(lv_obj_t * obj, lv_part_t part, lv_style_prop_t prop, trans_t * tr_limit)
{
 800a4d8:	b580      	push	{r7, lr}
 800a4da:	b088      	sub	sp, #32
 800a4dc:	af00      	add	r7, sp, #0
 800a4de:	60f8      	str	r0, [r7, #12]
 800a4e0:	60b9      	str	r1, [r7, #8]
 800a4e2:	603b      	str	r3, [r7, #0]
 800a4e4:	4613      	mov	r3, r2
 800a4e6:	71fb      	strb	r3, [r7, #7]
    trans_t * tr;
    trans_t * tr_prev;
    bool removed = false;
 800a4e8:	2300      	movs	r3, #0
 800a4ea:	76fb      	strb	r3, [r7, #27]
    tr = _lv_ll_get_tail(style_trans_ll_p);
 800a4ec:	4839      	ldr	r0, [pc, #228]	@ (800a5d4 <trans_delete+0xfc>)
 800a4ee:	f018 fe7f 	bl	80231f0 <_lv_ll_get_tail>
 800a4f2:	61f8      	str	r0, [r7, #28]
    while(tr != NULL) {
 800a4f4:	e063      	b.n	800a5be <trans_delete+0xe6>
        if(tr == tr_limit) break;
 800a4f6:	69fa      	ldr	r2, [r7, #28]
 800a4f8:	683b      	ldr	r3, [r7, #0]
 800a4fa:	429a      	cmp	r2, r3
 800a4fc:	d063      	beq.n	800a5c6 <trans_delete+0xee>

        /*'tr' might be deleted, so get the next object while 'tr' is valid*/
        tr_prev = _lv_ll_get_prev(style_trans_ll_p, tr);
 800a4fe:	69f9      	ldr	r1, [r7, #28]
 800a500:	4834      	ldr	r0, [pc, #208]	@ (800a5d4 <trans_delete+0xfc>)
 800a502:	f018 fe9b 	bl	802323c <_lv_ll_get_prev>
 800a506:	6138      	str	r0, [r7, #16]

        if(tr->obj == obj && (part == tr->selector || part == LV_PART_ANY) && (prop == tr->prop || prop == LV_STYLE_PROP_ANY)) {
 800a508:	69fb      	ldr	r3, [r7, #28]
 800a50a:	681b      	ldr	r3, [r3, #0]
 800a50c:	68fa      	ldr	r2, [r7, #12]
 800a50e:	429a      	cmp	r2, r3
 800a510:	d153      	bne.n	800a5ba <trans_delete+0xe2>
 800a512:	69fb      	ldr	r3, [r7, #28]
 800a514:	689b      	ldr	r3, [r3, #8]
 800a516:	68ba      	ldr	r2, [r7, #8]
 800a518:	429a      	cmp	r2, r3
 800a51a:	d003      	beq.n	800a524 <trans_delete+0x4c>
 800a51c:	68bb      	ldr	r3, [r7, #8]
 800a51e:	f5b3 2f70 	cmp.w	r3, #983040	@ 0xf0000
 800a522:	d14a      	bne.n	800a5ba <trans_delete+0xe2>
 800a524:	69fb      	ldr	r3, [r7, #28]
 800a526:	791b      	ldrb	r3, [r3, #4]
 800a528:	79fa      	ldrb	r2, [r7, #7]
 800a52a:	429a      	cmp	r2, r3
 800a52c:	d002      	beq.n	800a534 <trans_delete+0x5c>
 800a52e:	79fb      	ldrb	r3, [r7, #7]
 800a530:	2bff      	cmp	r3, #255	@ 0xff
 800a532:	d142      	bne.n	800a5ba <trans_delete+0xe2>
            /*Remove any transitioned properties from the trans. style
             *to allow changing it by normal styles*/
            uint32_t i;
            for(i = 0; i < obj->style_cnt; i++) {
 800a534:	2300      	movs	r3, #0
 800a536:	617b      	str	r3, [r7, #20]
 800a538:	e029      	b.n	800a58e <trans_delete+0xb6>
                if(obj->styles[i].is_trans && (part == LV_PART_ANY || obj->styles[i].selector == part)) {
 800a53a:	68fb      	ldr	r3, [r7, #12]
 800a53c:	68da      	ldr	r2, [r3, #12]
 800a53e:	697b      	ldr	r3, [r7, #20]
 800a540:	00db      	lsls	r3, r3, #3
 800a542:	4413      	add	r3, r2
 800a544:	79db      	ldrb	r3, [r3, #7]
 800a546:	f003 0302 	and.w	r3, r3, #2
 800a54a:	b2db      	uxtb	r3, r3
 800a54c:	2b00      	cmp	r3, #0
 800a54e:	d01b      	beq.n	800a588 <trans_delete+0xb0>
 800a550:	68bb      	ldr	r3, [r7, #8]
 800a552:	f5b3 2f70 	cmp.w	r3, #983040	@ 0xf0000
 800a556:	d00b      	beq.n	800a570 <trans_delete+0x98>
 800a558:	68fb      	ldr	r3, [r7, #12]
 800a55a:	68da      	ldr	r2, [r3, #12]
 800a55c:	697b      	ldr	r3, [r7, #20]
 800a55e:	00db      	lsls	r3, r3, #3
 800a560:	4413      	add	r3, r2
 800a562:	685b      	ldr	r3, [r3, #4]
 800a564:	f3c3 0317 	ubfx	r3, r3, #0, #24
 800a568:	461a      	mov	r2, r3
 800a56a:	68bb      	ldr	r3, [r7, #8]
 800a56c:	4293      	cmp	r3, r2
 800a56e:	d10b      	bne.n	800a588 <trans_delete+0xb0>
                    lv_style_remove_prop((lv_style_t *)obj->styles[i].style, tr->prop);
 800a570:	68fb      	ldr	r3, [r7, #12]
 800a572:	68da      	ldr	r2, [r3, #12]
 800a574:	697b      	ldr	r3, [r7, #20]
 800a576:	00db      	lsls	r3, r3, #3
 800a578:	4413      	add	r3, r2
 800a57a:	681a      	ldr	r2, [r3, #0]
 800a57c:	69fb      	ldr	r3, [r7, #28]
 800a57e:	791b      	ldrb	r3, [r3, #4]
 800a580:	4619      	mov	r1, r3
 800a582:	4610      	mov	r0, r2
 800a584:	f019 f9b8 	bl	80238f8 <lv_style_remove_prop>
            for(i = 0; i < obj->style_cnt; i++) {
 800a588:	697b      	ldr	r3, [r7, #20]
 800a58a:	3301      	adds	r3, #1
 800a58c:	617b      	str	r3, [r7, #20]
 800a58e:	68fb      	ldr	r3, [r7, #12]
 800a590:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a592:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a596:	b2db      	uxtb	r3, r3
 800a598:	461a      	mov	r2, r3
 800a59a:	697b      	ldr	r3, [r7, #20]
 800a59c:	4293      	cmp	r3, r2
 800a59e:	d3cc      	bcc.n	800a53a <trans_delete+0x62>
                }
            }

            /*Free the transition descriptor too*/
            lv_anim_delete(tr, NULL);
 800a5a0:	2100      	movs	r1, #0
 800a5a2:	69f8      	ldr	r0, [r7, #28]
 800a5a4:	f016 fd6a 	bl	802107c <lv_anim_delete>
            _lv_ll_remove(style_trans_ll_p, tr);
 800a5a8:	69f9      	ldr	r1, [r7, #28]
 800a5aa:	480a      	ldr	r0, [pc, #40]	@ (800a5d4 <trans_delete+0xfc>)
 800a5ac:	f018 fdb2 	bl	8023114 <_lv_ll_remove>
            lv_free(tr);
 800a5b0:	69f8      	ldr	r0, [r7, #28]
 800a5b2:	f01b fc41 	bl	8025e38 <lv_free>
            removed = true;
 800a5b6:	2301      	movs	r3, #1
 800a5b8:	76fb      	strb	r3, [r7, #27]

        }
        tr = tr_prev;
 800a5ba:	693b      	ldr	r3, [r7, #16]
 800a5bc:	61fb      	str	r3, [r7, #28]
    while(tr != NULL) {
 800a5be:	69fb      	ldr	r3, [r7, #28]
 800a5c0:	2b00      	cmp	r3, #0
 800a5c2:	d198      	bne.n	800a4f6 <trans_delete+0x1e>
 800a5c4:	e000      	b.n	800a5c8 <trans_delete+0xf0>
        if(tr == tr_limit) break;
 800a5c6:	bf00      	nop
    }
    return removed;
 800a5c8:	7efb      	ldrb	r3, [r7, #27]
}
 800a5ca:	4618      	mov	r0, r3
 800a5cc:	3720      	adds	r7, #32
 800a5ce:	46bd      	mov	sp, r7
 800a5d0:	bd80      	pop	{r7, pc}
 800a5d2:	bf00      	nop
 800a5d4:	200000b4 	.word	0x200000b4

0800a5d8 <trans_anim_cb>:

static void trans_anim_cb(void * _tr, int32_t v)
{
 800a5d8:	b580      	push	{r7, lr}
 800a5da:	b088      	sub	sp, #32
 800a5dc:	af00      	add	r7, sp, #0
 800a5de:	6078      	str	r0, [r7, #4]
 800a5e0:	6039      	str	r1, [r7, #0]
    trans_t * tr = _tr;
 800a5e2:	687b      	ldr	r3, [r7, #4]
 800a5e4:	617b      	str	r3, [r7, #20]
    lv_obj_t * obj = tr->obj;
 800a5e6:	697b      	ldr	r3, [r7, #20]
 800a5e8:	681b      	ldr	r3, [r3, #0]
 800a5ea:	613b      	str	r3, [r7, #16]

    uint32_t i;
    for(i = 0; i < obj->style_cnt; i++) {
 800a5ec:	2300      	movs	r3, #0
 800a5ee:	61fb      	str	r3, [r7, #28]
 800a5f0:	e12e      	b.n	800a850 <trans_anim_cb+0x278>
        if(obj->styles[i].is_trans == 0 || obj->styles[i].selector != tr->selector) continue;
 800a5f2:	693b      	ldr	r3, [r7, #16]
 800a5f4:	68da      	ldr	r2, [r3, #12]
 800a5f6:	69fb      	ldr	r3, [r7, #28]
 800a5f8:	00db      	lsls	r3, r3, #3
 800a5fa:	4413      	add	r3, r2
 800a5fc:	79db      	ldrb	r3, [r3, #7]
 800a5fe:	f003 0302 	and.w	r3, r3, #2
 800a602:	b2db      	uxtb	r3, r3
 800a604:	2b00      	cmp	r3, #0
 800a606:	d00c      	beq.n	800a622 <trans_anim_cb+0x4a>
 800a608:	693b      	ldr	r3, [r7, #16]
 800a60a:	68da      	ldr	r2, [r3, #12]
 800a60c:	69fb      	ldr	r3, [r7, #28]
 800a60e:	00db      	lsls	r3, r3, #3
 800a610:	4413      	add	r3, r2
 800a612:	685b      	ldr	r3, [r3, #4]
 800a614:	f3c3 0317 	ubfx	r3, r3, #0, #24
 800a618:	461a      	mov	r2, r3
 800a61a:	697b      	ldr	r3, [r7, #20]
 800a61c:	689b      	ldr	r3, [r3, #8]
 800a61e:	429a      	cmp	r2, r3
 800a620:	d003      	beq.n	800a62a <trans_anim_cb+0x52>
    for(i = 0; i < obj->style_cnt; i++) {
 800a622:	69fb      	ldr	r3, [r7, #28]
 800a624:	3301      	adds	r3, #1
 800a626:	61fb      	str	r3, [r7, #28]
 800a628:	e112      	b.n	800a850 <trans_anim_cb+0x278>

        lv_style_value_t value_final = {0};
 800a62a:	2300      	movs	r3, #0
 800a62c:	60fb      	str	r3, [r7, #12]
        switch(tr->prop) {
 800a62e:	697b      	ldr	r3, [r7, #20]
 800a630:	791b      	ldrb	r3, [r3, #4]
 800a632:	2b67      	cmp	r3, #103	@ 0x67
 800a634:	f300 80b2 	bgt.w	800a79c <trans_anim_cb+0x1c4>
 800a638:	2b5a      	cmp	r3, #90	@ 0x5a
 800a63a:	da04      	bge.n	800a646 <trans_anim_cb+0x6e>
 800a63c:	2b39      	cmp	r3, #57	@ 0x39
 800a63e:	dc49      	bgt.n	800a6d4 <trans_anim_cb+0xfc>
 800a640:	2b1c      	cmp	r3, #28
 800a642:	da31      	bge.n	800a6a8 <trans_anim_cb+0xd0>
 800a644:	e0aa      	b.n	800a79c <trans_anim_cb+0x1c4>
 800a646:	3b5a      	subs	r3, #90	@ 0x5a
 800a648:	2b0d      	cmp	r3, #13
 800a64a:	f200 80a7 	bhi.w	800a79c <trans_anim_cb+0x1c4>
 800a64e:	a201      	add	r2, pc, #4	@ (adr r2, 800a654 <trans_anim_cb+0x7c>)
 800a650:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a654:	0800a6f5 	.word	0x0800a6f5
 800a658:	0800a79d 	.word	0x0800a79d
 800a65c:	0800a79d 	.word	0x0800a79d
 800a660:	0800a79d 	.word	0x0800a79d
 800a664:	0800a79d 	.word	0x0800a79d
 800a668:	0800a79d 	.word	0x0800a79d
 800a66c:	0800a79d 	.word	0x0800a79d
 800a670:	0800a70b 	.word	0x0800a70b
 800a674:	0800a79d 	.word	0x0800a79d
 800a678:	0800a79d 	.word	0x0800a79d
 800a67c:	0800a79d 	.word	0x0800a79d
 800a680:	0800a79d 	.word	0x0800a79d
 800a684:	0800a6f5 	.word	0x0800a6f5
 800a688:	0800a6df 	.word	0x0800a6df
 800a68c:	3b3d      	subs	r3, #61	@ 0x3d
 800a68e:	4a78      	ldr	r2, [pc, #480]	@ (800a870 <trans_anim_cb+0x298>)
 800a690:	fa22 f303 	lsr.w	r3, r2, r3
 800a694:	f003 0301 	and.w	r3, r3, #1
 800a698:	2b00      	cmp	r3, #0
 800a69a:	bf14      	ite	ne
 800a69c:	2301      	movne	r3, #1
 800a69e:	2300      	moveq	r3, #0
 800a6a0:	b2db      	uxtb	r3, r3
 800a6a2:	2b00      	cmp	r3, #0
 800a6a4:	d14c      	bne.n	800a740 <trans_anim_cb+0x168>
 800a6a6:	e079      	b.n	800a79c <trans_anim_cb+0x1c4>
 800a6a8:	3b1c      	subs	r3, #28
 800a6aa:	2201      	movs	r2, #1
 800a6ac:	409a      	lsls	r2, r3
 800a6ae:	4b71      	ldr	r3, [pc, #452]	@ (800a874 <trans_anim_cb+0x29c>)
 800a6b0:	4013      	ands	r3, r2
 800a6b2:	2b00      	cmp	r3, #0
 800a6b4:	bf14      	ite	ne
 800a6b6:	2301      	movne	r3, #1
 800a6b8:	2300      	moveq	r3, #0
 800a6ba:	b2db      	uxtb	r3, r3
 800a6bc:	2b00      	cmp	r3, #0
 800a6be:	d13f      	bne.n	800a740 <trans_anim_cb+0x168>
 800a6c0:	f002 7340 	and.w	r3, r2, #50331648	@ 0x3000000
 800a6c4:	2b00      	cmp	r3, #0
 800a6c6:	bf14      	ite	ne
 800a6c8:	2301      	movne	r3, #1
 800a6ca:	2300      	moveq	r3, #0
 800a6cc:	b2db      	uxtb	r3, r3
 800a6ce:	2b00      	cmp	r3, #0
 800a6d0:	d105      	bne.n	800a6de <trans_anim_cb+0x106>
 800a6d2:	e063      	b.n	800a79c <trans_anim_cb+0x1c4>
 800a6d4:	2b58      	cmp	r3, #88	@ 0x58
 800a6d6:	dc61      	bgt.n	800a79c <trans_anim_cb+0x1c4>
 800a6d8:	2b3d      	cmp	r3, #61	@ 0x3d
 800a6da:	dad7      	bge.n	800a68c <trans_anim_cb+0xb4>
 800a6dc:	e05e      	b.n	800a79c <trans_anim_cb+0x1c4>

            case LV_STYLE_BORDER_SIDE:
            case LV_STYLE_BORDER_POST:
            case LV_STYLE_BLEND_MODE:
                if(v < 255) value_final.num = tr->start_value.num;
 800a6de:	683b      	ldr	r3, [r7, #0]
 800a6e0:	2bfe      	cmp	r3, #254	@ 0xfe
 800a6e2:	dc03      	bgt.n	800a6ec <trans_anim_cb+0x114>
 800a6e4:	697b      	ldr	r3, [r7, #20]
 800a6e6:	68db      	ldr	r3, [r3, #12]
 800a6e8:	60fb      	str	r3, [r7, #12]
                else value_final.num = tr->end_value.num;
                break;
 800a6ea:	e073      	b.n	800a7d4 <trans_anim_cb+0x1fc>
                else value_final.num = tr->end_value.num;
 800a6ec:	697b      	ldr	r3, [r7, #20]
 800a6ee:	691b      	ldr	r3, [r3, #16]
 800a6f0:	60fb      	str	r3, [r7, #12]
                break;
 800a6f2:	e06f      	b.n	800a7d4 <trans_anim_cb+0x1fc>
            case LV_STYLE_TRANSITION:
            case LV_STYLE_TEXT_FONT:
                if(v < 255) value_final.ptr = tr->start_value.ptr;
 800a6f4:	683b      	ldr	r3, [r7, #0]
 800a6f6:	2bfe      	cmp	r3, #254	@ 0xfe
 800a6f8:	dc03      	bgt.n	800a702 <trans_anim_cb+0x12a>
 800a6fa:	697b      	ldr	r3, [r7, #20]
 800a6fc:	68db      	ldr	r3, [r3, #12]
 800a6fe:	60fb      	str	r3, [r7, #12]
                else value_final.ptr = tr->end_value.ptr;
                break;
 800a700:	e068      	b.n	800a7d4 <trans_anim_cb+0x1fc>
                else value_final.ptr = tr->end_value.ptr;
 800a702:	697b      	ldr	r3, [r7, #20]
 800a704:	691b      	ldr	r3, [r3, #16]
 800a706:	60fb      	str	r3, [r7, #12]
                break;
 800a708:	e064      	b.n	800a7d4 <trans_anim_cb+0x1fc>
            case LV_STYLE_COLOR_FILTER_DSC:
                if(tr->start_value.ptr == NULL) value_final.ptr = tr->end_value.ptr;
 800a70a:	697b      	ldr	r3, [r7, #20]
 800a70c:	68db      	ldr	r3, [r3, #12]
 800a70e:	2b00      	cmp	r3, #0
 800a710:	d103      	bne.n	800a71a <trans_anim_cb+0x142>
 800a712:	697b      	ldr	r3, [r7, #20]
 800a714:	691b      	ldr	r3, [r3, #16]
 800a716:	60fb      	str	r3, [r7, #12]
                else if(tr->end_value.ptr == NULL) value_final.ptr = tr->start_value.ptr;
                else if(v < 128) value_final.ptr = tr->start_value.ptr;
                else value_final.ptr = tr->end_value.ptr;
                break;
 800a718:	e05c      	b.n	800a7d4 <trans_anim_cb+0x1fc>
                else if(tr->end_value.ptr == NULL) value_final.ptr = tr->start_value.ptr;
 800a71a:	697b      	ldr	r3, [r7, #20]
 800a71c:	691b      	ldr	r3, [r3, #16]
 800a71e:	2b00      	cmp	r3, #0
 800a720:	d103      	bne.n	800a72a <trans_anim_cb+0x152>
 800a722:	697b      	ldr	r3, [r7, #20]
 800a724:	68db      	ldr	r3, [r3, #12]
 800a726:	60fb      	str	r3, [r7, #12]
                break;
 800a728:	e054      	b.n	800a7d4 <trans_anim_cb+0x1fc>
                else if(v < 128) value_final.ptr = tr->start_value.ptr;
 800a72a:	683b      	ldr	r3, [r7, #0]
 800a72c:	2b7f      	cmp	r3, #127	@ 0x7f
 800a72e:	dc03      	bgt.n	800a738 <trans_anim_cb+0x160>
 800a730:	697b      	ldr	r3, [r7, #20]
 800a732:	68db      	ldr	r3, [r3, #12]
 800a734:	60fb      	str	r3, [r7, #12]
                break;
 800a736:	e04d      	b.n	800a7d4 <trans_anim_cb+0x1fc>
                else value_final.ptr = tr->end_value.ptr;
 800a738:	697b      	ldr	r3, [r7, #20]
 800a73a:	691b      	ldr	r3, [r3, #16]
 800a73c:	60fb      	str	r3, [r7, #12]
                break;
 800a73e:	e049      	b.n	800a7d4 <trans_anim_cb+0x1fc>
            case LV_STYLE_BORDER_COLOR:
            case LV_STYLE_TEXT_COLOR:
            case LV_STYLE_SHADOW_COLOR:
            case LV_STYLE_OUTLINE_COLOR:
            case LV_STYLE_IMAGE_RECOLOR:
                if(v <= 0) value_final.color = tr->start_value.color;
 800a740:	683b      	ldr	r3, [r7, #0]
 800a742:	2b00      	cmp	r3, #0
 800a744:	dc0a      	bgt.n	800a75c <trans_anim_cb+0x184>
 800a746:	697a      	ldr	r2, [r7, #20]
 800a748:	f107 030c 	add.w	r3, r7, #12
 800a74c:	320c      	adds	r2, #12
 800a74e:	6812      	ldr	r2, [r2, #0]
 800a750:	4611      	mov	r1, r2
 800a752:	8019      	strh	r1, [r3, #0]
 800a754:	3302      	adds	r3, #2
 800a756:	0c12      	lsrs	r2, r2, #16
 800a758:	701a      	strb	r2, [r3, #0]
                else if(v >= 255) value_final.color = tr->end_value.color;
                else value_final.color = lv_color_mix(tr->end_value.color, tr->start_value.color, v);
                break;
 800a75a:	e03b      	b.n	800a7d4 <trans_anim_cb+0x1fc>
                else if(v >= 255) value_final.color = tr->end_value.color;
 800a75c:	683b      	ldr	r3, [r7, #0]
 800a75e:	2bfe      	cmp	r3, #254	@ 0xfe
 800a760:	dd0a      	ble.n	800a778 <trans_anim_cb+0x1a0>
 800a762:	697a      	ldr	r2, [r7, #20]
 800a764:	f107 030c 	add.w	r3, r7, #12
 800a768:	3210      	adds	r2, #16
 800a76a:	6812      	ldr	r2, [r2, #0]
 800a76c:	4611      	mov	r1, r2
 800a76e:	8019      	strh	r1, [r3, #0]
 800a770:	3302      	adds	r3, #2
 800a772:	0c12      	lsrs	r2, r2, #16
 800a774:	701a      	strb	r2, [r3, #0]
                break;
 800a776:	e02d      	b.n	800a7d4 <trans_anim_cb+0x1fc>
                else value_final.color = lv_color_mix(tr->end_value.color, tr->start_value.color, v);
 800a778:	683b      	ldr	r3, [r7, #0]
 800a77a:	b2da      	uxtb	r2, r3
 800a77c:	6979      	ldr	r1, [r7, #20]
 800a77e:	697b      	ldr	r3, [r7, #20]
 800a780:	68c9      	ldr	r1, [r1, #12]
 800a782:	6918      	ldr	r0, [r3, #16]
 800a784:	f7fe f9e1 	bl	8008b4a <lv_color_mix>
 800a788:	4603      	mov	r3, r0
 800a78a:	461a      	mov	r2, r3
 800a78c:	733a      	strb	r2, [r7, #12]
 800a78e:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800a792:	737a      	strb	r2, [r7, #13]
 800a794:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800a798:	73bb      	strb	r3, [r7, #14]
                break;
 800a79a:	e01b      	b.n	800a7d4 <trans_anim_cb+0x1fc>

            default:
                if(v == 0) value_final.num = tr->start_value.num;
 800a79c:	683b      	ldr	r3, [r7, #0]
 800a79e:	2b00      	cmp	r3, #0
 800a7a0:	d103      	bne.n	800a7aa <trans_anim_cb+0x1d2>
 800a7a2:	697b      	ldr	r3, [r7, #20]
 800a7a4:	68db      	ldr	r3, [r3, #12]
 800a7a6:	60fb      	str	r3, [r7, #12]
                else if(v == 255) value_final.num = tr->end_value.num;
                else value_final.num = tr->start_value.num + ((int32_t)((int32_t)(tr->end_value.num - tr->start_value.num) * v) >> 8);
                break;
 800a7a8:	e013      	b.n	800a7d2 <trans_anim_cb+0x1fa>
                else if(v == 255) value_final.num = tr->end_value.num;
 800a7aa:	683b      	ldr	r3, [r7, #0]
 800a7ac:	2bff      	cmp	r3, #255	@ 0xff
 800a7ae:	d103      	bne.n	800a7b8 <trans_anim_cb+0x1e0>
 800a7b0:	697b      	ldr	r3, [r7, #20]
 800a7b2:	691b      	ldr	r3, [r3, #16]
 800a7b4:	60fb      	str	r3, [r7, #12]
                break;
 800a7b6:	e00c      	b.n	800a7d2 <trans_anim_cb+0x1fa>
                else value_final.num = tr->start_value.num + ((int32_t)((int32_t)(tr->end_value.num - tr->start_value.num) * v) >> 8);
 800a7b8:	697b      	ldr	r3, [r7, #20]
 800a7ba:	68da      	ldr	r2, [r3, #12]
 800a7bc:	697b      	ldr	r3, [r7, #20]
 800a7be:	6919      	ldr	r1, [r3, #16]
 800a7c0:	697b      	ldr	r3, [r7, #20]
 800a7c2:	68db      	ldr	r3, [r3, #12]
 800a7c4:	1acb      	subs	r3, r1, r3
 800a7c6:	6839      	ldr	r1, [r7, #0]
 800a7c8:	fb01 f303 	mul.w	r3, r1, r3
 800a7cc:	121b      	asrs	r3, r3, #8
 800a7ce:	4413      	add	r3, r2
 800a7d0:	60fb      	str	r3, [r7, #12]
                break;
 800a7d2:	bf00      	nop
        }

        lv_style_value_t old_value = {0};
 800a7d4:	2300      	movs	r3, #0
 800a7d6:	60bb      	str	r3, [r7, #8]
        bool refr = true;
 800a7d8:	2301      	movs	r3, #1
 800a7da:	76fb      	strb	r3, [r7, #27]
        if(lv_style_get_prop(obj->styles[i].style, tr->prop, &old_value)) {
 800a7dc:	693b      	ldr	r3, [r7, #16]
 800a7de:	68da      	ldr	r2, [r3, #12]
 800a7e0:	69fb      	ldr	r3, [r7, #28]
 800a7e2:	00db      	lsls	r3, r3, #3
 800a7e4:	4413      	add	r3, r2
 800a7e6:	6818      	ldr	r0, [r3, #0]
 800a7e8:	697b      	ldr	r3, [r7, #20]
 800a7ea:	791b      	ldrb	r3, [r3, #4]
 800a7ec:	f107 0208 	add.w	r2, r7, #8
 800a7f0:	4619      	mov	r1, r3
 800a7f2:	f019 f9a8 	bl	8023b46 <lv_style_get_prop>
 800a7f6:	4603      	mov	r3, r0
 800a7f8:	2b00      	cmp	r3, #0
 800a7fa:	d010      	beq.n	800a81e <trans_anim_cb+0x246>
            if(value_final.ptr == old_value.ptr && lv_color_eq(value_final.color, old_value.color) &&
 800a7fc:	68fa      	ldr	r2, [r7, #12]
 800a7fe:	68bb      	ldr	r3, [r7, #8]
 800a800:	429a      	cmp	r2, r3
 800a802:	d10c      	bne.n	800a81e <trans_anim_cb+0x246>
 800a804:	68b9      	ldr	r1, [r7, #8]
 800a806:	68f8      	ldr	r0, [r7, #12]
 800a808:	f7fe f989 	bl	8008b1e <lv_color_eq>
 800a80c:	4603      	mov	r3, r0
 800a80e:	2b00      	cmp	r3, #0
 800a810:	d005      	beq.n	800a81e <trans_anim_cb+0x246>
               value_final.num == old_value.num) {
 800a812:	68fa      	ldr	r2, [r7, #12]
 800a814:	68bb      	ldr	r3, [r7, #8]
            if(value_final.ptr == old_value.ptr && lv_color_eq(value_final.color, old_value.color) &&
 800a816:	429a      	cmp	r2, r3
 800a818:	d101      	bne.n	800a81e <trans_anim_cb+0x246>
                refr = false;
 800a81a:	2300      	movs	r3, #0
 800a81c:	76fb      	strb	r3, [r7, #27]
            }
        }
        lv_style_set_prop((lv_style_t *)obj->styles[i].style, tr->prop, value_final);
 800a81e:	693b      	ldr	r3, [r7, #16]
 800a820:	68da      	ldr	r2, [r3, #12]
 800a822:	69fb      	ldr	r3, [r7, #28]
 800a824:	00db      	lsls	r3, r3, #3
 800a826:	4413      	add	r3, r2
 800a828:	6818      	ldr	r0, [r3, #0]
 800a82a:	697b      	ldr	r3, [r7, #20]
 800a82c:	791b      	ldrb	r3, [r3, #4]
 800a82e:	68fa      	ldr	r2, [r7, #12]
 800a830:	4619      	mov	r1, r3
 800a832:	f019 f8eb 	bl	8023a0c <lv_style_set_prop>
        if(refr) lv_obj_refresh_style(tr->obj, tr->selector, tr->prop);
 800a836:	7efb      	ldrb	r3, [r7, #27]
 800a838:	2b00      	cmp	r3, #0
 800a83a:	d014      	beq.n	800a866 <trans_anim_cb+0x28e>
 800a83c:	697b      	ldr	r3, [r7, #20]
 800a83e:	6818      	ldr	r0, [r3, #0]
 800a840:	697b      	ldr	r3, [r7, #20]
 800a842:	6899      	ldr	r1, [r3, #8]
 800a844:	697b      	ldr	r3, [r7, #20]
 800a846:	791b      	ldrb	r3, [r3, #4]
 800a848:	461a      	mov	r2, r3
 800a84a:	f7fe fd85 	bl	8009358 <lv_obj_refresh_style>
        break;

    }

}
 800a84e:	e00b      	b.n	800a868 <trans_anim_cb+0x290>
    for(i = 0; i < obj->style_cnt; i++) {
 800a850:	693b      	ldr	r3, [r7, #16]
 800a852:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a854:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800a858:	b2db      	uxtb	r3, r3
 800a85a:	461a      	mov	r2, r3
 800a85c:	69fb      	ldr	r3, [r7, #28]
 800a85e:	4293      	cmp	r3, r2
 800a860:	f4ff aec7 	bcc.w	800a5f2 <trans_anim_cb+0x1a>
}
 800a864:	e000      	b.n	800a868 <trans_anim_cb+0x290>
        break;
 800a866:	bf00      	nop
}
 800a868:	bf00      	nop
 800a86a:	3720      	adds	r7, #32
 800a86c:	46bd      	mov	sp, r7
 800a86e:	bd80      	pop	{r7, pc}
 800a870:	08000101 	.word	0x08000101
 800a874:	20200081 	.word	0x20200081

0800a878 <trans_anim_start_cb>:

static void trans_anim_start_cb(lv_anim_t * a)
{
 800a878:	b590      	push	{r4, r7, lr}
 800a87a:	b087      	sub	sp, #28
 800a87c:	af00      	add	r7, sp, #0
 800a87e:	6078      	str	r0, [r7, #4]
    trans_t * tr = a->var;
 800a880:	687b      	ldr	r3, [r7, #4]
 800a882:	681b      	ldr	r3, [r3, #0]
 800a884:	617b      	str	r3, [r7, #20]

    lv_part_t part = lv_obj_style_get_selector_part(tr->selector);
 800a886:	697b      	ldr	r3, [r7, #20]
 800a888:	689b      	ldr	r3, [r3, #8]
 800a88a:	4618      	mov	r0, r3
 800a88c:	f7fe fb23 	bl	8008ed6 <lv_obj_style_get_selector_part>
 800a890:	6138      	str	r0, [r7, #16]
    tr->start_value = lv_obj_get_style_prop(tr->obj, part, tr->prop);
 800a892:	697b      	ldr	r3, [r7, #20]
 800a894:	6818      	ldr	r0, [r3, #0]
 800a896:	697b      	ldr	r3, [r7, #20]
 800a898:	791b      	ldrb	r3, [r3, #4]
 800a89a:	697c      	ldr	r4, [r7, #20]
 800a89c:	461a      	mov	r2, r3
 800a89e:	6939      	ldr	r1, [r7, #16]
 800a8a0:	f7fe ff42 	bl	8009728 <lv_obj_get_style_prop>
 800a8a4:	4603      	mov	r3, r0
 800a8a6:	60e3      	str	r3, [r4, #12]

    /*Init prop to an invalid values to be sure `trans_del` won't delete this added `tr`*/
    lv_style_prop_t prop_tmp = tr->prop;
 800a8a8:	697b      	ldr	r3, [r7, #20]
 800a8aa:	791b      	ldrb	r3, [r3, #4]
 800a8ac:	73fb      	strb	r3, [r7, #15]
    tr->prop = LV_STYLE_PROP_INV;
 800a8ae:	697b      	ldr	r3, [r7, #20]
 800a8b0:	2200      	movs	r2, #0
 800a8b2:	711a      	strb	r2, [r3, #4]

    /*Delete the related transitions if any*/
    trans_delete(tr->obj, part, prop_tmp, tr);
 800a8b4:	697b      	ldr	r3, [r7, #20]
 800a8b6:	6818      	ldr	r0, [r3, #0]
 800a8b8:	7bfa      	ldrb	r2, [r7, #15]
 800a8ba:	697b      	ldr	r3, [r7, #20]
 800a8bc:	6939      	ldr	r1, [r7, #16]
 800a8be:	f7ff fe0b 	bl	800a4d8 <trans_delete>

    tr->prop = prop_tmp;
 800a8c2:	697b      	ldr	r3, [r7, #20]
 800a8c4:	7bfa      	ldrb	r2, [r7, #15]
 800a8c6:	711a      	strb	r2, [r3, #4]

    _lv_obj_style_t * style_trans = get_trans_style(tr->obj, tr->selector);
 800a8c8:	697b      	ldr	r3, [r7, #20]
 800a8ca:	681a      	ldr	r2, [r3, #0]
 800a8cc:	697b      	ldr	r3, [r7, #20]
 800a8ce:	689b      	ldr	r3, [r3, #8]
 800a8d0:	4619      	mov	r1, r3
 800a8d2:	4610      	mov	r0, r2
 800a8d4:	f7ff fc46 	bl	800a164 <get_trans_style>
 800a8d8:	60b8      	str	r0, [r7, #8]
    lv_style_set_prop((lv_style_t *)style_trans->style, tr->prop,
 800a8da:	68bb      	ldr	r3, [r7, #8]
 800a8dc:	6818      	ldr	r0, [r3, #0]
 800a8de:	697b      	ldr	r3, [r7, #20]
 800a8e0:	7919      	ldrb	r1, [r3, #4]
 800a8e2:	697b      	ldr	r3, [r7, #20]
 800a8e4:	68da      	ldr	r2, [r3, #12]
 800a8e6:	f019 f891 	bl	8023a0c <lv_style_set_prop>
                      tr->start_value);  /*Be sure `trans_style` has a valid value*/

}
 800a8ea:	bf00      	nop
 800a8ec:	371c      	adds	r7, #28
 800a8ee:	46bd      	mov	sp, r7
 800a8f0:	bd90      	pop	{r4, r7, pc}
	...

0800a8f4 <trans_anim_completed_cb>:

static void trans_anim_completed_cb(lv_anim_t * a)
{
 800a8f4:	b580      	push	{r7, lr}
 800a8f6:	b08a      	sub	sp, #40	@ 0x28
 800a8f8:	af00      	add	r7, sp, #0
 800a8fa:	6078      	str	r0, [r7, #4]
    trans_t * tr = a->var;
 800a8fc:	687b      	ldr	r3, [r7, #4]
 800a8fe:	681b      	ldr	r3, [r3, #0]
 800a900:	61bb      	str	r3, [r7, #24]
    lv_obj_t * obj = tr->obj;
 800a902:	69bb      	ldr	r3, [r7, #24]
 800a904:	681b      	ldr	r3, [r3, #0]
 800a906:	617b      	str	r3, [r7, #20]
    lv_style_prop_t prop = tr->prop;
 800a908:	69bb      	ldr	r3, [r7, #24]
 800a90a:	791b      	ldrb	r3, [r3, #4]
 800a90c:	74fb      	strb	r3, [r7, #19]

    /*Remove the transitioned property from trans. style
     *if there no more transitions for this property
     *It allows changing it by normal styles*/
    bool running = false;
 800a90e:	2300      	movs	r3, #0
 800a910:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    trans_t * tr_i;
    _LV_LL_READ(style_trans_ll_p, tr_i) {
 800a914:	4842      	ldr	r0, [pc, #264]	@ (800aa20 <trans_anim_completed_cb+0x12c>)
 800a916:	f018 fc5a 	bl	80231ce <_lv_ll_get_head>
 800a91a:	6238      	str	r0, [r7, #32]
 800a91c:	e01e      	b.n	800a95c <trans_anim_completed_cb+0x68>
        if(tr_i != tr && tr_i->obj == tr->obj && tr_i->selector == tr->selector && tr_i->prop == tr->prop) {
 800a91e:	6a3a      	ldr	r2, [r7, #32]
 800a920:	69bb      	ldr	r3, [r7, #24]
 800a922:	429a      	cmp	r2, r3
 800a924:	d015      	beq.n	800a952 <trans_anim_completed_cb+0x5e>
 800a926:	6a3b      	ldr	r3, [r7, #32]
 800a928:	681a      	ldr	r2, [r3, #0]
 800a92a:	69bb      	ldr	r3, [r7, #24]
 800a92c:	681b      	ldr	r3, [r3, #0]
 800a92e:	429a      	cmp	r2, r3
 800a930:	d10f      	bne.n	800a952 <trans_anim_completed_cb+0x5e>
 800a932:	6a3b      	ldr	r3, [r7, #32]
 800a934:	689a      	ldr	r2, [r3, #8]
 800a936:	69bb      	ldr	r3, [r7, #24]
 800a938:	689b      	ldr	r3, [r3, #8]
 800a93a:	429a      	cmp	r2, r3
 800a93c:	d109      	bne.n	800a952 <trans_anim_completed_cb+0x5e>
 800a93e:	6a3b      	ldr	r3, [r7, #32]
 800a940:	791a      	ldrb	r2, [r3, #4]
 800a942:	69bb      	ldr	r3, [r7, #24]
 800a944:	791b      	ldrb	r3, [r3, #4]
 800a946:	429a      	cmp	r2, r3
 800a948:	d103      	bne.n	800a952 <trans_anim_completed_cb+0x5e>
            running = true;
 800a94a:	2301      	movs	r3, #1
 800a94c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
            break;
 800a950:	e007      	b.n	800a962 <trans_anim_completed_cb+0x6e>
    _LV_LL_READ(style_trans_ll_p, tr_i) {
 800a952:	6a39      	ldr	r1, [r7, #32]
 800a954:	4832      	ldr	r0, [pc, #200]	@ (800aa20 <trans_anim_completed_cb+0x12c>)
 800a956:	f018 fc5c 	bl	8023212 <_lv_ll_get_next>
 800a95a:	6238      	str	r0, [r7, #32]
 800a95c:	6a3b      	ldr	r3, [r7, #32]
 800a95e:	2b00      	cmp	r3, #0
 800a960:	d1dd      	bne.n	800a91e <trans_anim_completed_cb+0x2a>
        }
    }

    if(!running) {
 800a962:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800a966:	f083 0301 	eor.w	r3, r3, #1
 800a96a:	b2db      	uxtb	r3, r3
 800a96c:	2b00      	cmp	r3, #0
 800a96e:	d053      	beq.n	800aa18 <trans_anim_completed_cb+0x124>
        uint32_t i;
        for(i = 0; i < obj->style_cnt; i++) {
 800a970:	2300      	movs	r3, #0
 800a972:	61fb      	str	r3, [r7, #28]
 800a974:	e045      	b.n	800aa02 <trans_anim_completed_cb+0x10e>
            if(obj->styles[i].is_trans && obj->styles[i].selector == tr->selector) {
 800a976:	697b      	ldr	r3, [r7, #20]
 800a978:	68da      	ldr	r2, [r3, #12]
 800a97a:	69fb      	ldr	r3, [r7, #28]
 800a97c:	00db      	lsls	r3, r3, #3
 800a97e:	4413      	add	r3, r2
 800a980:	79db      	ldrb	r3, [r3, #7]
 800a982:	f003 0302 	and.w	r3, r3, #2
 800a986:	b2db      	uxtb	r3, r3
 800a988:	2b00      	cmp	r3, #0
 800a98a:	d037      	beq.n	800a9fc <trans_anim_completed_cb+0x108>
 800a98c:	697b      	ldr	r3, [r7, #20]
 800a98e:	68da      	ldr	r2, [r3, #12]
 800a990:	69fb      	ldr	r3, [r7, #28]
 800a992:	00db      	lsls	r3, r3, #3
 800a994:	4413      	add	r3, r2
 800a996:	685b      	ldr	r3, [r3, #4]
 800a998:	f3c3 0317 	ubfx	r3, r3, #0, #24
 800a99c:	461a      	mov	r2, r3
 800a99e:	69bb      	ldr	r3, [r7, #24]
 800a9a0:	689b      	ldr	r3, [r3, #8]
 800a9a2:	429a      	cmp	r2, r3
 800a9a4:	d12a      	bne.n	800a9fc <trans_anim_completed_cb+0x108>
                _lv_ll_remove(style_trans_ll_p, tr);
 800a9a6:	69b9      	ldr	r1, [r7, #24]
 800a9a8:	481d      	ldr	r0, [pc, #116]	@ (800aa20 <trans_anim_completed_cb+0x12c>)
 800a9aa:	f018 fbb3 	bl	8023114 <_lv_ll_remove>
                lv_free(tr);
 800a9ae:	69b8      	ldr	r0, [r7, #24]
 800a9b0:	f01b fa42 	bl	8025e38 <lv_free>

                _lv_obj_style_t * obj_style = &obj->styles[i];
 800a9b4:	697b      	ldr	r3, [r7, #20]
 800a9b6:	68da      	ldr	r2, [r3, #12]
 800a9b8:	69fb      	ldr	r3, [r7, #28]
 800a9ba:	00db      	lsls	r3, r3, #3
 800a9bc:	4413      	add	r3, r2
 800a9be:	60fb      	str	r3, [r7, #12]
                lv_style_remove_prop((lv_style_t *)obj_style->style, prop);
 800a9c0:	68fb      	ldr	r3, [r7, #12]
 800a9c2:	681b      	ldr	r3, [r3, #0]
 800a9c4:	7cfa      	ldrb	r2, [r7, #19]
 800a9c6:	4611      	mov	r1, r2
 800a9c8:	4618      	mov	r0, r3
 800a9ca:	f018 ff95 	bl	80238f8 <lv_style_remove_prop>

                if(lv_style_is_empty(obj->styles[i].style)) {
 800a9ce:	697b      	ldr	r3, [r7, #20]
 800a9d0:	68da      	ldr	r2, [r3, #12]
 800a9d2:	69fb      	ldr	r3, [r7, #28]
 800a9d4:	00db      	lsls	r3, r3, #3
 800a9d6:	4413      	add	r3, r2
 800a9d8:	681b      	ldr	r3, [r3, #0]
 800a9da:	4618      	mov	r0, r3
 800a9dc:	f019 f8c5 	bl	8023b6a <lv_style_is_empty>
 800a9e0:	4603      	mov	r3, r0
 800a9e2:	2b00      	cmp	r3, #0
 800a9e4:	d017      	beq.n	800aa16 <trans_anim_completed_cb+0x122>
                    lv_obj_remove_style(obj, (lv_style_t *)obj_style->style, obj_style->selector);
 800a9e6:	68fb      	ldr	r3, [r7, #12]
 800a9e8:	6819      	ldr	r1, [r3, #0]
 800a9ea:	68fb      	ldr	r3, [r7, #12]
 800a9ec:	685b      	ldr	r3, [r3, #4]
 800a9ee:	f3c3 0317 	ubfx	r3, r3, #0, #24
 800a9f2:	461a      	mov	r2, r3
 800a9f4:	6978      	ldr	r0, [r7, #20]
 800a9f6:	f7fe fb8b 	bl	8009110 <lv_obj_remove_style>

                }
                break;
 800a9fa:	e00c      	b.n	800aa16 <trans_anim_completed_cb+0x122>
        for(i = 0; i < obj->style_cnt; i++) {
 800a9fc:	69fb      	ldr	r3, [r7, #28]
 800a9fe:	3301      	adds	r3, #1
 800aa00:	61fb      	str	r3, [r7, #28]
 800aa02:	697b      	ldr	r3, [r7, #20]
 800aa04:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800aa06:	f3c3 1305 	ubfx	r3, r3, #4, #6
 800aa0a:	b2db      	uxtb	r3, r3
 800aa0c:	461a      	mov	r2, r3
 800aa0e:	69fb      	ldr	r3, [r7, #28]
 800aa10:	4293      	cmp	r3, r2
 800aa12:	d3b0      	bcc.n	800a976 <trans_anim_completed_cb+0x82>
            }
        }
    }
}
 800aa14:	e000      	b.n	800aa18 <trans_anim_completed_cb+0x124>
                break;
 800aa16:	bf00      	nop
}
 800aa18:	bf00      	nop
 800aa1a:	3728      	adds	r7, #40	@ 0x28
 800aa1c:	46bd      	mov	sp, r7
 800aa1e:	bd80      	pop	{r7, pc}
 800aa20:	200000b4 	.word	0x200000b4

0800aa24 <calculate_layer_type>:

static lv_layer_type_t calculate_layer_type(lv_obj_t * obj)
{
 800aa24:	b580      	push	{r7, lr}
 800aa26:	b082      	sub	sp, #8
 800aa28:	af00      	add	r7, sp, #0
 800aa2a:	6078      	str	r0, [r7, #4]
    if(lv_obj_get_style_transform_rotation(obj, 0) != 0) return LV_LAYER_TYPE_TRANSFORM;
 800aa2c:	2100      	movs	r1, #0
 800aa2e:	6878      	ldr	r0, [r7, #4]
 800aa30:	f7fe faa2 	bl	8008f78 <lv_obj_get_style_transform_rotation>
 800aa34:	4603      	mov	r3, r0
 800aa36:	2b00      	cmp	r3, #0
 800aa38:	d001      	beq.n	800aa3e <calculate_layer_type+0x1a>
 800aa3a:	2302      	movs	r3, #2
 800aa3c:	e041      	b.n	800aac2 <calculate_layer_type+0x9e>
    if(lv_obj_get_style_transform_scale_x(obj, 0) != 256) return LV_LAYER_TYPE_TRANSFORM;
 800aa3e:	2100      	movs	r1, #0
 800aa40:	6878      	ldr	r0, [r7, #4]
 800aa42:	f7fe fa77 	bl	8008f34 <lv_obj_get_style_transform_scale_x>
 800aa46:	4603      	mov	r3, r0
 800aa48:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800aa4c:	d001      	beq.n	800aa52 <calculate_layer_type+0x2e>
 800aa4e:	2302      	movs	r3, #2
 800aa50:	e037      	b.n	800aac2 <calculate_layer_type+0x9e>
    if(lv_obj_get_style_transform_scale_y(obj, 0) != 256) return LV_LAYER_TYPE_TRANSFORM;
 800aa52:	2100      	movs	r1, #0
 800aa54:	6878      	ldr	r0, [r7, #4]
 800aa56:	f7fe fa7e 	bl	8008f56 <lv_obj_get_style_transform_scale_y>
 800aa5a:	4603      	mov	r3, r0
 800aa5c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800aa60:	d001      	beq.n	800aa66 <calculate_layer_type+0x42>
 800aa62:	2302      	movs	r3, #2
 800aa64:	e02d      	b.n	800aac2 <calculate_layer_type+0x9e>
    if(lv_obj_get_style_transform_skew_x(obj, 0) != 0) return LV_LAYER_TYPE_TRANSFORM;
 800aa66:	2100      	movs	r1, #0
 800aa68:	6878      	ldr	r0, [r7, #4]
 800aa6a:	f7fe fa96 	bl	8008f9a <lv_obj_get_style_transform_skew_x>
 800aa6e:	4603      	mov	r3, r0
 800aa70:	2b00      	cmp	r3, #0
 800aa72:	d001      	beq.n	800aa78 <calculate_layer_type+0x54>
 800aa74:	2302      	movs	r3, #2
 800aa76:	e024      	b.n	800aac2 <calculate_layer_type+0x9e>
    if(lv_obj_get_style_transform_skew_y(obj, 0) != 0) return LV_LAYER_TYPE_TRANSFORM;
 800aa78:	2100      	movs	r1, #0
 800aa7a:	6878      	ldr	r0, [r7, #4]
 800aa7c:	f7fe fa9e 	bl	8008fbc <lv_obj_get_style_transform_skew_y>
 800aa80:	4603      	mov	r3, r0
 800aa82:	2b00      	cmp	r3, #0
 800aa84:	d001      	beq.n	800aa8a <calculate_layer_type+0x66>
 800aa86:	2302      	movs	r3, #2
 800aa88:	e01b      	b.n	800aac2 <calculate_layer_type+0x9e>
    if(lv_obj_get_style_opa_layered(obj, 0) != LV_OPA_COVER) return LV_LAYER_TYPE_SIMPLE;
 800aa8a:	2100      	movs	r1, #0
 800aa8c:	6878      	ldr	r0, [r7, #4]
 800aa8e:	f7fe faca 	bl	8009026 <lv_obj_get_style_opa_layered>
 800aa92:	4603      	mov	r3, r0
 800aa94:	2bff      	cmp	r3, #255	@ 0xff
 800aa96:	d001      	beq.n	800aa9c <calculate_layer_type+0x78>
 800aa98:	2301      	movs	r3, #1
 800aa9a:	e012      	b.n	800aac2 <calculate_layer_type+0x9e>
    if(lv_obj_get_style_bitmap_mask_src(obj, 0) != NULL) return LV_LAYER_TYPE_SIMPLE;
 800aa9c:	2100      	movs	r1, #0
 800aa9e:	6878      	ldr	r0, [r7, #4]
 800aaa0:	f7fe fb1a 	bl	80090d8 <lv_obj_get_style_bitmap_mask_src>
 800aaa4:	4603      	mov	r3, r0
 800aaa6:	2b00      	cmp	r3, #0
 800aaa8:	d001      	beq.n	800aaae <calculate_layer_type+0x8a>
 800aaaa:	2301      	movs	r3, #1
 800aaac:	e009      	b.n	800aac2 <calculate_layer_type+0x9e>
    if(lv_obj_get_style_blend_mode(obj, 0) != LV_BLEND_MODE_NORMAL) return LV_LAYER_TYPE_SIMPLE;
 800aaae:	2100      	movs	r1, #0
 800aab0:	6878      	ldr	r0, [r7, #4]
 800aab2:	f7fe faed 	bl	8009090 <lv_obj_get_style_blend_mode>
 800aab6:	4603      	mov	r3, r0
 800aab8:	2b00      	cmp	r3, #0
 800aaba:	d001      	beq.n	800aac0 <calculate_layer_type+0x9c>
 800aabc:	2301      	movs	r3, #1
 800aabe:	e000      	b.n	800aac2 <calculate_layer_type+0x9e>
    return LV_LAYER_TYPE_NONE;
 800aac0:	2300      	movs	r3, #0
}
 800aac2:	4618      	mov	r0, r3
 800aac4:	3708      	adds	r7, #8
 800aac6:	46bd      	mov	sp, r7
 800aac8:	bd80      	pop	{r7, pc}

0800aaca <full_cache_refresh>:

static void full_cache_refresh(lv_obj_t * obj, lv_part_t part)
{
 800aaca:	b480      	push	{r7}
 800aacc:	b083      	sub	sp, #12
 800aace:	af00      	add	r7, sp, #0
 800aad0:	6078      	str	r0, [r7, #4]
 800aad2:	6039      	str	r1, [r7, #0]
    }
#else
    LV_UNUSED(obj);
    LV_UNUSED(part);
#endif
}
 800aad4:	bf00      	nop
 800aad6:	370c      	adds	r7, #12
 800aad8:	46bd      	mov	sp, r7
 800aada:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aade:	4770      	bx	lr

0800aae0 <style_has_flag>:
{
    lv_obj_remove_local_style_prop(a->var, LV_STYLE_OPA, 0);
}

static bool style_has_flag(const lv_style_t * style, uint32_t flag)
{
 800aae0:	b580      	push	{r7, lr}
 800aae2:	b086      	sub	sp, #24
 800aae4:	af00      	add	r7, sp, #0
 800aae6:	6078      	str	r0, [r7, #4]
 800aae8:	6039      	str	r1, [r7, #0]
    if(lv_style_is_const(style)) {
 800aaea:	6878      	ldr	r0, [r7, #4]
 800aaec:	f7fe f94c 	bl	8008d88 <lv_style_is_const>
 800aaf0:	4603      	mov	r3, r0
 800aaf2:	2b00      	cmp	r3, #0
 800aaf4:	d021      	beq.n	800ab3a <style_has_flag+0x5a>
        lv_style_const_prop_t * props = style->values_and_props;
 800aaf6:	687b      	ldr	r3, [r7, #4]
 800aaf8:	681b      	ldr	r3, [r3, #0]
 800aafa:	60bb      	str	r3, [r7, #8]
        uint32_t i;
        for(i = 0; props[i].prop_ptr; i++) {
 800aafc:	2300      	movs	r3, #0
 800aafe:	617b      	str	r3, [r7, #20]
 800ab00:	e013      	b.n	800ab2a <style_has_flag+0x4a>
            if(lv_style_prop_has_flag(*props[i].prop_ptr, flag)) {
 800ab02:	697b      	ldr	r3, [r7, #20]
 800ab04:	00db      	lsls	r3, r3, #3
 800ab06:	68ba      	ldr	r2, [r7, #8]
 800ab08:	4413      	add	r3, r2
 800ab0a:	681b      	ldr	r3, [r3, #0]
 800ab0c:	781b      	ldrb	r3, [r3, #0]
 800ab0e:	683a      	ldr	r2, [r7, #0]
 800ab10:	b2d2      	uxtb	r2, r2
 800ab12:	4611      	mov	r1, r2
 800ab14:	4618      	mov	r0, r3
 800ab16:	f7fe f9b8 	bl	8008e8a <lv_style_prop_has_flag>
 800ab1a:	4603      	mov	r3, r0
 800ab1c:	2b00      	cmp	r3, #0
 800ab1e:	d001      	beq.n	800ab24 <style_has_flag+0x44>
                return true;
 800ab20:	2301      	movs	r3, #1
 800ab22:	e02d      	b.n	800ab80 <style_has_flag+0xa0>
        for(i = 0; props[i].prop_ptr; i++) {
 800ab24:	697b      	ldr	r3, [r7, #20]
 800ab26:	3301      	adds	r3, #1
 800ab28:	617b      	str	r3, [r7, #20]
 800ab2a:	697b      	ldr	r3, [r7, #20]
 800ab2c:	00db      	lsls	r3, r3, #3
 800ab2e:	68ba      	ldr	r2, [r7, #8]
 800ab30:	4413      	add	r3, r2
 800ab32:	681b      	ldr	r3, [r3, #0]
 800ab34:	2b00      	cmp	r3, #0
 800ab36:	d1e4      	bne.n	800ab02 <style_has_flag+0x22>
 800ab38:	e021      	b.n	800ab7e <style_has_flag+0x9e>
            }
        }
    }
    else {
        lv_style_prop_t * props = (lv_style_prop_t *)style->values_and_props + style->prop_cnt * sizeof(lv_style_value_t);
 800ab3a:	687b      	ldr	r3, [r7, #4]
 800ab3c:	681a      	ldr	r2, [r3, #0]
 800ab3e:	687b      	ldr	r3, [r7, #4]
 800ab40:	7a1b      	ldrb	r3, [r3, #8]
 800ab42:	009b      	lsls	r3, r3, #2
 800ab44:	4413      	add	r3, r2
 800ab46:	60fb      	str	r3, [r7, #12]
        uint32_t i;
        for(i = 0; i < style->prop_cnt; i++) {
 800ab48:	2300      	movs	r3, #0
 800ab4a:	613b      	str	r3, [r7, #16]
 800ab4c:	e011      	b.n	800ab72 <style_has_flag+0x92>
            if(lv_style_prop_has_flag(props[i], flag)) {
 800ab4e:	68fa      	ldr	r2, [r7, #12]
 800ab50:	693b      	ldr	r3, [r7, #16]
 800ab52:	4413      	add	r3, r2
 800ab54:	781b      	ldrb	r3, [r3, #0]
 800ab56:	683a      	ldr	r2, [r7, #0]
 800ab58:	b2d2      	uxtb	r2, r2
 800ab5a:	4611      	mov	r1, r2
 800ab5c:	4618      	mov	r0, r3
 800ab5e:	f7fe f994 	bl	8008e8a <lv_style_prop_has_flag>
 800ab62:	4603      	mov	r3, r0
 800ab64:	2b00      	cmp	r3, #0
 800ab66:	d001      	beq.n	800ab6c <style_has_flag+0x8c>
                return true;
 800ab68:	2301      	movs	r3, #1
 800ab6a:	e009      	b.n	800ab80 <style_has_flag+0xa0>
        for(i = 0; i < style->prop_cnt; i++) {
 800ab6c:	693b      	ldr	r3, [r7, #16]
 800ab6e:	3301      	adds	r3, #1
 800ab70:	613b      	str	r3, [r7, #16]
 800ab72:	687b      	ldr	r3, [r7, #4]
 800ab74:	7a1b      	ldrb	r3, [r3, #8]
 800ab76:	461a      	mov	r2, r3
 800ab78:	693b      	ldr	r3, [r7, #16]
 800ab7a:	4293      	cmp	r3, r2
 800ab7c:	d3e7      	bcc.n	800ab4e <style_has_flag+0x6e>
            }
        }
    }
    return false;
 800ab7e:	2300      	movs	r3, #0
}
 800ab80:	4618      	mov	r0, r3
 800ab82:	3718      	adds	r7, #24
 800ab84:	46bd      	mov	sp, r7
 800ab86:	bd80      	pop	{r7, pc}

0800ab88 <get_selector_style_prop>:

static lv_style_res_t get_selector_style_prop(const lv_obj_t * obj, lv_style_selector_t selector, lv_style_prop_t prop,
                                              lv_style_value_t * value_act)
{
 800ab88:	b580      	push	{r7, lr}
 800ab8a:	b088      	sub	sp, #32
 800ab8c:	af00      	add	r7, sp, #0
 800ab8e:	60f8      	str	r0, [r7, #12]
 800ab90:	60b9      	str	r1, [r7, #8]
 800ab92:	603b      	str	r3, [r7, #0]
 800ab94:	4613      	mov	r3, r2
 800ab96:	71fb      	strb	r3, [r7, #7]
    lv_style_res_t found;
    lv_part_t part = lv_obj_style_get_selector_part(selector);
 800ab98:	68b8      	ldr	r0, [r7, #8]
 800ab9a:	f7fe f99c 	bl	8008ed6 <lv_obj_style_get_selector_part>
 800ab9e:	61f8      	str	r0, [r7, #28]
#if LV_OBJ_STYLE_CACHE
    const uint32_t prop_shifted = STYLE_PROP_SHIFTED(prop);
    if((part == LV_PART_MAIN ? obj->style_main_prop_is_set : obj->style_other_prop_is_set) & prop_shifted)
#endif
    {
        found = get_prop_core(obj, selector, prop, value_act);
 800aba0:	79fa      	ldrb	r2, [r7, #7]
 800aba2:	683b      	ldr	r3, [r7, #0]
 800aba4:	68b9      	ldr	r1, [r7, #8]
 800aba6:	68f8      	ldr	r0, [r7, #12]
 800aba8:	f7ff fb86 	bl	800a2b8 <get_prop_core>
 800abac:	4603      	mov	r3, r0
 800abae:	74fb      	strb	r3, [r7, #19]
        if(found == LV_STYLE_RES_FOUND) return LV_STYLE_RES_FOUND;
 800abb0:	7cfb      	ldrb	r3, [r7, #19]
 800abb2:	2b01      	cmp	r3, #1
 800abb4:	d101      	bne.n	800abba <get_selector_style_prop+0x32>
 800abb6:	2301      	movs	r3, #1
 800abb8:	e072      	b.n	800aca0 <get_selector_style_prop+0x118>
    }

    extern const uint8_t _lv_style_builtin_prop_flag_lookup_table[];
    bool inheritable = false;
 800abba:	2300      	movs	r3, #0
 800abbc:	76fb      	strb	r3, [r7, #27]
    if(prop < _LV_STYLE_NUM_BUILT_IN_PROPS) {
 800abbe:	79fb      	ldrb	r3, [r7, #7]
 800abc0:	2b8c      	cmp	r3, #140	@ 0x8c
 800abc2:	d80a      	bhi.n	800abda <get_selector_style_prop+0x52>
        inheritable = _lv_style_builtin_prop_flag_lookup_table[prop] & LV_STYLE_PROP_FLAG_INHERITABLE;
 800abc4:	79fb      	ldrb	r3, [r7, #7]
 800abc6:	4a38      	ldr	r2, [pc, #224]	@ (800aca8 <get_selector_style_prop+0x120>)
 800abc8:	5cd3      	ldrb	r3, [r2, r3]
 800abca:	f003 0301 	and.w	r3, r3, #1
 800abce:	2b00      	cmp	r3, #0
 800abd0:	bf14      	ite	ne
 800abd2:	2301      	movne	r3, #1
 800abd4:	2300      	moveq	r3, #0
 800abd6:	76fb      	strb	r3, [r7, #27]
 800abd8:	e010      	b.n	800abfc <get_selector_style_prop+0x74>
    }
    else {
        if(_style_custom_prop_flag_lookup_table != NULL) {
 800abda:	4b34      	ldr	r3, [pc, #208]	@ (800acac <get_selector_style_prop+0x124>)
 800abdc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800abde:	2b00      	cmp	r3, #0
 800abe0:	d00c      	beq.n	800abfc <get_selector_style_prop+0x74>
            inheritable = _style_custom_prop_flag_lookup_table[prop - _LV_STYLE_NUM_BUILT_IN_PROPS] &
 800abe2:	4b32      	ldr	r3, [pc, #200]	@ (800acac <get_selector_style_prop+0x124>)
 800abe4:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800abe6:	79fb      	ldrb	r3, [r7, #7]
 800abe8:	3b8d      	subs	r3, #141	@ 0x8d
 800abea:	4413      	add	r3, r2
 800abec:	781b      	ldrb	r3, [r3, #0]
 800abee:	f003 0301 	and.w	r3, r3, #1
 800abf2:	2b00      	cmp	r3, #0
 800abf4:	bf14      	ite	ne
 800abf6:	2301      	movne	r3, #1
 800abf8:	2300      	moveq	r3, #0
 800abfa:	76fb      	strb	r3, [r7, #27]
                          LV_STYLE_PROP_FLAG_INHERITABLE;
        }
    }

    if(inheritable) {
 800abfc:	7efb      	ldrb	r3, [r7, #27]
 800abfe:	2b00      	cmp	r3, #0
 800ac00:	d023      	beq.n	800ac4a <get_selector_style_prop+0xc2>
        /*If not found, check the `MAIN` style first, if already on the MAIN part go to the parent*/
        if(part != LV_PART_MAIN) part = LV_PART_MAIN;
 800ac02:	69fb      	ldr	r3, [r7, #28]
 800ac04:	2b00      	cmp	r3, #0
 800ac06:	d002      	beq.n	800ac0e <get_selector_style_prop+0x86>
 800ac08:	2300      	movs	r3, #0
 800ac0a:	61fb      	str	r3, [r7, #28]
 800ac0c:	e019      	b.n	800ac42 <get_selector_style_prop+0xba>
        else obj = obj->parent;
 800ac0e:	68fb      	ldr	r3, [r7, #12]
 800ac10:	685b      	ldr	r3, [r3, #4]
 800ac12:	60fb      	str	r3, [r7, #12]

        while(obj) {
 800ac14:	e015      	b.n	800ac42 <get_selector_style_prop+0xba>
#if LV_OBJ_STYLE_CACHE
            if(obj->style_main_prop_is_set & prop_shifted)
#endif
            {
                selector = part | obj->state;
 800ac16:	68fb      	ldr	r3, [r7, #12]
 800ac18:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800ac1a:	461a      	mov	r2, r3
 800ac1c:	69fb      	ldr	r3, [r7, #28]
 800ac1e:	4313      	orrs	r3, r2
 800ac20:	60bb      	str	r3, [r7, #8]
                found = get_prop_core(obj, selector, prop, value_act);
 800ac22:	79fa      	ldrb	r2, [r7, #7]
 800ac24:	683b      	ldr	r3, [r7, #0]
 800ac26:	68b9      	ldr	r1, [r7, #8]
 800ac28:	68f8      	ldr	r0, [r7, #12]
 800ac2a:	f7ff fb45 	bl	800a2b8 <get_prop_core>
 800ac2e:	4603      	mov	r3, r0
 800ac30:	74fb      	strb	r3, [r7, #19]
                if(found == LV_STYLE_RES_FOUND) return LV_STYLE_RES_FOUND;
 800ac32:	7cfb      	ldrb	r3, [r7, #19]
 800ac34:	2b01      	cmp	r3, #1
 800ac36:	d101      	bne.n	800ac3c <get_selector_style_prop+0xb4>
 800ac38:	2301      	movs	r3, #1
 800ac3a:	e031      	b.n	800aca0 <get_selector_style_prop+0x118>
            }
            /*Check the parent too.*/
            obj = obj->parent;
 800ac3c:	68fb      	ldr	r3, [r7, #12]
 800ac3e:	685b      	ldr	r3, [r3, #4]
 800ac40:	60fb      	str	r3, [r7, #12]
        while(obj) {
 800ac42:	68fb      	ldr	r3, [r7, #12]
 800ac44:	2b00      	cmp	r3, #0
 800ac46:	d1e6      	bne.n	800ac16 <get_selector_style_prop+0x8e>
 800ac48:	e029      	b.n	800ac9e <get_selector_style_prop+0x116>
        }
    }
    else {
        /*Get the width and height from the class.
                * WIDTH and HEIGHT are not inherited so add them in the `else` to skip checking them for inherited properties */
        if(part == LV_PART_MAIN && (prop == LV_STYLE_WIDTH || prop == LV_STYLE_HEIGHT)) {
 800ac4a:	69fb      	ldr	r3, [r7, #28]
 800ac4c:	2b00      	cmp	r3, #0
 800ac4e:	d126      	bne.n	800ac9e <get_selector_style_prop+0x116>
 800ac50:	79fb      	ldrb	r3, [r7, #7]
 800ac52:	2b01      	cmp	r3, #1
 800ac54:	d002      	beq.n	800ac5c <get_selector_style_prop+0xd4>
 800ac56:	79fb      	ldrb	r3, [r7, #7]
 800ac58:	2b02      	cmp	r3, #2
 800ac5a:	d120      	bne.n	800ac9e <get_selector_style_prop+0x116>
            const lv_obj_class_t * cls = obj->class_p;
 800ac5c:	68fb      	ldr	r3, [r7, #12]
 800ac5e:	681b      	ldr	r3, [r3, #0]
 800ac60:	617b      	str	r3, [r7, #20]
            while(cls) {
 800ac62:	e019      	b.n	800ac98 <get_selector_style_prop+0x110>
                if(prop == LV_STYLE_WIDTH) {
 800ac64:	79fb      	ldrb	r3, [r7, #7]
 800ac66:	2b01      	cmp	r3, #1
 800ac68:	d109      	bne.n	800ac7e <get_selector_style_prop+0xf6>
                    if(cls->width_def != 0)  {
 800ac6a:	697b      	ldr	r3, [r7, #20]
 800ac6c:	699b      	ldr	r3, [r3, #24]
 800ac6e:	2b00      	cmp	r3, #0
 800ac70:	d00f      	beq.n	800ac92 <get_selector_style_prop+0x10a>
                        value_act->num = cls->width_def;
 800ac72:	697b      	ldr	r3, [r7, #20]
 800ac74:	699a      	ldr	r2, [r3, #24]
 800ac76:	683b      	ldr	r3, [r7, #0]
 800ac78:	601a      	str	r2, [r3, #0]
                        return LV_STYLE_RES_FOUND;
 800ac7a:	2301      	movs	r3, #1
 800ac7c:	e010      	b.n	800aca0 <get_selector_style_prop+0x118>
                    }
                }
                else {
                    if(cls->height_def != 0) {
 800ac7e:	697b      	ldr	r3, [r7, #20]
 800ac80:	69db      	ldr	r3, [r3, #28]
 800ac82:	2b00      	cmp	r3, #0
 800ac84:	d005      	beq.n	800ac92 <get_selector_style_prop+0x10a>
                        value_act->num = cls->height_def;
 800ac86:	697b      	ldr	r3, [r7, #20]
 800ac88:	69da      	ldr	r2, [r3, #28]
 800ac8a:	683b      	ldr	r3, [r7, #0]
 800ac8c:	601a      	str	r2, [r3, #0]
                        return LV_STYLE_RES_FOUND;
 800ac8e:	2301      	movs	r3, #1
 800ac90:	e006      	b.n	800aca0 <get_selector_style_prop+0x118>
                    }
                }
                cls = cls->base_class;
 800ac92:	697b      	ldr	r3, [r7, #20]
 800ac94:	681b      	ldr	r3, [r3, #0]
 800ac96:	617b      	str	r3, [r7, #20]
            while(cls) {
 800ac98:	697b      	ldr	r3, [r7, #20]
 800ac9a:	2b00      	cmp	r3, #0
 800ac9c:	d1e2      	bne.n	800ac64 <get_selector_style_prop+0xdc>
            }
        }
    }

    return LV_STYLE_RES_NOT_FOUND;
 800ac9e:	2300      	movs	r3, #0
}
 800aca0:	4618      	mov	r0, r3
 800aca2:	3720      	adds	r7, #32
 800aca4:	46bd      	mov	sp, r7
 800aca6:	bd80      	pop	{r7, pc}
 800aca8:	0802b26c 	.word	0x0802b26c
 800acac:	2000009c 	.word	0x2000009c

0800acb0 <lv_obj_set_style_x>:
    };
    lv_obj_set_local_style_prop(obj, LV_STYLE_LENGTH, v, selector);
}

void lv_obj_set_style_x(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
{
 800acb0:	b580      	push	{r7, lr}
 800acb2:	b086      	sub	sp, #24
 800acb4:	af00      	add	r7, sp, #0
 800acb6:	60f8      	str	r0, [r7, #12]
 800acb8:	60b9      	str	r1, [r7, #8]
 800acba:	607a      	str	r2, [r7, #4]
    lv_style_value_t v = {
 800acbc:	68bb      	ldr	r3, [r7, #8]
 800acbe:	617b      	str	r3, [r7, #20]
        .num = (int32_t)value
    };
    lv_obj_set_local_style_prop(obj, LV_STYLE_X, v, selector);
 800acc0:	687b      	ldr	r3, [r7, #4]
 800acc2:	697a      	ldr	r2, [r7, #20]
 800acc4:	2108      	movs	r1, #8
 800acc6:	68f8      	ldr	r0, [r7, #12]
 800acc8:	f7fe fd5c 	bl	8009784 <lv_obj_set_local_style_prop>
}
 800accc:	bf00      	nop
 800acce:	3718      	adds	r7, #24
 800acd0:	46bd      	mov	sp, r7
 800acd2:	bd80      	pop	{r7, pc}

0800acd4 <lv_obj_set_style_y>:

void lv_obj_set_style_y(lv_obj_t * obj, int32_t value, lv_style_selector_t selector)
{
 800acd4:	b580      	push	{r7, lr}
 800acd6:	b086      	sub	sp, #24
 800acd8:	af00      	add	r7, sp, #0
 800acda:	60f8      	str	r0, [r7, #12]
 800acdc:	60b9      	str	r1, [r7, #8]
 800acde:	607a      	str	r2, [r7, #4]
    lv_style_value_t v = {
 800ace0:	68bb      	ldr	r3, [r7, #8]
 800ace2:	617b      	str	r3, [r7, #20]
        .num = (int32_t)value
    };
    lv_obj_set_local_style_prop(obj, LV_STYLE_Y, v, selector);
 800ace4:	687b      	ldr	r3, [r7, #4]
 800ace6:	697a      	ldr	r2, [r7, #20]
 800ace8:	2109      	movs	r1, #9
 800acea:	68f8      	ldr	r0, [r7, #12]
 800acec:	f7fe fd4a 	bl	8009784 <lv_obj_set_local_style_prop>
}
 800acf0:	bf00      	nop
 800acf2:	3718      	adds	r7, #24
 800acf4:	46bd      	mov	sp, r7
 800acf6:	bd80      	pop	{r7, pc}

0800acf8 <lv_obj_set_style_align>:

void lv_obj_set_style_align(lv_obj_t * obj, lv_align_t value, lv_style_selector_t selector)
{
 800acf8:	b580      	push	{r7, lr}
 800acfa:	b086      	sub	sp, #24
 800acfc:	af00      	add	r7, sp, #0
 800acfe:	60f8      	str	r0, [r7, #12]
 800ad00:	460b      	mov	r3, r1
 800ad02:	607a      	str	r2, [r7, #4]
 800ad04:	72fb      	strb	r3, [r7, #11]
    lv_style_value_t v = {
        .num = (int32_t)value
 800ad06:	7afb      	ldrb	r3, [r7, #11]
    lv_style_value_t v = {
 800ad08:	617b      	str	r3, [r7, #20]
    };
    lv_obj_set_local_style_prop(obj, LV_STYLE_ALIGN, v, selector);
 800ad0a:	687b      	ldr	r3, [r7, #4]
 800ad0c:	697a      	ldr	r2, [r7, #20]
 800ad0e:	210a      	movs	r1, #10
 800ad10:	68f8      	ldr	r0, [r7, #12]
 800ad12:	f7fe fd37 	bl	8009784 <lv_obj_set_local_style_prop>
}
 800ad16:	bf00      	nop
 800ad18:	3718      	adds	r7, #24
 800ad1a:	46bd      	mov	sp, r7
 800ad1c:	bd80      	pop	{r7, pc}

0800ad1e <lv_obj_set_style_bg_color>:
    };
    lv_obj_set_local_style_prop(obj, LV_STYLE_MARGIN_RIGHT, v, selector);
}

void lv_obj_set_style_bg_color(lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)
{
 800ad1e:	b580      	push	{r7, lr}
 800ad20:	b086      	sub	sp, #24
 800ad22:	af00      	add	r7, sp, #0
 800ad24:	60f8      	str	r0, [r7, #12]
 800ad26:	60b9      	str	r1, [r7, #8]
 800ad28:	607a      	str	r2, [r7, #4]
    lv_style_value_t v = {
 800ad2a:	2300      	movs	r3, #0
 800ad2c:	617b      	str	r3, [r7, #20]
 800ad2e:	f107 0314 	add.w	r3, r7, #20
 800ad32:	f107 0208 	add.w	r2, r7, #8
 800ad36:	6812      	ldr	r2, [r2, #0]
 800ad38:	4611      	mov	r1, r2
 800ad3a:	8019      	strh	r1, [r3, #0]
 800ad3c:	3302      	adds	r3, #2
 800ad3e:	0c12      	lsrs	r2, r2, #16
 800ad40:	701a      	strb	r2, [r3, #0]
        .color = value
    };
    lv_obj_set_local_style_prop(obj, LV_STYLE_BG_COLOR, v, selector);
 800ad42:	687b      	ldr	r3, [r7, #4]
 800ad44:	697a      	ldr	r2, [r7, #20]
 800ad46:	211c      	movs	r1, #28
 800ad48:	68f8      	ldr	r0, [r7, #12]
 800ad4a:	f7fe fd1b 	bl	8009784 <lv_obj_set_local_style_prop>
}
 800ad4e:	bf00      	nop
 800ad50:	3718      	adds	r7, #24
 800ad52:	46bd      	mov	sp, r7
 800ad54:	bd80      	pop	{r7, pc}

0800ad56 <lv_obj_set_style_text_color>:
    };
    lv_obj_set_local_style_prop(obj, LV_STYLE_ARC_IMAGE_SRC, v, selector);
}

void lv_obj_set_style_text_color(lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector)
{
 800ad56:	b580      	push	{r7, lr}
 800ad58:	b086      	sub	sp, #24
 800ad5a:	af00      	add	r7, sp, #0
 800ad5c:	60f8      	str	r0, [r7, #12]
 800ad5e:	60b9      	str	r1, [r7, #8]
 800ad60:	607a      	str	r2, [r7, #4]
    lv_style_value_t v = {
 800ad62:	2300      	movs	r3, #0
 800ad64:	617b      	str	r3, [r7, #20]
 800ad66:	f107 0314 	add.w	r3, r7, #20
 800ad6a:	f107 0208 	add.w	r2, r7, #8
 800ad6e:	6812      	ldr	r2, [r2, #0]
 800ad70:	4611      	mov	r1, r2
 800ad72:	8019      	strh	r1, [r3, #0]
 800ad74:	3302      	adds	r3, #2
 800ad76:	0c12      	lsrs	r2, r2, #16
 800ad78:	701a      	strb	r2, [r3, #0]
        .color = value
    };
    lv_obj_set_local_style_prop(obj, LV_STYLE_TEXT_COLOR, v, selector);
 800ad7a:	687b      	ldr	r3, [r7, #4]
 800ad7c:	697a      	ldr	r2, [r7, #20]
 800ad7e:	2158      	movs	r1, #88	@ 0x58
 800ad80:	68f8      	ldr	r0, [r7, #12]
 800ad82:	f7fe fcff 	bl	8009784 <lv_obj_set_local_style_prop>
}
 800ad86:	bf00      	nop
 800ad88:	3718      	adds	r7, #24
 800ad8a:	46bd      	mov	sp, r7
 800ad8c:	bd80      	pop	{r7, pc}

0800ad8e <lv_obj_get_screen>:
    }
    lv_group_swap_obj(obj1, obj2);
}

lv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)
{
 800ad8e:	b580      	push	{r7, lr}
 800ad90:	b084      	sub	sp, #16
 800ad92:	af00      	add	r7, sp, #0
 800ad94:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    const lv_obj_t * par = obj;
 800ad96:	687b      	ldr	r3, [r7, #4]
 800ad98:	60fb      	str	r3, [r7, #12]
    const lv_obj_t * act_par;

    do {
        act_par = par;
 800ad9a:	68fb      	ldr	r3, [r7, #12]
 800ad9c:	60bb      	str	r3, [r7, #8]
        par = lv_obj_get_parent(act_par);
 800ad9e:	68b8      	ldr	r0, [r7, #8]
 800ada0:	f000 f848 	bl	800ae34 <lv_obj_get_parent>
 800ada4:	60f8      	str	r0, [r7, #12]
    } while(par != NULL);
 800ada6:	68fb      	ldr	r3, [r7, #12]
 800ada8:	2b00      	cmp	r3, #0
 800adaa:	d1f6      	bne.n	800ad9a <lv_obj_get_screen+0xc>

    return (lv_obj_t *)act_par;
 800adac:	68bb      	ldr	r3, [r7, #8]
}
 800adae:	4618      	mov	r0, r3
 800adb0:	3710      	adds	r7, #16
 800adb2:	46bd      	mov	sp, r7
 800adb4:	bd80      	pop	{r7, pc}
	...

0800adb8 <lv_obj_get_display>:

lv_display_t * lv_obj_get_display(const lv_obj_t * obj)
{
 800adb8:	b580      	push	{r7, lr}
 800adba:	b086      	sub	sp, #24
 800adbc:	af00      	add	r7, sp, #0
 800adbe:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    const lv_obj_t * scr;

    if(obj->parent == NULL) scr = obj;  /*`obj` is a screen*/
 800adc0:	687b      	ldr	r3, [r7, #4]
 800adc2:	685b      	ldr	r3, [r3, #4]
 800adc4:	2b00      	cmp	r3, #0
 800adc6:	d102      	bne.n	800adce <lv_obj_get_display+0x16>
 800adc8:	687b      	ldr	r3, [r7, #4]
 800adca:	617b      	str	r3, [r7, #20]
 800adcc:	e003      	b.n	800add6 <lv_obj_get_display+0x1e>
    else scr = lv_obj_get_screen(obj);  /*get the screen of `obj`*/
 800adce:	6878      	ldr	r0, [r7, #4]
 800add0:	f7ff ffdd 	bl	800ad8e <lv_obj_get_screen>
 800add4:	6178      	str	r0, [r7, #20]

    lv_display_t * d;
    lv_ll_t * disp_head = disp_ll_p;
 800add6:	4b16      	ldr	r3, [pc, #88]	@ (800ae30 <lv_obj_get_display+0x78>)
 800add8:	60bb      	str	r3, [r7, #8]
    _LV_LL_READ(disp_head, d) {
 800adda:	68b8      	ldr	r0, [r7, #8]
 800addc:	f018 f9f7 	bl	80231ce <_lv_ll_get_head>
 800ade0:	6138      	str	r0, [r7, #16]
 800ade2:	e01c      	b.n	800ae1e <lv_obj_get_display+0x66>
        uint32_t i;
        for(i = 0; i < d->screen_cnt; i++) {
 800ade4:	2300      	movs	r3, #0
 800ade6:	60fb      	str	r3, [r7, #12]
 800ade8:	e00e      	b.n	800ae08 <lv_obj_get_display+0x50>
            if(d->screens[i] == scr) return d;
 800adea:	693b      	ldr	r3, [r7, #16]
 800adec:	f8d3 22ac 	ldr.w	r2, [r3, #684]	@ 0x2ac
 800adf0:	68fb      	ldr	r3, [r7, #12]
 800adf2:	009b      	lsls	r3, r3, #2
 800adf4:	4413      	add	r3, r2
 800adf6:	681b      	ldr	r3, [r3, #0]
 800adf8:	697a      	ldr	r2, [r7, #20]
 800adfa:	429a      	cmp	r2, r3
 800adfc:	d101      	bne.n	800ae02 <lv_obj_get_display+0x4a>
 800adfe:	693b      	ldr	r3, [r7, #16]
 800ae00:	e011      	b.n	800ae26 <lv_obj_get_display+0x6e>
        for(i = 0; i < d->screen_cnt; i++) {
 800ae02:	68fb      	ldr	r3, [r7, #12]
 800ae04:	3301      	adds	r3, #1
 800ae06:	60fb      	str	r3, [r7, #12]
 800ae08:	693b      	ldr	r3, [r7, #16]
 800ae0a:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 800ae0e:	68fa      	ldr	r2, [r7, #12]
 800ae10:	429a      	cmp	r2, r3
 800ae12:	d3ea      	bcc.n	800adea <lv_obj_get_display+0x32>
    _LV_LL_READ(disp_head, d) {
 800ae14:	6939      	ldr	r1, [r7, #16]
 800ae16:	68b8      	ldr	r0, [r7, #8]
 800ae18:	f018 f9fb 	bl	8023212 <_lv_ll_get_next>
 800ae1c:	6138      	str	r0, [r7, #16]
 800ae1e:	693b      	ldr	r3, [r7, #16]
 800ae20:	2b00      	cmp	r3, #0
 800ae22:	d1df      	bne.n	800ade4 <lv_obj_get_display+0x2c>
        }
    }

    LV_LOG_WARN("No screen found");
    return NULL;
 800ae24:	2300      	movs	r3, #0
}
 800ae26:	4618      	mov	r0, r3
 800ae28:	3718      	adds	r7, #24
 800ae2a:	46bd      	mov	sp, r7
 800ae2c:	bd80      	pop	{r7, pc}
 800ae2e:	bf00      	nop
 800ae30:	200000a0 	.word	0x200000a0

0800ae34 <lv_obj_get_parent>:

lv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)
{
 800ae34:	b480      	push	{r7}
 800ae36:	b083      	sub	sp, #12
 800ae38:	af00      	add	r7, sp, #0
 800ae3a:	6078      	str	r0, [r7, #4]
    if(obj == NULL) return NULL;
 800ae3c:	687b      	ldr	r3, [r7, #4]
 800ae3e:	2b00      	cmp	r3, #0
 800ae40:	d101      	bne.n	800ae46 <lv_obj_get_parent+0x12>
 800ae42:	2300      	movs	r3, #0
 800ae44:	e001      	b.n	800ae4a <lv_obj_get_parent+0x16>
    LV_ASSERT_OBJ(obj, MY_CLASS);

    return obj->parent;
 800ae46:	687b      	ldr	r3, [r7, #4]
 800ae48:	685b      	ldr	r3, [r3, #4]
}
 800ae4a:	4618      	mov	r0, r3
 800ae4c:	370c      	adds	r7, #12
 800ae4e:	46bd      	mov	sp, r7
 800ae50:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ae54:	4770      	bx	lr

0800ae56 <lv_obj_get_child>:

lv_obj_t * lv_obj_get_child(const lv_obj_t * obj, int32_t idx)
{
 800ae56:	b480      	push	{r7}
 800ae58:	b085      	sub	sp, #20
 800ae5a:	af00      	add	r7, sp, #0
 800ae5c:	6078      	str	r0, [r7, #4]
 800ae5e:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    if(obj->spec_attr == NULL) return NULL;
 800ae60:	687b      	ldr	r3, [r7, #4]
 800ae62:	689b      	ldr	r3, [r3, #8]
 800ae64:	2b00      	cmp	r3, #0
 800ae66:	d101      	bne.n	800ae6c <lv_obj_get_child+0x16>
 800ae68:	2300      	movs	r3, #0
 800ae6a:	e023      	b.n	800aeb4 <lv_obj_get_child+0x5e>

    uint32_t idu;
    if(idx < 0) {
 800ae6c:	683b      	ldr	r3, [r7, #0]
 800ae6e:	2b00      	cmp	r3, #0
 800ae70:	da0e      	bge.n	800ae90 <lv_obj_get_child+0x3a>
        idx = obj->spec_attr->child_cnt + idx;
 800ae72:	687b      	ldr	r3, [r7, #4]
 800ae74:	689b      	ldr	r3, [r3, #8]
 800ae76:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800ae78:	461a      	mov	r2, r3
 800ae7a:	683b      	ldr	r3, [r7, #0]
 800ae7c:	4413      	add	r3, r2
 800ae7e:	603b      	str	r3, [r7, #0]
        if(idx < 0) return NULL;
 800ae80:	683b      	ldr	r3, [r7, #0]
 800ae82:	2b00      	cmp	r3, #0
 800ae84:	da01      	bge.n	800ae8a <lv_obj_get_child+0x34>
 800ae86:	2300      	movs	r3, #0
 800ae88:	e014      	b.n	800aeb4 <lv_obj_get_child+0x5e>
        idu = (uint32_t) idx;
 800ae8a:	683b      	ldr	r3, [r7, #0]
 800ae8c:	60fb      	str	r3, [r7, #12]
 800ae8e:	e001      	b.n	800ae94 <lv_obj_get_child+0x3e>
    }
    else {
        idu = idx;
 800ae90:	683b      	ldr	r3, [r7, #0]
 800ae92:	60fb      	str	r3, [r7, #12]
    }

    if(idu >= obj->spec_attr->child_cnt) return NULL;
 800ae94:	687b      	ldr	r3, [r7, #4]
 800ae96:	689b      	ldr	r3, [r3, #8]
 800ae98:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800ae9a:	461a      	mov	r2, r3
 800ae9c:	68fb      	ldr	r3, [r7, #12]
 800ae9e:	4293      	cmp	r3, r2
 800aea0:	d301      	bcc.n	800aea6 <lv_obj_get_child+0x50>
 800aea2:	2300      	movs	r3, #0
 800aea4:	e006      	b.n	800aeb4 <lv_obj_get_child+0x5e>
    else return obj->spec_attr->children[idx];
 800aea6:	687b      	ldr	r3, [r7, #4]
 800aea8:	689b      	ldr	r3, [r3, #8]
 800aeaa:	681a      	ldr	r2, [r3, #0]
 800aeac:	683b      	ldr	r3, [r7, #0]
 800aeae:	009b      	lsls	r3, r3, #2
 800aeb0:	4413      	add	r3, r2
 800aeb2:	681b      	ldr	r3, [r3, #0]
}
 800aeb4:	4618      	mov	r0, r3
 800aeb6:	3714      	adds	r7, #20
 800aeb8:	46bd      	mov	sp, r7
 800aeba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aebe:	4770      	bx	lr

0800aec0 <lv_obj_get_child_count>:

    return lv_obj_get_child(parent, sibling_idx);
}

uint32_t lv_obj_get_child_count(const lv_obj_t * obj)
{
 800aec0:	b480      	push	{r7}
 800aec2:	b083      	sub	sp, #12
 800aec4:	af00      	add	r7, sp, #0
 800aec6:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);
    if(obj->spec_attr == NULL) return 0;
 800aec8:	687b      	ldr	r3, [r7, #4]
 800aeca:	689b      	ldr	r3, [r3, #8]
 800aecc:	2b00      	cmp	r3, #0
 800aece:	d101      	bne.n	800aed4 <lv_obj_get_child_count+0x14>
 800aed0:	2300      	movs	r3, #0
 800aed2:	e002      	b.n	800aeda <lv_obj_get_child_count+0x1a>
    return obj->spec_attr->child_cnt;
 800aed4:	687b      	ldr	r3, [r7, #4]
 800aed6:	689b      	ldr	r3, [r3, #8]
 800aed8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
}
 800aeda:	4618      	mov	r0, r3
 800aedc:	370c      	adds	r7, #12
 800aede:	46bd      	mov	sp, r7
 800aee0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aee4:	4770      	bx	lr

0800aee6 <lv_area_copy>:
{
 800aee6:	b480      	push	{r7}
 800aee8:	b083      	sub	sp, #12
 800aeea:	af00      	add	r7, sp, #0
 800aeec:	6078      	str	r0, [r7, #4]
 800aeee:	6039      	str	r1, [r7, #0]
    dest->x1 = src->x1;
 800aef0:	683b      	ldr	r3, [r7, #0]
 800aef2:	681a      	ldr	r2, [r3, #0]
 800aef4:	687b      	ldr	r3, [r7, #4]
 800aef6:	601a      	str	r2, [r3, #0]
    dest->y1 = src->y1;
 800aef8:	683b      	ldr	r3, [r7, #0]
 800aefa:	685a      	ldr	r2, [r3, #4]
 800aefc:	687b      	ldr	r3, [r7, #4]
 800aefe:	605a      	str	r2, [r3, #4]
    dest->x2 = src->x2;
 800af00:	683b      	ldr	r3, [r7, #0]
 800af02:	689a      	ldr	r2, [r3, #8]
 800af04:	687b      	ldr	r3, [r7, #4]
 800af06:	609a      	str	r2, [r3, #8]
    dest->y2 = src->y2;
 800af08:	683b      	ldr	r3, [r7, #0]
 800af0a:	68da      	ldr	r2, [r3, #12]
 800af0c:	687b      	ldr	r3, [r7, #4]
 800af0e:	60da      	str	r2, [r3, #12]
}
 800af10:	bf00      	nop
 800af12:	370c      	adds	r7, #12
 800af14:	46bd      	mov	sp, r7
 800af16:	f85d 7b04 	ldr.w	r7, [sp], #4
 800af1a:	4770      	bx	lr

0800af1c <_lv_refr_init>:

/**
 * Initialize the screen refresh subsystem
 */
void _lv_refr_init(void)
{
 800af1c:	b480      	push	{r7}
 800af1e:	af00      	add	r7, sp, #0
}
 800af20:	bf00      	nop
 800af22:	46bd      	mov	sp, r7
 800af24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800af28:	4770      	bx	lr

0800af2a <_lv_inv_area>:

    layer->_clip_area = clip_area_ori;
}

void _lv_inv_area(lv_display_t * disp, const lv_area_t * area_p)
{
 800af2a:	b590      	push	{r4, r7, lr}
 800af2c:	b08f      	sub	sp, #60	@ 0x3c
 800af2e:	af00      	add	r7, sp, #0
 800af30:	6078      	str	r0, [r7, #4]
 800af32:	6039      	str	r1, [r7, #0]
    if(!disp) disp = lv_display_get_default();
 800af34:	687b      	ldr	r3, [r7, #4]
 800af36:	2b00      	cmp	r3, #0
 800af38:	d102      	bne.n	800af40 <_lv_inv_area+0x16>
 800af3a:	f000 f8d1 	bl	800b0e0 <lv_display_get_default>
 800af3e:	6078      	str	r0, [r7, #4]
    if(!disp) return;
 800af40:	687b      	ldr	r3, [r7, #4]
 800af42:	2b00      	cmp	r3, #0
 800af44:	f000 80a6 	beq.w	800b094 <_lv_inv_area+0x16a>
    if(!lv_display_is_invalidation_enabled(disp)) return;
 800af48:	6878      	ldr	r0, [r7, #4]
 800af4a:	f000 fa1c 	bl	800b386 <lv_display_is_invalidation_enabled>
 800af4e:	4603      	mov	r3, r0
 800af50:	f083 0301 	eor.w	r3, r3, #1
 800af54:	b2db      	uxtb	r3, r3
 800af56:	2b00      	cmp	r3, #0
 800af58:	f040 809e 	bne.w	800b098 <_lv_inv_area+0x16e>

    LV_ASSERT_MSG(!disp->rendering_in_progress, "Invalidate area is not allowed during rendering.");
 800af5c:	687b      	ldr	r3, [r7, #4]
 800af5e:	f893 303a 	ldrb.w	r3, [r3, #58]	@ 0x3a
 800af62:	f003 0302 	and.w	r3, r3, #2
 800af66:	b2db      	uxtb	r3, r3
 800af68:	2b00      	cmp	r3, #0
 800af6a:	d001      	beq.n	800af70 <_lv_inv_area+0x46>
 800af6c:	bf00      	nop
 800af6e:	e7fd      	b.n	800af6c <_lv_inv_area+0x42>

    /*Clear the invalidate buffer if the parameter is NULL*/
    if(area_p == NULL) {
 800af70:	683b      	ldr	r3, [r7, #0]
 800af72:	2b00      	cmp	r3, #0
 800af74:	d104      	bne.n	800af80 <_lv_inv_area+0x56>
        disp->inv_p = 0;
 800af76:	687b      	ldr	r3, [r7, #4]
 800af78:	2200      	movs	r2, #0
 800af7a:	f8c3 225c 	str.w	r2, [r3, #604]	@ 0x25c
        return;
 800af7e:	e092      	b.n	800b0a6 <_lv_inv_area+0x17c>
    }

    lv_area_t scr_area;
    scr_area.x1 = 0;
 800af80:	2300      	movs	r3, #0
 800af82:	61fb      	str	r3, [r7, #28]
    scr_area.y1 = 0;
 800af84:	2300      	movs	r3, #0
 800af86:	623b      	str	r3, [r7, #32]
    scr_area.x2 = lv_display_get_horizontal_resolution(disp) - 1;
 800af88:	6878      	ldr	r0, [r7, #4]
 800af8a:	f000 f8cd 	bl	800b128 <lv_display_get_horizontal_resolution>
 800af8e:	4603      	mov	r3, r0
 800af90:	3b01      	subs	r3, #1
 800af92:	627b      	str	r3, [r7, #36]	@ 0x24
    scr_area.y2 = lv_display_get_vertical_resolution(disp) - 1;
 800af94:	6878      	ldr	r0, [r7, #4]
 800af96:	f000 f8e9 	bl	800b16c <lv_display_get_vertical_resolution>
 800af9a:	4603      	mov	r3, r0
 800af9c:	3b01      	subs	r3, #1
 800af9e:	62bb      	str	r3, [r7, #40]	@ 0x28

    lv_area_t com_area;
    bool suc;

    suc = _lv_area_intersect(&com_area, area_p, &scr_area);
 800afa0:	f107 021c 	add.w	r2, r7, #28
 800afa4:	f107 030c 	add.w	r3, r7, #12
 800afa8:	6839      	ldr	r1, [r7, #0]
 800afaa:	4618      	mov	r0, r3
 800afac:	f016 fccc 	bl	8021948 <_lv_area_intersect>
 800afb0:	4603      	mov	r3, r0
 800afb2:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if(suc == false)  return; /*Out of the screen*/
 800afb6:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800afba:	f083 0301 	eor.w	r3, r3, #1
 800afbe:	b2db      	uxtb	r3, r3
 800afc0:	2b00      	cmp	r3, #0
 800afc2:	d16b      	bne.n	800b09c <_lv_inv_area+0x172>

    /*If there were at least 1 invalid area in full refresh mode, redraw the whole screen*/
    if(disp->render_mode == LV_DISPLAY_RENDER_MODE_FULL) {
 800afc4:	687b      	ldr	r3, [r7, #4]
 800afc6:	f893 3039 	ldrb.w	r3, [r3, #57]	@ 0x39
 800afca:	2b02      	cmp	r3, #2
 800afcc:	d111      	bne.n	800aff2 <_lv_inv_area+0xc8>
        disp->inv_areas[0] = scr_area;
 800afce:	687b      	ldr	r3, [r7, #4]
 800afd0:	f103 043c 	add.w	r4, r3, #60	@ 0x3c
 800afd4:	f107 031c 	add.w	r3, r7, #28
 800afd8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800afda:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        disp->inv_p = 1;
 800afde:	687b      	ldr	r3, [r7, #4]
 800afe0:	2201      	movs	r2, #1
 800afe2:	f8c3 225c 	str.w	r2, [r3, #604]	@ 0x25c
        lv_display_send_event(disp, LV_EVENT_REFR_REQUEST, NULL);
 800afe6:	2200      	movs	r2, #0
 800afe8:	2132      	movs	r1, #50	@ 0x32
 800afea:	6878      	ldr	r0, [r7, #4]
 800afec:	f000 f979 	bl	800b2e2 <lv_display_send_event>
        return;
 800aff0:	e059      	b.n	800b0a6 <_lv_inv_area+0x17c>
    }

    lv_result_t res = lv_display_send_event(disp, LV_EVENT_INVALIDATE_AREA, &com_area);
 800aff2:	f107 030c 	add.w	r3, r7, #12
 800aff6:	461a      	mov	r2, r3
 800aff8:	212f      	movs	r1, #47	@ 0x2f
 800affa:	6878      	ldr	r0, [r7, #4]
 800affc:	f000 f971 	bl	800b2e2 <lv_display_send_event>
 800b000:	4603      	mov	r3, r0
 800b002:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
    if(res != LV_RESULT_OK) return;
 800b006:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 800b00a:	2b01      	cmp	r3, #1
 800b00c:	d148      	bne.n	800b0a0 <_lv_inv_area+0x176>

    /*Save only if this area is not in one of the saved areas*/
    uint16_t i;
    for(i = 0; i < disp->inv_p; i++) {
 800b00e:	2300      	movs	r3, #0
 800b010:	86fb      	strh	r3, [r7, #54]	@ 0x36
 800b012:	e011      	b.n	800b038 <_lv_inv_area+0x10e>
        if(_lv_area_is_in(&com_area, &disp->inv_areas[i], 0) != false) return;
 800b014:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 800b016:	011b      	lsls	r3, r3, #4
 800b018:	3338      	adds	r3, #56	@ 0x38
 800b01a:	687a      	ldr	r2, [r7, #4]
 800b01c:	4413      	add	r3, r2
 800b01e:	1d19      	adds	r1, r3, #4
 800b020:	f107 030c 	add.w	r3, r7, #12
 800b024:	2200      	movs	r2, #0
 800b026:	4618      	mov	r0, r3
 800b028:	f016 fdb2 	bl	8021b90 <_lv_area_is_in>
 800b02c:	4603      	mov	r3, r0
 800b02e:	2b00      	cmp	r3, #0
 800b030:	d138      	bne.n	800b0a4 <_lv_inv_area+0x17a>
    for(i = 0; i < disp->inv_p; i++) {
 800b032:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 800b034:	3301      	adds	r3, #1
 800b036:	86fb      	strh	r3, [r7, #54]	@ 0x36
 800b038:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 800b03a:	687b      	ldr	r3, [r7, #4]
 800b03c:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
 800b040:	429a      	cmp	r2, r3
 800b042:	d3e7      	bcc.n	800b014 <_lv_inv_area+0xea>
    }

    /*Save the area*/
    lv_area_t * tmp_area_p = &com_area;
 800b044:	f107 030c 	add.w	r3, r7, #12
 800b048:	633b      	str	r3, [r7, #48]	@ 0x30
    if(disp->inv_p >= LV_INV_BUF_SIZE) { /*If no place for the area add the screen*/
 800b04a:	687b      	ldr	r3, [r7, #4]
 800b04c:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
 800b050:	2b1f      	cmp	r3, #31
 800b052:	d906      	bls.n	800b062 <_lv_inv_area+0x138>
        disp->inv_p = 0;
 800b054:	687b      	ldr	r3, [r7, #4]
 800b056:	2200      	movs	r2, #0
 800b058:	f8c3 225c 	str.w	r2, [r3, #604]	@ 0x25c
        tmp_area_p = &scr_area;
 800b05c:	f107 031c 	add.w	r3, r7, #28
 800b060:	633b      	str	r3, [r7, #48]	@ 0x30
    }
    lv_area_copy(&disp->inv_areas[disp->inv_p], tmp_area_p);
 800b062:	687b      	ldr	r3, [r7, #4]
 800b064:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
 800b068:	011b      	lsls	r3, r3, #4
 800b06a:	3338      	adds	r3, #56	@ 0x38
 800b06c:	687a      	ldr	r2, [r7, #4]
 800b06e:	4413      	add	r3, r2
 800b070:	3304      	adds	r3, #4
 800b072:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 800b074:	4618      	mov	r0, r3
 800b076:	f7ff ff36 	bl	800aee6 <lv_area_copy>
    disp->inv_p++;
 800b07a:	687b      	ldr	r3, [r7, #4]
 800b07c:	f8d3 325c 	ldr.w	r3, [r3, #604]	@ 0x25c
 800b080:	1c5a      	adds	r2, r3, #1
 800b082:	687b      	ldr	r3, [r7, #4]
 800b084:	f8c3 225c 	str.w	r2, [r3, #604]	@ 0x25c

    lv_display_send_event(disp, LV_EVENT_REFR_REQUEST, NULL);
 800b088:	2200      	movs	r2, #0
 800b08a:	2132      	movs	r1, #50	@ 0x32
 800b08c:	6878      	ldr	r0, [r7, #4]
 800b08e:	f000 f928 	bl	800b2e2 <lv_display_send_event>
 800b092:	e008      	b.n	800b0a6 <_lv_inv_area+0x17c>
    if(!disp) return;
 800b094:	bf00      	nop
 800b096:	e006      	b.n	800b0a6 <_lv_inv_area+0x17c>
    if(!lv_display_is_invalidation_enabled(disp)) return;
 800b098:	bf00      	nop
 800b09a:	e004      	b.n	800b0a6 <_lv_inv_area+0x17c>
    if(suc == false)  return; /*Out of the screen*/
 800b09c:	bf00      	nop
 800b09e:	e002      	b.n	800b0a6 <_lv_inv_area+0x17c>
    if(res != LV_RESULT_OK) return;
 800b0a0:	bf00      	nop
 800b0a2:	e000      	b.n	800b0a6 <_lv_inv_area+0x17c>
        if(_lv_area_is_in(&com_area, &disp->inv_areas[i], 0) != false) return;
 800b0a4:	bf00      	nop
}
 800b0a6:	373c      	adds	r7, #60	@ 0x3c
 800b0a8:	46bd      	mov	sp, r7
 800b0aa:	bd90      	pop	{r4, r7, pc}

0800b0ac <_lv_refr_get_disp_refreshing>:
/**
 * Get the display which is being refreshed
 * @return the display being refreshed
 */
lv_display_t * _lv_refr_get_disp_refreshing(void)
{
 800b0ac:	b480      	push	{r7}
 800b0ae:	af00      	add	r7, sp, #0
    return disp_refr;
 800b0b0:	4b03      	ldr	r3, [pc, #12]	@ (800b0c0 <_lv_refr_get_disp_refreshing+0x14>)
 800b0b2:	691b      	ldr	r3, [r3, #16]
}
 800b0b4:	4618      	mov	r0, r3
 800b0b6:	46bd      	mov	sp, r7
 800b0b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b0bc:	4770      	bx	lr
 800b0be:	bf00      	nop
 800b0c0:	2000009c 	.word	0x2000009c

0800b0c4 <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 800b0c4:	b580      	push	{r7, lr}
 800b0c6:	b082      	sub	sp, #8
 800b0c8:	af00      	add	r7, sp, #0
 800b0ca:	6078      	str	r0, [r7, #4]
 800b0cc:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 800b0ce:	683a      	ldr	r2, [r7, #0]
 800b0d0:	2100      	movs	r1, #0
 800b0d2:	6878      	ldr	r0, [r7, #4]
 800b0d4:	f019 fea5 	bl	8024e22 <lv_memset>
}
 800b0d8:	bf00      	nop
 800b0da:	3708      	adds	r7, #8
 800b0dc:	46bd      	mov	sp, r7
 800b0de:	bd80      	pop	{r7, pc}

0800b0e0 <lv_display_get_default>:
{
    disp_def = disp;
}

lv_display_t * lv_display_get_default(void)
{
 800b0e0:	b480      	push	{r7}
 800b0e2:	af00      	add	r7, sp, #0
    return disp_def;
 800b0e4:	4b03      	ldr	r3, [pc, #12]	@ (800b0f4 <lv_display_get_default+0x14>)
 800b0e6:	695b      	ldr	r3, [r3, #20]
}
 800b0e8:	4618      	mov	r0, r3
 800b0ea:	46bd      	mov	sp, r7
 800b0ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b0f0:	4770      	bx	lr
 800b0f2:	bf00      	nop
 800b0f4:	2000009c 	.word	0x2000009c

0800b0f8 <lv_display_get_next>:

lv_display_t * lv_display_get_next(lv_display_t * disp)
{
 800b0f8:	b580      	push	{r7, lr}
 800b0fa:	b082      	sub	sp, #8
 800b0fc:	af00      	add	r7, sp, #0
 800b0fe:	6078      	str	r0, [r7, #4]
    if(disp == NULL)
 800b100:	687b      	ldr	r3, [r7, #4]
 800b102:	2b00      	cmp	r3, #0
 800b104:	d104      	bne.n	800b110 <lv_display_get_next+0x18>
        return _lv_ll_get_head(disp_ll_p);
 800b106:	4807      	ldr	r0, [pc, #28]	@ (800b124 <lv_display_get_next+0x2c>)
 800b108:	f018 f861 	bl	80231ce <_lv_ll_get_head>
 800b10c:	4603      	mov	r3, r0
 800b10e:	e004      	b.n	800b11a <lv_display_get_next+0x22>
    else
        return _lv_ll_get_next(disp_ll_p, disp);
 800b110:	6879      	ldr	r1, [r7, #4]
 800b112:	4804      	ldr	r0, [pc, #16]	@ (800b124 <lv_display_get_next+0x2c>)
 800b114:	f018 f87d 	bl	8023212 <_lv_ll_get_next>
 800b118:	4603      	mov	r3, r0
}
 800b11a:	4618      	mov	r0, r3
 800b11c:	3708      	adds	r7, #8
 800b11e:	46bd      	mov	sp, r7
 800b120:	bd80      	pop	{r7, pc}
 800b122:	bf00      	nop
 800b124:	200000a0 	.word	0x200000a0

0800b128 <lv_display_get_horizontal_resolution>:

    disp->dpi = dpi;
}

int32_t lv_display_get_horizontal_resolution(const lv_display_t * disp)
{
 800b128:	b580      	push	{r7, lr}
 800b12a:	b082      	sub	sp, #8
 800b12c:	af00      	add	r7, sp, #0
 800b12e:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_display_get_default();
 800b130:	687b      	ldr	r3, [r7, #4]
 800b132:	2b00      	cmp	r3, #0
 800b134:	d102      	bne.n	800b13c <lv_display_get_horizontal_resolution+0x14>
 800b136:	f7ff ffd3 	bl	800b0e0 <lv_display_get_default>
 800b13a:	6078      	str	r0, [r7, #4]

    if(disp == NULL) {
 800b13c:	687b      	ldr	r3, [r7, #4]
 800b13e:	2b00      	cmp	r3, #0
 800b140:	d101      	bne.n	800b146 <lv_display_get_horizontal_resolution+0x1e>
        return 0;
 800b142:	2300      	movs	r3, #0
 800b144:	e00e      	b.n	800b164 <lv_display_get_horizontal_resolution+0x3c>
    }
    else {
        switch(disp->rotation) {
 800b146:	687b      	ldr	r3, [r7, #4]
 800b148:	f893 32e8 	ldrb.w	r3, [r3, #744]	@ 0x2e8
 800b14c:	f3c3 0341 	ubfx	r3, r3, #1, #2
 800b150:	b2db      	uxtb	r3, r3
 800b152:	2b01      	cmp	r3, #1
 800b154:	d001      	beq.n	800b15a <lv_display_get_horizontal_resolution+0x32>
 800b156:	2b03      	cmp	r3, #3
 800b158:	d102      	bne.n	800b160 <lv_display_get_horizontal_resolution+0x38>
            case LV_DISPLAY_ROTATION_90:
            case LV_DISPLAY_ROTATION_270:
                return disp->ver_res;
 800b15a:	687b      	ldr	r3, [r7, #4]
 800b15c:	685b      	ldr	r3, [r3, #4]
 800b15e:	e001      	b.n	800b164 <lv_display_get_horizontal_resolution+0x3c>
            default:
                return disp->hor_res;
 800b160:	687b      	ldr	r3, [r7, #4]
 800b162:	681b      	ldr	r3, [r3, #0]
        }
    }
}
 800b164:	4618      	mov	r0, r3
 800b166:	3708      	adds	r7, #8
 800b168:	46bd      	mov	sp, r7
 800b16a:	bd80      	pop	{r7, pc}

0800b16c <lv_display_get_vertical_resolution>:

int32_t lv_display_get_vertical_resolution(const lv_display_t * disp)
{
 800b16c:	b580      	push	{r7, lr}
 800b16e:	b082      	sub	sp, #8
 800b170:	af00      	add	r7, sp, #0
 800b172:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_display_get_default();
 800b174:	687b      	ldr	r3, [r7, #4]
 800b176:	2b00      	cmp	r3, #0
 800b178:	d102      	bne.n	800b180 <lv_display_get_vertical_resolution+0x14>
 800b17a:	f7ff ffb1 	bl	800b0e0 <lv_display_get_default>
 800b17e:	6078      	str	r0, [r7, #4]

    if(disp == NULL) {
 800b180:	687b      	ldr	r3, [r7, #4]
 800b182:	2b00      	cmp	r3, #0
 800b184:	d101      	bne.n	800b18a <lv_display_get_vertical_resolution+0x1e>
        return 0;
 800b186:	2300      	movs	r3, #0
 800b188:	e00e      	b.n	800b1a8 <lv_display_get_vertical_resolution+0x3c>
    }
    else {
        switch(disp->rotation) {
 800b18a:	687b      	ldr	r3, [r7, #4]
 800b18c:	f893 32e8 	ldrb.w	r3, [r3, #744]	@ 0x2e8
 800b190:	f3c3 0341 	ubfx	r3, r3, #1, #2
 800b194:	b2db      	uxtb	r3, r3
 800b196:	2b01      	cmp	r3, #1
 800b198:	d001      	beq.n	800b19e <lv_display_get_vertical_resolution+0x32>
 800b19a:	2b03      	cmp	r3, #3
 800b19c:	d102      	bne.n	800b1a4 <lv_display_get_vertical_resolution+0x38>
            case LV_DISPLAY_ROTATION_90:
            case LV_DISPLAY_ROTATION_270:
                return disp->hor_res;
 800b19e:	687b      	ldr	r3, [r7, #4]
 800b1a0:	681b      	ldr	r3, [r3, #0]
 800b1a2:	e001      	b.n	800b1a8 <lv_display_get_vertical_resolution+0x3c>
            default:
                return disp->ver_res;
 800b1a4:	687b      	ldr	r3, [r7, #4]
 800b1a6:	685b      	ldr	r3, [r3, #4]
        }
    }
}
 800b1a8:	4618      	mov	r0, r3
 800b1aa:	3708      	adds	r7, #8
 800b1ac:	46bd      	mov	sp, r7
 800b1ae:	bd80      	pop	{r7, pc}

0800b1b0 <lv_display_get_dpi>:
        }
    }
}

int32_t lv_display_get_dpi(const lv_display_t * disp)
{
 800b1b0:	b580      	push	{r7, lr}
 800b1b2:	b082      	sub	sp, #8
 800b1b4:	af00      	add	r7, sp, #0
 800b1b6:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_display_get_default();
 800b1b8:	687b      	ldr	r3, [r7, #4]
 800b1ba:	2b00      	cmp	r3, #0
 800b1bc:	d102      	bne.n	800b1c4 <lv_display_get_dpi+0x14>
 800b1be:	f7ff ff8f 	bl	800b0e0 <lv_display_get_default>
 800b1c2:	6078      	str	r0, [r7, #4]
    if(disp == NULL) return LV_DPI_DEF;  /*Do not return 0 because it might be a divider*/
 800b1c4:	687b      	ldr	r3, [r7, #4]
 800b1c6:	2b00      	cmp	r3, #0
 800b1c8:	d101      	bne.n	800b1ce <lv_display_get_dpi+0x1e>
 800b1ca:	2382      	movs	r3, #130	@ 0x82
 800b1cc:	e001      	b.n	800b1d2 <lv_display_get_dpi+0x22>
    return disp->dpi;
 800b1ce:	687b      	ldr	r3, [r7, #4]
 800b1d0:	699b      	ldr	r3, [r3, #24]
}
 800b1d2:	4618      	mov	r0, r3
 800b1d4:	3708      	adds	r7, #8
 800b1d6:	46bd      	mov	sp, r7
 800b1d8:	bd80      	pop	{r7, pc}

0800b1da <lv_display_get_color_format>:

    lv_display_send_event(disp, LV_EVENT_COLOR_FORMAT_CHANGED, NULL);
}

lv_color_format_t lv_display_get_color_format(lv_display_t * disp)
{
 800b1da:	b580      	push	{r7, lr}
 800b1dc:	b082      	sub	sp, #8
 800b1de:	af00      	add	r7, sp, #0
 800b1e0:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_display_get_default();
 800b1e2:	687b      	ldr	r3, [r7, #4]
 800b1e4:	2b00      	cmp	r3, #0
 800b1e6:	d102      	bne.n	800b1ee <lv_display_get_color_format+0x14>
 800b1e8:	f7ff ff7a 	bl	800b0e0 <lv_display_get_default>
 800b1ec:	6078      	str	r0, [r7, #4]
    if(disp == NULL) return LV_COLOR_FORMAT_UNKNOWN;
 800b1ee:	687b      	ldr	r3, [r7, #4]
 800b1f0:	2b00      	cmp	r3, #0
 800b1f2:	d101      	bne.n	800b1f8 <lv_display_get_color_format+0x1e>
 800b1f4:	2300      	movs	r3, #0
 800b1f6:	e002      	b.n	800b1fe <lv_display_get_color_format+0x24>

    return disp->color_format;
 800b1f8:	687b      	ldr	r3, [r7, #4]
 800b1fa:	f893 303b 	ldrb.w	r3, [r3, #59]	@ 0x3b
}
 800b1fe:	4618      	mov	r0, r3
 800b200:	3708      	adds	r7, #8
 800b202:	46bd      	mov	sp, r7
 800b204:	bd80      	pop	{r7, pc}

0800b206 <lv_display_get_screen_active>:
/*---------------------
  * SCREENS
  *--------------------*/

lv_obj_t * lv_display_get_screen_active(lv_display_t * disp)
{
 800b206:	b580      	push	{r7, lr}
 800b208:	b082      	sub	sp, #8
 800b20a:	af00      	add	r7, sp, #0
 800b20c:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_display_get_default();
 800b20e:	687b      	ldr	r3, [r7, #4]
 800b210:	2b00      	cmp	r3, #0
 800b212:	d102      	bne.n	800b21a <lv_display_get_screen_active+0x14>
 800b214:	f7ff ff64 	bl	800b0e0 <lv_display_get_default>
 800b218:	6078      	str	r0, [r7, #4]
    if(!disp) {
 800b21a:	687b      	ldr	r3, [r7, #4]
 800b21c:	2b00      	cmp	r3, #0
 800b21e:	d101      	bne.n	800b224 <lv_display_get_screen_active+0x1e>
        LV_LOG_WARN("no display registered to get its active screen");
        return NULL;
 800b220:	2300      	movs	r3, #0
 800b222:	e002      	b.n	800b22a <lv_display_get_screen_active+0x24>
    }

    return disp->act_scr;
 800b224:	687b      	ldr	r3, [r7, #4]
 800b226:	f8d3 32b0 	ldr.w	r3, [r3, #688]	@ 0x2b0
}
 800b22a:	4618      	mov	r0, r3
 800b22c:	3708      	adds	r7, #8
 800b22e:	46bd      	mov	sp, r7
 800b230:	bd80      	pop	{r7, pc}

0800b232 <lv_display_get_screen_prev>:

lv_obj_t * lv_display_get_screen_prev(lv_display_t * disp)
{
 800b232:	b580      	push	{r7, lr}
 800b234:	b082      	sub	sp, #8
 800b236:	af00      	add	r7, sp, #0
 800b238:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_display_get_default();
 800b23a:	687b      	ldr	r3, [r7, #4]
 800b23c:	2b00      	cmp	r3, #0
 800b23e:	d102      	bne.n	800b246 <lv_display_get_screen_prev+0x14>
 800b240:	f7ff ff4e 	bl	800b0e0 <lv_display_get_default>
 800b244:	6078      	str	r0, [r7, #4]
    if(!disp) {
 800b246:	687b      	ldr	r3, [r7, #4]
 800b248:	2b00      	cmp	r3, #0
 800b24a:	d101      	bne.n	800b250 <lv_display_get_screen_prev+0x1e>
        LV_LOG_WARN("no display registered to get its previous screen");
        return NULL;
 800b24c:	2300      	movs	r3, #0
 800b24e:	e002      	b.n	800b256 <lv_display_get_screen_prev+0x24>
    }

    return disp->prev_scr;
 800b250:	687b      	ldr	r3, [r7, #4]
 800b252:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
}
 800b256:	4618      	mov	r0, r3
 800b258:	3708      	adds	r7, #8
 800b25a:	46bd      	mov	sp, r7
 800b25c:	bd80      	pop	{r7, pc}

0800b25e <lv_display_get_layer_top>:

lv_obj_t * lv_display_get_layer_top(lv_display_t * disp)
{
 800b25e:	b580      	push	{r7, lr}
 800b260:	b082      	sub	sp, #8
 800b262:	af00      	add	r7, sp, #0
 800b264:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_display_get_default();
 800b266:	687b      	ldr	r3, [r7, #4]
 800b268:	2b00      	cmp	r3, #0
 800b26a:	d102      	bne.n	800b272 <lv_display_get_layer_top+0x14>
 800b26c:	f7ff ff38 	bl	800b0e0 <lv_display_get_default>
 800b270:	6078      	str	r0, [r7, #4]
    if(!disp) {
 800b272:	687b      	ldr	r3, [r7, #4]
 800b274:	2b00      	cmp	r3, #0
 800b276:	d101      	bne.n	800b27c <lv_display_get_layer_top+0x1e>
        LV_LOG_WARN("lv_layer_top: no display registered to get its top layer");
        return NULL;
 800b278:	2300      	movs	r3, #0
 800b27a:	e002      	b.n	800b282 <lv_display_get_layer_top+0x24>
    }

    return disp->top_layer;
 800b27c:	687b      	ldr	r3, [r7, #4]
 800b27e:	f8d3 32c0 	ldr.w	r3, [r3, #704]	@ 0x2c0
}
 800b282:	4618      	mov	r0, r3
 800b284:	3708      	adds	r7, #8
 800b286:	46bd      	mov	sp, r7
 800b288:	bd80      	pop	{r7, pc}

0800b28a <lv_display_get_layer_sys>:

lv_obj_t * lv_display_get_layer_sys(lv_display_t * disp)
{
 800b28a:	b580      	push	{r7, lr}
 800b28c:	b082      	sub	sp, #8
 800b28e:	af00      	add	r7, sp, #0
 800b290:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_display_get_default();
 800b292:	687b      	ldr	r3, [r7, #4]
 800b294:	2b00      	cmp	r3, #0
 800b296:	d102      	bne.n	800b29e <lv_display_get_layer_sys+0x14>
 800b298:	f7ff ff22 	bl	800b0e0 <lv_display_get_default>
 800b29c:	6078      	str	r0, [r7, #4]
    if(!disp) {
 800b29e:	687b      	ldr	r3, [r7, #4]
 800b2a0:	2b00      	cmp	r3, #0
 800b2a2:	d101      	bne.n	800b2a8 <lv_display_get_layer_sys+0x1e>
        LV_LOG_WARN("lv_layer_sys: no display registered to get its sys. layer");
        return NULL;
 800b2a4:	2300      	movs	r3, #0
 800b2a6:	e002      	b.n	800b2ae <lv_display_get_layer_sys+0x24>
    }

    return disp->sys_layer;
 800b2a8:	687b      	ldr	r3, [r7, #4]
 800b2aa:	f8d3 32c4 	ldr.w	r3, [r3, #708]	@ 0x2c4
}
 800b2ae:	4618      	mov	r0, r3
 800b2b0:	3708      	adds	r7, #8
 800b2b2:	46bd      	mov	sp, r7
 800b2b4:	bd80      	pop	{r7, pc}

0800b2b6 <lv_display_get_layer_bottom>:

lv_obj_t * lv_display_get_layer_bottom(lv_display_t * disp)
{
 800b2b6:	b580      	push	{r7, lr}
 800b2b8:	b082      	sub	sp, #8
 800b2ba:	af00      	add	r7, sp, #0
 800b2bc:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_display_get_default();
 800b2be:	687b      	ldr	r3, [r7, #4]
 800b2c0:	2b00      	cmp	r3, #0
 800b2c2:	d102      	bne.n	800b2ca <lv_display_get_layer_bottom+0x14>
 800b2c4:	f7ff ff0c 	bl	800b0e0 <lv_display_get_default>
 800b2c8:	6078      	str	r0, [r7, #4]
    if(!disp) {
 800b2ca:	687b      	ldr	r3, [r7, #4]
 800b2cc:	2b00      	cmp	r3, #0
 800b2ce:	d101      	bne.n	800b2d4 <lv_display_get_layer_bottom+0x1e>
        LV_LOG_WARN("lv_layer_bottom: no display registered to get its bottom layer");
        return NULL;
 800b2d0:	2300      	movs	r3, #0
 800b2d2:	e002      	b.n	800b2da <lv_display_get_layer_bottom+0x24>
    }

    return disp->bottom_layer;
 800b2d4:	687b      	ldr	r3, [r7, #4]
 800b2d6:	f8d3 32bc 	ldr.w	r3, [r3, #700]	@ 0x2bc
}
 800b2da:	4618      	mov	r0, r3
 800b2dc:	3708      	adds	r7, #8
 800b2de:	46bd      	mov	sp, r7
 800b2e0:	bd80      	pop	{r7, pc}

0800b2e2 <lv_display_send_event>:

    return removed_count;
}

lv_result_t lv_display_send_event(lv_display_t * disp, lv_event_code_t code, void * param)
{
 800b2e2:	b580      	push	{r7, lr}
 800b2e4:	b08c      	sub	sp, #48	@ 0x30
 800b2e6:	af00      	add	r7, sp, #0
 800b2e8:	60f8      	str	r0, [r7, #12]
 800b2ea:	460b      	mov	r3, r1
 800b2ec:	607a      	str	r2, [r7, #4]
 800b2ee:	817b      	strh	r3, [r7, #10]

    lv_event_t e;
    lv_memzero(&e, sizeof(e));
 800b2f0:	f107 0310 	add.w	r3, r7, #16
 800b2f4:	211c      	movs	r1, #28
 800b2f6:	4618      	mov	r0, r3
 800b2f8:	f7ff fee4 	bl	800b0c4 <lv_memzero>
    e.code = code;
 800b2fc:	897b      	ldrh	r3, [r7, #10]
 800b2fe:	833b      	strh	r3, [r7, #24]
    e.current_target = disp;
 800b300:	68fb      	ldr	r3, [r7, #12]
 800b302:	613b      	str	r3, [r7, #16]
    e.original_target = disp;
 800b304:	68fb      	ldr	r3, [r7, #12]
 800b306:	617b      	str	r3, [r7, #20]
    e.param = param;
 800b308:	687b      	ldr	r3, [r7, #4]
 800b30a:	623b      	str	r3, [r7, #32]
    lv_result_t res;
    res = lv_event_send(&disp->event_list, &e, true);
 800b30c:	68fb      	ldr	r3, [r7, #12]
 800b30e:	f503 7336 	add.w	r3, r3, #728	@ 0x2d8
 800b312:	f107 0110 	add.w	r1, r7, #16
 800b316:	2201      	movs	r2, #1
 800b318:	4618      	mov	r0, r3
 800b31a:	f017 f9ed 	bl	80226f8 <lv_event_send>
 800b31e:	4603      	mov	r3, r0
 800b320:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if(res != LV_RESULT_OK) return res;
 800b324:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800b328:	2b01      	cmp	r3, #1
 800b32a:	d002      	beq.n	800b332 <lv_display_send_event+0x50>
 800b32c:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800b330:	e014      	b.n	800b35c <lv_display_send_event+0x7a>

    res = lv_event_send(&disp->event_list, &e, false);
 800b332:	68fb      	ldr	r3, [r7, #12]
 800b334:	f503 7336 	add.w	r3, r3, #728	@ 0x2d8
 800b338:	f107 0110 	add.w	r1, r7, #16
 800b33c:	2200      	movs	r2, #0
 800b33e:	4618      	mov	r0, r3
 800b340:	f017 f9da 	bl	80226f8 <lv_event_send>
 800b344:	4603      	mov	r3, r0
 800b346:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if(res != LV_RESULT_OK) return res;
 800b34a:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800b34e:	2b01      	cmp	r3, #1
 800b350:	d002      	beq.n	800b358 <lv_display_send_event+0x76>
 800b352:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800b356:	e001      	b.n	800b35c <lv_display_send_event+0x7a>

    return res;
 800b358:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
 800b35c:	4618      	mov	r0, r3
 800b35e:	3730      	adds	r7, #48	@ 0x30
 800b360:	46bd      	mov	sp, r7
 800b362:	bd80      	pop	{r7, pc}

0800b364 <lv_display_get_theme>:
        lv_theme_apply(disp->screens[0]);
    }
}

lv_theme_t * lv_display_get_theme(lv_display_t * disp)
{
 800b364:	b580      	push	{r7, lr}
 800b366:	b082      	sub	sp, #8
 800b368:	af00      	add	r7, sp, #0
 800b36a:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_display_get_default();
 800b36c:	687b      	ldr	r3, [r7, #4]
 800b36e:	2b00      	cmp	r3, #0
 800b370:	d102      	bne.n	800b378 <lv_display_get_theme+0x14>
 800b372:	f7ff feb5 	bl	800b0e0 <lv_display_get_default>
 800b376:	6078      	str	r0, [r7, #4]
    return disp->theme;
 800b378:	687b      	ldr	r3, [r7, #4]
 800b37a:	f8d3 32ec 	ldr.w	r3, [r3, #748]	@ 0x2ec
}
 800b37e:	4618      	mov	r0, r3
 800b380:	3708      	adds	r7, #8
 800b382:	46bd      	mov	sp, r7
 800b384:	bd80      	pop	{r7, pc}

0800b386 <lv_display_is_invalidation_enabled>:

    disp->inv_en_cnt += en ? 1 : -1;
}

bool lv_display_is_invalidation_enabled(lv_display_t * disp)
{
 800b386:	b580      	push	{r7, lr}
 800b388:	b082      	sub	sp, #8
 800b38a:	af00      	add	r7, sp, #0
 800b38c:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_display_get_default();
 800b38e:	687b      	ldr	r3, [r7, #4]
 800b390:	2b00      	cmp	r3, #0
 800b392:	d102      	bne.n	800b39a <lv_display_is_invalidation_enabled+0x14>
 800b394:	f7ff fea4 	bl	800b0e0 <lv_display_get_default>
 800b398:	6078      	str	r0, [r7, #4]
    if(!disp) {
 800b39a:	687b      	ldr	r3, [r7, #4]
 800b39c:	2b00      	cmp	r3, #0
 800b39e:	d101      	bne.n	800b3a4 <lv_display_is_invalidation_enabled+0x1e>
        LV_LOG_WARN("no display registered");
        return false;
 800b3a0:	2300      	movs	r3, #0
 800b3a2:	e007      	b.n	800b3b4 <lv_display_is_invalidation_enabled+0x2e>
    }

    return (disp->inv_en_cnt > 0);
 800b3a4:	687b      	ldr	r3, [r7, #4]
 800b3a6:	f8d3 3260 	ldr.w	r3, [r3, #608]	@ 0x260
 800b3aa:	2b00      	cmp	r3, #0
 800b3ac:	bfcc      	ite	gt
 800b3ae:	2301      	movgt	r3, #1
 800b3b0:	2300      	movle	r3, #0
 800b3b2:	b2db      	uxtb	r3, r3
}
 800b3b4:	4618      	mov	r0, r3
 800b3b6:	3708      	adds	r7, #8
 800b3b8:	46bd      	mov	sp, r7
 800b3ba:	bd80      	pop	{r7, pc}

0800b3bc <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline int32_t lv_area_get_width(const lv_area_t * area_p)
{
 800b3bc:	b480      	push	{r7}
 800b3be:	b083      	sub	sp, #12
 800b3c0:	af00      	add	r7, sp, #0
 800b3c2:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 800b3c4:	687b      	ldr	r3, [r7, #4]
 800b3c6:	689a      	ldr	r2, [r3, #8]
 800b3c8:	687b      	ldr	r3, [r7, #4]
 800b3ca:	681b      	ldr	r3, [r3, #0]
 800b3cc:	1ad3      	subs	r3, r2, r3
 800b3ce:	3301      	adds	r3, #1
}
 800b3d0:	4618      	mov	r0, r3
 800b3d2:	370c      	adds	r7, #12
 800b3d4:	46bd      	mov	sp, r7
 800b3d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3da:	4770      	bx	lr

0800b3dc <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline int32_t lv_area_get_height(const lv_area_t * area_p)
{
 800b3dc:	b480      	push	{r7}
 800b3de:	b083      	sub	sp, #12
 800b3e0:	af00      	add	r7, sp, #0
 800b3e2:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 800b3e4:	687b      	ldr	r3, [r7, #4]
 800b3e6:	68da      	ldr	r2, [r3, #12]
 800b3e8:	687b      	ldr	r3, [r7, #4]
 800b3ea:	685b      	ldr	r3, [r3, #4]
 800b3ec:	1ad3      	subs	r3, r2, r3
 800b3ee:	3301      	adds	r3, #1
}
 800b3f0:	4618      	mov	r0, r3
 800b3f2:	370c      	adds	r7, #12
 800b3f4:	46bd      	mov	sp, r7
 800b3f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3fa:	4770      	bx	lr

0800b3fc <get_layer_size_kb>:
 *  STATIC PROTOTYPES
 **********************/
static bool is_independent(lv_layer_t * layer, lv_draw_task_t * t_check);

static inline uint32_t get_layer_size_kb(uint32_t size_byte)
{
 800b3fc:	b480      	push	{r7}
 800b3fe:	b083      	sub	sp, #12
 800b400:	af00      	add	r7, sp, #0
 800b402:	6078      	str	r0, [r7, #4]
    return size_byte < 1024 ? 1 : size_byte >> 10;
 800b404:	687b      	ldr	r3, [r7, #4]
 800b406:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800b40a:	d302      	bcc.n	800b412 <get_layer_size_kb+0x16>
 800b40c:	687b      	ldr	r3, [r7, #4]
 800b40e:	0a9b      	lsrs	r3, r3, #10
 800b410:	e000      	b.n	800b414 <get_layer_size_kb+0x18>
 800b412:	2301      	movs	r3, #1
}
 800b414:	4618      	mov	r0, r3
 800b416:	370c      	adds	r7, #12
 800b418:	46bd      	mov	sp, r7
 800b41a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b41e:	4770      	bx	lr

0800b420 <lv_draw_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_init(void)
{
 800b420:	b480      	push	{r7}
 800b422:	af00      	add	r7, sp, #0
#if LV_USE_OS
    lv_thread_sync_init(&_draw_info.sync);
#endif
}
 800b424:	bf00      	nop
 800b426:	46bd      	mov	sp, r7
 800b428:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b42c:	4770      	bx	lr
	...

0800b430 <lv_draw_create_unit>:
    }
    _draw_info.unit_head = NULL;
}

void * lv_draw_create_unit(size_t size)
{
 800b430:	b580      	push	{r7, lr}
 800b432:	b084      	sub	sp, #16
 800b434:	af00      	add	r7, sp, #0
 800b436:	6078      	str	r0, [r7, #4]
    lv_draw_unit_t * new_unit = lv_malloc_zeroed(size);
 800b438:	6878      	ldr	r0, [r7, #4]
 800b43a:	f01a fcdf 	bl	8025dfc <lv_malloc_zeroed>
 800b43e:	60f8      	str	r0, [r7, #12]

    new_unit->next = _draw_info.unit_head;
 800b440:	4b06      	ldr	r3, [pc, #24]	@ (800b45c <lv_draw_create_unit+0x2c>)
 800b442:	f8d3 20f4 	ldr.w	r2, [r3, #244]	@ 0xf4
 800b446:	68fb      	ldr	r3, [r7, #12]
 800b448:	601a      	str	r2, [r3, #0]
    _draw_info.unit_head = new_unit;
 800b44a:	4a04      	ldr	r2, [pc, #16]	@ (800b45c <lv_draw_create_unit+0x2c>)
 800b44c:	68fb      	ldr	r3, [r7, #12]
 800b44e:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4

    return new_unit;
 800b452:	68fb      	ldr	r3, [r7, #12]
}
 800b454:	4618      	mov	r0, r3
 800b456:	3710      	adds	r7, #16
 800b458:	46bd      	mov	sp, r7
 800b45a:	bd80      	pop	{r7, pc}
 800b45c:	2000009c 	.word	0x2000009c

0800b460 <lv_draw_add_task>:

lv_draw_task_t * lv_draw_add_task(lv_layer_t * layer, const lv_area_t * coords)
{
 800b460:	b590      	push	{r4, r7, lr}
 800b462:	b085      	sub	sp, #20
 800b464:	af00      	add	r7, sp, #0
 800b466:	6078      	str	r0, [r7, #4]
 800b468:	6039      	str	r1, [r7, #0]
    LV_PROFILER_BEGIN;
    lv_draw_task_t * new_task = lv_malloc_zeroed(sizeof(lv_draw_task_t));
 800b46a:	2054      	movs	r0, #84	@ 0x54
 800b46c:	f01a fcc6 	bl	8025dfc <lv_malloc_zeroed>
 800b470:	60b8      	str	r0, [r7, #8]

    new_task->area = *coords;
 800b472:	68bb      	ldr	r3, [r7, #8]
 800b474:	683a      	ldr	r2, [r7, #0]
 800b476:	f103 0408 	add.w	r4, r3, #8
 800b47a:	4613      	mov	r3, r2
 800b47c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800b47e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    new_task->_real_area = *coords;
 800b482:	68bb      	ldr	r3, [r7, #8]
 800b484:	683a      	ldr	r2, [r7, #0]
 800b486:	f103 0418 	add.w	r4, r3, #24
 800b48a:	4613      	mov	r3, r2
 800b48c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800b48e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    new_task->clip_area = layer->_clip_area;
 800b492:	68ba      	ldr	r2, [r7, #8]
 800b494:	687b      	ldr	r3, [r7, #4]
 800b496:	f102 0438 	add.w	r4, r2, #56	@ 0x38
 800b49a:	3318      	adds	r3, #24
 800b49c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800b49e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    new_task->state = LV_DRAW_TASK_STATE_QUEUED;
 800b4a2:	68bb      	ldr	r3, [r7, #8]
 800b4a4:	2201      	movs	r2, #1
 800b4a6:	649a      	str	r2, [r3, #72]	@ 0x48

    /*Find the tail*/
    if(layer->draw_task_head == NULL) {
 800b4a8:	687b      	ldr	r3, [r7, #4]
 800b4aa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b4ac:	2b00      	cmp	r3, #0
 800b4ae:	d103      	bne.n	800b4b8 <lv_draw_add_task+0x58>
        layer->draw_task_head = new_task;
 800b4b0:	687b      	ldr	r3, [r7, #4]
 800b4b2:	68ba      	ldr	r2, [r7, #8]
 800b4b4:	629a      	str	r2, [r3, #40]	@ 0x28
 800b4b6:	e00d      	b.n	800b4d4 <lv_draw_add_task+0x74>
    }
    else {
        lv_draw_task_t * tail = layer->draw_task_head;
 800b4b8:	687b      	ldr	r3, [r7, #4]
 800b4ba:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b4bc:	60fb      	str	r3, [r7, #12]
        while(tail->next) tail = tail->next;
 800b4be:	e002      	b.n	800b4c6 <lv_draw_add_task+0x66>
 800b4c0:	68fb      	ldr	r3, [r7, #12]
 800b4c2:	681b      	ldr	r3, [r3, #0]
 800b4c4:	60fb      	str	r3, [r7, #12]
 800b4c6:	68fb      	ldr	r3, [r7, #12]
 800b4c8:	681b      	ldr	r3, [r3, #0]
 800b4ca:	2b00      	cmp	r3, #0
 800b4cc:	d1f8      	bne.n	800b4c0 <lv_draw_add_task+0x60>

        tail->next = new_task;
 800b4ce:	68fb      	ldr	r3, [r7, #12]
 800b4d0:	68ba      	ldr	r2, [r7, #8]
 800b4d2:	601a      	str	r2, [r3, #0]
    }

    LV_PROFILER_END;
    return new_task;
 800b4d4:	68bb      	ldr	r3, [r7, #8]
}
 800b4d6:	4618      	mov	r0, r3
 800b4d8:	3714      	adds	r7, #20
 800b4da:	46bd      	mov	sp, r7
 800b4dc:	bd90      	pop	{r4, r7, pc}
	...

0800b4e0 <lv_draw_finalize_task_creation>:

void lv_draw_finalize_task_creation(lv_layer_t * layer, lv_draw_task_t * t)
{
 800b4e0:	b580      	push	{r7, lr}
 800b4e2:	b086      	sub	sp, #24
 800b4e4:	af00      	add	r7, sp, #0
 800b4e6:	6078      	str	r0, [r7, #4]
 800b4e8:	6039      	str	r1, [r7, #0]
    LV_PROFILER_BEGIN;
    lv_draw_dsc_base_t * base_dsc = t->draw_dsc;
 800b4ea:	683b      	ldr	r3, [r7, #0]
 800b4ec:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800b4ee:	60fb      	str	r3, [r7, #12]
    base_dsc->layer = layer;
 800b4f0:	68fb      	ldr	r3, [r7, #12]
 800b4f2:	687a      	ldr	r2, [r7, #4]
 800b4f4:	611a      	str	r2, [r3, #16]

    lv_draw_global_info_t * info = &_draw_info;
 800b4f6:	4b30      	ldr	r3, [pc, #192]	@ (800b5b8 <lv_draw_finalize_task_creation+0xd8>)
 800b4f8:	60bb      	str	r3, [r7, #8]
    /*Send LV_EVENT_DRAW_TASK_ADDED and dispatch only on the "main" draw_task
     *and not on the draw tasks added in the event.
     *Sending LV_EVENT_DRAW_TASK_ADDED events might cause recursive event sends and besides
     *dispatching might remove the "main" draw task while it's still being used in the event*/

    if(info->task_running == false) {
 800b4fa:	68bb      	ldr	r3, [r7, #8]
 800b4fc:	7c1b      	ldrb	r3, [r3, #16]
 800b4fe:	f083 0301 	eor.w	r3, r3, #1
 800b502:	b2db      	uxtb	r3, r3
 800b504:	2b00      	cmp	r3, #0
 800b506:	d038      	beq.n	800b57a <lv_draw_finalize_task_creation+0x9a>
        if(base_dsc->obj && lv_obj_has_flag(base_dsc->obj, LV_OBJ_FLAG_SEND_DRAW_TASK_EVENTS)) {
 800b508:	68fb      	ldr	r3, [r7, #12]
 800b50a:	681b      	ldr	r3, [r3, #0]
 800b50c:	2b00      	cmp	r3, #0
 800b50e:	d016      	beq.n	800b53e <lv_draw_finalize_task_creation+0x5e>
 800b510:	68fb      	ldr	r3, [r7, #12]
 800b512:	681b      	ldr	r3, [r3, #0]
 800b514:	f44f 2100 	mov.w	r1, #524288	@ 0x80000
 800b518:	4618      	mov	r0, r3
 800b51a:	f7f7 fc18 	bl	8002d4e <lv_obj_has_flag>
 800b51e:	4603      	mov	r3, r0
 800b520:	2b00      	cmp	r3, #0
 800b522:	d00c      	beq.n	800b53e <lv_draw_finalize_task_creation+0x5e>
            info->task_running = true;
 800b524:	68bb      	ldr	r3, [r7, #8]
 800b526:	2201      	movs	r2, #1
 800b528:	741a      	strb	r2, [r3, #16]
            lv_obj_send_event(base_dsc->obj, LV_EVENT_DRAW_TASK_ADDED, t);
 800b52a:	68fb      	ldr	r3, [r7, #12]
 800b52c:	681b      	ldr	r3, [r3, #0]
 800b52e:	683a      	ldr	r2, [r7, #0]
 800b530:	211c      	movs	r1, #28
 800b532:	4618      	mov	r0, r3
 800b534:	f7f9 fc6e 	bl	8004e14 <lv_obj_send_event>
            info->task_running = false;
 800b538:	68bb      	ldr	r3, [r7, #8]
 800b53a:	2200      	movs	r2, #0
 800b53c:	741a      	strb	r2, [r3, #16]
        }

        /*Let the draw units set their preference score*/
        t->preference_score = 100;
 800b53e:	683b      	ldr	r3, [r7, #0]
 800b540:	2264      	movs	r2, #100	@ 0x64
 800b542:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
        t->preferred_draw_unit_id = 0;
 800b546:	683b      	ldr	r3, [r7, #0]
 800b548:	2200      	movs	r2, #0
 800b54a:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
        lv_draw_unit_t * u = info->unit_head;
 800b54e:	68bb      	ldr	r3, [r7, #8]
 800b550:	681b      	ldr	r3, [r3, #0]
 800b552:	617b      	str	r3, [r7, #20]
        while(u) {
 800b554:	e00b      	b.n	800b56e <lv_draw_finalize_task_creation+0x8e>
            if(u->evaluate_cb) u->evaluate_cb(u, t);
 800b556:	697b      	ldr	r3, [r7, #20]
 800b558:	691b      	ldr	r3, [r3, #16]
 800b55a:	2b00      	cmp	r3, #0
 800b55c:	d004      	beq.n	800b568 <lv_draw_finalize_task_creation+0x88>
 800b55e:	697b      	ldr	r3, [r7, #20]
 800b560:	691b      	ldr	r3, [r3, #16]
 800b562:	6839      	ldr	r1, [r7, #0]
 800b564:	6978      	ldr	r0, [r7, #20]
 800b566:	4798      	blx	r3
            u = u->next;
 800b568:	697b      	ldr	r3, [r7, #20]
 800b56a:	681b      	ldr	r3, [r3, #0]
 800b56c:	617b      	str	r3, [r7, #20]
        while(u) {
 800b56e:	697b      	ldr	r3, [r7, #20]
 800b570:	2b00      	cmp	r3, #0
 800b572:	d1f0      	bne.n	800b556 <lv_draw_finalize_task_creation+0x76>
        }

        lv_draw_dispatch();
 800b574:	f000 f822 	bl	800b5bc <lv_draw_dispatch>
            if(u->evaluate_cb) u->evaluate_cb(u, t);
            u = u->next;
        }
    }
    LV_PROFILER_END;
}
 800b578:	e01a      	b.n	800b5b0 <lv_draw_finalize_task_creation+0xd0>
        t->preference_score = 100;
 800b57a:	683b      	ldr	r3, [r7, #0]
 800b57c:	2264      	movs	r2, #100	@ 0x64
 800b57e:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
        t->preferred_draw_unit_id = 0;
 800b582:	683b      	ldr	r3, [r7, #0]
 800b584:	2200      	movs	r2, #0
 800b586:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
        lv_draw_unit_t * u = info->unit_head;
 800b58a:	68bb      	ldr	r3, [r7, #8]
 800b58c:	681b      	ldr	r3, [r3, #0]
 800b58e:	613b      	str	r3, [r7, #16]
        while(u) {
 800b590:	e00b      	b.n	800b5aa <lv_draw_finalize_task_creation+0xca>
            if(u->evaluate_cb) u->evaluate_cb(u, t);
 800b592:	693b      	ldr	r3, [r7, #16]
 800b594:	691b      	ldr	r3, [r3, #16]
 800b596:	2b00      	cmp	r3, #0
 800b598:	d004      	beq.n	800b5a4 <lv_draw_finalize_task_creation+0xc4>
 800b59a:	693b      	ldr	r3, [r7, #16]
 800b59c:	691b      	ldr	r3, [r3, #16]
 800b59e:	6839      	ldr	r1, [r7, #0]
 800b5a0:	6938      	ldr	r0, [r7, #16]
 800b5a2:	4798      	blx	r3
            u = u->next;
 800b5a4:	693b      	ldr	r3, [r7, #16]
 800b5a6:	681b      	ldr	r3, [r3, #0]
 800b5a8:	613b      	str	r3, [r7, #16]
        while(u) {
 800b5aa:	693b      	ldr	r3, [r7, #16]
 800b5ac:	2b00      	cmp	r3, #0
 800b5ae:	d1f0      	bne.n	800b592 <lv_draw_finalize_task_creation+0xb2>
}
 800b5b0:	bf00      	nop
 800b5b2:	3718      	adds	r7, #24
 800b5b4:	46bd      	mov	sp, r7
 800b5b6:	bd80      	pop	{r7, pc}
 800b5b8:	20000190 	.word	0x20000190

0800b5bc <lv_draw_dispatch>:

void lv_draw_dispatch(void)
{
 800b5bc:	b580      	push	{r7, lr}
 800b5be:	b084      	sub	sp, #16
 800b5c0:	af00      	add	r7, sp, #0
    LV_PROFILER_BEGIN;
    bool render_running = false;
 800b5c2:	2300      	movs	r3, #0
 800b5c4:	73fb      	strb	r3, [r7, #15]
    lv_display_t * disp = lv_display_get_next(NULL);
 800b5c6:	2000      	movs	r0, #0
 800b5c8:	f7ff fd96 	bl	800b0f8 <lv_display_get_next>
 800b5cc:	60b8      	str	r0, [r7, #8]
    while(disp) {
 800b5ce:	e01f      	b.n	800b610 <lv_draw_dispatch+0x54>
        lv_layer_t * layer = disp->layer_head;
 800b5d0:	68bb      	ldr	r3, [r7, #8]
 800b5d2:	f8d3 32a0 	ldr.w	r3, [r3, #672]	@ 0x2a0
 800b5d6:	607b      	str	r3, [r7, #4]
        while(layer) {
 800b5d8:	e00b      	b.n	800b5f2 <lv_draw_dispatch+0x36>
            if(lv_draw_dispatch_layer(disp, layer))
 800b5da:	6879      	ldr	r1, [r7, #4]
 800b5dc:	68b8      	ldr	r0, [r7, #8]
 800b5de:	f000 f81f 	bl	800b620 <lv_draw_dispatch_layer>
 800b5e2:	4603      	mov	r3, r0
 800b5e4:	2b00      	cmp	r3, #0
 800b5e6:	d001      	beq.n	800b5ec <lv_draw_dispatch+0x30>
                render_running = true;
 800b5e8:	2301      	movs	r3, #1
 800b5ea:	73fb      	strb	r3, [r7, #15]
            layer = layer->next;
 800b5ec:	687b      	ldr	r3, [r7, #4]
 800b5ee:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800b5f0:	607b      	str	r3, [r7, #4]
        while(layer) {
 800b5f2:	687b      	ldr	r3, [r7, #4]
 800b5f4:	2b00      	cmp	r3, #0
 800b5f6:	d1f0      	bne.n	800b5da <lv_draw_dispatch+0x1e>
        }
        if(!render_running) {
 800b5f8:	7bfb      	ldrb	r3, [r7, #15]
 800b5fa:	f083 0301 	eor.w	r3, r3, #1
 800b5fe:	b2db      	uxtb	r3, r3
 800b600:	2b00      	cmp	r3, #0
 800b602:	d001      	beq.n	800b608 <lv_draw_dispatch+0x4c>
            lv_draw_dispatch_request();
 800b604:	f000 f904 	bl	800b810 <lv_draw_dispatch_request>
        }
        disp = lv_display_get_next(disp);
 800b608:	68b8      	ldr	r0, [r7, #8]
 800b60a:	f7ff fd75 	bl	800b0f8 <lv_display_get_next>
 800b60e:	60b8      	str	r0, [r7, #8]
    while(disp) {
 800b610:	68bb      	ldr	r3, [r7, #8]
 800b612:	2b00      	cmp	r3, #0
 800b614:	d1dc      	bne.n	800b5d0 <lv_draw_dispatch+0x14>
    }
    LV_PROFILER_END;
}
 800b616:	bf00      	nop
 800b618:	bf00      	nop
 800b61a:	3710      	adds	r7, #16
 800b61c:	46bd      	mov	sp, r7
 800b61e:	bd80      	pop	{r7, pc}

0800b620 <lv_draw_dispatch_layer>:

bool lv_draw_dispatch_layer(lv_display_t * disp, lv_layer_t * layer)
{
 800b620:	b580      	push	{r7, lr}
 800b622:	b092      	sub	sp, #72	@ 0x48
 800b624:	af00      	add	r7, sp, #0
 800b626:	6078      	str	r0, [r7, #4]
 800b628:	6039      	str	r1, [r7, #0]
    LV_PROFILER_BEGIN;
    /*Remove the finished tasks first*/
    lv_draw_task_t * t_prev = NULL;
 800b62a:	2300      	movs	r3, #0
 800b62c:	647b      	str	r3, [r7, #68]	@ 0x44
    lv_draw_task_t * t = layer->draw_task_head;
 800b62e:	683b      	ldr	r3, [r7, #0]
 800b630:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b632:	643b      	str	r3, [r7, #64]	@ 0x40
    while(t) {
 800b634:	e095      	b.n	800b762 <lv_draw_dispatch_layer+0x142>
        lv_draw_task_t * t_next = t->next;
 800b636:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b638:	681b      	ldr	r3, [r3, #0]
 800b63a:	627b      	str	r3, [r7, #36]	@ 0x24
        if(t->state == LV_DRAW_TASK_STATE_READY) {
 800b63c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b63e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800b640:	2b03      	cmp	r3, #3
 800b642:	f040 808a 	bne.w	800b75a <lv_draw_dispatch_layer+0x13a>
            if(t_prev) t_prev->next = t->next;      /*Remove by it by assigning the next task to the previous*/
 800b646:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800b648:	2b00      	cmp	r3, #0
 800b64a:	d004      	beq.n	800b656 <lv_draw_dispatch_layer+0x36>
 800b64c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b64e:	681a      	ldr	r2, [r3, #0]
 800b650:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800b652:	601a      	str	r2, [r3, #0]
 800b654:	e002      	b.n	800b65c <lv_draw_dispatch_layer+0x3c>
            else layer->draw_task_head = t_next;    /*If it was the head, set the next as head*/
 800b656:	683b      	ldr	r3, [r7, #0]
 800b658:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800b65a:	629a      	str	r2, [r3, #40]	@ 0x28

            /*If it was layer drawing free the layer too*/
            if(t->type == LV_DRAW_TASK_TYPE_LAYER) {
 800b65c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b65e:	791b      	ldrb	r3, [r3, #4]
 800b660:	2b05      	cmp	r3, #5
 800b662:	d15a      	bne.n	800b71a <lv_draw_dispatch_layer+0xfa>
                lv_draw_image_dsc_t * draw_image_dsc = t->draw_dsc;
 800b664:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b666:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800b668:	623b      	str	r3, [r7, #32]
                lv_layer_t * layer_drawn = (lv_layer_t *)draw_image_dsc->src;
 800b66a:	6a3b      	ldr	r3, [r7, #32]
 800b66c:	69db      	ldr	r3, [r3, #28]
 800b66e:	61fb      	str	r3, [r7, #28]

                if(layer_drawn->draw_buf) {
 800b670:	69fb      	ldr	r3, [r7, #28]
 800b672:	681b      	ldr	r3, [r3, #0]
 800b674:	2b00      	cmp	r3, #0
 800b676:	d02a      	beq.n	800b6ce <lv_draw_dispatch_layer+0xae>
                    int32_t h = lv_area_get_height(&layer_drawn->buf_area);
 800b678:	69fb      	ldr	r3, [r7, #28]
 800b67a:	3304      	adds	r3, #4
 800b67c:	4618      	mov	r0, r3
 800b67e:	f7ff fead 	bl	800b3dc <lv_area_get_height>
 800b682:	61b8      	str	r0, [r7, #24]
                    int32_t w = lv_area_get_width(&layer_drawn->buf_area);
 800b684:	69fb      	ldr	r3, [r7, #28]
 800b686:	3304      	adds	r3, #4
 800b688:	4618      	mov	r0, r3
 800b68a:	f7ff fe97 	bl	800b3bc <lv_area_get_width>
 800b68e:	6178      	str	r0, [r7, #20]
                    uint32_t layer_size_byte = h * lv_draw_buf_width_to_stride(w, layer_drawn->color_format);
 800b690:	697a      	ldr	r2, [r7, #20]
 800b692:	69fb      	ldr	r3, [r7, #28]
 800b694:	7d1b      	ldrb	r3, [r3, #20]
 800b696:	4619      	mov	r1, r3
 800b698:	4610      	mov	r0, r2
 800b69a:	f000 fa93 	bl	800bbc4 <lv_draw_buf_width_to_stride>
 800b69e:	4602      	mov	r2, r0
 800b6a0:	69bb      	ldr	r3, [r7, #24]
 800b6a2:	fb02 f303 	mul.w	r3, r2, r3
 800b6a6:	613b      	str	r3, [r7, #16]

                    _draw_info.used_memory_for_layers_kb -= get_layer_size_kb(layer_size_byte);
 800b6a8:	6938      	ldr	r0, [r7, #16]
 800b6aa:	f7ff fea7 	bl	800b3fc <get_layer_size_kb>
 800b6ae:	4602      	mov	r2, r0
 800b6b0:	4b56      	ldr	r3, [pc, #344]	@ (800b80c <lv_draw_dispatch_layer+0x1ec>)
 800b6b2:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
 800b6b6:	1a9b      	subs	r3, r3, r2
 800b6b8:	4a54      	ldr	r2, [pc, #336]	@ (800b80c <lv_draw_dispatch_layer+0x1ec>)
 800b6ba:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
                    LV_LOG_INFO("Layer memory used: %" LV_PRIu32 " kB\n", _draw_info.used_memory_for_layers_kb);
                    lv_draw_buf_destroy(layer_drawn->draw_buf);
 800b6be:	69fb      	ldr	r3, [r7, #28]
 800b6c0:	681b      	ldr	r3, [r3, #0]
 800b6c2:	4618      	mov	r0, r3
 800b6c4:	f000 fc72 	bl	800bfac <lv_draw_buf_destroy>
                    layer_drawn->draw_buf = NULL;
 800b6c8:	69fb      	ldr	r3, [r7, #28]
 800b6ca:	2200      	movs	r2, #0
 800b6cc:	601a      	str	r2, [r3, #0]
                }

                /*Remove the layer from  the display's*/
                if(disp) {
 800b6ce:	687b      	ldr	r3, [r7, #4]
 800b6d0:	2b00      	cmp	r3, #0
 800b6d2:	d022      	beq.n	800b71a <lv_draw_dispatch_layer+0xfa>
                    lv_layer_t * l2 = disp->layer_head;
 800b6d4:	687b      	ldr	r3, [r7, #4]
 800b6d6:	f8d3 32a0 	ldr.w	r3, [r3, #672]	@ 0x2a0
 800b6da:	63fb      	str	r3, [r7, #60]	@ 0x3c
                    while(l2) {
 800b6dc:	e00c      	b.n	800b6f8 <lv_draw_dispatch_layer+0xd8>
                        if(l2->next == layer_drawn) {
 800b6de:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800b6e0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800b6e2:	69fa      	ldr	r2, [r7, #28]
 800b6e4:	429a      	cmp	r2, r3
 800b6e6:	d104      	bne.n	800b6f2 <lv_draw_dispatch_layer+0xd2>
                            l2->next = layer_drawn->next;
 800b6e8:	69fb      	ldr	r3, [r7, #28]
 800b6ea:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800b6ec:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800b6ee:	631a      	str	r2, [r3, #48]	@ 0x30
                            break;
 800b6f0:	e005      	b.n	800b6fe <lv_draw_dispatch_layer+0xde>
                        }
                        l2 = l2->next;
 800b6f2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800b6f4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800b6f6:	63fb      	str	r3, [r7, #60]	@ 0x3c
                    while(l2) {
 800b6f8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800b6fa:	2b00      	cmp	r3, #0
 800b6fc:	d1ef      	bne.n	800b6de <lv_draw_dispatch_layer+0xbe>
                    }

                    if(disp->layer_deinit) disp->layer_deinit(disp, layer_drawn);
 800b6fe:	687b      	ldr	r3, [r7, #4]
 800b700:	f8d3 32a8 	ldr.w	r3, [r3, #680]	@ 0x2a8
 800b704:	2b00      	cmp	r3, #0
 800b706:	d005      	beq.n	800b714 <lv_draw_dispatch_layer+0xf4>
 800b708:	687b      	ldr	r3, [r7, #4]
 800b70a:	f8d3 32a8 	ldr.w	r3, [r3, #680]	@ 0x2a8
 800b70e:	69f9      	ldr	r1, [r7, #28]
 800b710:	6878      	ldr	r0, [r7, #4]
 800b712:	4798      	blx	r3
                    lv_free(layer_drawn);
 800b714:	69f8      	ldr	r0, [r7, #28]
 800b716:	f01a fb8f 	bl	8025e38 <lv_free>
                }
            }
            lv_draw_label_dsc_t * draw_label_dsc = lv_draw_task_get_label_dsc(t);
 800b71a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800b71c:	f001 fbe0 	bl	800cee0 <lv_draw_task_get_label_dsc>
 800b720:	60f8      	str	r0, [r7, #12]
            if(draw_label_dsc && draw_label_dsc->text_local) {
 800b722:	68fb      	ldr	r3, [r7, #12]
 800b724:	2b00      	cmp	r3, #0
 800b726:	d00f      	beq.n	800b748 <lv_draw_dispatch_layer+0x128>
 800b728:	68fb      	ldr	r3, [r7, #12]
 800b72a:	f893 304c 	ldrb.w	r3, [r3, #76]	@ 0x4c
 800b72e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800b732:	b2db      	uxtb	r3, r3
 800b734:	2b00      	cmp	r3, #0
 800b736:	d007      	beq.n	800b748 <lv_draw_dispatch_layer+0x128>
                lv_free((void *)draw_label_dsc->text);
 800b738:	68fb      	ldr	r3, [r7, #12]
 800b73a:	69db      	ldr	r3, [r3, #28]
 800b73c:	4618      	mov	r0, r3
 800b73e:	f01a fb7b 	bl	8025e38 <lv_free>
                draw_label_dsc->text = NULL;
 800b742:	68fb      	ldr	r3, [r7, #12]
 800b744:	2200      	movs	r2, #0
 800b746:	61da      	str	r2, [r3, #28]
            }

            lv_free(t->draw_dsc);
 800b748:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b74a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800b74c:	4618      	mov	r0, r3
 800b74e:	f01a fb73 	bl	8025e38 <lv_free>
            lv_free(t);
 800b752:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800b754:	f01a fb70 	bl	8025e38 <lv_free>
 800b758:	e001      	b.n	800b75e <lv_draw_dispatch_layer+0x13e>
        }
        else {
            t_prev = t;
 800b75a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b75c:	647b      	str	r3, [r7, #68]	@ 0x44
        }
        t = t_next;
 800b75e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b760:	643b      	str	r3, [r7, #64]	@ 0x40
    while(t) {
 800b762:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800b764:	2b00      	cmp	r3, #0
 800b766:	f47f af66 	bne.w	800b636 <lv_draw_dispatch_layer+0x16>
    }

    bool render_running = false;
 800b76a:	2300      	movs	r3, #0
 800b76c:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b

    /*This layer is ready, enable blending its buffer*/
    if(layer->parent && layer->all_tasks_added && layer->draw_task_head == NULL) {
 800b770:	683b      	ldr	r3, [r7, #0]
 800b772:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b774:	2b00      	cmp	r3, #0
 800b776:	d02b      	beq.n	800b7d0 <lv_draw_dispatch_layer+0x1b0>
 800b778:	683b      	ldr	r3, [r7, #0]
 800b77a:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 800b77e:	2b00      	cmp	r3, #0
 800b780:	d026      	beq.n	800b7d0 <lv_draw_dispatch_layer+0x1b0>
 800b782:	683b      	ldr	r3, [r7, #0]
 800b784:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b786:	2b00      	cmp	r3, #0
 800b788:	d122      	bne.n	800b7d0 <lv_draw_dispatch_layer+0x1b0>
        /*Find a draw task with TYPE_LAYER in the layer where the src is this layer*/
        lv_draw_task_t * t_src = layer->parent->draw_task_head;
 800b78a:	683b      	ldr	r3, [r7, #0]
 800b78c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b78e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b790:	637b      	str	r3, [r7, #52]	@ 0x34
        while(t_src) {
 800b792:	e019      	b.n	800b7c8 <lv_draw_dispatch_layer+0x1a8>
            if(t_src->type == LV_DRAW_TASK_TYPE_LAYER && t_src->state == LV_DRAW_TASK_STATE_WAITING) {
 800b794:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b796:	791b      	ldrb	r3, [r3, #4]
 800b798:	2b05      	cmp	r3, #5
 800b79a:	d112      	bne.n	800b7c2 <lv_draw_dispatch_layer+0x1a2>
 800b79c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b79e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800b7a0:	2b00      	cmp	r3, #0
 800b7a2:	d10e      	bne.n	800b7c2 <lv_draw_dispatch_layer+0x1a2>
                lv_draw_image_dsc_t * draw_dsc = t_src->draw_dsc;
 800b7a4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b7a6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800b7a8:	62fb      	str	r3, [r7, #44]	@ 0x2c
                if(draw_dsc->src == layer) {
 800b7aa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800b7ac:	69db      	ldr	r3, [r3, #28]
 800b7ae:	683a      	ldr	r2, [r7, #0]
 800b7b0:	429a      	cmp	r2, r3
 800b7b2:	d106      	bne.n	800b7c2 <lv_draw_dispatch_layer+0x1a2>
                    t_src->state = LV_DRAW_TASK_STATE_QUEUED;
 800b7b4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b7b6:	2201      	movs	r2, #1
 800b7b8:	649a      	str	r2, [r3, #72]	@ 0x48
                    lv_draw_dispatch_request();
 800b7ba:	f000 f829 	bl	800b810 <lv_draw_dispatch_request>
                    break;
 800b7be:	bf00      	nop
    if(layer->parent && layer->all_tasks_added && layer->draw_task_head == NULL) {
 800b7c0:	e01d      	b.n	800b7fe <lv_draw_dispatch_layer+0x1de>
                }
            }
            t_src = t_src->next;
 800b7c2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b7c4:	681b      	ldr	r3, [r3, #0]
 800b7c6:	637b      	str	r3, [r7, #52]	@ 0x34
        while(t_src) {
 800b7c8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800b7ca:	2b00      	cmp	r3, #0
 800b7cc:	d1e2      	bne.n	800b794 <lv_draw_dispatch_layer+0x174>
    if(layer->parent && layer->all_tasks_added && layer->draw_task_head == NULL) {
 800b7ce:	e016      	b.n	800b7fe <lv_draw_dispatch_layer+0x1de>
    }
    /*Assign draw tasks to the draw_units*/
    else {
        /*Find a draw unit which is not busy and can take at least one task*/
        /*Let all draw units to pick draw tasks*/
        lv_draw_unit_t * u = _draw_info.unit_head;
 800b7d0:	4b0e      	ldr	r3, [pc, #56]	@ (800b80c <lv_draw_dispatch_layer+0x1ec>)
 800b7d2:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 800b7d6:	633b      	str	r3, [r7, #48]	@ 0x30
        while(u) {
 800b7d8:	e00e      	b.n	800b7f8 <lv_draw_dispatch_layer+0x1d8>
            int32_t taken_cnt = u->dispatch_cb(u, layer);
 800b7da:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800b7dc:	68db      	ldr	r3, [r3, #12]
 800b7de:	6839      	ldr	r1, [r7, #0]
 800b7e0:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 800b7e2:	4798      	blx	r3
 800b7e4:	62b8      	str	r0, [r7, #40]	@ 0x28
            if(taken_cnt >= 0) render_running = true;
 800b7e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800b7e8:	2b00      	cmp	r3, #0
 800b7ea:	db02      	blt.n	800b7f2 <lv_draw_dispatch_layer+0x1d2>
 800b7ec:	2301      	movs	r3, #1
 800b7ee:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
            u = u->next;
 800b7f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800b7f4:	681b      	ldr	r3, [r3, #0]
 800b7f6:	633b      	str	r3, [r7, #48]	@ 0x30
        while(u) {
 800b7f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800b7fa:	2b00      	cmp	r3, #0
 800b7fc:	d1ed      	bne.n	800b7da <lv_draw_dispatch_layer+0x1ba>
        }
    }

    LV_PROFILER_END;
    return render_running;
 800b7fe:	f897 303b 	ldrb.w	r3, [r7, #59]	@ 0x3b
}
 800b802:	4618      	mov	r0, r3
 800b804:	3748      	adds	r7, #72	@ 0x48
 800b806:	46bd      	mov	sp, r7
 800b808:	bd80      	pop	{r7, pc}
 800b80a:	bf00      	nop
 800b80c:	2000009c 	.word	0x2000009c

0800b810 <lv_draw_dispatch_request>:
    _draw_info.dispatch_req = 0;
#endif
}

void lv_draw_dispatch_request(void)
{
 800b810:	b480      	push	{r7}
 800b812:	af00      	add	r7, sp, #0
#if LV_USE_OS
    lv_thread_sync_signal(&_draw_info.sync);
#else
    _draw_info.dispatch_req = 1;
 800b814:	4b04      	ldr	r3, [pc, #16]	@ (800b828 <lv_draw_dispatch_request+0x18>)
 800b816:	2201      	movs	r2, #1
 800b818:	f8c3 20fc 	str.w	r2, [r3, #252]	@ 0xfc
#endif
}
 800b81c:	bf00      	nop
 800b81e:	46bd      	mov	sp, r7
 800b820:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b824:	4770      	bx	lr
 800b826:	bf00      	nop
 800b828:	2000009c 	.word	0x2000009c

0800b82c <lv_draw_get_next_available_task>:

lv_draw_task_t * lv_draw_get_next_available_task(lv_layer_t * layer, lv_draw_task_t * t_prev, uint8_t draw_unit_id)
{
 800b82c:	b580      	push	{r7, lr}
 800b82e:	b088      	sub	sp, #32
 800b830:	af00      	add	r7, sp, #0
 800b832:	60f8      	str	r0, [r7, #12]
 800b834:	60b9      	str	r1, [r7, #8]
 800b836:	4613      	mov	r3, r2
 800b838:	71fb      	strb	r3, [r7, #7]
    LV_PROFILER_BEGIN;
    /*If the first task is screen sized, there cannot be independent areas*/
    if(layer->draw_task_head) {
 800b83a:	68fb      	ldr	r3, [r7, #12]
 800b83c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b83e:	2b00      	cmp	r3, #0
 800b840:	d02a      	beq.n	800b898 <lv_draw_get_next_available_task+0x6c>
        int32_t hor_res = lv_display_get_horizontal_resolution(_lv_refr_get_disp_refreshing());
 800b842:	f7ff fc33 	bl	800b0ac <_lv_refr_get_disp_refreshing>
 800b846:	4603      	mov	r3, r0
 800b848:	4618      	mov	r0, r3
 800b84a:	f7ff fc6d 	bl	800b128 <lv_display_get_horizontal_resolution>
 800b84e:	61b8      	str	r0, [r7, #24]
        int32_t ver_res = lv_display_get_vertical_resolution(_lv_refr_get_disp_refreshing());
 800b850:	f7ff fc2c 	bl	800b0ac <_lv_refr_get_disp_refreshing>
 800b854:	4603      	mov	r3, r0
 800b856:	4618      	mov	r0, r3
 800b858:	f7ff fc88 	bl	800b16c <lv_display_get_vertical_resolution>
 800b85c:	6178      	str	r0, [r7, #20]
        lv_draw_task_t * t = layer->draw_task_head;
 800b85e:	68fb      	ldr	r3, [r7, #12]
 800b860:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b862:	613b      	str	r3, [r7, #16]
        if(t->state != LV_DRAW_TASK_STATE_QUEUED &&
 800b864:	693b      	ldr	r3, [r7, #16]
 800b866:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800b868:	2b01      	cmp	r3, #1
 800b86a:	d015      	beq.n	800b898 <lv_draw_get_next_available_task+0x6c>
           t->area.x1 <= 0 && t->area.x2 >= hor_res - 1 &&
 800b86c:	693b      	ldr	r3, [r7, #16]
 800b86e:	689b      	ldr	r3, [r3, #8]
        if(t->state != LV_DRAW_TASK_STATE_QUEUED &&
 800b870:	2b00      	cmp	r3, #0
 800b872:	dc11      	bgt.n	800b898 <lv_draw_get_next_available_task+0x6c>
           t->area.x1 <= 0 && t->area.x2 >= hor_res - 1 &&
 800b874:	693b      	ldr	r3, [r7, #16]
 800b876:	691a      	ldr	r2, [r3, #16]
 800b878:	69bb      	ldr	r3, [r7, #24]
 800b87a:	3b01      	subs	r3, #1
 800b87c:	429a      	cmp	r2, r3
 800b87e:	db0b      	blt.n	800b898 <lv_draw_get_next_available_task+0x6c>
           t->area.y1 <= 0 && t->area.y2 >= ver_res - 1) {
 800b880:	693b      	ldr	r3, [r7, #16]
 800b882:	68db      	ldr	r3, [r3, #12]
           t->area.x1 <= 0 && t->area.x2 >= hor_res - 1 &&
 800b884:	2b00      	cmp	r3, #0
 800b886:	dc07      	bgt.n	800b898 <lv_draw_get_next_available_task+0x6c>
           t->area.y1 <= 0 && t->area.y2 >= ver_res - 1) {
 800b888:	693b      	ldr	r3, [r7, #16]
 800b88a:	695a      	ldr	r2, [r3, #20]
 800b88c:	697b      	ldr	r3, [r7, #20]
 800b88e:	3b01      	subs	r3, #1
 800b890:	429a      	cmp	r2, r3
 800b892:	db01      	blt.n	800b898 <lv_draw_get_next_available_task+0x6c>
            LV_PROFILER_END;
            return NULL;
 800b894:	2300      	movs	r3, #0
 800b896:	e028      	b.n	800b8ea <lv_draw_get_next_available_task+0xbe>
        }
    }

    lv_draw_task_t * t = t_prev ? t_prev->next : layer->draw_task_head;
 800b898:	68bb      	ldr	r3, [r7, #8]
 800b89a:	2b00      	cmp	r3, #0
 800b89c:	d002      	beq.n	800b8a4 <lv_draw_get_next_available_task+0x78>
 800b89e:	68bb      	ldr	r3, [r7, #8]
 800b8a0:	681b      	ldr	r3, [r3, #0]
 800b8a2:	e001      	b.n	800b8a8 <lv_draw_get_next_available_task+0x7c>
 800b8a4:	68fb      	ldr	r3, [r7, #12]
 800b8a6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b8a8:	61fb      	str	r3, [r7, #28]
    while(t) {
 800b8aa:	e01a      	b.n	800b8e2 <lv_draw_get_next_available_task+0xb6>
        /*Find a queued and independent task*/
        if(t->state == LV_DRAW_TASK_STATE_QUEUED &&
 800b8ac:	69fb      	ldr	r3, [r7, #28]
 800b8ae:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800b8b0:	2b01      	cmp	r3, #1
 800b8b2:	d113      	bne.n	800b8dc <lv_draw_get_next_available_task+0xb0>
           (t->preferred_draw_unit_id == LV_DRAW_UNIT_ID_ANY || t->preferred_draw_unit_id == draw_unit_id) &&
 800b8b4:	69fb      	ldr	r3, [r7, #28]
 800b8b6:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
        if(t->state == LV_DRAW_TASK_STATE_QUEUED &&
 800b8ba:	2b00      	cmp	r3, #0
 800b8bc:	d005      	beq.n	800b8ca <lv_draw_get_next_available_task+0x9e>
           (t->preferred_draw_unit_id == LV_DRAW_UNIT_ID_ANY || t->preferred_draw_unit_id == draw_unit_id) &&
 800b8be:	69fb      	ldr	r3, [r7, #28]
 800b8c0:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 800b8c4:	79fa      	ldrb	r2, [r7, #7]
 800b8c6:	429a      	cmp	r2, r3
 800b8c8:	d108      	bne.n	800b8dc <lv_draw_get_next_available_task+0xb0>
           is_independent(layer, t)) {
 800b8ca:	69f9      	ldr	r1, [r7, #28]
 800b8cc:	68f8      	ldr	r0, [r7, #12]
 800b8ce:	f000 f879 	bl	800b9c4 <is_independent>
 800b8d2:	4603      	mov	r3, r0
           (t->preferred_draw_unit_id == LV_DRAW_UNIT_ID_ANY || t->preferred_draw_unit_id == draw_unit_id) &&
 800b8d4:	2b00      	cmp	r3, #0
 800b8d6:	d001      	beq.n	800b8dc <lv_draw_get_next_available_task+0xb0>
            LV_PROFILER_END;
            return t;
 800b8d8:	69fb      	ldr	r3, [r7, #28]
 800b8da:	e006      	b.n	800b8ea <lv_draw_get_next_available_task+0xbe>
        }
        t = t->next;
 800b8dc:	69fb      	ldr	r3, [r7, #28]
 800b8de:	681b      	ldr	r3, [r3, #0]
 800b8e0:	61fb      	str	r3, [r7, #28]
    while(t) {
 800b8e2:	69fb      	ldr	r3, [r7, #28]
 800b8e4:	2b00      	cmp	r3, #0
 800b8e6:	d1e1      	bne.n	800b8ac <lv_draw_get_next_available_task+0x80>
    }

    LV_PROFILER_END;
    return NULL;
 800b8e8:	2300      	movs	r3, #0
}
 800b8ea:	4618      	mov	r0, r3
 800b8ec:	3720      	adds	r7, #32
 800b8ee:	46bd      	mov	sp, r7
 800b8f0:	bd80      	pop	{r7, pc}
	...

0800b8f4 <lv_draw_layer_alloc_buf>:

    return new_layer;
}

void * lv_draw_layer_alloc_buf(lv_layer_t * layer)
{
 800b8f4:	b580      	push	{r7, lr}
 800b8f6:	b086      	sub	sp, #24
 800b8f8:	af00      	add	r7, sp, #0
 800b8fa:	6078      	str	r0, [r7, #4]
    /*If the buffer of the layer is already allocated return it*/
    if(layer->draw_buf != NULL) {
 800b8fc:	687b      	ldr	r3, [r7, #4]
 800b8fe:	681b      	ldr	r3, [r3, #0]
 800b900:	2b00      	cmp	r3, #0
 800b902:	d003      	beq.n	800b90c <lv_draw_layer_alloc_buf+0x18>
        return layer->draw_buf->data;
 800b904:	687b      	ldr	r3, [r7, #4]
 800b906:	681b      	ldr	r3, [r3, #0]
 800b908:	691b      	ldr	r3, [r3, #16]
 800b90a:	e043      	b.n	800b994 <lv_draw_layer_alloc_buf+0xa0>
    }

    /*If the buffer of the layer is not allocated yet, allocate it now*/
    int32_t w = lv_area_get_width(&layer->buf_area);
 800b90c:	687b      	ldr	r3, [r7, #4]
 800b90e:	3304      	adds	r3, #4
 800b910:	4618      	mov	r0, r3
 800b912:	f7ff fd53 	bl	800b3bc <lv_area_get_width>
 800b916:	6178      	str	r0, [r7, #20]
    int32_t h = lv_area_get_height(&layer->buf_area);
 800b918:	687b      	ldr	r3, [r7, #4]
 800b91a:	3304      	adds	r3, #4
 800b91c:	4618      	mov	r0, r3
 800b91e:	f7ff fd5d 	bl	800b3dc <lv_area_get_height>
 800b922:	6138      	str	r0, [r7, #16]
    uint32_t layer_size_byte = h * lv_draw_buf_width_to_stride(w, layer->color_format);
 800b924:	697a      	ldr	r2, [r7, #20]
 800b926:	687b      	ldr	r3, [r7, #4]
 800b928:	7d1b      	ldrb	r3, [r3, #20]
 800b92a:	4619      	mov	r1, r3
 800b92c:	4610      	mov	r0, r2
 800b92e:	f000 f949 	bl	800bbc4 <lv_draw_buf_width_to_stride>
 800b932:	4602      	mov	r2, r0
 800b934:	693b      	ldr	r3, [r7, #16]
 800b936:	fb02 f303 	mul.w	r3, r2, r3
 800b93a:	60fb      	str	r3, [r7, #12]

    layer->draw_buf = lv_draw_buf_create(w, h, layer->color_format, 0);
 800b93c:	6978      	ldr	r0, [r7, #20]
 800b93e:	6939      	ldr	r1, [r7, #16]
 800b940:	687b      	ldr	r3, [r7, #4]
 800b942:	7d1a      	ldrb	r2, [r3, #20]
 800b944:	2300      	movs	r3, #0
 800b946:	f000 fa5f 	bl	800be08 <lv_draw_buf_create>
 800b94a:	4602      	mov	r2, r0
 800b94c:	687b      	ldr	r3, [r7, #4]
 800b94e:	601a      	str	r2, [r3, #0]

    if(layer->draw_buf == NULL) {
 800b950:	687b      	ldr	r3, [r7, #4]
 800b952:	681b      	ldr	r3, [r3, #0]
 800b954:	2b00      	cmp	r3, #0
 800b956:	d101      	bne.n	800b95c <lv_draw_layer_alloc_buf+0x68>
        LV_LOG_WARN("Allocating layer buffer failed. Try later");
        return NULL;
 800b958:	2300      	movs	r3, #0
 800b95a:	e01b      	b.n	800b994 <lv_draw_layer_alloc_buf+0xa0>
    }

    _draw_info.used_memory_for_layers_kb += get_layer_size_kb(layer_size_byte);
 800b95c:	68f8      	ldr	r0, [r7, #12]
 800b95e:	f7ff fd4d 	bl	800b3fc <get_layer_size_kb>
 800b962:	4602      	mov	r2, r0
 800b964:	4b0d      	ldr	r3, [pc, #52]	@ (800b99c <lv_draw_layer_alloc_buf+0xa8>)
 800b966:	f8d3 30f8 	ldr.w	r3, [r3, #248]	@ 0xf8
 800b96a:	4413      	add	r3, r2
 800b96c:	4a0b      	ldr	r2, [pc, #44]	@ (800b99c <lv_draw_layer_alloc_buf+0xa8>)
 800b96e:	f8c2 30f8 	str.w	r3, [r2, #248]	@ 0xf8
    LV_LOG_INFO("Layer memory used: %" LV_PRIu32 " kB\n", _draw_info.used_memory_for_layers_kb);

    if(lv_color_format_has_alpha(layer->color_format)) {
 800b972:	687b      	ldr	r3, [r7, #4]
 800b974:	7d1b      	ldrb	r3, [r3, #20]
 800b976:	4618      	mov	r0, r3
 800b978:	f016 fe06 	bl	8022588 <lv_color_format_has_alpha>
 800b97c:	4603      	mov	r3, r0
 800b97e:	2b00      	cmp	r3, #0
 800b980:	d005      	beq.n	800b98e <lv_draw_layer_alloc_buf+0x9a>
        lv_draw_buf_clear(layer->draw_buf, NULL);
 800b982:	687b      	ldr	r3, [r7, #4]
 800b984:	681b      	ldr	r3, [r3, #0]
 800b986:	2100      	movs	r1, #0
 800b988:	4618      	mov	r0, r3
 800b98a:	f000 f953 	bl	800bc34 <lv_draw_buf_clear>
    }

    return layer->draw_buf->data;
 800b98e:	687b      	ldr	r3, [r7, #4]
 800b990:	681b      	ldr	r3, [r3, #0]
 800b992:	691b      	ldr	r3, [r3, #16]
}
 800b994:	4618      	mov	r0, r3
 800b996:	3718      	adds	r7, #24
 800b998:	46bd      	mov	sp, r7
 800b99a:	bd80      	pop	{r7, pc}
 800b99c:	2000009c 	.word	0x2000009c

0800b9a0 <lv_draw_layer_go_to_xy>:

void * lv_draw_layer_go_to_xy(lv_layer_t * layer, int32_t x, int32_t y)
{
 800b9a0:	b580      	push	{r7, lr}
 800b9a2:	b084      	sub	sp, #16
 800b9a4:	af00      	add	r7, sp, #0
 800b9a6:	60f8      	str	r0, [r7, #12]
 800b9a8:	60b9      	str	r1, [r7, #8]
 800b9aa:	607a      	str	r2, [r7, #4]
    return lv_draw_buf_goto_xy(layer->draw_buf, x, y);
 800b9ac:	68fb      	ldr	r3, [r7, #12]
 800b9ae:	681b      	ldr	r3, [r3, #0]
 800b9b0:	68b9      	ldr	r1, [r7, #8]
 800b9b2:	687a      	ldr	r2, [r7, #4]
 800b9b4:	4618      	mov	r0, r3
 800b9b6:	f000 fb18 	bl	800bfea <lv_draw_buf_goto_xy>
 800b9ba:	4603      	mov	r3, r0
}
 800b9bc:	4618      	mov	r0, r3
 800b9be:	3710      	adds	r7, #16
 800b9c0:	46bd      	mov	sp, r7
 800b9c2:	bd80      	pop	{r7, pc}

0800b9c4 <is_independent>:
 * @param layer      the draw ctx to search in
 * @param t_check       check this task if it overlaps with the older ones
 * @return              true: `t_check` is not overlapping with older tasks so it's independent
 */
static bool is_independent(lv_layer_t * layer, lv_draw_task_t * t_check)
{
 800b9c4:	b580      	push	{r7, lr}
 800b9c6:	b088      	sub	sp, #32
 800b9c8:	af00      	add	r7, sp, #0
 800b9ca:	6078      	str	r0, [r7, #4]
 800b9cc:	6039      	str	r1, [r7, #0]
    LV_PROFILER_BEGIN;
    lv_draw_task_t * t = layer->draw_task_head;
 800b9ce:	687b      	ldr	r3, [r7, #4]
 800b9d0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b9d2:	61fb      	str	r3, [r7, #28]

    /*If t_check is outside of the older tasks then it's independent*/
    while(t && t != t_check) {
 800b9d4:	e016      	b.n	800ba04 <is_independent+0x40>
        if(t->state != LV_DRAW_TASK_STATE_READY) {
 800b9d6:	69fb      	ldr	r3, [r7, #28]
 800b9d8:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800b9da:	2b03      	cmp	r3, #3
 800b9dc:	d00f      	beq.n	800b9fe <is_independent+0x3a>
            lv_area_t a;
            if(_lv_area_intersect(&a, &t->_real_area, &t_check->_real_area)) {
 800b9de:	69fb      	ldr	r3, [r7, #28]
 800b9e0:	f103 0118 	add.w	r1, r3, #24
 800b9e4:	683b      	ldr	r3, [r7, #0]
 800b9e6:	f103 0218 	add.w	r2, r3, #24
 800b9ea:	f107 030c 	add.w	r3, r7, #12
 800b9ee:	4618      	mov	r0, r3
 800b9f0:	f015 ffaa 	bl	8021948 <_lv_area_intersect>
 800b9f4:	4603      	mov	r3, r0
 800b9f6:	2b00      	cmp	r3, #0
 800b9f8:	d001      	beq.n	800b9fe <is_independent+0x3a>
                LV_PROFILER_END;
                return false;
 800b9fa:	2300      	movs	r3, #0
 800b9fc:	e00a      	b.n	800ba14 <is_independent+0x50>
            }
        }
        t = t->next;
 800b9fe:	69fb      	ldr	r3, [r7, #28]
 800ba00:	681b      	ldr	r3, [r3, #0]
 800ba02:	61fb      	str	r3, [r7, #28]
    while(t && t != t_check) {
 800ba04:	69fb      	ldr	r3, [r7, #28]
 800ba06:	2b00      	cmp	r3, #0
 800ba08:	d003      	beq.n	800ba12 <is_independent+0x4e>
 800ba0a:	69fa      	ldr	r2, [r7, #28]
 800ba0c:	683b      	ldr	r3, [r7, #0]
 800ba0e:	429a      	cmp	r2, r3
 800ba10:	d1e1      	bne.n	800b9d6 <is_independent+0x12>
    }
    LV_PROFILER_END;

    return true;
 800ba12:	2301      	movs	r3, #1
}
 800ba14:	4618      	mov	r0, r3
 800ba16:	3720      	adds	r7, #32
 800ba18:	46bd      	mov	sp, r7
 800ba1a:	bd80      	pop	{r7, pc}

0800ba1c <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline int32_t lv_area_get_width(const lv_area_t * area_p)
{
 800ba1c:	b480      	push	{r7}
 800ba1e:	b083      	sub	sp, #12
 800ba20:	af00      	add	r7, sp, #0
 800ba22:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 800ba24:	687b      	ldr	r3, [r7, #4]
 800ba26:	689a      	ldr	r2, [r3, #8]
 800ba28:	687b      	ldr	r3, [r7, #4]
 800ba2a:	681b      	ldr	r3, [r3, #0]
 800ba2c:	1ad3      	subs	r3, r2, r3
 800ba2e:	3301      	adds	r3, #1
}
 800ba30:	4618      	mov	r0, r3
 800ba32:	370c      	adds	r7, #12
 800ba34:	46bd      	mov	sp, r7
 800ba36:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ba3a:	4770      	bx	lr

0800ba3c <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline int32_t lv_area_get_height(const lv_area_t * area_p)
{
 800ba3c:	b480      	push	{r7}
 800ba3e:	b083      	sub	sp, #12
 800ba40:	af00      	add	r7, sp, #0
 800ba42:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 800ba44:	687b      	ldr	r3, [r7, #4]
 800ba46:	68da      	ldr	r2, [r3, #12]
 800ba48:	687b      	ldr	r3, [r7, #4]
 800ba4a:	685b      	ldr	r3, [r3, #4]
 800ba4c:	1ad3      	subs	r3, r2, r3
 800ba4e:	3301      	adds	r3, #1
}
 800ba50:	4618      	mov	r0, r3
 800ba52:	370c      	adds	r7, #12
 800ba54:	46bd      	mov	sp, r7
 800ba56:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ba5a:	4770      	bx	lr

0800ba5c <lv_color_format_get_size>:
 * Get the pixel size of a color format in bytes
 * @param src_cf    a color format (`LV_COLOR_FORMAT_...`)
 * @return          the pixel size in bytes
 */
static inline uint8_t lv_color_format_get_size(lv_color_format_t cf)
{
 800ba5c:	b580      	push	{r7, lr}
 800ba5e:	b082      	sub	sp, #8
 800ba60:	af00      	add	r7, sp, #0
 800ba62:	4603      	mov	r3, r0
 800ba64:	71fb      	strb	r3, [r7, #7]
    return (lv_color_format_get_bpp(cf) + 7) >> 3;
 800ba66:	79fb      	ldrb	r3, [r7, #7]
 800ba68:	4618      	mov	r0, r3
 800ba6a:	f016 fd4d 	bl	8022508 <lv_color_format_get_bpp>
 800ba6e:	4603      	mov	r3, r0
 800ba70:	3307      	adds	r3, #7
 800ba72:	10db      	asrs	r3, r3, #3
 800ba74:	b2db      	uxtb	r3, r3
}
 800ba76:	4618      	mov	r0, r3
 800ba78:	3708      	adds	r7, #8
 800ba7a:	46bd      	mov	sp, r7
 800ba7c:	bd80      	pop	{r7, pc}

0800ba7e <lv_color_premultiply>:
{
    return lv_color_make(0x00, 0x00, 0x00);
}

static inline void lv_color_premultiply(lv_color32_t * c)
{
 800ba7e:	b480      	push	{r7}
 800ba80:	b083      	sub	sp, #12
 800ba82:	af00      	add	r7, sp, #0
 800ba84:	6078      	str	r0, [r7, #4]
    c->red = LV_OPA_MIX2(c->red, c->alpha);
 800ba86:	687b      	ldr	r3, [r7, #4]
 800ba88:	789b      	ldrb	r3, [r3, #2]
 800ba8a:	461a      	mov	r2, r3
 800ba8c:	687b      	ldr	r3, [r7, #4]
 800ba8e:	78db      	ldrb	r3, [r3, #3]
 800ba90:	fb02 f303 	mul.w	r3, r2, r3
 800ba94:	121b      	asrs	r3, r3, #8
 800ba96:	b2da      	uxtb	r2, r3
 800ba98:	687b      	ldr	r3, [r7, #4]
 800ba9a:	709a      	strb	r2, [r3, #2]
    c->green = LV_OPA_MIX2(c->green, c->alpha);
 800ba9c:	687b      	ldr	r3, [r7, #4]
 800ba9e:	785b      	ldrb	r3, [r3, #1]
 800baa0:	461a      	mov	r2, r3
 800baa2:	687b      	ldr	r3, [r7, #4]
 800baa4:	78db      	ldrb	r3, [r3, #3]
 800baa6:	fb02 f303 	mul.w	r3, r2, r3
 800baaa:	121b      	asrs	r3, r3, #8
 800baac:	b2da      	uxtb	r2, r3
 800baae:	687b      	ldr	r3, [r7, #4]
 800bab0:	705a      	strb	r2, [r3, #1]
    c->blue = LV_OPA_MIX2(c->blue, c->alpha);
 800bab2:	687b      	ldr	r3, [r7, #4]
 800bab4:	781b      	ldrb	r3, [r3, #0]
 800bab6:	461a      	mov	r2, r3
 800bab8:	687b      	ldr	r3, [r7, #4]
 800baba:	78db      	ldrb	r3, [r3, #3]
 800babc:	fb02 f303 	mul.w	r3, r2, r3
 800bac0:	121b      	asrs	r3, r3, #8
 800bac2:	b2da      	uxtb	r2, r3
 800bac4:	687b      	ldr	r3, [r7, #4]
 800bac6:	701a      	strb	r2, [r3, #0]
}
 800bac8:	bf00      	nop
 800baca:	370c      	adds	r7, #12
 800bacc:	46bd      	mov	sp, r7
 800bace:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bad2:	4770      	bx	lr

0800bad4 <lv_color16_premultiply>:

static inline void lv_color16_premultiply(lv_color16_t * c, lv_opa_t a)
{
 800bad4:	b480      	push	{r7}
 800bad6:	b083      	sub	sp, #12
 800bad8:	af00      	add	r7, sp, #0
 800bada:	6078      	str	r0, [r7, #4]
 800badc:	460b      	mov	r3, r1
 800bade:	70fb      	strb	r3, [r7, #3]
    c->red = LV_OPA_MIX2(c->red, a);
 800bae0:	687b      	ldr	r3, [r7, #4]
 800bae2:	785b      	ldrb	r3, [r3, #1]
 800bae4:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 800bae8:	b2db      	uxtb	r3, r3
 800baea:	461a      	mov	r2, r3
 800baec:	78fb      	ldrb	r3, [r7, #3]
 800baee:	fb02 f303 	mul.w	r3, r2, r3
 800baf2:	121b      	asrs	r3, r3, #8
 800baf4:	f003 031f 	and.w	r3, r3, #31
 800baf8:	b2d9      	uxtb	r1, r3
 800bafa:	687a      	ldr	r2, [r7, #4]
 800bafc:	7853      	ldrb	r3, [r2, #1]
 800bafe:	f361 03c7 	bfi	r3, r1, #3, #5
 800bb02:	7053      	strb	r3, [r2, #1]
    c->green = LV_OPA_MIX2(c->green, a);
 800bb04:	687b      	ldr	r3, [r7, #4]
 800bb06:	881b      	ldrh	r3, [r3, #0]
 800bb08:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800bb0c:	b2db      	uxtb	r3, r3
 800bb0e:	461a      	mov	r2, r3
 800bb10:	78fb      	ldrb	r3, [r7, #3]
 800bb12:	fb02 f303 	mul.w	r3, r2, r3
 800bb16:	121b      	asrs	r3, r3, #8
 800bb18:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800bb1c:	b2d9      	uxtb	r1, r3
 800bb1e:	687a      	ldr	r2, [r7, #4]
 800bb20:	8813      	ldrh	r3, [r2, #0]
 800bb22:	f361 134a 	bfi	r3, r1, #5, #6
 800bb26:	8013      	strh	r3, [r2, #0]
    c->blue = LV_OPA_MIX2(c->blue, a);
 800bb28:	687b      	ldr	r3, [r7, #4]
 800bb2a:	781b      	ldrb	r3, [r3, #0]
 800bb2c:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800bb30:	b2db      	uxtb	r3, r3
 800bb32:	461a      	mov	r2, r3
 800bb34:	78fb      	ldrb	r3, [r7, #3]
 800bb36:	fb02 f303 	mul.w	r3, r2, r3
 800bb3a:	121b      	asrs	r3, r3, #8
 800bb3c:	f003 031f 	and.w	r3, r3, #31
 800bb40:	b2d9      	uxtb	r1, r3
 800bb42:	687a      	ldr	r2, [r7, #4]
 800bb44:	7813      	ldrb	r3, [r2, #0]
 800bb46:	f361 0304 	bfi	r3, r1, #0, #5
 800bb4a:	7013      	strb	r3, [r2, #0]
}
 800bb4c:	bf00      	nop
 800bb4e:	370c      	adds	r7, #12
 800bb50:	46bd      	mov	sp, r7
 800bb52:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb56:	4770      	bx	lr

0800bb58 <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 800bb58:	b580      	push	{r7, lr}
 800bb5a:	b082      	sub	sp, #8
 800bb5c:	af00      	add	r7, sp, #0
 800bb5e:	6078      	str	r0, [r7, #4]
 800bb60:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 800bb62:	683a      	ldr	r2, [r7, #0]
 800bb64:	2100      	movs	r1, #0
 800bb66:	6878      	ldr	r0, [r7, #4]
 800bb68:	f019 f95b 	bl	8024e22 <lv_memset>
}
 800bb6c:	bf00      	nop
 800bb6e:	3708      	adds	r7, #8
 800bb70:	46bd      	mov	sp, r7
 800bb72:	bd80      	pop	{r7, pc}

0800bb74 <_lv_draw_buf_init_handlers>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void _lv_draw_buf_init_handlers(void)
{
 800bb74:	b580      	push	{r7, lr}
 800bb76:	af00      	add	r7, sp, #0
    lv_memzero(&handlers, sizeof(lv_draw_buf_handlers_t));
 800bb78:	2114      	movs	r1, #20
 800bb7a:	480c      	ldr	r0, [pc, #48]	@ (800bbac <_lv_draw_buf_init_handlers+0x38>)
 800bb7c:	f7ff ffec 	bl	800bb58 <lv_memzero>
    handlers.buf_malloc_cb = buf_malloc;
 800bb80:	4b0b      	ldr	r3, [pc, #44]	@ (800bbb0 <_lv_draw_buf_init_handlers+0x3c>)
 800bb82:	4a0c      	ldr	r2, [pc, #48]	@ (800bbb4 <_lv_draw_buf_init_handlers+0x40>)
 800bb84:	f8c3 20d4 	str.w	r2, [r3, #212]	@ 0xd4
    handlers.buf_free_cb = buf_free;
 800bb88:	4b09      	ldr	r3, [pc, #36]	@ (800bbb0 <_lv_draw_buf_init_handlers+0x3c>)
 800bb8a:	4a0b      	ldr	r2, [pc, #44]	@ (800bbb8 <_lv_draw_buf_init_handlers+0x44>)
 800bb8c:	f8c3 20d8 	str.w	r2, [r3, #216]	@ 0xd8
    handlers.align_pointer_cb = buf_align;
 800bb90:	4b07      	ldr	r3, [pc, #28]	@ (800bbb0 <_lv_draw_buf_init_handlers+0x3c>)
 800bb92:	4a0a      	ldr	r2, [pc, #40]	@ (800bbbc <_lv_draw_buf_init_handlers+0x48>)
 800bb94:	f8c3 20dc 	str.w	r2, [r3, #220]	@ 0xdc
    handlers.invalidate_cache_cb = NULL;
 800bb98:	4b05      	ldr	r3, [pc, #20]	@ (800bbb0 <_lv_draw_buf_init_handlers+0x3c>)
 800bb9a:	2200      	movs	r2, #0
 800bb9c:	f8c3 20e0 	str.w	r2, [r3, #224]	@ 0xe0
    handlers.width_to_stride_cb = width_to_stride;
 800bba0:	4b03      	ldr	r3, [pc, #12]	@ (800bbb0 <_lv_draw_buf_init_handlers+0x3c>)
 800bba2:	4a07      	ldr	r2, [pc, #28]	@ (800bbc0 <_lv_draw_buf_init_handlers+0x4c>)
 800bba4:	f8c3 20e4 	str.w	r2, [r3, #228]	@ 0xe4
}
 800bba8:	bf00      	nop
 800bbaa:	bd80      	pop	{r7, pc}
 800bbac:	20000170 	.word	0x20000170
 800bbb0:	2000009c 	.word	0x2000009c
 800bbb4:	0800c41d 	.word	0x0800c41d
 800bbb8:	0800c43f 	.word	0x0800c43f
 800bbbc:	0800c455 	.word	0x0800c455
 800bbc0:	0800c487 	.word	0x0800c487

0800bbc4 <lv_draw_buf_width_to_stride>:
{
    return &handlers;
}

uint32_t lv_draw_buf_width_to_stride(uint32_t w, lv_color_format_t color_format)
{
 800bbc4:	b580      	push	{r7, lr}
 800bbc6:	b082      	sub	sp, #8
 800bbc8:	af00      	add	r7, sp, #0
 800bbca:	6078      	str	r0, [r7, #4]
 800bbcc:	460b      	mov	r3, r1
 800bbce:	70fb      	strb	r3, [r7, #3]
    if(handlers.width_to_stride_cb) return handlers.width_to_stride_cb(w, color_format);
 800bbd0:	4b09      	ldr	r3, [pc, #36]	@ (800bbf8 <lv_draw_buf_width_to_stride+0x34>)
 800bbd2:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800bbd6:	2b00      	cmp	r3, #0
 800bbd8:	d008      	beq.n	800bbec <lv_draw_buf_width_to_stride+0x28>
 800bbda:	4b07      	ldr	r3, [pc, #28]	@ (800bbf8 <lv_draw_buf_width_to_stride+0x34>)
 800bbdc:	f8d3 30e4 	ldr.w	r3, [r3, #228]	@ 0xe4
 800bbe0:	78fa      	ldrb	r2, [r7, #3]
 800bbe2:	4611      	mov	r1, r2
 800bbe4:	6878      	ldr	r0, [r7, #4]
 800bbe6:	4798      	blx	r3
 800bbe8:	4603      	mov	r3, r0
 800bbea:	e000      	b.n	800bbee <lv_draw_buf_width_to_stride+0x2a>
    else return 0;
 800bbec:	2300      	movs	r3, #0
}
 800bbee:	4618      	mov	r0, r3
 800bbf0:	3708      	adds	r7, #8
 800bbf2:	46bd      	mov	sp, r7
 800bbf4:	bd80      	pop	{r7, pc}
 800bbf6:	bf00      	nop
 800bbf8:	2000009c 	.word	0x2000009c

0800bbfc <lv_draw_buf_align>:

void * lv_draw_buf_align(void * data, lv_color_format_t color_format)
{
 800bbfc:	b580      	push	{r7, lr}
 800bbfe:	b082      	sub	sp, #8
 800bc00:	af00      	add	r7, sp, #0
 800bc02:	6078      	str	r0, [r7, #4]
 800bc04:	460b      	mov	r3, r1
 800bc06:	70fb      	strb	r3, [r7, #3]
    if(handlers.align_pointer_cb) return handlers.align_pointer_cb(data, color_format);
 800bc08:	4b09      	ldr	r3, [pc, #36]	@ (800bc30 <lv_draw_buf_align+0x34>)
 800bc0a:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 800bc0e:	2b00      	cmp	r3, #0
 800bc10:	d008      	beq.n	800bc24 <lv_draw_buf_align+0x28>
 800bc12:	4b07      	ldr	r3, [pc, #28]	@ (800bc30 <lv_draw_buf_align+0x34>)
 800bc14:	f8d3 30dc 	ldr.w	r3, [r3, #220]	@ 0xdc
 800bc18:	78fa      	ldrb	r2, [r7, #3]
 800bc1a:	4611      	mov	r1, r2
 800bc1c:	6878      	ldr	r0, [r7, #4]
 800bc1e:	4798      	blx	r3
 800bc20:	4603      	mov	r3, r0
 800bc22:	e000      	b.n	800bc26 <lv_draw_buf_align+0x2a>
    else return NULL;
 800bc24:	2300      	movs	r3, #0
}
 800bc26:	4618      	mov	r0, r3
 800bc28:	3708      	adds	r7, #8
 800bc2a:	46bd      	mov	sp, r7
 800bc2c:	bd80      	pop	{r7, pc}
 800bc2e:	bf00      	nop
 800bc30:	2000009c 	.word	0x2000009c

0800bc34 <lv_draw_buf_clear>:
        handlers.invalidate_cache_cb(draw_buf, area);
    }
}

void lv_draw_buf_clear(lv_draw_buf_t * draw_buf, const lv_area_t * a)
{
 800bc34:	b580      	push	{r7, lr}
 800bc36:	b08a      	sub	sp, #40	@ 0x28
 800bc38:	af00      	add	r7, sp, #0
 800bc3a:	6078      	str	r0, [r7, #4]
 800bc3c:	6039      	str	r1, [r7, #0]
    LV_ASSERT_NULL(draw_buf);
 800bc3e:	687b      	ldr	r3, [r7, #4]
 800bc40:	2b00      	cmp	r3, #0
 800bc42:	d101      	bne.n	800bc48 <lv_draw_buf_clear+0x14>
 800bc44:	bf00      	nop
 800bc46:	e7fd      	b.n	800bc44 <lv_draw_buf_clear+0x10>
    if(a && lv_area_get_width(a) < 0) return;
 800bc48:	683b      	ldr	r3, [r7, #0]
 800bc4a:	2b00      	cmp	r3, #0
 800bc4c:	d005      	beq.n	800bc5a <lv_draw_buf_clear+0x26>
 800bc4e:	6838      	ldr	r0, [r7, #0]
 800bc50:	f7ff fee4 	bl	800ba1c <lv_area_get_width>
 800bc54:	4603      	mov	r3, r0
 800bc56:	2b00      	cmp	r3, #0
 800bc58:	db4d      	blt.n	800bcf6 <lv_draw_buf_clear+0xc2>
    if(a && lv_area_get_height(a) < 0) return;
 800bc5a:	683b      	ldr	r3, [r7, #0]
 800bc5c:	2b00      	cmp	r3, #0
 800bc5e:	d005      	beq.n	800bc6c <lv_draw_buf_clear+0x38>
 800bc60:	6838      	ldr	r0, [r7, #0]
 800bc62:	f7ff feeb 	bl	800ba3c <lv_area_get_height>
 800bc66:	4603      	mov	r3, r0
 800bc68:	2b00      	cmp	r3, #0
 800bc6a:	db46      	blt.n	800bcfa <lv_draw_buf_clear+0xc6>

    const lv_image_header_t * header = &draw_buf->header;
 800bc6c:	687b      	ldr	r3, [r7, #4]
 800bc6e:	61fb      	str	r3, [r7, #28]
    uint32_t stride = header->stride;
 800bc70:	69fb      	ldr	r3, [r7, #28]
 800bc72:	891b      	ldrh	r3, [r3, #8]
 800bc74:	61bb      	str	r3, [r7, #24]

    if(a == NULL) {
 800bc76:	683b      	ldr	r3, [r7, #0]
 800bc78:	2b00      	cmp	r3, #0
 800bc7a:	d10c      	bne.n	800bc96 <lv_draw_buf_clear+0x62>
        lv_memzero(draw_buf->data, header->h * stride);
 800bc7c:	687b      	ldr	r3, [r7, #4]
 800bc7e:	691a      	ldr	r2, [r3, #16]
 800bc80:	69fb      	ldr	r3, [r7, #28]
 800bc82:	88db      	ldrh	r3, [r3, #6]
 800bc84:	4619      	mov	r1, r3
 800bc86:	69bb      	ldr	r3, [r7, #24]
 800bc88:	fb01 f303 	mul.w	r3, r1, r3
 800bc8c:	4619      	mov	r1, r3
 800bc8e:	4610      	mov	r0, r2
 800bc90:	f7ff ff62 	bl	800bb58 <lv_memzero>
 800bc94:	e032      	b.n	800bcfc <lv_draw_buf_clear+0xc8>
    }
    else {
        uint8_t * bufc;
        uint32_t line_length;
        int32_t start_y, end_y;
        uint8_t px_size = lv_color_format_get_size(header->cf);
 800bc96:	69fb      	ldr	r3, [r7, #28]
 800bc98:	785b      	ldrb	r3, [r3, #1]
 800bc9a:	4618      	mov	r0, r3
 800bc9c:	f7ff fede 	bl	800ba5c <lv_color_format_get_size>
 800bca0:	4603      	mov	r3, r0
 800bca2:	75fb      	strb	r3, [r7, #23]
        bufc = lv_draw_buf_goto_xy(draw_buf, a->x1, a->y1);
 800bca4:	683b      	ldr	r3, [r7, #0]
 800bca6:	681b      	ldr	r3, [r3, #0]
 800bca8:	4619      	mov	r1, r3
 800bcaa:	683b      	ldr	r3, [r7, #0]
 800bcac:	685b      	ldr	r3, [r3, #4]
 800bcae:	461a      	mov	r2, r3
 800bcb0:	6878      	ldr	r0, [r7, #4]
 800bcb2:	f000 f99a 	bl	800bfea <lv_draw_buf_goto_xy>
 800bcb6:	6278      	str	r0, [r7, #36]	@ 0x24
        line_length = lv_area_get_width(a) * px_size;
 800bcb8:	6838      	ldr	r0, [r7, #0]
 800bcba:	f7ff feaf 	bl	800ba1c <lv_area_get_width>
 800bcbe:	4602      	mov	r2, r0
 800bcc0:	7dfb      	ldrb	r3, [r7, #23]
 800bcc2:	fb02 f303 	mul.w	r3, r2, r3
 800bcc6:	613b      	str	r3, [r7, #16]
        start_y = a->y1;
 800bcc8:	683b      	ldr	r3, [r7, #0]
 800bcca:	685b      	ldr	r3, [r3, #4]
 800bccc:	623b      	str	r3, [r7, #32]
        end_y = a->y2;
 800bcce:	683b      	ldr	r3, [r7, #0]
 800bcd0:	68db      	ldr	r3, [r3, #12]
 800bcd2:	60fb      	str	r3, [r7, #12]
        for(; start_y <= end_y; start_y++) {
 800bcd4:	e00a      	b.n	800bcec <lv_draw_buf_clear+0xb8>
            lv_memzero(bufc, line_length);
 800bcd6:	6939      	ldr	r1, [r7, #16]
 800bcd8:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800bcda:	f7ff ff3d 	bl	800bb58 <lv_memzero>
            bufc += stride;
 800bcde:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800bce0:	69bb      	ldr	r3, [r7, #24]
 800bce2:	4413      	add	r3, r2
 800bce4:	627b      	str	r3, [r7, #36]	@ 0x24
        for(; start_y <= end_y; start_y++) {
 800bce6:	6a3b      	ldr	r3, [r7, #32]
 800bce8:	3301      	adds	r3, #1
 800bcea:	623b      	str	r3, [r7, #32]
 800bcec:	6a3a      	ldr	r2, [r7, #32]
 800bcee:	68fb      	ldr	r3, [r7, #12]
 800bcf0:	429a      	cmp	r2, r3
 800bcf2:	ddf0      	ble.n	800bcd6 <lv_draw_buf_clear+0xa2>
 800bcf4:	e002      	b.n	800bcfc <lv_draw_buf_clear+0xc8>
    if(a && lv_area_get_width(a) < 0) return;
 800bcf6:	bf00      	nop
 800bcf8:	e000      	b.n	800bcfc <lv_draw_buf_clear+0xc8>
    if(a && lv_area_get_height(a) < 0) return;
 800bcfa:	bf00      	nop
        }
    }
}
 800bcfc:	3728      	adds	r7, #40	@ 0x28
 800bcfe:	46bd      	mov	sp, r7
 800bd00:	bd80      	pop	{r7, pc}

0800bd02 <lv_draw_buf_copy>:

void lv_draw_buf_copy(lv_draw_buf_t * dest, const lv_area_t * dest_area,
                      const lv_draw_buf_t * src, const lv_area_t * src_area)
{
 800bd02:	b580      	push	{r7, lr}
 800bd04:	b08c      	sub	sp, #48	@ 0x30
 800bd06:	af00      	add	r7, sp, #0
 800bd08:	60f8      	str	r0, [r7, #12]
 800bd0a:	60b9      	str	r1, [r7, #8]
 800bd0c:	607a      	str	r2, [r7, #4]
 800bd0e:	603b      	str	r3, [r7, #0]
    uint8_t * dest_bufc;
    uint8_t * src_bufc;
    int32_t line_width;

    if(dest_area == NULL) line_width = dest->header.w;
 800bd10:	68bb      	ldr	r3, [r7, #8]
 800bd12:	2b00      	cmp	r3, #0
 800bd14:	d103      	bne.n	800bd1e <lv_draw_buf_copy+0x1c>
 800bd16:	68fb      	ldr	r3, [r7, #12]
 800bd18:	889b      	ldrh	r3, [r3, #4]
 800bd1a:	627b      	str	r3, [r7, #36]	@ 0x24
 800bd1c:	e003      	b.n	800bd26 <lv_draw_buf_copy+0x24>
    else line_width = lv_area_get_width(dest_area);
 800bd1e:	68b8      	ldr	r0, [r7, #8]
 800bd20:	f7ff fe7c 	bl	800ba1c <lv_area_get_width>
 800bd24:	6278      	str	r0, [r7, #36]	@ 0x24

    /*Check source and dest area have same width*/
    if((src_area == NULL && line_width != src->header.w) || \
 800bd26:	683b      	ldr	r3, [r7, #0]
 800bd28:	2b00      	cmp	r3, #0
 800bd2a:	d105      	bne.n	800bd38 <lv_draw_buf_copy+0x36>
 800bd2c:	687b      	ldr	r3, [r7, #4]
 800bd2e:	889b      	ldrh	r3, [r3, #4]
 800bd30:	461a      	mov	r2, r3
 800bd32:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800bd34:	4293      	cmp	r3, r2
 800bd36:	d109      	bne.n	800bd4c <lv_draw_buf_copy+0x4a>
 800bd38:	683b      	ldr	r3, [r7, #0]
 800bd3a:	2b00      	cmp	r3, #0
 800bd3c:	d008      	beq.n	800bd50 <lv_draw_buf_copy+0x4e>
       (src_area != NULL && line_width != lv_area_get_width(src_area))) {
 800bd3e:	6838      	ldr	r0, [r7, #0]
 800bd40:	f7ff fe6c 	bl	800ba1c <lv_area_get_width>
 800bd44:	4602      	mov	r2, r0
 800bd46:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800bd48:	4293      	cmp	r3, r2
 800bd4a:	d001      	beq.n	800bd50 <lv_draw_buf_copy+0x4e>
        LV_ASSERT_MSG(0, "Source and destination areas have different width");
 800bd4c:	bf00      	nop
 800bd4e:	e7fd      	b.n	800bd4c <lv_draw_buf_copy+0x4a>
        return;
    }

    if(src_area) src_bufc = lv_draw_buf_goto_xy(src, src_area->x1, src_area->y1);
 800bd50:	683b      	ldr	r3, [r7, #0]
 800bd52:	2b00      	cmp	r3, #0
 800bd54:	d00a      	beq.n	800bd6c <lv_draw_buf_copy+0x6a>
 800bd56:	683b      	ldr	r3, [r7, #0]
 800bd58:	681b      	ldr	r3, [r3, #0]
 800bd5a:	4619      	mov	r1, r3
 800bd5c:	683b      	ldr	r3, [r7, #0]
 800bd5e:	685b      	ldr	r3, [r3, #4]
 800bd60:	461a      	mov	r2, r3
 800bd62:	6878      	ldr	r0, [r7, #4]
 800bd64:	f000 f941 	bl	800bfea <lv_draw_buf_goto_xy>
 800bd68:	62b8      	str	r0, [r7, #40]	@ 0x28
 800bd6a:	e002      	b.n	800bd72 <lv_draw_buf_copy+0x70>
    else src_bufc = src->data;
 800bd6c:	687b      	ldr	r3, [r7, #4]
 800bd6e:	691b      	ldr	r3, [r3, #16]
 800bd70:	62bb      	str	r3, [r7, #40]	@ 0x28

    if(dest_area) dest_bufc = lv_draw_buf_goto_xy(dest, dest_area->x1, dest_area->y1);
 800bd72:	68bb      	ldr	r3, [r7, #8]
 800bd74:	2b00      	cmp	r3, #0
 800bd76:	d00a      	beq.n	800bd8e <lv_draw_buf_copy+0x8c>
 800bd78:	68bb      	ldr	r3, [r7, #8]
 800bd7a:	681b      	ldr	r3, [r3, #0]
 800bd7c:	4619      	mov	r1, r3
 800bd7e:	68bb      	ldr	r3, [r7, #8]
 800bd80:	685b      	ldr	r3, [r3, #4]
 800bd82:	461a      	mov	r2, r3
 800bd84:	68f8      	ldr	r0, [r7, #12]
 800bd86:	f000 f930 	bl	800bfea <lv_draw_buf_goto_xy>
 800bd8a:	62f8      	str	r0, [r7, #44]	@ 0x2c
 800bd8c:	e002      	b.n	800bd94 <lv_draw_buf_copy+0x92>
    else dest_bufc = dest->data;
 800bd8e:	68fb      	ldr	r3, [r7, #12]
 800bd90:	691b      	ldr	r3, [r3, #16]
 800bd92:	62fb      	str	r3, [r7, #44]	@ 0x2c

    int32_t start_y, end_y;
    if(dest_area) {
 800bd94:	68bb      	ldr	r3, [r7, #8]
 800bd96:	2b00      	cmp	r3, #0
 800bd98:	d006      	beq.n	800bda8 <lv_draw_buf_copy+0xa6>
        start_y = dest_area->y1;
 800bd9a:	68bb      	ldr	r3, [r7, #8]
 800bd9c:	685b      	ldr	r3, [r3, #4]
 800bd9e:	623b      	str	r3, [r7, #32]
        end_y = dest_area->y2;
 800bda0:	68bb      	ldr	r3, [r7, #8]
 800bda2:	68db      	ldr	r3, [r3, #12]
 800bda4:	61fb      	str	r3, [r7, #28]
 800bda6:	e005      	b.n	800bdb4 <lv_draw_buf_copy+0xb2>
    }
    else {
        start_y = 0;
 800bda8:	2300      	movs	r3, #0
 800bdaa:	623b      	str	r3, [r7, #32]
        end_y = dest->header.h - 1;
 800bdac:	68fb      	ldr	r3, [r7, #12]
 800bdae:	88db      	ldrh	r3, [r3, #6]
 800bdb0:	3b01      	subs	r3, #1
 800bdb2:	61fb      	str	r3, [r7, #28]
    }

    uint32_t dest_stride = dest->header.stride;
 800bdb4:	68fb      	ldr	r3, [r7, #12]
 800bdb6:	891b      	ldrh	r3, [r3, #8]
 800bdb8:	61bb      	str	r3, [r7, #24]
    uint32_t src_stride = src->header.stride;
 800bdba:	687b      	ldr	r3, [r7, #4]
 800bdbc:	891b      	ldrh	r3, [r3, #8]
 800bdbe:	617b      	str	r3, [r7, #20]
    line_width *= lv_color_format_get_size(dest->header.cf); /*Pixel to bytes*/
 800bdc0:	68fb      	ldr	r3, [r7, #12]
 800bdc2:	785b      	ldrb	r3, [r3, #1]
 800bdc4:	4618      	mov	r0, r3
 800bdc6:	f7ff fe49 	bl	800ba5c <lv_color_format_get_size>
 800bdca:	4603      	mov	r3, r0
 800bdcc:	461a      	mov	r2, r3
 800bdce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800bdd0:	fb02 f303 	mul.w	r3, r2, r3
 800bdd4:	627b      	str	r3, [r7, #36]	@ 0x24

    for(; start_y <= end_y; start_y++) {
 800bdd6:	e010      	b.n	800bdfa <lv_draw_buf_copy+0xf8>
        lv_memcpy(dest_bufc, src_bufc, line_width);
 800bdd8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800bdda:	461a      	mov	r2, r3
 800bddc:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800bdde:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800bde0:	f018 fe02 	bl	80249e8 <lv_memcpy>
        dest_bufc += dest_stride;
 800bde4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800bde6:	69bb      	ldr	r3, [r7, #24]
 800bde8:	4413      	add	r3, r2
 800bdea:	62fb      	str	r3, [r7, #44]	@ 0x2c
        src_bufc += src_stride;
 800bdec:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800bdee:	697b      	ldr	r3, [r7, #20]
 800bdf0:	4413      	add	r3, r2
 800bdf2:	62bb      	str	r3, [r7, #40]	@ 0x28
    for(; start_y <= end_y; start_y++) {
 800bdf4:	6a3b      	ldr	r3, [r7, #32]
 800bdf6:	3301      	adds	r3, #1
 800bdf8:	623b      	str	r3, [r7, #32]
 800bdfa:	6a3a      	ldr	r2, [r7, #32]
 800bdfc:	69fb      	ldr	r3, [r7, #28]
 800bdfe:	429a      	cmp	r2, r3
 800be00:	ddea      	ble.n	800bdd8 <lv_draw_buf_copy+0xd6>
    }
}
 800be02:	3730      	adds	r7, #48	@ 0x30
 800be04:	46bd      	mov	sp, r7
 800be06:	bd80      	pop	{r7, pc}

0800be08 <lv_draw_buf_create>:
    }
    return LV_RESULT_OK;
}

lv_draw_buf_t * lv_draw_buf_create(uint32_t w, uint32_t h, lv_color_format_t cf, uint32_t stride)
{
 800be08:	b580      	push	{r7, lr}
 800be0a:	b088      	sub	sp, #32
 800be0c:	af00      	add	r7, sp, #0
 800be0e:	60f8      	str	r0, [r7, #12]
 800be10:	60b9      	str	r1, [r7, #8]
 800be12:	603b      	str	r3, [r7, #0]
 800be14:	4613      	mov	r3, r2
 800be16:	71fb      	strb	r3, [r7, #7]
    lv_draw_buf_t * draw_buf = lv_malloc_zeroed(sizeof(lv_draw_buf_t));
 800be18:	2018      	movs	r0, #24
 800be1a:	f019 ffef 	bl	8025dfc <lv_malloc_zeroed>
 800be1e:	61f8      	str	r0, [r7, #28]
    LV_ASSERT_MALLOC(draw_buf);
 800be20:	69fb      	ldr	r3, [r7, #28]
 800be22:	2b00      	cmp	r3, #0
 800be24:	d101      	bne.n	800be2a <lv_draw_buf_create+0x22>
 800be26:	bf00      	nop
 800be28:	e7fd      	b.n	800be26 <lv_draw_buf_create+0x1e>
    if(draw_buf == NULL) return NULL;
 800be2a:	69fb      	ldr	r3, [r7, #28]
 800be2c:	2b00      	cmp	r3, #0
 800be2e:	d101      	bne.n	800be34 <lv_draw_buf_create+0x2c>
 800be30:	2300      	movs	r3, #0
 800be32:	e041      	b.n	800beb8 <lv_draw_buf_create+0xb0>
    if(stride == 0) stride = lv_draw_buf_width_to_stride(w, cf);
 800be34:	683b      	ldr	r3, [r7, #0]
 800be36:	2b00      	cmp	r3, #0
 800be38:	d105      	bne.n	800be46 <lv_draw_buf_create+0x3e>
 800be3a:	79fb      	ldrb	r3, [r7, #7]
 800be3c:	4619      	mov	r1, r3
 800be3e:	68f8      	ldr	r0, [r7, #12]
 800be40:	f7ff fec0 	bl	800bbc4 <lv_draw_buf_width_to_stride>
 800be44:	6038      	str	r0, [r7, #0]

    uint32_t size = _calculate_draw_buf_size(w, h, cf, stride);
 800be46:	79fa      	ldrb	r2, [r7, #7]
 800be48:	683b      	ldr	r3, [r7, #0]
 800be4a:	68b9      	ldr	r1, [r7, #8]
 800be4c:	68f8      	ldr	r0, [r7, #12]
 800be4e:	f000 fb63 	bl	800c518 <_calculate_draw_buf_size>
 800be52:	61b8      	str	r0, [r7, #24]

    void * buf = draw_buf_malloc(size, cf);
 800be54:	79fb      	ldrb	r3, [r7, #7]
 800be56:	4619      	mov	r1, r3
 800be58:	69b8      	ldr	r0, [r7, #24]
 800be5a:	f000 fb2d 	bl	800c4b8 <draw_buf_malloc>
 800be5e:	6178      	str	r0, [r7, #20]
    /*Do not assert here as LVGL or the app might just want to try creating a draw_buf*/
    if(buf == NULL) {
 800be60:	697b      	ldr	r3, [r7, #20]
 800be62:	2b00      	cmp	r3, #0
 800be64:	d104      	bne.n	800be70 <lv_draw_buf_create+0x68>
        LV_LOG_WARN("No memory: %"LV_PRIu32"x%"LV_PRIu32", cf: %d, stride: %"LV_PRIu32", %"LV_PRIu32"Byte, ",
                    w, h, cf, stride, size);
        lv_free(draw_buf);
 800be66:	69f8      	ldr	r0, [r7, #28]
 800be68:	f019 ffe6 	bl	8025e38 <lv_free>
        return NULL;
 800be6c:	2300      	movs	r3, #0
 800be6e:	e023      	b.n	800beb8 <lv_draw_buf_create+0xb0>
    }

    draw_buf->header.w = w;
 800be70:	68fb      	ldr	r3, [r7, #12]
 800be72:	b29a      	uxth	r2, r3
 800be74:	69fb      	ldr	r3, [r7, #28]
 800be76:	809a      	strh	r2, [r3, #4]
    draw_buf->header.h = h;
 800be78:	68bb      	ldr	r3, [r7, #8]
 800be7a:	b29a      	uxth	r2, r3
 800be7c:	69fb      	ldr	r3, [r7, #28]
 800be7e:	80da      	strh	r2, [r3, #6]
    draw_buf->header.cf = cf;
 800be80:	69fb      	ldr	r3, [r7, #28]
 800be82:	79fa      	ldrb	r2, [r7, #7]
 800be84:	705a      	strb	r2, [r3, #1]
    draw_buf->header.flags = LV_IMAGE_FLAGS_MODIFIABLE | LV_IMAGE_FLAGS_ALLOCATED;
 800be86:	69fb      	ldr	r3, [r7, #28]
 800be88:	2230      	movs	r2, #48	@ 0x30
 800be8a:	805a      	strh	r2, [r3, #2]
    draw_buf->header.stride = stride;
 800be8c:	683b      	ldr	r3, [r7, #0]
 800be8e:	b29a      	uxth	r2, r3
 800be90:	69fb      	ldr	r3, [r7, #28]
 800be92:	811a      	strh	r2, [r3, #8]
    draw_buf->header.magic = LV_IMAGE_HEADER_MAGIC;
 800be94:	69fb      	ldr	r3, [r7, #28]
 800be96:	2219      	movs	r2, #25
 800be98:	701a      	strb	r2, [r3, #0]
    draw_buf->data = lv_draw_buf_align(buf, cf);
 800be9a:	79fb      	ldrb	r3, [r7, #7]
 800be9c:	4619      	mov	r1, r3
 800be9e:	6978      	ldr	r0, [r7, #20]
 800bea0:	f7ff feac 	bl	800bbfc <lv_draw_buf_align>
 800bea4:	4602      	mov	r2, r0
 800bea6:	69fb      	ldr	r3, [r7, #28]
 800bea8:	611a      	str	r2, [r3, #16]
    draw_buf->unaligned_data = buf;
 800beaa:	69fb      	ldr	r3, [r7, #28]
 800beac:	697a      	ldr	r2, [r7, #20]
 800beae:	615a      	str	r2, [r3, #20]
    draw_buf->data_size = size;
 800beb0:	69fb      	ldr	r3, [r7, #28]
 800beb2:	69ba      	ldr	r2, [r7, #24]
 800beb4:	60da      	str	r2, [r3, #12]
    return draw_buf;
 800beb6:	69fb      	ldr	r3, [r7, #28]
}
 800beb8:	4618      	mov	r0, r3
 800beba:	3720      	adds	r7, #32
 800bebc:	46bd      	mov	sp, r7
 800bebe:	bd80      	pop	{r7, pc}

0800bec0 <lv_draw_buf_dup>:

lv_draw_buf_t * lv_draw_buf_dup(const lv_draw_buf_t * draw_buf)
{
 800bec0:	b580      	push	{r7, lr}
 800bec2:	b086      	sub	sp, #24
 800bec4:	af00      	add	r7, sp, #0
 800bec6:	6078      	str	r0, [r7, #4]
    const lv_image_header_t * header = &draw_buf->header;
 800bec8:	687b      	ldr	r3, [r7, #4]
 800beca:	617b      	str	r3, [r7, #20]
    lv_draw_buf_t * new_buf = lv_draw_buf_create(header->w, header->h, header->cf, header->stride);
 800becc:	697b      	ldr	r3, [r7, #20]
 800bece:	889b      	ldrh	r3, [r3, #4]
 800bed0:	4618      	mov	r0, r3
 800bed2:	697b      	ldr	r3, [r7, #20]
 800bed4:	88db      	ldrh	r3, [r3, #6]
 800bed6:	4619      	mov	r1, r3
 800bed8:	697b      	ldr	r3, [r7, #20]
 800beda:	785a      	ldrb	r2, [r3, #1]
 800bedc:	697b      	ldr	r3, [r7, #20]
 800bede:	891b      	ldrh	r3, [r3, #8]
 800bee0:	f7ff ff92 	bl	800be08 <lv_draw_buf_create>
 800bee4:	6138      	str	r0, [r7, #16]
    if(new_buf == NULL) return NULL;
 800bee6:	693b      	ldr	r3, [r7, #16]
 800bee8:	2b00      	cmp	r3, #0
 800beea:	d101      	bne.n	800bef0 <lv_draw_buf_dup+0x30>
 800beec:	2300      	movs	r3, #0
 800beee:	e01b      	b.n	800bf28 <lv_draw_buf_dup+0x68>

    new_buf->header.flags = draw_buf->header.flags;
 800bef0:	687b      	ldr	r3, [r7, #4]
 800bef2:	885a      	ldrh	r2, [r3, #2]
 800bef4:	693b      	ldr	r3, [r7, #16]
 800bef6:	805a      	strh	r2, [r3, #2]
    new_buf->header.flags |= LV_IMAGE_FLAGS_MODIFIABLE | LV_IMAGE_FLAGS_ALLOCATED;
 800bef8:	693b      	ldr	r3, [r7, #16]
 800befa:	885b      	ldrh	r3, [r3, #2]
 800befc:	f043 0330 	orr.w	r3, r3, #48	@ 0x30
 800bf00:	b29a      	uxth	r2, r3
 800bf02:	693b      	ldr	r3, [r7, #16]
 800bf04:	805a      	strh	r2, [r3, #2]

    /*Choose the smaller size to copy*/
    uint32_t size = LV_MIN(draw_buf->data_size, new_buf->data_size);
 800bf06:	693b      	ldr	r3, [r7, #16]
 800bf08:	68da      	ldr	r2, [r3, #12]
 800bf0a:	687b      	ldr	r3, [r7, #4]
 800bf0c:	68db      	ldr	r3, [r3, #12]
 800bf0e:	4293      	cmp	r3, r2
 800bf10:	bf28      	it	cs
 800bf12:	4613      	movcs	r3, r2
 800bf14:	60fb      	str	r3, [r7, #12]

    /*Copy image data*/
    lv_memcpy(new_buf->data, draw_buf->data, size);
 800bf16:	693b      	ldr	r3, [r7, #16]
 800bf18:	6918      	ldr	r0, [r3, #16]
 800bf1a:	687b      	ldr	r3, [r7, #4]
 800bf1c:	691b      	ldr	r3, [r3, #16]
 800bf1e:	68fa      	ldr	r2, [r7, #12]
 800bf20:	4619      	mov	r1, r3
 800bf22:	f018 fd61 	bl	80249e8 <lv_memcpy>
    return new_buf;
 800bf26:	693b      	ldr	r3, [r7, #16]
}
 800bf28:	4618      	mov	r0, r3
 800bf2a:	3718      	adds	r7, #24
 800bf2c:	46bd      	mov	sp, r7
 800bf2e:	bd80      	pop	{r7, pc}

0800bf30 <lv_draw_buf_reshape>:

lv_draw_buf_t * lv_draw_buf_reshape(lv_draw_buf_t * draw_buf, lv_color_format_t cf, uint32_t w, uint32_t h,
                                    uint32_t stride)
{
 800bf30:	b580      	push	{r7, lr}
 800bf32:	b086      	sub	sp, #24
 800bf34:	af00      	add	r7, sp, #0
 800bf36:	60f8      	str	r0, [r7, #12]
 800bf38:	607a      	str	r2, [r7, #4]
 800bf3a:	603b      	str	r3, [r7, #0]
 800bf3c:	460b      	mov	r3, r1
 800bf3e:	72fb      	strb	r3, [r7, #11]
    if(draw_buf == NULL) return NULL;
 800bf40:	68fb      	ldr	r3, [r7, #12]
 800bf42:	2b00      	cmp	r3, #0
 800bf44:	d101      	bne.n	800bf4a <lv_draw_buf_reshape+0x1a>
 800bf46:	2300      	movs	r3, #0
 800bf48:	e02c      	b.n	800bfa4 <lv_draw_buf_reshape+0x74>

    /*If color format is unknown, keep using the original color format.*/
    if(cf == LV_COLOR_FORMAT_UNKNOWN) cf = draw_buf->header.cf;
 800bf4a:	7afb      	ldrb	r3, [r7, #11]
 800bf4c:	2b00      	cmp	r3, #0
 800bf4e:	d102      	bne.n	800bf56 <lv_draw_buf_reshape+0x26>
 800bf50:	68fb      	ldr	r3, [r7, #12]
 800bf52:	785b      	ldrb	r3, [r3, #1]
 800bf54:	72fb      	strb	r3, [r7, #11]
    if(stride == 0) stride = lv_draw_buf_width_to_stride(w, cf);
 800bf56:	6a3b      	ldr	r3, [r7, #32]
 800bf58:	2b00      	cmp	r3, #0
 800bf5a:	d105      	bne.n	800bf68 <lv_draw_buf_reshape+0x38>
 800bf5c:	7afb      	ldrb	r3, [r7, #11]
 800bf5e:	4619      	mov	r1, r3
 800bf60:	6878      	ldr	r0, [r7, #4]
 800bf62:	f7ff fe2f 	bl	800bbc4 <lv_draw_buf_width_to_stride>
 800bf66:	6238      	str	r0, [r7, #32]

    uint32_t size = _calculate_draw_buf_size(w, h, cf, stride);
 800bf68:	7afa      	ldrb	r2, [r7, #11]
 800bf6a:	6a3b      	ldr	r3, [r7, #32]
 800bf6c:	6839      	ldr	r1, [r7, #0]
 800bf6e:	6878      	ldr	r0, [r7, #4]
 800bf70:	f000 fad2 	bl	800c518 <_calculate_draw_buf_size>
 800bf74:	6178      	str	r0, [r7, #20]

    if(size > draw_buf->data_size) {
 800bf76:	68fb      	ldr	r3, [r7, #12]
 800bf78:	68db      	ldr	r3, [r3, #12]
 800bf7a:	697a      	ldr	r2, [r7, #20]
 800bf7c:	429a      	cmp	r2, r3
 800bf7e:	d901      	bls.n	800bf84 <lv_draw_buf_reshape+0x54>
        LV_LOG_TRACE("Draw buf too small for new shape");
        return NULL;
 800bf80:	2300      	movs	r3, #0
 800bf82:	e00f      	b.n	800bfa4 <lv_draw_buf_reshape+0x74>
    }

    draw_buf->header.cf = cf;
 800bf84:	68fb      	ldr	r3, [r7, #12]
 800bf86:	7afa      	ldrb	r2, [r7, #11]
 800bf88:	705a      	strb	r2, [r3, #1]
    draw_buf->header.w = w;
 800bf8a:	687b      	ldr	r3, [r7, #4]
 800bf8c:	b29a      	uxth	r2, r3
 800bf8e:	68fb      	ldr	r3, [r7, #12]
 800bf90:	809a      	strh	r2, [r3, #4]
    draw_buf->header.h = h;
 800bf92:	683b      	ldr	r3, [r7, #0]
 800bf94:	b29a      	uxth	r2, r3
 800bf96:	68fb      	ldr	r3, [r7, #12]
 800bf98:	80da      	strh	r2, [r3, #6]
    draw_buf->header.stride = stride;
 800bf9a:	6a3b      	ldr	r3, [r7, #32]
 800bf9c:	b29a      	uxth	r2, r3
 800bf9e:	68fb      	ldr	r3, [r7, #12]
 800bfa0:	811a      	strh	r2, [r3, #8]

    return draw_buf;
 800bfa2:	68fb      	ldr	r3, [r7, #12]
}
 800bfa4:	4618      	mov	r0, r3
 800bfa6:	3718      	adds	r7, #24
 800bfa8:	46bd      	mov	sp, r7
 800bfaa:	bd80      	pop	{r7, pc}

0800bfac <lv_draw_buf_destroy>:

void lv_draw_buf_destroy(lv_draw_buf_t * buf)
{
 800bfac:	b580      	push	{r7, lr}
 800bfae:	b082      	sub	sp, #8
 800bfb0:	af00      	add	r7, sp, #0
 800bfb2:	6078      	str	r0, [r7, #4]
    LV_ASSERT_NULL(buf);
 800bfb4:	687b      	ldr	r3, [r7, #4]
 800bfb6:	2b00      	cmp	r3, #0
 800bfb8:	d101      	bne.n	800bfbe <lv_draw_buf_destroy+0x12>
 800bfba:	bf00      	nop
 800bfbc:	e7fd      	b.n	800bfba <lv_draw_buf_destroy+0xe>
    if(buf == NULL) return;
 800bfbe:	687b      	ldr	r3, [r7, #4]
 800bfc0:	2b00      	cmp	r3, #0
 800bfc2:	d00e      	beq.n	800bfe2 <lv_draw_buf_destroy+0x36>

    if(buf->header.flags & LV_IMAGE_FLAGS_ALLOCATED) {
 800bfc4:	687b      	ldr	r3, [r7, #4]
 800bfc6:	885b      	ldrh	r3, [r3, #2]
 800bfc8:	f003 0310 	and.w	r3, r3, #16
 800bfcc:	2b00      	cmp	r3, #0
 800bfce:	d009      	beq.n	800bfe4 <lv_draw_buf_destroy+0x38>
        draw_buf_free(buf->unaligned_data);
 800bfd0:	687b      	ldr	r3, [r7, #4]
 800bfd2:	695b      	ldr	r3, [r3, #20]
 800bfd4:	4618      	mov	r0, r3
 800bfd6:	f000 fa8b 	bl	800c4f0 <draw_buf_free>
        lv_free(buf);
 800bfda:	6878      	ldr	r0, [r7, #4]
 800bfdc:	f019 ff2c 	bl	8025e38 <lv_free>
 800bfe0:	e000      	b.n	800bfe4 <lv_draw_buf_destroy+0x38>
    if(buf == NULL) return;
 800bfe2:	bf00      	nop
    }
    else {
        LV_LOG_ERROR("draw buffer is not allocated, ignored");
    }
}
 800bfe4:	3708      	adds	r7, #8
 800bfe6:	46bd      	mov	sp, r7
 800bfe8:	bd80      	pop	{r7, pc}

0800bfea <lv_draw_buf_goto_xy>:

void * lv_draw_buf_goto_xy(const lv_draw_buf_t * buf, uint32_t x, uint32_t y)
{
 800bfea:	b580      	push	{r7, lr}
 800bfec:	b086      	sub	sp, #24
 800bfee:	af00      	add	r7, sp, #0
 800bff0:	60f8      	str	r0, [r7, #12]
 800bff2:	60b9      	str	r1, [r7, #8]
 800bff4:	607a      	str	r2, [r7, #4]
    LV_ASSERT_NULL(buf);
 800bff6:	68fb      	ldr	r3, [r7, #12]
 800bff8:	2b00      	cmp	r3, #0
 800bffa:	d101      	bne.n	800c000 <lv_draw_buf_goto_xy+0x16>
 800bffc:	bf00      	nop
 800bffe:	e7fd      	b.n	800bffc <lv_draw_buf_goto_xy+0x12>
    if(buf == NULL) return NULL;
 800c000:	68fb      	ldr	r3, [r7, #12]
 800c002:	2b00      	cmp	r3, #0
 800c004:	d101      	bne.n	800c00a <lv_draw_buf_goto_xy+0x20>
 800c006:	2300      	movs	r3, #0
 800c008:	e01a      	b.n	800c040 <lv_draw_buf_goto_xy+0x56>

    uint8_t * data = buf->data + buf->header.stride * y;
 800c00a:	68fb      	ldr	r3, [r7, #12]
 800c00c:	691a      	ldr	r2, [r3, #16]
 800c00e:	68fb      	ldr	r3, [r7, #12]
 800c010:	891b      	ldrh	r3, [r3, #8]
 800c012:	4619      	mov	r1, r3
 800c014:	687b      	ldr	r3, [r7, #4]
 800c016:	fb01 f303 	mul.w	r3, r1, r3
 800c01a:	4413      	add	r3, r2
 800c01c:	617b      	str	r3, [r7, #20]

    if(x == 0)
 800c01e:	68bb      	ldr	r3, [r7, #8]
 800c020:	2b00      	cmp	r3, #0
 800c022:	d101      	bne.n	800c028 <lv_draw_buf_goto_xy+0x3e>
        return data;
 800c024:	697b      	ldr	r3, [r7, #20]
 800c026:	e00b      	b.n	800c040 <lv_draw_buf_goto_xy+0x56>

    return data + x * lv_color_format_get_size(buf->header.cf);
 800c028:	68fb      	ldr	r3, [r7, #12]
 800c02a:	785b      	ldrb	r3, [r3, #1]
 800c02c:	4618      	mov	r0, r3
 800c02e:	f7ff fd15 	bl	800ba5c <lv_color_format_get_size>
 800c032:	4603      	mov	r3, r0
 800c034:	461a      	mov	r2, r3
 800c036:	68bb      	ldr	r3, [r7, #8]
 800c038:	fb02 f303 	mul.w	r3, r2, r3
 800c03c:	697a      	ldr	r2, [r7, #20]
 800c03e:	4413      	add	r3, r2
}
 800c040:	4618      	mov	r0, r3
 800c042:	3718      	adds	r7, #24
 800c044:	46bd      	mov	sp, r7
 800c046:	bd80      	pop	{r7, pc}

0800c048 <lv_draw_buf_adjust_stride>:

lv_result_t lv_draw_buf_adjust_stride(lv_draw_buf_t * src, uint32_t stride)
{
 800c048:	b580      	push	{r7, lr}
 800c04a:	b090      	sub	sp, #64	@ 0x40
 800c04c:	af00      	add	r7, sp, #0
 800c04e:	6078      	str	r0, [r7, #4]
 800c050:	6039      	str	r1, [r7, #0]
    LV_ASSERT_NULL(src);
 800c052:	687b      	ldr	r3, [r7, #4]
 800c054:	2b00      	cmp	r3, #0
 800c056:	d101      	bne.n	800c05c <lv_draw_buf_adjust_stride+0x14>
 800c058:	bf00      	nop
 800c05a:	e7fd      	b.n	800c058 <lv_draw_buf_adjust_stride+0x10>
    LV_ASSERT_NULL(src->data);
 800c05c:	687b      	ldr	r3, [r7, #4]
 800c05e:	691b      	ldr	r3, [r3, #16]
 800c060:	2b00      	cmp	r3, #0
 800c062:	d101      	bne.n	800c068 <lv_draw_buf_adjust_stride+0x20>
 800c064:	bf00      	nop
 800c066:	e7fd      	b.n	800c064 <lv_draw_buf_adjust_stride+0x1c>
    if(src == NULL) return LV_RESULT_INVALID;
 800c068:	687b      	ldr	r3, [r7, #4]
 800c06a:	2b00      	cmp	r3, #0
 800c06c:	d101      	bne.n	800c072 <lv_draw_buf_adjust_stride+0x2a>
 800c06e:	2300      	movs	r3, #0
 800c070:	e0be      	b.n	800c1f0 <lv_draw_buf_adjust_stride+0x1a8>
    if(src->data == NULL) return LV_RESULT_INVALID;
 800c072:	687b      	ldr	r3, [r7, #4]
 800c074:	691b      	ldr	r3, [r3, #16]
 800c076:	2b00      	cmp	r3, #0
 800c078:	d101      	bne.n	800c07e <lv_draw_buf_adjust_stride+0x36>
 800c07a:	2300      	movs	r3, #0
 800c07c:	e0b8      	b.n	800c1f0 <lv_draw_buf_adjust_stride+0x1a8>

    const lv_image_header_t * header = &src->header;
 800c07e:	687b      	ldr	r3, [r7, #4]
 800c080:	627b      	str	r3, [r7, #36]	@ 0x24
    uint32_t w = header->w;
 800c082:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c084:	889b      	ldrh	r3, [r3, #4]
 800c086:	623b      	str	r3, [r7, #32]
    uint32_t h = header->h;
 800c088:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c08a:	88db      	ldrh	r3, [r3, #6]
 800c08c:	61fb      	str	r3, [r7, #28]

    /*Use global stride*/
    if(stride == 0) stride = lv_draw_buf_width_to_stride(w, header->cf);
 800c08e:	683b      	ldr	r3, [r7, #0]
 800c090:	2b00      	cmp	r3, #0
 800c092:	d106      	bne.n	800c0a2 <lv_draw_buf_adjust_stride+0x5a>
 800c094:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c096:	785b      	ldrb	r3, [r3, #1]
 800c098:	4619      	mov	r1, r3
 800c09a:	6a38      	ldr	r0, [r7, #32]
 800c09c:	f7ff fd92 	bl	800bbc4 <lv_draw_buf_width_to_stride>
 800c0a0:	6038      	str	r0, [r7, #0]

    /*Check if stride already match*/
    if(header->stride == stride) return LV_RESULT_OK;
 800c0a2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c0a4:	891b      	ldrh	r3, [r3, #8]
 800c0a6:	461a      	mov	r2, r3
 800c0a8:	683b      	ldr	r3, [r7, #0]
 800c0aa:	4293      	cmp	r3, r2
 800c0ac:	d101      	bne.n	800c0b2 <lv_draw_buf_adjust_stride+0x6a>
 800c0ae:	2301      	movs	r3, #1
 800c0b0:	e09e      	b.n	800c1f0 <lv_draw_buf_adjust_stride+0x1a8>

    /*Calculate the minimal stride allowed from bpp*/
    uint32_t bpp = lv_color_format_get_bpp(header->cf);
 800c0b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c0b4:	785b      	ldrb	r3, [r3, #1]
 800c0b6:	4618      	mov	r0, r3
 800c0b8:	f016 fa26 	bl	8022508 <lv_color_format_get_bpp>
 800c0bc:	4603      	mov	r3, r0
 800c0be:	61bb      	str	r3, [r7, #24]
    uint32_t min_stride = (w * bpp + 7) >> 3;
 800c0c0:	6a3b      	ldr	r3, [r7, #32]
 800c0c2:	69ba      	ldr	r2, [r7, #24]
 800c0c4:	fb02 f303 	mul.w	r3, r2, r3
 800c0c8:	3307      	adds	r3, #7
 800c0ca:	08db      	lsrs	r3, r3, #3
 800c0cc:	617b      	str	r3, [r7, #20]
    if(stride < min_stride) {
 800c0ce:	683a      	ldr	r2, [r7, #0]
 800c0d0:	697b      	ldr	r3, [r7, #20]
 800c0d2:	429a      	cmp	r2, r3
 800c0d4:	d201      	bcs.n	800c0da <lv_draw_buf_adjust_stride+0x92>
        LV_LOG_WARN("New stride is too small. min: %" LV_PRId32, min_stride);
        return LV_RESULT_INVALID;
 800c0d6:	2300      	movs	r3, #0
 800c0d8:	e08a      	b.n	800c1f0 <lv_draw_buf_adjust_stride+0x1a8>
    }

    /*Check if buffer has enough space. */
    uint32_t new_size = _calculate_draw_buf_size(w, h, header->cf, stride);
 800c0da:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c0dc:	785a      	ldrb	r2, [r3, #1]
 800c0de:	683b      	ldr	r3, [r7, #0]
 800c0e0:	69f9      	ldr	r1, [r7, #28]
 800c0e2:	6a38      	ldr	r0, [r7, #32]
 800c0e4:	f000 fa18 	bl	800c518 <_calculate_draw_buf_size>
 800c0e8:	6138      	str	r0, [r7, #16]
    if(new_size > src->data_size) {
 800c0ea:	687b      	ldr	r3, [r7, #4]
 800c0ec:	68db      	ldr	r3, [r3, #12]
 800c0ee:	693a      	ldr	r2, [r7, #16]
 800c0f0:	429a      	cmp	r2, r3
 800c0f2:	d901      	bls.n	800c0f8 <lv_draw_buf_adjust_stride+0xb0>
        return LV_RESULT_INVALID;
 800c0f4:	2300      	movs	r3, #0
 800c0f6:	e07b      	b.n	800c1f0 <lv_draw_buf_adjust_stride+0x1a8>
    }

    uint32_t offset = LV_COLOR_INDEXED_PALETTE_SIZE(header->cf) * 4;
 800c0f8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c0fa:	785b      	ldrb	r3, [r3, #1]
 800c0fc:	2b07      	cmp	r3, #7
 800c0fe:	d014      	beq.n	800c12a <lv_draw_buf_adjust_stride+0xe2>
 800c100:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c102:	785b      	ldrb	r3, [r3, #1]
 800c104:	2b08      	cmp	r3, #8
 800c106:	d00e      	beq.n	800c126 <lv_draw_buf_adjust_stride+0xde>
 800c108:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c10a:	785b      	ldrb	r3, [r3, #1]
 800c10c:	2b09      	cmp	r3, #9
 800c10e:	d008      	beq.n	800c122 <lv_draw_buf_adjust_stride+0xda>
 800c110:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c112:	785b      	ldrb	r3, [r3, #1]
 800c114:	2b0a      	cmp	r3, #10
 800c116:	d102      	bne.n	800c11e <lv_draw_buf_adjust_stride+0xd6>
 800c118:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800c11c:	e006      	b.n	800c12c <lv_draw_buf_adjust_stride+0xe4>
 800c11e:	2300      	movs	r3, #0
 800c120:	e004      	b.n	800c12c <lv_draw_buf_adjust_stride+0xe4>
 800c122:	2340      	movs	r3, #64	@ 0x40
 800c124:	e002      	b.n	800c12c <lv_draw_buf_adjust_stride+0xe4>
 800c126:	2310      	movs	r3, #16
 800c128:	e000      	b.n	800c12c <lv_draw_buf_adjust_stride+0xe4>
 800c12a:	2308      	movs	r3, #8
 800c12c:	60fb      	str	r3, [r7, #12]

    if(stride > header->stride) {
 800c12e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c130:	891b      	ldrh	r3, [r3, #8]
 800c132:	461a      	mov	r2, r3
 800c134:	683b      	ldr	r3, [r7, #0]
 800c136:	4293      	cmp	r3, r2
 800c138:	d932      	bls.n	800c1a0 <lv_draw_buf_adjust_stride+0x158>
        /*Copy from the last line to the first*/
        uint8_t * src_data = src->data + offset + header->stride * (h - 1);
 800c13a:	687b      	ldr	r3, [r7, #4]
 800c13c:	691a      	ldr	r2, [r3, #16]
 800c13e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c140:	891b      	ldrh	r3, [r3, #8]
 800c142:	4619      	mov	r1, r3
 800c144:	69fb      	ldr	r3, [r7, #28]
 800c146:	3b01      	subs	r3, #1
 800c148:	fb03 f101 	mul.w	r1, r3, r1
 800c14c:	68fb      	ldr	r3, [r7, #12]
 800c14e:	440b      	add	r3, r1
 800c150:	4413      	add	r3, r2
 800c152:	63fb      	str	r3, [r7, #60]	@ 0x3c
        uint8_t * dst_data = src->data + offset + stride * (h - 1);
 800c154:	687b      	ldr	r3, [r7, #4]
 800c156:	691a      	ldr	r2, [r3, #16]
 800c158:	69fb      	ldr	r3, [r7, #28]
 800c15a:	3b01      	subs	r3, #1
 800c15c:	6839      	ldr	r1, [r7, #0]
 800c15e:	fb03 f101 	mul.w	r1, r3, r1
 800c162:	68fb      	ldr	r3, [r7, #12]
 800c164:	440b      	add	r3, r1
 800c166:	4413      	add	r3, r2
 800c168:	63bb      	str	r3, [r7, #56]	@ 0x38
        for(uint32_t y = 0; y < h; y++) {
 800c16a:	2300      	movs	r3, #0
 800c16c:	637b      	str	r3, [r7, #52]	@ 0x34
 800c16e:	e012      	b.n	800c196 <lv_draw_buf_adjust_stride+0x14e>
            lv_memmove(dst_data, src_data, min_stride);
 800c170:	697a      	ldr	r2, [r7, #20]
 800c172:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 800c174:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 800c176:	f018 fed5 	bl	8024f24 <lv_memmove>
            src_data -= header->stride;
 800c17a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c17c:	891b      	ldrh	r3, [r3, #8]
 800c17e:	425b      	negs	r3, r3
 800c180:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800c182:	4413      	add	r3, r2
 800c184:	63fb      	str	r3, [r7, #60]	@ 0x3c
            dst_data -= stride;
 800c186:	683b      	ldr	r3, [r7, #0]
 800c188:	425b      	negs	r3, r3
 800c18a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800c18c:	4413      	add	r3, r2
 800c18e:	63bb      	str	r3, [r7, #56]	@ 0x38
        for(uint32_t y = 0; y < h; y++) {
 800c190:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800c192:	3301      	adds	r3, #1
 800c194:	637b      	str	r3, [r7, #52]	@ 0x34
 800c196:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800c198:	69fb      	ldr	r3, [r7, #28]
 800c19a:	429a      	cmp	r2, r3
 800c19c:	d3e8      	bcc.n	800c170 <lv_draw_buf_adjust_stride+0x128>
 800c19e:	e022      	b.n	800c1e6 <lv_draw_buf_adjust_stride+0x19e>
        }
    }
    else {
        /*Copy from the first line to the last*/
        uint8_t * src_data = src->data + offset;
 800c1a0:	687b      	ldr	r3, [r7, #4]
 800c1a2:	691a      	ldr	r2, [r3, #16]
 800c1a4:	68fb      	ldr	r3, [r7, #12]
 800c1a6:	4413      	add	r3, r2
 800c1a8:	633b      	str	r3, [r7, #48]	@ 0x30
        uint8_t * dst_data = src->data + offset;
 800c1aa:	687b      	ldr	r3, [r7, #4]
 800c1ac:	691a      	ldr	r2, [r3, #16]
 800c1ae:	68fb      	ldr	r3, [r7, #12]
 800c1b0:	4413      	add	r3, r2
 800c1b2:	62fb      	str	r3, [r7, #44]	@ 0x2c
        for(uint32_t y = 0; y < h; y++) {
 800c1b4:	2300      	movs	r3, #0
 800c1b6:	62bb      	str	r3, [r7, #40]	@ 0x28
 800c1b8:	e011      	b.n	800c1de <lv_draw_buf_adjust_stride+0x196>
            lv_memmove(dst_data, src_data, min_stride);
 800c1ba:	697a      	ldr	r2, [r7, #20]
 800c1bc:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 800c1be:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 800c1c0:	f018 feb0 	bl	8024f24 <lv_memmove>
            src_data += header->stride;
 800c1c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c1c6:	891b      	ldrh	r3, [r3, #8]
 800c1c8:	461a      	mov	r2, r3
 800c1ca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800c1cc:	4413      	add	r3, r2
 800c1ce:	633b      	str	r3, [r7, #48]	@ 0x30
            dst_data += stride;
 800c1d0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800c1d2:	683b      	ldr	r3, [r7, #0]
 800c1d4:	4413      	add	r3, r2
 800c1d6:	62fb      	str	r3, [r7, #44]	@ 0x2c
        for(uint32_t y = 0; y < h; y++) {
 800c1d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c1da:	3301      	adds	r3, #1
 800c1dc:	62bb      	str	r3, [r7, #40]	@ 0x28
 800c1de:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800c1e0:	69fb      	ldr	r3, [r7, #28]
 800c1e2:	429a      	cmp	r2, r3
 800c1e4:	d3e9      	bcc.n	800c1ba <lv_draw_buf_adjust_stride+0x172>
        }
    }

    src->header.stride = stride;
 800c1e6:	683b      	ldr	r3, [r7, #0]
 800c1e8:	b29a      	uxth	r2, r3
 800c1ea:	687b      	ldr	r3, [r7, #4]
 800c1ec:	811a      	strh	r2, [r3, #8]

    return LV_RESULT_OK;
 800c1ee:	2301      	movs	r3, #1
}
 800c1f0:	4618      	mov	r0, r3
 800c1f2:	3740      	adds	r7, #64	@ 0x40
 800c1f4:	46bd      	mov	sp, r7
 800c1f6:	bd80      	pop	{r7, pc}

0800c1f8 <lv_draw_buf_premultiply>:

lv_result_t lv_draw_buf_premultiply(lv_draw_buf_t * draw_buf)
{
 800c1f8:	b580      	push	{r7, lr}
 800c1fa:	b09e      	sub	sp, #120	@ 0x78
 800c1fc:	af00      	add	r7, sp, #0
 800c1fe:	6078      	str	r0, [r7, #4]
    LV_ASSERT_NULL(draw_buf);
 800c200:	687b      	ldr	r3, [r7, #4]
 800c202:	2b00      	cmp	r3, #0
 800c204:	d101      	bne.n	800c20a <lv_draw_buf_premultiply+0x12>
 800c206:	bf00      	nop
 800c208:	e7fd      	b.n	800c206 <lv_draw_buf_premultiply+0xe>
    if(draw_buf == NULL) return LV_RESULT_INVALID;
 800c20a:	687b      	ldr	r3, [r7, #4]
 800c20c:	2b00      	cmp	r3, #0
 800c20e:	d101      	bne.n	800c214 <lv_draw_buf_premultiply+0x1c>
 800c210:	2300      	movs	r3, #0
 800c212:	e0ff      	b.n	800c414 <lv_draw_buf_premultiply+0x21c>

    if(draw_buf->header.flags & LV_IMAGE_FLAGS_PREMULTIPLIED) return LV_RESULT_INVALID;
 800c214:	687b      	ldr	r3, [r7, #4]
 800c216:	885b      	ldrh	r3, [r3, #2]
 800c218:	f003 0301 	and.w	r3, r3, #1
 800c21c:	2b00      	cmp	r3, #0
 800c21e:	d001      	beq.n	800c224 <lv_draw_buf_premultiply+0x2c>
 800c220:	2300      	movs	r3, #0
 800c222:	e0f7      	b.n	800c414 <lv_draw_buf_premultiply+0x21c>
    if((draw_buf->header.flags & LV_IMAGE_FLAGS_MODIFIABLE) == 0) {
 800c224:	687b      	ldr	r3, [r7, #4]
 800c226:	885b      	ldrh	r3, [r3, #2]
 800c228:	f003 0320 	and.w	r3, r3, #32
 800c22c:	2b00      	cmp	r3, #0
 800c22e:	d101      	bne.n	800c234 <lv_draw_buf_premultiply+0x3c>
        LV_LOG_WARN("draw buf is not modifiable: 0x%04x", draw_buf->header.flags);
        return LV_RESULT_INVALID;
 800c230:	2300      	movs	r3, #0
 800c232:	e0ef      	b.n	800c414 <lv_draw_buf_premultiply+0x21c>
    }

    /*Premultiply color with alpha, do case by case by judging color format*/
    lv_color_format_t cf = draw_buf->header.cf;
 800c234:	687b      	ldr	r3, [r7, #4]
 800c236:	785b      	ldrb	r3, [r3, #1]
 800c238:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    if(LV_COLOR_FORMAT_IS_INDEXED(cf)) {
 800c23c:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 800c240:	2b06      	cmp	r3, #6
 800c242:	d933      	bls.n	800c2ac <lv_draw_buf_premultiply+0xb4>
 800c244:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 800c248:	2b0a      	cmp	r3, #10
 800c24a:	d82f      	bhi.n	800c2ac <lv_draw_buf_premultiply+0xb4>
        int size = LV_COLOR_INDEXED_PALETTE_SIZE(cf);
 800c24c:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 800c250:	2b07      	cmp	r3, #7
 800c252:	d014      	beq.n	800c27e <lv_draw_buf_premultiply+0x86>
 800c254:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 800c258:	2b08      	cmp	r3, #8
 800c25a:	d00e      	beq.n	800c27a <lv_draw_buf_premultiply+0x82>
 800c25c:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 800c260:	2b09      	cmp	r3, #9
 800c262:	d008      	beq.n	800c276 <lv_draw_buf_premultiply+0x7e>
 800c264:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 800c268:	2b0a      	cmp	r3, #10
 800c26a:	d102      	bne.n	800c272 <lv_draw_buf_premultiply+0x7a>
 800c26c:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800c270:	e006      	b.n	800c280 <lv_draw_buf_premultiply+0x88>
 800c272:	2300      	movs	r3, #0
 800c274:	e004      	b.n	800c280 <lv_draw_buf_premultiply+0x88>
 800c276:	2310      	movs	r3, #16
 800c278:	e002      	b.n	800c280 <lv_draw_buf_premultiply+0x88>
 800c27a:	2304      	movs	r3, #4
 800c27c:	e000      	b.n	800c280 <lv_draw_buf_premultiply+0x88>
 800c27e:	2302      	movs	r3, #2
 800c280:	63bb      	str	r3, [r7, #56]	@ 0x38
        lv_color32_t * palette = (lv_color32_t *)draw_buf->data;
 800c282:	687b      	ldr	r3, [r7, #4]
 800c284:	691b      	ldr	r3, [r3, #16]
 800c286:	637b      	str	r3, [r7, #52]	@ 0x34
        for(int i = 0; i < size; i++) {
 800c288:	2300      	movs	r3, #0
 800c28a:	677b      	str	r3, [r7, #116]	@ 0x74
 800c28c:	e009      	b.n	800c2a2 <lv_draw_buf_premultiply+0xaa>
            lv_color_premultiply(&palette[i]);
 800c28e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800c290:	009b      	lsls	r3, r3, #2
 800c292:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800c294:	4413      	add	r3, r2
 800c296:	4618      	mov	r0, r3
 800c298:	f7ff fbf1 	bl	800ba7e <lv_color_premultiply>
        for(int i = 0; i < size; i++) {
 800c29c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800c29e:	3301      	adds	r3, #1
 800c2a0:	677b      	str	r3, [r7, #116]	@ 0x74
 800c2a2:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 800c2a4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c2a6:	429a      	cmp	r2, r3
 800c2a8:	dbf1      	blt.n	800c28e <lv_draw_buf_premultiply+0x96>
    if(LV_COLOR_FORMAT_IS_INDEXED(cf)) {
 800c2aa:	e0ab      	b.n	800c404 <lv_draw_buf_premultiply+0x20c>
        }
    }
    else if(cf == LV_COLOR_FORMAT_ARGB8888) {
 800c2ac:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 800c2b0:	2b10      	cmp	r3, #16
 800c2b2:	d12c      	bne.n	800c30e <lv_draw_buf_premultiply+0x116>
        uint32_t h = draw_buf->header.h;
 800c2b4:	687b      	ldr	r3, [r7, #4]
 800c2b6:	88db      	ldrh	r3, [r3, #6]
 800c2b8:	613b      	str	r3, [r7, #16]
        uint32_t w = draw_buf->header.w;
 800c2ba:	687b      	ldr	r3, [r7, #4]
 800c2bc:	889b      	ldrh	r3, [r3, #4]
 800c2be:	60fb      	str	r3, [r7, #12]
        uint32_t stride = draw_buf->header.stride;
 800c2c0:	687b      	ldr	r3, [r7, #4]
 800c2c2:	891b      	ldrh	r3, [r3, #8]
 800c2c4:	60bb      	str	r3, [r7, #8]
        uint8_t * line = (uint8_t *)draw_buf->data;
 800c2c6:	687b      	ldr	r3, [r7, #4]
 800c2c8:	691b      	ldr	r3, [r3, #16]
 800c2ca:	673b      	str	r3, [r7, #112]	@ 0x70
        for(uint32_t y = 0; y < h; y++) {
 800c2cc:	2300      	movs	r3, #0
 800c2ce:	66fb      	str	r3, [r7, #108]	@ 0x6c
 800c2d0:	e018      	b.n	800c304 <lv_draw_buf_premultiply+0x10c>
            lv_color32_t * pixel = (lv_color32_t *)line;
 800c2d2:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800c2d4:	66bb      	str	r3, [r7, #104]	@ 0x68
            for(uint32_t x = 0; x < w; x++) {
 800c2d6:	2300      	movs	r3, #0
 800c2d8:	667b      	str	r3, [r7, #100]	@ 0x64
 800c2da:	e008      	b.n	800c2ee <lv_draw_buf_premultiply+0xf6>
                lv_color_premultiply(pixel);
 800c2dc:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 800c2de:	f7ff fbce 	bl	800ba7e <lv_color_premultiply>
                pixel++;
 800c2e2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800c2e4:	3304      	adds	r3, #4
 800c2e6:	66bb      	str	r3, [r7, #104]	@ 0x68
            for(uint32_t x = 0; x < w; x++) {
 800c2e8:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800c2ea:	3301      	adds	r3, #1
 800c2ec:	667b      	str	r3, [r7, #100]	@ 0x64
 800c2ee:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 800c2f0:	68fb      	ldr	r3, [r7, #12]
 800c2f2:	429a      	cmp	r2, r3
 800c2f4:	d3f2      	bcc.n	800c2dc <lv_draw_buf_premultiply+0xe4>
            }
            line += stride;
 800c2f6:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 800c2f8:	68bb      	ldr	r3, [r7, #8]
 800c2fa:	4413      	add	r3, r2
 800c2fc:	673b      	str	r3, [r7, #112]	@ 0x70
        for(uint32_t y = 0; y < h; y++) {
 800c2fe:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800c300:	3301      	adds	r3, #1
 800c302:	66fb      	str	r3, [r7, #108]	@ 0x6c
 800c304:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 800c306:	693b      	ldr	r3, [r7, #16]
 800c308:	429a      	cmp	r2, r3
 800c30a:	d3e2      	bcc.n	800c2d2 <lv_draw_buf_premultiply+0xda>
 800c30c:	e07a      	b.n	800c404 <lv_draw_buf_premultiply+0x20c>
        }
    }
    else if(cf == LV_COLOR_FORMAT_RGB565A8) {
 800c30e:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 800c312:	2b14      	cmp	r3, #20
 800c314:	d13f      	bne.n	800c396 <lv_draw_buf_premultiply+0x19e>
        uint32_t h = draw_buf->header.h;
 800c316:	687b      	ldr	r3, [r7, #4]
 800c318:	88db      	ldrh	r3, [r3, #6]
 800c31a:	623b      	str	r3, [r7, #32]
        uint32_t w = draw_buf->header.w;
 800c31c:	687b      	ldr	r3, [r7, #4]
 800c31e:	889b      	ldrh	r3, [r3, #4]
 800c320:	61fb      	str	r3, [r7, #28]
        uint32_t stride = draw_buf->header.stride;
 800c322:	687b      	ldr	r3, [r7, #4]
 800c324:	891b      	ldrh	r3, [r3, #8]
 800c326:	61bb      	str	r3, [r7, #24]
        uint32_t alpha_stride = stride / 2;
 800c328:	69bb      	ldr	r3, [r7, #24]
 800c32a:	085b      	lsrs	r3, r3, #1
 800c32c:	617b      	str	r3, [r7, #20]
        uint8_t * line = (uint8_t *)draw_buf->data;
 800c32e:	687b      	ldr	r3, [r7, #4]
 800c330:	691b      	ldr	r3, [r3, #16]
 800c332:	663b      	str	r3, [r7, #96]	@ 0x60
        lv_opa_t * alpha = (lv_opa_t *)(line + stride * h);
 800c334:	69bb      	ldr	r3, [r7, #24]
 800c336:	6a3a      	ldr	r2, [r7, #32]
 800c338:	fb02 f303 	mul.w	r3, r2, r3
 800c33c:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 800c33e:	4413      	add	r3, r2
 800c340:	65fb      	str	r3, [r7, #92]	@ 0x5c
        for(uint32_t y = 0; y < h; y++) {
 800c342:	2300      	movs	r3, #0
 800c344:	65bb      	str	r3, [r7, #88]	@ 0x58
 800c346:	e021      	b.n	800c38c <lv_draw_buf_premultiply+0x194>
            lv_color16_t * pixel = (lv_color16_t *)line;
 800c348:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800c34a:	657b      	str	r3, [r7, #84]	@ 0x54
            for(uint32_t x = 0; x < w; x++) {
 800c34c:	2300      	movs	r3, #0
 800c34e:	653b      	str	r3, [r7, #80]	@ 0x50
 800c350:	e00d      	b.n	800c36e <lv_draw_buf_premultiply+0x176>
                lv_color16_premultiply(pixel, alpha[x]);
 800c352:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 800c354:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c356:	4413      	add	r3, r2
 800c358:	781b      	ldrb	r3, [r3, #0]
 800c35a:	4619      	mov	r1, r3
 800c35c:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 800c35e:	f7ff fbb9 	bl	800bad4 <lv_color16_premultiply>
                pixel++;
 800c362:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800c364:	3302      	adds	r3, #2
 800c366:	657b      	str	r3, [r7, #84]	@ 0x54
            for(uint32_t x = 0; x < w; x++) {
 800c368:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c36a:	3301      	adds	r3, #1
 800c36c:	653b      	str	r3, [r7, #80]	@ 0x50
 800c36e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800c370:	69fb      	ldr	r3, [r7, #28]
 800c372:	429a      	cmp	r2, r3
 800c374:	d3ed      	bcc.n	800c352 <lv_draw_buf_premultiply+0x15a>
            }
            line += stride;
 800c376:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 800c378:	69bb      	ldr	r3, [r7, #24]
 800c37a:	4413      	add	r3, r2
 800c37c:	663b      	str	r3, [r7, #96]	@ 0x60
            alpha += alpha_stride;
 800c37e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 800c380:	697b      	ldr	r3, [r7, #20]
 800c382:	4413      	add	r3, r2
 800c384:	65fb      	str	r3, [r7, #92]	@ 0x5c
        for(uint32_t y = 0; y < h; y++) {
 800c386:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800c388:	3301      	adds	r3, #1
 800c38a:	65bb      	str	r3, [r7, #88]	@ 0x58
 800c38c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 800c38e:	6a3b      	ldr	r3, [r7, #32]
 800c390:	429a      	cmp	r2, r3
 800c392:	d3d9      	bcc.n	800c348 <lv_draw_buf_premultiply+0x150>
 800c394:	e036      	b.n	800c404 <lv_draw_buf_premultiply+0x20c>
        }
    }
    else if(cf == LV_COLOR_FORMAT_ARGB8565) {
 800c396:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 800c39a:	2b13      	cmp	r3, #19
 800c39c:	d132      	bne.n	800c404 <lv_draw_buf_premultiply+0x20c>
        uint32_t h = draw_buf->header.h;
 800c39e:	687b      	ldr	r3, [r7, #4]
 800c3a0:	88db      	ldrh	r3, [r3, #6]
 800c3a2:	633b      	str	r3, [r7, #48]	@ 0x30
        uint32_t w = draw_buf->header.w;
 800c3a4:	687b      	ldr	r3, [r7, #4]
 800c3a6:	889b      	ldrh	r3, [r3, #4]
 800c3a8:	62fb      	str	r3, [r7, #44]	@ 0x2c
        uint32_t stride = draw_buf->header.stride;
 800c3aa:	687b      	ldr	r3, [r7, #4]
 800c3ac:	891b      	ldrh	r3, [r3, #8]
 800c3ae:	62bb      	str	r3, [r7, #40]	@ 0x28
        uint8_t * line = (uint8_t *)draw_buf->data;
 800c3b0:	687b      	ldr	r3, [r7, #4]
 800c3b2:	691b      	ldr	r3, [r3, #16]
 800c3b4:	64fb      	str	r3, [r7, #76]	@ 0x4c
        for(uint32_t y = 0; y < h; y++) {
 800c3b6:	2300      	movs	r3, #0
 800c3b8:	64bb      	str	r3, [r7, #72]	@ 0x48
 800c3ba:	e01f      	b.n	800c3fc <lv_draw_buf_premultiply+0x204>
            uint8_t * pixel = line;
 800c3bc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800c3be:	647b      	str	r3, [r7, #68]	@ 0x44
            for(uint32_t x = 0; x < w; x++) {
 800c3c0:	2300      	movs	r3, #0
 800c3c2:	643b      	str	r3, [r7, #64]	@ 0x40
 800c3c4:	e00f      	b.n	800c3e6 <lv_draw_buf_premultiply+0x1ee>
                uint8_t alpha = pixel[2];
 800c3c6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800c3c8:	789b      	ldrb	r3, [r3, #2]
 800c3ca:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
                lv_color16_premultiply((lv_color16_t *)pixel, alpha);
 800c3ce:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800c3d2:	4619      	mov	r1, r3
 800c3d4:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800c3d6:	f7ff fb7d 	bl	800bad4 <lv_color16_premultiply>
                pixel += 3;
 800c3da:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800c3dc:	3303      	adds	r3, #3
 800c3de:	647b      	str	r3, [r7, #68]	@ 0x44
            for(uint32_t x = 0; x < w; x++) {
 800c3e0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800c3e2:	3301      	adds	r3, #1
 800c3e4:	643b      	str	r3, [r7, #64]	@ 0x40
 800c3e6:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800c3e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800c3ea:	429a      	cmp	r2, r3
 800c3ec:	d3eb      	bcc.n	800c3c6 <lv_draw_buf_premultiply+0x1ce>
            }
            line += stride;
 800c3ee:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800c3f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c3f2:	4413      	add	r3, r2
 800c3f4:	64fb      	str	r3, [r7, #76]	@ 0x4c
        for(uint32_t y = 0; y < h; y++) {
 800c3f6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800c3f8:	3301      	adds	r3, #1
 800c3fa:	64bb      	str	r3, [r7, #72]	@ 0x48
 800c3fc:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800c3fe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800c400:	429a      	cmp	r2, r3
 800c402:	d3db      	bcc.n	800c3bc <lv_draw_buf_premultiply+0x1c4>
    }
    else {
        LV_LOG_WARN("draw buf has no alpha, cf: %d", cf);
    }

    draw_buf->header.flags |= LV_IMAGE_FLAGS_PREMULTIPLIED;
 800c404:	687b      	ldr	r3, [r7, #4]
 800c406:	885b      	ldrh	r3, [r3, #2]
 800c408:	f043 0301 	orr.w	r3, r3, #1
 800c40c:	b29a      	uxth	r2, r3
 800c40e:	687b      	ldr	r3, [r7, #4]
 800c410:	805a      	strh	r2, [r3, #2]

    return LV_RESULT_OK;
 800c412:	2301      	movs	r3, #1
}
 800c414:	4618      	mov	r0, r3
 800c416:	3778      	adds	r7, #120	@ 0x78
 800c418:	46bd      	mov	sp, r7
 800c41a:	bd80      	pop	{r7, pc}

0800c41c <buf_malloc>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void * buf_malloc(size_t size_bytes, lv_color_format_t color_format)
{
 800c41c:	b580      	push	{r7, lr}
 800c41e:	b082      	sub	sp, #8
 800c420:	af00      	add	r7, sp, #0
 800c422:	6078      	str	r0, [r7, #4]
 800c424:	460b      	mov	r3, r1
 800c426:	70fb      	strb	r3, [r7, #3]
    LV_UNUSED(color_format);

    /*Allocate larger memory to be sure it can be aligned as needed*/
    size_bytes += LV_DRAW_BUF_ALIGN - 1;
 800c428:	687b      	ldr	r3, [r7, #4]
 800c42a:	3303      	adds	r3, #3
 800c42c:	607b      	str	r3, [r7, #4]
    return lv_malloc(size_bytes);
 800c42e:	6878      	ldr	r0, [r7, #4]
 800c430:	f019 fcca 	bl	8025dc8 <lv_malloc>
 800c434:	4603      	mov	r3, r0
}
 800c436:	4618      	mov	r0, r3
 800c438:	3708      	adds	r7, #8
 800c43a:	46bd      	mov	sp, r7
 800c43c:	bd80      	pop	{r7, pc}

0800c43e <buf_free>:

static void buf_free(void * buf)
{
 800c43e:	b580      	push	{r7, lr}
 800c440:	b082      	sub	sp, #8
 800c442:	af00      	add	r7, sp, #0
 800c444:	6078      	str	r0, [r7, #4]
    lv_free(buf);
 800c446:	6878      	ldr	r0, [r7, #4]
 800c448:	f019 fcf6 	bl	8025e38 <lv_free>
}
 800c44c:	bf00      	nop
 800c44e:	3708      	adds	r7, #8
 800c450:	46bd      	mov	sp, r7
 800c452:	bd80      	pop	{r7, pc}

0800c454 <buf_align>:

static void * buf_align(void * buf, lv_color_format_t color_format)
{
 800c454:	b480      	push	{r7}
 800c456:	b085      	sub	sp, #20
 800c458:	af00      	add	r7, sp, #0
 800c45a:	6078      	str	r0, [r7, #4]
 800c45c:	460b      	mov	r3, r1
 800c45e:	70fb      	strb	r3, [r7, #3]
    LV_UNUSED(color_format);

    uint8_t * buf_u8 = buf;
 800c460:	687b      	ldr	r3, [r7, #4]
 800c462:	60fb      	str	r3, [r7, #12]
    if(buf_u8) {
 800c464:	68fb      	ldr	r3, [r7, #12]
 800c466:	2b00      	cmp	r3, #0
 800c468:	d006      	beq.n	800c478 <buf_align+0x24>
        buf_u8 += LV_DRAW_BUF_ALIGN - 1;
 800c46a:	68fb      	ldr	r3, [r7, #12]
 800c46c:	3303      	adds	r3, #3
 800c46e:	60fb      	str	r3, [r7, #12]
        buf_u8 = (uint8_t *)((lv_uintptr_t) buf_u8 & ~(LV_DRAW_BUF_ALIGN - 1));
 800c470:	68fb      	ldr	r3, [r7, #12]
 800c472:	f023 0303 	bic.w	r3, r3, #3
 800c476:	60fb      	str	r3, [r7, #12]
    }
    return buf_u8;
 800c478:	68fb      	ldr	r3, [r7, #12]
}
 800c47a:	4618      	mov	r0, r3
 800c47c:	3714      	adds	r7, #20
 800c47e:	46bd      	mov	sp, r7
 800c480:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c484:	4770      	bx	lr

0800c486 <width_to_stride>:

static uint32_t width_to_stride(uint32_t w, lv_color_format_t color_format)
{
 800c486:	b580      	push	{r7, lr}
 800c488:	b084      	sub	sp, #16
 800c48a:	af00      	add	r7, sp, #0
 800c48c:	6078      	str	r0, [r7, #4]
 800c48e:	460b      	mov	r3, r1
 800c490:	70fb      	strb	r3, [r7, #3]
    uint32_t width_byte;
    width_byte = w * lv_color_format_get_bpp(color_format);
 800c492:	78fb      	ldrb	r3, [r7, #3]
 800c494:	4618      	mov	r0, r3
 800c496:	f016 f837 	bl	8022508 <lv_color_format_get_bpp>
 800c49a:	4603      	mov	r3, r0
 800c49c:	461a      	mov	r2, r3
 800c49e:	687b      	ldr	r3, [r7, #4]
 800c4a0:	fb02 f303 	mul.w	r3, r2, r3
 800c4a4:	60fb      	str	r3, [r7, #12]
    width_byte = (width_byte + 7) >> 3; /*Round up*/
 800c4a6:	68fb      	ldr	r3, [r7, #12]
 800c4a8:	3307      	adds	r3, #7
 800c4aa:	08db      	lsrs	r3, r3, #3
 800c4ac:	60fb      	str	r3, [r7, #12]
    return (width_byte + LV_DRAW_BUF_STRIDE_ALIGN - 1) & ~(LV_DRAW_BUF_STRIDE_ALIGN - 1);
 800c4ae:	68fb      	ldr	r3, [r7, #12]
}
 800c4b0:	4618      	mov	r0, r3
 800c4b2:	3710      	adds	r7, #16
 800c4b4:	46bd      	mov	sp, r7
 800c4b6:	bd80      	pop	{r7, pc}

0800c4b8 <draw_buf_malloc>:

static void * draw_buf_malloc(size_t size_bytes, lv_color_format_t color_format)
{
 800c4b8:	b580      	push	{r7, lr}
 800c4ba:	b082      	sub	sp, #8
 800c4bc:	af00      	add	r7, sp, #0
 800c4be:	6078      	str	r0, [r7, #4]
 800c4c0:	460b      	mov	r3, r1
 800c4c2:	70fb      	strb	r3, [r7, #3]
    if(handlers.buf_malloc_cb) return handlers.buf_malloc_cb(size_bytes, color_format);
 800c4c4:	4b09      	ldr	r3, [pc, #36]	@ (800c4ec <draw_buf_malloc+0x34>)
 800c4c6:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
 800c4ca:	2b00      	cmp	r3, #0
 800c4cc:	d008      	beq.n	800c4e0 <draw_buf_malloc+0x28>
 800c4ce:	4b07      	ldr	r3, [pc, #28]	@ (800c4ec <draw_buf_malloc+0x34>)
 800c4d0:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
 800c4d4:	78fa      	ldrb	r2, [r7, #3]
 800c4d6:	4611      	mov	r1, r2
 800c4d8:	6878      	ldr	r0, [r7, #4]
 800c4da:	4798      	blx	r3
 800c4dc:	4603      	mov	r3, r0
 800c4de:	e000      	b.n	800c4e2 <draw_buf_malloc+0x2a>
    else return NULL;
 800c4e0:	2300      	movs	r3, #0
}
 800c4e2:	4618      	mov	r0, r3
 800c4e4:	3708      	adds	r7, #8
 800c4e6:	46bd      	mov	sp, r7
 800c4e8:	bd80      	pop	{r7, pc}
 800c4ea:	bf00      	nop
 800c4ec:	2000009c 	.word	0x2000009c

0800c4f0 <draw_buf_free>:

static void draw_buf_free(void * buf)
{
 800c4f0:	b580      	push	{r7, lr}
 800c4f2:	b082      	sub	sp, #8
 800c4f4:	af00      	add	r7, sp, #0
 800c4f6:	6078      	str	r0, [r7, #4]
    if(handlers.buf_free_cb) handlers.buf_free_cb(buf);
 800c4f8:	4b06      	ldr	r3, [pc, #24]	@ (800c514 <draw_buf_free+0x24>)
 800c4fa:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800c4fe:	2b00      	cmp	r3, #0
 800c500:	d004      	beq.n	800c50c <draw_buf_free+0x1c>
 800c502:	4b04      	ldr	r3, [pc, #16]	@ (800c514 <draw_buf_free+0x24>)
 800c504:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800c508:	6878      	ldr	r0, [r7, #4]
 800c50a:	4798      	blx	r3
}
 800c50c:	bf00      	nop
 800c50e:	3708      	adds	r7, #8
 800c510:	46bd      	mov	sp, r7
 800c512:	bd80      	pop	{r7, pc}
 800c514:	2000009c 	.word	0x2000009c

0800c518 <_calculate_draw_buf_size>:

/**
 * For given width, height, color format, and stride, calculate the size needed for a new draw buffer.
 */
static uint32_t _calculate_draw_buf_size(uint32_t w, uint32_t h, lv_color_format_t cf, uint32_t stride)
{
 800c518:	b580      	push	{r7, lr}
 800c51a:	b086      	sub	sp, #24
 800c51c:	af00      	add	r7, sp, #0
 800c51e:	60f8      	str	r0, [r7, #12]
 800c520:	60b9      	str	r1, [r7, #8]
 800c522:	603b      	str	r3, [r7, #0]
 800c524:	4613      	mov	r3, r2
 800c526:	71fb      	strb	r3, [r7, #7]
    uint32_t size;

    if(stride == 0) stride = lv_draw_buf_width_to_stride(w, cf);
 800c528:	683b      	ldr	r3, [r7, #0]
 800c52a:	2b00      	cmp	r3, #0
 800c52c:	d105      	bne.n	800c53a <_calculate_draw_buf_size+0x22>
 800c52e:	79fb      	ldrb	r3, [r7, #7]
 800c530:	4619      	mov	r1, r3
 800c532:	68f8      	ldr	r0, [r7, #12]
 800c534:	f7ff fb46 	bl	800bbc4 <lv_draw_buf_width_to_stride>
 800c538:	6038      	str	r0, [r7, #0]

    size = stride * h;
 800c53a:	683b      	ldr	r3, [r7, #0]
 800c53c:	68ba      	ldr	r2, [r7, #8]
 800c53e:	fb02 f303 	mul.w	r3, r2, r3
 800c542:	617b      	str	r3, [r7, #20]
    if(cf == LV_COLOR_FORMAT_RGB565A8) {
 800c544:	79fb      	ldrb	r3, [r7, #7]
 800c546:	2b14      	cmp	r3, #20
 800c548:	d108      	bne.n	800c55c <_calculate_draw_buf_size+0x44>
        size += (stride / 2) * h; /*A8 mask*/
 800c54a:	683b      	ldr	r3, [r7, #0]
 800c54c:	085b      	lsrs	r3, r3, #1
 800c54e:	68ba      	ldr	r2, [r7, #8]
 800c550:	fb02 f303 	mul.w	r3, r2, r3
 800c554:	697a      	ldr	r2, [r7, #20]
 800c556:	4413      	add	r3, r2
 800c558:	617b      	str	r3, [r7, #20]
 800c55a:	e01e      	b.n	800c59a <_calculate_draw_buf_size+0x82>
    }
    else if(LV_COLOR_FORMAT_IS_INDEXED(cf)) {
 800c55c:	79fb      	ldrb	r3, [r7, #7]
 800c55e:	2b06      	cmp	r3, #6
 800c560:	d91b      	bls.n	800c59a <_calculate_draw_buf_size+0x82>
 800c562:	79fb      	ldrb	r3, [r7, #7]
 800c564:	2b0a      	cmp	r3, #10
 800c566:	d818      	bhi.n	800c59a <_calculate_draw_buf_size+0x82>
        /*@todo we have to include palette right before image data*/
        size += LV_COLOR_INDEXED_PALETTE_SIZE(cf) * 4;
 800c568:	79fb      	ldrb	r3, [r7, #7]
 800c56a:	2b07      	cmp	r3, #7
 800c56c:	d011      	beq.n	800c592 <_calculate_draw_buf_size+0x7a>
 800c56e:	79fb      	ldrb	r3, [r7, #7]
 800c570:	2b08      	cmp	r3, #8
 800c572:	d00c      	beq.n	800c58e <_calculate_draw_buf_size+0x76>
 800c574:	79fb      	ldrb	r3, [r7, #7]
 800c576:	2b09      	cmp	r3, #9
 800c578:	d007      	beq.n	800c58a <_calculate_draw_buf_size+0x72>
 800c57a:	79fb      	ldrb	r3, [r7, #7]
 800c57c:	2b0a      	cmp	r3, #10
 800c57e:	d102      	bne.n	800c586 <_calculate_draw_buf_size+0x6e>
 800c580:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 800c584:	e006      	b.n	800c594 <_calculate_draw_buf_size+0x7c>
 800c586:	2300      	movs	r3, #0
 800c588:	e004      	b.n	800c594 <_calculate_draw_buf_size+0x7c>
 800c58a:	2340      	movs	r3, #64	@ 0x40
 800c58c:	e002      	b.n	800c594 <_calculate_draw_buf_size+0x7c>
 800c58e:	2310      	movs	r3, #16
 800c590:	e000      	b.n	800c594 <_calculate_draw_buf_size+0x7c>
 800c592:	2308      	movs	r3, #8
 800c594:	697a      	ldr	r2, [r7, #20]
 800c596:	4413      	add	r3, r2
 800c598:	617b      	str	r3, [r7, #20]
    }

    return size;
 800c59a:	697b      	ldr	r3, [r7, #20]
}
 800c59c:	4618      	mov	r0, r3
 800c59e:	3718      	adds	r7, #24
 800c5a0:	46bd      	mov	sp, r7
 800c5a2:	bd80      	pop	{r7, pc}

0800c5a4 <lv_area_copy>:
{
 800c5a4:	b480      	push	{r7}
 800c5a6:	b083      	sub	sp, #12
 800c5a8:	af00      	add	r7, sp, #0
 800c5aa:	6078      	str	r0, [r7, #4]
 800c5ac:	6039      	str	r1, [r7, #0]
    dest->x1 = src->x1;
 800c5ae:	683b      	ldr	r3, [r7, #0]
 800c5b0:	681a      	ldr	r2, [r3, #0]
 800c5b2:	687b      	ldr	r3, [r7, #4]
 800c5b4:	601a      	str	r2, [r3, #0]
    dest->y1 = src->y1;
 800c5b6:	683b      	ldr	r3, [r7, #0]
 800c5b8:	685a      	ldr	r2, [r3, #4]
 800c5ba:	687b      	ldr	r3, [r7, #4]
 800c5bc:	605a      	str	r2, [r3, #4]
    dest->x2 = src->x2;
 800c5be:	683b      	ldr	r3, [r7, #0]
 800c5c0:	689a      	ldr	r2, [r3, #8]
 800c5c2:	687b      	ldr	r3, [r7, #4]
 800c5c4:	609a      	str	r2, [r3, #8]
    dest->y2 = src->y2;
 800c5c6:	683b      	ldr	r3, [r7, #0]
 800c5c8:	68da      	ldr	r2, [r3, #12]
 800c5ca:	687b      	ldr	r3, [r7, #4]
 800c5cc:	60da      	str	r2, [r3, #12]
}
 800c5ce:	bf00      	nop
 800c5d0:	370c      	adds	r7, #12
 800c5d2:	46bd      	mov	sp, r7
 800c5d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5d8:	4770      	bx	lr

0800c5da <lv_area_get_width>:
{
 800c5da:	b480      	push	{r7}
 800c5dc:	b083      	sub	sp, #12
 800c5de:	af00      	add	r7, sp, #0
 800c5e0:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 800c5e2:	687b      	ldr	r3, [r7, #4]
 800c5e4:	689a      	ldr	r2, [r3, #8]
 800c5e6:	687b      	ldr	r3, [r7, #4]
 800c5e8:	681b      	ldr	r3, [r3, #0]
 800c5ea:	1ad3      	subs	r3, r2, r3
 800c5ec:	3301      	adds	r3, #1
}
 800c5ee:	4618      	mov	r0, r3
 800c5f0:	370c      	adds	r7, #12
 800c5f2:	46bd      	mov	sp, r7
 800c5f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c5f8:	4770      	bx	lr

0800c5fa <lv_area_get_height>:
{
 800c5fa:	b480      	push	{r7}
 800c5fc:	b083      	sub	sp, #12
 800c5fe:	af00      	add	r7, sp, #0
 800c600:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 800c602:	687b      	ldr	r3, [r7, #4]
 800c604:	68da      	ldr	r2, [r3, #12]
 800c606:	687b      	ldr	r3, [r7, #4]
 800c608:	685b      	ldr	r3, [r3, #4]
 800c60a:	1ad3      	subs	r3, r2, r3
 800c60c:	3301      	adds	r3, #1
}
 800c60e:	4618      	mov	r0, r3
 800c610:	370c      	adds	r7, #12
 800c612:	46bd      	mov	sp, r7
 800c614:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c618:	4770      	bx	lr

0800c61a <lv_color_make>:
 * @param g     the green channel (0..255)
 * @param b     the blue channel (0..255)
 * @return      the color
 */
static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
{
 800c61a:	b480      	push	{r7}
 800c61c:	b085      	sub	sp, #20
 800c61e:	af00      	add	r7, sp, #0
 800c620:	4603      	mov	r3, r0
 800c622:	71fb      	strb	r3, [r7, #7]
 800c624:	460b      	mov	r3, r1
 800c626:	71bb      	strb	r3, [r7, #6]
 800c628:	4613      	mov	r3, r2
 800c62a:	717b      	strb	r3, [r7, #5]
    lv_color_t ret;
    ret.red = r;
 800c62c:	79fb      	ldrb	r3, [r7, #7]
 800c62e:	72bb      	strb	r3, [r7, #10]
    ret.green = g;
 800c630:	79bb      	ldrb	r3, [r7, #6]
 800c632:	727b      	strb	r3, [r7, #9]
    ret.blue = b;
 800c634:	797b      	ldrb	r3, [r7, #5]
 800c636:	723b      	strb	r3, [r7, #8]
    return ret;
 800c638:	f107 030c 	add.w	r3, r7, #12
 800c63c:	f107 0208 	add.w	r2, r7, #8
 800c640:	6812      	ldr	r2, [r2, #0]
 800c642:	4611      	mov	r1, r2
 800c644:	8019      	strh	r1, [r3, #0]
 800c646:	3302      	adds	r3, #2
 800c648:	0c12      	lsrs	r2, r2, #16
 800c64a:	701a      	strb	r2, [r3, #0]
 800c64c:	2300      	movs	r3, #0
 800c64e:	7b3a      	ldrb	r2, [r7, #12]
 800c650:	f362 0307 	bfi	r3, r2, #0, #8
 800c654:	7b7a      	ldrb	r2, [r7, #13]
 800c656:	f362 230f 	bfi	r3, r2, #8, #8
 800c65a:	7bba      	ldrb	r2, [r7, #14]
 800c65c:	f362 4317 	bfi	r3, r2, #16, #8
}
 800c660:	4618      	mov	r0, r3
 800c662:	3714      	adds	r7, #20
 800c664:	46bd      	mov	sp, r7
 800c666:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c66a:	4770      	bx	lr

0800c66c <lv_color_black>:
/**
 * A helper for black color
 * @return      a black color
 */
static inline lv_color_t lv_color_black(void)
{
 800c66c:	b580      	push	{r7, lr}
 800c66e:	b082      	sub	sp, #8
 800c670:	af00      	add	r7, sp, #0
    return lv_color_make(0x00, 0x00, 0x00);
 800c672:	2200      	movs	r2, #0
 800c674:	2100      	movs	r1, #0
 800c676:	2000      	movs	r0, #0
 800c678:	f7ff ffcf 	bl	800c61a <lv_color_make>
 800c67c:	4603      	mov	r3, r0
 800c67e:	461a      	mov	r2, r3
 800c680:	713a      	strb	r2, [r7, #4]
 800c682:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800c686:	717a      	strb	r2, [r7, #5]
 800c688:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800c68c:	71bb      	strb	r3, [r7, #6]
 800c68e:	2300      	movs	r3, #0
 800c690:	793a      	ldrb	r2, [r7, #4]
 800c692:	f362 0307 	bfi	r3, r2, #0, #8
 800c696:	797a      	ldrb	r2, [r7, #5]
 800c698:	f362 230f 	bfi	r3, r2, #8, #8
 800c69c:	79ba      	ldrb	r2, [r7, #6]
 800c69e:	f362 4317 	bfi	r3, r2, #16, #8
}
 800c6a2:	4618      	mov	r0, r3
 800c6a4:	3708      	adds	r7, #8
 800c6a6:	46bd      	mov	sp, r7
 800c6a8:	bd80      	pop	{r7, pc}

0800c6aa <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 800c6aa:	b580      	push	{r7, lr}
 800c6ac:	b082      	sub	sp, #8
 800c6ae:	af00      	add	r7, sp, #0
 800c6b0:	6078      	str	r0, [r7, #4]
 800c6b2:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 800c6b4:	683a      	ldr	r2, [r7, #0]
 800c6b6:	2100      	movs	r1, #0
 800c6b8:	6878      	ldr	r0, [r7, #4]
 800c6ba:	f018 fbb2 	bl	8024e22 <lv_memset>
}
 800c6be:	bf00      	nop
 800c6c0:	3708      	adds	r7, #8
 800c6c2:	46bd      	mov	sp, r7
 800c6c4:	bd80      	pop	{r7, pc}
	...

0800c6c8 <lv_draw_image_dsc_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_image_dsc_init(lv_draw_image_dsc_t * dsc)
{
 800c6c8:	b590      	push	{r4, r7, lr}
 800c6ca:	b083      	sub	sp, #12
 800c6cc:	af00      	add	r7, sp, #0
 800c6ce:	6078      	str	r0, [r7, #4]
    lv_memzero(dsc, sizeof(lv_draw_image_dsc_t));
 800c6d0:	2168      	movs	r1, #104	@ 0x68
 800c6d2:	6878      	ldr	r0, [r7, #4]
 800c6d4:	f7ff ffe9 	bl	800c6aa <lv_memzero>
    dsc->recolor = lv_color_black();
 800c6d8:	687c      	ldr	r4, [r7, #4]
 800c6da:	f7ff ffc7 	bl	800c66c <lv_color_black>
 800c6de:	4603      	mov	r3, r0
 800c6e0:	461a      	mov	r2, r3
 800c6e2:	f884 2048 	strb.w	r2, [r4, #72]	@ 0x48
 800c6e6:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800c6ea:	f884 2049 	strb.w	r2, [r4, #73]	@ 0x49
 800c6ee:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800c6f2:	f884 304a 	strb.w	r3, [r4, #74]	@ 0x4a
    dsc->opa = LV_OPA_COVER;
 800c6f6:	687b      	ldr	r3, [r7, #4]
 800c6f8:	22ff      	movs	r2, #255	@ 0xff
 800c6fa:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
    dsc->scale_x = LV_SCALE_NONE;
 800c6fe:	687b      	ldr	r3, [r7, #4]
 800c700:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800c704:	631a      	str	r2, [r3, #48]	@ 0x30
    dsc->scale_y = LV_SCALE_NONE;
 800c706:	687b      	ldr	r3, [r7, #4]
 800c708:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800c70c:	635a      	str	r2, [r3, #52]	@ 0x34
    dsc->antialias = LV_COLOR_DEPTH > 8 ? 1 : 0;
 800c70e:	687a      	ldr	r2, [r7, #4]
 800c710:	f892 304d 	ldrb.w	r3, [r2, #77]	@ 0x4d
 800c714:	f043 0310 	orr.w	r3, r3, #16
 800c718:	f882 304d 	strb.w	r3, [r2, #77]	@ 0x4d
    dsc->original_area.x2 = LV_COORD_MIN;   /*Indicate invalid area by default by setting a negative size*/
 800c71c:	687b      	ldr	r3, [r7, #4]
 800c71e:	4a04      	ldr	r2, [pc, #16]	@ (800c730 <lv_draw_image_dsc_init+0x68>)
 800c720:	65da      	str	r2, [r3, #92]	@ 0x5c
    dsc->base.dsc_size = sizeof(lv_draw_image_dsc_t);
 800c722:	687b      	ldr	r3, [r7, #4]
 800c724:	2268      	movs	r2, #104	@ 0x68
 800c726:	615a      	str	r2, [r3, #20]
}
 800c728:	bf00      	nop
 800c72a:	370c      	adds	r7, #12
 800c72c:	46bd      	mov	sp, r7
 800c72e:	bd90      	pop	{r4, r7, pc}
 800c730:	e0000001 	.word	0xe0000001

0800c734 <lv_image_src_get_type>:
    lv_draw_finalize_task_creation(layer, t);
    LV_PROFILER_END;
}

lv_image_src_t lv_image_src_get_type(const void * src)
{
 800c734:	b480      	push	{r7}
 800c736:	b085      	sub	sp, #20
 800c738:	af00      	add	r7, sp, #0
 800c73a:	6078      	str	r0, [r7, #4]
    if(src == NULL) return LV_IMAGE_SRC_UNKNOWN;
 800c73c:	687b      	ldr	r3, [r7, #4]
 800c73e:	2b00      	cmp	r3, #0
 800c740:	d101      	bne.n	800c746 <lv_image_src_get_type+0x12>
 800c742:	2303      	movs	r3, #3
 800c744:	e014      	b.n	800c770 <lv_image_src_get_type+0x3c>
    const uint8_t * u8_p = src;
 800c746:	687b      	ldr	r3, [r7, #4]
 800c748:	60fb      	str	r3, [r7, #12]

    /*The first byte shows the type of the image source*/
    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {
 800c74a:	68fb      	ldr	r3, [r7, #12]
 800c74c:	781b      	ldrb	r3, [r3, #0]
 800c74e:	2b1f      	cmp	r3, #31
 800c750:	d906      	bls.n	800c760 <lv_image_src_get_type+0x2c>
 800c752:	68fb      	ldr	r3, [r7, #12]
 800c754:	781b      	ldrb	r3, [r3, #0]
 800c756:	b25b      	sxtb	r3, r3
 800c758:	2b00      	cmp	r3, #0
 800c75a:	db01      	blt.n	800c760 <lv_image_src_get_type+0x2c>
        return LV_IMAGE_SRC_FILE; /*If it's an ASCII character then it's file name*/
 800c75c:	2301      	movs	r3, #1
 800c75e:	e007      	b.n	800c770 <lv_image_src_get_type+0x3c>
    }
    else if(u8_p[0] >= 0x80) {
 800c760:	68fb      	ldr	r3, [r7, #12]
 800c762:	781b      	ldrb	r3, [r3, #0]
 800c764:	b25b      	sxtb	r3, r3
 800c766:	2b00      	cmp	r3, #0
 800c768:	da01      	bge.n	800c76e <lv_image_src_get_type+0x3a>
        return LV_IMAGE_SRC_SYMBOL; /*Symbols begins after 0x7F*/
 800c76a:	2302      	movs	r3, #2
 800c76c:	e000      	b.n	800c770 <lv_image_src_get_type+0x3c>
    }
    else {
        return LV_IMAGE_SRC_VARIABLE; /*`lv_image_dsc_t` is draw to the first byte < 0x20*/
 800c76e:	2300      	movs	r3, #0
    }
}
 800c770:	4618      	mov	r0, r3
 800c772:	3714      	adds	r7, #20
 800c774:	46bd      	mov	sp, r7
 800c776:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c77a:	4770      	bx	lr

0800c77c <_lv_draw_image_normal_helper>:

void _lv_draw_image_normal_helper(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                                  const lv_area_t * coords, lv_draw_image_core_cb draw_core_cb)
{
 800c77c:	b590      	push	{r4, r7, lr}
 800c77e:	b0a3      	sub	sp, #140	@ 0x8c
 800c780:	af04      	add	r7, sp, #16
 800c782:	60f8      	str	r0, [r7, #12]
 800c784:	60b9      	str	r1, [r7, #8]
 800c786:	607a      	str	r2, [r7, #4]
 800c788:	603b      	str	r3, [r7, #0]
    if(draw_core_cb == NULL) {
 800c78a:	683b      	ldr	r3, [r7, #0]
 800c78c:	2b00      	cmp	r3, #0
 800c78e:	d075      	beq.n	800c87c <_lv_draw_image_normal_helper+0x100>
        LV_LOG_WARN("draw_core_cb is NULL");
        return;
    }

    lv_area_t draw_area;
    lv_area_copy(&draw_area, coords);
 800c790:	f107 035c 	add.w	r3, r7, #92	@ 0x5c
 800c794:	6879      	ldr	r1, [r7, #4]
 800c796:	4618      	mov	r0, r3
 800c798:	f7ff ff04 	bl	800c5a4 <lv_area_copy>
    if(draw_dsc->rotation || draw_dsc->scale_x != LV_SCALE_NONE || draw_dsc->scale_y != LV_SCALE_NONE) {
 800c79c:	68bb      	ldr	r3, [r7, #8]
 800c79e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c7a0:	2b00      	cmp	r3, #0
 800c7a2:	d109      	bne.n	800c7b8 <_lv_draw_image_normal_helper+0x3c>
 800c7a4:	68bb      	ldr	r3, [r7, #8]
 800c7a6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c7a8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800c7ac:	d104      	bne.n	800c7b8 <_lv_draw_image_normal_helper+0x3c>
 800c7ae:	68bb      	ldr	r3, [r7, #8]
 800c7b0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c7b2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800c7b6:	d02f      	beq.n	800c818 <_lv_draw_image_normal_helper+0x9c>
        int32_t w = lv_area_get_width(coords);
 800c7b8:	6878      	ldr	r0, [r7, #4]
 800c7ba:	f7ff ff0e 	bl	800c5da <lv_area_get_width>
 800c7be:	6778      	str	r0, [r7, #116]	@ 0x74
        int32_t h = lv_area_get_height(coords);
 800c7c0:	6878      	ldr	r0, [r7, #4]
 800c7c2:	f7ff ff1a 	bl	800c5fa <lv_area_get_height>
 800c7c6:	6738      	str	r0, [r7, #112]	@ 0x70

        _lv_image_buf_get_transformed_area(&draw_area, w, h, draw_dsc->rotation, draw_dsc->scale_x, draw_dsc->scale_y,
 800c7c8:	68bb      	ldr	r3, [r7, #8]
 800c7ca:	6adc      	ldr	r4, [r3, #44]	@ 0x2c
 800c7cc:	68bb      	ldr	r3, [r7, #8]
 800c7ce:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c7d0:	b29b      	uxth	r3, r3
 800c7d2:	68ba      	ldr	r2, [r7, #8]
 800c7d4:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 800c7d6:	b292      	uxth	r2, r2
 800c7d8:	68b9      	ldr	r1, [r7, #8]
 800c7da:	3140      	adds	r1, #64	@ 0x40
 800c7dc:	f107 005c 	add.w	r0, r7, #92	@ 0x5c
 800c7e0:	9102      	str	r1, [sp, #8]
 800c7e2:	9201      	str	r2, [sp, #4]
 800c7e4:	9300      	str	r3, [sp, #0]
 800c7e6:	4623      	mov	r3, r4
 800c7e8:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 800c7ea:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 800c7ec:	f000 f8e4 	bl	800c9b8 <_lv_image_buf_get_transformed_area>
                                           &draw_dsc->pivot);

        draw_area.x1 += coords->x1;
 800c7f0:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 800c7f2:	687b      	ldr	r3, [r7, #4]
 800c7f4:	681b      	ldr	r3, [r3, #0]
 800c7f6:	4413      	add	r3, r2
 800c7f8:	65fb      	str	r3, [r7, #92]	@ 0x5c
        draw_area.y1 += coords->y1;
 800c7fa:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 800c7fc:	687b      	ldr	r3, [r7, #4]
 800c7fe:	685b      	ldr	r3, [r3, #4]
 800c800:	4413      	add	r3, r2
 800c802:	663b      	str	r3, [r7, #96]	@ 0x60
        draw_area.x2 += coords->x1;
 800c804:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 800c806:	687b      	ldr	r3, [r7, #4]
 800c808:	681b      	ldr	r3, [r3, #0]
 800c80a:	4413      	add	r3, r2
 800c80c:	667b      	str	r3, [r7, #100]	@ 0x64
        draw_area.y2 += coords->y1;
 800c80e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 800c810:	687b      	ldr	r3, [r7, #4]
 800c812:	685b      	ldr	r3, [r3, #4]
 800c814:	4413      	add	r3, r2
 800c816:	66bb      	str	r3, [r7, #104]	@ 0x68
    }

    lv_area_t clipped_img_area;
    if(!_lv_area_intersect(&clipped_img_area, &draw_area, draw_unit->clip_area)) {
 800c818:	68fb      	ldr	r3, [r7, #12]
 800c81a:	689a      	ldr	r2, [r3, #8]
 800c81c:	f107 015c 	add.w	r1, r7, #92	@ 0x5c
 800c820:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
 800c824:	4618      	mov	r0, r3
 800c826:	f015 f88f 	bl	8021948 <_lv_area_intersect>
 800c82a:	4603      	mov	r3, r0
 800c82c:	f083 0301 	eor.w	r3, r3, #1
 800c830:	b2db      	uxtb	r3, r3
 800c832:	2b00      	cmp	r3, #0
 800c834:	d124      	bne.n	800c880 <_lv_draw_image_normal_helper+0x104>
        return;
    }

    lv_image_decoder_dsc_t decoder_dsc;
    lv_result_t res = lv_image_decoder_open(&decoder_dsc, draw_dsc->src, NULL);
 800c836:	68bb      	ldr	r3, [r7, #8]
 800c838:	69d9      	ldr	r1, [r3, #28]
 800c83a:	f107 0310 	add.w	r3, r7, #16
 800c83e:	2200      	movs	r2, #0
 800c840:	4618      	mov	r0, r3
 800c842:	f001 fe67 	bl	800e514 <lv_image_decoder_open>
 800c846:	4603      	mov	r3, r0
 800c848:	f887 306f 	strb.w	r3, [r7, #111]	@ 0x6f
    if(res != LV_RESULT_OK) {
 800c84c:	f897 306f 	ldrb.w	r3, [r7, #111]	@ 0x6f
 800c850:	2b01      	cmp	r3, #1
 800c852:	d117      	bne.n	800c884 <_lv_draw_image_normal_helper+0x108>
        LV_LOG_ERROR("Failed to open image");
        return;
    }

    img_decode_and_draw(draw_unit, draw_dsc, &decoder_dsc, NULL, coords, &clipped_img_area, draw_core_cb);
 800c854:	f107 0210 	add.w	r2, r7, #16
 800c858:	683b      	ldr	r3, [r7, #0]
 800c85a:	9302      	str	r3, [sp, #8]
 800c85c:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
 800c860:	9301      	str	r3, [sp, #4]
 800c862:	687b      	ldr	r3, [r7, #4]
 800c864:	9300      	str	r3, [sp, #0]
 800c866:	2300      	movs	r3, #0
 800c868:	68b9      	ldr	r1, [r7, #8]
 800c86a:	68f8      	ldr	r0, [r7, #12]
 800c86c:	f000 f94c 	bl	800cb08 <img_decode_and_draw>

    lv_image_decoder_close(&decoder_dsc);
 800c870:	f107 0310 	add.w	r3, r7, #16
 800c874:	4618      	mov	r0, r3
 800c876:	f001 fead 	bl	800e5d4 <lv_image_decoder_close>
 800c87a:	e004      	b.n	800c886 <_lv_draw_image_normal_helper+0x10a>
        return;
 800c87c:	bf00      	nop
 800c87e:	e002      	b.n	800c886 <_lv_draw_image_normal_helper+0x10a>
        return;
 800c880:	bf00      	nop
 800c882:	e000      	b.n	800c886 <_lv_draw_image_normal_helper+0x10a>
        return;
 800c884:	bf00      	nop
}
 800c886:	377c      	adds	r7, #124	@ 0x7c
 800c888:	46bd      	mov	sp, r7
 800c88a:	bd90      	pop	{r4, r7, pc}

0800c88c <_lv_draw_image_tiled_helper>:

void _lv_draw_image_tiled_helper(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                                 const lv_area_t * coords, lv_draw_image_core_cb draw_core_cb)
{
 800c88c:	b590      	push	{r4, r7, lr}
 800c88e:	b0a9      	sub	sp, #164	@ 0xa4
 800c890:	af04      	add	r7, sp, #16
 800c892:	60f8      	str	r0, [r7, #12]
 800c894:	60b9      	str	r1, [r7, #8]
 800c896:	607a      	str	r2, [r7, #4]
 800c898:	603b      	str	r3, [r7, #0]
    if(draw_core_cb == NULL) {
 800c89a:	683b      	ldr	r3, [r7, #0]
 800c89c:	2b00      	cmp	r3, #0
 800c89e:	f000 8082 	beq.w	800c9a6 <_lv_draw_image_tiled_helper+0x11a>
        LV_LOG_WARN("draw_core_cb is NULL");
        return;
    }

    lv_image_decoder_dsc_t decoder_dsc;
    lv_result_t res = lv_image_decoder_open(&decoder_dsc, draw_dsc->src, NULL);
 800c8a2:	68bb      	ldr	r3, [r7, #8]
 800c8a4:	69d9      	ldr	r1, [r3, #28]
 800c8a6:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 800c8aa:	2200      	movs	r2, #0
 800c8ac:	4618      	mov	r0, r3
 800c8ae:	f001 fe31 	bl	800e514 <lv_image_decoder_open>
 800c8b2:	4603      	mov	r3, r0
 800c8b4:	f887 308f 	strb.w	r3, [r7, #143]	@ 0x8f
    if(res != LV_RESULT_OK) {
 800c8b8:	f897 308f 	ldrb.w	r3, [r7, #143]	@ 0x8f
 800c8bc:	2b01      	cmp	r3, #1
 800c8be:	d174      	bne.n	800c9aa <_lv_draw_image_tiled_helper+0x11e>
        LV_LOG_ERROR("Failed to open image");
        return;
    }

    int32_t img_w = draw_dsc->header.w;
 800c8c0:	68bb      	ldr	r3, [r7, #8]
 800c8c2:	8c9b      	ldrh	r3, [r3, #36]	@ 0x24
 800c8c4:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    int32_t img_h = draw_dsc->header.h;
 800c8c8:	68bb      	ldr	r3, [r7, #8]
 800c8ca:	8cdb      	ldrh	r3, [r3, #38]	@ 0x26
 800c8cc:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84

    lv_area_t tile_area = *coords;
 800c8d0:	687b      	ldr	r3, [r7, #4]
 800c8d2:	f107 0434 	add.w	r4, r7, #52	@ 0x34
 800c8d6:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800c8d8:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    lv_area_set_width(&tile_area, img_w);
 800c8dc:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 800c8e0:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 800c8e4:	4618      	mov	r0, r3
 800c8e6:	f014 ffa8 	bl	802183a <lv_area_set_width>
    lv_area_set_height(&tile_area, img_h);
 800c8ea:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 800c8ee:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 800c8f2:	4618      	mov	r0, r3
 800c8f4:	f014 ffb3 	bl	802185e <lv_area_set_height>

    int32_t tile_x_start = tile_area.x1;
 800c8f8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800c8fa:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

    lv_area_t relative_decoded_area = {
 800c8fe:	4b2d      	ldr	r3, [pc, #180]	@ (800c9b4 <_lv_draw_image_tiled_helper+0x128>)
 800c900:	f107 0424 	add.w	r4, r7, #36	@ 0x24
 800c904:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800c906:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        .y1 = LV_COORD_MIN,
        .x2 = LV_COORD_MIN,
        .y2 = LV_COORD_MIN,
    };

    while(tile_area.y1 <= draw_unit->clip_area->y2) {
 800c90a:	e040      	b.n	800c98e <_lv_draw_image_tiled_helper+0x102>
        while(tile_area.x1 <= draw_unit->clip_area->x2) {

            lv_area_t clipped_img_area;
            if(_lv_area_intersect(&clipped_img_area, &tile_area, draw_unit->clip_area)) {
 800c90c:	68fb      	ldr	r3, [r7, #12]
 800c90e:	689a      	ldr	r2, [r3, #8]
 800c910:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 800c914:	f107 0314 	add.w	r3, r7, #20
 800c918:	4618      	mov	r0, r3
 800c91a:	f015 f815 	bl	8021948 <_lv_area_intersect>
 800c91e:	4603      	mov	r3, r0
 800c920:	2b00      	cmp	r3, #0
 800c922:	d010      	beq.n	800c946 <_lv_draw_image_tiled_helper+0xba>
                img_decode_and_draw(draw_unit, draw_dsc, &decoder_dsc, &relative_decoded_area, &tile_area, &clipped_img_area,
 800c924:	f107 0124 	add.w	r1, r7, #36	@ 0x24
 800c928:	f107 0244 	add.w	r2, r7, #68	@ 0x44
 800c92c:	683b      	ldr	r3, [r7, #0]
 800c92e:	9302      	str	r3, [sp, #8]
 800c930:	f107 0314 	add.w	r3, r7, #20
 800c934:	9301      	str	r3, [sp, #4]
 800c936:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 800c93a:	9300      	str	r3, [sp, #0]
 800c93c:	460b      	mov	r3, r1
 800c93e:	68b9      	ldr	r1, [r7, #8]
 800c940:	68f8      	ldr	r0, [r7, #12]
 800c942:	f000 f8e1 	bl	800cb08 <img_decode_and_draw>
                                    draw_core_cb);
            }

            tile_area.x1 += img_w;
 800c946:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800c948:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800c94c:	4413      	add	r3, r2
 800c94e:	637b      	str	r3, [r7, #52]	@ 0x34
            tile_area.x2 += img_w;
 800c950:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800c952:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800c956:	4413      	add	r3, r2
 800c958:	63fb      	str	r3, [r7, #60]	@ 0x3c
        while(tile_area.x1 <= draw_unit->clip_area->x2) {
 800c95a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800c95c:	68fb      	ldr	r3, [r7, #12]
 800c95e:	689b      	ldr	r3, [r3, #8]
 800c960:	689b      	ldr	r3, [r3, #8]
 800c962:	429a      	cmp	r2, r3
 800c964:	ddd2      	ble.n	800c90c <_lv_draw_image_tiled_helper+0x80>
        }

        tile_area.y1 += img_h;
 800c966:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800c968:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 800c96c:	4413      	add	r3, r2
 800c96e:	63bb      	str	r3, [r7, #56]	@ 0x38
        tile_area.y2 += img_h;
 800c970:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800c972:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 800c976:	4413      	add	r3, r2
 800c978:	643b      	str	r3, [r7, #64]	@ 0x40
        tile_area.x1 = tile_x_start;
 800c97a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800c97e:	637b      	str	r3, [r7, #52]	@ 0x34
        tile_area.x2 = tile_x_start + img_w - 1;
 800c980:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 800c984:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800c988:	4413      	add	r3, r2
 800c98a:	3b01      	subs	r3, #1
 800c98c:	63fb      	str	r3, [r7, #60]	@ 0x3c
    while(tile_area.y1 <= draw_unit->clip_area->y2) {
 800c98e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800c990:	68fb      	ldr	r3, [r7, #12]
 800c992:	689b      	ldr	r3, [r3, #8]
 800c994:	68db      	ldr	r3, [r3, #12]
 800c996:	429a      	cmp	r2, r3
 800c998:	dddf      	ble.n	800c95a <_lv_draw_image_tiled_helper+0xce>
    }

    lv_image_decoder_close(&decoder_dsc);
 800c99a:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 800c99e:	4618      	mov	r0, r3
 800c9a0:	f001 fe18 	bl	800e5d4 <lv_image_decoder_close>
 800c9a4:	e002      	b.n	800c9ac <_lv_draw_image_tiled_helper+0x120>
        return;
 800c9a6:	bf00      	nop
 800c9a8:	e000      	b.n	800c9ac <_lv_draw_image_tiled_helper+0x120>
        return;
 800c9aa:	bf00      	nop
}
 800c9ac:	3794      	adds	r7, #148	@ 0x94
 800c9ae:	46bd      	mov	sp, r7
 800c9b0:	bd90      	pop	{r4, r7, pc}
 800c9b2:	bf00      	nop
 800c9b4:	08027b80 	.word	0x08027b80

0800c9b8 <_lv_image_buf_get_transformed_area>:

void _lv_image_buf_get_transformed_area(lv_area_t * res, int32_t w, int32_t h, int32_t angle,
                                        uint16_t scale_x, uint16_t scale_y, const lv_point_t * pivot)
{
 800c9b8:	b580      	push	{r7, lr}
 800c9ba:	b08e      	sub	sp, #56	@ 0x38
 800c9bc:	af02      	add	r7, sp, #8
 800c9be:	60f8      	str	r0, [r7, #12]
 800c9c0:	60b9      	str	r1, [r7, #8]
 800c9c2:	607a      	str	r2, [r7, #4]
 800c9c4:	603b      	str	r3, [r7, #0]
    if(angle == 0 && scale_x == LV_SCALE_NONE && scale_y == LV_SCALE_NONE) {
 800c9c6:	683b      	ldr	r3, [r7, #0]
 800c9c8:	2b00      	cmp	r3, #0
 800c9ca:	d116      	bne.n	800c9fa <_lv_image_buf_get_transformed_area+0x42>
 800c9cc:	8f3b      	ldrh	r3, [r7, #56]	@ 0x38
 800c9ce:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800c9d2:	d112      	bne.n	800c9fa <_lv_image_buf_get_transformed_area+0x42>
 800c9d4:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 800c9d6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800c9da:	d10e      	bne.n	800c9fa <_lv_image_buf_get_transformed_area+0x42>
        res->x1 = 0;
 800c9dc:	68fb      	ldr	r3, [r7, #12]
 800c9de:	2200      	movs	r2, #0
 800c9e0:	601a      	str	r2, [r3, #0]
        res->y1 = 0;
 800c9e2:	68fb      	ldr	r3, [r7, #12]
 800c9e4:	2200      	movs	r2, #0
 800c9e6:	605a      	str	r2, [r3, #4]
        res->x2 = w - 1;
 800c9e8:	68bb      	ldr	r3, [r7, #8]
 800c9ea:	1e5a      	subs	r2, r3, #1
 800c9ec:	68fb      	ldr	r3, [r7, #12]
 800c9ee:	609a      	str	r2, [r3, #8]
        res->y2 = h - 1;
 800c9f0:	687b      	ldr	r3, [r7, #4]
 800c9f2:	1e5a      	subs	r2, r3, #1
 800c9f4:	68fb      	ldr	r3, [r7, #12]
 800c9f6:	60da      	str	r2, [r3, #12]
 800c9f8:	e083      	b.n	800cb02 <_lv_image_buf_get_transformed_area+0x14a>
        return;
    }

    lv_point_t p[4] = {
 800c9fa:	2300      	movs	r3, #0
 800c9fc:	613b      	str	r3, [r7, #16]
 800c9fe:	2300      	movs	r3, #0
 800ca00:	617b      	str	r3, [r7, #20]
 800ca02:	68bb      	ldr	r3, [r7, #8]
 800ca04:	61bb      	str	r3, [r7, #24]
 800ca06:	2300      	movs	r3, #0
 800ca08:	61fb      	str	r3, [r7, #28]
 800ca0a:	2300      	movs	r3, #0
 800ca0c:	623b      	str	r3, [r7, #32]
 800ca0e:	687b      	ldr	r3, [r7, #4]
 800ca10:	627b      	str	r3, [r7, #36]	@ 0x24
 800ca12:	68bb      	ldr	r3, [r7, #8]
 800ca14:	62bb      	str	r3, [r7, #40]	@ 0x28
 800ca16:	687b      	ldr	r3, [r7, #4]
 800ca18:	62fb      	str	r3, [r7, #44]	@ 0x2c
        {0, 0},
        {w, 0},
        {0, h},
        {w, h},
    };
    lv_point_transform(&p[0], angle, scale_x, scale_y, pivot, true);
 800ca1a:	8f3a      	ldrh	r2, [r7, #56]	@ 0x38
 800ca1c:	8fb9      	ldrh	r1, [r7, #60]	@ 0x3c
 800ca1e:	f107 0010 	add.w	r0, r7, #16
 800ca22:	2301      	movs	r3, #1
 800ca24:	9301      	str	r3, [sp, #4]
 800ca26:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ca28:	9300      	str	r3, [sp, #0]
 800ca2a:	460b      	mov	r3, r1
 800ca2c:	6839      	ldr	r1, [r7, #0]
 800ca2e:	f015 fbab 	bl	8022188 <lv_point_transform>
    lv_point_transform(&p[1], angle, scale_x, scale_y, pivot, true);
 800ca32:	8f3a      	ldrh	r2, [r7, #56]	@ 0x38
 800ca34:	8fb9      	ldrh	r1, [r7, #60]	@ 0x3c
 800ca36:	f107 0310 	add.w	r3, r7, #16
 800ca3a:	f103 0008 	add.w	r0, r3, #8
 800ca3e:	2301      	movs	r3, #1
 800ca40:	9301      	str	r3, [sp, #4]
 800ca42:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ca44:	9300      	str	r3, [sp, #0]
 800ca46:	460b      	mov	r3, r1
 800ca48:	6839      	ldr	r1, [r7, #0]
 800ca4a:	f015 fb9d 	bl	8022188 <lv_point_transform>
    lv_point_transform(&p[2], angle, scale_x, scale_y, pivot, true);
 800ca4e:	8f3a      	ldrh	r2, [r7, #56]	@ 0x38
 800ca50:	8fb9      	ldrh	r1, [r7, #60]	@ 0x3c
 800ca52:	f107 0310 	add.w	r3, r7, #16
 800ca56:	f103 0010 	add.w	r0, r3, #16
 800ca5a:	2301      	movs	r3, #1
 800ca5c:	9301      	str	r3, [sp, #4]
 800ca5e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ca60:	9300      	str	r3, [sp, #0]
 800ca62:	460b      	mov	r3, r1
 800ca64:	6839      	ldr	r1, [r7, #0]
 800ca66:	f015 fb8f 	bl	8022188 <lv_point_transform>
    lv_point_transform(&p[3], angle, scale_x, scale_y, pivot, true);
 800ca6a:	8f3a      	ldrh	r2, [r7, #56]	@ 0x38
 800ca6c:	8fb9      	ldrh	r1, [r7, #60]	@ 0x3c
 800ca6e:	f107 0310 	add.w	r3, r7, #16
 800ca72:	f103 0018 	add.w	r0, r3, #24
 800ca76:	2301      	movs	r3, #1
 800ca78:	9301      	str	r3, [sp, #4]
 800ca7a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800ca7c:	9300      	str	r3, [sp, #0]
 800ca7e:	460b      	mov	r3, r1
 800ca80:	6839      	ldr	r1, [r7, #0]
 800ca82:	f015 fb81 	bl	8022188 <lv_point_transform>
    res->x1 = LV_MIN4(p[0].x, p[1].x, p[2].x, p[3].x);
 800ca86:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800ca88:	6a3b      	ldr	r3, [r7, #32]
 800ca8a:	429a      	cmp	r2, r3
 800ca8c:	bfa8      	it	ge
 800ca8e:	461a      	movge	r2, r3
 800ca90:	69b9      	ldr	r1, [r7, #24]
 800ca92:	693b      	ldr	r3, [r7, #16]
 800ca94:	428b      	cmp	r3, r1
 800ca96:	bfa8      	it	ge
 800ca98:	460b      	movge	r3, r1
 800ca9a:	429a      	cmp	r2, r3
 800ca9c:	bfa8      	it	ge
 800ca9e:	461a      	movge	r2, r3
 800caa0:	68fb      	ldr	r3, [r7, #12]
 800caa2:	601a      	str	r2, [r3, #0]
    res->x2 = LV_MAX4(p[0].x, p[1].x, p[2].x, p[3].x) - 1;
 800caa4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800caa6:	6a3b      	ldr	r3, [r7, #32]
 800caa8:	429a      	cmp	r2, r3
 800caaa:	bfb8      	it	lt
 800caac:	461a      	movlt	r2, r3
 800caae:	69b9      	ldr	r1, [r7, #24]
 800cab0:	693b      	ldr	r3, [r7, #16]
 800cab2:	428b      	cmp	r3, r1
 800cab4:	bfb8      	it	lt
 800cab6:	460b      	movlt	r3, r1
 800cab8:	4293      	cmp	r3, r2
 800caba:	bfb8      	it	lt
 800cabc:	4613      	movlt	r3, r2
 800cabe:	1e5a      	subs	r2, r3, #1
 800cac0:	68fb      	ldr	r3, [r7, #12]
 800cac2:	609a      	str	r2, [r3, #8]
    res->y1 = LV_MIN4(p[0].y, p[1].y, p[2].y, p[3].y);
 800cac4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800cac6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cac8:	429a      	cmp	r2, r3
 800caca:	bfa8      	it	ge
 800cacc:	461a      	movge	r2, r3
 800cace:	69f9      	ldr	r1, [r7, #28]
 800cad0:	697b      	ldr	r3, [r7, #20]
 800cad2:	428b      	cmp	r3, r1
 800cad4:	bfa8      	it	ge
 800cad6:	460b      	movge	r3, r1
 800cad8:	429a      	cmp	r2, r3
 800cada:	bfa8      	it	ge
 800cadc:	461a      	movge	r2, r3
 800cade:	68fb      	ldr	r3, [r7, #12]
 800cae0:	605a      	str	r2, [r3, #4]
    res->y2 = LV_MAX4(p[0].y, p[1].y, p[2].y, p[3].y) - 1;
 800cae2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800cae4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cae6:	429a      	cmp	r2, r3
 800cae8:	bfb8      	it	lt
 800caea:	461a      	movlt	r2, r3
 800caec:	69f9      	ldr	r1, [r7, #28]
 800caee:	697b      	ldr	r3, [r7, #20]
 800caf0:	428b      	cmp	r3, r1
 800caf2:	bfb8      	it	lt
 800caf4:	460b      	movlt	r3, r1
 800caf6:	4293      	cmp	r3, r2
 800caf8:	bfb8      	it	lt
 800cafa:	4613      	movlt	r3, r2
 800cafc:	1e5a      	subs	r2, r3, #1
 800cafe:	68fb      	ldr	r3, [r7, #12]
 800cb00:	60da      	str	r2, [r3, #12]
}
 800cb02:	3730      	adds	r7, #48	@ 0x30
 800cb04:	46bd      	mov	sp, r7
 800cb06:	bd80      	pop	{r7, pc}

0800cb08 <img_decode_and_draw>:

static void img_decode_and_draw(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                                lv_image_decoder_dsc_t * decoder_dsc, lv_area_t * relative_decoded_area,
                                const lv_area_t * img_area, const lv_area_t * clipped_img_area,
                                lv_draw_image_core_cb draw_core_cb)
{
 800cb08:	b590      	push	{r4, r7, lr}
 800cb0a:	b09b      	sub	sp, #108	@ 0x6c
 800cb0c:	af02      	add	r7, sp, #8
 800cb0e:	60f8      	str	r0, [r7, #12]
 800cb10:	60b9      	str	r1, [r7, #8]
 800cb12:	607a      	str	r2, [r7, #4]
 800cb14:	603b      	str	r3, [r7, #0]
    lv_draw_image_sup_t sup;
    sup.alpha_color = draw_dsc->recolor;
 800cb16:	68ba      	ldr	r2, [r7, #8]
 800cb18:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 800cb1c:	3248      	adds	r2, #72	@ 0x48
 800cb1e:	6812      	ldr	r2, [r2, #0]
 800cb20:	4611      	mov	r1, r2
 800cb22:	8019      	strh	r1, [r3, #0]
 800cb24:	3302      	adds	r3, #2
 800cb26:	0c12      	lsrs	r2, r2, #16
 800cb28:	701a      	strb	r2, [r3, #0]
    sup.palette = decoder_dsc->palette;
 800cb2a:	687b      	ldr	r3, [r7, #4]
 800cb2c:	6a1b      	ldr	r3, [r3, #32]
 800cb2e:	657b      	str	r3, [r7, #84]	@ 0x54
    sup.palette_size = decoder_dsc->palette_size;
 800cb30:	687b      	ldr	r3, [r7, #4]
 800cb32:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800cb34:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800cb38:	b29a      	uxth	r2, r3
 800cb3a:	f8b7 3058 	ldrh.w	r3, [r7, #88]	@ 0x58
 800cb3e:	f362 0308 	bfi	r3, r2, #0, #9
 800cb42:	f8a7 3058 	strh.w	r3, [r7, #88]	@ 0x58

    /*The whole image is available, just draw it*/
    if(decoder_dsc->decoded && (relative_decoded_area == NULL || relative_decoded_area->x1 == LV_COORD_MIN)) {
 800cb46:	687b      	ldr	r3, [r7, #4]
 800cb48:	69db      	ldr	r3, [r3, #28]
 800cb4a:	2b00      	cmp	r3, #0
 800cb4c:	d014      	beq.n	800cb78 <img_decode_and_draw+0x70>
 800cb4e:	683b      	ldr	r3, [r7, #0]
 800cb50:	2b00      	cmp	r3, #0
 800cb52:	d004      	beq.n	800cb5e <img_decode_and_draw+0x56>
 800cb54:	683b      	ldr	r3, [r7, #0]
 800cb56:	681b      	ldr	r3, [r3, #0]
 800cb58:	4a3a      	ldr	r2, [pc, #232]	@ (800cc44 <img_decode_and_draw+0x13c>)
 800cb5a:	4293      	cmp	r3, r2
 800cb5c:	d10c      	bne.n	800cb78 <img_decode_and_draw+0x70>
        draw_core_cb(draw_unit, draw_dsc, decoder_dsc, &sup, img_area, clipped_img_area);
 800cb5e:	f107 0250 	add.w	r2, r7, #80	@ 0x50
 800cb62:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800cb64:	9301      	str	r3, [sp, #4]
 800cb66:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800cb68:	9300      	str	r3, [sp, #0]
 800cb6a:	6fbc      	ldr	r4, [r7, #120]	@ 0x78
 800cb6c:	4613      	mov	r3, r2
 800cb6e:	687a      	ldr	r2, [r7, #4]
 800cb70:	68b9      	ldr	r1, [r7, #8]
 800cb72:	68f8      	ldr	r0, [r7, #12]
 800cb74:	47a0      	blx	r4
 800cb76:	e061      	b.n	800cc3c <img_decode_and_draw+0x134>
    }
    /*Draw in smaller pieces*/
    else {
        lv_area_t relative_full_area_to_decode = *clipped_img_area;
 800cb78:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800cb7a:	f107 0440 	add.w	r4, r7, #64	@ 0x40
 800cb7e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800cb80:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        lv_area_move(&relative_full_area_to_decode, -img_area->x1, -img_area->y1);
 800cb84:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800cb86:	681b      	ldr	r3, [r3, #0]
 800cb88:	4259      	negs	r1, r3
 800cb8a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800cb8c:	685b      	ldr	r3, [r3, #4]
 800cb8e:	425a      	negs	r2, r3
 800cb90:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 800cb94:	4618      	mov	r0, r3
 800cb96:	f014 feb3 	bl	8021900 <lv_area_move>
        lv_area_t tmp;
        if(relative_decoded_area == NULL) relative_decoded_area = &tmp;
 800cb9a:	683b      	ldr	r3, [r7, #0]
 800cb9c:	2b00      	cmp	r3, #0
 800cb9e:	d102      	bne.n	800cba6 <img_decode_and_draw+0x9e>
 800cba0:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 800cba4:	603b      	str	r3, [r7, #0]
        relative_decoded_area->x1 = LV_COORD_MIN;
 800cba6:	683b      	ldr	r3, [r7, #0]
 800cba8:	4a26      	ldr	r2, [pc, #152]	@ (800cc44 <img_decode_and_draw+0x13c>)
 800cbaa:	601a      	str	r2, [r3, #0]
        relative_decoded_area->y1 = LV_COORD_MIN;
 800cbac:	683b      	ldr	r3, [r7, #0]
 800cbae:	4a25      	ldr	r2, [pc, #148]	@ (800cc44 <img_decode_and_draw+0x13c>)
 800cbb0:	605a      	str	r2, [r3, #4]
        relative_decoded_area->x2 = LV_COORD_MIN;
 800cbb2:	683b      	ldr	r3, [r7, #0]
 800cbb4:	4a23      	ldr	r2, [pc, #140]	@ (800cc44 <img_decode_and_draw+0x13c>)
 800cbb6:	609a      	str	r2, [r3, #8]
        relative_decoded_area->y2 = LV_COORD_MIN;
 800cbb8:	683b      	ldr	r3, [r7, #0]
 800cbba:	4a22      	ldr	r2, [pc, #136]	@ (800cc44 <img_decode_and_draw+0x13c>)
 800cbbc:	60da      	str	r2, [r3, #12]
        lv_result_t res = LV_RESULT_OK;
 800cbbe:	2301      	movs	r3, #1
 800cbc0:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f

        while(res == LV_RESULT_OK) {
 800cbc4:	e035      	b.n	800cc32 <img_decode_and_draw+0x12a>
            res = lv_image_decoder_get_area(decoder_dsc, &relative_full_area_to_decode, relative_decoded_area);
 800cbc6:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 800cbca:	683a      	ldr	r2, [r7, #0]
 800cbcc:	4619      	mov	r1, r3
 800cbce:	6878      	ldr	r0, [r7, #4]
 800cbd0:	f001 fce3 	bl	800e59a <lv_image_decoder_get_area>
 800cbd4:	4603      	mov	r3, r0
 800cbd6:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f

            lv_area_t absolute_decoded_area = *relative_decoded_area;
 800cbda:	683b      	ldr	r3, [r7, #0]
 800cbdc:	f107 0420 	add.w	r4, r7, #32
 800cbe0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800cbe2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
            lv_area_move(&absolute_decoded_area, img_area->x1, img_area->y1);
 800cbe6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800cbe8:	6819      	ldr	r1, [r3, #0]
 800cbea:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800cbec:	685a      	ldr	r2, [r3, #4]
 800cbee:	f107 0320 	add.w	r3, r7, #32
 800cbf2:	4618      	mov	r0, r3
 800cbf4:	f014 fe84 	bl	8021900 <lv_area_move>
            if(res == LV_RESULT_OK) {
 800cbf8:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800cbfc:	2b01      	cmp	r3, #1
 800cbfe:	d118      	bne.n	800cc32 <img_decode_and_draw+0x12a>
                /*Limit draw area to the current decoded area and draw the image*/
                lv_area_t clipped_img_area_sub;
                if(_lv_area_intersect(&clipped_img_area_sub, clipped_img_area, &absolute_decoded_area)) {
 800cc00:	f107 0220 	add.w	r2, r7, #32
 800cc04:	f107 0310 	add.w	r3, r7, #16
 800cc08:	6f79      	ldr	r1, [r7, #116]	@ 0x74
 800cc0a:	4618      	mov	r0, r3
 800cc0c:	f014 fe9c 	bl	8021948 <_lv_area_intersect>
 800cc10:	4603      	mov	r3, r0
 800cc12:	2b00      	cmp	r3, #0
 800cc14:	d00d      	beq.n	800cc32 <img_decode_and_draw+0x12a>
                    draw_core_cb(draw_unit, draw_dsc, decoder_dsc, &sup,
 800cc16:	f107 0250 	add.w	r2, r7, #80	@ 0x50
 800cc1a:	f107 0310 	add.w	r3, r7, #16
 800cc1e:	9301      	str	r3, [sp, #4]
 800cc20:	f107 0320 	add.w	r3, r7, #32
 800cc24:	9300      	str	r3, [sp, #0]
 800cc26:	6fbc      	ldr	r4, [r7, #120]	@ 0x78
 800cc28:	4613      	mov	r3, r2
 800cc2a:	687a      	ldr	r2, [r7, #4]
 800cc2c:	68b9      	ldr	r1, [r7, #8]
 800cc2e:	68f8      	ldr	r0, [r7, #12]
 800cc30:	47a0      	blx	r4
        while(res == LV_RESULT_OK) {
 800cc32:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 800cc36:	2b01      	cmp	r3, #1
 800cc38:	d0c5      	beq.n	800cbc6 <img_decode_and_draw+0xbe>
                                 &absolute_decoded_area, &clipped_img_area_sub);
                }
            }
        }
    }
}
 800cc3a:	bf00      	nop
 800cc3c:	bf00      	nop
 800cc3e:	3764      	adds	r7, #100	@ 0x64
 800cc40:	46bd      	mov	sp, r7
 800cc42:	bd90      	pop	{r4, r7, pc}
 800cc44:	e0000001 	.word	0xe0000001

0800cc48 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline int32_t lv_area_get_width(const lv_area_t * area_p)
{
 800cc48:	b480      	push	{r7}
 800cc4a:	b083      	sub	sp, #12
 800cc4c:	af00      	add	r7, sp, #0
 800cc4e:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 800cc50:	687b      	ldr	r3, [r7, #4]
 800cc52:	689a      	ldr	r2, [r3, #8]
 800cc54:	687b      	ldr	r3, [r7, #4]
 800cc56:	681b      	ldr	r3, [r3, #0]
 800cc58:	1ad3      	subs	r3, r2, r3
 800cc5a:	3301      	adds	r3, #1
}
 800cc5c:	4618      	mov	r0, r3
 800cc5e:	370c      	adds	r7, #12
 800cc60:	46bd      	mov	sp, r7
 800cc62:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc66:	4770      	bx	lr

0800cc68 <lv_point_set>:

    return point;
}

static inline void lv_point_set(lv_point_t * p, int32_t x, int32_t y)
{
 800cc68:	b480      	push	{r7}
 800cc6a:	b085      	sub	sp, #20
 800cc6c:	af00      	add	r7, sp, #0
 800cc6e:	60f8      	str	r0, [r7, #12]
 800cc70:	60b9      	str	r1, [r7, #8]
 800cc72:	607a      	str	r2, [r7, #4]
    p->x = x;
 800cc74:	68fb      	ldr	r3, [r7, #12]
 800cc76:	68ba      	ldr	r2, [r7, #8]
 800cc78:	601a      	str	r2, [r3, #0]
    p->y = y;
 800cc7a:	68fb      	ldr	r3, [r7, #12]
 800cc7c:	687a      	ldr	r2, [r7, #4]
 800cc7e:	605a      	str	r2, [r3, #4]
}
 800cc80:	bf00      	nop
 800cc82:	3714      	adds	r7, #20
 800cc84:	46bd      	mov	sp, r7
 800cc86:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc8a:	4770      	bx	lr

0800cc8c <lv_color_make>:
 * @param g     the green channel (0..255)
 * @param b     the blue channel (0..255)
 * @return      the color
 */
static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
{
 800cc8c:	b480      	push	{r7}
 800cc8e:	b085      	sub	sp, #20
 800cc90:	af00      	add	r7, sp, #0
 800cc92:	4603      	mov	r3, r0
 800cc94:	71fb      	strb	r3, [r7, #7]
 800cc96:	460b      	mov	r3, r1
 800cc98:	71bb      	strb	r3, [r7, #6]
 800cc9a:	4613      	mov	r3, r2
 800cc9c:	717b      	strb	r3, [r7, #5]
    lv_color_t ret;
    ret.red = r;
 800cc9e:	79fb      	ldrb	r3, [r7, #7]
 800cca0:	72bb      	strb	r3, [r7, #10]
    ret.green = g;
 800cca2:	79bb      	ldrb	r3, [r7, #6]
 800cca4:	727b      	strb	r3, [r7, #9]
    ret.blue = b;
 800cca6:	797b      	ldrb	r3, [r7, #5]
 800cca8:	723b      	strb	r3, [r7, #8]
    return ret;
 800ccaa:	f107 030c 	add.w	r3, r7, #12
 800ccae:	f107 0208 	add.w	r2, r7, #8
 800ccb2:	6812      	ldr	r2, [r2, #0]
 800ccb4:	4611      	mov	r1, r2
 800ccb6:	8019      	strh	r1, [r3, #0]
 800ccb8:	3302      	adds	r3, #2
 800ccba:	0c12      	lsrs	r2, r2, #16
 800ccbc:	701a      	strb	r2, [r3, #0]
 800ccbe:	2300      	movs	r3, #0
 800ccc0:	7b3a      	ldrb	r2, [r7, #12]
 800ccc2:	f362 0307 	bfi	r3, r2, #0, #8
 800ccc6:	7b7a      	ldrb	r2, [r7, #13]
 800ccc8:	f362 230f 	bfi	r3, r2, #8, #8
 800cccc:	7bba      	ldrb	r2, [r7, #14]
 800ccce:	f362 4317 	bfi	r3, r2, #16, #8
}
 800ccd2:	4618      	mov	r0, r3
 800ccd4:	3714      	adds	r7, #20
 800ccd6:	46bd      	mov	sp, r7
 800ccd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ccdc:	4770      	bx	lr

0800ccde <lv_color_black>:
/**
 * A helper for black color
 * @return      a black color
 */
static inline lv_color_t lv_color_black(void)
{
 800ccde:	b580      	push	{r7, lr}
 800cce0:	b082      	sub	sp, #8
 800cce2:	af00      	add	r7, sp, #0
    return lv_color_make(0x00, 0x00, 0x00);
 800cce4:	2200      	movs	r2, #0
 800cce6:	2100      	movs	r1, #0
 800cce8:	2000      	movs	r0, #0
 800ccea:	f7ff ffcf 	bl	800cc8c <lv_color_make>
 800ccee:	4603      	mov	r3, r0
 800ccf0:	461a      	mov	r2, r3
 800ccf2:	713a      	strb	r2, [r7, #4]
 800ccf4:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800ccf8:	717a      	strb	r2, [r7, #5]
 800ccfa:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800ccfe:	71bb      	strb	r3, [r7, #6]
 800cd00:	2300      	movs	r3, #0
 800cd02:	793a      	ldrb	r2, [r7, #4]
 800cd04:	f362 0307 	bfi	r3, r2, #0, #8
 800cd08:	797a      	ldrb	r2, [r7, #5]
 800cd0a:	f362 230f 	bfi	r3, r2, #8, #8
 800cd0e:	79ba      	ldrb	r2, [r7, #6]
 800cd10:	f362 4317 	bfi	r3, r2, #16, #8
}
 800cd14:	4618      	mov	r0, r3
 800cd16:	3708      	adds	r7, #8
 800cd18:	46bd      	mov	sp, r7
 800cd1a:	bd80      	pop	{r7, pc}

0800cd1c <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 800cd1c:	b580      	push	{r7, lr}
 800cd1e:	b082      	sub	sp, #8
 800cd20:	af00      	add	r7, sp, #0
 800cd22:	6078      	str	r0, [r7, #4]
 800cd24:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 800cd26:	683a      	ldr	r2, [r7, #0]
 800cd28:	2100      	movs	r1, #0
 800cd2a:	6878      	ldr	r0, [r7, #4]
 800cd2c:	f018 f879 	bl	8024e22 <lv_memset>
}
 800cd30:	bf00      	nop
 800cd32:	3708      	adds	r7, #8
 800cd34:	46bd      	mov	sp, r7
 800cd36:	bd80      	pop	{r7, pc}

0800cd38 <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font      pointer to a font
 * @return the height of a font
 */
static inline int32_t lv_font_get_line_height(const lv_font_t * font)
{
 800cd38:	b480      	push	{r7}
 800cd3a:	b083      	sub	sp, #12
 800cd3c:	af00      	add	r7, sp, #0
 800cd3e:	6078      	str	r0, [r7, #4]
    return font->line_height;
 800cd40:	687b      	ldr	r3, [r7, #4]
 800cd42:	68db      	ldr	r3, [r3, #12]
}
 800cd44:	4618      	mov	r0, r3
 800cd46:	370c      	adds	r7, #12
 800cd48:	46bd      	mov	sp, r7
 800cd4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cd4e:	4770      	bx	lr

0800cd50 <_lv_text_is_marker>:
 *
 * @param letter a letter
 * @return true if so
 */
static inline bool _lv_text_is_marker(uint32_t letter)
{
 800cd50:	b480      	push	{r7}
 800cd52:	b083      	sub	sp, #12
 800cd54:	af00      	add	r7, sp, #0
 800cd56:	6078      	str	r0, [r7, #4]
    if(letter < 0x20) return true;
 800cd58:	687b      	ldr	r3, [r7, #4]
 800cd5a:	2b1f      	cmp	r3, #31
 800cd5c:	d801      	bhi.n	800cd62 <_lv_text_is_marker+0x12>
 800cd5e:	2301      	movs	r3, #1
 800cd60:	e052      	b.n	800ce08 <_lv_text_is_marker+0xb8>

    /*U+061C ARABIC LETTER MARK, see https://www.compart.com/en/unicode/block/U+0600*/
    if(letter == 0x061C) return true;
 800cd62:	687b      	ldr	r3, [r7, #4]
 800cd64:	f240 621c 	movw	r2, #1564	@ 0x61c
 800cd68:	4293      	cmp	r3, r2
 800cd6a:	d101      	bne.n	800cd70 <_lv_text_is_marker+0x20>
 800cd6c:	2301      	movs	r3, #1
 800cd6e:	e04b      	b.n	800ce08 <_lv_text_is_marker+0xb8>

    /*U+115F HANGUL CHOSEONG FILLER, See https://www.compart.com/en/unicode/block/U+1100*/
    if(letter == 0x115F) return true;
 800cd70:	687b      	ldr	r3, [r7, #4]
 800cd72:	f241 125f 	movw	r2, #4447	@ 0x115f
 800cd76:	4293      	cmp	r3, r2
 800cd78:	d101      	bne.n	800cd7e <_lv_text_is_marker+0x2e>
 800cd7a:	2301      	movs	r3, #1
 800cd7c:	e044      	b.n	800ce08 <_lv_text_is_marker+0xb8>
    /*U+1160 HANGUL JUNGSEONG FILLER*/
    if(letter == 0x1160) return true;
 800cd7e:	687b      	ldr	r3, [r7, #4]
 800cd80:	f5b3 5f8b 	cmp.w	r3, #4448	@ 0x1160
 800cd84:	d101      	bne.n	800cd8a <_lv_text_is_marker+0x3a>
 800cd86:	2301      	movs	r3, #1
 800cd88:	e03e      	b.n	800ce08 <_lv_text_is_marker+0xb8>

    /*See https://www.compart.com/en/unicode/block/U+1800*/
    if(letter >= 0x180B && letter <= 0x180E) return true;
 800cd8a:	687b      	ldr	r3, [r7, #4]
 800cd8c:	f641 020a 	movw	r2, #6154	@ 0x180a
 800cd90:	4293      	cmp	r3, r2
 800cd92:	d906      	bls.n	800cda2 <_lv_text_is_marker+0x52>
 800cd94:	687b      	ldr	r3, [r7, #4]
 800cd96:	f641 020e 	movw	r2, #6158	@ 0x180e
 800cd9a:	4293      	cmp	r3, r2
 800cd9c:	d801      	bhi.n	800cda2 <_lv_text_is_marker+0x52>
 800cd9e:	2301      	movs	r3, #1
 800cda0:	e032      	b.n	800ce08 <_lv_text_is_marker+0xb8>

    /*See https://www.compart.com/en/unicode/block/U+2000*/
    if(letter >= 0x200B && letter <= 0x200F) return true;
 800cda2:	687b      	ldr	r3, [r7, #4]
 800cda4:	f242 020a 	movw	r2, #8202	@ 0x200a
 800cda8:	4293      	cmp	r3, r2
 800cdaa:	d906      	bls.n	800cdba <_lv_text_is_marker+0x6a>
 800cdac:	687b      	ldr	r3, [r7, #4]
 800cdae:	f242 020f 	movw	r2, #8207	@ 0x200f
 800cdb2:	4293      	cmp	r3, r2
 800cdb4:	d801      	bhi.n	800cdba <_lv_text_is_marker+0x6a>
 800cdb6:	2301      	movs	r3, #1
 800cdb8:	e026      	b.n	800ce08 <_lv_text_is_marker+0xb8>
    if(letter >= 0x2028 && letter <= 0x202F) return true;
 800cdba:	687b      	ldr	r3, [r7, #4]
 800cdbc:	f242 0227 	movw	r2, #8231	@ 0x2027
 800cdc0:	4293      	cmp	r3, r2
 800cdc2:	d906      	bls.n	800cdd2 <_lv_text_is_marker+0x82>
 800cdc4:	687b      	ldr	r3, [r7, #4]
 800cdc6:	f242 022f 	movw	r2, #8239	@ 0x202f
 800cdca:	4293      	cmp	r3, r2
 800cdcc:	d801      	bhi.n	800cdd2 <_lv_text_is_marker+0x82>
 800cdce:	2301      	movs	r3, #1
 800cdd0:	e01a      	b.n	800ce08 <_lv_text_is_marker+0xb8>
    if(letter >= 0x205F && letter <= 0x206F) return true;
 800cdd2:	687b      	ldr	r3, [r7, #4]
 800cdd4:	f242 025e 	movw	r2, #8286	@ 0x205e
 800cdd8:	4293      	cmp	r3, r2
 800cdda:	d906      	bls.n	800cdea <_lv_text_is_marker+0x9a>
 800cddc:	687b      	ldr	r3, [r7, #4]
 800cdde:	f242 026f 	movw	r2, #8303	@ 0x206f
 800cde2:	4293      	cmp	r3, r2
 800cde4:	d801      	bhi.n	800cdea <_lv_text_is_marker+0x9a>
 800cde6:	2301      	movs	r3, #1
 800cde8:	e00e      	b.n	800ce08 <_lv_text_is_marker+0xb8>

    /*U+FEFF ZERO WIDTH NO-BREAK SPACE, see https://www.compart.com/en/unicode/block/U+FE70*/
    if(letter == 0xFEFF) return true;
 800cdea:	687b      	ldr	r3, [r7, #4]
 800cdec:	f64f 62ff 	movw	r2, #65279	@ 0xfeff
 800cdf0:	4293      	cmp	r3, r2
 800cdf2:	d101      	bne.n	800cdf8 <_lv_text_is_marker+0xa8>
 800cdf4:	2301      	movs	r3, #1
 800cdf6:	e007      	b.n	800ce08 <_lv_text_is_marker+0xb8>

    if(letter == 0xF8FF) return true; /*LV_SYMBOL_DUMMY*/
 800cdf8:	687b      	ldr	r3, [r7, #4]
 800cdfa:	f64f 02ff 	movw	r2, #63743	@ 0xf8ff
 800cdfe:	4293      	cmp	r3, r2
 800ce00:	d101      	bne.n	800ce06 <_lv_text_is_marker+0xb6>
 800ce02:	2301      	movs	r3, #1
 800ce04:	e000      	b.n	800ce08 <_lv_text_is_marker+0xb8>

    return false;
 800ce06:	2300      	movs	r3, #0
}
 800ce08:	4618      	mov	r0, r3
 800ce0a:	370c      	adds	r7, #12
 800ce0c:	46bd      	mov	sp, r7
 800ce0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce12:	4770      	bx	lr

0800ce14 <lv_bidi_calculate_align>:
 * @param align     For LV_TEXT_ALIGN_AUTO give LV_TEXT_ALIGN_LEFT else leave unchanged, write back the calculated align here
 * @param base_dir  Unused
 * @param txt       Unused
 */
static inline void lv_bidi_calculate_align(lv_text_align_t * align, lv_base_dir_t * base_dir, const char * txt)
{
 800ce14:	b480      	push	{r7}
 800ce16:	b085      	sub	sp, #20
 800ce18:	af00      	add	r7, sp, #0
 800ce1a:	60f8      	str	r0, [r7, #12]
 800ce1c:	60b9      	str	r1, [r7, #8]
 800ce1e:	607a      	str	r2, [r7, #4]
    LV_UNUSED(txt);
    LV_UNUSED(base_dir);
    if(*align == LV_TEXT_ALIGN_AUTO) * align = LV_TEXT_ALIGN_LEFT;
 800ce20:	68fb      	ldr	r3, [r7, #12]
 800ce22:	781b      	ldrb	r3, [r3, #0]
 800ce24:	2b00      	cmp	r3, #0
 800ce26:	d102      	bne.n	800ce2e <lv_bidi_calculate_align+0x1a>
 800ce28:	68fb      	ldr	r3, [r7, #12]
 800ce2a:	2201      	movs	r2, #1
 800ce2c:	701a      	strb	r2, [r3, #0]
}
 800ce2e:	bf00      	nop
 800ce30:	3714      	adds	r7, #20
 800ce32:	46bd      	mov	sp, r7
 800ce34:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce38:	4770      	bx	lr
	...

0800ce3c <lv_draw_label_dsc_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_label_dsc_init(lv_draw_label_dsc_t * dsc)
{
 800ce3c:	b590      	push	{r4, r7, lr}
 800ce3e:	b083      	sub	sp, #12
 800ce40:	af00      	add	r7, sp, #0
 800ce42:	6078      	str	r0, [r7, #4]
    lv_memzero(dsc, sizeof(lv_draw_label_dsc_t));
 800ce44:	2154      	movs	r1, #84	@ 0x54
 800ce46:	6878      	ldr	r0, [r7, #4]
 800ce48:	f7ff ff68 	bl	800cd1c <lv_memzero>
    dsc->opa = LV_OPA_COVER;
 800ce4c:	687b      	ldr	r3, [r7, #4]
 800ce4e:	22ff      	movs	r2, #255	@ 0xff
 800ce50:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
    dsc->color = lv_color_black();
 800ce54:	687c      	ldr	r4, [r7, #4]
 800ce56:	f7ff ff42 	bl	800ccde <lv_color_black>
 800ce5a:	4603      	mov	r3, r0
 800ce5c:	461a      	mov	r2, r3
 800ce5e:	f884 202c 	strb.w	r2, [r4, #44]	@ 0x2c
 800ce62:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800ce66:	f884 202d 	strb.w	r2, [r4, #45]	@ 0x2d
 800ce6a:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800ce6e:	f884 302e 	strb.w	r3, [r4, #46]	@ 0x2e
    dsc->font = LV_FONT_DEFAULT;
 800ce72:	687b      	ldr	r3, [r7, #4]
 800ce74:	4a19      	ldr	r2, [pc, #100]	@ (800cedc <lv_draw_label_dsc_init+0xa0>)
 800ce76:	621a      	str	r2, [r3, #32]
    dsc->sel_start = LV_DRAW_LABEL_NO_TXT_SEL;
 800ce78:	687b      	ldr	r3, [r7, #4]
 800ce7a:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800ce7e:	625a      	str	r2, [r3, #36]	@ 0x24
    dsc->sel_end = LV_DRAW_LABEL_NO_TXT_SEL;
 800ce80:	687b      	ldr	r3, [r7, #4]
 800ce82:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800ce86:	629a      	str	r2, [r3, #40]	@ 0x28
    dsc->sel_color = lv_color_black();
 800ce88:	687c      	ldr	r4, [r7, #4]
 800ce8a:	f7ff ff28 	bl	800ccde <lv_color_black>
 800ce8e:	4603      	mov	r3, r0
 800ce90:	461a      	mov	r2, r3
 800ce92:	f884 202f 	strb.w	r2, [r4, #47]	@ 0x2f
 800ce96:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800ce9a:	f884 2030 	strb.w	r2, [r4, #48]	@ 0x30
 800ce9e:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800cea2:	f884 3031 	strb.w	r3, [r4, #49]	@ 0x31
    dsc->sel_bg_color = lv_palette_main(LV_PALETTE_BLUE);
 800cea6:	687c      	ldr	r4, [r7, #4]
 800cea8:	2005      	movs	r0, #5
 800ceaa:	f016 fc45 	bl	8023738 <lv_palette_main>
 800ceae:	4603      	mov	r3, r0
 800ceb0:	461a      	mov	r2, r3
 800ceb2:	f884 2032 	strb.w	r2, [r4, #50]	@ 0x32
 800ceb6:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800ceba:	f884 2033 	strb.w	r2, [r4, #51]	@ 0x33
 800cebe:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800cec2:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
    dsc->bidi_dir = LV_BASE_DIR_LTR;
 800cec6:	687b      	ldr	r3, [r7, #4]
 800cec8:	2200      	movs	r2, #0
 800ceca:	f883 2049 	strb.w	r2, [r3, #73]	@ 0x49
    dsc->base.dsc_size = sizeof(lv_draw_label_dsc_t);
 800cece:	687b      	ldr	r3, [r7, #4]
 800ced0:	2254      	movs	r2, #84	@ 0x54
 800ced2:	615a      	str	r2, [r3, #20]
}
 800ced4:	bf00      	nop
 800ced6:	370c      	adds	r7, #12
 800ced8:	46bd      	mov	sp, r7
 800ceda:	bd90      	pop	{r4, r7, pc}
 800cedc:	0802b154 	.word	0x0802b154

0800cee0 <lv_draw_task_get_label_dsc>:

lv_draw_label_dsc_t * lv_draw_task_get_label_dsc(lv_draw_task_t * task)
{
 800cee0:	b480      	push	{r7}
 800cee2:	b083      	sub	sp, #12
 800cee4:	af00      	add	r7, sp, #0
 800cee6:	6078      	str	r0, [r7, #4]
    return task->type == LV_DRAW_TASK_TYPE_LABEL ? (lv_draw_label_dsc_t *)task->draw_dsc : NULL;
 800cee8:	687b      	ldr	r3, [r7, #4]
 800ceea:	791b      	ldrb	r3, [r3, #4]
 800ceec:	2b03      	cmp	r3, #3
 800ceee:	d102      	bne.n	800cef6 <lv_draw_task_get_label_dsc+0x16>
 800cef0:	687b      	ldr	r3, [r7, #4]
 800cef2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800cef4:	e000      	b.n	800cef8 <lv_draw_task_get_label_dsc+0x18>
 800cef6:	2300      	movs	r3, #0
}
 800cef8:	4618      	mov	r0, r3
 800cefa:	370c      	adds	r7, #12
 800cefc:	46bd      	mov	sp, r7
 800cefe:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf02:	4770      	bx	lr

0800cf04 <lv_draw_glyph_dsc_init>:

void lv_draw_glyph_dsc_init(lv_draw_glyph_dsc_t * dsc)
{
 800cf04:	b580      	push	{r7, lr}
 800cf06:	b082      	sub	sp, #8
 800cf08:	af00      	add	r7, sp, #0
 800cf0a:	6078      	str	r0, [r7, #4]
    lv_memzero(dsc, sizeof(lv_draw_glyph_dsc_t));
 800cf0c:	211c      	movs	r1, #28
 800cf0e:	6878      	ldr	r0, [r7, #4]
 800cf10:	f7ff ff04 	bl	800cd1c <lv_memzero>
}
 800cf14:	bf00      	nop
 800cf16:	3708      	adds	r7, #8
 800cf18:	46bd      	mov	sp, r7
 800cf1a:	bd80      	pop	{r7, pc}

0800cf1c <lv_draw_label>:

void LV_ATTRIBUTE_FAST_MEM lv_draw_label(lv_layer_t * layer, const lv_draw_label_dsc_t * dsc,
                                         const lv_area_t * coords)
{
 800cf1c:	b580      	push	{r7, lr}
 800cf1e:	b086      	sub	sp, #24
 800cf20:	af00      	add	r7, sp, #0
 800cf22:	60f8      	str	r0, [r7, #12]
 800cf24:	60b9      	str	r1, [r7, #8]
 800cf26:	607a      	str	r2, [r7, #4]
    if(dsc->opa <= LV_OPA_MIN) return;
 800cf28:	68bb      	ldr	r3, [r7, #8]
 800cf2a:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800cf2e:	2b02      	cmp	r3, #2
 800cf30:	d939      	bls.n	800cfa6 <lv_draw_label+0x8a>
    if(dsc->text == NULL || dsc->text[0] == '\0') return;
 800cf32:	68bb      	ldr	r3, [r7, #8]
 800cf34:	69db      	ldr	r3, [r3, #28]
 800cf36:	2b00      	cmp	r3, #0
 800cf38:	d037      	beq.n	800cfaa <lv_draw_label+0x8e>
 800cf3a:	68bb      	ldr	r3, [r7, #8]
 800cf3c:	69db      	ldr	r3, [r3, #28]
 800cf3e:	781b      	ldrb	r3, [r3, #0]
 800cf40:	2b00      	cmp	r3, #0
 800cf42:	d032      	beq.n	800cfaa <lv_draw_label+0x8e>
    if(dsc->font == NULL) {
 800cf44:	68bb      	ldr	r3, [r7, #8]
 800cf46:	6a1b      	ldr	r3, [r3, #32]
 800cf48:	2b00      	cmp	r3, #0
 800cf4a:	d030      	beq.n	800cfae <lv_draw_label+0x92>
        LV_LOG_WARN("dsc->font == NULL");
        return;
    }

    LV_PROFILER_BEGIN;
    lv_draw_task_t * t = lv_draw_add_task(layer, coords);
 800cf4c:	6879      	ldr	r1, [r7, #4]
 800cf4e:	68f8      	ldr	r0, [r7, #12]
 800cf50:	f7fe fa86 	bl	800b460 <lv_draw_add_task>
 800cf54:	6178      	str	r0, [r7, #20]

    t->draw_dsc = lv_malloc(sizeof(*dsc));
 800cf56:	2054      	movs	r0, #84	@ 0x54
 800cf58:	f018 ff36 	bl	8025dc8 <lv_malloc>
 800cf5c:	4602      	mov	r2, r0
 800cf5e:	697b      	ldr	r3, [r7, #20]
 800cf60:	64da      	str	r2, [r3, #76]	@ 0x4c
    lv_memcpy(t->draw_dsc, dsc, sizeof(*dsc));
 800cf62:	697b      	ldr	r3, [r7, #20]
 800cf64:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800cf66:	2254      	movs	r2, #84	@ 0x54
 800cf68:	68b9      	ldr	r1, [r7, #8]
 800cf6a:	4618      	mov	r0, r3
 800cf6c:	f017 fd3c 	bl	80249e8 <lv_memcpy>
    t->type = LV_DRAW_TASK_TYPE_LABEL;
 800cf70:	697b      	ldr	r3, [r7, #20]
 800cf72:	2203      	movs	r2, #3
 800cf74:	711a      	strb	r2, [r3, #4]

    /*The text is stored in a local variable so malloc memory for it*/
    if(dsc->text_local) {
 800cf76:	68bb      	ldr	r3, [r7, #8]
 800cf78:	f893 304c 	ldrb.w	r3, [r3, #76]	@ 0x4c
 800cf7c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800cf80:	b2db      	uxtb	r3, r3
 800cf82:	2b00      	cmp	r3, #0
 800cf84:	d00a      	beq.n	800cf9c <lv_draw_label+0x80>
        lv_draw_label_dsc_t * new_dsc = t->draw_dsc;
 800cf86:	697b      	ldr	r3, [r7, #20]
 800cf88:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800cf8a:	613b      	str	r3, [r7, #16]
        new_dsc->text = lv_strdup(dsc->text);
 800cf8c:	68bb      	ldr	r3, [r7, #8]
 800cf8e:	69db      	ldr	r3, [r3, #28]
 800cf90:	4618      	mov	r0, r3
 800cf92:	f018 f865 	bl	8025060 <lv_strdup>
 800cf96:	4602      	mov	r2, r0
 800cf98:	693b      	ldr	r3, [r7, #16]
 800cf9a:	61da      	str	r2, [r3, #28]
    }

    lv_draw_finalize_task_creation(layer, t);
 800cf9c:	6979      	ldr	r1, [r7, #20]
 800cf9e:	68f8      	ldr	r0, [r7, #12]
 800cfa0:	f7fe fa9e 	bl	800b4e0 <lv_draw_finalize_task_creation>
 800cfa4:	e004      	b.n	800cfb0 <lv_draw_label+0x94>
    if(dsc->opa <= LV_OPA_MIN) return;
 800cfa6:	bf00      	nop
 800cfa8:	e002      	b.n	800cfb0 <lv_draw_label+0x94>
    if(dsc->text == NULL || dsc->text[0] == '\0') return;
 800cfaa:	bf00      	nop
 800cfac:	e000      	b.n	800cfb0 <lv_draw_label+0x94>
        return;
 800cfae:	bf00      	nop
    LV_PROFILER_END;
}
 800cfb0:	3718      	adds	r7, #24
 800cfb2:	46bd      	mov	sp, r7
 800cfb4:	bd80      	pop	{r7, pc}
	...

0800cfb8 <lv_draw_label_iterate_characters>:
}

void lv_draw_label_iterate_characters(lv_draw_unit_t * draw_unit, const lv_draw_label_dsc_t * dsc,
                                      const lv_area_t * coords,
                                      lv_draw_glyph_cb_t cb)
{
 800cfb8:	b5b0      	push	{r4, r5, r7, lr}
 800cfba:	b0c6      	sub	sp, #280	@ 0x118
 800cfbc:	af04      	add	r7, sp, #16
 800cfbe:	60f8      	str	r0, [r7, #12]
 800cfc0:	f507 7084 	add.w	r0, r7, #264	@ 0x108
 800cfc4:	f5a0 7080 	sub.w	r0, r0, #256	@ 0x100
 800cfc8:	6001      	str	r1, [r0, #0]
 800cfca:	f507 7184 	add.w	r1, r7, #264	@ 0x108
 800cfce:	f5a1 7182 	sub.w	r1, r1, #260	@ 0x104
 800cfd2:	600a      	str	r2, [r1, #0]
 800cfd4:	f507 7284 	add.w	r2, r7, #264	@ 0x108
 800cfd8:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
 800cfdc:	6013      	str	r3, [r2, #0]
    const lv_font_t * font = dsc->font;
 800cfde:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800cfe2:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800cfe6:	681b      	ldr	r3, [r3, #0]
 800cfe8:	6a1b      	ldr	r3, [r3, #32]
 800cfea:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    int32_t w;

    lv_area_t clipped_area;
    bool clip_ok = _lv_area_intersect(&clipped_area, coords, draw_unit->clip_area);
 800cfee:	68fb      	ldr	r3, [r7, #12]
 800cff0:	689a      	ldr	r2, [r3, #8]
 800cff2:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800cff6:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800cffa:	f107 00ac 	add.w	r0, r7, #172	@ 0xac
 800cffe:	6819      	ldr	r1, [r3, #0]
 800d000:	f014 fca2 	bl	8021948 <_lv_area_intersect>
 800d004:	4603      	mov	r3, r0
 800d006:	f887 30e7 	strb.w	r3, [r7, #231]	@ 0xe7
    if(!clip_ok) return;
 800d00a:	f897 30e7 	ldrb.w	r3, [r7, #231]	@ 0xe7
 800d00e:	f083 0301 	eor.w	r3, r3, #1
 800d012:	b2db      	uxtb	r3, r3
 800d014:	2b00      	cmp	r3, #0
 800d016:	f040 84ab 	bne.w	800d970 <lv_draw_label_iterate_characters+0x9b8>

    lv_text_align_t align = dsc->align;
 800d01a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d01e:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d022:	681b      	ldr	r3, [r3, #0]
 800d024:	f893 304a 	ldrb.w	r3, [r3, #74]	@ 0x4a
 800d028:	f887 30ab 	strb.w	r3, [r7, #171]	@ 0xab
    lv_base_dir_t base_dir = dsc->bidi_dir;
 800d02c:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d030:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d034:	681b      	ldr	r3, [r3, #0]
 800d036:	f893 3049 	ldrb.w	r3, [r3, #73]	@ 0x49
 800d03a:	f887 30aa 	strb.w	r3, [r7, #170]	@ 0xaa

    lv_bidi_calculate_align(&align, &base_dir, dsc->text);
 800d03e:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d042:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d046:	681b      	ldr	r3, [r3, #0]
 800d048:	69da      	ldr	r2, [r3, #28]
 800d04a:	f107 01aa 	add.w	r1, r7, #170	@ 0xaa
 800d04e:	f107 03ab 	add.w	r3, r7, #171	@ 0xab
 800d052:	4618      	mov	r0, r3
 800d054:	f7ff fede 	bl	800ce14 <lv_bidi_calculate_align>

    if((dsc->flag & LV_TEXT_FLAG_EXPAND) == 0) {
 800d058:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d05c:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d060:	681b      	ldr	r3, [r3, #0]
 800d062:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 800d066:	f003 0301 	and.w	r3, r3, #1
 800d06a:	2b00      	cmp	r3, #0
 800d06c:	d109      	bne.n	800d082 <lv_draw_label_iterate_characters+0xca>
        /*Normally use the label's width as width*/
        w = lv_area_get_width(coords);
 800d06e:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d072:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800d076:	6818      	ldr	r0, [r3, #0]
 800d078:	f7ff fde6 	bl	800cc48 <lv_area_get_width>
 800d07c:	f8c7 0104 	str.w	r0, [r7, #260]	@ 0x104
 800d080:	e02c      	b.n	800d0dc <lv_draw_label_iterate_characters+0x124>
    }
    else {
        /*If EXPAND is enabled then not limit the text's width to the object's width*/
        lv_point_t p;
        lv_text_get_size(&p, dsc->text, dsc->font, dsc->letter_space, dsc->line_space, LV_COORD_MAX,
 800d082:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d086:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d08a:	681b      	ldr	r3, [r3, #0]
 800d08c:	69d9      	ldr	r1, [r3, #28]
 800d08e:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d092:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d096:	681b      	ldr	r3, [r3, #0]
 800d098:	6a1c      	ldr	r4, [r3, #32]
 800d09a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d09e:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d0a2:	681b      	ldr	r3, [r3, #0]
 800d0a4:	6bdd      	ldr	r5, [r3, #60]	@ 0x3c
 800d0a6:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d0aa:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d0ae:	681b      	ldr	r3, [r3, #0]
 800d0b0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
                         dsc->flag);
 800d0b2:	f507 7284 	add.w	r2, r7, #264	@ 0x108
 800d0b6:	f5a2 7280 	sub.w	r2, r2, #256	@ 0x100
 800d0ba:	6812      	ldr	r2, [r2, #0]
 800d0bc:	f892 204b 	ldrb.w	r2, [r2, #75]	@ 0x4b
        lv_text_get_size(&p, dsc->text, dsc->font, dsc->letter_space, dsc->line_space, LV_COORD_MAX,
 800d0c0:	f107 0038 	add.w	r0, r7, #56	@ 0x38
 800d0c4:	9202      	str	r2, [sp, #8]
 800d0c6:	f06f 4260 	mvn.w	r2, #3758096384	@ 0xe0000000
 800d0ca:	9201      	str	r2, [sp, #4]
 800d0cc:	9300      	str	r3, [sp, #0]
 800d0ce:	462b      	mov	r3, r5
 800d0d0:	4622      	mov	r2, r4
 800d0d2:	f016 fe25 	bl	8023d20 <lv_text_get_size>
        w = p.x;
 800d0d6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800d0d8:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
    }

    int32_t line_height_font = lv_font_get_line_height(font);
 800d0dc:	f8d7 00e8 	ldr.w	r0, [r7, #232]	@ 0xe8
 800d0e0:	f7ff fe2a 	bl	800cd38 <lv_font_get_line_height>
 800d0e4:	f8c7 00e0 	str.w	r0, [r7, #224]	@ 0xe0
    int32_t line_height = line_height_font + dsc->line_space;
 800d0e8:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d0ec:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d0f0:	681b      	ldr	r3, [r3, #0]
 800d0f2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800d0f4:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 800d0f8:	4413      	add	r3, r2
 800d0fa:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc

    /*Init variables for the first line*/
    int32_t line_width = 0;
 800d0fe:	2300      	movs	r3, #0
 800d100:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    lv_point_t pos;
    lv_point_set(&pos, coords->x1, coords->y1);
 800d104:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d108:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800d10c:	681b      	ldr	r3, [r3, #0]
 800d10e:	6819      	ldr	r1, [r3, #0]
 800d110:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d114:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800d118:	681b      	ldr	r3, [r3, #0]
 800d11a:	685a      	ldr	r2, [r3, #4]
 800d11c:	f107 03a0 	add.w	r3, r7, #160	@ 0xa0
 800d120:	4618      	mov	r0, r3
 800d122:	f7ff fda1 	bl	800cc68 <lv_point_set>

    int32_t x_ofs = 0;
 800d126:	2300      	movs	r3, #0
 800d128:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    int32_t y_ofs = 0;
 800d12c:	2300      	movs	r3, #0
 800d12e:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    x_ofs = dsc->ofs_x;
 800d132:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d136:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d13a:	681b      	ldr	r3, [r3, #0]
 800d13c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800d13e:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    y_ofs = dsc->ofs_y;
 800d142:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d146:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d14a:	681b      	ldr	r3, [r3, #0]
 800d14c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d14e:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
    pos.y += y_ofs;
 800d152:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 800d156:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 800d15a:	4413      	add	r3, r2
 800d15c:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4

    uint32_t line_start     = 0;
 800d160:	2300      	movs	r3, #0
 800d162:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    int32_t last_line_start = -1;
 800d166:	f04f 33ff 	mov.w	r3, #4294967295
 800d16a:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc

    /*Check the hint to use the cached info*/
    if(dsc->hint && y_ofs == 0 && coords->y1 < 0) {
 800d16e:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d172:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d176:	681b      	ldr	r3, [r3, #0]
 800d178:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d17a:	2b00      	cmp	r3, #0
 800d17c:	d036      	beq.n	800d1ec <lv_draw_label_iterate_characters+0x234>
 800d17e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 800d182:	2b00      	cmp	r3, #0
 800d184:	d132      	bne.n	800d1ec <lv_draw_label_iterate_characters+0x234>
 800d186:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d18a:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800d18e:	681b      	ldr	r3, [r3, #0]
 800d190:	685b      	ldr	r3, [r3, #4]
 800d192:	2b00      	cmp	r3, #0
 800d194:	da2a      	bge.n	800d1ec <lv_draw_label_iterate_characters+0x234>
        /*If the label changed too much recalculate the hint.*/
        if(LV_ABS(dsc->hint->coord_y - coords->y1) > LV_LABEL_HINT_UPDATE_TH - 2 * line_height) {
 800d196:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d19a:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d19e:	681b      	ldr	r3, [r3, #0]
 800d1a0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d1a2:	689a      	ldr	r2, [r3, #8]
 800d1a4:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d1a8:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800d1ac:	681b      	ldr	r3, [r3, #0]
 800d1ae:	685b      	ldr	r3, [r3, #4]
 800d1b0:	1ad3      	subs	r3, r2, r3
 800d1b2:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 800d1b6:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 800d1ba:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800d1be:	f5c3 7300 	rsb	r3, r3, #512	@ 0x200
 800d1c2:	005b      	lsls	r3, r3, #1
 800d1c4:	429a      	cmp	r2, r3
 800d1c6:	dd08      	ble.n	800d1da <lv_draw_label_iterate_characters+0x222>
            dsc->hint->line_start = -1;
 800d1c8:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d1cc:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d1d0:	681b      	ldr	r3, [r3, #0]
 800d1d2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d1d4:	f04f 32ff 	mov.w	r2, #4294967295
 800d1d8:	601a      	str	r2, [r3, #0]
        }
        last_line_start = dsc->hint->line_start;
 800d1da:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d1de:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d1e2:	681b      	ldr	r3, [r3, #0]
 800d1e4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d1e6:	681b      	ldr	r3, [r3, #0]
 800d1e8:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    }

    /*Use the hint if it's valid*/
    if(dsc->hint && last_line_start >= 0) {
 800d1ec:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d1f0:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d1f4:	681b      	ldr	r3, [r3, #0]
 800d1f6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d1f8:	2b00      	cmp	r3, #0
 800d1fa:	d013      	beq.n	800d224 <lv_draw_label_iterate_characters+0x26c>
 800d1fc:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800d200:	2b00      	cmp	r3, #0
 800d202:	db0f      	blt.n	800d224 <lv_draw_label_iterate_characters+0x26c>
        line_start = last_line_start;
 800d204:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 800d208:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
        pos.y += dsc->hint->y;
 800d20c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 800d210:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d214:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d218:	681b      	ldr	r3, [r3, #0]
 800d21a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d21c:	685b      	ldr	r3, [r3, #4]
 800d21e:	4413      	add	r3, r2
 800d220:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    }

    uint32_t line_end = line_start + _lv_text_get_next_line(&dsc->text[line_start], font, dsc->letter_space, w, NULL,
 800d224:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d228:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d22c:	681b      	ldr	r3, [r3, #0]
 800d22e:	69da      	ldr	r2, [r3, #28]
 800d230:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d234:	18d0      	adds	r0, r2, r3
 800d236:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d23a:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d23e:	681b      	ldr	r3, [r3, #0]
 800d240:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
                                                            dsc->flag);
 800d242:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d246:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d24a:	681b      	ldr	r3, [r3, #0]
 800d24c:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
    uint32_t line_end = line_start + _lv_text_get_next_line(&dsc->text[line_start], font, dsc->letter_space, w, NULL,
 800d250:	9301      	str	r3, [sp, #4]
 800d252:	2300      	movs	r3, #0
 800d254:	9300      	str	r3, [sp, #0]
 800d256:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 800d25a:	f8d7 10e8 	ldr.w	r1, [r7, #232]	@ 0xe8
 800d25e:	f016 fec9 	bl	8023ff4 <_lv_text_get_next_line>
 800d262:	4602      	mov	r2, r0
 800d264:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d268:	4413      	add	r3, r2
 800d26a:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8

    /*Go the first visible line*/
    while(pos.y + line_height_font < draw_unit->clip_area->y1) {
 800d26e:	e078      	b.n	800d362 <lv_draw_label_iterate_characters+0x3aa>
        /*Go to next line*/
        line_start = line_end;
 800d270:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 800d274:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
        line_end += _lv_text_get_next_line(&dsc->text[line_start], font, dsc->letter_space, w, NULL, dsc->flag);
 800d278:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d27c:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d280:	681b      	ldr	r3, [r3, #0]
 800d282:	69da      	ldr	r2, [r3, #28]
 800d284:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d288:	18d0      	adds	r0, r2, r3
 800d28a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d28e:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d292:	681b      	ldr	r3, [r3, #0]
 800d294:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800d296:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d29a:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d29e:	681b      	ldr	r3, [r3, #0]
 800d2a0:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 800d2a4:	9301      	str	r3, [sp, #4]
 800d2a6:	2300      	movs	r3, #0
 800d2a8:	9300      	str	r3, [sp, #0]
 800d2aa:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 800d2ae:	f8d7 10e8 	ldr.w	r1, [r7, #232]	@ 0xe8
 800d2b2:	f016 fe9f 	bl	8023ff4 <_lv_text_get_next_line>
 800d2b6:	4602      	mov	r2, r0
 800d2b8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 800d2bc:	4413      	add	r3, r2
 800d2be:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
        pos.y += line_height;
 800d2c2:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 800d2c6:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800d2ca:	4413      	add	r3, r2
 800d2cc:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4

        /*Save at the threshold coordinate*/
        if(dsc->hint && pos.y >= -LV_LABEL_HINT_UPDATE_TH && dsc->hint->line_start < 0) {
 800d2d0:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d2d4:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d2d8:	681b      	ldr	r3, [r3, #0]
 800d2da:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d2dc:	2b00      	cmp	r3, #0
 800d2de:	d033      	beq.n	800d348 <lv_draw_label_iterate_characters+0x390>
 800d2e0:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 800d2e4:	f513 6f80 	cmn.w	r3, #1024	@ 0x400
 800d2e8:	db2e      	blt.n	800d348 <lv_draw_label_iterate_characters+0x390>
 800d2ea:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d2ee:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d2f2:	681b      	ldr	r3, [r3, #0]
 800d2f4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d2f6:	681b      	ldr	r3, [r3, #0]
 800d2f8:	2b00      	cmp	r3, #0
 800d2fa:	da25      	bge.n	800d348 <lv_draw_label_iterate_characters+0x390>
            dsc->hint->line_start = line_start;
 800d2fc:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d300:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d304:	681b      	ldr	r3, [r3, #0]
 800d306:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d308:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 800d30c:	601a      	str	r2, [r3, #0]
            dsc->hint->y          = pos.y - coords->y1;
 800d30e:	f8d7 10a4 	ldr.w	r1, [r7, #164]	@ 0xa4
 800d312:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d316:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800d31a:	681b      	ldr	r3, [r3, #0]
 800d31c:	685a      	ldr	r2, [r3, #4]
 800d31e:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d322:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d326:	681b      	ldr	r3, [r3, #0]
 800d328:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d32a:	1a8a      	subs	r2, r1, r2
 800d32c:	605a      	str	r2, [r3, #4]
            dsc->hint->coord_y    = coords->y1;
 800d32e:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d332:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d336:	681b      	ldr	r3, [r3, #0]
 800d338:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800d33a:	f507 7284 	add.w	r2, r7, #264	@ 0x108
 800d33e:	f5a2 7282 	sub.w	r2, r2, #260	@ 0x104
 800d342:	6812      	ldr	r2, [r2, #0]
 800d344:	6852      	ldr	r2, [r2, #4]
 800d346:	609a      	str	r2, [r3, #8]
        }

        if(dsc->text[line_start] == '\0') return;
 800d348:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d34c:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d350:	681b      	ldr	r3, [r3, #0]
 800d352:	69da      	ldr	r2, [r3, #28]
 800d354:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d358:	4413      	add	r3, r2
 800d35a:	781b      	ldrb	r3, [r3, #0]
 800d35c:	2b00      	cmp	r3, #0
 800d35e:	f000 8309 	beq.w	800d974 <lv_draw_label_iterate_characters+0x9bc>
    while(pos.y + line_height_font < draw_unit->clip_area->y1) {
 800d362:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 800d366:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 800d36a:	441a      	add	r2, r3
 800d36c:	68fb      	ldr	r3, [r7, #12]
 800d36e:	689b      	ldr	r3, [r3, #8]
 800d370:	685b      	ldr	r3, [r3, #4]
 800d372:	429a      	cmp	r2, r3
 800d374:	f6ff af7c 	blt.w	800d270 <lv_draw_label_iterate_characters+0x2b8>
    }

    /*Align to middle*/
    if(align == LV_TEXT_ALIGN_CENTER) {
 800d378:	f897 30ab 	ldrb.w	r3, [r7, #171]	@ 0xab
 800d37c:	2b02      	cmp	r3, #2
 800d37e:	d12e      	bne.n	800d3de <lv_draw_label_iterate_characters+0x426>
        line_width = lv_text_get_width(&dsc->text[line_start], line_end - line_start, font, dsc->letter_space);
 800d380:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d384:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d388:	681b      	ldr	r3, [r3, #0]
 800d38a:	69da      	ldr	r2, [r3, #28]
 800d38c:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d390:	18d0      	adds	r0, r2, r3
 800d392:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 800d396:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d39a:	1ad1      	subs	r1, r2, r3
 800d39c:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d3a0:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d3a4:	681b      	ldr	r3, [r3, #0]
 800d3a6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800d3a8:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 800d3ac:	f016 fef0 	bl	8024190 <lv_text_get_width>
 800d3b0:	f8c7 00d8 	str.w	r0, [r7, #216]	@ 0xd8

        pos.x += (lv_area_get_width(coords) - line_width) / 2;
 800d3b4:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d3b8:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800d3bc:	6818      	ldr	r0, [r3, #0]
 800d3be:	f7ff fc43 	bl	800cc48 <lv_area_get_width>
 800d3c2:	4602      	mov	r2, r0
 800d3c4:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 800d3c8:	1ad3      	subs	r3, r2, r3
 800d3ca:	0fda      	lsrs	r2, r3, #31
 800d3cc:	4413      	add	r3, r2
 800d3ce:	105b      	asrs	r3, r3, #1
 800d3d0:	461a      	mov	r2, r3
 800d3d2:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 800d3d6:	4413      	add	r3, r2
 800d3d8:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 800d3dc:	e02d      	b.n	800d43a <lv_draw_label_iterate_characters+0x482>

    }
    /*Align to the right*/
    else if(align == LV_TEXT_ALIGN_RIGHT) {
 800d3de:	f897 30ab 	ldrb.w	r3, [r7, #171]	@ 0xab
 800d3e2:	2b03      	cmp	r3, #3
 800d3e4:	d129      	bne.n	800d43a <lv_draw_label_iterate_characters+0x482>
        line_width = lv_text_get_width(&dsc->text[line_start], line_end - line_start, font, dsc->letter_space);
 800d3e6:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d3ea:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d3ee:	681b      	ldr	r3, [r3, #0]
 800d3f0:	69da      	ldr	r2, [r3, #28]
 800d3f2:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d3f6:	18d0      	adds	r0, r2, r3
 800d3f8:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 800d3fc:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d400:	1ad1      	subs	r1, r2, r3
 800d402:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d406:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d40a:	681b      	ldr	r3, [r3, #0]
 800d40c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800d40e:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 800d412:	f016 febd 	bl	8024190 <lv_text_get_width>
 800d416:	f8c7 00d8 	str.w	r0, [r7, #216]	@ 0xd8
        pos.x += lv_area_get_width(coords) - line_width;
 800d41a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d41e:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800d422:	6818      	ldr	r0, [r3, #0]
 800d424:	f7ff fc10 	bl	800cc48 <lv_area_get_width>
 800d428:	4602      	mov	r2, r0
 800d42a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 800d42e:	1ad2      	subs	r2, r2, r3
 800d430:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 800d434:	4413      	add	r3, r2
 800d436:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    }

    uint32_t sel_start = dsc->sel_start;
 800d43a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d43e:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d442:	681b      	ldr	r3, [r3, #0]
 800d444:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d446:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    uint32_t sel_end = dsc->sel_end;
 800d44a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d44e:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d452:	681b      	ldr	r3, [r3, #0]
 800d454:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800d456:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    if(sel_start > sel_end) {
 800d45a:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 800d45e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800d462:	429a      	cmp	r2, r3
 800d464:	d90b      	bls.n	800d47e <lv_draw_label_iterate_characters+0x4c6>
        uint32_t tmp = sel_start;
 800d466:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800d46a:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
        sel_start = sel_end;
 800d46e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800d472:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
        sel_end = tmp;
 800d476:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 800d47a:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
    }

    lv_area_t bg_coords;
    lv_draw_glyph_dsc_t draw_letter_dsc;
    lv_draw_glyph_dsc_init(&draw_letter_dsc);
 800d47e:	f107 0374 	add.w	r3, r7, #116	@ 0x74
 800d482:	4618      	mov	r0, r3
 800d484:	f7ff fd3e 	bl	800cf04 <lv_draw_glyph_dsc_init>
    draw_letter_dsc.opa = dsc->opa;
 800d488:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d48c:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d490:	681b      	ldr	r3, [r3, #0]
 800d492:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800d496:	f887 308b 	strb.w	r3, [r7, #139]	@ 0x8b
    draw_letter_dsc.bg_coords = &bg_coords;
 800d49a:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 800d49e:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    draw_letter_dsc.color = dsc->color;
 800d4a2:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d4a6:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d4aa:	681a      	ldr	r2, [r3, #0]
 800d4ac:	f107 0388 	add.w	r3, r7, #136	@ 0x88
 800d4b0:	322c      	adds	r2, #44	@ 0x2c
 800d4b2:	6812      	ldr	r2, [r2, #0]
 800d4b4:	4611      	mov	r1, r2
 800d4b6:	8019      	strh	r1, [r3, #0]
 800d4b8:	3302      	adds	r3, #2
 800d4ba:	0c12      	lsrs	r2, r2, #16
 800d4bc:	701a      	strb	r2, [r3, #0]

    lv_draw_fill_dsc_t fill_dsc;
    lv_draw_fill_dsc_init(&fill_dsc);
 800d4be:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 800d4c2:	4618      	mov	r0, r3
 800d4c4:	f000 fc28 	bl	800dd18 <lv_draw_fill_dsc_init>
    fill_dsc.opa = dsc->opa;
 800d4c8:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d4cc:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d4d0:	681b      	ldr	r3, [r3, #0]
 800d4d2:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800d4d6:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
    int32_t underline_width = font->underline_thickness ? font->underline_thickness : 1;
 800d4da:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 800d4de:	f993 3016 	ldrsb.w	r3, [r3, #22]
 800d4e2:	2b00      	cmp	r3, #0
 800d4e4:	d004      	beq.n	800d4f0 <lv_draw_label_iterate_characters+0x538>
 800d4e6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 800d4ea:	f993 3016 	ldrsb.w	r3, [r3, #22]
 800d4ee:	e000      	b.n	800d4f2 <lv_draw_label_iterate_characters+0x53a>
 800d4f0:	2301      	movs	r3, #1
 800d4f2:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    int32_t line_start_x;
    uint32_t i;
    int32_t letter_w;

    /*Write out all lines*/
    while(dsc->text[line_start] != '\0') {
 800d4f6:	e222      	b.n	800d93e <lv_draw_label_iterate_characters+0x986>
        pos.x += x_ofs;
 800d4f8:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 800d4fc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 800d500:	4413      	add	r3, r2
 800d502:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
        line_start_x = pos.x;
 800d506:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 800d50a:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4

        /*Write all letter of a line*/
        i = 0;
 800d50e:	2300      	movs	r3, #0
 800d510:	643b      	str	r3, [r7, #64]	@ 0x40
#if LV_USE_BIDI
        char * bidi_txt = lv_malloc(line_end - line_start + 1);
        LV_ASSERT_MALLOC(bidi_txt);
        _lv_bidi_process_paragraph(dsc->text + line_start, bidi_txt, line_end - line_start, base_dir, NULL, 0);
#else
        const char * bidi_txt = dsc->text + line_start;
 800d512:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d516:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d51a:	681b      	ldr	r3, [r3, #0]
 800d51c:	69da      	ldr	r2, [r3, #28]
 800d51e:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d522:	4413      	add	r3, r2
 800d524:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
#endif

        while(i < line_end - line_start) {
 800d528:	e160      	b.n	800d7ec <lv_draw_label_iterate_characters+0x834>
            uint32_t logical_char_pos = 0;
 800d52a:	2300      	movs	r3, #0
 800d52c:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
 800d530:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800d534:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800d538:	4293      	cmp	r3, r2
 800d53a:	d015      	beq.n	800d568 <lv_draw_label_iterate_characters+0x5b0>
 800d53c:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800d540:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800d544:	4293      	cmp	r3, r2
 800d546:	d00f      	beq.n	800d568 <lv_draw_label_iterate_characters+0x5b0>
#if LV_USE_BIDI
                logical_char_pos = _lv_text_encoded_get_char_id(dsc->text, line_start);
                uint32_t t = _lv_text_encoded_get_char_id(bidi_txt, i);
                logical_char_pos += _lv_bidi_get_logical_pos(bidi_txt, NULL, line_end - line_start, base_dir, t, NULL);
#else
                logical_char_pos = _lv_text_encoded_get_char_id(dsc->text, line_start + i);
 800d548:	4b8d      	ldr	r3, [pc, #564]	@ (800d780 <lv_draw_label_iterate_characters+0x7c8>)
 800d54a:	681b      	ldr	r3, [r3, #0]
 800d54c:	f507 7284 	add.w	r2, r7, #264	@ 0x108
 800d550:	f5a2 7280 	sub.w	r2, r2, #256	@ 0x100
 800d554:	6812      	ldr	r2, [r2, #0]
 800d556:	69d0      	ldr	r0, [r2, #28]
 800d558:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 800d55a:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 800d55e:	440a      	add	r2, r1
 800d560:	4611      	mov	r1, r2
 800d562:	4798      	blx	r3
 800d564:	f8c7 00ec 	str.w	r0, [r7, #236]	@ 0xec
#endif
            }

            uint32_t letter;
            uint32_t letter_next;
            _lv_text_encoded_letter_next_2(bidi_txt, &letter, &letter_next, &i);
 800d568:	f107 0340 	add.w	r3, r7, #64	@ 0x40
 800d56c:	f107 0230 	add.w	r2, r7, #48	@ 0x30
 800d570:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 800d574:	f8d7 00c0 	ldr.w	r0, [r7, #192]	@ 0xc0
 800d578:	f016 fe56 	bl	8024228 <_lv_text_encoded_letter_next_2>

            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
 800d57c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d57e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800d580:	4619      	mov	r1, r3
 800d582:	f8d7 00e8 	ldr.w	r0, [r7, #232]	@ 0xe8
 800d586:	f00e ff75 	bl	801c474 <lv_font_get_glyph_width>
 800d58a:	4603      	mov	r3, r0
 800d58c:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc

            /*Always set the bg_coordinates for placeholder drawing*/
            bg_coords.x1 = pos.x;
 800d590:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 800d594:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
            bg_coords.y1 = pos.y;
 800d598:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 800d59c:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
            bg_coords.x2 = pos.x + letter_w - 1;
 800d5a0:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 800d5a4:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 800d5a8:	4413      	add	r3, r2
 800d5aa:	3b01      	subs	r3, #1
 800d5ac:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
            bg_coords.y2 = pos.y + line_height - 1;
 800d5b0:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 800d5b4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800d5b8:	4413      	add	r3, r2
 800d5ba:	3b01      	subs	r3, #1
 800d5bc:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c

            if(i >= line_end - line_start) {
 800d5c0:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 800d5c4:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d5c8:	1ad2      	subs	r2, r2, r3
 800d5ca:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d5cc:	429a      	cmp	r2, r3
 800d5ce:	f200 8098 	bhi.w	800d702 <lv_draw_label_iterate_characters+0x74a>
                if(dsc->decor & LV_TEXT_DECOR_UNDERLINE) {
 800d5d2:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d5d6:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d5da:	681b      	ldr	r3, [r3, #0]
 800d5dc:	f893 304c 	ldrb.w	r3, [r3, #76]	@ 0x4c
 800d5e0:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800d5e4:	b2db      	uxtb	r3, r3
 800d5e6:	f003 0301 	and.w	r3, r3, #1
 800d5ea:	2b00      	cmp	r3, #0
 800d5ec:	d038      	beq.n	800d660 <lv_draw_label_iterate_characters+0x6a8>
                    lv_area_t fill_area;
                    fill_area.x1 = line_start_x;
 800d5ee:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800d5f2:	623b      	str	r3, [r7, #32]
                    fill_area.x2 = pos.x + letter_w - 1;
 800d5f4:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 800d5f8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 800d5fc:	4413      	add	r3, r2
 800d5fe:	3b01      	subs	r3, #1
 800d600:	62bb      	str	r3, [r7, #40]	@ 0x28
                    fill_area.y1 = pos.y + font->line_height - font->base_line - font->underline_position;
 800d602:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 800d606:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 800d60a:	68db      	ldr	r3, [r3, #12]
 800d60c:	441a      	add	r2, r3
 800d60e:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 800d612:	691b      	ldr	r3, [r3, #16]
 800d614:	1ad3      	subs	r3, r2, r3
 800d616:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 800d61a:	f992 2015 	ldrsb.w	r2, [r2, #21]
 800d61e:	1a9b      	subs	r3, r3, r2
 800d620:	627b      	str	r3, [r7, #36]	@ 0x24
                    fill_area.y2 = fill_area.y1 + underline_width - 1;
 800d622:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800d624:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 800d628:	4413      	add	r3, r2
 800d62a:	3b01      	subs	r3, #1
 800d62c:	62fb      	str	r3, [r7, #44]	@ 0x2c

                    fill_dsc.color = dsc->color;
 800d62e:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d632:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d636:	681a      	ldr	r2, [r3, #0]
 800d638:	f107 0365 	add.w	r3, r7, #101	@ 0x65
 800d63c:	322c      	adds	r2, #44	@ 0x2c
 800d63e:	8811      	ldrh	r1, [r2, #0]
 800d640:	7892      	ldrb	r2, [r2, #2]
 800d642:	8019      	strh	r1, [r3, #0]
 800d644:	709a      	strb	r2, [r3, #2]
                    cb(draw_unit, NULL, &fill_dsc, &fill_area);
 800d646:	f107 0120 	add.w	r1, r7, #32
 800d64a:	f107 0244 	add.w	r2, r7, #68	@ 0x44
 800d64e:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d652:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
 800d656:	681c      	ldr	r4, [r3, #0]
 800d658:	460b      	mov	r3, r1
 800d65a:	2100      	movs	r1, #0
 800d65c:	68f8      	ldr	r0, [r7, #12]
 800d65e:	47a0      	blx	r4
                }
                if(dsc->decor & LV_TEXT_DECOR_STRIKETHROUGH) {
 800d660:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d664:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d668:	681b      	ldr	r3, [r3, #0]
 800d66a:	f893 304c 	ldrb.w	r3, [r3, #76]	@ 0x4c
 800d66e:	f3c3 0302 	ubfx	r3, r3, #0, #3
 800d672:	b2db      	uxtb	r3, r3
 800d674:	f003 0302 	and.w	r3, r3, #2
 800d678:	2b00      	cmp	r3, #0
 800d67a:	d042      	beq.n	800d702 <lv_draw_label_iterate_characters+0x74a>
                    lv_area_t fill_area;
                    fill_area.x1 = line_start_x;
 800d67c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 800d680:	613b      	str	r3, [r7, #16]
                    fill_area.x2 = pos.x + letter_w - 1;
 800d682:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 800d686:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 800d68a:	4413      	add	r3, r2
 800d68c:	3b01      	subs	r3, #1
 800d68e:	61bb      	str	r3, [r7, #24]
                    fill_area.y1 = pos.y + (font->line_height - font->base_line) * 2 / 3 + font->underline_thickness / 2;
 800d690:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 800d694:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 800d698:	68d9      	ldr	r1, [r3, #12]
 800d69a:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 800d69e:	691b      	ldr	r3, [r3, #16]
 800d6a0:	1acb      	subs	r3, r1, r3
 800d6a2:	005b      	lsls	r3, r3, #1
 800d6a4:	4937      	ldr	r1, [pc, #220]	@ (800d784 <lv_draw_label_iterate_characters+0x7cc>)
 800d6a6:	fb81 0103 	smull	r0, r1, r1, r3
 800d6aa:	17db      	asrs	r3, r3, #31
 800d6ac:	1acb      	subs	r3, r1, r3
 800d6ae:	441a      	add	r2, r3
 800d6b0:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 800d6b4:	f993 3016 	ldrsb.w	r3, [r3, #22]
 800d6b8:	0fd9      	lsrs	r1, r3, #31
 800d6ba:	440b      	add	r3, r1
 800d6bc:	105b      	asrs	r3, r3, #1
 800d6be:	b25b      	sxtb	r3, r3
 800d6c0:	4413      	add	r3, r2
 800d6c2:	617b      	str	r3, [r7, #20]
                    fill_area.y2 = fill_area.y1 + underline_width - 1;
 800d6c4:	697a      	ldr	r2, [r7, #20]
 800d6c6:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 800d6ca:	4413      	add	r3, r2
 800d6cc:	3b01      	subs	r3, #1
 800d6ce:	61fb      	str	r3, [r7, #28]

                    fill_dsc.color = dsc->color;
 800d6d0:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d6d4:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d6d8:	681a      	ldr	r2, [r3, #0]
 800d6da:	f107 0365 	add.w	r3, r7, #101	@ 0x65
 800d6de:	322c      	adds	r2, #44	@ 0x2c
 800d6e0:	8811      	ldrh	r1, [r2, #0]
 800d6e2:	7892      	ldrb	r2, [r2, #2]
 800d6e4:	8019      	strh	r1, [r3, #0]
 800d6e6:	709a      	strb	r2, [r3, #2]
                    cb(draw_unit, NULL, &fill_dsc, &fill_area);
 800d6e8:	f107 0110 	add.w	r1, r7, #16
 800d6ec:	f107 0244 	add.w	r2, r7, #68	@ 0x44
 800d6f0:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d6f4:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
 800d6f8:	681c      	ldr	r4, [r3, #0]
 800d6fa:	460b      	mov	r3, r1
 800d6fc:	2100      	movs	r1, #0
 800d6fe:	68f8      	ldr	r0, [r7, #12]
 800d700:	47a0      	blx	r4
                }
            }

            if(sel_start != 0xFFFF && sel_end != 0xFFFF && logical_char_pos >= sel_start && logical_char_pos < sel_end) {
 800d702:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800d706:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800d70a:	4293      	cmp	r3, r2
 800d70c:	d03c      	beq.n	800d788 <lv_draw_label_iterate_characters+0x7d0>
 800d70e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800d712:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800d716:	4293      	cmp	r3, r2
 800d718:	d036      	beq.n	800d788 <lv_draw_label_iterate_characters+0x7d0>
 800d71a:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 800d71e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 800d722:	429a      	cmp	r2, r3
 800d724:	d330      	bcc.n	800d788 <lv_draw_label_iterate_characters+0x7d0>
 800d726:	f8d7 20ec 	ldr.w	r2, [r7, #236]	@ 0xec
 800d72a:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 800d72e:	429a      	cmp	r2, r3
 800d730:	d22a      	bcs.n	800d788 <lv_draw_label_iterate_characters+0x7d0>
                draw_letter_dsc.color = dsc->sel_color;
 800d732:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d736:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d73a:	681a      	ldr	r2, [r3, #0]
 800d73c:	f107 0388 	add.w	r3, r7, #136	@ 0x88
 800d740:	322f      	adds	r2, #47	@ 0x2f
 800d742:	8811      	ldrh	r1, [r2, #0]
 800d744:	7892      	ldrb	r2, [r2, #2]
 800d746:	8019      	strh	r1, [r3, #0]
 800d748:	709a      	strb	r2, [r3, #2]
                fill_dsc.color = dsc->sel_bg_color;
 800d74a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d74e:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d752:	681a      	ldr	r2, [r3, #0]
 800d754:	f107 0365 	add.w	r3, r7, #101	@ 0x65
 800d758:	3232      	adds	r2, #50	@ 0x32
 800d75a:	8811      	ldrh	r1, [r2, #0]
 800d75c:	7892      	ldrb	r2, [r2, #2]
 800d75e:	8019      	strh	r1, [r3, #0]
 800d760:	709a      	strb	r2, [r3, #2]
                cb(draw_unit, NULL, &fill_dsc, &bg_coords);
 800d762:	f107 0190 	add.w	r1, r7, #144	@ 0x90
 800d766:	f107 0244 	add.w	r2, r7, #68	@ 0x44
 800d76a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d76e:	f5a3 7384 	sub.w	r3, r3, #264	@ 0x108
 800d772:	681c      	ldr	r4, [r3, #0]
 800d774:	460b      	mov	r3, r1
 800d776:	2100      	movs	r1, #0
 800d778:	68f8      	ldr	r0, [r7, #12]
 800d77a:	47a0      	blx	r4
 800d77c:	e012      	b.n	800d7a4 <lv_draw_label_iterate_characters+0x7ec>
 800d77e:	bf00      	nop
 800d780:	2000001c 	.word	0x2000001c
 800d784:	55555556 	.word	0x55555556
            }
            else {
                draw_letter_dsc.color = dsc->color;
 800d788:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d78c:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d790:	681a      	ldr	r2, [r3, #0]
 800d792:	f107 0388 	add.w	r3, r7, #136	@ 0x88
 800d796:	322c      	adds	r2, #44	@ 0x2c
 800d798:	6812      	ldr	r2, [r2, #0]
 800d79a:	4611      	mov	r1, r2
 800d79c:	8019      	strh	r1, [r3, #0]
 800d79e:	3302      	adds	r3, #2
 800d7a0:	0c12      	lsrs	r2, r2, #16
 800d7a2:	701a      	strb	r2, [r3, #0]
            }

            draw_letter(draw_unit, &draw_letter_dsc, &pos, font, letter, cb);
 800d7a4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d7a6:	f107 00a0 	add.w	r0, r7, #160	@ 0xa0
 800d7aa:	f107 0174 	add.w	r1, r7, #116	@ 0x74
 800d7ae:	f507 7284 	add.w	r2, r7, #264	@ 0x108
 800d7b2:	f5a2 7284 	sub.w	r2, r2, #264	@ 0x108
 800d7b6:	6812      	ldr	r2, [r2, #0]
 800d7b8:	9201      	str	r2, [sp, #4]
 800d7ba:	9300      	str	r3, [sp, #0]
 800d7bc:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 800d7c0:	4602      	mov	r2, r0
 800d7c2:	68f8      	ldr	r0, [r7, #12]
 800d7c4:	f000 f8dc 	bl	800d980 <draw_letter>

            if(letter_w > 0) {
 800d7c8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 800d7cc:	2b00      	cmp	r3, #0
 800d7ce:	dd0d      	ble.n	800d7ec <lv_draw_label_iterate_characters+0x834>
                pos.x += letter_w + dsc->letter_space;
 800d7d0:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 800d7d4:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d7d8:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d7dc:	681b      	ldr	r3, [r3, #0]
 800d7de:	6bd9      	ldr	r1, [r3, #60]	@ 0x3c
 800d7e0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 800d7e4:	440b      	add	r3, r1
 800d7e6:	4413      	add	r3, r2
 800d7e8:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
        while(i < line_end - line_start) {
 800d7ec:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 800d7f0:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d7f4:	1ad2      	subs	r2, r2, r3
 800d7f6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800d7f8:	429a      	cmp	r2, r3
 800d7fa:	f63f ae96 	bhi.w	800d52a <lv_draw_label_iterate_characters+0x572>
#if LV_USE_BIDI
        lv_free(bidi_txt);
        bidi_txt = NULL;
#endif
        /*Go to next line*/
        line_start = line_end;
 800d7fe:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 800d802:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
        line_end += _lv_text_get_next_line(&dsc->text[line_start], font, dsc->letter_space, w, NULL, dsc->flag);
 800d806:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d80a:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d80e:	681b      	ldr	r3, [r3, #0]
 800d810:	69da      	ldr	r2, [r3, #28]
 800d812:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d816:	18d0      	adds	r0, r2, r3
 800d818:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d81c:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d820:	681b      	ldr	r3, [r3, #0]
 800d822:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800d824:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d828:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d82c:	681b      	ldr	r3, [r3, #0]
 800d82e:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 800d832:	9301      	str	r3, [sp, #4]
 800d834:	2300      	movs	r3, #0
 800d836:	9300      	str	r3, [sp, #0]
 800d838:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 800d83c:	f8d7 10e8 	ldr.w	r1, [r7, #232]	@ 0xe8
 800d840:	f016 fbd8 	bl	8023ff4 <_lv_text_get_next_line>
 800d844:	4602      	mov	r2, r0
 800d846:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 800d84a:	4413      	add	r3, r2
 800d84c:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8

        pos.x = coords->x1;
 800d850:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d854:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800d858:	681b      	ldr	r3, [r3, #0]
 800d85a:	681b      	ldr	r3, [r3, #0]
 800d85c:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
        /*Align to middle*/
        if(align == LV_TEXT_ALIGN_CENTER) {
 800d860:	f897 30ab 	ldrb.w	r3, [r7, #171]	@ 0xab
 800d864:	2b02      	cmp	r3, #2
 800d866:	d12e      	bne.n	800d8c6 <lv_draw_label_iterate_characters+0x90e>
            line_width =
                lv_text_get_width(&dsc->text[line_start], line_end - line_start, font, dsc->letter_space);
 800d868:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d86c:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d870:	681b      	ldr	r3, [r3, #0]
 800d872:	69da      	ldr	r2, [r3, #28]
 800d874:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d878:	18d0      	adds	r0, r2, r3
 800d87a:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 800d87e:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d882:	1ad1      	subs	r1, r2, r3
 800d884:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d888:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d88c:	681b      	ldr	r3, [r3, #0]
 800d88e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800d890:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 800d894:	f016 fc7c 	bl	8024190 <lv_text_get_width>
 800d898:	f8c7 00d8 	str.w	r0, [r7, #216]	@ 0xd8

            pos.x += (lv_area_get_width(coords) - line_width) / 2;
 800d89c:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d8a0:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800d8a4:	6818      	ldr	r0, [r3, #0]
 800d8a6:	f7ff f9cf 	bl	800cc48 <lv_area_get_width>
 800d8aa:	4602      	mov	r2, r0
 800d8ac:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 800d8b0:	1ad3      	subs	r3, r2, r3
 800d8b2:	0fda      	lsrs	r2, r3, #31
 800d8b4:	4413      	add	r3, r2
 800d8b6:	105b      	asrs	r3, r3, #1
 800d8b8:	461a      	mov	r2, r3
 800d8ba:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 800d8be:	4413      	add	r3, r2
 800d8c0:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 800d8c4:	e02d      	b.n	800d922 <lv_draw_label_iterate_characters+0x96a>
        }
        /*Align to the right*/
        else if(align == LV_TEXT_ALIGN_RIGHT) {
 800d8c6:	f897 30ab 	ldrb.w	r3, [r7, #171]	@ 0xab
 800d8ca:	2b03      	cmp	r3, #3
 800d8cc:	d129      	bne.n	800d922 <lv_draw_label_iterate_characters+0x96a>
            line_width =
                lv_text_get_width(&dsc->text[line_start], line_end - line_start, font, dsc->letter_space);
 800d8ce:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d8d2:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d8d6:	681b      	ldr	r3, [r3, #0]
 800d8d8:	69da      	ldr	r2, [r3, #28]
 800d8da:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d8de:	18d0      	adds	r0, r2, r3
 800d8e0:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 800d8e4:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d8e8:	1ad1      	subs	r1, r2, r3
 800d8ea:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d8ee:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d8f2:	681b      	ldr	r3, [r3, #0]
 800d8f4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800d8f6:	f8d7 20e8 	ldr.w	r2, [r7, #232]	@ 0xe8
 800d8fa:	f016 fc49 	bl	8024190 <lv_text_get_width>
 800d8fe:	f8c7 00d8 	str.w	r0, [r7, #216]	@ 0xd8
            pos.x += lv_area_get_width(coords) - line_width;
 800d902:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d906:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 800d90a:	6818      	ldr	r0, [r3, #0]
 800d90c:	f7ff f99c 	bl	800cc48 <lv_area_get_width>
 800d910:	4602      	mov	r2, r0
 800d912:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 800d916:	1ad2      	subs	r2, r2, r3
 800d918:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 800d91c:	4413      	add	r3, r2
 800d91e:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
        }

        /*Go the next line position*/
        pos.y += line_height;
 800d922:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 800d926:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 800d92a:	4413      	add	r3, r2
 800d92c:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4

        if(pos.y > draw_unit->clip_area->y2) break;
 800d930:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 800d934:	68fb      	ldr	r3, [r7, #12]
 800d936:	689b      	ldr	r3, [r3, #8]
 800d938:	68db      	ldr	r3, [r3, #12]
 800d93a:	429a      	cmp	r2, r3
 800d93c:	dc0d      	bgt.n	800d95a <lv_draw_label_iterate_characters+0x9a2>
    while(dsc->text[line_start] != '\0') {
 800d93e:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 800d942:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 800d946:	681b      	ldr	r3, [r3, #0]
 800d948:	69da      	ldr	r2, [r3, #28]
 800d94a:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 800d94e:	4413      	add	r3, r2
 800d950:	781b      	ldrb	r3, [r3, #0]
 800d952:	2b00      	cmp	r3, #0
 800d954:	f47f add0 	bne.w	800d4f8 <lv_draw_label_iterate_characters+0x540>
 800d958:	e000      	b.n	800d95c <lv_draw_label_iterate_characters+0x9a4>
        if(pos.y > draw_unit->clip_area->y2) break;
 800d95a:	bf00      	nop
    }

    if(draw_letter_dsc._draw_buf) lv_draw_buf_destroy(draw_letter_dsc._draw_buf);
 800d95c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 800d960:	2b00      	cmp	r3, #0
 800d962:	d008      	beq.n	800d976 <lv_draw_label_iterate_characters+0x9be>
 800d964:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 800d968:	4618      	mov	r0, r3
 800d96a:	f7fe fb1f 	bl	800bfac <lv_draw_buf_destroy>
 800d96e:	e002      	b.n	800d976 <lv_draw_label_iterate_characters+0x9be>
    if(!clip_ok) return;
 800d970:	bf00      	nop
 800d972:	e000      	b.n	800d976 <lv_draw_label_iterate_characters+0x9be>
        if(dsc->text[line_start] == '\0') return;
 800d974:	bf00      	nop

    LV_ASSERT_MEM_INTEGRITY();
}
 800d976:	f507 7784 	add.w	r7, r7, #264	@ 0x108
 800d97a:	46bd      	mov	sp, r7
 800d97c:	bdb0      	pop	{r4, r5, r7, pc}
 800d97e:	bf00      	nop

0800d980 <draw_letter>:
 *   STATIC FUNCTIONS
 **********************/

static void draw_letter(lv_draw_unit_t * draw_unit, lv_draw_glyph_dsc_t * dsc,  const lv_point_t * pos,
                        const lv_font_t * font, uint32_t letter, lv_draw_glyph_cb_t cb)
{
 800d980:	b590      	push	{r4, r7, lr}
 800d982:	b095      	sub	sp, #84	@ 0x54
 800d984:	af02      	add	r7, sp, #8
 800d986:	60f8      	str	r0, [r7, #12]
 800d988:	60b9      	str	r1, [r7, #8]
 800d98a:	607a      	str	r2, [r7, #4]
 800d98c:	603b      	str	r3, [r7, #0]
    lv_font_glyph_dsc_t g;

    if(_lv_text_is_marker(letter)) /*Markers are valid letters but should not be rendered.*/
 800d98e:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 800d990:	f7ff f9de 	bl	800cd50 <_lv_text_is_marker>
 800d994:	4603      	mov	r3, r0
 800d996:	2b00      	cmp	r3, #0
 800d998:	f040 80c0 	bne.w	800db1c <draw_letter+0x19c>
        return;

    LV_PROFILER_BEGIN;
    bool g_ret = lv_font_get_glyph_dsc(font, &g, letter, '\0');
 800d99c:	f107 0124 	add.w	r1, r7, #36	@ 0x24
 800d9a0:	2300      	movs	r3, #0
 800d9a2:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 800d9a4:	6838      	ldr	r0, [r7, #0]
 800d9a6:	f00e fcdf 	bl	801c368 <lv_font_get_glyph_dsc>
 800d9aa:	4603      	mov	r3, r0
 800d9ac:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
        /*Add warning if the dsc is not found*/
        LV_LOG_WARN("lv_draw_letter: glyph dsc. not found for U+%" LV_PRIX32, letter);
    }

    /*Don't draw anything if the character is empty. E.g. space*/
    if((g.box_h == 0) || (g.box_w == 0)) {
 800d9b0:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 800d9b2:	2b00      	cmp	r3, #0
 800d9b4:	f000 80b4 	beq.w	800db20 <draw_letter+0x1a0>
 800d9b8:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 800d9ba:	2b00      	cmp	r3, #0
 800d9bc:	f000 80b0 	beq.w	800db20 <draw_letter+0x1a0>
        LV_PROFILER_END;
        return;
    }

    lv_area_t letter_coords;
    letter_coords.x1 = pos->x + g.ofs_x;
 800d9c0:	687b      	ldr	r3, [r7, #4]
 800d9c2:	681b      	ldr	r3, [r3, #0]
 800d9c4:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	@ 0x2e
 800d9c8:	4413      	add	r3, r2
 800d9ca:	617b      	str	r3, [r7, #20]
    letter_coords.x2 = letter_coords.x1 + g.box_w - 1;
 800d9cc:	697b      	ldr	r3, [r7, #20]
 800d9ce:	8d7a      	ldrh	r2, [r7, #42]	@ 0x2a
 800d9d0:	4413      	add	r3, r2
 800d9d2:	3b01      	subs	r3, #1
 800d9d4:	61fb      	str	r3, [r7, #28]
    letter_coords.y1 = pos->y + (font->line_height - font->base_line) - g.box_h - g.ofs_y;
 800d9d6:	687b      	ldr	r3, [r7, #4]
 800d9d8:	685a      	ldr	r2, [r3, #4]
 800d9da:	683b      	ldr	r3, [r7, #0]
 800d9dc:	68d9      	ldr	r1, [r3, #12]
 800d9de:	683b      	ldr	r3, [r7, #0]
 800d9e0:	691b      	ldr	r3, [r3, #16]
 800d9e2:	1acb      	subs	r3, r1, r3
 800d9e4:	4413      	add	r3, r2
 800d9e6:	8dba      	ldrh	r2, [r7, #44]	@ 0x2c
 800d9e8:	1a9b      	subs	r3, r3, r2
 800d9ea:	f9b7 2030 	ldrsh.w	r2, [r7, #48]	@ 0x30
 800d9ee:	1a9b      	subs	r3, r3, r2
 800d9f0:	61bb      	str	r3, [r7, #24]
    letter_coords.y2 = letter_coords.y1 + g.box_h - 1;
 800d9f2:	69bb      	ldr	r3, [r7, #24]
 800d9f4:	8dba      	ldrh	r2, [r7, #44]	@ 0x2c
 800d9f6:	4413      	add	r3, r2
 800d9f8:	3b01      	subs	r3, #1
 800d9fa:	623b      	str	r3, [r7, #32]

    /*If the letter is completely out of mask don't draw it*/
    if(_lv_area_is_out(&letter_coords, draw_unit->clip_area, 0) &&
 800d9fc:	68fb      	ldr	r3, [r7, #12]
 800d9fe:	6899      	ldr	r1, [r3, #8]
 800da00:	f107 0314 	add.w	r3, r7, #20
 800da04:	2200      	movs	r2, #0
 800da06:	4618      	mov	r0, r3
 800da08:	f014 f956 	bl	8021cb8 <_lv_area_is_out>
 800da0c:	4603      	mov	r3, r0
 800da0e:	2b00      	cmp	r3, #0
 800da10:	d00a      	beq.n	800da28 <draw_letter+0xa8>
       _lv_area_is_out(dsc->bg_coords, draw_unit->clip_area, 0)) {
 800da12:	68bb      	ldr	r3, [r7, #8]
 800da14:	68d8      	ldr	r0, [r3, #12]
 800da16:	68fb      	ldr	r3, [r7, #12]
 800da18:	689b      	ldr	r3, [r3, #8]
 800da1a:	2200      	movs	r2, #0
 800da1c:	4619      	mov	r1, r3
 800da1e:	f014 f94b 	bl	8021cb8 <_lv_area_is_out>
 800da22:	4603      	mov	r3, r0
    if(_lv_area_is_out(&letter_coords, draw_unit->clip_area, 0) &&
 800da24:	2b00      	cmp	r3, #0
 800da26:	d17d      	bne.n	800db24 <draw_letter+0x1a4>
        LV_PROFILER_END;
        return;
    }

    if(g.resolved_font) {
 800da28:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800da2a:	2b00      	cmp	r3, #0
 800da2c:	d056      	beq.n	800dadc <draw_letter+0x15c>
        lv_draw_buf_t * draw_buf = NULL;
 800da2e:	2300      	movs	r3, #0
 800da30:	647b      	str	r3, [r7, #68]	@ 0x44
        if(LV_FONT_GLYPH_FORMAT_NONE < g.format && g.format < LV_FONT_GLYPH_FORMAT_IMAGE) {
 800da32:	f897 3032 	ldrb.w	r3, [r7, #50]	@ 0x32
 800da36:	2b00      	cmp	r3, #0
 800da38:	d03b      	beq.n	800dab2 <draw_letter+0x132>
 800da3a:	f897 3032 	ldrb.w	r3, [r7, #50]	@ 0x32
 800da3e:	2b08      	cmp	r3, #8
 800da40:	d837      	bhi.n	800dab2 <draw_letter+0x132>
            /*Only check draw buf for bitmap glyph*/
            draw_buf = lv_draw_buf_reshape(dsc->_draw_buf, 0, g.box_w, g.box_h, LV_STRIDE_AUTO);
 800da42:	68bb      	ldr	r3, [r7, #8]
 800da44:	6998      	ldr	r0, [r3, #24]
 800da46:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 800da48:	461a      	mov	r2, r3
 800da4a:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 800da4c:	4619      	mov	r1, r3
 800da4e:	2300      	movs	r3, #0
 800da50:	9300      	str	r3, [sp, #0]
 800da52:	460b      	mov	r3, r1
 800da54:	2100      	movs	r1, #0
 800da56:	f7fe fa6b 	bl	800bf30 <lv_draw_buf_reshape>
 800da5a:	6478      	str	r0, [r7, #68]	@ 0x44
            if(draw_buf == NULL) {
 800da5c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800da5e:	2b00      	cmp	r3, #0
 800da60:	d127      	bne.n	800dab2 <draw_letter+0x132>
                if(dsc->_draw_buf) lv_draw_buf_destroy(dsc->_draw_buf);
 800da62:	68bb      	ldr	r3, [r7, #8]
 800da64:	699b      	ldr	r3, [r3, #24]
 800da66:	2b00      	cmp	r3, #0
 800da68:	d004      	beq.n	800da74 <draw_letter+0xf4>
 800da6a:	68bb      	ldr	r3, [r7, #8]
 800da6c:	699b      	ldr	r3, [r3, #24]
 800da6e:	4618      	mov	r0, r3
 800da70:	f7fe fa9c 	bl	800bfac <lv_draw_buf_destroy>

                uint32_t h = g.box_h;
 800da74:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 800da76:	643b      	str	r3, [r7, #64]	@ 0x40
                if(h * g.box_w < 64) h *= 2; /*Alloc a slightly larger buffer*/
 800da78:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 800da7a:	461a      	mov	r2, r3
 800da7c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800da7e:	fb02 f303 	mul.w	r3, r2, r3
 800da82:	2b3f      	cmp	r3, #63	@ 0x3f
 800da84:	d802      	bhi.n	800da8c <draw_letter+0x10c>
 800da86:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800da88:	005b      	lsls	r3, r3, #1
 800da8a:	643b      	str	r3, [r7, #64]	@ 0x40
                draw_buf = lv_draw_buf_create(g.box_w, h, LV_COLOR_FORMAT_A8, LV_STRIDE_AUTO);
 800da8c:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 800da8e:	4618      	mov	r0, r3
 800da90:	2300      	movs	r3, #0
 800da92:	220e      	movs	r2, #14
 800da94:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 800da96:	f7fe f9b7 	bl	800be08 <lv_draw_buf_create>
 800da9a:	6478      	str	r0, [r7, #68]	@ 0x44
                LV_ASSERT_MALLOC(draw_buf);
 800da9c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800da9e:	2b00      	cmp	r3, #0
 800daa0:	d101      	bne.n	800daa6 <draw_letter+0x126>
 800daa2:	bf00      	nop
 800daa4:	e7fd      	b.n	800daa2 <draw_letter+0x122>
                draw_buf->header.h = g.box_h;
 800daa6:	8dba      	ldrh	r2, [r7, #44]	@ 0x2c
 800daa8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800daaa:	80da      	strh	r2, [r3, #6]
                dsc->_draw_buf = draw_buf;
 800daac:	68bb      	ldr	r3, [r7, #8]
 800daae:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800dab0:	619a      	str	r2, [r3, #24]
            }
        }

        dsc->glyph_data = (void *)lv_font_get_glyph_bitmap(&g, letter, draw_buf);
 800dab2:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800dab6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800dab8:	6db9      	ldr	r1, [r7, #88]	@ 0x58
 800daba:	4618      	mov	r0, r3
 800dabc:	f00e fc3b 	bl	801c336 <lv_font_get_glyph_bitmap>
 800dac0:	4602      	mov	r2, r0
 800dac2:	68bb      	ldr	r3, [r7, #8]
 800dac4:	601a      	str	r2, [r3, #0]
        dsc->format = dsc->glyph_data ? g.format : LV_FONT_GLYPH_FORMAT_NONE;
 800dac6:	68bb      	ldr	r3, [r7, #8]
 800dac8:	681b      	ldr	r3, [r3, #0]
 800daca:	2b00      	cmp	r3, #0
 800dacc:	d002      	beq.n	800dad4 <draw_letter+0x154>
 800dace:	f897 2032 	ldrb.w	r2, [r7, #50]	@ 0x32
 800dad2:	e000      	b.n	800dad6 <draw_letter+0x156>
 800dad4:	2200      	movs	r2, #0
 800dad6:	68bb      	ldr	r3, [r7, #8]
 800dad8:	711a      	strb	r2, [r3, #4]
 800dada:	e002      	b.n	800dae2 <draw_letter+0x162>
    }
    else {
        dsc->format = LV_FONT_GLYPH_FORMAT_NONE;
 800dadc:	68bb      	ldr	r3, [r7, #8]
 800dade:	2200      	movs	r2, #0
 800dae0:	711a      	strb	r2, [r3, #4]
    }

    dsc->letter_coords = &letter_coords;
 800dae2:	68bb      	ldr	r3, [r7, #8]
 800dae4:	f107 0214 	add.w	r2, r7, #20
 800dae8:	609a      	str	r2, [r3, #8]
    dsc->g = &g;
 800daea:	68bb      	ldr	r3, [r7, #8]
 800daec:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 800daf0:	611a      	str	r2, [r3, #16]
    cb(draw_unit, dsc, NULL, NULL);
 800daf2:	6dfc      	ldr	r4, [r7, #92]	@ 0x5c
 800daf4:	2300      	movs	r3, #0
 800daf6:	2200      	movs	r2, #0
 800daf8:	68b9      	ldr	r1, [r7, #8]
 800dafa:	68f8      	ldr	r0, [r7, #12]
 800dafc:	47a0      	blx	r4

    if(g.resolved_font && font->release_glyph) {
 800dafe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800db00:	2b00      	cmp	r3, #0
 800db02:	d010      	beq.n	800db26 <draw_letter+0x1a6>
 800db04:	683b      	ldr	r3, [r7, #0]
 800db06:	689b      	ldr	r3, [r3, #8]
 800db08:	2b00      	cmp	r3, #0
 800db0a:	d00c      	beq.n	800db26 <draw_letter+0x1a6>
        font->release_glyph(font, &g);
 800db0c:	683b      	ldr	r3, [r7, #0]
 800db0e:	689b      	ldr	r3, [r3, #8]
 800db10:	f107 0224 	add.w	r2, r7, #36	@ 0x24
 800db14:	4611      	mov	r1, r2
 800db16:	6838      	ldr	r0, [r7, #0]
 800db18:	4798      	blx	r3
 800db1a:	e004      	b.n	800db26 <draw_letter+0x1a6>
        return;
 800db1c:	bf00      	nop
 800db1e:	e002      	b.n	800db26 <draw_letter+0x1a6>
        return;
 800db20:	bf00      	nop
 800db22:	e000      	b.n	800db26 <draw_letter+0x1a6>
        return;
 800db24:	bf00      	nop
    }
    LV_PROFILER_END;
}
 800db26:	374c      	adds	r7, #76	@ 0x4c
 800db28:	46bd      	mov	sp, r7
 800db2a:	bd90      	pop	{r4, r7, pc}

0800db2c <lv_color_make>:
{
 800db2c:	b480      	push	{r7}
 800db2e:	b085      	sub	sp, #20
 800db30:	af00      	add	r7, sp, #0
 800db32:	4603      	mov	r3, r0
 800db34:	71fb      	strb	r3, [r7, #7]
 800db36:	460b      	mov	r3, r1
 800db38:	71bb      	strb	r3, [r7, #6]
 800db3a:	4613      	mov	r3, r2
 800db3c:	717b      	strb	r3, [r7, #5]
    ret.red = r;
 800db3e:	79fb      	ldrb	r3, [r7, #7]
 800db40:	72bb      	strb	r3, [r7, #10]
    ret.green = g;
 800db42:	79bb      	ldrb	r3, [r7, #6]
 800db44:	727b      	strb	r3, [r7, #9]
    ret.blue = b;
 800db46:	797b      	ldrb	r3, [r7, #5]
 800db48:	723b      	strb	r3, [r7, #8]
    return ret;
 800db4a:	f107 030c 	add.w	r3, r7, #12
 800db4e:	f107 0208 	add.w	r2, r7, #8
 800db52:	6812      	ldr	r2, [r2, #0]
 800db54:	4611      	mov	r1, r2
 800db56:	8019      	strh	r1, [r3, #0]
 800db58:	3302      	adds	r3, #2
 800db5a:	0c12      	lsrs	r2, r2, #16
 800db5c:	701a      	strb	r2, [r3, #0]
 800db5e:	2300      	movs	r3, #0
 800db60:	7b3a      	ldrb	r2, [r7, #12]
 800db62:	f362 0307 	bfi	r3, r2, #0, #8
 800db66:	7b7a      	ldrb	r2, [r7, #13]
 800db68:	f362 230f 	bfi	r3, r2, #8, #8
 800db6c:	7bba      	ldrb	r2, [r7, #14]
 800db6e:	f362 4317 	bfi	r3, r2, #16, #8
}
 800db72:	4618      	mov	r0, r3
 800db74:	3714      	adds	r7, #20
 800db76:	46bd      	mov	sp, r7
 800db78:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db7c:	4770      	bx	lr

0800db7e <lv_color_white>:
{
 800db7e:	b580      	push	{r7, lr}
 800db80:	b082      	sub	sp, #8
 800db82:	af00      	add	r7, sp, #0
    return lv_color_make(0xff, 0xff, 0xff);
 800db84:	22ff      	movs	r2, #255	@ 0xff
 800db86:	21ff      	movs	r1, #255	@ 0xff
 800db88:	20ff      	movs	r0, #255	@ 0xff
 800db8a:	f7ff ffcf 	bl	800db2c <lv_color_make>
 800db8e:	4603      	mov	r3, r0
 800db90:	461a      	mov	r2, r3
 800db92:	713a      	strb	r2, [r7, #4]
 800db94:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800db98:	717a      	strb	r2, [r7, #5]
 800db9a:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800db9e:	71bb      	strb	r3, [r7, #6]
 800dba0:	2300      	movs	r3, #0
 800dba2:	793a      	ldrb	r2, [r7, #4]
 800dba4:	f362 0307 	bfi	r3, r2, #0, #8
 800dba8:	797a      	ldrb	r2, [r7, #5]
 800dbaa:	f362 230f 	bfi	r3, r2, #8, #8
 800dbae:	79ba      	ldrb	r2, [r7, #6]
 800dbb0:	f362 4317 	bfi	r3, r2, #16, #8
}
 800dbb4:	4618      	mov	r0, r3
 800dbb6:	3708      	adds	r7, #8
 800dbb8:	46bd      	mov	sp, r7
 800dbba:	bd80      	pop	{r7, pc}

0800dbbc <lv_color_black>:
{
 800dbbc:	b580      	push	{r7, lr}
 800dbbe:	b082      	sub	sp, #8
 800dbc0:	af00      	add	r7, sp, #0
    return lv_color_make(0x00, 0x00, 0x00);
 800dbc2:	2200      	movs	r2, #0
 800dbc4:	2100      	movs	r1, #0
 800dbc6:	2000      	movs	r0, #0
 800dbc8:	f7ff ffb0 	bl	800db2c <lv_color_make>
 800dbcc:	4603      	mov	r3, r0
 800dbce:	461a      	mov	r2, r3
 800dbd0:	713a      	strb	r2, [r7, #4]
 800dbd2:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800dbd6:	717a      	strb	r2, [r7, #5]
 800dbd8:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800dbdc:	71bb      	strb	r3, [r7, #6]
 800dbde:	2300      	movs	r3, #0
 800dbe0:	793a      	ldrb	r2, [r7, #4]
 800dbe2:	f362 0307 	bfi	r3, r2, #0, #8
 800dbe6:	797a      	ldrb	r2, [r7, #5]
 800dbe8:	f362 230f 	bfi	r3, r2, #8, #8
 800dbec:	79ba      	ldrb	r2, [r7, #6]
 800dbee:	f362 4317 	bfi	r3, r2, #16, #8
}
 800dbf2:	4618      	mov	r0, r3
 800dbf4:	3708      	adds	r7, #8
 800dbf6:	46bd      	mov	sp, r7
 800dbf8:	bd80      	pop	{r7, pc}

0800dbfa <lv_memzero>:
{
 800dbfa:	b580      	push	{r7, lr}
 800dbfc:	b082      	sub	sp, #8
 800dbfe:	af00      	add	r7, sp, #0
 800dc00:	6078      	str	r0, [r7, #4]
 800dc02:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 800dc04:	683a      	ldr	r2, [r7, #0]
 800dc06:	2100      	movs	r1, #0
 800dc08:	6878      	ldr	r0, [r7, #4]
 800dc0a:	f017 f90a 	bl	8024e22 <lv_memset>
}
 800dc0e:	bf00      	nop
 800dc10:	3708      	adds	r7, #8
 800dc12:	46bd      	mov	sp, r7
 800dc14:	bd80      	pop	{r7, pc}
	...

0800dc18 <lv_draw_rect_dsc_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void LV_ATTRIBUTE_FAST_MEM lv_draw_rect_dsc_init(lv_draw_rect_dsc_t * dsc)
{
 800dc18:	b590      	push	{r4, r7, lr}
 800dc1a:	b083      	sub	sp, #12
 800dc1c:	af00      	add	r7, sp, #0
 800dc1e:	6078      	str	r0, [r7, #4]
    lv_memzero(dsc, sizeof(lv_draw_rect_dsc_t));
 800dc20:	2170      	movs	r1, #112	@ 0x70
 800dc22:	6878      	ldr	r0, [r7, #4]
 800dc24:	f7ff ffe9 	bl	800dbfa <lv_memzero>
    dsc->bg_color = lv_color_white();
 800dc28:	687c      	ldr	r4, [r7, #4]
 800dc2a:	f7ff ffa8 	bl	800db7e <lv_color_white>
 800dc2e:	4603      	mov	r3, r0
 800dc30:	461a      	mov	r2, r3
 800dc32:	f884 2021 	strb.w	r2, [r4, #33]	@ 0x21
 800dc36:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800dc3a:	f884 2022 	strb.w	r2, [r4, #34]	@ 0x22
 800dc3e:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800dc42:	f884 3023 	strb.w	r3, [r4, #35]	@ 0x23
    dsc->bg_grad.stops[0].color = lv_color_white();
 800dc46:	687c      	ldr	r4, [r7, #4]
 800dc48:	f7ff ff99 	bl	800db7e <lv_color_white>
 800dc4c:	4603      	mov	r3, r0
 800dc4e:	461a      	mov	r2, r3
 800dc50:	f884 2024 	strb.w	r2, [r4, #36]	@ 0x24
 800dc54:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800dc58:	f884 2025 	strb.w	r2, [r4, #37]	@ 0x25
 800dc5c:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800dc60:	f884 3026 	strb.w	r3, [r4, #38]	@ 0x26
    dsc->bg_grad.stops[1].color = lv_color_black();
 800dc64:	687c      	ldr	r4, [r7, #4]
 800dc66:	f7ff ffa9 	bl	800dbbc <lv_color_black>
 800dc6a:	4603      	mov	r3, r0
 800dc6c:	461a      	mov	r2, r3
 800dc6e:	f884 2029 	strb.w	r2, [r4, #41]	@ 0x29
 800dc72:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800dc76:	f884 202a 	strb.w	r2, [r4, #42]	@ 0x2a
 800dc7a:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800dc7e:	f884 302b 	strb.w	r3, [r4, #43]	@ 0x2b
    dsc->bg_grad.stops[1].frac = 0xFF;
 800dc82:	687b      	ldr	r3, [r7, #4]
 800dc84:	22ff      	movs	r2, #255	@ 0xff
 800dc86:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d
    dsc->bg_grad.stops_count = 2;
 800dc8a:	687b      	ldr	r3, [r7, #4]
 800dc8c:	2202      	movs	r2, #2
 800dc8e:	f883 202e 	strb.w	r2, [r3, #46]	@ 0x2e
    dsc->border_color = lv_color_black();
 800dc92:	687c      	ldr	r4, [r7, #4]
 800dc94:	f7ff ff92 	bl	800dbbc <lv_color_black>
 800dc98:	4603      	mov	r3, r0
 800dc9a:	461a      	mov	r2, r3
 800dc9c:	f884 203e 	strb.w	r2, [r4, #62]	@ 0x3e
 800dca0:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800dca4:	f884 203f 	strb.w	r2, [r4, #63]	@ 0x3f
 800dca8:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800dcac:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
    dsc->shadow_color = lv_color_black();
 800dcb0:	687c      	ldr	r4, [r7, #4]
 800dcb2:	f7ff ff83 	bl	800dbbc <lv_color_black>
 800dcb6:	4603      	mov	r3, r0
 800dcb8:	461a      	mov	r2, r3
 800dcba:	f884 2059 	strb.w	r2, [r4, #89]	@ 0x59
 800dcbe:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800dcc2:	f884 205a 	strb.w	r2, [r4, #90]	@ 0x5a
 800dcc6:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800dcca:	f884 305b 	strb.w	r3, [r4, #91]	@ 0x5b
    dsc->bg_image_symbol_font = LV_FONT_DEFAULT;
 800dcce:	687b      	ldr	r3, [r7, #4]
 800dcd0:	4a10      	ldr	r2, [pc, #64]	@ (800dd14 <lv_draw_rect_dsc_init+0xfc>)
 800dcd2:	635a      	str	r2, [r3, #52]	@ 0x34
    dsc->bg_opa = LV_OPA_COVER;
 800dcd4:	687b      	ldr	r3, [r7, #4]
 800dcd6:	22ff      	movs	r2, #255	@ 0xff
 800dcd8:	f883 2020 	strb.w	r2, [r3, #32]
    dsc->bg_image_opa = LV_OPA_COVER;
 800dcdc:	687b      	ldr	r3, [r7, #4]
 800dcde:	22ff      	movs	r2, #255	@ 0xff
 800dce0:	f883 203b 	strb.w	r2, [r3, #59]	@ 0x3b
    dsc->outline_opa = LV_OPA_COVER;
 800dce4:	687b      	ldr	r3, [r7, #4]
 800dce6:	22ff      	movs	r2, #255	@ 0xff
 800dce8:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
    dsc->border_opa = LV_OPA_COVER;
 800dcec:	687b      	ldr	r3, [r7, #4]
 800dcee:	22ff      	movs	r2, #255	@ 0xff
 800dcf0:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48
    dsc->shadow_opa = LV_OPA_COVER;
 800dcf4:	687b      	ldr	r3, [r7, #4]
 800dcf6:	22ff      	movs	r2, #255	@ 0xff
 800dcf8:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
    dsc->border_side = LV_BORDER_SIDE_FULL;
 800dcfc:	687a      	ldr	r2, [r7, #4]
 800dcfe:	f892 3049 	ldrb.w	r3, [r2, #73]	@ 0x49
 800dd02:	210f      	movs	r1, #15
 800dd04:	f361 0304 	bfi	r3, r1, #0, #5
 800dd08:	f882 3049 	strb.w	r3, [r2, #73]	@ 0x49
}
 800dd0c:	bf00      	nop
 800dd0e:	370c      	adds	r7, #12
 800dd10:	46bd      	mov	sp, r7
 800dd12:	bd90      	pop	{r4, r7, pc}
 800dd14:	0802b154 	.word	0x0802b154

0800dd18 <lv_draw_fill_dsc_init>:

void lv_draw_fill_dsc_init(lv_draw_fill_dsc_t * dsc)
{
 800dd18:	b580      	push	{r7, lr}
 800dd1a:	b082      	sub	sp, #8
 800dd1c:	af00      	add	r7, sp, #0
 800dd1e:	6078      	str	r0, [r7, #4]
    lv_memzero(dsc, sizeof(*dsc));
 800dd20:	2130      	movs	r1, #48	@ 0x30
 800dd22:	6878      	ldr	r0, [r7, #4]
 800dd24:	f7ff ff69 	bl	800dbfa <lv_memzero>
    dsc->opa = LV_OPA_COVER;
 800dd28:	687b      	ldr	r3, [r7, #4]
 800dd2a:	22ff      	movs	r2, #255	@ 0xff
 800dd2c:	f883 2020 	strb.w	r2, [r3, #32]
    dsc->base.dsc_size = sizeof(lv_draw_fill_dsc_t);
 800dd30:	687b      	ldr	r3, [r7, #4]
 800dd32:	2230      	movs	r2, #48	@ 0x30
 800dd34:	615a      	str	r2, [r3, #20]
}
 800dd36:	bf00      	nop
 800dd38:	3708      	adds	r7, #8
 800dd3a:	46bd      	mov	sp, r7
 800dd3c:	bd80      	pop	{r7, pc}

0800dd3e <lv_draw_border_dsc_init>:
{
    return task->type == LV_DRAW_TASK_TYPE_FILL ? (lv_draw_fill_dsc_t *)task->draw_dsc : NULL;
}

void lv_draw_border_dsc_init(lv_draw_border_dsc_t * dsc)
{
 800dd3e:	b580      	push	{r7, lr}
 800dd40:	b082      	sub	sp, #8
 800dd42:	af00      	add	r7, sp, #0
 800dd44:	6078      	str	r0, [r7, #4]
    lv_memzero(dsc, sizeof(*dsc));
 800dd46:	212c      	movs	r1, #44	@ 0x2c
 800dd48:	6878      	ldr	r0, [r7, #4]
 800dd4a:	f7ff ff56 	bl	800dbfa <lv_memzero>
    dsc->opa = LV_OPA_COVER;
 800dd4e:	687b      	ldr	r3, [r7, #4]
 800dd50:	22ff      	movs	r2, #255	@ 0xff
 800dd52:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    dsc->side = LV_BORDER_SIDE_FULL;
 800dd56:	687a      	ldr	r2, [r7, #4]
 800dd58:	f892 3029 	ldrb.w	r3, [r2, #41]	@ 0x29
 800dd5c:	210f      	movs	r1, #15
 800dd5e:	f361 0304 	bfi	r3, r1, #0, #5
 800dd62:	f882 3029 	strb.w	r3, [r2, #41]	@ 0x29
    dsc->base.dsc_size = sizeof(lv_draw_border_dsc_t);
 800dd66:	687b      	ldr	r3, [r7, #4]
 800dd68:	222c      	movs	r2, #44	@ 0x2c
 800dd6a:	615a      	str	r2, [r3, #20]
}
 800dd6c:	bf00      	nop
 800dd6e:	3708      	adds	r7, #8
 800dd70:	46bd      	mov	sp, r7
 800dd72:	bd80      	pop	{r7, pc}

0800dd74 <lv_draw_rect>:
{
    return task->type == LV_DRAW_TASK_TYPE_BOX_SHADOW ? (lv_draw_box_shadow_dsc_t *)task->draw_dsc : NULL;
}

void lv_draw_rect(lv_layer_t * layer, const lv_draw_rect_dsc_t * dsc, const lv_area_t * coords)
{
 800dd74:	b5b0      	push	{r4, r5, r7, lr}
 800dd76:	b0aa      	sub	sp, #168	@ 0xa8
 800dd78:	af04      	add	r7, sp, #16
 800dd7a:	60f8      	str	r0, [r7, #12]
 800dd7c:	60b9      	str	r1, [r7, #8]
 800dd7e:	607a      	str	r2, [r7, #4]
    bool has_fill;
    bool has_border;
    bool has_outline;
    bool has_bg_img;

    if(dsc->shadow_width == 0 ||
 800dd80:	68bb      	ldr	r3, [r7, #8]
 800dd82:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800dd84:	2b00      	cmp	r3, #0
 800dd86:	d014      	beq.n	800ddb2 <lv_draw_rect+0x3e>
       dsc->shadow_opa <= LV_OPA_MIN ||
 800dd88:	68bb      	ldr	r3, [r7, #8]
 800dd8a:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
    if(dsc->shadow_width == 0 ||
 800dd8e:	2b02      	cmp	r3, #2
 800dd90:	d90f      	bls.n	800ddb2 <lv_draw_rect+0x3e>
       (dsc->shadow_width == 1 && dsc->shadow_spread <= 0 &&
 800dd92:	68bb      	ldr	r3, [r7, #8]
 800dd94:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
       dsc->shadow_opa <= LV_OPA_MIN ||
 800dd96:	2b01      	cmp	r3, #1
 800dd98:	d10f      	bne.n	800ddba <lv_draw_rect+0x46>
       (dsc->shadow_width == 1 && dsc->shadow_spread <= 0 &&
 800dd9a:	68bb      	ldr	r3, [r7, #8]
 800dd9c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800dd9e:	2b00      	cmp	r3, #0
 800dda0:	dc0b      	bgt.n	800ddba <lv_draw_rect+0x46>
        dsc->shadow_offset_x == 0 && dsc->shadow_offset_y == 0)) {
 800dda2:	68bb      	ldr	r3, [r7, #8]
 800dda4:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
       (dsc->shadow_width == 1 && dsc->shadow_spread <= 0 &&
 800dda6:	2b00      	cmp	r3, #0
 800dda8:	d107      	bne.n	800ddba <lv_draw_rect+0x46>
        dsc->shadow_offset_x == 0 && dsc->shadow_offset_y == 0)) {
 800ddaa:	68bb      	ldr	r3, [r7, #8]
 800ddac:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800ddae:	2b00      	cmp	r3, #0
 800ddb0:	d103      	bne.n	800ddba <lv_draw_rect+0x46>
        has_shadow = false;
 800ddb2:	2300      	movs	r3, #0
 800ddb4:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
 800ddb8:	e002      	b.n	800ddc0 <lv_draw_rect+0x4c>
    }
    else {
        has_shadow = true;
 800ddba:	2301      	movs	r3, #1
 800ddbc:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
    }

    if(dsc->bg_opa <= LV_OPA_MIN) has_fill = false;
 800ddc0:	68bb      	ldr	r3, [r7, #8]
 800ddc2:	f893 3020 	ldrb.w	r3, [r3, #32]
 800ddc6:	2b02      	cmp	r3, #2
 800ddc8:	d803      	bhi.n	800ddd2 <lv_draw_rect+0x5e>
 800ddca:	2300      	movs	r3, #0
 800ddcc:	f887 3096 	strb.w	r3, [r7, #150]	@ 0x96
 800ddd0:	e002      	b.n	800ddd8 <lv_draw_rect+0x64>
    else has_fill = true;
 800ddd2:	2301      	movs	r3, #1
 800ddd4:	f887 3096 	strb.w	r3, [r7, #150]	@ 0x96

    if(dsc->bg_image_opa <= LV_OPA_MIN || dsc->bg_image_src == NULL) has_bg_img = false;
 800ddd8:	68bb      	ldr	r3, [r7, #8]
 800ddda:	f893 303b 	ldrb.w	r3, [r3, #59]	@ 0x3b
 800ddde:	2b02      	cmp	r3, #2
 800dde0:	d903      	bls.n	800ddea <lv_draw_rect+0x76>
 800dde2:	68bb      	ldr	r3, [r7, #8]
 800dde4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800dde6:	2b00      	cmp	r3, #0
 800dde8:	d103      	bne.n	800ddf2 <lv_draw_rect+0x7e>
 800ddea:	2300      	movs	r3, #0
 800ddec:	f887 3093 	strb.w	r3, [r7, #147]	@ 0x93
 800ddf0:	e002      	b.n	800ddf8 <lv_draw_rect+0x84>
    else has_bg_img = true;
 800ddf2:	2301      	movs	r3, #1
 800ddf4:	f887 3093 	strb.w	r3, [r7, #147]	@ 0x93

    if(dsc->border_opa <= LV_OPA_MIN || dsc->border_width == 0 || dsc->border_post == true) has_border = false;
 800ddf8:	68bb      	ldr	r3, [r7, #8]
 800ddfa:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800ddfe:	2b02      	cmp	r3, #2
 800de00:	d90b      	bls.n	800de1a <lv_draw_rect+0xa6>
 800de02:	68bb      	ldr	r3, [r7, #8]
 800de04:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800de06:	2b00      	cmp	r3, #0
 800de08:	d007      	beq.n	800de1a <lv_draw_rect+0xa6>
 800de0a:	68bb      	ldr	r3, [r7, #8]
 800de0c:	f893 3049 	ldrb.w	r3, [r3, #73]	@ 0x49
 800de10:	f003 0320 	and.w	r3, r3, #32
 800de14:	b2db      	uxtb	r3, r3
 800de16:	2b00      	cmp	r3, #0
 800de18:	d003      	beq.n	800de22 <lv_draw_rect+0xae>
 800de1a:	2300      	movs	r3, #0
 800de1c:	f887 3095 	strb.w	r3, [r7, #149]	@ 0x95
 800de20:	e002      	b.n	800de28 <lv_draw_rect+0xb4>
    else has_border = true;
 800de22:	2301      	movs	r3, #1
 800de24:	f887 3095 	strb.w	r3, [r7, #149]	@ 0x95

    if(dsc->outline_opa <= LV_OPA_MIN || dsc->outline_width == 0) has_outline = false;
 800de28:	68bb      	ldr	r3, [r7, #8]
 800de2a:	f893 3058 	ldrb.w	r3, [r3, #88]	@ 0x58
 800de2e:	2b02      	cmp	r3, #2
 800de30:	d903      	bls.n	800de3a <lv_draw_rect+0xc6>
 800de32:	68bb      	ldr	r3, [r7, #8]
 800de34:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800de36:	2b00      	cmp	r3, #0
 800de38:	d103      	bne.n	800de42 <lv_draw_rect+0xce>
 800de3a:	2300      	movs	r3, #0
 800de3c:	f887 3094 	strb.w	r3, [r7, #148]	@ 0x94
 800de40:	e002      	b.n	800de48 <lv_draw_rect+0xd4>
    else has_outline = true;
 800de42:	2301      	movs	r3, #1
 800de44:	f887 3094 	strb.w	r3, [r7, #148]	@ 0x94

    bool bg_cover = true;
 800de48:	2301      	movs	r3, #1
 800de4a:	f887 3092 	strb.w	r3, [r7, #146]	@ 0x92
    if(dsc->bg_opa < LV_OPA_COVER) bg_cover = false;
 800de4e:	68bb      	ldr	r3, [r7, #8]
 800de50:	f893 3020 	ldrb.w	r3, [r3, #32]
 800de54:	2bff      	cmp	r3, #255	@ 0xff
 800de56:	d003      	beq.n	800de60 <lv_draw_rect+0xec>
 800de58:	2300      	movs	r3, #0
 800de5a:	f887 3092 	strb.w	r3, [r7, #146]	@ 0x92
 800de5e:	e027      	b.n	800deb0 <lv_draw_rect+0x13c>
    else if(dsc->bg_grad.dir != LV_GRAD_DIR_NONE) {
 800de60:	68bb      	ldr	r3, [r7, #8]
 800de62:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
 800de66:	f003 0307 	and.w	r3, r3, #7
 800de6a:	b2db      	uxtb	r3, r3
 800de6c:	2b00      	cmp	r3, #0
 800de6e:	d01f      	beq.n	800deb0 <lv_draw_rect+0x13c>
        uint32_t s;
        for(s = 0; s < dsc->bg_grad.stops_count; s++) {
 800de70:	2300      	movs	r3, #0
 800de72:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 800de76:	e013      	b.n	800dea0 <lv_draw_rect+0x12c>
            if(dsc->bg_grad.stops[s].opa != LV_OPA_COVER) {
 800de78:	68b9      	ldr	r1, [r7, #8]
 800de7a:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 800de7e:	4613      	mov	r3, r2
 800de80:	009b      	lsls	r3, r3, #2
 800de82:	4413      	add	r3, r2
 800de84:	440b      	add	r3, r1
 800de86:	3327      	adds	r3, #39	@ 0x27
 800de88:	781b      	ldrb	r3, [r3, #0]
 800de8a:	2bff      	cmp	r3, #255	@ 0xff
 800de8c:	d003      	beq.n	800de96 <lv_draw_rect+0x122>
                bg_cover = false;
 800de8e:	2300      	movs	r3, #0
 800de90:	f887 3092 	strb.w	r3, [r7, #146]	@ 0x92
                break;
 800de94:	e00c      	b.n	800deb0 <lv_draw_rect+0x13c>
        for(s = 0; s < dsc->bg_grad.stops_count; s++) {
 800de96:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 800de9a:	3301      	adds	r3, #1
 800de9c:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 800dea0:	68bb      	ldr	r3, [r7, #8]
 800dea2:	f893 302e 	ldrb.w	r3, [r3, #46]	@ 0x2e
 800dea6:	461a      	mov	r2, r3
 800dea8:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 800deac:	4293      	cmp	r3, r2
 800deae:	d3e3      	bcc.n	800de78 <lv_draw_rect+0x104>
    }

    lv_draw_task_t * t;

    /*Shadow*/
    if(has_shadow) {
 800deb0:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 800deb4:	2b00      	cmp	r3, #0
 800deb6:	d07b      	beq.n	800dfb0 <lv_draw_rect+0x23c>
        /*Check whether the shadow is visible*/
        t = lv_draw_add_task(layer, coords);
 800deb8:	6879      	ldr	r1, [r7, #4]
 800deba:	68f8      	ldr	r0, [r7, #12]
 800debc:	f7fd fad0 	bl	800b460 <lv_draw_add_task>
 800dec0:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
        lv_draw_box_shadow_dsc_t * shadow_dsc = lv_malloc(sizeof(lv_draw_box_shadow_dsc_t));
 800dec4:	2038      	movs	r0, #56	@ 0x38
 800dec6:	f017 ff7f 	bl	8025dc8 <lv_malloc>
 800deca:	f8c7 0080 	str.w	r0, [r7, #128]	@ 0x80
        t->draw_dsc = shadow_dsc;
 800dece:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800ded2:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 800ded6:	64da      	str	r2, [r3, #76]	@ 0x4c
        lv_area_increase(&t->_real_area, dsc->shadow_spread, dsc->shadow_spread);
 800ded8:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800dedc:	f103 0018 	add.w	r0, r3, #24
 800dee0:	68bb      	ldr	r3, [r7, #8]
 800dee2:	6e99      	ldr	r1, [r3, #104]	@ 0x68
 800dee4:	68bb      	ldr	r3, [r7, #8]
 800dee6:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800dee8:	461a      	mov	r2, r3
 800deea:	f013 fce5 	bl	80218b8 <lv_area_increase>
        lv_area_increase(&t->_real_area, dsc->shadow_width, dsc->shadow_width);
 800deee:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800def2:	f103 0018 	add.w	r0, r3, #24
 800def6:	68bb      	ldr	r3, [r7, #8]
 800def8:	6dd9      	ldr	r1, [r3, #92]	@ 0x5c
 800defa:	68bb      	ldr	r3, [r7, #8]
 800defc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800defe:	461a      	mov	r2, r3
 800df00:	f013 fcda 	bl	80218b8 <lv_area_increase>
        lv_area_move(&t->_real_area, dsc->shadow_offset_x, dsc->shadow_offset_y);
 800df04:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800df08:	f103 0018 	add.w	r0, r3, #24
 800df0c:	68bb      	ldr	r3, [r7, #8]
 800df0e:	6e19      	ldr	r1, [r3, #96]	@ 0x60
 800df10:	68bb      	ldr	r3, [r7, #8]
 800df12:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800df14:	461a      	mov	r2, r3
 800df16:	f013 fcf3 	bl	8021900 <lv_area_move>
        shadow_dsc->base = dsc->base;
 800df1a:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 800df1e:	68bb      	ldr	r3, [r7, #8]
 800df20:	4614      	mov	r4, r2
 800df22:	461d      	mov	r5, r3
 800df24:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800df26:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800df28:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800df2c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        shadow_dsc->base.dsc_size = sizeof(lv_draw_box_shadow_dsc_t);
 800df30:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800df34:	2238      	movs	r2, #56	@ 0x38
 800df36:	615a      	str	r2, [r3, #20]
        shadow_dsc->radius = dsc->radius;
 800df38:	68bb      	ldr	r3, [r7, #8]
 800df3a:	69da      	ldr	r2, [r3, #28]
 800df3c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800df40:	61da      	str	r2, [r3, #28]
        shadow_dsc->color = dsc->shadow_color;
 800df42:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800df46:	68ba      	ldr	r2, [r7, #8]
 800df48:	3320      	adds	r3, #32
 800df4a:	3259      	adds	r2, #89	@ 0x59
 800df4c:	8811      	ldrh	r1, [r2, #0]
 800df4e:	7892      	ldrb	r2, [r2, #2]
 800df50:	8019      	strh	r1, [r3, #0]
 800df52:	709a      	strb	r2, [r3, #2]
        shadow_dsc->width = dsc->shadow_width;
 800df54:	68bb      	ldr	r3, [r7, #8]
 800df56:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 800df58:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800df5c:	625a      	str	r2, [r3, #36]	@ 0x24
        shadow_dsc->spread = dsc->shadow_spread;
 800df5e:	68bb      	ldr	r3, [r7, #8]
 800df60:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
 800df62:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800df66:	629a      	str	r2, [r3, #40]	@ 0x28
        shadow_dsc->opa = dsc->shadow_opa;
 800df68:	68bb      	ldr	r3, [r7, #8]
 800df6a:	f893 206c 	ldrb.w	r2, [r3, #108]	@ 0x6c
 800df6e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800df72:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        shadow_dsc->ofs_x = dsc->shadow_offset_x;
 800df76:	68bb      	ldr	r3, [r7, #8]
 800df78:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 800df7a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800df7e:	62da      	str	r2, [r3, #44]	@ 0x2c
        shadow_dsc->ofs_y = dsc->shadow_offset_y;
 800df80:	68bb      	ldr	r3, [r7, #8]
 800df82:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 800df84:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 800df88:	631a      	str	r2, [r3, #48]	@ 0x30
        shadow_dsc->bg_cover = bg_cover;
 800df8a:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 800df8e:	f892 3035 	ldrb.w	r3, [r2, #53]	@ 0x35
 800df92:	f897 1092 	ldrb.w	r1, [r7, #146]	@ 0x92
 800df96:	f361 0300 	bfi	r3, r1, #0, #1
 800df9a:	f882 3035 	strb.w	r3, [r2, #53]	@ 0x35
        t->type = LV_DRAW_TASK_TYPE_BOX_SHADOW;
 800df9e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800dfa2:	2202      	movs	r2, #2
 800dfa4:	711a      	strb	r2, [r3, #4]
        lv_draw_finalize_task_creation(layer, t);
 800dfa6:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 800dfaa:	68f8      	ldr	r0, [r7, #12]
 800dfac:	f7fd fa98 	bl	800b4e0 <lv_draw_finalize_task_creation>
    }

    /*Background*/
    if(has_fill) {
 800dfb0:	f897 3096 	ldrb.w	r3, [r7, #150]	@ 0x96
 800dfb4:	2b00      	cmp	r3, #0
 800dfb6:	f000 8084 	beq.w	800e0c2 <lv_draw_rect+0x34e>
        lv_area_t bg_coords = *coords;
 800dfba:	687b      	ldr	r3, [r7, #4]
 800dfbc:	f107 0458 	add.w	r4, r7, #88	@ 0x58
 800dfc0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800dfc2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        /*If the border fully covers make the bg area 1px smaller to avoid artifacts on the corners*/
        if(dsc->border_width > 1 && dsc->border_opa >= LV_OPA_MAX && dsc->radius != 0) {
 800dfc6:	68bb      	ldr	r3, [r7, #8]
 800dfc8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800dfca:	2b01      	cmp	r3, #1
 800dfcc:	dd37      	ble.n	800e03e <lv_draw_rect+0x2ca>
 800dfce:	68bb      	ldr	r3, [r7, #8]
 800dfd0:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 800dfd4:	2bfc      	cmp	r3, #252	@ 0xfc
 800dfd6:	d932      	bls.n	800e03e <lv_draw_rect+0x2ca>
 800dfd8:	68bb      	ldr	r3, [r7, #8]
 800dfda:	69db      	ldr	r3, [r3, #28]
 800dfdc:	2b00      	cmp	r3, #0
 800dfde:	d02e      	beq.n	800e03e <lv_draw_rect+0x2ca>
            bg_coords.x1 += (dsc->border_side & LV_BORDER_SIDE_LEFT) ? 1 : 0;
 800dfe0:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 800dfe2:	68bb      	ldr	r3, [r7, #8]
 800dfe4:	f893 3049 	ldrb.w	r3, [r3, #73]	@ 0x49
 800dfe8:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800dfec:	b2db      	uxtb	r3, r3
 800dfee:	109b      	asrs	r3, r3, #2
 800dff0:	f003 0301 	and.w	r3, r3, #1
 800dff4:	4413      	add	r3, r2
 800dff6:	65bb      	str	r3, [r7, #88]	@ 0x58
            bg_coords.y1 += (dsc->border_side & LV_BORDER_SIDE_TOP) ? 1 : 0;
 800dff8:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 800dffa:	68bb      	ldr	r3, [r7, #8]
 800dffc:	f893 3049 	ldrb.w	r3, [r3, #73]	@ 0x49
 800e000:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800e004:	b2db      	uxtb	r3, r3
 800e006:	105b      	asrs	r3, r3, #1
 800e008:	f003 0301 	and.w	r3, r3, #1
 800e00c:	4413      	add	r3, r2
 800e00e:	65fb      	str	r3, [r7, #92]	@ 0x5c
            bg_coords.x2 -= (dsc->border_side & LV_BORDER_SIDE_RIGHT) ? 1 : 0;
 800e010:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 800e012:	68bb      	ldr	r3, [r7, #8]
 800e014:	f893 3049 	ldrb.w	r3, [r3, #73]	@ 0x49
 800e018:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800e01c:	b2db      	uxtb	r3, r3
 800e01e:	10db      	asrs	r3, r3, #3
 800e020:	f003 0301 	and.w	r3, r3, #1
 800e024:	1ad3      	subs	r3, r2, r3
 800e026:	663b      	str	r3, [r7, #96]	@ 0x60
            bg_coords.y2 -= (dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? 1 : 0;
 800e028:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 800e02a:	68bb      	ldr	r3, [r7, #8]
 800e02c:	f893 3049 	ldrb.w	r3, [r3, #73]	@ 0x49
 800e030:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800e034:	b2db      	uxtb	r3, r3
 800e036:	f003 0301 	and.w	r3, r3, #1
 800e03a:	1ad3      	subs	r3, r2, r3
 800e03c:	667b      	str	r3, [r7, #100]	@ 0x64
        }

        t = lv_draw_add_task(layer, &bg_coords);
 800e03e:	f107 0358 	add.w	r3, r7, #88	@ 0x58
 800e042:	4619      	mov	r1, r3
 800e044:	68f8      	ldr	r0, [r7, #12]
 800e046:	f7fd fa0b 	bl	800b460 <lv_draw_add_task>
 800e04a:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
        lv_draw_fill_dsc_t * bg_dsc = lv_malloc(sizeof(lv_draw_fill_dsc_t));
 800e04e:	2030      	movs	r0, #48	@ 0x30
 800e050:	f017 feba 	bl	8025dc8 <lv_malloc>
 800e054:	67f8      	str	r0, [r7, #124]	@ 0x7c
        lv_draw_fill_dsc_init(bg_dsc);
 800e056:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 800e058:	f7ff fe5e 	bl	800dd18 <lv_draw_fill_dsc_init>
        t->draw_dsc = bg_dsc;
 800e05c:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800e060:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 800e062:	64da      	str	r2, [r3, #76]	@ 0x4c
        bg_dsc->base = dsc->base;
 800e064:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 800e066:	68bb      	ldr	r3, [r7, #8]
 800e068:	4614      	mov	r4, r2
 800e06a:	461d      	mov	r5, r3
 800e06c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800e06e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800e070:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800e074:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        bg_dsc->base.dsc_size = sizeof(lv_draw_fill_dsc_t);
 800e078:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800e07a:	2230      	movs	r2, #48	@ 0x30
 800e07c:	615a      	str	r2, [r3, #20]
        bg_dsc->radius = dsc->radius;
 800e07e:	68bb      	ldr	r3, [r7, #8]
 800e080:	69da      	ldr	r2, [r3, #28]
 800e082:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800e084:	61da      	str	r2, [r3, #28]
        bg_dsc->color = dsc->bg_color;
 800e086:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800e088:	68ba      	ldr	r2, [r7, #8]
 800e08a:	3321      	adds	r3, #33	@ 0x21
 800e08c:	3221      	adds	r2, #33	@ 0x21
 800e08e:	8811      	ldrh	r1, [r2, #0]
 800e090:	7892      	ldrb	r2, [r2, #2]
 800e092:	8019      	strh	r1, [r3, #0]
 800e094:	709a      	strb	r2, [r3, #2]
        bg_dsc->grad = dsc->bg_grad;
 800e096:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800e098:	68ba      	ldr	r2, [r7, #8]
 800e09a:	3324      	adds	r3, #36	@ 0x24
 800e09c:	3224      	adds	r2, #36	@ 0x24
 800e09e:	ca07      	ldmia	r2, {r0, r1, r2}
 800e0a0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
        bg_dsc->opa = dsc->bg_opa;
 800e0a4:	68bb      	ldr	r3, [r7, #8]
 800e0a6:	f893 2020 	ldrb.w	r2, [r3, #32]
 800e0aa:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 800e0ac:	f883 2020 	strb.w	r2, [r3, #32]
        t->type = LV_DRAW_TASK_TYPE_FILL;
 800e0b0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800e0b4:	2200      	movs	r2, #0
 800e0b6:	711a      	strb	r2, [r3, #4]

        lv_draw_finalize_task_creation(layer, t);
 800e0b8:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 800e0bc:	68f8      	ldr	r0, [r7, #12]
 800e0be:	f7fd fa0f 	bl	800b4e0 <lv_draw_finalize_task_creation>
    }

    /*Background image*/
    if(has_bg_img) {
 800e0c2:	f897 3093 	ldrb.w	r3, [r7, #147]	@ 0x93
 800e0c6:	2b00      	cmp	r3, #0
 800e0c8:	f000 8111 	beq.w	800e2ee <lv_draw_rect+0x57a>
        lv_image_src_t src_type = lv_image_src_get_type(dsc->bg_image_src);
 800e0cc:	68bb      	ldr	r3, [r7, #8]
 800e0ce:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800e0d0:	4618      	mov	r0, r3
 800e0d2:	f7fe fb2f 	bl	800c734 <lv_image_src_get_type>
 800e0d6:	4603      	mov	r3, r0
 800e0d8:	f887 307b 	strb.w	r3, [r7, #123]	@ 0x7b
        lv_result_t res = LV_RESULT_OK;
 800e0dc:	2301      	movs	r3, #1
 800e0de:	f887 3087 	strb.w	r3, [r7, #135]	@ 0x87
        lv_image_header_t header;
        if(src_type == LV_IMAGE_SRC_VARIABLE || src_type == LV_IMAGE_SRC_FILE) {
 800e0e2:	f897 307b 	ldrb.w	r3, [r7, #123]	@ 0x7b
 800e0e6:	2b00      	cmp	r3, #0
 800e0e8:	d003      	beq.n	800e0f2 <lv_draw_rect+0x37e>
 800e0ea:	f897 307b 	ldrb.w	r3, [r7, #123]	@ 0x7b
 800e0ee:	2b01      	cmp	r3, #1
 800e0f0:	d10b      	bne.n	800e10a <lv_draw_rect+0x396>
            res  = lv_image_decoder_get_info(dsc->bg_image_src, &header);
 800e0f2:	68bb      	ldr	r3, [r7, #8]
 800e0f4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800e0f6:	f107 024c 	add.w	r2, r7, #76	@ 0x4c
 800e0fa:	4611      	mov	r1, r2
 800e0fc:	4618      	mov	r0, r3
 800e0fe:	f000 f9f5 	bl	800e4ec <lv_image_decoder_get_info>
 800e102:	4603      	mov	r3, r0
 800e104:	f887 3087 	strb.w	r3, [r7, #135]	@ 0x87
 800e108:	e00d      	b.n	800e126 <lv_draw_rect+0x3b2>
        }
        else if(src_type == LV_IMAGE_SRC_UNKNOWN) {
 800e10a:	f897 307b 	ldrb.w	r3, [r7, #123]	@ 0x7b
 800e10e:	2b03      	cmp	r3, #3
 800e110:	d103      	bne.n	800e11a <lv_draw_rect+0x3a6>
            res = LV_RESULT_INVALID;
 800e112:	2300      	movs	r3, #0
 800e114:	f887 3087 	strb.w	r3, [r7, #135]	@ 0x87
 800e118:	e005      	b.n	800e126 <lv_draw_rect+0x3b2>
        }
        else {
            lv_memzero(&header, sizeof(header));
 800e11a:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
 800e11e:	210c      	movs	r1, #12
 800e120:	4618      	mov	r0, r3
 800e122:	f7ff fd6a 	bl	800dbfa <lv_memzero>
        }

        if(res == LV_RESULT_OK) {
 800e126:	f897 3087 	ldrb.w	r3, [r7, #135]	@ 0x87
 800e12a:	2b01      	cmp	r3, #1
 800e12c:	f040 80df 	bne.w	800e2ee <lv_draw_rect+0x57a>
            if(src_type == LV_IMAGE_SRC_VARIABLE || src_type == LV_IMAGE_SRC_FILE) {
 800e130:	f897 307b 	ldrb.w	r3, [r7, #123]	@ 0x7b
 800e134:	2b00      	cmp	r3, #0
 800e136:	d003      	beq.n	800e140 <lv_draw_rect+0x3cc>
 800e138:	f897 307b 	ldrb.w	r3, [r7, #123]	@ 0x7b
 800e13c:	2b01      	cmp	r3, #1
 800e13e:	d178      	bne.n	800e232 <lv_draw_rect+0x4be>

                if(dsc->bg_image_tiled) {
 800e140:	68bb      	ldr	r3, [r7, #8]
 800e142:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800e146:	2b00      	cmp	r3, #0
 800e148:	d006      	beq.n	800e158 <lv_draw_rect+0x3e4>
                    t = lv_draw_add_task(layer, coords);
 800e14a:	6879      	ldr	r1, [r7, #4]
 800e14c:	68f8      	ldr	r0, [r7, #12]
 800e14e:	f7fd f987 	bl	800b460 <lv_draw_add_task>
 800e152:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
 800e156:	e01c      	b.n	800e192 <lv_draw_rect+0x41e>
                }
                else {
                    lv_area_t a = {0, 0, header.w - 1, header.h - 1};
 800e158:	2300      	movs	r3, #0
 800e15a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800e15c:	2300      	movs	r3, #0
 800e15e:	643b      	str	r3, [r7, #64]	@ 0x40
 800e160:	f8b7 3050 	ldrh.w	r3, [r7, #80]	@ 0x50
 800e164:	3b01      	subs	r3, #1
 800e166:	647b      	str	r3, [r7, #68]	@ 0x44
 800e168:	f8b7 3052 	ldrh.w	r3, [r7, #82]	@ 0x52
 800e16c:	3b01      	subs	r3, #1
 800e16e:	64bb      	str	r3, [r7, #72]	@ 0x48
                    lv_area_align(coords, &a, LV_ALIGN_CENTER, 0, 0);
 800e170:	f107 013c 	add.w	r1, r7, #60	@ 0x3c
 800e174:	2300      	movs	r3, #0
 800e176:	9300      	str	r3, [sp, #0]
 800e178:	2300      	movs	r3, #0
 800e17a:	2209      	movs	r2, #9
 800e17c:	6878      	ldr	r0, [r7, #4]
 800e17e:	f013 fe19 	bl	8021db4 <lv_area_align>
                    t = lv_draw_add_task(layer, &a);
 800e182:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 800e186:	4619      	mov	r1, r3
 800e188:	68f8      	ldr	r0, [r7, #12]
 800e18a:	f7fd f969 	bl	800b460 <lv_draw_add_task>
 800e18e:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
                }

                lv_draw_image_dsc_t * bg_image_dsc = lv_malloc(sizeof(lv_draw_image_dsc_t));
 800e192:	2068      	movs	r0, #104	@ 0x68
 800e194:	f017 fe18 	bl	8025dc8 <lv_malloc>
 800e198:	6738      	str	r0, [r7, #112]	@ 0x70
                lv_draw_image_dsc_init(bg_image_dsc);
 800e19a:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 800e19c:	f7fe fa94 	bl	800c6c8 <lv_draw_image_dsc_init>
                t->draw_dsc = bg_image_dsc;
 800e1a0:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800e1a4:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 800e1a6:	64da      	str	r2, [r3, #76]	@ 0x4c
                bg_image_dsc->base = dsc->base;
 800e1a8:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 800e1aa:	68bb      	ldr	r3, [r7, #8]
 800e1ac:	4614      	mov	r4, r2
 800e1ae:	461d      	mov	r5, r3
 800e1b0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800e1b2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800e1b4:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800e1b8:	e884 0007 	stmia.w	r4, {r0, r1, r2}
                bg_image_dsc->base.dsc_size = sizeof(lv_draw_image_dsc_t);
 800e1bc:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800e1be:	2268      	movs	r2, #104	@ 0x68
 800e1c0:	615a      	str	r2, [r3, #20]
                bg_image_dsc->src = dsc->bg_image_src;
 800e1c2:	68bb      	ldr	r3, [r7, #8]
 800e1c4:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800e1c6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800e1c8:	61da      	str	r2, [r3, #28]
                bg_image_dsc->opa = dsc->bg_image_opa;
 800e1ca:	68bb      	ldr	r3, [r7, #8]
 800e1cc:	f893 203b 	ldrb.w	r2, [r3, #59]	@ 0x3b
 800e1d0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800e1d2:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
                bg_image_dsc->recolor = dsc->bg_image_recolor;
 800e1d6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800e1d8:	68ba      	ldr	r2, [r7, #8]
 800e1da:	3348      	adds	r3, #72	@ 0x48
 800e1dc:	3238      	adds	r2, #56	@ 0x38
 800e1de:	6812      	ldr	r2, [r2, #0]
 800e1e0:	4611      	mov	r1, r2
 800e1e2:	8019      	strh	r1, [r3, #0]
 800e1e4:	3302      	adds	r3, #2
 800e1e6:	0c12      	lsrs	r2, r2, #16
 800e1e8:	701a      	strb	r2, [r3, #0]
                bg_image_dsc->recolor_opa = dsc->bg_image_recolor_opa;
 800e1ea:	68bb      	ldr	r3, [r7, #8]
 800e1ec:	f893 203c 	ldrb.w	r2, [r3, #60]	@ 0x3c
 800e1f0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800e1f2:	f883 204b 	strb.w	r2, [r3, #75]	@ 0x4b
                bg_image_dsc->tile = dsc->bg_image_tiled;
 800e1f6:	68bb      	ldr	r3, [r7, #8]
 800e1f8:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800e1fc:	f003 0301 	and.w	r3, r3, #1
 800e200:	b2d9      	uxtb	r1, r3
 800e202:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 800e204:	f892 304d 	ldrb.w	r3, [r2, #77]	@ 0x4d
 800e208:	f361 1345 	bfi	r3, r1, #5, #1
 800e20c:	f882 304d 	strb.w	r3, [r2, #77]	@ 0x4d
                bg_image_dsc->header = header;
 800e210:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 800e212:	3320      	adds	r3, #32
 800e214:	f107 024c 	add.w	r2, r7, #76	@ 0x4c
 800e218:	ca07      	ldmia	r2, {r0, r1, r2}
 800e21a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
                t->type = LV_DRAW_TASK_TYPE_IMAGE;
 800e21e:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800e222:	2204      	movs	r2, #4
 800e224:	711a      	strb	r2, [r3, #4]
                lv_draw_finalize_task_creation(layer, t);
 800e226:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 800e22a:	68f8      	ldr	r0, [r7, #12]
 800e22c:	f7fd f958 	bl	800b4e0 <lv_draw_finalize_task_creation>
            if(src_type == LV_IMAGE_SRC_VARIABLE || src_type == LV_IMAGE_SRC_FILE) {
 800e230:	e05d      	b.n	800e2ee <lv_draw_rect+0x57a>
            }
            else {
                lv_point_t s;
                lv_text_get_size(&s, dsc->bg_image_src, dsc->bg_image_symbol_font, 0, 0, LV_COORD_MAX, LV_TEXT_FLAG_NONE);
 800e232:	68bb      	ldr	r3, [r7, #8]
 800e234:	6b19      	ldr	r1, [r3, #48]	@ 0x30
 800e236:	68bb      	ldr	r3, [r7, #8]
 800e238:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800e23a:	f107 0034 	add.w	r0, r7, #52	@ 0x34
 800e23e:	2300      	movs	r3, #0
 800e240:	9302      	str	r3, [sp, #8]
 800e242:	f06f 4360 	mvn.w	r3, #3758096384	@ 0xe0000000
 800e246:	9301      	str	r3, [sp, #4]
 800e248:	2300      	movs	r3, #0
 800e24a:	9300      	str	r3, [sp, #0]
 800e24c:	2300      	movs	r3, #0
 800e24e:	f015 fd67 	bl	8023d20 <lv_text_get_size>

                lv_area_t a = {0, 0, s.x - 1, s.y - 1};
 800e252:	2300      	movs	r3, #0
 800e254:	627b      	str	r3, [r7, #36]	@ 0x24
 800e256:	2300      	movs	r3, #0
 800e258:	62bb      	str	r3, [r7, #40]	@ 0x28
 800e25a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e25c:	3b01      	subs	r3, #1
 800e25e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800e260:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800e262:	3b01      	subs	r3, #1
 800e264:	633b      	str	r3, [r7, #48]	@ 0x30
                lv_area_align(coords, &a, LV_ALIGN_CENTER, 0, 0);
 800e266:	f107 0124 	add.w	r1, r7, #36	@ 0x24
 800e26a:	2300      	movs	r3, #0
 800e26c:	9300      	str	r3, [sp, #0]
 800e26e:	2300      	movs	r3, #0
 800e270:	2209      	movs	r2, #9
 800e272:	6878      	ldr	r0, [r7, #4]
 800e274:	f013 fd9e 	bl	8021db4 <lv_area_align>
                t = lv_draw_add_task(layer, &a);
 800e278:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800e27c:	4619      	mov	r1, r3
 800e27e:	68f8      	ldr	r0, [r7, #12]
 800e280:	f7fd f8ee 	bl	800b460 <lv_draw_add_task>
 800e284:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88

                lv_draw_label_dsc_t * bg_label_dsc = lv_malloc(sizeof(lv_draw_label_dsc_t));
 800e288:	2054      	movs	r0, #84	@ 0x54
 800e28a:	f017 fd9d 	bl	8025dc8 <lv_malloc>
 800e28e:	6778      	str	r0, [r7, #116]	@ 0x74
                lv_draw_label_dsc_init(bg_label_dsc);
 800e290:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 800e292:	f7fe fdd3 	bl	800ce3c <lv_draw_label_dsc_init>
                t->draw_dsc = bg_label_dsc;
 800e296:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800e29a:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 800e29c:	64da      	str	r2, [r3, #76]	@ 0x4c
                bg_label_dsc->base = dsc->base;
 800e29e:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 800e2a0:	68bb      	ldr	r3, [r7, #8]
 800e2a2:	4614      	mov	r4, r2
 800e2a4:	461d      	mov	r5, r3
 800e2a6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800e2a8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800e2aa:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800e2ae:	e884 0007 	stmia.w	r4, {r0, r1, r2}
                bg_label_dsc->base.dsc_size = sizeof(lv_draw_label_dsc_t);
 800e2b2:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800e2b4:	2254      	movs	r2, #84	@ 0x54
 800e2b6:	615a      	str	r2, [r3, #20]
                bg_label_dsc->color = dsc->bg_image_recolor;
 800e2b8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800e2ba:	68ba      	ldr	r2, [r7, #8]
 800e2bc:	332c      	adds	r3, #44	@ 0x2c
 800e2be:	3238      	adds	r2, #56	@ 0x38
 800e2c0:	6812      	ldr	r2, [r2, #0]
 800e2c2:	4611      	mov	r1, r2
 800e2c4:	8019      	strh	r1, [r3, #0]
 800e2c6:	3302      	adds	r3, #2
 800e2c8:	0c12      	lsrs	r2, r2, #16
 800e2ca:	701a      	strb	r2, [r3, #0]
                bg_label_dsc->font = dsc->bg_image_symbol_font;
 800e2cc:	68bb      	ldr	r3, [r7, #8]
 800e2ce:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800e2d0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800e2d2:	621a      	str	r2, [r3, #32]
                bg_label_dsc->text = dsc->bg_image_src;
 800e2d4:	68bb      	ldr	r3, [r7, #8]
 800e2d6:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800e2d8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 800e2da:	61da      	str	r2, [r3, #28]
                t->type = LV_DRAW_TASK_TYPE_LABEL;
 800e2dc:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800e2e0:	2203      	movs	r2, #3
 800e2e2:	711a      	strb	r2, [r3, #4]
                lv_draw_finalize_task_creation(layer, t);
 800e2e4:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 800e2e8:	68f8      	ldr	r0, [r7, #12]
 800e2ea:	f7fd f8f9 	bl	800b4e0 <lv_draw_finalize_task_creation>
            }
        }
    }

    /*Border*/
    if(has_border) {
 800e2ee:	f897 3095 	ldrb.w	r3, [r7, #149]	@ 0x95
 800e2f2:	2b00      	cmp	r3, #0
 800e2f4:	d046      	beq.n	800e384 <lv_draw_rect+0x610>
        t = lv_draw_add_task(layer, coords);
 800e2f6:	6879      	ldr	r1, [r7, #4]
 800e2f8:	68f8      	ldr	r0, [r7, #12]
 800e2fa:	f7fd f8b1 	bl	800b460 <lv_draw_add_task>
 800e2fe:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
        lv_draw_border_dsc_t * border_dsc = lv_malloc(sizeof(lv_draw_border_dsc_t));
 800e302:	202c      	movs	r0, #44	@ 0x2c
 800e304:	f017 fd60 	bl	8025dc8 <lv_malloc>
 800e308:	66f8      	str	r0, [r7, #108]	@ 0x6c
        t->draw_dsc = border_dsc;
 800e30a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800e30e:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 800e310:	64da      	str	r2, [r3, #76]	@ 0x4c
        border_dsc->base = dsc->base;
 800e312:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 800e314:	68bb      	ldr	r3, [r7, #8]
 800e316:	4614      	mov	r4, r2
 800e318:	461d      	mov	r5, r3
 800e31a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800e31c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800e31e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800e322:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        border_dsc->base.dsc_size = sizeof(lv_draw_border_dsc_t);
 800e326:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800e328:	222c      	movs	r2, #44	@ 0x2c
 800e32a:	615a      	str	r2, [r3, #20]
        border_dsc->radius = dsc->radius;
 800e32c:	68bb      	ldr	r3, [r7, #8]
 800e32e:	69da      	ldr	r2, [r3, #28]
 800e330:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800e332:	61da      	str	r2, [r3, #28]
        border_dsc->color = dsc->border_color;
 800e334:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800e336:	68ba      	ldr	r2, [r7, #8]
 800e338:	3320      	adds	r3, #32
 800e33a:	323e      	adds	r2, #62	@ 0x3e
 800e33c:	8811      	ldrh	r1, [r2, #0]
 800e33e:	7892      	ldrb	r2, [r2, #2]
 800e340:	8019      	strh	r1, [r3, #0]
 800e342:	709a      	strb	r2, [r3, #2]
        border_dsc->opa = dsc->border_opa;
 800e344:	68bb      	ldr	r3, [r7, #8]
 800e346:	f893 2048 	ldrb.w	r2, [r3, #72]	@ 0x48
 800e34a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800e34c:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
        border_dsc->width = dsc->border_width;
 800e350:	68bb      	ldr	r3, [r7, #8]
 800e352:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800e354:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 800e356:	625a      	str	r2, [r3, #36]	@ 0x24
        border_dsc->side = dsc->border_side;
 800e358:	68bb      	ldr	r3, [r7, #8]
 800e35a:	f893 3049 	ldrb.w	r3, [r3, #73]	@ 0x49
 800e35e:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800e362:	b2d9      	uxtb	r1, r3
 800e364:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 800e366:	f892 3029 	ldrb.w	r3, [r2, #41]	@ 0x29
 800e36a:	f361 0304 	bfi	r3, r1, #0, #5
 800e36e:	f882 3029 	strb.w	r3, [r2, #41]	@ 0x29
        t->type = LV_DRAW_TASK_TYPE_BORDER;
 800e372:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800e376:	2201      	movs	r2, #1
 800e378:	711a      	strb	r2, [r3, #4]
        lv_draw_finalize_task_creation(layer, t);
 800e37a:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 800e37e:	68f8      	ldr	r0, [r7, #12]
 800e380:	f7fd f8ae 	bl	800b4e0 <lv_draw_finalize_task_creation>
    }

    /*Outline*/
    if(has_outline) {
 800e384:	f897 3094 	ldrb.w	r3, [r7, #148]	@ 0x94
 800e388:	2b00      	cmp	r3, #0
 800e38a:	d07d      	beq.n	800e488 <lv_draw_rect+0x714>
        lv_area_t outline_coords = *coords;
 800e38c:	687b      	ldr	r3, [r7, #4]
 800e38e:	f107 0414 	add.w	r4, r7, #20
 800e392:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800e394:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        lv_area_increase(&outline_coords, dsc->outline_width + dsc->outline_pad, dsc->outline_width + dsc->outline_pad);
 800e398:	68bb      	ldr	r3, [r7, #8]
 800e39a:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 800e39c:	68bb      	ldr	r3, [r7, #8]
 800e39e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800e3a0:	18d1      	adds	r1, r2, r3
 800e3a2:	68bb      	ldr	r3, [r7, #8]
 800e3a4:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 800e3a6:	68bb      	ldr	r3, [r7, #8]
 800e3a8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800e3aa:	441a      	add	r2, r3
 800e3ac:	f107 0314 	add.w	r3, r7, #20
 800e3b0:	4618      	mov	r0, r3
 800e3b2:	f013 fa81 	bl	80218b8 <lv_area_increase>
        t = lv_draw_add_task(layer, &outline_coords);
 800e3b6:	f107 0314 	add.w	r3, r7, #20
 800e3ba:	4619      	mov	r1, r3
 800e3bc:	68f8      	ldr	r0, [r7, #12]
 800e3be:	f7fd f84f 	bl	800b460 <lv_draw_add_task>
 800e3c2:	f8c7 0088 	str.w	r0, [r7, #136]	@ 0x88
        lv_draw_border_dsc_t * outline_dsc = lv_malloc(sizeof(lv_draw_border_dsc_t));
 800e3c6:	202c      	movs	r0, #44	@ 0x2c
 800e3c8:	f017 fcfe 	bl	8025dc8 <lv_malloc>
 800e3cc:	66b8      	str	r0, [r7, #104]	@ 0x68
        t->draw_dsc = outline_dsc;
 800e3ce:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800e3d2:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 800e3d4:	64da      	str	r2, [r3, #76]	@ 0x4c
        lv_area_increase(&t->_real_area, dsc->outline_width, dsc->outline_width);
 800e3d6:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800e3da:	f103 0018 	add.w	r0, r3, #24
 800e3de:	68bb      	ldr	r3, [r7, #8]
 800e3e0:	6d19      	ldr	r1, [r3, #80]	@ 0x50
 800e3e2:	68bb      	ldr	r3, [r7, #8]
 800e3e4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800e3e6:	461a      	mov	r2, r3
 800e3e8:	f013 fa66 	bl	80218b8 <lv_area_increase>
        lv_area_increase(&t->_real_area, dsc->outline_pad, dsc->outline_pad);
 800e3ec:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800e3f0:	f103 0018 	add.w	r0, r3, #24
 800e3f4:	68bb      	ldr	r3, [r7, #8]
 800e3f6:	6d59      	ldr	r1, [r3, #84]	@ 0x54
 800e3f8:	68bb      	ldr	r3, [r7, #8]
 800e3fa:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800e3fc:	461a      	mov	r2, r3
 800e3fe:	f013 fa5b 	bl	80218b8 <lv_area_increase>
        outline_dsc->base = dsc->base;
 800e402:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 800e404:	68bb      	ldr	r3, [r7, #8]
 800e406:	4614      	mov	r4, r2
 800e408:	461d      	mov	r5, r3
 800e40a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800e40c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800e40e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 800e412:	e884 0007 	stmia.w	r4, {r0, r1, r2}
        outline_dsc->base.dsc_size = sizeof(lv_draw_border_dsc_t);
 800e416:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800e418:	222c      	movs	r2, #44	@ 0x2c
 800e41a:	615a      	str	r2, [r3, #20]
        outline_dsc->radius = dsc->radius == LV_RADIUS_CIRCLE ? LV_RADIUS_CIRCLE : dsc->radius + dsc->outline_width +
 800e41c:	68bb      	ldr	r3, [r7, #8]
 800e41e:	69db      	ldr	r3, [r3, #28]
 800e420:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 800e424:	4293      	cmp	r3, r2
 800e426:	d008      	beq.n	800e43a <lv_draw_rect+0x6c6>
 800e428:	68bb      	ldr	r3, [r7, #8]
 800e42a:	69da      	ldr	r2, [r3, #28]
 800e42c:	68bb      	ldr	r3, [r7, #8]
 800e42e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800e430:	441a      	add	r2, r3
                              dsc->outline_pad;
 800e432:	68bb      	ldr	r3, [r7, #8]
 800e434:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
        outline_dsc->radius = dsc->radius == LV_RADIUS_CIRCLE ? LV_RADIUS_CIRCLE : dsc->radius + dsc->outline_width +
 800e436:	4413      	add	r3, r2
 800e438:	e001      	b.n	800e43e <lv_draw_rect+0x6ca>
 800e43a:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 800e43e:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 800e440:	61d3      	str	r3, [r2, #28]
        outline_dsc->color = dsc->outline_color;
 800e442:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800e444:	68ba      	ldr	r2, [r7, #8]
 800e446:	3320      	adds	r3, #32
 800e448:	324a      	adds	r2, #74	@ 0x4a
 800e44a:	8811      	ldrh	r1, [r2, #0]
 800e44c:	7892      	ldrb	r2, [r2, #2]
 800e44e:	8019      	strh	r1, [r3, #0]
 800e450:	709a      	strb	r2, [r3, #2]
        outline_dsc->opa = dsc->outline_opa;
 800e452:	68bb      	ldr	r3, [r7, #8]
 800e454:	f893 2058 	ldrb.w	r2, [r3, #88]	@ 0x58
 800e458:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800e45a:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
        outline_dsc->width = dsc->outline_width;
 800e45e:	68bb      	ldr	r3, [r7, #8]
 800e460:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 800e462:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 800e464:	625a      	str	r2, [r3, #36]	@ 0x24
        outline_dsc->side = LV_BORDER_SIDE_FULL;
 800e466:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 800e468:	f892 3029 	ldrb.w	r3, [r2, #41]	@ 0x29
 800e46c:	210f      	movs	r1, #15
 800e46e:	f361 0304 	bfi	r3, r1, #0, #5
 800e472:	f882 3029 	strb.w	r3, [r2, #41]	@ 0x29
        t->type = LV_DRAW_TASK_TYPE_BORDER;
 800e476:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 800e47a:	2201      	movs	r2, #1
 800e47c:	711a      	strb	r2, [r3, #4]
        lv_draw_finalize_task_creation(layer, t);
 800e47e:	f8d7 1088 	ldr.w	r1, [r7, #136]	@ 0x88
 800e482:	68f8      	ldr	r0, [r7, #12]
 800e484:	f7fd f82c 	bl	800b4e0 <lv_draw_finalize_task_creation>
    }

    LV_ASSERT_MEM_INTEGRITY();

    LV_PROFILER_END;
}
 800e488:	bf00      	nop
 800e48a:	3798      	adds	r7, #152	@ 0x98
 800e48c:	46bd      	mov	sp, r7
 800e48e:	bdb0      	pop	{r4, r5, r7, pc}

0800e490 <lv_memzero>:
{
 800e490:	b580      	push	{r7, lr}
 800e492:	b082      	sub	sp, #8
 800e494:	af00      	add	r7, sp, #0
 800e496:	6078      	str	r0, [r7, #4]
 800e498:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 800e49a:	683a      	ldr	r2, [r7, #0]
 800e49c:	2100      	movs	r1, #0
 800e49e:	6878      	ldr	r0, [r7, #4]
 800e4a0:	f016 fcbf 	bl	8024e22 <lv_memset>
}
 800e4a4:	bf00      	nop
 800e4a6:	3708      	adds	r7, #8
 800e4a8:	46bd      	mov	sp, r7
 800e4aa:	bd80      	pop	{r7, pc}

0800e4ac <lv_draw_buf_has_flag>:
 * @return LV_RESULT_OK: premultiply success
 */
lv_result_t lv_draw_buf_premultiply(lv_draw_buf_t * draw_buf);

static inline bool lv_draw_buf_has_flag(lv_draw_buf_t * draw_buf, lv_image_flags_t flag)
{
 800e4ac:	b480      	push	{r7}
 800e4ae:	b083      	sub	sp, #12
 800e4b0:	af00      	add	r7, sp, #0
 800e4b2:	6078      	str	r0, [r7, #4]
 800e4b4:	460b      	mov	r3, r1
 800e4b6:	807b      	strh	r3, [r7, #2]
    return draw_buf->header.flags & flag;
 800e4b8:	687b      	ldr	r3, [r7, #4]
 800e4ba:	885a      	ldrh	r2, [r3, #2]
 800e4bc:	887b      	ldrh	r3, [r7, #2]
 800e4be:	4013      	ands	r3, r2
 800e4c0:	b29b      	uxth	r3, r3
 800e4c2:	2b00      	cmp	r3, #0
 800e4c4:	bf14      	ite	ne
 800e4c6:	2301      	movne	r3, #1
 800e4c8:	2300      	moveq	r3, #0
 800e4ca:	b2db      	uxtb	r3, r3
}
 800e4cc:	4618      	mov	r0, r3
 800e4ce:	370c      	adds	r7, #12
 800e4d0:	46bd      	mov	sp, r7
 800e4d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e4d6:	4770      	bx	lr

0800e4d8 <_lv_image_decoder_init>:

/**
 * Initialize the image decoder module
 */
void _lv_image_decoder_init(void)
{
 800e4d8:	b580      	push	{r7, lr}
 800e4da:	af00      	add	r7, sp, #0
    _lv_ll_init(img_decoder_ll_p, sizeof(lv_image_decoder_t));
 800e4dc:	2118      	movs	r1, #24
 800e4de:	4802      	ldr	r0, [pc, #8]	@ (800e4e8 <_lv_image_decoder_init+0x10>)
 800e4e0:	f014 fd97 	bl	8023012 <_lv_ll_init>
        .compare_cb = (lv_cache_compare_cb_t)image_decoder_header_cache_compare_cb,
        .create_cb = NULL,
        .free_cb = (lv_cache_free_cb_t)image_decoder_header_cache_free_cb
    });
#endif
}
 800e4e4:	bf00      	nop
 800e4e6:	bd80      	pop	{r7, pc}
 800e4e8:	20000184 	.word	0x20000184

0800e4ec <lv_image_decoder_get_info>:
#endif
    _lv_ll_clear(img_decoder_ll_p);
}

lv_result_t lv_image_decoder_get_info(const void * src, lv_image_header_t * header)
{
 800e4ec:	b580      	push	{r7, lr}
 800e4ee:	b084      	sub	sp, #16
 800e4f0:	af00      	add	r7, sp, #0
 800e4f2:	6078      	str	r0, [r7, #4]
 800e4f4:	6039      	str	r1, [r7, #0]
    lv_image_decoder_t * decoder = image_decoder_get_info(src, header);
 800e4f6:	6839      	ldr	r1, [r7, #0]
 800e4f8:	6878      	ldr	r0, [r7, #4]
 800e4fa:	f000 f969 	bl	800e7d0 <image_decoder_get_info>
 800e4fe:	60f8      	str	r0, [r7, #12]
    if(decoder == NULL) return LV_RESULT_INVALID;
 800e500:	68fb      	ldr	r3, [r7, #12]
 800e502:	2b00      	cmp	r3, #0
 800e504:	d101      	bne.n	800e50a <lv_image_decoder_get_info+0x1e>
 800e506:	2300      	movs	r3, #0
 800e508:	e000      	b.n	800e50c <lv_image_decoder_get_info+0x20>

    return LV_RESULT_OK;
 800e50a:	2301      	movs	r3, #1
}
 800e50c:	4618      	mov	r0, r3
 800e50e:	3710      	adds	r7, #16
 800e510:	46bd      	mov	sp, r7
 800e512:	bd80      	pop	{r7, pc}

0800e514 <lv_image_decoder_open>:

lv_result_t lv_image_decoder_open(lv_image_decoder_dsc_t * dsc, const void * src, const lv_image_decoder_args_t * args)
{
 800e514:	b580      	push	{r7, lr}
 800e516:	b086      	sub	sp, #24
 800e518:	af00      	add	r7, sp, #0
 800e51a:	60f8      	str	r0, [r7, #12]
 800e51c:	60b9      	str	r1, [r7, #8]
 800e51e:	607a      	str	r2, [r7, #4]
    lv_memzero(dsc, sizeof(lv_image_decoder_dsc_t));
 800e520:	213c      	movs	r1, #60	@ 0x3c
 800e522:	68f8      	ldr	r0, [r7, #12]
 800e524:	f7ff ffb4 	bl	800e490 <lv_memzero>

    if(src == NULL) return LV_RESULT_INVALID;
 800e528:	68bb      	ldr	r3, [r7, #8]
 800e52a:	2b00      	cmp	r3, #0
 800e52c:	d101      	bne.n	800e532 <lv_image_decoder_open+0x1e>
 800e52e:	2300      	movs	r3, #0
 800e530:	e02f      	b.n	800e592 <lv_image_decoder_open+0x7e>
    dsc->src = src;
 800e532:	68fb      	ldr	r3, [r7, #12]
 800e534:	68ba      	ldr	r2, [r7, #8]
 800e536:	609a      	str	r2, [r3, #8]
    dsc->src_type = lv_image_src_get_type(src);
 800e538:	68b8      	ldr	r0, [r7, #8]
 800e53a:	f7fe f8fb 	bl	800c734 <lv_image_src_get_type>
 800e53e:	4603      	mov	r3, r0
 800e540:	461a      	mov	r2, r3
 800e542:	68fb      	ldr	r3, [r7, #12]
 800e544:	731a      	strb	r2, [r3, #12]
        if(try_cache(dsc) == LV_RESULT_OK) return LV_RESULT_OK;
    }
#endif

    /*Find the decoder that can open the image source, and get the header info in the same time.*/
    dsc->decoder = image_decoder_get_info(src, &dsc->header);
 800e546:	68fb      	ldr	r3, [r7, #12]
 800e548:	3310      	adds	r3, #16
 800e54a:	4619      	mov	r1, r3
 800e54c:	68b8      	ldr	r0, [r7, #8]
 800e54e:	f000 f93f 	bl	800e7d0 <image_decoder_get_info>
 800e552:	4602      	mov	r2, r0
 800e554:	68fb      	ldr	r3, [r7, #12]
 800e556:	601a      	str	r2, [r3, #0]
    if(dsc->decoder == NULL) return LV_RESULT_INVALID;
 800e558:	68fb      	ldr	r3, [r7, #12]
 800e55a:	681b      	ldr	r3, [r3, #0]
 800e55c:	2b00      	cmp	r3, #0
 800e55e:	d101      	bne.n	800e564 <lv_image_decoder_open+0x50>
 800e560:	2300      	movs	r3, #0
 800e562:	e016      	b.n	800e592 <lv_image_decoder_open+0x7e>

    /*Make a copy of args*/
    dsc->args = args ? *args : (lv_image_decoder_args_t) {
 800e564:	687b      	ldr	r3, [r7, #4]
 800e566:	2b00      	cmp	r3, #0
 800e568:	d005      	beq.n	800e576 <lv_image_decoder_open+0x62>
 800e56a:	68fb      	ldr	r3, [r7, #12]
 800e56c:	687a      	ldr	r2, [r7, #4]
 800e56e:	3304      	adds	r3, #4
 800e570:	6810      	ldr	r0, [r2, #0]
 800e572:	6018      	str	r0, [r3, #0]
 800e574:	e002      	b.n	800e57c <lv_image_decoder_open+0x68>
 800e576:	68fb      	ldr	r3, [r7, #12]
 800e578:	2200      	movs	r2, #0
 800e57a:	605a      	str	r2, [r3, #4]
    /*
     * We assume that if a decoder can get the info, it can open the image.
     * If decoder open failed, free the source and return error.
     * If decoder open succeed, add the image to cache if enabled.
     * */
    lv_result_t res = dsc->decoder->open_cb(dsc->decoder, dsc);
 800e57c:	68fb      	ldr	r3, [r7, #12]
 800e57e:	681b      	ldr	r3, [r3, #0]
 800e580:	685b      	ldr	r3, [r3, #4]
 800e582:	68fa      	ldr	r2, [r7, #12]
 800e584:	6812      	ldr	r2, [r2, #0]
 800e586:	68f9      	ldr	r1, [r7, #12]
 800e588:	4610      	mov	r0, r2
 800e58a:	4798      	blx	r3
 800e58c:	4603      	mov	r3, r0
 800e58e:	75fb      	strb	r3, [r7, #23]

    return res;
 800e590:	7dfb      	ldrb	r3, [r7, #23]
}
 800e592:	4618      	mov	r0, r3
 800e594:	3718      	adds	r7, #24
 800e596:	46bd      	mov	sp, r7
 800e598:	bd80      	pop	{r7, pc}

0800e59a <lv_image_decoder_get_area>:

lv_result_t lv_image_decoder_get_area(lv_image_decoder_dsc_t * dsc, const lv_area_t * full_area,
                                      lv_area_t * decoded_area)
{
 800e59a:	b590      	push	{r4, r7, lr}
 800e59c:	b087      	sub	sp, #28
 800e59e:	af00      	add	r7, sp, #0
 800e5a0:	60f8      	str	r0, [r7, #12]
 800e5a2:	60b9      	str	r1, [r7, #8]
 800e5a4:	607a      	str	r2, [r7, #4]
    lv_result_t res = LV_RESULT_INVALID;
 800e5a6:	2300      	movs	r3, #0
 800e5a8:	75fb      	strb	r3, [r7, #23]
    if(dsc->decoder->get_area_cb) res = dsc->decoder->get_area_cb(dsc->decoder, dsc, full_area, decoded_area);
 800e5aa:	68fb      	ldr	r3, [r7, #12]
 800e5ac:	681b      	ldr	r3, [r3, #0]
 800e5ae:	689b      	ldr	r3, [r3, #8]
 800e5b0:	2b00      	cmp	r3, #0
 800e5b2:	d00a      	beq.n	800e5ca <lv_image_decoder_get_area+0x30>
 800e5b4:	68fb      	ldr	r3, [r7, #12]
 800e5b6:	681b      	ldr	r3, [r3, #0]
 800e5b8:	689c      	ldr	r4, [r3, #8]
 800e5ba:	68fb      	ldr	r3, [r7, #12]
 800e5bc:	6818      	ldr	r0, [r3, #0]
 800e5be:	687b      	ldr	r3, [r7, #4]
 800e5c0:	68ba      	ldr	r2, [r7, #8]
 800e5c2:	68f9      	ldr	r1, [r7, #12]
 800e5c4:	47a0      	blx	r4
 800e5c6:	4603      	mov	r3, r0
 800e5c8:	75fb      	strb	r3, [r7, #23]

    return res;
 800e5ca:	7dfb      	ldrb	r3, [r7, #23]
}
 800e5cc:	4618      	mov	r0, r3
 800e5ce:	371c      	adds	r7, #28
 800e5d0:	46bd      	mov	sp, r7
 800e5d2:	bd90      	pop	{r4, r7, pc}

0800e5d4 <lv_image_decoder_close>:

void lv_image_decoder_close(lv_image_decoder_dsc_t * dsc)
{
 800e5d4:	b580      	push	{r7, lr}
 800e5d6:	b082      	sub	sp, #8
 800e5d8:	af00      	add	r7, sp, #0
 800e5da:	6078      	str	r0, [r7, #4]
    if(dsc->decoder) {
 800e5dc:	687b      	ldr	r3, [r7, #4]
 800e5de:	681b      	ldr	r3, [r3, #0]
 800e5e0:	2b00      	cmp	r3, #0
 800e5e2:	d00c      	beq.n	800e5fe <lv_image_decoder_close+0x2a>
        if(dsc->decoder->close_cb) dsc->decoder->close_cb(dsc->decoder, dsc);
 800e5e4:	687b      	ldr	r3, [r7, #4]
 800e5e6:	681b      	ldr	r3, [r3, #0]
 800e5e8:	68db      	ldr	r3, [r3, #12]
 800e5ea:	2b00      	cmp	r3, #0
 800e5ec:	d007      	beq.n	800e5fe <lv_image_decoder_close+0x2a>
 800e5ee:	687b      	ldr	r3, [r7, #4]
 800e5f0:	681b      	ldr	r3, [r3, #0]
 800e5f2:	68db      	ldr	r3, [r3, #12]
 800e5f4:	687a      	ldr	r2, [r7, #4]
 800e5f6:	6812      	ldr	r2, [r2, #0]
 800e5f8:	6879      	ldr	r1, [r7, #4]
 800e5fa:	4610      	mov	r0, r2
 800e5fc:	4798      	blx	r3
    }
}
 800e5fe:	bf00      	nop
 800e600:	3708      	adds	r7, #8
 800e602:	46bd      	mov	sp, r7
 800e604:	bd80      	pop	{r7, pc}
	...

0800e608 <lv_image_decoder_create>:
/**
 * Create a new image decoder
 * @return pointer to the new image decoder
 */
lv_image_decoder_t * lv_image_decoder_create(void)
{
 800e608:	b580      	push	{r7, lr}
 800e60a:	b082      	sub	sp, #8
 800e60c:	af00      	add	r7, sp, #0
    lv_image_decoder_t * decoder;
    decoder = _lv_ll_ins_head(img_decoder_ll_p);
 800e60e:	480b      	ldr	r0, [pc, #44]	@ (800e63c <lv_image_decoder_create+0x34>)
 800e610:	f014 fd18 	bl	8023044 <_lv_ll_ins_head>
 800e614:	6078      	str	r0, [r7, #4]
    LV_ASSERT_MALLOC(decoder);
 800e616:	687b      	ldr	r3, [r7, #4]
 800e618:	2b00      	cmp	r3, #0
 800e61a:	d101      	bne.n	800e620 <lv_image_decoder_create+0x18>
 800e61c:	bf00      	nop
 800e61e:	e7fd      	b.n	800e61c <lv_image_decoder_create+0x14>
    if(decoder == NULL) return NULL;
 800e620:	687b      	ldr	r3, [r7, #4]
 800e622:	2b00      	cmp	r3, #0
 800e624:	d101      	bne.n	800e62a <lv_image_decoder_create+0x22>
 800e626:	2300      	movs	r3, #0
 800e628:	e004      	b.n	800e634 <lv_image_decoder_create+0x2c>

    lv_memzero(decoder, sizeof(lv_image_decoder_t));
 800e62a:	2118      	movs	r1, #24
 800e62c:	6878      	ldr	r0, [r7, #4]
 800e62e:	f7ff ff2f 	bl	800e490 <lv_memzero>

    return decoder;
 800e632:	687b      	ldr	r3, [r7, #4]
}
 800e634:	4618      	mov	r0, r3
 800e636:	3708      	adds	r7, #8
 800e638:	46bd      	mov	sp, r7
 800e63a:	bd80      	pop	{r7, pc}
 800e63c:	20000184 	.word	0x20000184

0800e640 <lv_image_decoder_set_info_cb>:
    else
        return _lv_ll_get_next(img_decoder_ll_p, decoder);
}

void lv_image_decoder_set_info_cb(lv_image_decoder_t * decoder, lv_image_decoder_info_f_t info_cb)
{
 800e640:	b480      	push	{r7}
 800e642:	b083      	sub	sp, #12
 800e644:	af00      	add	r7, sp, #0
 800e646:	6078      	str	r0, [r7, #4]
 800e648:	6039      	str	r1, [r7, #0]
    decoder->info_cb = info_cb;
 800e64a:	687b      	ldr	r3, [r7, #4]
 800e64c:	683a      	ldr	r2, [r7, #0]
 800e64e:	601a      	str	r2, [r3, #0]
}
 800e650:	bf00      	nop
 800e652:	370c      	adds	r7, #12
 800e654:	46bd      	mov	sp, r7
 800e656:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e65a:	4770      	bx	lr

0800e65c <lv_image_decoder_set_open_cb>:

void lv_image_decoder_set_open_cb(lv_image_decoder_t * decoder, lv_image_decoder_open_f_t open_cb)
{
 800e65c:	b480      	push	{r7}
 800e65e:	b083      	sub	sp, #12
 800e660:	af00      	add	r7, sp, #0
 800e662:	6078      	str	r0, [r7, #4]
 800e664:	6039      	str	r1, [r7, #0]
    decoder->open_cb = open_cb;
 800e666:	687b      	ldr	r3, [r7, #4]
 800e668:	683a      	ldr	r2, [r7, #0]
 800e66a:	605a      	str	r2, [r3, #4]
}
 800e66c:	bf00      	nop
 800e66e:	370c      	adds	r7, #12
 800e670:	46bd      	mov	sp, r7
 800e672:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e676:	4770      	bx	lr

0800e678 <lv_image_decoder_set_get_area_cb>:

void lv_image_decoder_set_get_area_cb(lv_image_decoder_t * decoder, lv_image_decoder_get_area_cb_t get_area_cb)
{
 800e678:	b480      	push	{r7}
 800e67a:	b083      	sub	sp, #12
 800e67c:	af00      	add	r7, sp, #0
 800e67e:	6078      	str	r0, [r7, #4]
 800e680:	6039      	str	r1, [r7, #0]
    decoder->get_area_cb = get_area_cb;
 800e682:	687b      	ldr	r3, [r7, #4]
 800e684:	683a      	ldr	r2, [r7, #0]
 800e686:	609a      	str	r2, [r3, #8]
}
 800e688:	bf00      	nop
 800e68a:	370c      	adds	r7, #12
 800e68c:	46bd      	mov	sp, r7
 800e68e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e692:	4770      	bx	lr

0800e694 <lv_image_decoder_set_close_cb>:

void lv_image_decoder_set_close_cb(lv_image_decoder_t * decoder, lv_image_decoder_close_f_t close_cb)
{
 800e694:	b480      	push	{r7}
 800e696:	b083      	sub	sp, #12
 800e698:	af00      	add	r7, sp, #0
 800e69a:	6078      	str	r0, [r7, #4]
 800e69c:	6039      	str	r1, [r7, #0]
    decoder->close_cb = close_cb;
 800e69e:	687b      	ldr	r3, [r7, #4]
 800e6a0:	683a      	ldr	r2, [r7, #0]
 800e6a2:	60da      	str	r2, [r3, #12]
}
 800e6a4:	bf00      	nop
 800e6a6:	370c      	adds	r7, #12
 800e6a8:	46bd      	mov	sp, r7
 800e6aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e6ae:	4770      	bx	lr

0800e6b0 <lv_image_decoder_set_cache_free_cb>:

void lv_image_decoder_set_cache_free_cb(lv_image_decoder_t * decoder, lv_cache_free_cb_t cache_free_cb)
{
 800e6b0:	b480      	push	{r7}
 800e6b2:	b083      	sub	sp, #12
 800e6b4:	af00      	add	r7, sp, #0
 800e6b6:	6078      	str	r0, [r7, #4]
 800e6b8:	6039      	str	r1, [r7, #0]
    decoder->cache_free_cb = cache_free_cb;
 800e6ba:	687b      	ldr	r3, [r7, #4]
 800e6bc:	683a      	ldr	r2, [r7, #0]
 800e6be:	611a      	str	r2, [r3, #16]
}
 800e6c0:	bf00      	nop
 800e6c2:	370c      	adds	r7, #12
 800e6c4:	46bd      	mov	sp, r7
 800e6c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e6ca:	4770      	bx	lr

0800e6cc <lv_image_decoder_post_process>:
    return cache_entry;
}
#endif

lv_draw_buf_t * lv_image_decoder_post_process(lv_image_decoder_dsc_t * dsc, lv_draw_buf_t * decoded)
{
 800e6cc:	b580      	push	{r7, lr}
 800e6ce:	b086      	sub	sp, #24
 800e6d0:	af00      	add	r7, sp, #0
 800e6d2:	6078      	str	r0, [r7, #4]
 800e6d4:	6039      	str	r1, [r7, #0]
    if(decoded == NULL) return NULL; /*No need to adjust*/
 800e6d6:	683b      	ldr	r3, [r7, #0]
 800e6d8:	2b00      	cmp	r3, #0
 800e6da:	d101      	bne.n	800e6e0 <lv_image_decoder_post_process+0x14>
 800e6dc:	2300      	movs	r3, #0
 800e6de:	e072      	b.n	800e7c6 <lv_image_decoder_post_process+0xfa>

    lv_image_decoder_args_t * args = &dsc->args;
 800e6e0:	687b      	ldr	r3, [r7, #4]
 800e6e2:	3304      	adds	r3, #4
 800e6e4:	617b      	str	r3, [r7, #20]
    if(args->stride_align && decoded->header.cf != LV_COLOR_FORMAT_RGB565A8) {
 800e6e6:	697b      	ldr	r3, [r7, #20]
 800e6e8:	781b      	ldrb	r3, [r3, #0]
 800e6ea:	2b00      	cmp	r3, #0
 800e6ec:	d035      	beq.n	800e75a <lv_image_decoder_post_process+0x8e>
 800e6ee:	683b      	ldr	r3, [r7, #0]
 800e6f0:	785b      	ldrb	r3, [r3, #1]
 800e6f2:	2b14      	cmp	r3, #20
 800e6f4:	d031      	beq.n	800e75a <lv_image_decoder_post_process+0x8e>
        uint32_t stride_expect = lv_draw_buf_width_to_stride(decoded->header.w, decoded->header.cf);
 800e6f6:	683b      	ldr	r3, [r7, #0]
 800e6f8:	889b      	ldrh	r3, [r3, #4]
 800e6fa:	461a      	mov	r2, r3
 800e6fc:	683b      	ldr	r3, [r7, #0]
 800e6fe:	785b      	ldrb	r3, [r3, #1]
 800e700:	4619      	mov	r1, r3
 800e702:	4610      	mov	r0, r2
 800e704:	f7fd fa5e 	bl	800bbc4 <lv_draw_buf_width_to_stride>
 800e708:	6138      	str	r0, [r7, #16]
        if(decoded->header.stride != stride_expect) {
 800e70a:	683b      	ldr	r3, [r7, #0]
 800e70c:	891b      	ldrh	r3, [r3, #8]
 800e70e:	461a      	mov	r2, r3
 800e710:	693b      	ldr	r3, [r7, #16]
 800e712:	4293      	cmp	r3, r2
 800e714:	d021      	beq.n	800e75a <lv_image_decoder_post_process+0x8e>
            LV_LOG_TRACE("Stride mismatch");
            lv_result_t res = lv_draw_buf_adjust_stride(decoded, stride_expect);
 800e716:	6939      	ldr	r1, [r7, #16]
 800e718:	6838      	ldr	r0, [r7, #0]
 800e71a:	f7fd fc95 	bl	800c048 <lv_draw_buf_adjust_stride>
 800e71e:	4603      	mov	r3, r0
 800e720:	73fb      	strb	r3, [r7, #15]
            if(res != LV_RESULT_OK) {
 800e722:	7bfb      	ldrb	r3, [r7, #15]
 800e724:	2b01      	cmp	r3, #1
 800e726:	d018      	beq.n	800e75a <lv_image_decoder_post_process+0x8e>
                lv_draw_buf_t * aligned = lv_draw_buf_create(decoded->header.w, decoded->header.h, decoded->header.cf, stride_expect);
 800e728:	683b      	ldr	r3, [r7, #0]
 800e72a:	889b      	ldrh	r3, [r3, #4]
 800e72c:	4618      	mov	r0, r3
 800e72e:	683b      	ldr	r3, [r7, #0]
 800e730:	88db      	ldrh	r3, [r3, #6]
 800e732:	4619      	mov	r1, r3
 800e734:	683b      	ldr	r3, [r7, #0]
 800e736:	785a      	ldrb	r2, [r3, #1]
 800e738:	693b      	ldr	r3, [r7, #16]
 800e73a:	f7fd fb65 	bl	800be08 <lv_draw_buf_create>
 800e73e:	60b8      	str	r0, [r7, #8]
                if(aligned == NULL) {
 800e740:	68bb      	ldr	r3, [r7, #8]
 800e742:	2b00      	cmp	r3, #0
 800e744:	d101      	bne.n	800e74a <lv_image_decoder_post_process+0x7e>
                    LV_LOG_ERROR("No memory for Stride adjust.");
                    return NULL;
 800e746:	2300      	movs	r3, #0
 800e748:	e03d      	b.n	800e7c6 <lv_image_decoder_post_process+0xfa>
                }

                lv_draw_buf_copy(aligned, NULL, decoded, NULL);
 800e74a:	2300      	movs	r3, #0
 800e74c:	683a      	ldr	r2, [r7, #0]
 800e74e:	2100      	movs	r1, #0
 800e750:	68b8      	ldr	r0, [r7, #8]
 800e752:	f7fd fad6 	bl	800bd02 <lv_draw_buf_copy>
                decoded = aligned;
 800e756:	68bb      	ldr	r3, [r7, #8]
 800e758:	603b      	str	r3, [r7, #0]
            }
        }
    }

    /*Premultiply alpha channel*/
    if(args->premultiply
 800e75a:	697b      	ldr	r3, [r7, #20]
 800e75c:	785b      	ldrb	r3, [r3, #1]
 800e75e:	2b00      	cmp	r3, #0
 800e760:	d030      	beq.n	800e7c4 <lv_image_decoder_post_process+0xf8>
       && !LV_COLOR_FORMAT_IS_ALPHA_ONLY(decoded->header.cf)
 800e762:	683b      	ldr	r3, [r7, #0]
 800e764:	785b      	ldrb	r3, [r3, #1]
 800e766:	2b0a      	cmp	r3, #10
 800e768:	d903      	bls.n	800e772 <lv_image_decoder_post_process+0xa6>
 800e76a:	683b      	ldr	r3, [r7, #0]
 800e76c:	785b      	ldrb	r3, [r3, #1]
 800e76e:	2b0e      	cmp	r3, #14
 800e770:	d928      	bls.n	800e7c4 <lv_image_decoder_post_process+0xf8>
       && lv_color_format_has_alpha(decoded->header.cf)
 800e772:	683b      	ldr	r3, [r7, #0]
 800e774:	785b      	ldrb	r3, [r3, #1]
 800e776:	4618      	mov	r0, r3
 800e778:	f013 ff06 	bl	8022588 <lv_color_format_has_alpha>
 800e77c:	4603      	mov	r3, r0
 800e77e:	2b00      	cmp	r3, #0
 800e780:	d020      	beq.n	800e7c4 <lv_image_decoder_post_process+0xf8>
       && !lv_draw_buf_has_flag(decoded, LV_IMAGE_FLAGS_PREMULTIPLIED) /*Hasn't done yet*/
 800e782:	2101      	movs	r1, #1
 800e784:	6838      	ldr	r0, [r7, #0]
 800e786:	f7ff fe91 	bl	800e4ac <lv_draw_buf_has_flag>
 800e78a:	4603      	mov	r3, r0
 800e78c:	f083 0301 	eor.w	r3, r3, #1
 800e790:	b2db      	uxtb	r3, r3
 800e792:	2b00      	cmp	r3, #0
 800e794:	d016      	beq.n	800e7c4 <lv_image_decoder_post_process+0xf8>
      ) {
        LV_LOG_TRACE("Alpha premultiply.");
        if(lv_draw_buf_has_flag(decoded, LV_IMAGE_FLAGS_MODIFIABLE)) {
 800e796:	2120      	movs	r1, #32
 800e798:	6838      	ldr	r0, [r7, #0]
 800e79a:	f7ff fe87 	bl	800e4ac <lv_draw_buf_has_flag>
 800e79e:	4603      	mov	r3, r0
 800e7a0:	2b00      	cmp	r3, #0
 800e7a2:	d003      	beq.n	800e7ac <lv_image_decoder_post_process+0xe0>
            /*Do it directly*/
            lv_draw_buf_premultiply(decoded);
 800e7a4:	6838      	ldr	r0, [r7, #0]
 800e7a6:	f7fd fd27 	bl	800c1f8 <lv_draw_buf_premultiply>
 800e7aa:	e00b      	b.n	800e7c4 <lv_image_decoder_post_process+0xf8>
        }
        else {
            decoded = lv_draw_buf_dup(decoded);
 800e7ac:	6838      	ldr	r0, [r7, #0]
 800e7ae:	f7fd fb87 	bl	800bec0 <lv_draw_buf_dup>
 800e7b2:	6038      	str	r0, [r7, #0]
            if(decoded == NULL) {
 800e7b4:	683b      	ldr	r3, [r7, #0]
 800e7b6:	2b00      	cmp	r3, #0
 800e7b8:	d101      	bne.n	800e7be <lv_image_decoder_post_process+0xf2>
                LV_LOG_ERROR("No memory for premulitplying.");
                return NULL;
 800e7ba:	2300      	movs	r3, #0
 800e7bc:	e003      	b.n	800e7c6 <lv_image_decoder_post_process+0xfa>
            }

            lv_draw_buf_premultiply(decoded);
 800e7be:	6838      	ldr	r0, [r7, #0]
 800e7c0:	f7fd fd1a 	bl	800c1f8 <lv_draw_buf_premultiply>
        }
    }

    return decoded;
 800e7c4:	683b      	ldr	r3, [r7, #0]
}
 800e7c6:	4618      	mov	r0, r3
 800e7c8:	3718      	adds	r7, #24
 800e7ca:	46bd      	mov	sp, r7
 800e7cc:	bd80      	pop	{r7, pc}
	...

0800e7d0 <image_decoder_get_info>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static lv_image_decoder_t * image_decoder_get_info(const void * src, lv_image_header_t * header)
{
 800e7d0:	b580      	push	{r7, lr}
 800e7d2:	b086      	sub	sp, #24
 800e7d4:	af00      	add	r7, sp, #0
 800e7d6:	6078      	str	r0, [r7, #4]
 800e7d8:	6039      	str	r1, [r7, #0]
    lv_memzero(header, sizeof(lv_image_header_t));
 800e7da:	210c      	movs	r1, #12
 800e7dc:	6838      	ldr	r0, [r7, #0]
 800e7de:	f7ff fe57 	bl	800e490 <lv_memzero>

    if(src == NULL) return NULL;
 800e7e2:	687b      	ldr	r3, [r7, #4]
 800e7e4:	2b00      	cmp	r3, #0
 800e7e6:	d101      	bne.n	800e7ec <image_decoder_get_info+0x1c>
 800e7e8:	2300      	movs	r3, #0
 800e7ea:	e03e      	b.n	800e86a <image_decoder_get_info+0x9a>

    lv_image_src_t src_type = lv_image_src_get_type(src);
 800e7ec:	6878      	ldr	r0, [r7, #4]
 800e7ee:	f7fd ffa1 	bl	800c734 <lv_image_src_get_type>
 800e7f2:	4603      	mov	r3, r0
 800e7f4:	74fb      	strb	r3, [r7, #19]
    if(src_type == LV_IMAGE_SRC_VARIABLE) {
 800e7f6:	7cfb      	ldrb	r3, [r7, #19]
 800e7f8:	2b00      	cmp	r3, #0
 800e7fa:	d107      	bne.n	800e80c <image_decoder_get_info+0x3c>
        const lv_image_dsc_t * img_dsc = src;
 800e7fc:	687b      	ldr	r3, [r7, #4]
 800e7fe:	60fb      	str	r3, [r7, #12]
        if(img_dsc->data == NULL) return NULL;
 800e800:	68fb      	ldr	r3, [r7, #12]
 800e802:	691b      	ldr	r3, [r3, #16]
 800e804:	2b00      	cmp	r3, #0
 800e806:	d101      	bne.n	800e80c <image_decoder_get_info+0x3c>
 800e808:	2300      	movs	r3, #0
 800e80a:	e02e      	b.n	800e86a <image_decoder_get_info+0x9a>
            return decoder;
        }
    }
#endif

    _LV_LL_READ(img_decoder_ll_p, decoder) {
 800e80c:	4819      	ldr	r0, [pc, #100]	@ (800e874 <image_decoder_get_info+0xa4>)
 800e80e:	f014 fcde 	bl	80231ce <_lv_ll_get_head>
 800e812:	6178      	str	r0, [r7, #20]
 800e814:	e023      	b.n	800e85e <image_decoder_get_info+0x8e>
        /*Info and Open callbacks are required*/
        if(decoder->info_cb && decoder->open_cb) {
 800e816:	697b      	ldr	r3, [r7, #20]
 800e818:	681b      	ldr	r3, [r3, #0]
 800e81a:	2b00      	cmp	r3, #0
 800e81c:	d01a      	beq.n	800e854 <image_decoder_get_info+0x84>
 800e81e:	697b      	ldr	r3, [r7, #20]
 800e820:	685b      	ldr	r3, [r3, #4]
 800e822:	2b00      	cmp	r3, #0
 800e824:	d016      	beq.n	800e854 <image_decoder_get_info+0x84>
            lv_result_t res = decoder->info_cb(decoder, src, header);
 800e826:	697b      	ldr	r3, [r7, #20]
 800e828:	681b      	ldr	r3, [r3, #0]
 800e82a:	683a      	ldr	r2, [r7, #0]
 800e82c:	6879      	ldr	r1, [r7, #4]
 800e82e:	6978      	ldr	r0, [r7, #20]
 800e830:	4798      	blx	r3
 800e832:	4603      	mov	r3, r0
 800e834:	72fb      	strb	r3, [r7, #11]
            if(res == LV_RESULT_OK) {
 800e836:	7afb      	ldrb	r3, [r7, #11]
 800e838:	2b01      	cmp	r3, #1
 800e83a:	d10b      	bne.n	800e854 <image_decoder_get_info+0x84>
                if(header->stride == 0) {
 800e83c:	683b      	ldr	r3, [r7, #0]
 800e83e:	891b      	ldrh	r3, [r3, #8]
 800e840:	2b00      	cmp	r3, #0
 800e842:	d110      	bne.n	800e866 <image_decoder_get_info+0x96>
                    LV_LOG_INFO("Image decoder didn't set stride. Calculate it from width.");
                    header->stride = img_width_to_stride(header);
 800e844:	6838      	ldr	r0, [r7, #0]
 800e846:	f000 f817 	bl	800e878 <img_width_to_stride>
 800e84a:	4603      	mov	r3, r0
 800e84c:	b29a      	uxth	r2, r3
 800e84e:	683b      	ldr	r3, [r7, #0]
 800e850:	811a      	strh	r2, [r3, #8]
                }
                break;
 800e852:	e008      	b.n	800e866 <image_decoder_get_info+0x96>
    _LV_LL_READ(img_decoder_ll_p, decoder) {
 800e854:	6979      	ldr	r1, [r7, #20]
 800e856:	4807      	ldr	r0, [pc, #28]	@ (800e874 <image_decoder_get_info+0xa4>)
 800e858:	f014 fcdb 	bl	8023212 <_lv_ll_get_next>
 800e85c:	6178      	str	r0, [r7, #20]
 800e85e:	697b      	ldr	r3, [r7, #20]
 800e860:	2b00      	cmp	r3, #0
 800e862:	d1d8      	bne.n	800e816 <image_decoder_get_info+0x46>
 800e864:	e000      	b.n	800e868 <image_decoder_get_info+0x98>
                break;
 800e866:	bf00      	nop

        lv_cache_release(img_header_cache_p, entry, NULL);
    }
#endif

    return decoder;
 800e868:	697b      	ldr	r3, [r7, #20]
}
 800e86a:	4618      	mov	r0, r3
 800e86c:	3718      	adds	r7, #24
 800e86e:	46bd      	mov	sp, r7
 800e870:	bd80      	pop	{r7, pc}
 800e872:	bf00      	nop
 800e874:	20000184 	.word	0x20000184

0800e878 <img_width_to_stride>:

static uint32_t img_width_to_stride(lv_image_header_t * header)
{
 800e878:	b590      	push	{r4, r7, lr}
 800e87a:	b083      	sub	sp, #12
 800e87c:	af00      	add	r7, sp, #0
 800e87e:	6078      	str	r0, [r7, #4]
    if(header->cf == LV_COLOR_FORMAT_RGB565A8) {
 800e880:	687b      	ldr	r3, [r7, #4]
 800e882:	785b      	ldrb	r3, [r3, #1]
 800e884:	2b14      	cmp	r3, #20
 800e886:	d103      	bne.n	800e890 <img_width_to_stride+0x18>
        return header->w * 2;
 800e888:	687b      	ldr	r3, [r7, #4]
 800e88a:	889b      	ldrh	r3, [r3, #4]
 800e88c:	005b      	lsls	r3, r3, #1
 800e88e:	e00c      	b.n	800e8aa <img_width_to_stride+0x32>
    }
    else {
        return ((uint32_t)header->w * lv_color_format_get_bpp(header->cf) + 7) >> 3;
 800e890:	687b      	ldr	r3, [r7, #4]
 800e892:	889b      	ldrh	r3, [r3, #4]
 800e894:	461c      	mov	r4, r3
 800e896:	687b      	ldr	r3, [r7, #4]
 800e898:	785b      	ldrb	r3, [r3, #1]
 800e89a:	4618      	mov	r0, r3
 800e89c:	f013 fe34 	bl	8022508 <lv_color_format_get_bpp>
 800e8a0:	4603      	mov	r3, r0
 800e8a2:	fb04 f303 	mul.w	r3, r4, r3
 800e8a6:	3307      	adds	r3, #7
 800e8a8:	08db      	lsrs	r3, r3, #3
    }
}
 800e8aa:	4618      	mov	r0, r3
 800e8ac:	370c      	adds	r7, #12
 800e8ae:	46bd      	mov	sp, r7
 800e8b0:	bd90      	pop	{r4, r7, pc}

0800e8b2 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline int32_t lv_area_get_width(const lv_area_t * area_p)
{
 800e8b2:	b480      	push	{r7}
 800e8b4:	b083      	sub	sp, #12
 800e8b6:	af00      	add	r7, sp, #0
 800e8b8:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 800e8ba:	687b      	ldr	r3, [r7, #4]
 800e8bc:	689a      	ldr	r2, [r3, #8]
 800e8be:	687b      	ldr	r3, [r7, #4]
 800e8c0:	681b      	ldr	r3, [r3, #0]
 800e8c2:	1ad3      	subs	r3, r2, r3
 800e8c4:	3301      	adds	r3, #1
}
 800e8c6:	4618      	mov	r0, r3
 800e8c8:	370c      	adds	r7, #12
 800e8ca:	46bd      	mov	sp, r7
 800e8cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e8d0:	4770      	bx	lr

0800e8d2 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline int32_t lv_area_get_height(const lv_area_t * area_p)
{
 800e8d2:	b480      	push	{r7}
 800e8d4:	b083      	sub	sp, #12
 800e8d6:	af00      	add	r7, sp, #0
 800e8d8:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 800e8da:	687b      	ldr	r3, [r7, #4]
 800e8dc:	68da      	ldr	r2, [r3, #12]
 800e8de:	687b      	ldr	r3, [r7, #4]
 800e8e0:	685b      	ldr	r3, [r3, #4]
 800e8e2:	1ad3      	subs	r3, r2, r3
 800e8e4:	3301      	adds	r3, #1
}
 800e8e6:	4618      	mov	r0, r3
 800e8e8:	370c      	adds	r7, #12
 800e8ea:	46bd      	mov	sp, r7
 800e8ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e8f0:	4770      	bx	lr

0800e8f2 <lv_color_format_get_size>:
 * Get the pixel size of a color format in bytes
 * @param src_cf    a color format (`LV_COLOR_FORMAT_...`)
 * @return          the pixel size in bytes
 */
static inline uint8_t lv_color_format_get_size(lv_color_format_t cf)
{
 800e8f2:	b580      	push	{r7, lr}
 800e8f4:	b082      	sub	sp, #8
 800e8f6:	af00      	add	r7, sp, #0
 800e8f8:	4603      	mov	r3, r0
 800e8fa:	71fb      	strb	r3, [r7, #7]
    return (lv_color_format_get_bpp(cf) + 7) >> 3;
 800e8fc:	79fb      	ldrb	r3, [r7, #7]
 800e8fe:	4618      	mov	r0, r3
 800e900:	f013 fe02 	bl	8022508 <lv_color_format_get_bpp>
 800e904:	4603      	mov	r3, r0
 800e906:	3307      	adds	r3, #7
 800e908:	10db      	asrs	r3, r3, #3
 800e90a:	b2db      	uxtb	r3, r3
}
 800e90c:	4618      	mov	r0, r3
 800e90e:	3708      	adds	r7, #8
 800e910:	46bd      	mov	sp, r7
 800e912:	bd80      	pop	{r7, pc}

0800e914 <lv_draw_sw_blend>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_sw_blend(lv_draw_unit_t * draw_unit, const lv_draw_sw_blend_dsc_t * blend_dsc)
{
 800e914:	b580      	push	{r7, lr}
 800e916:	b09a      	sub	sp, #104	@ 0x68
 800e918:	af00      	add	r7, sp, #0
 800e91a:	6078      	str	r0, [r7, #4]
 800e91c:	6039      	str	r1, [r7, #0]
    /*Do not draw transparent things*/
    if(blend_dsc->opa <= LV_OPA_MIN) return;
 800e91e:	683b      	ldr	r3, [r7, #0]
 800e920:	7d1b      	ldrb	r3, [r3, #20]
 800e922:	2b02      	cmp	r3, #2
 800e924:	f240 8192 	bls.w	800ec4c <lv_draw_sw_blend+0x338>
    if(blend_dsc->mask_buf && blend_dsc->mask_res == LV_DRAW_SW_MASK_RES_TRANSP) return;
 800e928:	683b      	ldr	r3, [r7, #0]
 800e92a:	699b      	ldr	r3, [r3, #24]
 800e92c:	2b00      	cmp	r3, #0
 800e92e:	d004      	beq.n	800e93a <lv_draw_sw_blend+0x26>
 800e930:	683b      	ldr	r3, [r7, #0]
 800e932:	7f1b      	ldrb	r3, [r3, #28]
 800e934:	2b00      	cmp	r3, #0
 800e936:	f000 818b 	beq.w	800ec50 <lv_draw_sw_blend+0x33c>

    lv_area_t blend_area;
    if(!_lv_area_intersect(&blend_area, blend_dsc->blend_area, draw_unit->clip_area)) return;
 800e93a:	683b      	ldr	r3, [r7, #0]
 800e93c:	6819      	ldr	r1, [r3, #0]
 800e93e:	687b      	ldr	r3, [r7, #4]
 800e940:	689a      	ldr	r2, [r3, #8]
 800e942:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 800e946:	4618      	mov	r0, r3
 800e948:	f012 fffe 	bl	8021948 <_lv_area_intersect>
 800e94c:	4603      	mov	r3, r0
 800e94e:	f083 0301 	eor.w	r3, r3, #1
 800e952:	b2db      	uxtb	r3, r3
 800e954:	2b00      	cmp	r3, #0
 800e956:	f040 817d 	bne.w	800ec54 <lv_draw_sw_blend+0x340>

    LV_PROFILER_BEGIN;
    lv_layer_t * layer = draw_unit->target_layer;
 800e95a:	687b      	ldr	r3, [r7, #4]
 800e95c:	685b      	ldr	r3, [r3, #4]
 800e95e:	667b      	str	r3, [r7, #100]	@ 0x64
    uint32_t layer_stride_byte = lv_draw_buf_width_to_stride(lv_area_get_width(&layer->buf_area), layer->color_format);
 800e960:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800e962:	3304      	adds	r3, #4
 800e964:	4618      	mov	r0, r3
 800e966:	f7ff ffa4 	bl	800e8b2 <lv_area_get_width>
 800e96a:	4603      	mov	r3, r0
 800e96c:	461a      	mov	r2, r3
 800e96e:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800e970:	7d1b      	ldrb	r3, [r3, #20]
 800e972:	4619      	mov	r1, r3
 800e974:	4610      	mov	r0, r2
 800e976:	f7fd f925 	bl	800bbc4 <lv_draw_buf_width_to_stride>
 800e97a:	6638      	str	r0, [r7, #96]	@ 0x60

    if(blend_dsc->src_buf == NULL) {
 800e97c:	683b      	ldr	r3, [r7, #0]
 800e97e:	685b      	ldr	r3, [r3, #4]
 800e980:	2b00      	cmp	r3, #0
 800e982:	f040 8089 	bne.w	800ea98 <lv_draw_sw_blend+0x184>
        _lv_draw_sw_blend_fill_dsc_t fill_dsc;
        fill_dsc.dest_w = lv_area_get_width(&blend_area);
 800e986:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 800e98a:	4618      	mov	r0, r3
 800e98c:	f7ff ff91 	bl	800e8b2 <lv_area_get_width>
 800e990:	4603      	mov	r3, r0
 800e992:	633b      	str	r3, [r7, #48]	@ 0x30
        fill_dsc.dest_h = lv_area_get_height(&blend_area);
 800e994:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 800e998:	4618      	mov	r0, r3
 800e99a:	f7ff ff9a 	bl	800e8d2 <lv_area_get_height>
 800e99e:	4603      	mov	r3, r0
 800e9a0:	637b      	str	r3, [r7, #52]	@ 0x34
        fill_dsc.dest_stride = layer_stride_byte;
 800e9a2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800e9a4:	63bb      	str	r3, [r7, #56]	@ 0x38
        fill_dsc.opa = blend_dsc->opa;
 800e9a6:	683b      	ldr	r3, [r7, #0]
 800e9a8:	7d1b      	ldrb	r3, [r3, #20]
 800e9aa:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
        fill_dsc.color = blend_dsc->color;
 800e9ae:	683a      	ldr	r2, [r7, #0]
 800e9b0:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 800e9b4:	3215      	adds	r2, #21
 800e9b6:	8811      	ldrh	r1, [r2, #0]
 800e9b8:	7892      	ldrb	r2, [r2, #2]
 800e9ba:	8019      	strh	r1, [r3, #0]
 800e9bc:	709a      	strb	r2, [r3, #2]

        if(blend_dsc->mask_buf == NULL) fill_dsc.mask_buf = NULL;
 800e9be:	683b      	ldr	r3, [r7, #0]
 800e9c0:	699b      	ldr	r3, [r3, #24]
 800e9c2:	2b00      	cmp	r3, #0
 800e9c4:	d102      	bne.n	800e9cc <lv_draw_sw_blend+0xb8>
 800e9c6:	2300      	movs	r3, #0
 800e9c8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800e9ca:	e009      	b.n	800e9e0 <lv_draw_sw_blend+0xcc>
        else if(blend_dsc->mask_res == LV_DRAW_SW_MASK_RES_FULL_COVER) fill_dsc.mask_buf = NULL;
 800e9cc:	683b      	ldr	r3, [r7, #0]
 800e9ce:	7f1b      	ldrb	r3, [r3, #28]
 800e9d0:	2b01      	cmp	r3, #1
 800e9d2:	d102      	bne.n	800e9da <lv_draw_sw_blend+0xc6>
 800e9d4:	2300      	movs	r3, #0
 800e9d6:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800e9d8:	e002      	b.n	800e9e0 <lv_draw_sw_blend+0xcc>
        else fill_dsc.mask_buf = blend_dsc->mask_buf;
 800e9da:	683b      	ldr	r3, [r7, #0]
 800e9dc:	699b      	ldr	r3, [r3, #24]
 800e9de:	63fb      	str	r3, [r7, #60]	@ 0x3c

        fill_dsc.dest_buf = lv_draw_layer_go_to_xy(layer, blend_area.x1 - layer->buf_area.x1,
 800e9e0:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800e9e2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800e9e4:	685b      	ldr	r3, [r3, #4]
 800e9e6:	1ad1      	subs	r1, r2, r3
                                                   blend_area.y1 - layer->buf_area.y1);
 800e9e8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800e9ea:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800e9ec:	689b      	ldr	r3, [r3, #8]
        fill_dsc.dest_buf = lv_draw_layer_go_to_xy(layer, blend_area.x1 - layer->buf_area.x1,
 800e9ee:	1ad3      	subs	r3, r2, r3
 800e9f0:	461a      	mov	r2, r3
 800e9f2:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 800e9f4:	f7fc ffd4 	bl	800b9a0 <lv_draw_layer_go_to_xy>
 800e9f8:	4603      	mov	r3, r0
 800e9fa:	62fb      	str	r3, [r7, #44]	@ 0x2c

        if(fill_dsc.mask_buf) {
 800e9fc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800e9fe:	2b00      	cmp	r3, #0
 800ea00:	d01e      	beq.n	800ea40 <lv_draw_sw_blend+0x12c>
            fill_dsc.mask_stride = blend_dsc->mask_stride == 0  ? lv_area_get_width(blend_dsc->mask_area) : blend_dsc->mask_stride;
 800ea02:	683b      	ldr	r3, [r7, #0]
 800ea04:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ea06:	2b00      	cmp	r3, #0
 800ea08:	d106      	bne.n	800ea18 <lv_draw_sw_blend+0x104>
 800ea0a:	683b      	ldr	r3, [r7, #0]
 800ea0c:	6a1b      	ldr	r3, [r3, #32]
 800ea0e:	4618      	mov	r0, r3
 800ea10:	f7ff ff4f 	bl	800e8b2 <lv_area_get_width>
 800ea14:	4603      	mov	r3, r0
 800ea16:	e001      	b.n	800ea1c <lv_draw_sw_blend+0x108>
 800ea18:	683b      	ldr	r3, [r7, #0]
 800ea1a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ea1c:	643b      	str	r3, [r7, #64]	@ 0x40
            fill_dsc.mask_buf += fill_dsc.mask_stride * (blend_area.y1 - blend_dsc->mask_area->y1) +
 800ea1e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800ea20:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800ea22:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 800ea24:	6839      	ldr	r1, [r7, #0]
 800ea26:	6a09      	ldr	r1, [r1, #32]
 800ea28:	6849      	ldr	r1, [r1, #4]
 800ea2a:	1a41      	subs	r1, r0, r1
 800ea2c:	fb02 f101 	mul.w	r1, r2, r1
                                 (blend_area.x1 - blend_dsc->mask_area->x1);
 800ea30:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 800ea32:	683a      	ldr	r2, [r7, #0]
 800ea34:	6a12      	ldr	r2, [r2, #32]
 800ea36:	6812      	ldr	r2, [r2, #0]
 800ea38:	1a82      	subs	r2, r0, r2
            fill_dsc.mask_buf += fill_dsc.mask_stride * (blend_area.y1 - blend_dsc->mask_area->y1) +
 800ea3a:	440a      	add	r2, r1
 800ea3c:	4413      	add	r3, r2
 800ea3e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        switch(layer->color_format) {
 800ea40:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800ea42:	7d1b      	ldrb	r3, [r3, #20]
 800ea44:	3b0f      	subs	r3, #15
 800ea46:	2b03      	cmp	r3, #3
 800ea48:	f200 8106 	bhi.w	800ec58 <lv_draw_sw_blend+0x344>
 800ea4c:	a201      	add	r2, pc, #4	@ (adr r2, 800ea54 <lv_draw_sw_blend+0x140>)
 800ea4e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ea52:	bf00      	nop
 800ea54:	0800ea7d 	.word	0x0800ea7d
 800ea58:	0800ea71 	.word	0x0800ea71
 800ea5c:	0800ea8b 	.word	0x0800ea8b
 800ea60:	0800ea65 	.word	0x0800ea65
            case LV_COLOR_FORMAT_RGB565:
                lv_draw_sw_blend_color_to_rgb565(&fill_dsc);
 800ea64:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 800ea68:	4618      	mov	r0, r3
 800ea6a:	f001 fb2d 	bl	80100c8 <lv_draw_sw_blend_color_to_rgb565>
                break;
 800ea6e:	e0fa      	b.n	800ec66 <lv_draw_sw_blend+0x352>
            case LV_COLOR_FORMAT_ARGB8888:
                lv_draw_sw_blend_color_to_argb8888(&fill_dsc);
 800ea70:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 800ea74:	4618      	mov	r0, r3
 800ea76:	f000 f96d 	bl	800ed54 <lv_draw_sw_blend_color_to_argb8888>
                break;
 800ea7a:	e0f4      	b.n	800ec66 <lv_draw_sw_blend+0x352>
            case LV_COLOR_FORMAT_RGB888:
                lv_draw_sw_blend_color_to_rgb888(&fill_dsc, 3);
 800ea7c:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 800ea80:	2103      	movs	r1, #3
 800ea82:	4618      	mov	r0, r3
 800ea84:	f002 fe2a 	bl	80116dc <lv_draw_sw_blend_color_to_rgb888>
                break;
 800ea88:	e0ed      	b.n	800ec66 <lv_draw_sw_blend+0x352>
            case LV_COLOR_FORMAT_XRGB8888:
                lv_draw_sw_blend_color_to_rgb888(&fill_dsc, 4);
 800ea8a:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 800ea8e:	2104      	movs	r1, #4
 800ea90:	4618      	mov	r0, r3
 800ea92:	f002 fe23 	bl	80116dc <lv_draw_sw_blend_color_to_rgb888>
                break;
 800ea96:	e0e6      	b.n	800ec66 <lv_draw_sw_blend+0x352>
            default:
                break;
        }
    }
    else {
        if(!_lv_area_intersect(&blend_area, &blend_area, blend_dsc->src_area)) {
 800ea98:	683b      	ldr	r3, [r7, #0]
 800ea9a:	691a      	ldr	r2, [r3, #16]
 800ea9c:	f107 0148 	add.w	r1, r7, #72	@ 0x48
 800eaa0:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 800eaa4:	4618      	mov	r0, r3
 800eaa6:	f012 ff4f 	bl	8021948 <_lv_area_intersect>
 800eaaa:	4603      	mov	r3, r0
 800eaac:	f083 0301 	eor.w	r3, r3, #1
 800eab0:	b2db      	uxtb	r3, r3
 800eab2:	2b00      	cmp	r3, #0
 800eab4:	f040 80d2 	bne.w	800ec5c <lv_draw_sw_blend+0x348>
            LV_PROFILER_END;
            return;
        }

        if(blend_dsc->mask_area && !_lv_area_intersect(&blend_area, &blend_area, blend_dsc->mask_area)) {
 800eab8:	683b      	ldr	r3, [r7, #0]
 800eaba:	6a1b      	ldr	r3, [r3, #32]
 800eabc:	2b00      	cmp	r3, #0
 800eabe:	d00f      	beq.n	800eae0 <lv_draw_sw_blend+0x1cc>
 800eac0:	683b      	ldr	r3, [r7, #0]
 800eac2:	6a1a      	ldr	r2, [r3, #32]
 800eac4:	f107 0148 	add.w	r1, r7, #72	@ 0x48
 800eac8:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 800eacc:	4618      	mov	r0, r3
 800eace:	f012 ff3b 	bl	8021948 <_lv_area_intersect>
 800ead2:	4603      	mov	r3, r0
 800ead4:	f083 0301 	eor.w	r3, r3, #1
 800ead8:	b2db      	uxtb	r3, r3
 800eada:	2b00      	cmp	r3, #0
 800eadc:	f040 80c0 	bne.w	800ec60 <lv_draw_sw_blend+0x34c>
            LV_PROFILER_END;
            return;
        }

        _lv_draw_sw_blend_image_dsc_t image_dsc;
        image_dsc.dest_w = lv_area_get_width(&blend_area);
 800eae0:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 800eae4:	4618      	mov	r0, r3
 800eae6:	f7ff fee4 	bl	800e8b2 <lv_area_get_width>
 800eaea:	4603      	mov	r3, r0
 800eaec:	60fb      	str	r3, [r7, #12]
        image_dsc.dest_h = lv_area_get_height(&blend_area);
 800eaee:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 800eaf2:	4618      	mov	r0, r3
 800eaf4:	f7ff feed 	bl	800e8d2 <lv_area_get_height>
 800eaf8:	4603      	mov	r3, r0
 800eafa:	613b      	str	r3, [r7, #16]
        image_dsc.dest_stride = layer_stride_byte;
 800eafc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 800eafe:	617b      	str	r3, [r7, #20]

        image_dsc.opa = blend_dsc->opa;
 800eb00:	683b      	ldr	r3, [r7, #0]
 800eb02:	7d1b      	ldrb	r3, [r3, #20]
 800eb04:	f887 3029 	strb.w	r3, [r7, #41]	@ 0x29
        image_dsc.blend_mode = blend_dsc->blend_mode;
 800eb08:	683b      	ldr	r3, [r7, #0]
 800eb0a:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 800eb0e:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
        image_dsc.src_stride = blend_dsc->src_stride;
 800eb12:	683b      	ldr	r3, [r7, #0]
 800eb14:	689b      	ldr	r3, [r3, #8]
 800eb16:	627b      	str	r3, [r7, #36]	@ 0x24
        image_dsc.src_color_format = blend_dsc->src_color_format;
 800eb18:	683b      	ldr	r3, [r7, #0]
 800eb1a:	7b1b      	ldrb	r3, [r3, #12]
 800eb1c:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28

        const uint8_t * src_buf = blend_dsc->src_buf;
 800eb20:	683b      	ldr	r3, [r7, #0]
 800eb22:	685b      	ldr	r3, [r3, #4]
 800eb24:	65fb      	str	r3, [r7, #92]	@ 0x5c
        uint32_t src_px_size = lv_color_format_get_size(blend_dsc->src_color_format);
 800eb26:	683b      	ldr	r3, [r7, #0]
 800eb28:	7b1b      	ldrb	r3, [r3, #12]
 800eb2a:	4618      	mov	r0, r3
 800eb2c:	f7ff fee1 	bl	800e8f2 <lv_color_format_get_size>
 800eb30:	4603      	mov	r3, r0
 800eb32:	65bb      	str	r3, [r7, #88]	@ 0x58
        src_buf += image_dsc.src_stride * (blend_area.y1 - blend_dsc->src_area->y1);
 800eb34:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800eb36:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 800eb38:	683a      	ldr	r2, [r7, #0]
 800eb3a:	6912      	ldr	r2, [r2, #16]
 800eb3c:	6852      	ldr	r2, [r2, #4]
 800eb3e:	1a8a      	subs	r2, r1, r2
 800eb40:	fb02 f303 	mul.w	r3, r2, r3
 800eb44:	461a      	mov	r2, r3
 800eb46:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800eb48:	4413      	add	r3, r2
 800eb4a:	65fb      	str	r3, [r7, #92]	@ 0x5c
        src_buf += (blend_area.x1 - blend_dsc->src_area->x1) * src_px_size;
 800eb4c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800eb4e:	683b      	ldr	r3, [r7, #0]
 800eb50:	691b      	ldr	r3, [r3, #16]
 800eb52:	681b      	ldr	r3, [r3, #0]
 800eb54:	1ad3      	subs	r3, r2, r3
 800eb56:	461a      	mov	r2, r3
 800eb58:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 800eb5a:	fb02 f303 	mul.w	r3, r2, r3
 800eb5e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 800eb60:	4413      	add	r3, r2
 800eb62:	65fb      	str	r3, [r7, #92]	@ 0x5c
        image_dsc.src_buf = src_buf;
 800eb64:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 800eb66:	623b      	str	r3, [r7, #32]

        if(blend_dsc->mask_buf == NULL) image_dsc.mask_buf = NULL;
 800eb68:	683b      	ldr	r3, [r7, #0]
 800eb6a:	699b      	ldr	r3, [r3, #24]
 800eb6c:	2b00      	cmp	r3, #0
 800eb6e:	d102      	bne.n	800eb76 <lv_draw_sw_blend+0x262>
 800eb70:	2300      	movs	r3, #0
 800eb72:	61bb      	str	r3, [r7, #24]
 800eb74:	e009      	b.n	800eb8a <lv_draw_sw_blend+0x276>
        else if(blend_dsc->mask_res == LV_DRAW_SW_MASK_RES_FULL_COVER) image_dsc.mask_buf = NULL;
 800eb76:	683b      	ldr	r3, [r7, #0]
 800eb78:	7f1b      	ldrb	r3, [r3, #28]
 800eb7a:	2b01      	cmp	r3, #1
 800eb7c:	d102      	bne.n	800eb84 <lv_draw_sw_blend+0x270>
 800eb7e:	2300      	movs	r3, #0
 800eb80:	61bb      	str	r3, [r7, #24]
 800eb82:	e002      	b.n	800eb8a <lv_draw_sw_blend+0x276>
        else image_dsc.mask_buf = blend_dsc->mask_buf;
 800eb84:	683b      	ldr	r3, [r7, #0]
 800eb86:	699b      	ldr	r3, [r3, #24]
 800eb88:	61bb      	str	r3, [r7, #24]

        if(image_dsc.mask_buf) {
 800eb8a:	69bb      	ldr	r3, [r7, #24]
 800eb8c:	2b00      	cmp	r3, #0
 800eb8e:	d021      	beq.n	800ebd4 <lv_draw_sw_blend+0x2c0>
            image_dsc.mask_buf = blend_dsc->mask_buf;
 800eb90:	683b      	ldr	r3, [r7, #0]
 800eb92:	699b      	ldr	r3, [r3, #24]
 800eb94:	61bb      	str	r3, [r7, #24]
            image_dsc.mask_stride = blend_dsc->mask_stride ? blend_dsc->mask_stride : lv_area_get_width(blend_dsc->mask_area);
 800eb96:	683b      	ldr	r3, [r7, #0]
 800eb98:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800eb9a:	2b00      	cmp	r3, #0
 800eb9c:	d002      	beq.n	800eba4 <lv_draw_sw_blend+0x290>
 800eb9e:	683b      	ldr	r3, [r7, #0]
 800eba0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800eba2:	e005      	b.n	800ebb0 <lv_draw_sw_blend+0x29c>
 800eba4:	683b      	ldr	r3, [r7, #0]
 800eba6:	6a1b      	ldr	r3, [r3, #32]
 800eba8:	4618      	mov	r0, r3
 800ebaa:	f7ff fe82 	bl	800e8b2 <lv_area_get_width>
 800ebae:	4603      	mov	r3, r0
 800ebb0:	61fb      	str	r3, [r7, #28]
            image_dsc.mask_buf += image_dsc.mask_stride * (blend_area.y1 - blend_dsc->mask_area->y1) +
 800ebb2:	69bb      	ldr	r3, [r7, #24]
 800ebb4:	69fa      	ldr	r2, [r7, #28]
 800ebb6:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 800ebb8:	6839      	ldr	r1, [r7, #0]
 800ebba:	6a09      	ldr	r1, [r1, #32]
 800ebbc:	6849      	ldr	r1, [r1, #4]
 800ebbe:	1a41      	subs	r1, r0, r1
 800ebc0:	fb02 f101 	mul.w	r1, r2, r1
                                  (blend_area.x1 - blend_dsc->mask_area->x1);
 800ebc4:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 800ebc6:	683a      	ldr	r2, [r7, #0]
 800ebc8:	6a12      	ldr	r2, [r2, #32]
 800ebca:	6812      	ldr	r2, [r2, #0]
 800ebcc:	1a82      	subs	r2, r0, r2
            image_dsc.mask_buf += image_dsc.mask_stride * (blend_area.y1 - blend_dsc->mask_area->y1) +
 800ebce:	440a      	add	r2, r1
 800ebd0:	4413      	add	r3, r2
 800ebd2:	61bb      	str	r3, [r7, #24]
        }

        image_dsc.dest_buf = lv_draw_layer_go_to_xy(layer, blend_area.x1 - layer->buf_area.x1,
 800ebd4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ebd6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800ebd8:	685b      	ldr	r3, [r3, #4]
 800ebda:	1ad1      	subs	r1, r2, r3
                                                    blend_area.y1 - layer->buf_area.y1);
 800ebdc:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800ebde:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800ebe0:	689b      	ldr	r3, [r3, #8]
        image_dsc.dest_buf = lv_draw_layer_go_to_xy(layer, blend_area.x1 - layer->buf_area.x1,
 800ebe2:	1ad3      	subs	r3, r2, r3
 800ebe4:	461a      	mov	r2, r3
 800ebe6:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 800ebe8:	f7fc feda 	bl	800b9a0 <lv_draw_layer_go_to_xy>
 800ebec:	4603      	mov	r3, r0
 800ebee:	60bb      	str	r3, [r7, #8]

        switch(layer->color_format) {
 800ebf0:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 800ebf2:	7d1b      	ldrb	r3, [r3, #20]
 800ebf4:	3b0f      	subs	r3, #15
 800ebf6:	2b05      	cmp	r3, #5
 800ebf8:	d834      	bhi.n	800ec64 <lv_draw_sw_blend+0x350>
 800ebfa:	a201      	add	r2, pc, #4	@ (adr r2, 800ec00 <lv_draw_sw_blend+0x2ec>)
 800ebfc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ec00:	0800ec31 	.word	0x0800ec31
 800ec04:	0800ec25 	.word	0x0800ec25
 800ec08:	0800ec3f 	.word	0x0800ec3f
 800ec0c:	0800ec19 	.word	0x0800ec19
 800ec10:	0800ec65 	.word	0x0800ec65
 800ec14:	0800ec19 	.word	0x0800ec19
            case LV_COLOR_FORMAT_RGB565:
            case LV_COLOR_FORMAT_RGB565A8:
                lv_draw_sw_blend_image_to_rgb565(&image_dsc);
 800ec18:	f107 0308 	add.w	r3, r7, #8
 800ec1c:	4618      	mov	r0, r3
 800ec1e:	f001 fc8b 	bl	8010538 <lv_draw_sw_blend_image_to_rgb565>
                break;
 800ec22:	e020      	b.n	800ec66 <lv_draw_sw_blend+0x352>
            case LV_COLOR_FORMAT_ARGB8888:
                lv_draw_sw_blend_image_to_argb8888(&image_dsc);
 800ec24:	f107 0308 	add.w	r3, r7, #8
 800ec28:	4618      	mov	r0, r3
 800ec2a:	f000 fa4d 	bl	800f0c8 <lv_draw_sw_blend_image_to_argb8888>
                break;
 800ec2e:	e01a      	b.n	800ec66 <lv_draw_sw_blend+0x352>
            case LV_COLOR_FORMAT_RGB888:
                lv_draw_sw_blend_image_to_rgb888(&image_dsc, 3);
 800ec30:	f107 0308 	add.w	r3, r7, #8
 800ec34:	2103      	movs	r1, #3
 800ec36:	4618      	mov	r0, r3
 800ec38:	f002 ff24 	bl	8011a84 <lv_draw_sw_blend_image_to_rgb888>
                break;
 800ec3c:	e013      	b.n	800ec66 <lv_draw_sw_blend+0x352>
            case LV_COLOR_FORMAT_XRGB8888:
                lv_draw_sw_blend_image_to_rgb888(&image_dsc, 4);
 800ec3e:	f107 0308 	add.w	r3, r7, #8
 800ec42:	2104      	movs	r1, #4
 800ec44:	4618      	mov	r0, r3
 800ec46:	f002 ff1d 	bl	8011a84 <lv_draw_sw_blend_image_to_rgb888>
                break;
 800ec4a:	e00c      	b.n	800ec66 <lv_draw_sw_blend+0x352>
    if(blend_dsc->opa <= LV_OPA_MIN) return;
 800ec4c:	bf00      	nop
 800ec4e:	e00a      	b.n	800ec66 <lv_draw_sw_blend+0x352>
    if(blend_dsc->mask_buf && blend_dsc->mask_res == LV_DRAW_SW_MASK_RES_TRANSP) return;
 800ec50:	bf00      	nop
 800ec52:	e008      	b.n	800ec66 <lv_draw_sw_blend+0x352>
    if(!_lv_area_intersect(&blend_area, blend_dsc->blend_area, draw_unit->clip_area)) return;
 800ec54:	bf00      	nop
 800ec56:	e006      	b.n	800ec66 <lv_draw_sw_blend+0x352>
                break;
 800ec58:	bf00      	nop
 800ec5a:	e004      	b.n	800ec66 <lv_draw_sw_blend+0x352>
            return;
 800ec5c:	bf00      	nop
 800ec5e:	e002      	b.n	800ec66 <lv_draw_sw_blend+0x352>
            return;
 800ec60:	bf00      	nop
 800ec62:	e000      	b.n	800ec66 <lv_draw_sw_blend+0x352>
            default:
                break;
 800ec64:	bf00      	nop
        }
    }
    LV_PROFILER_END;
}
 800ec66:	3768      	adds	r7, #104	@ 0x68
 800ec68:	46bd      	mov	sp, r7
 800ec6a:	bd80      	pop	{r7, pc}

0800ec6c <lv_color32_eq>:
 * @param c1    the first color
 * @param c2    the second color
 * @return      true: equal
 */
static inline bool lv_color32_eq(lv_color32_t c1, lv_color32_t c2)
{
 800ec6c:	b480      	push	{r7}
 800ec6e:	b083      	sub	sp, #12
 800ec70:	af00      	add	r7, sp, #0
 800ec72:	6078      	str	r0, [r7, #4]
 800ec74:	6039      	str	r1, [r7, #0]
    return *((uint32_t *)&c1) == *((uint32_t *)&c2);
 800ec76:	1d3b      	adds	r3, r7, #4
 800ec78:	681a      	ldr	r2, [r3, #0]
 800ec7a:	463b      	mov	r3, r7
 800ec7c:	681b      	ldr	r3, [r3, #0]
 800ec7e:	429a      	cmp	r2, r3
 800ec80:	bf0c      	ite	eq
 800ec82:	2301      	moveq	r3, #1
 800ec84:	2300      	movne	r3, #0
 800ec86:	b2db      	uxtb	r3, r3
}
 800ec88:	4618      	mov	r0, r3
 800ec8a:	370c      	adds	r7, #12
 800ec8c:	46bd      	mov	sp, r7
 800ec8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec92:	4770      	bx	lr

0800ec94 <lv_color_mix32>:
 * @return
 * @note Use bg.alpha in the return value
 * @note Use fg.alpha as mix ratio
 */
static inline lv_color32_t lv_color_mix32(lv_color32_t fg, lv_color32_t bg)
{
 800ec94:	b480      	push	{r7}
 800ec96:	b085      	sub	sp, #20
 800ec98:	af00      	add	r7, sp, #0
 800ec9a:	6078      	str	r0, [r7, #4]
 800ec9c:	6039      	str	r1, [r7, #0]
    if(fg.alpha >= LV_OPA_MAX) {
 800ec9e:	79fb      	ldrb	r3, [r7, #7]
 800eca0:	2bfc      	cmp	r3, #252	@ 0xfc
 800eca2:	d904      	bls.n	800ecae <lv_color_mix32+0x1a>
        fg.alpha = bg.alpha;
 800eca4:	78fb      	ldrb	r3, [r7, #3]
 800eca6:	71fb      	strb	r3, [r7, #7]
        return fg;
 800eca8:	687b      	ldr	r3, [r7, #4]
 800ecaa:	60fb      	str	r3, [r7, #12]
 800ecac:	e031      	b.n	800ed12 <lv_color_mix32+0x7e>
    }
    if(fg.alpha <= LV_OPA_MIN) {
 800ecae:	79fb      	ldrb	r3, [r7, #7]
 800ecb0:	2b02      	cmp	r3, #2
 800ecb2:	d802      	bhi.n	800ecba <lv_color_mix32+0x26>
        return bg;
 800ecb4:	683b      	ldr	r3, [r7, #0]
 800ecb6:	60fb      	str	r3, [r7, #12]
 800ecb8:	e02b      	b.n	800ed12 <lv_color_mix32+0x7e>
    }
    bg.red = (uint32_t)((uint32_t)fg.red * fg.alpha + (uint32_t)bg.red * (255 - fg.alpha)) >> 8;
 800ecba:	79bb      	ldrb	r3, [r7, #6]
 800ecbc:	79fa      	ldrb	r2, [r7, #7]
 800ecbe:	fb03 f202 	mul.w	r2, r3, r2
 800ecc2:	78bb      	ldrb	r3, [r7, #2]
 800ecc4:	79f9      	ldrb	r1, [r7, #7]
 800ecc6:	f1c1 01ff 	rsb	r1, r1, #255	@ 0xff
 800ecca:	fb01 f303 	mul.w	r3, r1, r3
 800ecce:	4413      	add	r3, r2
 800ecd0:	0a1b      	lsrs	r3, r3, #8
 800ecd2:	b2db      	uxtb	r3, r3
 800ecd4:	70bb      	strb	r3, [r7, #2]
    bg.green = (uint32_t)((uint32_t)fg.green * fg.alpha + (uint32_t)bg.green * (255 - fg.alpha)) >> 8;
 800ecd6:	797b      	ldrb	r3, [r7, #5]
 800ecd8:	79fa      	ldrb	r2, [r7, #7]
 800ecda:	fb03 f202 	mul.w	r2, r3, r2
 800ecde:	787b      	ldrb	r3, [r7, #1]
 800ece0:	79f9      	ldrb	r1, [r7, #7]
 800ece2:	f1c1 01ff 	rsb	r1, r1, #255	@ 0xff
 800ece6:	fb01 f303 	mul.w	r3, r1, r3
 800ecea:	4413      	add	r3, r2
 800ecec:	0a1b      	lsrs	r3, r3, #8
 800ecee:	b2db      	uxtb	r3, r3
 800ecf0:	707b      	strb	r3, [r7, #1]
    bg.blue = (uint32_t)((uint32_t)fg.blue * fg.alpha + (uint32_t)bg.blue * (255 - fg.alpha)) >> 8;
 800ecf2:	793b      	ldrb	r3, [r7, #4]
 800ecf4:	79fa      	ldrb	r2, [r7, #7]
 800ecf6:	fb03 f202 	mul.w	r2, r3, r2
 800ecfa:	783b      	ldrb	r3, [r7, #0]
 800ecfc:	79f9      	ldrb	r1, [r7, #7]
 800ecfe:	f1c1 01ff 	rsb	r1, r1, #255	@ 0xff
 800ed02:	fb01 f303 	mul.w	r3, r1, r3
 800ed06:	4413      	add	r3, r2
 800ed08:	0a1b      	lsrs	r3, r3, #8
 800ed0a:	b2db      	uxtb	r3, r3
 800ed0c:	703b      	strb	r3, [r7, #0]
    return bg;
 800ed0e:	683b      	ldr	r3, [r7, #0]
 800ed10:	60fb      	str	r3, [r7, #12]
}
 800ed12:	2300      	movs	r3, #0
 800ed14:	7b3a      	ldrb	r2, [r7, #12]
 800ed16:	f362 0307 	bfi	r3, r2, #0, #8
 800ed1a:	7b7a      	ldrb	r2, [r7, #13]
 800ed1c:	f362 230f 	bfi	r3, r2, #8, #8
 800ed20:	7bba      	ldrb	r2, [r7, #14]
 800ed22:	f362 4317 	bfi	r3, r2, #16, #8
 800ed26:	7bfa      	ldrb	r2, [r7, #15]
 800ed28:	f362 631f 	bfi	r3, r2, #24, #8
 800ed2c:	4618      	mov	r0, r3
 800ed2e:	3714      	adds	r7, #20
 800ed30:	46bd      	mov	sp, r7
 800ed32:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ed36:	4770      	bx	lr

0800ed38 <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 800ed38:	b580      	push	{r7, lr}
 800ed3a:	b082      	sub	sp, #8
 800ed3c:	af00      	add	r7, sp, #0
 800ed3e:	6078      	str	r0, [r7, #4]
 800ed40:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 800ed42:	683a      	ldr	r2, [r7, #0]
 800ed44:	2100      	movs	r1, #0
 800ed46:	6878      	ldr	r0, [r7, #4]
 800ed48:	f016 f86b 	bl	8024e22 <lv_memset>
}
 800ed4c:	bf00      	nop
 800ed4e:	3708      	adds	r7, #8
 800ed50:	46bd      	mov	sp, r7
 800ed52:	bd80      	pop	{r7, pc}

0800ed54 <lv_draw_sw_blend_color_to_argb8888>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void LV_ATTRIBUTE_FAST_MEM lv_draw_sw_blend_color_to_argb8888(_lv_draw_sw_blend_fill_dsc_t * dsc)
{
 800ed54:	b590      	push	{r4, r7, lr}
 800ed56:	b097      	sub	sp, #92	@ 0x5c
 800ed58:	af00      	add	r7, sp, #0
 800ed5a:	6078      	str	r0, [r7, #4]
    int32_t w = dsc->dest_w;
 800ed5c:	687b      	ldr	r3, [r7, #4]
 800ed5e:	685b      	ldr	r3, [r3, #4]
 800ed60:	63bb      	str	r3, [r7, #56]	@ 0x38
    int32_t h = dsc->dest_h;
 800ed62:	687b      	ldr	r3, [r7, #4]
 800ed64:	689b      	ldr	r3, [r3, #8]
 800ed66:	637b      	str	r3, [r7, #52]	@ 0x34
    lv_opa_t opa = dsc->opa;
 800ed68:	687b      	ldr	r3, [r7, #4]
 800ed6a:	7edb      	ldrb	r3, [r3, #27]
 800ed6c:	f887 3033 	strb.w	r3, [r7, #51]	@ 0x33
    const lv_opa_t * mask = dsc->mask_buf;
 800ed70:	687b      	ldr	r3, [r7, #4]
 800ed72:	691b      	ldr	r3, [r3, #16]
 800ed74:	657b      	str	r3, [r7, #84]	@ 0x54
    int32_t mask_stride = dsc->mask_stride;
 800ed76:	687b      	ldr	r3, [r7, #4]
 800ed78:	695b      	ldr	r3, [r3, #20]
 800ed7a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int32_t dest_stride = dsc->dest_stride;
 800ed7c:	687b      	ldr	r3, [r7, #4]
 800ed7e:	68db      	ldr	r3, [r3, #12]
 800ed80:	62bb      	str	r3, [r7, #40]	@ 0x28

    lv_color_mix_alpha_cache_t cache;
    lv_color_mix_with_alpha_cache_init(&cache);
 800ed82:	f107 0314 	add.w	r3, r7, #20
 800ed86:	4618      	mov	r0, r3
 800ed88:	f001 f8ad 	bl	800fee6 <lv_color_mix_with_alpha_cache_init>
    LV_UNUSED(mask);
    LV_UNUSED(mask_stride);
    LV_UNUSED(dest_stride);

    /*Simple fill*/
    if(mask == NULL && opa >= LV_OPA_MAX) {
 800ed8c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800ed8e:	2b00      	cmp	r3, #0
 800ed90:	f040 80a7 	bne.w	800eee2 <lv_draw_sw_blend_color_to_argb8888+0x18e>
 800ed94:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 800ed98:	2bfc      	cmp	r3, #252	@ 0xfc
 800ed9a:	f240 80a2 	bls.w	800eee2 <lv_draw_sw_blend_color_to_argb8888+0x18e>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_ARGB8888(dsc)) {
            uint32_t color32 = lv_color_to_u32(dsc->color);
 800ed9e:	687b      	ldr	r3, [r7, #4]
 800eda0:	6998      	ldr	r0, [r3, #24]
 800eda2:	f013 fc58 	bl	8022656 <lv_color_to_u32>
 800eda6:	6278      	str	r0, [r7, #36]	@ 0x24
            uint32_t * dest_buf = dsc->dest_buf;
 800eda8:	687b      	ldr	r3, [r7, #4]
 800edaa:	681b      	ldr	r3, [r3, #0]
 800edac:	64bb      	str	r3, [r7, #72]	@ 0x48
            for(y = 0; y < h; y++) {
 800edae:	2300      	movs	r3, #0
 800edb0:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800edb2:	e090      	b.n	800eed6 <lv_draw_sw_blend_color_to_argb8888+0x182>
                for(x = 0; x < w - 16; x += 16) {
 800edb4:	2300      	movs	r3, #0
 800edb6:	653b      	str	r3, [r7, #80]	@ 0x50
 800edb8:	e071      	b.n	800ee9e <lv_draw_sw_blend_color_to_argb8888+0x14a>
                    dest_buf[x + 0] = color32;
 800edba:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800edbc:	009b      	lsls	r3, r3, #2
 800edbe:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800edc0:	4413      	add	r3, r2
 800edc2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800edc4:	601a      	str	r2, [r3, #0]
                    dest_buf[x + 1] = color32;
 800edc6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800edc8:	3301      	adds	r3, #1
 800edca:	009b      	lsls	r3, r3, #2
 800edcc:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800edce:	4413      	add	r3, r2
 800edd0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800edd2:	601a      	str	r2, [r3, #0]
                    dest_buf[x + 2] = color32;
 800edd4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800edd6:	3302      	adds	r3, #2
 800edd8:	009b      	lsls	r3, r3, #2
 800edda:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800eddc:	4413      	add	r3, r2
 800edde:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ede0:	601a      	str	r2, [r3, #0]
                    dest_buf[x + 3] = color32;
 800ede2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ede4:	3303      	adds	r3, #3
 800ede6:	009b      	lsls	r3, r3, #2
 800ede8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800edea:	4413      	add	r3, r2
 800edec:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800edee:	601a      	str	r2, [r3, #0]

                    dest_buf[x + 4] = color32;
 800edf0:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800edf2:	3304      	adds	r3, #4
 800edf4:	009b      	lsls	r3, r3, #2
 800edf6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800edf8:	4413      	add	r3, r2
 800edfa:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800edfc:	601a      	str	r2, [r3, #0]
                    dest_buf[x + 5] = color32;
 800edfe:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ee00:	3305      	adds	r3, #5
 800ee02:	009b      	lsls	r3, r3, #2
 800ee04:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ee06:	4413      	add	r3, r2
 800ee08:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ee0a:	601a      	str	r2, [r3, #0]
                    dest_buf[x + 6] = color32;
 800ee0c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ee0e:	3306      	adds	r3, #6
 800ee10:	009b      	lsls	r3, r3, #2
 800ee12:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ee14:	4413      	add	r3, r2
 800ee16:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ee18:	601a      	str	r2, [r3, #0]
                    dest_buf[x + 7] = color32;
 800ee1a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ee1c:	3307      	adds	r3, #7
 800ee1e:	009b      	lsls	r3, r3, #2
 800ee20:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ee22:	4413      	add	r3, r2
 800ee24:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ee26:	601a      	str	r2, [r3, #0]

                    dest_buf[x + 8] = color32;
 800ee28:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ee2a:	3308      	adds	r3, #8
 800ee2c:	009b      	lsls	r3, r3, #2
 800ee2e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ee30:	4413      	add	r3, r2
 800ee32:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ee34:	601a      	str	r2, [r3, #0]
                    dest_buf[x + 9] = color32;
 800ee36:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ee38:	3309      	adds	r3, #9
 800ee3a:	009b      	lsls	r3, r3, #2
 800ee3c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ee3e:	4413      	add	r3, r2
 800ee40:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ee42:	601a      	str	r2, [r3, #0]
                    dest_buf[x + 10] = color32;
 800ee44:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ee46:	330a      	adds	r3, #10
 800ee48:	009b      	lsls	r3, r3, #2
 800ee4a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ee4c:	4413      	add	r3, r2
 800ee4e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ee50:	601a      	str	r2, [r3, #0]
                    dest_buf[x + 11] = color32;
 800ee52:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ee54:	330b      	adds	r3, #11
 800ee56:	009b      	lsls	r3, r3, #2
 800ee58:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ee5a:	4413      	add	r3, r2
 800ee5c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ee5e:	601a      	str	r2, [r3, #0]

                    dest_buf[x + 12] = color32;
 800ee60:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ee62:	330c      	adds	r3, #12
 800ee64:	009b      	lsls	r3, r3, #2
 800ee66:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ee68:	4413      	add	r3, r2
 800ee6a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ee6c:	601a      	str	r2, [r3, #0]
                    dest_buf[x + 13] = color32;
 800ee6e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ee70:	330d      	adds	r3, #13
 800ee72:	009b      	lsls	r3, r3, #2
 800ee74:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ee76:	4413      	add	r3, r2
 800ee78:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ee7a:	601a      	str	r2, [r3, #0]
                    dest_buf[x + 14] = color32;
 800ee7c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ee7e:	330e      	adds	r3, #14
 800ee80:	009b      	lsls	r3, r3, #2
 800ee82:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ee84:	4413      	add	r3, r2
 800ee86:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ee88:	601a      	str	r2, [r3, #0]
                    dest_buf[x + 15] = color32;
 800ee8a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ee8c:	330f      	adds	r3, #15
 800ee8e:	009b      	lsls	r3, r3, #2
 800ee90:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800ee92:	4413      	add	r3, r2
 800ee94:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ee96:	601a      	str	r2, [r3, #0]
                for(x = 0; x < w - 16; x += 16) {
 800ee98:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ee9a:	3310      	adds	r3, #16
 800ee9c:	653b      	str	r3, [r7, #80]	@ 0x50
 800ee9e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800eea0:	3b10      	subs	r3, #16
 800eea2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800eea4:	429a      	cmp	r2, r3
 800eea6:	db88      	blt.n	800edba <lv_draw_sw_blend_color_to_argb8888+0x66>
                }
                for(; x < w; x ++) {
 800eea8:	e008      	b.n	800eebc <lv_draw_sw_blend_color_to_argb8888+0x168>
                    dest_buf[x] = color32;
 800eeaa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800eeac:	009b      	lsls	r3, r3, #2
 800eeae:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800eeb0:	4413      	add	r3, r2
 800eeb2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800eeb4:	601a      	str	r2, [r3, #0]
                for(; x < w; x ++) {
 800eeb6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800eeb8:	3301      	adds	r3, #1
 800eeba:	653b      	str	r3, [r7, #80]	@ 0x50
 800eebc:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800eebe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800eec0:	429a      	cmp	r2, r3
 800eec2:	dbf2      	blt.n	800eeaa <lv_draw_sw_blend_color_to_argb8888+0x156>
                }

                dest_buf = drawbuf_next_row(dest_buf, dest_stride);
 800eec4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800eec6:	4619      	mov	r1, r3
 800eec8:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 800eeca:	f001 f8ad 	bl	8010028 <drawbuf_next_row>
 800eece:	64b8      	str	r0, [r7, #72]	@ 0x48
            for(y = 0; y < h; y++) {
 800eed0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800eed2:	3301      	adds	r3, #1
 800eed4:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800eed6:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800eed8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800eeda:	429a      	cmp	r2, r3
 800eedc:	f6ff af6a 	blt.w	800edb4 <lv_draw_sw_blend_color_to_argb8888+0x60>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_ARGB8888(dsc)) {
 800eee0:	e0ed      	b.n	800f0be <lv_draw_sw_blend_color_to_argb8888+0x36a>
            }
        }

    }
    /*Opacity only*/
    else if(mask == NULL && opa < LV_OPA_MAX) {
 800eee2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800eee4:	2b00      	cmp	r3, #0
 800eee6:	d146      	bne.n	800ef76 <lv_draw_sw_blend_color_to_argb8888+0x222>
 800eee8:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 800eeec:	2bfc      	cmp	r3, #252	@ 0xfc
 800eeee:	d842      	bhi.n	800ef76 <lv_draw_sw_blend_color_to_argb8888+0x222>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_ARGB8888_WITH_OPA(dsc)) {
            lv_color32_t color_argb = lv_color_to_32(dsc->color, opa);
 800eef0:	f897 2033 	ldrb.w	r2, [r7, #51]	@ 0x33
 800eef4:	687b      	ldr	r3, [r7, #4]
 800eef6:	4611      	mov	r1, r2
 800eef8:	6998      	ldr	r0, [r3, #24]
 800eefa:	f013 fb69 	bl	80225d0 <lv_color_to_32>
 800eefe:	4603      	mov	r3, r0
 800ef00:	613b      	str	r3, [r7, #16]
            lv_color32_t * dest_buf = dsc->dest_buf;
 800ef02:	687b      	ldr	r3, [r7, #4]
 800ef04:	681b      	ldr	r3, [r3, #0]
 800ef06:	647b      	str	r3, [r7, #68]	@ 0x44

            for(y = 0; y < h; y++) {
 800ef08:	2300      	movs	r3, #0
 800ef0a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800ef0c:	e02e      	b.n	800ef6c <lv_draw_sw_blend_color_to_argb8888+0x218>
                for(x = 0; x < w; x++) {
 800ef0e:	2300      	movs	r3, #0
 800ef10:	653b      	str	r3, [r7, #80]	@ 0x50
 800ef12:	e01e      	b.n	800ef52 <lv_draw_sw_blend_color_to_argb8888+0x1fe>
                    dest_buf[x] = lv_color_32_32_mix(color_argb, dest_buf[x], &cache);
 800ef14:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ef16:	009b      	lsls	r3, r3, #2
 800ef18:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800ef1a:	4413      	add	r3, r2
 800ef1c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800ef1e:	0092      	lsls	r2, r2, #2
 800ef20:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800ef22:	188c      	adds	r4, r1, r2
 800ef24:	f107 0214 	add.w	r2, r7, #20
 800ef28:	6819      	ldr	r1, [r3, #0]
 800ef2a:	460b      	mov	r3, r1
 800ef2c:	4619      	mov	r1, r3
 800ef2e:	6938      	ldr	r0, [r7, #16]
 800ef30:	f000 ff3b 	bl	800fdaa <lv_color_32_32_mix>
 800ef34:	4603      	mov	r3, r0
 800ef36:	461a      	mov	r2, r3
 800ef38:	7022      	strb	r2, [r4, #0]
 800ef3a:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800ef3e:	7062      	strb	r2, [r4, #1]
 800ef40:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800ef44:	70a2      	strb	r2, [r4, #2]
 800ef46:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800ef4a:	70e3      	strb	r3, [r4, #3]
                for(x = 0; x < w; x++) {
 800ef4c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800ef4e:	3301      	adds	r3, #1
 800ef50:	653b      	str	r3, [r7, #80]	@ 0x50
 800ef52:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800ef54:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800ef56:	429a      	cmp	r2, r3
 800ef58:	dbdc      	blt.n	800ef14 <lv_draw_sw_blend_color_to_argb8888+0x1c0>
                }
                dest_buf = drawbuf_next_row(dest_buf, dest_stride);
 800ef5a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800ef5c:	4619      	mov	r1, r3
 800ef5e:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800ef60:	f001 f862 	bl	8010028 <drawbuf_next_row>
 800ef64:	6478      	str	r0, [r7, #68]	@ 0x44
            for(y = 0; y < h; y++) {
 800ef66:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800ef68:	3301      	adds	r3, #1
 800ef6a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800ef6c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800ef6e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800ef70:	429a      	cmp	r2, r3
 800ef72:	dbcc      	blt.n	800ef0e <lv_draw_sw_blend_color_to_argb8888+0x1ba>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_ARGB8888_WITH_OPA(dsc)) {
 800ef74:	e0a3      	b.n	800f0be <lv_draw_sw_blend_color_to_argb8888+0x36a>
            }
        }

    }
    /*Masked with full opacity*/
    else if(mask && opa >= LV_OPA_MAX) {
 800ef76:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800ef78:	2b00      	cmp	r3, #0
 800ef7a:	d04d      	beq.n	800f018 <lv_draw_sw_blend_color_to_argb8888+0x2c4>
 800ef7c:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 800ef80:	2bfc      	cmp	r3, #252	@ 0xfc
 800ef82:	d949      	bls.n	800f018 <lv_draw_sw_blend_color_to_argb8888+0x2c4>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_ARGB8888_WITH_MASK(dsc)) {
            lv_color32_t color_argb = lv_color_to_32(dsc->color, 0xff);
 800ef84:	687b      	ldr	r3, [r7, #4]
 800ef86:	21ff      	movs	r1, #255	@ 0xff
 800ef88:	6998      	ldr	r0, [r3, #24]
 800ef8a:	f013 fb21 	bl	80225d0 <lv_color_to_32>
 800ef8e:	4603      	mov	r3, r0
 800ef90:	60fb      	str	r3, [r7, #12]
            lv_color32_t * dest_buf = dsc->dest_buf;
 800ef92:	687b      	ldr	r3, [r7, #4]
 800ef94:	681b      	ldr	r3, [r3, #0]
 800ef96:	643b      	str	r3, [r7, #64]	@ 0x40
            for(y = 0; y < h; y++) {
 800ef98:	2300      	movs	r3, #0
 800ef9a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800ef9c:	e037      	b.n	800f00e <lv_draw_sw_blend_color_to_argb8888+0x2ba>
                for(x = 0; x < w; x++) {
 800ef9e:	2300      	movs	r3, #0
 800efa0:	653b      	str	r3, [r7, #80]	@ 0x50
 800efa2:	e023      	b.n	800efec <lv_draw_sw_blend_color_to_argb8888+0x298>
                    color_argb.alpha = mask[x];
 800efa4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800efa6:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800efa8:	4413      	add	r3, r2
 800efaa:	781b      	ldrb	r3, [r3, #0]
 800efac:	73fb      	strb	r3, [r7, #15]
                    dest_buf[x] = lv_color_32_32_mix(color_argb, dest_buf[x], &cache);
 800efae:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800efb0:	009b      	lsls	r3, r3, #2
 800efb2:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800efb4:	4413      	add	r3, r2
 800efb6:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800efb8:	0092      	lsls	r2, r2, #2
 800efba:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 800efbc:	188c      	adds	r4, r1, r2
 800efbe:	f107 0214 	add.w	r2, r7, #20
 800efc2:	6819      	ldr	r1, [r3, #0]
 800efc4:	460b      	mov	r3, r1
 800efc6:	4619      	mov	r1, r3
 800efc8:	68f8      	ldr	r0, [r7, #12]
 800efca:	f000 feee 	bl	800fdaa <lv_color_32_32_mix>
 800efce:	4603      	mov	r3, r0
 800efd0:	461a      	mov	r2, r3
 800efd2:	7022      	strb	r2, [r4, #0]
 800efd4:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800efd8:	7062      	strb	r2, [r4, #1]
 800efda:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800efde:	70a2      	strb	r2, [r4, #2]
 800efe0:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800efe4:	70e3      	strb	r3, [r4, #3]
                for(x = 0; x < w; x++) {
 800efe6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800efe8:	3301      	adds	r3, #1
 800efea:	653b      	str	r3, [r7, #80]	@ 0x50
 800efec:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800efee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800eff0:	429a      	cmp	r2, r3
 800eff2:	dbd7      	blt.n	800efa4 <lv_draw_sw_blend_color_to_argb8888+0x250>
                }

                dest_buf = drawbuf_next_row(dest_buf, dest_stride);
 800eff4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800eff6:	4619      	mov	r1, r3
 800eff8:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800effa:	f001 f815 	bl	8010028 <drawbuf_next_row>
 800effe:	6438      	str	r0, [r7, #64]	@ 0x40
                mask += mask_stride;
 800f000:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f002:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f004:	4413      	add	r3, r2
 800f006:	657b      	str	r3, [r7, #84]	@ 0x54
            for(y = 0; y < h; y++) {
 800f008:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f00a:	3301      	adds	r3, #1
 800f00c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800f00e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f010:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f012:	429a      	cmp	r2, r3
 800f014:	dbc3      	blt.n	800ef9e <lv_draw_sw_blend_color_to_argb8888+0x24a>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_ARGB8888_WITH_MASK(dsc)) {
 800f016:	e052      	b.n	800f0be <lv_draw_sw_blend_color_to_argb8888+0x36a>

    }
    /*Masked with opacity*/
    else {
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_ARGB8888_MIX_MASK_OPA(dsc)) {
            lv_color32_t color_argb = lv_color_to_32(dsc->color, opa);
 800f018:	f897 2033 	ldrb.w	r2, [r7, #51]	@ 0x33
 800f01c:	687b      	ldr	r3, [r7, #4]
 800f01e:	4611      	mov	r1, r2
 800f020:	6998      	ldr	r0, [r3, #24]
 800f022:	f013 fad5 	bl	80225d0 <lv_color_to_32>
 800f026:	4603      	mov	r3, r0
 800f028:	60bb      	str	r3, [r7, #8]
            lv_color32_t * dest_buf = dsc->dest_buf;
 800f02a:	687b      	ldr	r3, [r7, #4]
 800f02c:	681b      	ldr	r3, [r3, #0]
 800f02e:	63fb      	str	r3, [r7, #60]	@ 0x3c
            for(y = 0; y < h; y++) {
 800f030:	2300      	movs	r3, #0
 800f032:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800f034:	e03e      	b.n	800f0b4 <lv_draw_sw_blend_color_to_argb8888+0x360>
                for(x = 0; x < w; x++) {
 800f036:	2300      	movs	r3, #0
 800f038:	653b      	str	r3, [r7, #80]	@ 0x50
 800f03a:	e02a      	b.n	800f092 <lv_draw_sw_blend_color_to_argb8888+0x33e>
                    color_argb.alpha = LV_OPA_MIX2(mask[x], opa);
 800f03c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f03e:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f040:	4413      	add	r3, r2
 800f042:	781b      	ldrb	r3, [r3, #0]
 800f044:	461a      	mov	r2, r3
 800f046:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 800f04a:	fb02 f303 	mul.w	r3, r2, r3
 800f04e:	121b      	asrs	r3, r3, #8
 800f050:	b2db      	uxtb	r3, r3
 800f052:	72fb      	strb	r3, [r7, #11]
                    dest_buf[x] = lv_color_32_32_mix(color_argb, dest_buf[x], &cache);
 800f054:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f056:	009b      	lsls	r3, r3, #2
 800f058:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f05a:	4413      	add	r3, r2
 800f05c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f05e:	0092      	lsls	r2, r2, #2
 800f060:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 800f062:	188c      	adds	r4, r1, r2
 800f064:	f107 0214 	add.w	r2, r7, #20
 800f068:	6819      	ldr	r1, [r3, #0]
 800f06a:	460b      	mov	r3, r1
 800f06c:	4619      	mov	r1, r3
 800f06e:	68b8      	ldr	r0, [r7, #8]
 800f070:	f000 fe9b 	bl	800fdaa <lv_color_32_32_mix>
 800f074:	4603      	mov	r3, r0
 800f076:	461a      	mov	r2, r3
 800f078:	7022      	strb	r2, [r4, #0]
 800f07a:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800f07e:	7062      	strb	r2, [r4, #1]
 800f080:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800f084:	70a2      	strb	r2, [r4, #2]
 800f086:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800f08a:	70e3      	strb	r3, [r4, #3]
                for(x = 0; x < w; x++) {
 800f08c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800f08e:	3301      	adds	r3, #1
 800f090:	653b      	str	r3, [r7, #80]	@ 0x50
 800f092:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f094:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f096:	429a      	cmp	r2, r3
 800f098:	dbd0      	blt.n	800f03c <lv_draw_sw_blend_color_to_argb8888+0x2e8>
                }
                dest_buf = drawbuf_next_row(dest_buf, dest_stride);
 800f09a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f09c:	4619      	mov	r1, r3
 800f09e:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 800f0a0:	f000 ffc2 	bl	8010028 <drawbuf_next_row>
 800f0a4:	63f8      	str	r0, [r7, #60]	@ 0x3c
                mask += mask_stride;
 800f0a6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f0a8:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f0aa:	4413      	add	r3, r2
 800f0ac:	657b      	str	r3, [r7, #84]	@ 0x54
            for(y = 0; y < h; y++) {
 800f0ae:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f0b0:	3301      	adds	r3, #1
 800f0b2:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800f0b4:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f0b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f0b8:	429a      	cmp	r2, r3
 800f0ba:	dbbc      	blt.n	800f036 <lv_draw_sw_blend_color_to_argb8888+0x2e2>
            }
        }
    }
}
 800f0bc:	bf00      	nop
 800f0be:	bf00      	nop
 800f0c0:	375c      	adds	r7, #92	@ 0x5c
 800f0c2:	46bd      	mov	sp, r7
 800f0c4:	bd90      	pop	{r4, r7, pc}
	...

0800f0c8 <lv_draw_sw_blend_image_to_argb8888>:

void LV_ATTRIBUTE_FAST_MEM lv_draw_sw_blend_image_to_argb8888(_lv_draw_sw_blend_image_dsc_t * dsc)
{
 800f0c8:	b580      	push	{r7, lr}
 800f0ca:	b082      	sub	sp, #8
 800f0cc:	af00      	add	r7, sp, #0
 800f0ce:	6078      	str	r0, [r7, #4]
    switch(dsc->src_color_format) {
 800f0d0:	687b      	ldr	r3, [r7, #4]
 800f0d2:	f893 3020 	ldrb.w	r3, [r3, #32]
 800f0d6:	3b0f      	subs	r3, #15
 800f0d8:	2b03      	cmp	r3, #3
 800f0da:	d81d      	bhi.n	800f118 <lv_draw_sw_blend_image_to_argb8888+0x50>
 800f0dc:	a201      	add	r2, pc, #4	@ (adr r2, 800f0e4 <lv_draw_sw_blend_image_to_argb8888+0x1c>)
 800f0de:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f0e2:	bf00      	nop
 800f0e4:	0800f0fd 	.word	0x0800f0fd
 800f0e8:	0800f111 	.word	0x0800f111
 800f0ec:	0800f107 	.word	0x0800f107
 800f0f0:	0800f0f5 	.word	0x0800f0f5
        case LV_COLOR_FORMAT_RGB565:
            rgb565_image_blend(dsc);
 800f0f4:	6878      	ldr	r0, [r7, #4]
 800f0f6:	f000 f815 	bl	800f124 <rgb565_image_blend>
            break;
 800f0fa:	e00e      	b.n	800f11a <lv_draw_sw_blend_image_to_argb8888+0x52>
        case LV_COLOR_FORMAT_RGB888:
            rgb888_image_blend(dsc, 3);
 800f0fc:	2103      	movs	r1, #3
 800f0fe:	6878      	ldr	r0, [r7, #4]
 800f100:	f000 fa34 	bl	800f56c <rgb888_image_blend>
            break;
 800f104:	e009      	b.n	800f11a <lv_draw_sw_blend_image_to_argb8888+0x52>
        case LV_COLOR_FORMAT_XRGB8888:
            rgb888_image_blend(dsc, 4);
 800f106:	2104      	movs	r1, #4
 800f108:	6878      	ldr	r0, [r7, #4]
 800f10a:	f000 fa2f 	bl	800f56c <rgb888_image_blend>
            break;
 800f10e:	e004      	b.n	800f11a <lv_draw_sw_blend_image_to_argb8888+0x52>
        case LV_COLOR_FORMAT_ARGB8888:
            argb8888_image_blend(dsc);
 800f110:	6878      	ldr	r0, [r7, #4]
 800f112:	f000 fc66 	bl	800f9e2 <argb8888_image_blend>
            break;
 800f116:	e000      	b.n	800f11a <lv_draw_sw_blend_image_to_argb8888+0x52>
        default:
            LV_LOG_WARN("Not supported source color format");
            break;
 800f118:	bf00      	nop
    }
}
 800f11a:	bf00      	nop
 800f11c:	3708      	adds	r7, #8
 800f11e:	46bd      	mov	sp, r7
 800f120:	bd80      	pop	{r7, pc}
 800f122:	bf00      	nop

0800f124 <rgb565_image_blend>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void LV_ATTRIBUTE_FAST_MEM rgb565_image_blend(_lv_draw_sw_blend_image_dsc_t * dsc)
{
 800f124:	b590      	push	{r4, r7, lr}
 800f126:	b095      	sub	sp, #84	@ 0x54
 800f128:	af00      	add	r7, sp, #0
 800f12a:	6078      	str	r0, [r7, #4]
    int32_t w = dsc->dest_w;
 800f12c:	687b      	ldr	r3, [r7, #4]
 800f12e:	685b      	ldr	r3, [r3, #4]
 800f130:	637b      	str	r3, [r7, #52]	@ 0x34
    int32_t h = dsc->dest_h;
 800f132:	687b      	ldr	r3, [r7, #4]
 800f134:	689b      	ldr	r3, [r3, #8]
 800f136:	633b      	str	r3, [r7, #48]	@ 0x30
    lv_opa_t opa = dsc->opa;
 800f138:	687b      	ldr	r3, [r7, #4]
 800f13a:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 800f13e:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    lv_color32_t * dest_buf_c32 = dsc->dest_buf;
 800f142:	687b      	ldr	r3, [r7, #4]
 800f144:	681b      	ldr	r3, [r3, #0]
 800f146:	64fb      	str	r3, [r7, #76]	@ 0x4c
    int32_t dest_stride = dsc->dest_stride;
 800f148:	687b      	ldr	r3, [r7, #4]
 800f14a:	68db      	ldr	r3, [r3, #12]
 800f14c:	62bb      	str	r3, [r7, #40]	@ 0x28
    const lv_color16_t * src_buf_c16 = (const lv_color16_t *) dsc->src_buf;
 800f14e:	687b      	ldr	r3, [r7, #4]
 800f150:	699b      	ldr	r3, [r3, #24]
 800f152:	64bb      	str	r3, [r7, #72]	@ 0x48
    int32_t src_stride = dsc->src_stride;
 800f154:	687b      	ldr	r3, [r7, #4]
 800f156:	69db      	ldr	r3, [r3, #28]
 800f158:	627b      	str	r3, [r7, #36]	@ 0x24
    const lv_opa_t * mask_buf = dsc->mask_buf;
 800f15a:	687b      	ldr	r3, [r7, #4]
 800f15c:	691b      	ldr	r3, [r3, #16]
 800f15e:	647b      	str	r3, [r7, #68]	@ 0x44
    int32_t mask_stride = dsc->mask_stride;
 800f160:	687b      	ldr	r3, [r7, #4]
 800f162:	695b      	ldr	r3, [r3, #20]
 800f164:	623b      	str	r3, [r7, #32]

    lv_color32_t color_argb;
    lv_color_mix_alpha_cache_t cache;
    lv_color_mix_with_alpha_cache_init(&cache);
 800f166:	f107 030c 	add.w	r3, r7, #12
 800f16a:	4618      	mov	r0, r3
 800f16c:	f000 febb 	bl	800fee6 <lv_color_mix_with_alpha_cache_init>
    int32_t x;
    int32_t y;

    LV_UNUSED(color_argb);

    if(dsc->blend_mode == LV_BLEND_MODE_NORMAL) {
 800f170:	687b      	ldr	r3, [r7, #4]
 800f172:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 800f176:	2b00      	cmp	r3, #0
 800f178:	f040 817d 	bne.w	800f476 <rgb565_image_blend+0x352>
        if(mask_buf == NULL) {
 800f17c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f17e:	2b00      	cmp	r3, #0
 800f180:	d17f      	bne.n	800f282 <rgb565_image_blend+0x15e>
            lv_result_t accelerated;
            if(opa >= LV_OPA_MAX) {
 800f182:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800f186:	2bfc      	cmp	r3, #252	@ 0xfc
 800f188:	d903      	bls.n	800f192 <rgb565_image_blend+0x6e>
                accelerated = LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_ARGB8888(dsc);
 800f18a:	2300      	movs	r3, #0
 800f18c:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
 800f190:	e002      	b.n	800f198 <rgb565_image_blend+0x74>
            }
            else {
                accelerated = LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_ARGB8888_WITH_OPA(dsc);
 800f192:	2300      	movs	r3, #0
 800f194:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
            }
            if(LV_RESULT_INVALID == accelerated) {
 800f198:	f897 303b 	ldrb.w	r3, [r7, #59]	@ 0x3b
 800f19c:	2b00      	cmp	r3, #0
 800f19e:	f040 81e1 	bne.w	800f564 <rgb565_image_blend+0x440>
                color_argb.alpha = opa;
 800f1a2:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800f1a6:	77fb      	strb	r3, [r7, #31]
                for(y = 0; y < h; y++) {
 800f1a8:	2300      	movs	r3, #0
 800f1aa:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800f1ac:	e064      	b.n	800f278 <rgb565_image_blend+0x154>
                    for(x = 0; x < w; x++) {
 800f1ae:	2300      	movs	r3, #0
 800f1b0:	643b      	str	r3, [r7, #64]	@ 0x40
 800f1b2:	e04e      	b.n	800f252 <rgb565_image_blend+0x12e>
                        color_argb.red = (src_buf_c16[x].red * 2106) >> 8;  /*To make it rounded*/
 800f1b4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f1b6:	005b      	lsls	r3, r3, #1
 800f1b8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f1ba:	4413      	add	r3, r2
 800f1bc:	785b      	ldrb	r3, [r3, #1]
 800f1be:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 800f1c2:	b2db      	uxtb	r3, r3
 800f1c4:	461a      	mov	r2, r3
 800f1c6:	f640 033a 	movw	r3, #2106	@ 0x83a
 800f1ca:	fb02 f303 	mul.w	r3, r2, r3
 800f1ce:	121b      	asrs	r3, r3, #8
 800f1d0:	b2db      	uxtb	r3, r3
 800f1d2:	77bb      	strb	r3, [r7, #30]
                        color_argb.green = (src_buf_c16[x].green * 1037) >> 8;
 800f1d4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f1d6:	005b      	lsls	r3, r3, #1
 800f1d8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f1da:	4413      	add	r3, r2
 800f1dc:	881b      	ldrh	r3, [r3, #0]
 800f1de:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800f1e2:	b2db      	uxtb	r3, r3
 800f1e4:	461a      	mov	r2, r3
 800f1e6:	f240 430d 	movw	r3, #1037	@ 0x40d
 800f1ea:	fb02 f303 	mul.w	r3, r2, r3
 800f1ee:	121b      	asrs	r3, r3, #8
 800f1f0:	b2db      	uxtb	r3, r3
 800f1f2:	777b      	strb	r3, [r7, #29]
                        color_argb.blue = (src_buf_c16[x].blue * 2106) >> 8;
 800f1f4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f1f6:	005b      	lsls	r3, r3, #1
 800f1f8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f1fa:	4413      	add	r3, r2
 800f1fc:	781b      	ldrb	r3, [r3, #0]
 800f1fe:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800f202:	b2db      	uxtb	r3, r3
 800f204:	461a      	mov	r2, r3
 800f206:	f640 033a 	movw	r3, #2106	@ 0x83a
 800f20a:	fb02 f303 	mul.w	r3, r2, r3
 800f20e:	121b      	asrs	r3, r3, #8
 800f210:	b2db      	uxtb	r3, r3
 800f212:	773b      	strb	r3, [r7, #28]
                        dest_buf_c32[x] = lv_color_32_32_mix(color_argb, dest_buf_c32[x], &cache);
 800f214:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f216:	009b      	lsls	r3, r3, #2
 800f218:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f21a:	4413      	add	r3, r2
 800f21c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f21e:	0092      	lsls	r2, r2, #2
 800f220:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 800f222:	188c      	adds	r4, r1, r2
 800f224:	f107 020c 	add.w	r2, r7, #12
 800f228:	6819      	ldr	r1, [r3, #0]
 800f22a:	460b      	mov	r3, r1
 800f22c:	4619      	mov	r1, r3
 800f22e:	69f8      	ldr	r0, [r7, #28]
 800f230:	f000 fdbb 	bl	800fdaa <lv_color_32_32_mix>
 800f234:	4603      	mov	r3, r0
 800f236:	461a      	mov	r2, r3
 800f238:	7022      	strb	r2, [r4, #0]
 800f23a:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800f23e:	7062      	strb	r2, [r4, #1]
 800f240:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800f244:	70a2      	strb	r2, [r4, #2]
 800f246:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800f24a:	70e3      	strb	r3, [r4, #3]
                    for(x = 0; x < w; x++) {
 800f24c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f24e:	3301      	adds	r3, #1
 800f250:	643b      	str	r3, [r7, #64]	@ 0x40
 800f252:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f254:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f256:	429a      	cmp	r2, r3
 800f258:	dbac      	blt.n	800f1b4 <rgb565_image_blend+0x90>
                    }
                    dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800f25a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f25c:	4619      	mov	r1, r3
 800f25e:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 800f260:	f000 fee2 	bl	8010028 <drawbuf_next_row>
 800f264:	64f8      	str	r0, [r7, #76]	@ 0x4c
                    src_buf_c16 = drawbuf_next_row(src_buf_c16, src_stride);
 800f266:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f268:	4619      	mov	r1, r3
 800f26a:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 800f26c:	f000 fedc 	bl	8010028 <drawbuf_next_row>
 800f270:	64b8      	str	r0, [r7, #72]	@ 0x48
                for(y = 0; y < h; y++) {
 800f272:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f274:	3301      	adds	r3, #1
 800f276:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800f278:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f27a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f27c:	429a      	cmp	r2, r3
 800f27e:	db96      	blt.n	800f1ae <rgb565_image_blend+0x8a>
            if(mask_buf) mask_buf += mask_stride;
            dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
            src_buf_c16 = drawbuf_next_row(src_buf_c16, src_stride);
        }
    }
}
 800f280:	e170      	b.n	800f564 <rgb565_image_blend+0x440>
        else if(mask_buf && opa >= LV_OPA_MAX) {
 800f282:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f284:	2b00      	cmp	r3, #0
 800f286:	d079      	beq.n	800f37c <rgb565_image_blend+0x258>
 800f288:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800f28c:	2bfc      	cmp	r3, #252	@ 0xfc
 800f28e:	d975      	bls.n	800f37c <rgb565_image_blend+0x258>
                for(y = 0; y < h; y++) {
 800f290:	2300      	movs	r3, #0
 800f292:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800f294:	e06d      	b.n	800f372 <rgb565_image_blend+0x24e>
                    for(x = 0; x < w; x++) {
 800f296:	2300      	movs	r3, #0
 800f298:	643b      	str	r3, [r7, #64]	@ 0x40
 800f29a:	e053      	b.n	800f344 <rgb565_image_blend+0x220>
                        color_argb.alpha = mask_buf[x];
 800f29c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f29e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f2a0:	4413      	add	r3, r2
 800f2a2:	781b      	ldrb	r3, [r3, #0]
 800f2a4:	77fb      	strb	r3, [r7, #31]
                        color_argb.red = (src_buf_c16[x].red * 2106) >> 8;  /*To make it rounded*/
 800f2a6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f2a8:	005b      	lsls	r3, r3, #1
 800f2aa:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f2ac:	4413      	add	r3, r2
 800f2ae:	785b      	ldrb	r3, [r3, #1]
 800f2b0:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 800f2b4:	b2db      	uxtb	r3, r3
 800f2b6:	461a      	mov	r2, r3
 800f2b8:	f640 033a 	movw	r3, #2106	@ 0x83a
 800f2bc:	fb02 f303 	mul.w	r3, r2, r3
 800f2c0:	121b      	asrs	r3, r3, #8
 800f2c2:	b2db      	uxtb	r3, r3
 800f2c4:	77bb      	strb	r3, [r7, #30]
                        color_argb.green = (src_buf_c16[x].green * 1037) >> 8;
 800f2c6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f2c8:	005b      	lsls	r3, r3, #1
 800f2ca:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f2cc:	4413      	add	r3, r2
 800f2ce:	881b      	ldrh	r3, [r3, #0]
 800f2d0:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800f2d4:	b2db      	uxtb	r3, r3
 800f2d6:	461a      	mov	r2, r3
 800f2d8:	f240 430d 	movw	r3, #1037	@ 0x40d
 800f2dc:	fb02 f303 	mul.w	r3, r2, r3
 800f2e0:	121b      	asrs	r3, r3, #8
 800f2e2:	b2db      	uxtb	r3, r3
 800f2e4:	777b      	strb	r3, [r7, #29]
                        color_argb.blue = (src_buf_c16[x].blue * 2106) >> 8;
 800f2e6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f2e8:	005b      	lsls	r3, r3, #1
 800f2ea:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f2ec:	4413      	add	r3, r2
 800f2ee:	781b      	ldrb	r3, [r3, #0]
 800f2f0:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800f2f4:	b2db      	uxtb	r3, r3
 800f2f6:	461a      	mov	r2, r3
 800f2f8:	f640 033a 	movw	r3, #2106	@ 0x83a
 800f2fc:	fb02 f303 	mul.w	r3, r2, r3
 800f300:	121b      	asrs	r3, r3, #8
 800f302:	b2db      	uxtb	r3, r3
 800f304:	773b      	strb	r3, [r7, #28]
                        dest_buf_c32[x] = lv_color_32_32_mix(color_argb, dest_buf_c32[x], &cache);
 800f306:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f308:	009b      	lsls	r3, r3, #2
 800f30a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f30c:	4413      	add	r3, r2
 800f30e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f310:	0092      	lsls	r2, r2, #2
 800f312:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 800f314:	188c      	adds	r4, r1, r2
 800f316:	f107 020c 	add.w	r2, r7, #12
 800f31a:	6819      	ldr	r1, [r3, #0]
 800f31c:	460b      	mov	r3, r1
 800f31e:	4619      	mov	r1, r3
 800f320:	69f8      	ldr	r0, [r7, #28]
 800f322:	f000 fd42 	bl	800fdaa <lv_color_32_32_mix>
 800f326:	4603      	mov	r3, r0
 800f328:	461a      	mov	r2, r3
 800f32a:	7022      	strb	r2, [r4, #0]
 800f32c:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800f330:	7062      	strb	r2, [r4, #1]
 800f332:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800f336:	70a2      	strb	r2, [r4, #2]
 800f338:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800f33c:	70e3      	strb	r3, [r4, #3]
                    for(x = 0; x < w; x++) {
 800f33e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f340:	3301      	adds	r3, #1
 800f342:	643b      	str	r3, [r7, #64]	@ 0x40
 800f344:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f346:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f348:	429a      	cmp	r2, r3
 800f34a:	dba7      	blt.n	800f29c <rgb565_image_blend+0x178>
                    dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800f34c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f34e:	4619      	mov	r1, r3
 800f350:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 800f352:	f000 fe69 	bl	8010028 <drawbuf_next_row>
 800f356:	64f8      	str	r0, [r7, #76]	@ 0x4c
                    src_buf_c16 = drawbuf_next_row(src_buf_c16, src_stride);
 800f358:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f35a:	4619      	mov	r1, r3
 800f35c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 800f35e:	f000 fe63 	bl	8010028 <drawbuf_next_row>
 800f362:	64b8      	str	r0, [r7, #72]	@ 0x48
                    mask_buf += mask_stride;
 800f364:	6a3b      	ldr	r3, [r7, #32]
 800f366:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f368:	4413      	add	r3, r2
 800f36a:	647b      	str	r3, [r7, #68]	@ 0x44
                for(y = 0; y < h; y++) {
 800f36c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f36e:	3301      	adds	r3, #1
 800f370:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800f372:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f374:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f376:	429a      	cmp	r2, r3
 800f378:	db8d      	blt.n	800f296 <rgb565_image_blend+0x172>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_ARGB8888_WITH_MASK(dsc)) {
 800f37a:	e0f3      	b.n	800f564 <rgb565_image_blend+0x440>
                for(y = 0; y < h; y++) {
 800f37c:	2300      	movs	r3, #0
 800f37e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800f380:	e074      	b.n	800f46c <rgb565_image_blend+0x348>
                    for(x = 0; x < w; x++) {
 800f382:	2300      	movs	r3, #0
 800f384:	643b      	str	r3, [r7, #64]	@ 0x40
 800f386:	e05a      	b.n	800f43e <rgb565_image_blend+0x31a>
                        color_argb.alpha = LV_OPA_MIX2(mask_buf[x], opa);
 800f388:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f38a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f38c:	4413      	add	r3, r2
 800f38e:	781b      	ldrb	r3, [r3, #0]
 800f390:	461a      	mov	r2, r3
 800f392:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800f396:	fb02 f303 	mul.w	r3, r2, r3
 800f39a:	121b      	asrs	r3, r3, #8
 800f39c:	b2db      	uxtb	r3, r3
 800f39e:	77fb      	strb	r3, [r7, #31]
                        color_argb.red = (src_buf_c16[x].red * 2106) >> 8;  /*To make it rounded*/
 800f3a0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f3a2:	005b      	lsls	r3, r3, #1
 800f3a4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f3a6:	4413      	add	r3, r2
 800f3a8:	785b      	ldrb	r3, [r3, #1]
 800f3aa:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 800f3ae:	b2db      	uxtb	r3, r3
 800f3b0:	461a      	mov	r2, r3
 800f3b2:	f640 033a 	movw	r3, #2106	@ 0x83a
 800f3b6:	fb02 f303 	mul.w	r3, r2, r3
 800f3ba:	121b      	asrs	r3, r3, #8
 800f3bc:	b2db      	uxtb	r3, r3
 800f3be:	77bb      	strb	r3, [r7, #30]
                        color_argb.green = (src_buf_c16[x].green * 1037) >> 8;
 800f3c0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f3c2:	005b      	lsls	r3, r3, #1
 800f3c4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f3c6:	4413      	add	r3, r2
 800f3c8:	881b      	ldrh	r3, [r3, #0]
 800f3ca:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800f3ce:	b2db      	uxtb	r3, r3
 800f3d0:	461a      	mov	r2, r3
 800f3d2:	f240 430d 	movw	r3, #1037	@ 0x40d
 800f3d6:	fb02 f303 	mul.w	r3, r2, r3
 800f3da:	121b      	asrs	r3, r3, #8
 800f3dc:	b2db      	uxtb	r3, r3
 800f3de:	777b      	strb	r3, [r7, #29]
                        color_argb.blue = (src_buf_c16[x].blue * 2106) >> 8;
 800f3e0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f3e2:	005b      	lsls	r3, r3, #1
 800f3e4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f3e6:	4413      	add	r3, r2
 800f3e8:	781b      	ldrb	r3, [r3, #0]
 800f3ea:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800f3ee:	b2db      	uxtb	r3, r3
 800f3f0:	461a      	mov	r2, r3
 800f3f2:	f640 033a 	movw	r3, #2106	@ 0x83a
 800f3f6:	fb02 f303 	mul.w	r3, r2, r3
 800f3fa:	121b      	asrs	r3, r3, #8
 800f3fc:	b2db      	uxtb	r3, r3
 800f3fe:	773b      	strb	r3, [r7, #28]
                        dest_buf_c32[x] = lv_color_32_32_mix(color_argb, dest_buf_c32[x], &cache);
 800f400:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f402:	009b      	lsls	r3, r3, #2
 800f404:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f406:	4413      	add	r3, r2
 800f408:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f40a:	0092      	lsls	r2, r2, #2
 800f40c:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 800f40e:	188c      	adds	r4, r1, r2
 800f410:	f107 020c 	add.w	r2, r7, #12
 800f414:	6819      	ldr	r1, [r3, #0]
 800f416:	460b      	mov	r3, r1
 800f418:	4619      	mov	r1, r3
 800f41a:	69f8      	ldr	r0, [r7, #28]
 800f41c:	f000 fcc5 	bl	800fdaa <lv_color_32_32_mix>
 800f420:	4603      	mov	r3, r0
 800f422:	461a      	mov	r2, r3
 800f424:	7022      	strb	r2, [r4, #0]
 800f426:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800f42a:	7062      	strb	r2, [r4, #1]
 800f42c:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800f430:	70a2      	strb	r2, [r4, #2]
 800f432:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800f436:	70e3      	strb	r3, [r4, #3]
                    for(x = 0; x < w; x++) {
 800f438:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f43a:	3301      	adds	r3, #1
 800f43c:	643b      	str	r3, [r7, #64]	@ 0x40
 800f43e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f440:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f442:	429a      	cmp	r2, r3
 800f444:	dba0      	blt.n	800f388 <rgb565_image_blend+0x264>
                    dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800f446:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f448:	4619      	mov	r1, r3
 800f44a:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 800f44c:	f000 fdec 	bl	8010028 <drawbuf_next_row>
 800f450:	64f8      	str	r0, [r7, #76]	@ 0x4c
                    src_buf_c16 = drawbuf_next_row(src_buf_c16, src_stride);
 800f452:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f454:	4619      	mov	r1, r3
 800f456:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 800f458:	f000 fde6 	bl	8010028 <drawbuf_next_row>
 800f45c:	64b8      	str	r0, [r7, #72]	@ 0x48
                    mask_buf += mask_stride;
 800f45e:	6a3b      	ldr	r3, [r7, #32]
 800f460:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f462:	4413      	add	r3, r2
 800f464:	647b      	str	r3, [r7, #68]	@ 0x44
                for(y = 0; y < h; y++) {
 800f466:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f468:	3301      	adds	r3, #1
 800f46a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800f46c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f46e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f470:	429a      	cmp	r2, r3
 800f472:	db86      	blt.n	800f382 <rgb565_image_blend+0x25e>
}
 800f474:	e076      	b.n	800f564 <rgb565_image_blend+0x440>
        for(y = 0; y < h; y++) {
 800f476:	2300      	movs	r3, #0
 800f478:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800f47a:	e06e      	b.n	800f55a <rgb565_image_blend+0x436>
            for(x = 0; x < w; x++) {
 800f47c:	2300      	movs	r3, #0
 800f47e:	643b      	str	r3, [r7, #64]	@ 0x40
 800f480:	e051      	b.n	800f526 <rgb565_image_blend+0x402>
                src_argb.red = (src_buf_c16[x].red * 2106) >> 8;
 800f482:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f484:	005b      	lsls	r3, r3, #1
 800f486:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f488:	4413      	add	r3, r2
 800f48a:	785b      	ldrb	r3, [r3, #1]
 800f48c:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 800f490:	b2db      	uxtb	r3, r3
 800f492:	461a      	mov	r2, r3
 800f494:	f640 033a 	movw	r3, #2106	@ 0x83a
 800f498:	fb02 f303 	mul.w	r3, r2, r3
 800f49c:	121b      	asrs	r3, r3, #8
 800f49e:	b2db      	uxtb	r3, r3
 800f4a0:	72bb      	strb	r3, [r7, #10]
                src_argb.green = (src_buf_c16[x].green * 1037) >> 8;
 800f4a2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f4a4:	005b      	lsls	r3, r3, #1
 800f4a6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f4a8:	4413      	add	r3, r2
 800f4aa:	881b      	ldrh	r3, [r3, #0]
 800f4ac:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800f4b0:	b2db      	uxtb	r3, r3
 800f4b2:	461a      	mov	r2, r3
 800f4b4:	f240 430d 	movw	r3, #1037	@ 0x40d
 800f4b8:	fb02 f303 	mul.w	r3, r2, r3
 800f4bc:	121b      	asrs	r3, r3, #8
 800f4be:	b2db      	uxtb	r3, r3
 800f4c0:	727b      	strb	r3, [r7, #9]
                src_argb.blue = (src_buf_c16[x].blue * 2106) >> 8;
 800f4c2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f4c4:	005b      	lsls	r3, r3, #1
 800f4c6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f4c8:	4413      	add	r3, r2
 800f4ca:	781b      	ldrb	r3, [r3, #0]
 800f4cc:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800f4d0:	b2db      	uxtb	r3, r3
 800f4d2:	461a      	mov	r2, r3
 800f4d4:	f640 033a 	movw	r3, #2106	@ 0x83a
 800f4d8:	fb02 f303 	mul.w	r3, r2, r3
 800f4dc:	121b      	asrs	r3, r3, #8
 800f4de:	b2db      	uxtb	r3, r3
 800f4e0:	723b      	strb	r3, [r7, #8]
                if(mask_buf == NULL) src_argb.alpha = opa;
 800f4e2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f4e4:	2b00      	cmp	r3, #0
 800f4e6:	d103      	bne.n	800f4f0 <rgb565_image_blend+0x3cc>
 800f4e8:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800f4ec:	72fb      	strb	r3, [r7, #11]
 800f4ee:	e00b      	b.n	800f508 <rgb565_image_blend+0x3e4>
                else src_argb.alpha = LV_OPA_MIX2(mask_buf[x], opa);
 800f4f0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f4f2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f4f4:	4413      	add	r3, r2
 800f4f6:	781b      	ldrb	r3, [r3, #0]
 800f4f8:	461a      	mov	r2, r3
 800f4fa:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800f4fe:	fb02 f303 	mul.w	r3, r2, r3
 800f502:	121b      	asrs	r3, r3, #8
 800f504:	b2db      	uxtb	r3, r3
 800f506:	72fb      	strb	r3, [r7, #11]
                blend_non_normal_pixel(&dest_buf_c32[x], src_argb, dsc->blend_mode, &cache);
 800f508:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f50a:	009b      	lsls	r3, r3, #2
 800f50c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f50e:	18d0      	adds	r0, r2, r3
 800f510:	687b      	ldr	r3, [r7, #4]
 800f512:	f893 2022 	ldrb.w	r2, [r3, #34]	@ 0x22
 800f516:	f107 030c 	add.w	r3, r7, #12
 800f51a:	68b9      	ldr	r1, [r7, #8]
 800f51c:	f000 fd02 	bl	800ff24 <blend_non_normal_pixel>
            for(x = 0; x < w; x++) {
 800f520:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f522:	3301      	adds	r3, #1
 800f524:	643b      	str	r3, [r7, #64]	@ 0x40
 800f526:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f528:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f52a:	429a      	cmp	r2, r3
 800f52c:	dba9      	blt.n	800f482 <rgb565_image_blend+0x35e>
            if(mask_buf) mask_buf += mask_stride;
 800f52e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f530:	2b00      	cmp	r3, #0
 800f532:	d003      	beq.n	800f53c <rgb565_image_blend+0x418>
 800f534:	6a3b      	ldr	r3, [r7, #32]
 800f536:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f538:	4413      	add	r3, r2
 800f53a:	647b      	str	r3, [r7, #68]	@ 0x44
            dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800f53c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f53e:	4619      	mov	r1, r3
 800f540:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 800f542:	f000 fd71 	bl	8010028 <drawbuf_next_row>
 800f546:	64f8      	str	r0, [r7, #76]	@ 0x4c
            src_buf_c16 = drawbuf_next_row(src_buf_c16, src_stride);
 800f548:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f54a:	4619      	mov	r1, r3
 800f54c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 800f54e:	f000 fd6b 	bl	8010028 <drawbuf_next_row>
 800f552:	64b8      	str	r0, [r7, #72]	@ 0x48
        for(y = 0; y < h; y++) {
 800f554:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f556:	3301      	adds	r3, #1
 800f558:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800f55a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f55c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f55e:	429a      	cmp	r2, r3
 800f560:	db8c      	blt.n	800f47c <rgb565_image_blend+0x358>
}
 800f562:	e7ff      	b.n	800f564 <rgb565_image_blend+0x440>
 800f564:	bf00      	nop
 800f566:	3754      	adds	r7, #84	@ 0x54
 800f568:	46bd      	mov	sp, r7
 800f56a:	bd90      	pop	{r4, r7, pc}

0800f56c <rgb888_image_blend>:

static void LV_ATTRIBUTE_FAST_MEM rgb888_image_blend(_lv_draw_sw_blend_image_dsc_t * dsc, const uint8_t src_px_size)
{
 800f56c:	b590      	push	{r4, r7, lr}
 800f56e:	b097      	sub	sp, #92	@ 0x5c
 800f570:	af00      	add	r7, sp, #0
 800f572:	6078      	str	r0, [r7, #4]
 800f574:	460b      	mov	r3, r1
 800f576:	70fb      	strb	r3, [r7, #3]

    int32_t w = dsc->dest_w;
 800f578:	687b      	ldr	r3, [r7, #4]
 800f57a:	685b      	ldr	r3, [r3, #4]
 800f57c:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int32_t h = dsc->dest_h;
 800f57e:	687b      	ldr	r3, [r7, #4]
 800f580:	689b      	ldr	r3, [r3, #8]
 800f582:	63bb      	str	r3, [r7, #56]	@ 0x38
    lv_opa_t opa = dsc->opa;
 800f584:	687b      	ldr	r3, [r7, #4]
 800f586:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 800f58a:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
    lv_color32_t * dest_buf_c32 = dsc->dest_buf;
 800f58e:	687b      	ldr	r3, [r7, #4]
 800f590:	681b      	ldr	r3, [r3, #0]
 800f592:	657b      	str	r3, [r7, #84]	@ 0x54
    int32_t dest_stride = dsc->dest_stride;
 800f594:	687b      	ldr	r3, [r7, #4]
 800f596:	68db      	ldr	r3, [r3, #12]
 800f598:	633b      	str	r3, [r7, #48]	@ 0x30
    const uint8_t * src_buf = dsc->src_buf;
 800f59a:	687b      	ldr	r3, [r7, #4]
 800f59c:	699b      	ldr	r3, [r3, #24]
 800f59e:	653b      	str	r3, [r7, #80]	@ 0x50
    int32_t src_stride = dsc->src_stride;
 800f5a0:	687b      	ldr	r3, [r7, #4]
 800f5a2:	69db      	ldr	r3, [r3, #28]
 800f5a4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    const lv_opa_t * mask_buf = dsc->mask_buf;
 800f5a6:	687b      	ldr	r3, [r7, #4]
 800f5a8:	691b      	ldr	r3, [r3, #16]
 800f5aa:	64fb      	str	r3, [r7, #76]	@ 0x4c
    int32_t mask_stride = dsc->mask_stride;
 800f5ac:	687b      	ldr	r3, [r7, #4]
 800f5ae:	695b      	ldr	r3, [r3, #20]
 800f5b0:	62bb      	str	r3, [r7, #40]	@ 0x28

    lv_color32_t color_argb;
    lv_color_mix_alpha_cache_t cache;
    lv_color_mix_with_alpha_cache_init(&cache);
 800f5b2:	f107 0310 	add.w	r3, r7, #16
 800f5b6:	4618      	mov	r0, r3
 800f5b8:	f000 fc95 	bl	800fee6 <lv_color_mix_with_alpha_cache_init>
    int32_t src_x;
    int32_t y;

    LV_UNUSED(color_argb);

    if(dsc->blend_mode == LV_BLEND_MODE_NORMAL) {
 800f5bc:	687b      	ldr	r3, [r7, #4]
 800f5be:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 800f5c2:	2b00      	cmp	r3, #0
 800f5c4:	f040 81ac 	bne.w	800f920 <rgb888_image_blend+0x3b4>
        /*Special case*/
        if(mask_buf == NULL && opa >= LV_OPA_MAX) {
 800f5c8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f5ca:	2b00      	cmp	r3, #0
 800f5cc:	d170      	bne.n	800f6b0 <rgb888_image_blend+0x144>
 800f5ce:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800f5d2:	2bfc      	cmp	r3, #252	@ 0xfc
 800f5d4:	d96c      	bls.n	800f6b0 <rgb888_image_blend+0x144>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_ARGB8888(dsc, src_px_size)) {
                if(src_px_size == 4) {
 800f5d6:	78fb      	ldrb	r3, [r7, #3]
 800f5d8:	2b04      	cmp	r3, #4
 800f5da:	d11e      	bne.n	800f61a <rgb888_image_blend+0xae>
                    uint32_t line_in_bytes = w * 4;
 800f5dc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f5de:	009b      	lsls	r3, r3, #2
 800f5e0:	627b      	str	r3, [r7, #36]	@ 0x24
                    for(y = 0; y < h; y++) {
 800f5e2:	2300      	movs	r3, #0
 800f5e4:	643b      	str	r3, [r7, #64]	@ 0x40
 800f5e6:	e013      	b.n	800f610 <rgb888_image_blend+0xa4>
                        lv_memcpy(dest_buf_c32, src_buf, line_in_bytes);
 800f5e8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800f5ea:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 800f5ec:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 800f5ee:	f015 f9fb 	bl	80249e8 <lv_memcpy>
                        dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800f5f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f5f4:	4619      	mov	r1, r3
 800f5f6:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 800f5f8:	f000 fd16 	bl	8010028 <drawbuf_next_row>
 800f5fc:	6578      	str	r0, [r7, #84]	@ 0x54
                        src_buf = drawbuf_next_row(src_buf, src_stride);
 800f5fe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f600:	4619      	mov	r1, r3
 800f602:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 800f604:	f000 fd10 	bl	8010028 <drawbuf_next_row>
 800f608:	6538      	str	r0, [r7, #80]	@ 0x50
                    for(y = 0; y < h; y++) {
 800f60a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f60c:	3301      	adds	r3, #1
 800f60e:	643b      	str	r3, [r7, #64]	@ 0x40
 800f610:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f612:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f614:	429a      	cmp	r2, r3
 800f616:	dbe7      	blt.n	800f5e8 <rgb888_image_blend+0x7c>
 800f618:	e04a      	b.n	800f6b0 <rgb888_image_blend+0x144>
                    }
                }
                else if(src_px_size == 3) {
 800f61a:	78fb      	ldrb	r3, [r7, #3]
 800f61c:	2b03      	cmp	r3, #3
 800f61e:	d147      	bne.n	800f6b0 <rgb888_image_blend+0x144>
                    for(y = 0; y < h; y++) {
 800f620:	2300      	movs	r3, #0
 800f622:	643b      	str	r3, [r7, #64]	@ 0x40
 800f624:	e040      	b.n	800f6a8 <rgb888_image_blend+0x13c>
                        for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += 3) {
 800f626:	2300      	movs	r3, #0
 800f628:	64bb      	str	r3, [r7, #72]	@ 0x48
 800f62a:	2300      	movs	r3, #0
 800f62c:	647b      	str	r3, [r7, #68]	@ 0x44
 800f62e:	e028      	b.n	800f682 <rgb888_image_blend+0x116>
                            dest_buf_c32[dest_x].red = src_buf[src_x + 2];
 800f630:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f632:	3302      	adds	r3, #2
 800f634:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f636:	441a      	add	r2, r3
 800f638:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f63a:	009b      	lsls	r3, r3, #2
 800f63c:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 800f63e:	440b      	add	r3, r1
 800f640:	7812      	ldrb	r2, [r2, #0]
 800f642:	709a      	strb	r2, [r3, #2]
                            dest_buf_c32[dest_x].green = src_buf[src_x + 1];
 800f644:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f646:	3301      	adds	r3, #1
 800f648:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f64a:	441a      	add	r2, r3
 800f64c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f64e:	009b      	lsls	r3, r3, #2
 800f650:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 800f652:	440b      	add	r3, r1
 800f654:	7812      	ldrb	r2, [r2, #0]
 800f656:	705a      	strb	r2, [r3, #1]
                            dest_buf_c32[dest_x].blue = src_buf[src_x + 0];
 800f658:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f65a:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f65c:	441a      	add	r2, r3
 800f65e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f660:	009b      	lsls	r3, r3, #2
 800f662:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 800f664:	440b      	add	r3, r1
 800f666:	7812      	ldrb	r2, [r2, #0]
 800f668:	701a      	strb	r2, [r3, #0]
                            dest_buf_c32[dest_x].alpha = 0xff;
 800f66a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f66c:	009b      	lsls	r3, r3, #2
 800f66e:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f670:	4413      	add	r3, r2
 800f672:	22ff      	movs	r2, #255	@ 0xff
 800f674:	70da      	strb	r2, [r3, #3]
                        for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += 3) {
 800f676:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f678:	3301      	adds	r3, #1
 800f67a:	64bb      	str	r3, [r7, #72]	@ 0x48
 800f67c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f67e:	3303      	adds	r3, #3
 800f680:	647b      	str	r3, [r7, #68]	@ 0x44
 800f682:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f684:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f686:	429a      	cmp	r2, r3
 800f688:	dbd2      	blt.n	800f630 <rgb888_image_blend+0xc4>
                        }
                        dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800f68a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f68c:	4619      	mov	r1, r3
 800f68e:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 800f690:	f000 fcca 	bl	8010028 <drawbuf_next_row>
 800f694:	6578      	str	r0, [r7, #84]	@ 0x54
                        src_buf = drawbuf_next_row(src_buf, src_stride);
 800f696:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f698:	4619      	mov	r1, r3
 800f69a:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 800f69c:	f000 fcc4 	bl	8010028 <drawbuf_next_row>
 800f6a0:	6538      	str	r0, [r7, #80]	@ 0x50
                    for(y = 0; y < h; y++) {
 800f6a2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f6a4:	3301      	adds	r3, #1
 800f6a6:	643b      	str	r3, [r7, #64]	@ 0x40
 800f6a8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f6aa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f6ac:	429a      	cmp	r2, r3
 800f6ae:	dbba      	blt.n	800f626 <rgb888_image_blend+0xba>
                    }
                }
            }

        }
        if(mask_buf == NULL && opa < LV_OPA_MAX) {
 800f6b0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f6b2:	2b00      	cmp	r3, #0
 800f6b4:	d15d      	bne.n	800f772 <rgb888_image_blend+0x206>
 800f6b6:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800f6ba:	2bfc      	cmp	r3, #252	@ 0xfc
 800f6bc:	d859      	bhi.n	800f772 <rgb888_image_blend+0x206>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_ARGB8888_WITH_OPA(dsc, src_px_size)) {
                color_argb.alpha = opa;
 800f6be:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800f6c2:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
                for(y = 0; y < h; y++) {
 800f6c6:	2300      	movs	r3, #0
 800f6c8:	643b      	str	r3, [r7, #64]	@ 0x40
 800f6ca:	e04e      	b.n	800f76a <rgb888_image_blend+0x1fe>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 800f6cc:	2300      	movs	r3, #0
 800f6ce:	64bb      	str	r3, [r7, #72]	@ 0x48
 800f6d0:	2300      	movs	r3, #0
 800f6d2:	647b      	str	r3, [r7, #68]	@ 0x44
 800f6d4:	e036      	b.n	800f744 <rgb888_image_blend+0x1d8>
                        color_argb.red = src_buf[src_x + 2];
 800f6d6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f6d8:	3302      	adds	r3, #2
 800f6da:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f6dc:	4413      	add	r3, r2
 800f6de:	781b      	ldrb	r3, [r3, #0]
 800f6e0:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22
                        color_argb.green = src_buf[src_x + 1];
 800f6e4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f6e6:	3301      	adds	r3, #1
 800f6e8:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f6ea:	4413      	add	r3, r2
 800f6ec:	781b      	ldrb	r3, [r3, #0]
 800f6ee:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
                        color_argb.blue = src_buf[src_x + 0];
 800f6f2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f6f4:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f6f6:	4413      	add	r3, r2
 800f6f8:	781b      	ldrb	r3, [r3, #0]
 800f6fa:	f887 3020 	strb.w	r3, [r7, #32]
                        dest_buf_c32[dest_x] = lv_color_32_32_mix(color_argb, dest_buf_c32[dest_x], &cache);
 800f6fe:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f700:	009b      	lsls	r3, r3, #2
 800f702:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f704:	4413      	add	r3, r2
 800f706:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f708:	0092      	lsls	r2, r2, #2
 800f70a:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 800f70c:	188c      	adds	r4, r1, r2
 800f70e:	f107 0210 	add.w	r2, r7, #16
 800f712:	6819      	ldr	r1, [r3, #0]
 800f714:	460b      	mov	r3, r1
 800f716:	4619      	mov	r1, r3
 800f718:	6a38      	ldr	r0, [r7, #32]
 800f71a:	f000 fb46 	bl	800fdaa <lv_color_32_32_mix>
 800f71e:	4603      	mov	r3, r0
 800f720:	461a      	mov	r2, r3
 800f722:	7022      	strb	r2, [r4, #0]
 800f724:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800f728:	7062      	strb	r2, [r4, #1]
 800f72a:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800f72e:	70a2      	strb	r2, [r4, #2]
 800f730:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800f734:	70e3      	strb	r3, [r4, #3]
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 800f736:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f738:	3301      	adds	r3, #1
 800f73a:	64bb      	str	r3, [r7, #72]	@ 0x48
 800f73c:	78fb      	ldrb	r3, [r7, #3]
 800f73e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f740:	4413      	add	r3, r2
 800f742:	647b      	str	r3, [r7, #68]	@ 0x44
 800f744:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f746:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f748:	429a      	cmp	r2, r3
 800f74a:	dbc4      	blt.n	800f6d6 <rgb888_image_blend+0x16a>
                    }
                    dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800f74c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f74e:	4619      	mov	r1, r3
 800f750:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 800f752:	f000 fc69 	bl	8010028 <drawbuf_next_row>
 800f756:	6578      	str	r0, [r7, #84]	@ 0x54
                    src_buf = drawbuf_next_row(src_buf, src_stride);
 800f758:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f75a:	4619      	mov	r1, r3
 800f75c:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 800f75e:	f000 fc63 	bl	8010028 <drawbuf_next_row>
 800f762:	6538      	str	r0, [r7, #80]	@ 0x50
                for(y = 0; y < h; y++) {
 800f764:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f766:	3301      	adds	r3, #1
 800f768:	643b      	str	r3, [r7, #64]	@ 0x40
 800f76a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f76c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f76e:	429a      	cmp	r2, r3
 800f770:	dbac      	blt.n	800f6cc <rgb888_image_blend+0x160>
                }
            }

        }
        if(mask_buf && opa >= LV_OPA_MAX) {
 800f772:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f774:	2b00      	cmp	r3, #0
 800f776:	d063      	beq.n	800f840 <rgb888_image_blend+0x2d4>
 800f778:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800f77c:	2bfc      	cmp	r3, #252	@ 0xfc
 800f77e:	d95f      	bls.n	800f840 <rgb888_image_blend+0x2d4>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_ARGB8888_WITH_MASK(dsc, src_px_size)) {
                for(y = 0; y < h; y++) {
 800f780:	2300      	movs	r3, #0
 800f782:	643b      	str	r3, [r7, #64]	@ 0x40
 800f784:	e058      	b.n	800f838 <rgb888_image_blend+0x2cc>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 800f786:	2300      	movs	r3, #0
 800f788:	64bb      	str	r3, [r7, #72]	@ 0x48
 800f78a:	2300      	movs	r3, #0
 800f78c:	647b      	str	r3, [r7, #68]	@ 0x44
 800f78e:	e03c      	b.n	800f80a <rgb888_image_blend+0x29e>
                        color_argb.alpha = mask_buf[dest_x];
 800f790:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f792:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f794:	4413      	add	r3, r2
 800f796:	781b      	ldrb	r3, [r3, #0]
 800f798:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
                        color_argb.red = src_buf[src_x + 2];
 800f79c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f79e:	3302      	adds	r3, #2
 800f7a0:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f7a2:	4413      	add	r3, r2
 800f7a4:	781b      	ldrb	r3, [r3, #0]
 800f7a6:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22
                        color_argb.green = src_buf[src_x + 1];
 800f7aa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f7ac:	3301      	adds	r3, #1
 800f7ae:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f7b0:	4413      	add	r3, r2
 800f7b2:	781b      	ldrb	r3, [r3, #0]
 800f7b4:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
                        color_argb.blue = src_buf[src_x + 0];
 800f7b8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f7ba:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f7bc:	4413      	add	r3, r2
 800f7be:	781b      	ldrb	r3, [r3, #0]
 800f7c0:	f887 3020 	strb.w	r3, [r7, #32]
                        dest_buf_c32[dest_x] = lv_color_32_32_mix(color_argb, dest_buf_c32[dest_x], &cache);
 800f7c4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f7c6:	009b      	lsls	r3, r3, #2
 800f7c8:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f7ca:	4413      	add	r3, r2
 800f7cc:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f7ce:	0092      	lsls	r2, r2, #2
 800f7d0:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 800f7d2:	188c      	adds	r4, r1, r2
 800f7d4:	f107 0210 	add.w	r2, r7, #16
 800f7d8:	6819      	ldr	r1, [r3, #0]
 800f7da:	460b      	mov	r3, r1
 800f7dc:	4619      	mov	r1, r3
 800f7de:	6a38      	ldr	r0, [r7, #32]
 800f7e0:	f000 fae3 	bl	800fdaa <lv_color_32_32_mix>
 800f7e4:	4603      	mov	r3, r0
 800f7e6:	461a      	mov	r2, r3
 800f7e8:	7022      	strb	r2, [r4, #0]
 800f7ea:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800f7ee:	7062      	strb	r2, [r4, #1]
 800f7f0:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800f7f4:	70a2      	strb	r2, [r4, #2]
 800f7f6:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800f7fa:	70e3      	strb	r3, [r4, #3]
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 800f7fc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f7fe:	3301      	adds	r3, #1
 800f800:	64bb      	str	r3, [r7, #72]	@ 0x48
 800f802:	78fb      	ldrb	r3, [r7, #3]
 800f804:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f806:	4413      	add	r3, r2
 800f808:	647b      	str	r3, [r7, #68]	@ 0x44
 800f80a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f80c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f80e:	429a      	cmp	r2, r3
 800f810:	dbbe      	blt.n	800f790 <rgb888_image_blend+0x224>
                    }
                    dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800f812:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f814:	4619      	mov	r1, r3
 800f816:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 800f818:	f000 fc06 	bl	8010028 <drawbuf_next_row>
 800f81c:	6578      	str	r0, [r7, #84]	@ 0x54
                    src_buf = drawbuf_next_row(src_buf, src_stride);
 800f81e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f820:	4619      	mov	r1, r3
 800f822:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 800f824:	f000 fc00 	bl	8010028 <drawbuf_next_row>
 800f828:	6538      	str	r0, [r7, #80]	@ 0x50
                    mask_buf += mask_stride;
 800f82a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f82c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f82e:	4413      	add	r3, r2
 800f830:	64fb      	str	r3, [r7, #76]	@ 0x4c
                for(y = 0; y < h; y++) {
 800f832:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f834:	3301      	adds	r3, #1
 800f836:	643b      	str	r3, [r7, #64]	@ 0x40
 800f838:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f83a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f83c:	429a      	cmp	r2, r3
 800f83e:	dba2      	blt.n	800f786 <rgb888_image_blend+0x21a>
                }
            }
        }
        if(mask_buf && opa < LV_OPA_MAX) {
 800f840:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f842:	2b00      	cmp	r3, #0
 800f844:	f000 80c9 	beq.w	800f9da <rgb888_image_blend+0x46e>
 800f848:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800f84c:	2bfc      	cmp	r3, #252	@ 0xfc
 800f84e:	f200 80c4 	bhi.w	800f9da <rgb888_image_blend+0x46e>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_ARGB8888_MIX_MASK_OPA(dsc, src_px_size)) {
                for(y = 0; y < h; y++) {
 800f852:	2300      	movs	r3, #0
 800f854:	643b      	str	r3, [r7, #64]	@ 0x40
 800f856:	e05e      	b.n	800f916 <rgb888_image_blend+0x3aa>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 800f858:	2300      	movs	r3, #0
 800f85a:	64bb      	str	r3, [r7, #72]	@ 0x48
 800f85c:	2300      	movs	r3, #0
 800f85e:	647b      	str	r3, [r7, #68]	@ 0x44
 800f860:	e042      	b.n	800f8e8 <rgb888_image_blend+0x37c>
                        color_argb.alpha = (opa * mask_buf[dest_x]) >> 8;
 800f862:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800f866:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f868:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 800f86a:	440a      	add	r2, r1
 800f86c:	7812      	ldrb	r2, [r2, #0]
 800f86e:	fb02 f303 	mul.w	r3, r2, r3
 800f872:	121b      	asrs	r3, r3, #8
 800f874:	b2db      	uxtb	r3, r3
 800f876:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
                        color_argb.red = src_buf[src_x + 2];
 800f87a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f87c:	3302      	adds	r3, #2
 800f87e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f880:	4413      	add	r3, r2
 800f882:	781b      	ldrb	r3, [r3, #0]
 800f884:	f887 3022 	strb.w	r3, [r7, #34]	@ 0x22
                        color_argb.green = src_buf[src_x + 1];
 800f888:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f88a:	3301      	adds	r3, #1
 800f88c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f88e:	4413      	add	r3, r2
 800f890:	781b      	ldrb	r3, [r3, #0]
 800f892:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
                        color_argb.blue = src_buf[src_x + 0];
 800f896:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f898:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f89a:	4413      	add	r3, r2
 800f89c:	781b      	ldrb	r3, [r3, #0]
 800f89e:	f887 3020 	strb.w	r3, [r7, #32]
                        dest_buf_c32[dest_x] = lv_color_32_32_mix(color_argb, dest_buf_c32[dest_x], &cache);
 800f8a2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f8a4:	009b      	lsls	r3, r3, #2
 800f8a6:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f8a8:	4413      	add	r3, r2
 800f8aa:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f8ac:	0092      	lsls	r2, r2, #2
 800f8ae:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 800f8b0:	188c      	adds	r4, r1, r2
 800f8b2:	f107 0210 	add.w	r2, r7, #16
 800f8b6:	6819      	ldr	r1, [r3, #0]
 800f8b8:	460b      	mov	r3, r1
 800f8ba:	4619      	mov	r1, r3
 800f8bc:	6a38      	ldr	r0, [r7, #32]
 800f8be:	f000 fa74 	bl	800fdaa <lv_color_32_32_mix>
 800f8c2:	4603      	mov	r3, r0
 800f8c4:	461a      	mov	r2, r3
 800f8c6:	7022      	strb	r2, [r4, #0]
 800f8c8:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800f8cc:	7062      	strb	r2, [r4, #1]
 800f8ce:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800f8d2:	70a2      	strb	r2, [r4, #2]
 800f8d4:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800f8d8:	70e3      	strb	r3, [r4, #3]
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 800f8da:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f8dc:	3301      	adds	r3, #1
 800f8de:	64bb      	str	r3, [r7, #72]	@ 0x48
 800f8e0:	78fb      	ldrb	r3, [r7, #3]
 800f8e2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f8e4:	4413      	add	r3, r2
 800f8e6:	647b      	str	r3, [r7, #68]	@ 0x44
 800f8e8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f8ea:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f8ec:	429a      	cmp	r2, r3
 800f8ee:	dbb8      	blt.n	800f862 <rgb888_image_blend+0x2f6>
                    }
                    dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800f8f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f8f2:	4619      	mov	r1, r3
 800f8f4:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 800f8f6:	f000 fb97 	bl	8010028 <drawbuf_next_row>
 800f8fa:	6578      	str	r0, [r7, #84]	@ 0x54
                    src_buf = drawbuf_next_row(src_buf, src_stride);
 800f8fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f8fe:	4619      	mov	r1, r3
 800f900:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 800f902:	f000 fb91 	bl	8010028 <drawbuf_next_row>
 800f906:	6538      	str	r0, [r7, #80]	@ 0x50
                    mask_buf += mask_stride;
 800f908:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f90a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f90c:	4413      	add	r3, r2
 800f90e:	64fb      	str	r3, [r7, #76]	@ 0x4c
                for(y = 0; y < h; y++) {
 800f910:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f912:	3301      	adds	r3, #1
 800f914:	643b      	str	r3, [r7, #64]	@ 0x40
 800f916:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f918:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f91a:	429a      	cmp	r2, r3
 800f91c:	db9c      	blt.n	800f858 <rgb888_image_blend+0x2ec>
            if(mask_buf) mask_buf += mask_stride;
            dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
            src_buf = drawbuf_next_row(src_buf, src_stride);
        }
    }
}
 800f91e:	e05c      	b.n	800f9da <rgb888_image_blend+0x46e>
        for(y = 0; y < h; y++) {
 800f920:	2300      	movs	r3, #0
 800f922:	643b      	str	r3, [r7, #64]	@ 0x40
 800f924:	e055      	b.n	800f9d2 <rgb888_image_blend+0x466>
            for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 800f926:	2300      	movs	r3, #0
 800f928:	64bb      	str	r3, [r7, #72]	@ 0x48
 800f92a:	2300      	movs	r3, #0
 800f92c:	647b      	str	r3, [r7, #68]	@ 0x44
 800f92e:	e036      	b.n	800f99e <rgb888_image_blend+0x432>
                src_argb.red = src_buf[src_x + 2];
 800f930:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f932:	3302      	adds	r3, #2
 800f934:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f936:	4413      	add	r3, r2
 800f938:	781b      	ldrb	r3, [r3, #0]
 800f93a:	73bb      	strb	r3, [r7, #14]
                src_argb.green = src_buf[src_x + 1];
 800f93c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f93e:	3301      	adds	r3, #1
 800f940:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f942:	4413      	add	r3, r2
 800f944:	781b      	ldrb	r3, [r3, #0]
 800f946:	737b      	strb	r3, [r7, #13]
                src_argb.blue = src_buf[src_x + 0];
 800f948:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800f94a:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 800f94c:	4413      	add	r3, r2
 800f94e:	781b      	ldrb	r3, [r3, #0]
 800f950:	733b      	strb	r3, [r7, #12]
                if(mask_buf == NULL) src_argb.alpha = opa;
 800f952:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f954:	2b00      	cmp	r3, #0
 800f956:	d103      	bne.n	800f960 <rgb888_image_blend+0x3f4>
 800f958:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800f95c:	73fb      	strb	r3, [r7, #15]
 800f95e:	e00b      	b.n	800f978 <rgb888_image_blend+0x40c>
                else src_argb.alpha = LV_OPA_MIX2(mask_buf[dest_x], opa);
 800f960:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f962:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f964:	4413      	add	r3, r2
 800f966:	781b      	ldrb	r3, [r3, #0]
 800f968:	461a      	mov	r2, r3
 800f96a:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 800f96e:	fb02 f303 	mul.w	r3, r2, r3
 800f972:	121b      	asrs	r3, r3, #8
 800f974:	b2db      	uxtb	r3, r3
 800f976:	73fb      	strb	r3, [r7, #15]
                blend_non_normal_pixel(&dest_buf_c32[dest_x], src_argb, dsc->blend_mode, &cache);
 800f978:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f97a:	009b      	lsls	r3, r3, #2
 800f97c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 800f97e:	18d0      	adds	r0, r2, r3
 800f980:	687b      	ldr	r3, [r7, #4]
 800f982:	f893 2022 	ldrb.w	r2, [r3, #34]	@ 0x22
 800f986:	f107 0310 	add.w	r3, r7, #16
 800f98a:	68f9      	ldr	r1, [r7, #12]
 800f98c:	f000 faca 	bl	800ff24 <blend_non_normal_pixel>
            for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 800f990:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 800f992:	3301      	adds	r3, #1
 800f994:	64bb      	str	r3, [r7, #72]	@ 0x48
 800f996:	78fb      	ldrb	r3, [r7, #3]
 800f998:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800f99a:	4413      	add	r3, r2
 800f99c:	647b      	str	r3, [r7, #68]	@ 0x44
 800f99e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800f9a0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800f9a2:	429a      	cmp	r2, r3
 800f9a4:	dbc4      	blt.n	800f930 <rgb888_image_blend+0x3c4>
            if(mask_buf) mask_buf += mask_stride;
 800f9a6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800f9a8:	2b00      	cmp	r3, #0
 800f9aa:	d003      	beq.n	800f9b4 <rgb888_image_blend+0x448>
 800f9ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f9ae:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 800f9b0:	4413      	add	r3, r2
 800f9b2:	64fb      	str	r3, [r7, #76]	@ 0x4c
            dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800f9b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f9b6:	4619      	mov	r1, r3
 800f9b8:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 800f9ba:	f000 fb35 	bl	8010028 <drawbuf_next_row>
 800f9be:	6578      	str	r0, [r7, #84]	@ 0x54
            src_buf = drawbuf_next_row(src_buf, src_stride);
 800f9c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f9c2:	4619      	mov	r1, r3
 800f9c4:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 800f9c6:	f000 fb2f 	bl	8010028 <drawbuf_next_row>
 800f9ca:	6538      	str	r0, [r7, #80]	@ 0x50
        for(y = 0; y < h; y++) {
 800f9cc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 800f9ce:	3301      	adds	r3, #1
 800f9d0:	643b      	str	r3, [r7, #64]	@ 0x40
 800f9d2:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800f9d4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800f9d6:	429a      	cmp	r2, r3
 800f9d8:	dba5      	blt.n	800f926 <rgb888_image_blend+0x3ba>
}
 800f9da:	bf00      	nop
 800f9dc:	375c      	adds	r7, #92	@ 0x5c
 800f9de:	46bd      	mov	sp, r7
 800f9e0:	bd90      	pop	{r4, r7, pc}

0800f9e2 <argb8888_image_blend>:

static void LV_ATTRIBUTE_FAST_MEM argb8888_image_blend(_lv_draw_sw_blend_image_dsc_t * dsc)
{
 800f9e2:	b590      	push	{r4, r7, lr}
 800f9e4:	b093      	sub	sp, #76	@ 0x4c
 800f9e6:	af00      	add	r7, sp, #0
 800f9e8:	6078      	str	r0, [r7, #4]
    int32_t w = dsc->dest_w;
 800f9ea:	687b      	ldr	r3, [r7, #4]
 800f9ec:	685b      	ldr	r3, [r3, #4]
 800f9ee:	633b      	str	r3, [r7, #48]	@ 0x30
    int32_t h = dsc->dest_h;
 800f9f0:	687b      	ldr	r3, [r7, #4]
 800f9f2:	689b      	ldr	r3, [r3, #8]
 800f9f4:	62fb      	str	r3, [r7, #44]	@ 0x2c
    lv_opa_t opa = dsc->opa;
 800f9f6:	687b      	ldr	r3, [r7, #4]
 800f9f8:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 800f9fc:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
    lv_color32_t * dest_buf_c32 = dsc->dest_buf;
 800fa00:	687b      	ldr	r3, [r7, #4]
 800fa02:	681b      	ldr	r3, [r3, #0]
 800fa04:	647b      	str	r3, [r7, #68]	@ 0x44
    int32_t dest_stride = dsc->dest_stride;
 800fa06:	687b      	ldr	r3, [r7, #4]
 800fa08:	68db      	ldr	r3, [r3, #12]
 800fa0a:	627b      	str	r3, [r7, #36]	@ 0x24
    const lv_color32_t * src_buf_c32 = dsc->src_buf;
 800fa0c:	687b      	ldr	r3, [r7, #4]
 800fa0e:	699b      	ldr	r3, [r3, #24]
 800fa10:	643b      	str	r3, [r7, #64]	@ 0x40
    int32_t src_stride = dsc->src_stride;
 800fa12:	687b      	ldr	r3, [r7, #4]
 800fa14:	69db      	ldr	r3, [r3, #28]
 800fa16:	623b      	str	r3, [r7, #32]
    const lv_opa_t * mask_buf = dsc->mask_buf;
 800fa18:	687b      	ldr	r3, [r7, #4]
 800fa1a:	691b      	ldr	r3, [r3, #16]
 800fa1c:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int32_t mask_stride = dsc->mask_stride;
 800fa1e:	687b      	ldr	r3, [r7, #4]
 800fa20:	695b      	ldr	r3, [r3, #20]
 800fa22:	61fb      	str	r3, [r7, #28]

    lv_color32_t color_argb;
    lv_color_mix_alpha_cache_t cache;
    lv_color_mix_with_alpha_cache_init(&cache);
 800fa24:	f107 0308 	add.w	r3, r7, #8
 800fa28:	4618      	mov	r0, r3
 800fa2a:	f000 fa5c 	bl	800fee6 <lv_color_mix_with_alpha_cache_init>

    int32_t x;
    int32_t y;

    if(dsc->blend_mode == LV_BLEND_MODE_NORMAL) {
 800fa2e:	687b      	ldr	r3, [r7, #4]
 800fa30:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 800fa34:	2b00      	cmp	r3, #0
 800fa36:	f040 815c 	bne.w	800fcf2 <argb8888_image_blend+0x310>
        if(mask_buf == NULL && opa >= LV_OPA_MAX) {
 800fa3a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800fa3c:	2b00      	cmp	r3, #0
 800fa3e:	d147      	bne.n	800fad0 <argb8888_image_blend+0xee>
 800fa40:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800fa44:	2bfc      	cmp	r3, #252	@ 0xfc
 800fa46:	d943      	bls.n	800fad0 <argb8888_image_blend+0xee>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_ARGB8888(dsc)) {
                for(y = 0; y < h; y++) {
 800fa48:	2300      	movs	r3, #0
 800fa4a:	637b      	str	r3, [r7, #52]	@ 0x34
 800fa4c:	e03b      	b.n	800fac6 <argb8888_image_blend+0xe4>
                    for(x = 0; x < w; x++) {
 800fa4e:	2300      	movs	r3, #0
 800fa50:	63bb      	str	r3, [r7, #56]	@ 0x38
 800fa52:	e025      	b.n	800faa0 <argb8888_image_blend+0xbe>
                        dest_buf_c32[x] = lv_color_32_32_mix(src_buf_c32[x], dest_buf_c32[x], &cache);
 800fa54:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fa56:	009b      	lsls	r3, r3, #2
 800fa58:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800fa5a:	4413      	add	r3, r2
 800fa5c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800fa5e:	0092      	lsls	r2, r2, #2
 800fa60:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800fa62:	440a      	add	r2, r1
 800fa64:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 800fa66:	0089      	lsls	r1, r1, #2
 800fa68:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800fa6a:	1844      	adds	r4, r0, r1
 800fa6c:	f107 0108 	add.w	r1, r7, #8
 800fa70:	6812      	ldr	r2, [r2, #0]
 800fa72:	4610      	mov	r0, r2
 800fa74:	681a      	ldr	r2, [r3, #0]
 800fa76:	4613      	mov	r3, r2
 800fa78:	460a      	mov	r2, r1
 800fa7a:	4601      	mov	r1, r0
 800fa7c:	4618      	mov	r0, r3
 800fa7e:	f000 f994 	bl	800fdaa <lv_color_32_32_mix>
 800fa82:	4603      	mov	r3, r0
 800fa84:	461a      	mov	r2, r3
 800fa86:	7022      	strb	r2, [r4, #0]
 800fa88:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800fa8c:	7062      	strb	r2, [r4, #1]
 800fa8e:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800fa92:	70a2      	strb	r2, [r4, #2]
 800fa94:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800fa98:	70e3      	strb	r3, [r4, #3]
                    for(x = 0; x < w; x++) {
 800fa9a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fa9c:	3301      	adds	r3, #1
 800fa9e:	63bb      	str	r3, [r7, #56]	@ 0x38
 800faa0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800faa2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800faa4:	429a      	cmp	r2, r3
 800faa6:	dbd5      	blt.n	800fa54 <argb8888_image_blend+0x72>
                    }
                    dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800faa8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800faaa:	4619      	mov	r1, r3
 800faac:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800faae:	f000 fabb 	bl	8010028 <drawbuf_next_row>
 800fab2:	6478      	str	r0, [r7, #68]	@ 0x44
                    src_buf_c32 = drawbuf_next_row(src_buf_c32, src_stride);
 800fab4:	6a3b      	ldr	r3, [r7, #32]
 800fab6:	4619      	mov	r1, r3
 800fab8:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800faba:	f000 fab5 	bl	8010028 <drawbuf_next_row>
 800fabe:	6438      	str	r0, [r7, #64]	@ 0x40
                for(y = 0; y < h; y++) {
 800fac0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fac2:	3301      	adds	r3, #1
 800fac4:	637b      	str	r3, [r7, #52]	@ 0x34
 800fac6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fac8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800faca:	429a      	cmp	r2, r3
 800facc:	dbbf      	blt.n	800fa4e <argb8888_image_blend+0x6c>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_ARGB8888(dsc)) {
 800face:	e168      	b.n	800fda2 <argb8888_image_blend+0x3c0>
                }
            }
        }
        else if(mask_buf == NULL && opa < LV_OPA_MAX) {
 800fad0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800fad2:	2b00      	cmp	r3, #0
 800fad4:	d151      	bne.n	800fb7a <argb8888_image_blend+0x198>
 800fad6:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800fada:	2bfc      	cmp	r3, #252	@ 0xfc
 800fadc:	d84d      	bhi.n	800fb7a <argb8888_image_blend+0x198>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_ARGB8888_WITH_OPA(dsc)) {
                for(y = 0; y < h; y++) {
 800fade:	2300      	movs	r3, #0
 800fae0:	637b      	str	r3, [r7, #52]	@ 0x34
 800fae2:	e045      	b.n	800fb70 <argb8888_image_blend+0x18e>
                    for(x = 0; x < w; x++) {
 800fae4:	2300      	movs	r3, #0
 800fae6:	63bb      	str	r3, [r7, #56]	@ 0x38
 800fae8:	e02f      	b.n	800fb4a <argb8888_image_blend+0x168>
                        color_argb = src_buf_c32[x];
 800faea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800faec:	009b      	lsls	r3, r3, #2
 800faee:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800faf0:	441a      	add	r2, r3
 800faf2:	f107 0318 	add.w	r3, r7, #24
 800faf6:	6810      	ldr	r0, [r2, #0]
 800faf8:	6018      	str	r0, [r3, #0]
                        color_argb.alpha = LV_OPA_MIX2(color_argb.alpha, opa);
 800fafa:	7efb      	ldrb	r3, [r7, #27]
 800fafc:	461a      	mov	r2, r3
 800fafe:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800fb02:	fb02 f303 	mul.w	r3, r2, r3
 800fb06:	121b      	asrs	r3, r3, #8
 800fb08:	b2db      	uxtb	r3, r3
 800fb0a:	76fb      	strb	r3, [r7, #27]
                        dest_buf_c32[x] = lv_color_32_32_mix(color_argb, dest_buf_c32[x], &cache);
 800fb0c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fb0e:	009b      	lsls	r3, r3, #2
 800fb10:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800fb12:	4413      	add	r3, r2
 800fb14:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800fb16:	0092      	lsls	r2, r2, #2
 800fb18:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800fb1a:	188c      	adds	r4, r1, r2
 800fb1c:	f107 0208 	add.w	r2, r7, #8
 800fb20:	6819      	ldr	r1, [r3, #0]
 800fb22:	460b      	mov	r3, r1
 800fb24:	4619      	mov	r1, r3
 800fb26:	69b8      	ldr	r0, [r7, #24]
 800fb28:	f000 f93f 	bl	800fdaa <lv_color_32_32_mix>
 800fb2c:	4603      	mov	r3, r0
 800fb2e:	461a      	mov	r2, r3
 800fb30:	7022      	strb	r2, [r4, #0]
 800fb32:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800fb36:	7062      	strb	r2, [r4, #1]
 800fb38:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800fb3c:	70a2      	strb	r2, [r4, #2]
 800fb3e:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800fb42:	70e3      	strb	r3, [r4, #3]
                    for(x = 0; x < w; x++) {
 800fb44:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fb46:	3301      	adds	r3, #1
 800fb48:	63bb      	str	r3, [r7, #56]	@ 0x38
 800fb4a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800fb4c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fb4e:	429a      	cmp	r2, r3
 800fb50:	dbcb      	blt.n	800faea <argb8888_image_blend+0x108>
                    }
                    dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800fb52:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fb54:	4619      	mov	r1, r3
 800fb56:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800fb58:	f000 fa66 	bl	8010028 <drawbuf_next_row>
 800fb5c:	6478      	str	r0, [r7, #68]	@ 0x44
                    src_buf_c32 = drawbuf_next_row(src_buf_c32, src_stride);
 800fb5e:	6a3b      	ldr	r3, [r7, #32]
 800fb60:	4619      	mov	r1, r3
 800fb62:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800fb64:	f000 fa60 	bl	8010028 <drawbuf_next_row>
 800fb68:	6438      	str	r0, [r7, #64]	@ 0x40
                for(y = 0; y < h; y++) {
 800fb6a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fb6c:	3301      	adds	r3, #1
 800fb6e:	637b      	str	r3, [r7, #52]	@ 0x34
 800fb70:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fb72:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fb74:	429a      	cmp	r2, r3
 800fb76:	dbb5      	blt.n	800fae4 <argb8888_image_blend+0x102>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_ARGB8888_WITH_OPA(dsc)) {
 800fb78:	e113      	b.n	800fda2 <argb8888_image_blend+0x3c0>
                }
            }
        }
        else if(mask_buf && opa >= LV_OPA_MAX) {
 800fb7a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800fb7c:	2b00      	cmp	r3, #0
 800fb7e:	d057      	beq.n	800fc30 <argb8888_image_blend+0x24e>
 800fb80:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800fb84:	2bfc      	cmp	r3, #252	@ 0xfc
 800fb86:	d953      	bls.n	800fc30 <argb8888_image_blend+0x24e>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_ARGB8888_WITH_MASK(dsc)) {
                for(y = 0; y < h; y++) {
 800fb88:	2300      	movs	r3, #0
 800fb8a:	637b      	str	r3, [r7, #52]	@ 0x34
 800fb8c:	e04b      	b.n	800fc26 <argb8888_image_blend+0x244>
                    for(x = 0; x < w; x++) {
 800fb8e:	2300      	movs	r3, #0
 800fb90:	63bb      	str	r3, [r7, #56]	@ 0x38
 800fb92:	e031      	b.n	800fbf8 <argb8888_image_blend+0x216>
                        color_argb = src_buf_c32[x];
 800fb94:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fb96:	009b      	lsls	r3, r3, #2
 800fb98:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800fb9a:	441a      	add	r2, r3
 800fb9c:	f107 0318 	add.w	r3, r7, #24
 800fba0:	6810      	ldr	r0, [r2, #0]
 800fba2:	6018      	str	r0, [r3, #0]
                        color_argb.alpha = LV_OPA_MIX2(color_argb.alpha, mask_buf[x]);
 800fba4:	7efb      	ldrb	r3, [r7, #27]
 800fba6:	4619      	mov	r1, r3
 800fba8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fbaa:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800fbac:	4413      	add	r3, r2
 800fbae:	781b      	ldrb	r3, [r3, #0]
 800fbb0:	fb01 f303 	mul.w	r3, r1, r3
 800fbb4:	121b      	asrs	r3, r3, #8
 800fbb6:	b2db      	uxtb	r3, r3
 800fbb8:	76fb      	strb	r3, [r7, #27]
                        dest_buf_c32[x] = lv_color_32_32_mix(color_argb, dest_buf_c32[x], &cache);
 800fbba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fbbc:	009b      	lsls	r3, r3, #2
 800fbbe:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800fbc0:	4413      	add	r3, r2
 800fbc2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800fbc4:	0092      	lsls	r2, r2, #2
 800fbc6:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800fbc8:	188c      	adds	r4, r1, r2
 800fbca:	f107 0208 	add.w	r2, r7, #8
 800fbce:	6819      	ldr	r1, [r3, #0]
 800fbd0:	460b      	mov	r3, r1
 800fbd2:	4619      	mov	r1, r3
 800fbd4:	69b8      	ldr	r0, [r7, #24]
 800fbd6:	f000 f8e8 	bl	800fdaa <lv_color_32_32_mix>
 800fbda:	4603      	mov	r3, r0
 800fbdc:	461a      	mov	r2, r3
 800fbde:	7022      	strb	r2, [r4, #0]
 800fbe0:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800fbe4:	7062      	strb	r2, [r4, #1]
 800fbe6:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800fbea:	70a2      	strb	r2, [r4, #2]
 800fbec:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800fbf0:	70e3      	strb	r3, [r4, #3]
                    for(x = 0; x < w; x++) {
 800fbf2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fbf4:	3301      	adds	r3, #1
 800fbf6:	63bb      	str	r3, [r7, #56]	@ 0x38
 800fbf8:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800fbfa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fbfc:	429a      	cmp	r2, r3
 800fbfe:	dbc9      	blt.n	800fb94 <argb8888_image_blend+0x1b2>
                    }
                    dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800fc00:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fc02:	4619      	mov	r1, r3
 800fc04:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800fc06:	f000 fa0f 	bl	8010028 <drawbuf_next_row>
 800fc0a:	6478      	str	r0, [r7, #68]	@ 0x44
                    src_buf_c32 = drawbuf_next_row(src_buf_c32, src_stride);
 800fc0c:	6a3b      	ldr	r3, [r7, #32]
 800fc0e:	4619      	mov	r1, r3
 800fc10:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800fc12:	f000 fa09 	bl	8010028 <drawbuf_next_row>
 800fc16:	6438      	str	r0, [r7, #64]	@ 0x40
                    mask_buf += mask_stride;
 800fc18:	69fb      	ldr	r3, [r7, #28]
 800fc1a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800fc1c:	4413      	add	r3, r2
 800fc1e:	63fb      	str	r3, [r7, #60]	@ 0x3c
                for(y = 0; y < h; y++) {
 800fc20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fc22:	3301      	adds	r3, #1
 800fc24:	637b      	str	r3, [r7, #52]	@ 0x34
 800fc26:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fc28:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fc2a:	429a      	cmp	r2, r3
 800fc2c:	dbaf      	blt.n	800fb8e <argb8888_image_blend+0x1ac>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_ARGB8888_WITH_MASK(dsc)) {
 800fc2e:	e0b8      	b.n	800fda2 <argb8888_image_blend+0x3c0>
                }
            }
        }
        else if(mask_buf && opa < LV_OPA_MAX) {
 800fc30:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800fc32:	2b00      	cmp	r3, #0
 800fc34:	f000 80b5 	beq.w	800fda2 <argb8888_image_blend+0x3c0>
 800fc38:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800fc3c:	2bfc      	cmp	r3, #252	@ 0xfc
 800fc3e:	f200 80b0 	bhi.w	800fda2 <argb8888_image_blend+0x3c0>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_ARGB8888_MIX_MASK_OPA(dsc)) {
                for(y = 0; y < h; y++) {
 800fc42:	2300      	movs	r3, #0
 800fc44:	637b      	str	r3, [r7, #52]	@ 0x34
 800fc46:	e04f      	b.n	800fce8 <argb8888_image_blend+0x306>
                    for(x = 0; x < w; x++) {
 800fc48:	2300      	movs	r3, #0
 800fc4a:	63bb      	str	r3, [r7, #56]	@ 0x38
 800fc4c:	e035      	b.n	800fcba <argb8888_image_blend+0x2d8>
                        color_argb = src_buf_c32[x];
 800fc4e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fc50:	009b      	lsls	r3, r3, #2
 800fc52:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800fc54:	441a      	add	r2, r3
 800fc56:	f107 0318 	add.w	r3, r7, #24
 800fc5a:	6810      	ldr	r0, [r2, #0]
 800fc5c:	6018      	str	r0, [r3, #0]
                        color_argb.alpha = LV_OPA_MIX3(color_argb.alpha, opa, mask_buf[x]);
 800fc5e:	7efb      	ldrb	r3, [r7, #27]
 800fc60:	461a      	mov	r2, r3
 800fc62:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800fc66:	fb02 f303 	mul.w	r3, r2, r3
 800fc6a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800fc6c:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 800fc6e:	440a      	add	r2, r1
 800fc70:	7812      	ldrb	r2, [r2, #0]
 800fc72:	fb02 f303 	mul.w	r3, r2, r3
 800fc76:	141b      	asrs	r3, r3, #16
 800fc78:	b2db      	uxtb	r3, r3
 800fc7a:	76fb      	strb	r3, [r7, #27]
                        dest_buf_c32[x] = lv_color_32_32_mix(color_argb, dest_buf_c32[x], &cache);
 800fc7c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fc7e:	009b      	lsls	r3, r3, #2
 800fc80:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800fc82:	4413      	add	r3, r2
 800fc84:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800fc86:	0092      	lsls	r2, r2, #2
 800fc88:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800fc8a:	188c      	adds	r4, r1, r2
 800fc8c:	f107 0208 	add.w	r2, r7, #8
 800fc90:	6819      	ldr	r1, [r3, #0]
 800fc92:	460b      	mov	r3, r1
 800fc94:	4619      	mov	r1, r3
 800fc96:	69b8      	ldr	r0, [r7, #24]
 800fc98:	f000 f887 	bl	800fdaa <lv_color_32_32_mix>
 800fc9c:	4603      	mov	r3, r0
 800fc9e:	461a      	mov	r2, r3
 800fca0:	7022      	strb	r2, [r4, #0]
 800fca2:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800fca6:	7062      	strb	r2, [r4, #1]
 800fca8:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800fcac:	70a2      	strb	r2, [r4, #2]
 800fcae:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800fcb2:	70e3      	strb	r3, [r4, #3]
                    for(x = 0; x < w; x++) {
 800fcb4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fcb6:	3301      	adds	r3, #1
 800fcb8:	63bb      	str	r3, [r7, #56]	@ 0x38
 800fcba:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800fcbc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fcbe:	429a      	cmp	r2, r3
 800fcc0:	dbc5      	blt.n	800fc4e <argb8888_image_blend+0x26c>
                    }
                    dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800fcc2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fcc4:	4619      	mov	r1, r3
 800fcc6:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800fcc8:	f000 f9ae 	bl	8010028 <drawbuf_next_row>
 800fccc:	6478      	str	r0, [r7, #68]	@ 0x44
                    src_buf_c32 = drawbuf_next_row(src_buf_c32, src_stride);
 800fcce:	6a3b      	ldr	r3, [r7, #32]
 800fcd0:	4619      	mov	r1, r3
 800fcd2:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800fcd4:	f000 f9a8 	bl	8010028 <drawbuf_next_row>
 800fcd8:	6438      	str	r0, [r7, #64]	@ 0x40
                    mask_buf += mask_stride;
 800fcda:	69fb      	ldr	r3, [r7, #28]
 800fcdc:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800fcde:	4413      	add	r3, r2
 800fce0:	63fb      	str	r3, [r7, #60]	@ 0x3c
                for(y = 0; y < h; y++) {
 800fce2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fce4:	3301      	adds	r3, #1
 800fce6:	637b      	str	r3, [r7, #52]	@ 0x34
 800fce8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fcea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fcec:	429a      	cmp	r2, r3
 800fcee:	dbab      	blt.n	800fc48 <argb8888_image_blend+0x266>
            if(mask_buf) mask_buf += mask_stride;
            dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
            src_buf_c32 = drawbuf_next_row(src_buf_c32, src_stride);
        }
    }
}
 800fcf0:	e057      	b.n	800fda2 <argb8888_image_blend+0x3c0>
        for(y = 0; y < h; y++) {
 800fcf2:	2300      	movs	r3, #0
 800fcf4:	637b      	str	r3, [r7, #52]	@ 0x34
 800fcf6:	e04f      	b.n	800fd98 <argb8888_image_blend+0x3b6>
            for(x = 0; x < w; x++) {
 800fcf8:	2300      	movs	r3, #0
 800fcfa:	63bb      	str	r3, [r7, #56]	@ 0x38
 800fcfc:	e032      	b.n	800fd64 <argb8888_image_blend+0x382>
                color_argb = src_buf_c32[x];
 800fcfe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fd00:	009b      	lsls	r3, r3, #2
 800fd02:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800fd04:	441a      	add	r2, r3
 800fd06:	f107 0318 	add.w	r3, r7, #24
 800fd0a:	6810      	ldr	r0, [r2, #0]
 800fd0c:	6018      	str	r0, [r3, #0]
                if(mask_buf == NULL) color_argb.alpha = LV_OPA_MIX2(color_argb.alpha, opa);
 800fd0e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800fd10:	2b00      	cmp	r3, #0
 800fd12:	d109      	bne.n	800fd28 <argb8888_image_blend+0x346>
 800fd14:	7efb      	ldrb	r3, [r7, #27]
 800fd16:	461a      	mov	r2, r3
 800fd18:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 800fd1c:	fb02 f303 	mul.w	r3, r2, r3
 800fd20:	121b      	asrs	r3, r3, #8
 800fd22:	b2db      	uxtb	r3, r3
 800fd24:	76fb      	strb	r3, [r7, #27]
 800fd26:	e00e      	b.n	800fd46 <argb8888_image_blend+0x364>
                else color_argb.alpha = LV_OPA_MIX3(color_argb.alpha, mask_buf[x], opa);
 800fd28:	7efb      	ldrb	r3, [r7, #27]
 800fd2a:	4619      	mov	r1, r3
 800fd2c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fd2e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800fd30:	4413      	add	r3, r2
 800fd32:	781b      	ldrb	r3, [r3, #0]
 800fd34:	fb01 f303 	mul.w	r3, r1, r3
 800fd38:	f897 202b 	ldrb.w	r2, [r7, #43]	@ 0x2b
 800fd3c:	fb02 f303 	mul.w	r3, r2, r3
 800fd40:	141b      	asrs	r3, r3, #16
 800fd42:	b2db      	uxtb	r3, r3
 800fd44:	76fb      	strb	r3, [r7, #27]
                blend_non_normal_pixel(&dest_buf_c32[x], color_argb, dsc->blend_mode, &cache);
 800fd46:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fd48:	009b      	lsls	r3, r3, #2
 800fd4a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800fd4c:	18d0      	adds	r0, r2, r3
 800fd4e:	687b      	ldr	r3, [r7, #4]
 800fd50:	f893 2022 	ldrb.w	r2, [r3, #34]	@ 0x22
 800fd54:	f107 0308 	add.w	r3, r7, #8
 800fd58:	69b9      	ldr	r1, [r7, #24]
 800fd5a:	f000 f8e3 	bl	800ff24 <blend_non_normal_pixel>
            for(x = 0; x < w; x++) {
 800fd5e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800fd60:	3301      	adds	r3, #1
 800fd62:	63bb      	str	r3, [r7, #56]	@ 0x38
 800fd64:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800fd66:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800fd68:	429a      	cmp	r2, r3
 800fd6a:	dbc8      	blt.n	800fcfe <argb8888_image_blend+0x31c>
            if(mask_buf) mask_buf += mask_stride;
 800fd6c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800fd6e:	2b00      	cmp	r3, #0
 800fd70:	d003      	beq.n	800fd7a <argb8888_image_blend+0x398>
 800fd72:	69fb      	ldr	r3, [r7, #28]
 800fd74:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800fd76:	4413      	add	r3, r2
 800fd78:	63fb      	str	r3, [r7, #60]	@ 0x3c
            dest_buf_c32 = drawbuf_next_row(dest_buf_c32, dest_stride);
 800fd7a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800fd7c:	4619      	mov	r1, r3
 800fd7e:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 800fd80:	f000 f952 	bl	8010028 <drawbuf_next_row>
 800fd84:	6478      	str	r0, [r7, #68]	@ 0x44
            src_buf_c32 = drawbuf_next_row(src_buf_c32, src_stride);
 800fd86:	6a3b      	ldr	r3, [r7, #32]
 800fd88:	4619      	mov	r1, r3
 800fd8a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 800fd8c:	f000 f94c 	bl	8010028 <drawbuf_next_row>
 800fd90:	6438      	str	r0, [r7, #64]	@ 0x40
        for(y = 0; y < h; y++) {
 800fd92:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800fd94:	3301      	adds	r3, #1
 800fd96:	637b      	str	r3, [r7, #52]	@ 0x34
 800fd98:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800fd9a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800fd9c:	429a      	cmp	r2, r3
 800fd9e:	dbab      	blt.n	800fcf8 <argb8888_image_blend+0x316>
}
 800fda0:	e7ff      	b.n	800fda2 <argb8888_image_blend+0x3c0>
 800fda2:	bf00      	nop
 800fda4:	374c      	adds	r7, #76	@ 0x4c
 800fda6:	46bd      	mov	sp, r7
 800fda8:	bd90      	pop	{r4, r7, pc}

0800fdaa <lv_color_32_32_mix>:

static inline lv_color32_t LV_ATTRIBUTE_FAST_MEM lv_color_32_32_mix(lv_color32_t fg, lv_color32_t bg,
                                                                    lv_color_mix_alpha_cache_t * cache)
{
 800fdaa:	b590      	push	{r4, r7, lr}
 800fdac:	b087      	sub	sp, #28
 800fdae:	af00      	add	r7, sp, #0
 800fdb0:	60f8      	str	r0, [r7, #12]
 800fdb2:	60b9      	str	r1, [r7, #8]
 800fdb4:	607a      	str	r2, [r7, #4]
    /*Pick the foreground if it's fully opaque or the Background is fully transparent*/
    if(fg.alpha >= LV_OPA_MAX || bg.alpha <= LV_OPA_MIN) {
 800fdb6:	7bfb      	ldrb	r3, [r7, #15]
 800fdb8:	2bfc      	cmp	r3, #252	@ 0xfc
 800fdba:	d802      	bhi.n	800fdc2 <lv_color_32_32_mix+0x18>
 800fdbc:	7afb      	ldrb	r3, [r7, #11]
 800fdbe:	2b02      	cmp	r3, #2
 800fdc0:	d802      	bhi.n	800fdc8 <lv_color_32_32_mix+0x1e>
        return fg;
 800fdc2:	68fb      	ldr	r3, [r7, #12]
 800fdc4:	617b      	str	r3, [r7, #20]
 800fdc6:	e07d      	b.n	800fec4 <lv_color_32_32_mix+0x11a>
    }
    /*Transparent foreground: use the Background*/
    else if(fg.alpha <= LV_OPA_MIN) {
 800fdc8:	7bfb      	ldrb	r3, [r7, #15]
 800fdca:	2b02      	cmp	r3, #2
 800fdcc:	d802      	bhi.n	800fdd4 <lv_color_32_32_mix+0x2a>
        return bg;
 800fdce:	68bb      	ldr	r3, [r7, #8]
 800fdd0:	617b      	str	r3, [r7, #20]
 800fdd2:	e077      	b.n	800fec4 <lv_color_32_32_mix+0x11a>
    }
    /*Opaque background: use simple mix*/
    else if(bg.alpha == 255) {
 800fdd4:	7afb      	ldrb	r3, [r7, #11]
 800fdd6:	2bff      	cmp	r3, #255	@ 0xff
 800fdd8:	d106      	bne.n	800fde8 <lv_color_32_32_mix+0x3e>
        return lv_color_mix32(fg, bg);
 800fdda:	68b9      	ldr	r1, [r7, #8]
 800fddc:	68f8      	ldr	r0, [r7, #12]
 800fdde:	f7fe ff59 	bl	800ec94 <lv_color_mix32>
 800fde2:	4603      	mov	r3, r0
 800fde4:	617b      	str	r3, [r7, #20]
 800fde6:	e06d      	b.n	800fec4 <lv_color_32_32_mix+0x11a>
    /*Both colors have alpha. Expensive calculation need to be applied*/
    else {
        /*Save the parameters and the result. If they will be asked again don't compute again*/

        /*Update the ratio and the result alpha value if the input alpha values change*/
        if(bg.alpha != cache->bg_saved.alpha || fg.alpha != cache->fg_saved.alpha) {
 800fde8:	7afa      	ldrb	r2, [r7, #11]
 800fdea:	687b      	ldr	r3, [r7, #4]
 800fdec:	79db      	ldrb	r3, [r3, #7]
 800fdee:	429a      	cmp	r2, r3
 800fdf0:	d104      	bne.n	800fdfc <lv_color_32_32_mix+0x52>
 800fdf2:	7bfa      	ldrb	r2, [r7, #15]
 800fdf4:	687b      	ldr	r3, [r7, #4]
 800fdf6:	78db      	ldrb	r3, [r3, #3]
 800fdf8:	429a      	cmp	r2, r3
 800fdfa:	d01f      	beq.n	800fe3c <lv_color_32_32_mix+0x92>
            /*Info:
             * https://en.wikipedia.org/wiki/Alpha_compositing#Analytical_derivation_of_the_over_operator*/
            cache->res_alpha_saved  = 255 - LV_OPA_MIX2(255 - fg.alpha, 255 - bg.alpha);
 800fdfc:	7bfb      	ldrb	r3, [r7, #15]
 800fdfe:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 800fe02:	7afa      	ldrb	r2, [r7, #11]
 800fe04:	f1c2 02ff 	rsb	r2, r2, #255	@ 0xff
 800fe08:	fb02 f303 	mul.w	r3, r2, r3
 800fe0c:	121b      	asrs	r3, r3, #8
 800fe0e:	b2db      	uxtb	r3, r3
 800fe10:	43db      	mvns	r3, r3
 800fe12:	b2da      	uxtb	r2, r3
 800fe14:	687b      	ldr	r3, [r7, #4]
 800fe16:	731a      	strb	r2, [r3, #12]
            LV_ASSERT(cache->ratio_saved != 0);
 800fe18:	687b      	ldr	r3, [r7, #4]
 800fe1a:	7b5b      	ldrb	r3, [r3, #13]
 800fe1c:	2b00      	cmp	r3, #0
 800fe1e:	d101      	bne.n	800fe24 <lv_color_32_32_mix+0x7a>
 800fe20:	bf00      	nop
 800fe22:	e7fd      	b.n	800fe20 <lv_color_32_32_mix+0x76>
            cache->ratio_saved = (uint32_t)((uint32_t)fg.alpha * 255) / cache->res_alpha_saved;
 800fe24:	7bfb      	ldrb	r3, [r7, #15]
 800fe26:	461a      	mov	r2, r3
 800fe28:	4613      	mov	r3, r2
 800fe2a:	021b      	lsls	r3, r3, #8
 800fe2c:	1a9b      	subs	r3, r3, r2
 800fe2e:	687a      	ldr	r2, [r7, #4]
 800fe30:	7b12      	ldrb	r2, [r2, #12]
 800fe32:	fbb3 f3f2 	udiv	r3, r3, r2
 800fe36:	b2da      	uxtb	r2, r3
 800fe38:	687b      	ldr	r3, [r7, #4]
 800fe3a:	735a      	strb	r2, [r3, #13]
        }

        if(!lv_color32_eq(bg, cache->bg_saved) || !lv_color32_eq(fg, cache->fg_saved)) {
 800fe3c:	687b      	ldr	r3, [r7, #4]
 800fe3e:	685a      	ldr	r2, [r3, #4]
 800fe40:	4613      	mov	r3, r2
 800fe42:	4619      	mov	r1, r3
 800fe44:	68b8      	ldr	r0, [r7, #8]
 800fe46:	f7fe ff11 	bl	800ec6c <lv_color32_eq>
 800fe4a:	4603      	mov	r3, r0
 800fe4c:	f083 0301 	eor.w	r3, r3, #1
 800fe50:	b2db      	uxtb	r3, r3
 800fe52:	2b00      	cmp	r3, #0
 800fe54:	d10c      	bne.n	800fe70 <lv_color_32_32_mix+0xc6>
 800fe56:	687b      	ldr	r3, [r7, #4]
 800fe58:	681a      	ldr	r2, [r3, #0]
 800fe5a:	4613      	mov	r3, r2
 800fe5c:	4619      	mov	r1, r3
 800fe5e:	68f8      	ldr	r0, [r7, #12]
 800fe60:	f7fe ff04 	bl	800ec6c <lv_color32_eq>
 800fe64:	4603      	mov	r3, r0
 800fe66:	f083 0301 	eor.w	r3, r3, #1
 800fe6a:	b2db      	uxtb	r3, r3
 800fe6c:	2b00      	cmp	r3, #0
 800fe6e:	d023      	beq.n	800feb8 <lv_color_32_32_mix+0x10e>
            cache->fg_saved = fg;
 800fe70:	687b      	ldr	r3, [r7, #4]
 800fe72:	461a      	mov	r2, r3
 800fe74:	f107 030c 	add.w	r3, r7, #12
 800fe78:	6818      	ldr	r0, [r3, #0]
 800fe7a:	6010      	str	r0, [r2, #0]
            cache->bg_saved = bg;
 800fe7c:	687b      	ldr	r3, [r7, #4]
 800fe7e:	3304      	adds	r3, #4
 800fe80:	f107 0208 	add.w	r2, r7, #8
 800fe84:	6810      	ldr	r0, [r2, #0]
 800fe86:	6018      	str	r0, [r3, #0]
            fg.alpha = cache->ratio_saved;
 800fe88:	687b      	ldr	r3, [r7, #4]
 800fe8a:	7b5b      	ldrb	r3, [r3, #13]
 800fe8c:	73fb      	strb	r3, [r7, #15]
            cache->res_saved = lv_color_mix32(fg, bg);
 800fe8e:	687c      	ldr	r4, [r7, #4]
 800fe90:	68b9      	ldr	r1, [r7, #8]
 800fe92:	68f8      	ldr	r0, [r7, #12]
 800fe94:	f7fe fefe 	bl	800ec94 <lv_color_mix32>
 800fe98:	4603      	mov	r3, r0
 800fe9a:	461a      	mov	r2, r3
 800fe9c:	7222      	strb	r2, [r4, #8]
 800fe9e:	f3c3 2207 	ubfx	r2, r3, #8, #8
 800fea2:	7262      	strb	r2, [r4, #9]
 800fea4:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800fea8:	72a2      	strb	r2, [r4, #10]
 800feaa:	f3c3 6307 	ubfx	r3, r3, #24, #8
 800feae:	72e3      	strb	r3, [r4, #11]
            cache->res_saved.alpha = cache->res_alpha_saved;
 800feb0:	687b      	ldr	r3, [r7, #4]
 800feb2:	7b1a      	ldrb	r2, [r3, #12]
 800feb4:	687b      	ldr	r3, [r7, #4]
 800feb6:	72da      	strb	r2, [r3, #11]
        }

        return cache->res_saved;
 800feb8:	687a      	ldr	r2, [r7, #4]
 800feba:	f107 0314 	add.w	r3, r7, #20
 800febe:	3208      	adds	r2, #8
 800fec0:	6810      	ldr	r0, [r2, #0]
 800fec2:	6018      	str	r0, [r3, #0]
    }
}
 800fec4:	2300      	movs	r3, #0
 800fec6:	7d3a      	ldrb	r2, [r7, #20]
 800fec8:	f362 0307 	bfi	r3, r2, #0, #8
 800fecc:	7d7a      	ldrb	r2, [r7, #21]
 800fece:	f362 230f 	bfi	r3, r2, #8, #8
 800fed2:	7dba      	ldrb	r2, [r7, #22]
 800fed4:	f362 4317 	bfi	r3, r2, #16, #8
 800fed8:	7dfa      	ldrb	r2, [r7, #23]
 800feda:	f362 631f 	bfi	r3, r2, #24, #8
 800fede:	4618      	mov	r0, r3
 800fee0:	371c      	adds	r7, #28
 800fee2:	46bd      	mov	sp, r7
 800fee4:	bd90      	pop	{r4, r7, pc}

0800fee6 <lv_color_mix_with_alpha_cache_init>:

void lv_color_mix_with_alpha_cache_init(lv_color_mix_alpha_cache_t * cache)
{
 800fee6:	b580      	push	{r7, lr}
 800fee8:	b082      	sub	sp, #8
 800feea:	af00      	add	r7, sp, #0
 800feec:	6078      	str	r0, [r7, #4]
    lv_memzero(&cache->fg_saved, sizeof(lv_color32_t));
 800feee:	687b      	ldr	r3, [r7, #4]
 800fef0:	2104      	movs	r1, #4
 800fef2:	4618      	mov	r0, r3
 800fef4:	f7fe ff20 	bl	800ed38 <lv_memzero>
    lv_memzero(&cache->bg_saved, sizeof(lv_color32_t));
 800fef8:	687b      	ldr	r3, [r7, #4]
 800fefa:	3304      	adds	r3, #4
 800fefc:	2104      	movs	r1, #4
 800fefe:	4618      	mov	r0, r3
 800ff00:	f7fe ff1a 	bl	800ed38 <lv_memzero>
    lv_memzero(&cache->res_saved, sizeof(lv_color32_t));
 800ff04:	687b      	ldr	r3, [r7, #4]
 800ff06:	3308      	adds	r3, #8
 800ff08:	2104      	movs	r1, #4
 800ff0a:	4618      	mov	r0, r3
 800ff0c:	f7fe ff14 	bl	800ed38 <lv_memzero>
    cache->res_alpha_saved = 255;
 800ff10:	687b      	ldr	r3, [r7, #4]
 800ff12:	22ff      	movs	r2, #255	@ 0xff
 800ff14:	731a      	strb	r2, [r3, #12]
    cache->ratio_saved = 255;
 800ff16:	687b      	ldr	r3, [r7, #4]
 800ff18:	22ff      	movs	r2, #255	@ 0xff
 800ff1a:	735a      	strb	r2, [r3, #13]
}
 800ff1c:	bf00      	nop
 800ff1e:	3708      	adds	r7, #8
 800ff20:	46bd      	mov	sp, r7
 800ff22:	bd80      	pop	{r7, pc}

0800ff24 <blend_non_normal_pixel>:

static inline void LV_ATTRIBUTE_FAST_MEM blend_non_normal_pixel(lv_color32_t * dest, lv_color32_t src,
                                                                lv_blend_mode_t mode, lv_color_mix_alpha_cache_t * cache)
{
 800ff24:	b580      	push	{r7, lr}
 800ff26:	b086      	sub	sp, #24
 800ff28:	af00      	add	r7, sp, #0
 800ff2a:	60f8      	str	r0, [r7, #12]
 800ff2c:	60b9      	str	r1, [r7, #8]
 800ff2e:	603b      	str	r3, [r7, #0]
 800ff30:	4613      	mov	r3, r2
 800ff32:	71fb      	strb	r3, [r7, #7]
    lv_color32_t res;
    switch(mode) {
 800ff34:	79fb      	ldrb	r3, [r7, #7]
 800ff36:	2b03      	cmp	r3, #3
 800ff38:	d041      	beq.n	800ffbe <blend_non_normal_pixel+0x9a>
 800ff3a:	2b03      	cmp	r3, #3
 800ff3c:	dc70      	bgt.n	8010020 <blend_non_normal_pixel+0xfc>
 800ff3e:	2b01      	cmp	r3, #1
 800ff40:	d002      	beq.n	800ff48 <blend_non_normal_pixel+0x24>
 800ff42:	2b02      	cmp	r3, #2
 800ff44:	d01f      	beq.n	800ff86 <blend_non_normal_pixel+0x62>
            res.green = (dest->green * src.green) >> 8;
            res.blue = (dest->blue * src.blue) >> 8;
            break;
        default:
            LV_LOG_WARN("Not supported blend mode: %d", mode);
            return;
 800ff46:	e06b      	b.n	8010020 <blend_non_normal_pixel+0xfc>
            res.red = LV_MIN(dest->red + src.red, 255);
 800ff48:	68fb      	ldr	r3, [r7, #12]
 800ff4a:	789b      	ldrb	r3, [r3, #2]
 800ff4c:	461a      	mov	r2, r3
 800ff4e:	7abb      	ldrb	r3, [r7, #10]
 800ff50:	4413      	add	r3, r2
 800ff52:	2bff      	cmp	r3, #255	@ 0xff
 800ff54:	bfa8      	it	ge
 800ff56:	23ff      	movge	r3, #255	@ 0xff
 800ff58:	b2db      	uxtb	r3, r3
 800ff5a:	75bb      	strb	r3, [r7, #22]
            res.green = LV_MIN(dest->green + src.green, 255);
 800ff5c:	68fb      	ldr	r3, [r7, #12]
 800ff5e:	785b      	ldrb	r3, [r3, #1]
 800ff60:	461a      	mov	r2, r3
 800ff62:	7a7b      	ldrb	r3, [r7, #9]
 800ff64:	4413      	add	r3, r2
 800ff66:	2bff      	cmp	r3, #255	@ 0xff
 800ff68:	bfa8      	it	ge
 800ff6a:	23ff      	movge	r3, #255	@ 0xff
 800ff6c:	b2db      	uxtb	r3, r3
 800ff6e:	757b      	strb	r3, [r7, #21]
            res.blue = LV_MIN(dest->blue + src.blue, 255);
 800ff70:	68fb      	ldr	r3, [r7, #12]
 800ff72:	781b      	ldrb	r3, [r3, #0]
 800ff74:	461a      	mov	r2, r3
 800ff76:	7a3b      	ldrb	r3, [r7, #8]
 800ff78:	4413      	add	r3, r2
 800ff7a:	2bff      	cmp	r3, #255	@ 0xff
 800ff7c:	bfa8      	it	ge
 800ff7e:	23ff      	movge	r3, #255	@ 0xff
 800ff80:	b2db      	uxtb	r3, r3
 800ff82:	753b      	strb	r3, [r7, #20]
            break;
 800ff84:	e034      	b.n	800fff0 <blend_non_normal_pixel+0xcc>
            res.red = LV_MAX(dest->red - src.red, 0);
 800ff86:	68fb      	ldr	r3, [r7, #12]
 800ff88:	789b      	ldrb	r3, [r3, #2]
 800ff8a:	461a      	mov	r2, r3
 800ff8c:	7abb      	ldrb	r3, [r7, #10]
 800ff8e:	1ad3      	subs	r3, r2, r3
 800ff90:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800ff94:	b2db      	uxtb	r3, r3
 800ff96:	75bb      	strb	r3, [r7, #22]
            res.green = LV_MAX(dest->green - src.green, 0);
 800ff98:	68fb      	ldr	r3, [r7, #12]
 800ff9a:	785b      	ldrb	r3, [r3, #1]
 800ff9c:	461a      	mov	r2, r3
 800ff9e:	7a7b      	ldrb	r3, [r7, #9]
 800ffa0:	1ad3      	subs	r3, r2, r3
 800ffa2:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800ffa6:	b2db      	uxtb	r3, r3
 800ffa8:	757b      	strb	r3, [r7, #21]
            res.blue = LV_MAX(dest->blue - src.blue, 0);
 800ffaa:	68fb      	ldr	r3, [r7, #12]
 800ffac:	781b      	ldrb	r3, [r3, #0]
 800ffae:	461a      	mov	r2, r3
 800ffb0:	7a3b      	ldrb	r3, [r7, #8]
 800ffb2:	1ad3      	subs	r3, r2, r3
 800ffb4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800ffb8:	b2db      	uxtb	r3, r3
 800ffba:	753b      	strb	r3, [r7, #20]
            break;
 800ffbc:	e018      	b.n	800fff0 <blend_non_normal_pixel+0xcc>
            res.red = (dest->red * src.red) >> 8;
 800ffbe:	68fb      	ldr	r3, [r7, #12]
 800ffc0:	789b      	ldrb	r3, [r3, #2]
 800ffc2:	7aba      	ldrb	r2, [r7, #10]
 800ffc4:	fb02 f303 	mul.w	r3, r2, r3
 800ffc8:	121b      	asrs	r3, r3, #8
 800ffca:	b2db      	uxtb	r3, r3
 800ffcc:	75bb      	strb	r3, [r7, #22]
            res.green = (dest->green * src.green) >> 8;
 800ffce:	68fb      	ldr	r3, [r7, #12]
 800ffd0:	785b      	ldrb	r3, [r3, #1]
 800ffd2:	7a7a      	ldrb	r2, [r7, #9]
 800ffd4:	fb02 f303 	mul.w	r3, r2, r3
 800ffd8:	121b      	asrs	r3, r3, #8
 800ffda:	b2db      	uxtb	r3, r3
 800ffdc:	757b      	strb	r3, [r7, #21]
            res.blue = (dest->blue * src.blue) >> 8;
 800ffde:	68fb      	ldr	r3, [r7, #12]
 800ffe0:	781b      	ldrb	r3, [r3, #0]
 800ffe2:	7a3a      	ldrb	r2, [r7, #8]
 800ffe4:	fb02 f303 	mul.w	r3, r2, r3
 800ffe8:	121b      	asrs	r3, r3, #8
 800ffea:	b2db      	uxtb	r3, r3
 800ffec:	753b      	strb	r3, [r7, #20]
            break;
 800ffee:	bf00      	nop
    }
    res.alpha = src.alpha;
 800fff0:	7afb      	ldrb	r3, [r7, #11]
 800fff2:	75fb      	strb	r3, [r7, #23]
    *dest = lv_color_32_32_mix(res, *dest, cache);
 800fff4:	68fb      	ldr	r3, [r7, #12]
 800fff6:	681a      	ldr	r2, [r3, #0]
 800fff8:	4613      	mov	r3, r2
 800fffa:	683a      	ldr	r2, [r7, #0]
 800fffc:	4619      	mov	r1, r3
 800fffe:	6978      	ldr	r0, [r7, #20]
 8010000:	f7ff fed3 	bl	800fdaa <lv_color_32_32_mix>
 8010004:	4602      	mov	r2, r0
 8010006:	68fb      	ldr	r3, [r7, #12]
 8010008:	4611      	mov	r1, r2
 801000a:	7019      	strb	r1, [r3, #0]
 801000c:	f3c2 2107 	ubfx	r1, r2, #8, #8
 8010010:	7059      	strb	r1, [r3, #1]
 8010012:	f3c2 4107 	ubfx	r1, r2, #16, #8
 8010016:	7099      	strb	r1, [r3, #2]
 8010018:	f3c2 6207 	ubfx	r2, r2, #24, #8
 801001c:	70da      	strb	r2, [r3, #3]
 801001e:	e000      	b.n	8010022 <blend_non_normal_pixel+0xfe>
            return;
 8010020:	bf00      	nop
}
 8010022:	3718      	adds	r7, #24
 8010024:	46bd      	mov	sp, r7
 8010026:	bd80      	pop	{r7, pc}

08010028 <drawbuf_next_row>:

static inline void * LV_ATTRIBUTE_FAST_MEM drawbuf_next_row(const void * buf, uint32_t stride)
{
 8010028:	b480      	push	{r7}
 801002a:	b083      	sub	sp, #12
 801002c:	af00      	add	r7, sp, #0
 801002e:	6078      	str	r0, [r7, #4]
 8010030:	6039      	str	r1, [r7, #0]
    return (void *)((uint8_t *)buf + stride);
 8010032:	687a      	ldr	r2, [r7, #4]
 8010034:	683b      	ldr	r3, [r7, #0]
 8010036:	4413      	add	r3, r2
}
 8010038:	4618      	mov	r0, r3
 801003a:	370c      	adds	r7, #12
 801003c:	46bd      	mov	sp, r7
 801003e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010042:	4770      	bx	lr

08010044 <lv_color_16_16_mix>:
 * @return          mix == 0: c2
 *                  mix == 255: c1
 *                  mix == 128: 0.5 x c1 + 0.5 x c2
 */
static inline uint16_t LV_ATTRIBUTE_FAST_MEM lv_color_16_16_mix(uint16_t c1, uint16_t c2, uint8_t mix)
{
 8010044:	b480      	push	{r7}
 8010046:	b087      	sub	sp, #28
 8010048:	af00      	add	r7, sp, #0
 801004a:	4603      	mov	r3, r0
 801004c:	80fb      	strh	r3, [r7, #6]
 801004e:	460b      	mov	r3, r1
 8010050:	80bb      	strh	r3, [r7, #4]
 8010052:	4613      	mov	r3, r2
 8010054:	70fb      	strb	r3, [r7, #3]
    if(mix == 255) return c1;
 8010056:	78fb      	ldrb	r3, [r7, #3]
 8010058:	2bff      	cmp	r3, #255	@ 0xff
 801005a:	d101      	bne.n	8010060 <lv_color_16_16_mix+0x1c>
 801005c:	88fb      	ldrh	r3, [r7, #6]
 801005e:	e02a      	b.n	80100b6 <lv_color_16_16_mix+0x72>
    if(mix == 0) return c2;
 8010060:	78fb      	ldrb	r3, [r7, #3]
 8010062:	2b00      	cmp	r3, #0
 8010064:	d101      	bne.n	801006a <lv_color_16_16_mix+0x26>
 8010066:	88bb      	ldrh	r3, [r7, #4]
 8010068:	e025      	b.n	80100b6 <lv_color_16_16_mix+0x72>

    uint16_t ret;

    /* Source: https://stackoverflow.com/a/50012418/1999969*/
    mix = (uint32_t)((uint32_t)mix + 4) >> 3;
 801006a:	78fb      	ldrb	r3, [r7, #3]
 801006c:	3304      	adds	r3, #4
 801006e:	08db      	lsrs	r3, r3, #3
 8010070:	70fb      	strb	r3, [r7, #3]

    /*0x7E0F81F = 0b00000111111000001111100000011111*/
    uint32_t bg = (uint32_t)(c2 | ((uint32_t)c2 << 16)) & 0x7E0F81F;
 8010072:	88ba      	ldrh	r2, [r7, #4]
 8010074:	4613      	mov	r3, r2
 8010076:	041b      	lsls	r3, r3, #16
 8010078:	441a      	add	r2, r3
 801007a:	4b12      	ldr	r3, [pc, #72]	@ (80100c4 <lv_color_16_16_mix+0x80>)
 801007c:	4013      	ands	r3, r2
 801007e:	617b      	str	r3, [r7, #20]
    uint32_t fg = (uint32_t)(c1 | ((uint32_t)c1 << 16)) & 0x7E0F81F;
 8010080:	88fa      	ldrh	r2, [r7, #6]
 8010082:	4613      	mov	r3, r2
 8010084:	041b      	lsls	r3, r3, #16
 8010086:	441a      	add	r2, r3
 8010088:	4b0e      	ldr	r3, [pc, #56]	@ (80100c4 <lv_color_16_16_mix+0x80>)
 801008a:	4013      	ands	r3, r2
 801008c:	613b      	str	r3, [r7, #16]
    uint32_t result = ((((fg - bg) * mix) >> 5) + bg) & 0x7E0F81F;
 801008e:	693a      	ldr	r2, [r7, #16]
 8010090:	697b      	ldr	r3, [r7, #20]
 8010092:	1ad3      	subs	r3, r2, r3
 8010094:	78fa      	ldrb	r2, [r7, #3]
 8010096:	fb02 f303 	mul.w	r3, r2, r3
 801009a:	095a      	lsrs	r2, r3, #5
 801009c:	697b      	ldr	r3, [r7, #20]
 801009e:	441a      	add	r2, r3
 80100a0:	4b08      	ldr	r3, [pc, #32]	@ (80100c4 <lv_color_16_16_mix+0x80>)
 80100a2:	4013      	ands	r3, r2
 80100a4:	60fb      	str	r3, [r7, #12]
    ret = (uint16_t)(result >> 16) | result;
 80100a6:	68fb      	ldr	r3, [r7, #12]
 80100a8:	0c1b      	lsrs	r3, r3, #16
 80100aa:	b29a      	uxth	r2, r3
 80100ac:	68fb      	ldr	r3, [r7, #12]
 80100ae:	b29b      	uxth	r3, r3
 80100b0:	4313      	orrs	r3, r2
 80100b2:	817b      	strh	r3, [r7, #10]

    return ret;
 80100b4:	897b      	ldrh	r3, [r7, #10]
}
 80100b6:	4618      	mov	r0, r3
 80100b8:	371c      	adds	r7, #28
 80100ba:	46bd      	mov	sp, r7
 80100bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80100c0:	4770      	bx	lr
 80100c2:	bf00      	nop
 80100c4:	07e0f81f 	.word	0x07e0f81f

080100c8 <lv_draw_sw_blend_color_to_rgb565>:
 * @param opa
 * @param mask
 * @param mask_stride
 */
void LV_ATTRIBUTE_FAST_MEM lv_draw_sw_blend_color_to_rgb565(_lv_draw_sw_blend_fill_dsc_t * dsc)
{
 80100c8:	b590      	push	{r4, r7, lr}
 80100ca:	b095      	sub	sp, #84	@ 0x54
 80100cc:	af00      	add	r7, sp, #0
 80100ce:	6078      	str	r0, [r7, #4]
    int32_t w = dsc->dest_w;
 80100d0:	687b      	ldr	r3, [r7, #4]
 80100d2:	685b      	ldr	r3, [r3, #4]
 80100d4:	633b      	str	r3, [r7, #48]	@ 0x30
    int32_t h = dsc->dest_h;
 80100d6:	687b      	ldr	r3, [r7, #4]
 80100d8:	689b      	ldr	r3, [r3, #8]
 80100da:	62fb      	str	r3, [r7, #44]	@ 0x2c
    uint16_t color16 = lv_color_to_u16(dsc->color);
 80100dc:	687b      	ldr	r3, [r7, #4]
 80100de:	6998      	ldr	r0, [r3, #24]
 80100e0:	f012 fa99 	bl	8022616 <lv_color_to_u16>
 80100e4:	4603      	mov	r3, r0
 80100e6:	857b      	strh	r3, [r7, #42]	@ 0x2a
    lv_opa_t opa = dsc->opa;
 80100e8:	687b      	ldr	r3, [r7, #4]
 80100ea:	7edb      	ldrb	r3, [r3, #27]
 80100ec:	f887 3029 	strb.w	r3, [r7, #41]	@ 0x29
    const lv_opa_t * mask = dsc->mask_buf;
 80100f0:	687b      	ldr	r3, [r7, #4]
 80100f2:	691b      	ldr	r3, [r3, #16]
 80100f4:	64fb      	str	r3, [r7, #76]	@ 0x4c
    int32_t mask_stride = dsc->mask_stride;
 80100f6:	687b      	ldr	r3, [r7, #4]
 80100f8:	695b      	ldr	r3, [r3, #20]
 80100fa:	627b      	str	r3, [r7, #36]	@ 0x24
    uint16_t * dest_buf_u16 = dsc->dest_buf;
 80100fc:	687b      	ldr	r3, [r7, #4]
 80100fe:	681b      	ldr	r3, [r3, #0]
 8010100:	64bb      	str	r3, [r7, #72]	@ 0x48
    int32_t dest_stride = dsc->dest_stride;
 8010102:	687b      	ldr	r3, [r7, #4]
 8010104:	68db      	ldr	r3, [r3, #12]
 8010106:	623b      	str	r3, [r7, #32]
    LV_UNUSED(mask_stride);
    LV_UNUSED(dest_stride);
    LV_UNUSED(dest_buf_u16);

    /*Simple fill*/
    if(mask == NULL && opa >= LV_OPA_MAX)  {
 8010108:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801010a:	2b00      	cmp	r3, #0
 801010c:	d16d      	bne.n	80101ea <lv_draw_sw_blend_color_to_rgb565+0x122>
 801010e:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 8010112:	2bfc      	cmp	r3, #252	@ 0xfc
 8010114:	d969      	bls.n	80101ea <lv_draw_sw_blend_color_to_rgb565+0x122>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB565(dsc)) {
            for(y = 0; y < h; y++) {
 8010116:	2300      	movs	r3, #0
 8010118:	643b      	str	r3, [r7, #64]	@ 0x40
 801011a:	e061      	b.n	80101e0 <lv_draw_sw_blend_color_to_rgb565+0x118>
                uint16_t * dest_end_final = dest_buf_u16 + w;
 801011c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801011e:	005b      	lsls	r3, r3, #1
 8010120:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8010122:	4413      	add	r3, r2
 8010124:	61fb      	str	r3, [r7, #28]
                uint32_t * dest_end_mid = (uint32_t *)((uint16_t *) dest_buf_u16 + ((w - 1) & ~(0xF)));
 8010126:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010128:	3b01      	subs	r3, #1
 801012a:	f023 030f 	bic.w	r3, r3, #15
 801012e:	005b      	lsls	r3, r3, #1
 8010130:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8010132:	4413      	add	r3, r2
 8010134:	61bb      	str	r3, [r7, #24]
                if((lv_uintptr_t)&dest_buf_u16[0] & 0x3) {
 8010136:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8010138:	f003 0303 	and.w	r3, r3, #3
 801013c:	2b00      	cmp	r3, #0
 801013e:	d005      	beq.n	801014c <lv_draw_sw_blend_color_to_rgb565+0x84>
                    dest_buf_u16[0] = color16;
 8010140:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8010142:	8d7a      	ldrh	r2, [r7, #42]	@ 0x2a
 8010144:	801a      	strh	r2, [r3, #0]
                    dest_buf_u16++;
 8010146:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8010148:	3302      	adds	r3, #2
 801014a:	64bb      	str	r3, [r7, #72]	@ 0x48
                }

                uint32_t c32 = (uint32_t)color16 + ((uint32_t)color16 << 16);
 801014c:	8d7a      	ldrh	r2, [r7, #42]	@ 0x2a
 801014e:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8010150:	041b      	lsls	r3, r3, #16
 8010152:	4413      	add	r3, r2
 8010154:	617b      	str	r3, [r7, #20]
                uint32_t * dest32 = (uint32_t *)dest_buf_u16;
 8010156:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8010158:	63fb      	str	r3, [r7, #60]	@ 0x3c
                while(dest32 < dest_end_mid) {
 801015a:	e021      	b.n	80101a0 <lv_draw_sw_blend_color_to_rgb565+0xd8>
                    dest32[0] = c32;
 801015c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801015e:	697a      	ldr	r2, [r7, #20]
 8010160:	601a      	str	r2, [r3, #0]
                    dest32[1] = c32;
 8010162:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010164:	3304      	adds	r3, #4
 8010166:	697a      	ldr	r2, [r7, #20]
 8010168:	601a      	str	r2, [r3, #0]
                    dest32[2] = c32;
 801016a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801016c:	3308      	adds	r3, #8
 801016e:	697a      	ldr	r2, [r7, #20]
 8010170:	601a      	str	r2, [r3, #0]
                    dest32[3] = c32;
 8010172:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010174:	330c      	adds	r3, #12
 8010176:	697a      	ldr	r2, [r7, #20]
 8010178:	601a      	str	r2, [r3, #0]
                    dest32[4] = c32;
 801017a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801017c:	3310      	adds	r3, #16
 801017e:	697a      	ldr	r2, [r7, #20]
 8010180:	601a      	str	r2, [r3, #0]
                    dest32[5] = c32;
 8010182:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010184:	3314      	adds	r3, #20
 8010186:	697a      	ldr	r2, [r7, #20]
 8010188:	601a      	str	r2, [r3, #0]
                    dest32[6] = c32;
 801018a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801018c:	3318      	adds	r3, #24
 801018e:	697a      	ldr	r2, [r7, #20]
 8010190:	601a      	str	r2, [r3, #0]
                    dest32[7] = c32;
 8010192:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010194:	331c      	adds	r3, #28
 8010196:	697a      	ldr	r2, [r7, #20]
 8010198:	601a      	str	r2, [r3, #0]
                    dest32 += 8;
 801019a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801019c:	3320      	adds	r3, #32
 801019e:	63fb      	str	r3, [r7, #60]	@ 0x3c
                while(dest32 < dest_end_mid) {
 80101a0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80101a2:	69bb      	ldr	r3, [r7, #24]
 80101a4:	429a      	cmp	r2, r3
 80101a6:	d3d9      	bcc.n	801015c <lv_draw_sw_blend_color_to_rgb565+0x94>
                }

                dest_buf_u16 = (uint16_t *)dest32;
 80101a8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80101aa:	64bb      	str	r3, [r7, #72]	@ 0x48

                while(dest_buf_u16 < dest_end_final) {
 80101ac:	e005      	b.n	80101ba <lv_draw_sw_blend_color_to_rgb565+0xf2>
                    *dest_buf_u16 = color16;
 80101ae:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80101b0:	8d7a      	ldrh	r2, [r7, #42]	@ 0x2a
 80101b2:	801a      	strh	r2, [r3, #0]
                    dest_buf_u16++;
 80101b4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80101b6:	3302      	adds	r3, #2
 80101b8:	64bb      	str	r3, [r7, #72]	@ 0x48
                while(dest_buf_u16 < dest_end_final) {
 80101ba:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80101bc:	69fb      	ldr	r3, [r7, #28]
 80101be:	429a      	cmp	r2, r3
 80101c0:	d3f5      	bcc.n	80101ae <lv_draw_sw_blend_color_to_rgb565+0xe6>
                }

                dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 80101c2:	6a3b      	ldr	r3, [r7, #32]
 80101c4:	4619      	mov	r1, r3
 80101c6:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 80101c8:	f001 fa7a 	bl	80116c0 <drawbuf_next_row>
 80101cc:	64b8      	str	r0, [r7, #72]	@ 0x48
                dest_buf_u16 -= w;
 80101ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80101d0:	005b      	lsls	r3, r3, #1
 80101d2:	425b      	negs	r3, r3
 80101d4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80101d6:	4413      	add	r3, r2
 80101d8:	64bb      	str	r3, [r7, #72]	@ 0x48
            for(y = 0; y < h; y++) {
 80101da:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80101dc:	3301      	adds	r3, #1
 80101de:	643b      	str	r3, [r7, #64]	@ 0x40
 80101e0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80101e2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80101e4:	429a      	cmp	r2, r3
 80101e6:	db99      	blt.n	801011c <lv_draw_sw_blend_color_to_rgb565+0x54>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB565(dsc)) {
 80101e8:	e1a2      	b.n	8010530 <lv_draw_sw_blend_color_to_rgb565+0x468>
            }
        }

    }
    /*Opacity only*/
    else if(mask == NULL && opa < LV_OPA_MAX) {
 80101ea:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80101ec:	2b00      	cmp	r3, #0
 80101ee:	f040 80b6 	bne.w	801035e <lv_draw_sw_blend_color_to_rgb565+0x296>
 80101f2:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 80101f6:	2bfc      	cmp	r3, #252	@ 0xfc
 80101f8:	f200 80b1 	bhi.w	801035e <lv_draw_sw_blend_color_to_rgb565+0x296>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB565_WITH_OPA(dsc)) {
            uint32_t last_dest32_color = dest_buf_u16[0] + 1; /*Set to value which is not equal to the first pixel*/
 80101fc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80101fe:	881b      	ldrh	r3, [r3, #0]
 8010200:	3301      	adds	r3, #1
 8010202:	63bb      	str	r3, [r7, #56]	@ 0x38
            uint32_t last_res32_color = 0;
 8010204:	2300      	movs	r3, #0
 8010206:	637b      	str	r3, [r7, #52]	@ 0x34

            for(y = 0; y < h; y++) {
 8010208:	2300      	movs	r3, #0
 801020a:	643b      	str	r3, [r7, #64]	@ 0x40
 801020c:	e0a1      	b.n	8010352 <lv_draw_sw_blend_color_to_rgb565+0x28a>
                x = 0;
 801020e:	2300      	movs	r3, #0
 8010210:	647b      	str	r3, [r7, #68]	@ 0x44
                if((lv_uintptr_t)&dest_buf_u16[0] & 0x3) {
 8010212:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8010214:	f003 0303 	and.w	r3, r3, #3
 8010218:	2b00      	cmp	r3, #0
 801021a:	d073      	beq.n	8010304 <lv_draw_sw_blend_color_to_rgb565+0x23c>
                    dest_buf_u16[0] = lv_color_16_16_mix(color16, dest_buf_u16[0], opa);
 801021c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801021e:	8819      	ldrh	r1, [r3, #0]
 8010220:	f897 2029 	ldrb.w	r2, [r7, #41]	@ 0x29
 8010224:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8010226:	4618      	mov	r0, r3
 8010228:	f7ff ff0c 	bl	8010044 <lv_color_16_16_mix>
 801022c:	4603      	mov	r3, r0
 801022e:	461a      	mov	r2, r3
 8010230:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8010232:	801a      	strh	r2, [r3, #0]
                    x = 1;
 8010234:	2301      	movs	r3, #1
 8010236:	647b      	str	r3, [r7, #68]	@ 0x44
                }

                for(; x < w - 2; x += 2) {
 8010238:	e064      	b.n	8010304 <lv_draw_sw_blend_color_to_rgb565+0x23c>
                    if(dest_buf_u16[x] != dest_buf_u16[x + 1]) {
 801023a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801023c:	005b      	lsls	r3, r3, #1
 801023e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8010240:	4413      	add	r3, r2
 8010242:	881a      	ldrh	r2, [r3, #0]
 8010244:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010246:	3301      	adds	r3, #1
 8010248:	005b      	lsls	r3, r3, #1
 801024a:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 801024c:	440b      	add	r3, r1
 801024e:	881b      	ldrh	r3, [r3, #0]
 8010250:	429a      	cmp	r2, r3
 8010252:	d024      	beq.n	801029e <lv_draw_sw_blend_color_to_rgb565+0x1d6>
                        dest_buf_u16[x + 0] = lv_color_16_16_mix(color16, dest_buf_u16[x + 0], opa);
 8010254:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010256:	005b      	lsls	r3, r3, #1
 8010258:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801025a:	4413      	add	r3, r2
 801025c:	8819      	ldrh	r1, [r3, #0]
 801025e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010260:	005b      	lsls	r3, r3, #1
 8010262:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8010264:	18d4      	adds	r4, r2, r3
 8010266:	f897 2029 	ldrb.w	r2, [r7, #41]	@ 0x29
 801026a:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 801026c:	4618      	mov	r0, r3
 801026e:	f7ff fee9 	bl	8010044 <lv_color_16_16_mix>
 8010272:	4603      	mov	r3, r0
 8010274:	8023      	strh	r3, [r4, #0]
                        dest_buf_u16[x + 1] = lv_color_16_16_mix(color16, dest_buf_u16[x + 1], opa);
 8010276:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010278:	3301      	adds	r3, #1
 801027a:	005b      	lsls	r3, r3, #1
 801027c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801027e:	4413      	add	r3, r2
 8010280:	8819      	ldrh	r1, [r3, #0]
 8010282:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010284:	3301      	adds	r3, #1
 8010286:	005b      	lsls	r3, r3, #1
 8010288:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801028a:	18d4      	adds	r4, r2, r3
 801028c:	f897 2029 	ldrb.w	r2, [r7, #41]	@ 0x29
 8010290:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8010292:	4618      	mov	r0, r3
 8010294:	f7ff fed6 	bl	8010044 <lv_color_16_16_mix>
 8010298:	4603      	mov	r3, r0
 801029a:	8023      	strh	r3, [r4, #0]
 801029c:	e02f      	b.n	80102fe <lv_draw_sw_blend_color_to_rgb565+0x236>
                    }
                    else {
                        volatile uint32_t * dest32 = (uint32_t *)&dest_buf_u16[x];
 801029e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80102a0:	005b      	lsls	r3, r3, #1
 80102a2:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80102a4:	4413      	add	r3, r2
 80102a6:	613b      	str	r3, [r7, #16]
                        if(last_dest32_color == *dest32) {
 80102a8:	693b      	ldr	r3, [r7, #16]
 80102aa:	681b      	ldr	r3, [r3, #0]
 80102ac:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80102ae:	429a      	cmp	r2, r3
 80102b0:	d103      	bne.n	80102ba <lv_draw_sw_blend_color_to_rgb565+0x1f2>
                            *dest32 = last_res32_color;
 80102b2:	693b      	ldr	r3, [r7, #16]
 80102b4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80102b6:	601a      	str	r2, [r3, #0]
 80102b8:	e021      	b.n	80102fe <lv_draw_sw_blend_color_to_rgb565+0x236>
                        }
                        else {
                            last_dest32_color =  *dest32;
 80102ba:	693b      	ldr	r3, [r7, #16]
 80102bc:	681b      	ldr	r3, [r3, #0]
 80102be:	63bb      	str	r3, [r7, #56]	@ 0x38

                            dest_buf_u16[x] = lv_color_16_16_mix(color16, dest_buf_u16[x + 0], opa);
 80102c0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80102c2:	005b      	lsls	r3, r3, #1
 80102c4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80102c6:	4413      	add	r3, r2
 80102c8:	8819      	ldrh	r1, [r3, #0]
 80102ca:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80102cc:	005b      	lsls	r3, r3, #1
 80102ce:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80102d0:	18d4      	adds	r4, r2, r3
 80102d2:	f897 2029 	ldrb.w	r2, [r7, #41]	@ 0x29
 80102d6:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 80102d8:	4618      	mov	r0, r3
 80102da:	f7ff feb3 	bl	8010044 <lv_color_16_16_mix>
 80102de:	4603      	mov	r3, r0
 80102e0:	8023      	strh	r3, [r4, #0]
                            dest_buf_u16[x + 1] = dest_buf_u16[x];
 80102e2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80102e4:	005b      	lsls	r3, r3, #1
 80102e6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80102e8:	441a      	add	r2, r3
 80102ea:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80102ec:	3301      	adds	r3, #1
 80102ee:	005b      	lsls	r3, r3, #1
 80102f0:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 80102f2:	440b      	add	r3, r1
 80102f4:	8812      	ldrh	r2, [r2, #0]
 80102f6:	801a      	strh	r2, [r3, #0]

                            last_res32_color = *dest32;
 80102f8:	693b      	ldr	r3, [r7, #16]
 80102fa:	681b      	ldr	r3, [r3, #0]
 80102fc:	637b      	str	r3, [r7, #52]	@ 0x34
                for(; x < w - 2; x += 2) {
 80102fe:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010300:	3302      	adds	r3, #2
 8010302:	647b      	str	r3, [r7, #68]	@ 0x44
 8010304:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010306:	3b02      	subs	r3, #2
 8010308:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801030a:	429a      	cmp	r2, r3
 801030c:	db95      	blt.n	801023a <lv_draw_sw_blend_color_to_rgb565+0x172>
                        }
                    }
                }

                for(; x < w ; x++) {
 801030e:	e013      	b.n	8010338 <lv_draw_sw_blend_color_to_rgb565+0x270>
                    dest_buf_u16[x] = lv_color_16_16_mix(color16, dest_buf_u16[x], opa);
 8010310:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010312:	005b      	lsls	r3, r3, #1
 8010314:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8010316:	4413      	add	r3, r2
 8010318:	8819      	ldrh	r1, [r3, #0]
 801031a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801031c:	005b      	lsls	r3, r3, #1
 801031e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8010320:	18d4      	adds	r4, r2, r3
 8010322:	f897 2029 	ldrb.w	r2, [r7, #41]	@ 0x29
 8010326:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8010328:	4618      	mov	r0, r3
 801032a:	f7ff fe8b 	bl	8010044 <lv_color_16_16_mix>
 801032e:	4603      	mov	r3, r0
 8010330:	8023      	strh	r3, [r4, #0]
                for(; x < w ; x++) {
 8010332:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010334:	3301      	adds	r3, #1
 8010336:	647b      	str	r3, [r7, #68]	@ 0x44
 8010338:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801033a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801033c:	429a      	cmp	r2, r3
 801033e:	dbe7      	blt.n	8010310 <lv_draw_sw_blend_color_to_rgb565+0x248>
                }
                dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 8010340:	6a3b      	ldr	r3, [r7, #32]
 8010342:	4619      	mov	r1, r3
 8010344:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8010346:	f001 f9bb 	bl	80116c0 <drawbuf_next_row>
 801034a:	64b8      	str	r0, [r7, #72]	@ 0x48
            for(y = 0; y < h; y++) {
 801034c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801034e:	3301      	adds	r3, #1
 8010350:	643b      	str	r3, [r7, #64]	@ 0x40
 8010352:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8010354:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010356:	429a      	cmp	r2, r3
 8010358:	f6ff af59 	blt.w	801020e <lv_draw_sw_blend_color_to_rgb565+0x146>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB565_WITH_OPA(dsc)) {
 801035c:	e0e8      	b.n	8010530 <lv_draw_sw_blend_color_to_rgb565+0x468>
        }

    }

    /*Masked with full opacity*/
    else if(mask && opa >= LV_OPA_MAX) {
 801035e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8010360:	2b00      	cmp	r3, #0
 8010362:	f000 80a4 	beq.w	80104ae <lv_draw_sw_blend_color_to_rgb565+0x3e6>
 8010366:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 801036a:	2bfc      	cmp	r3, #252	@ 0xfc
 801036c:	f240 809f 	bls.w	80104ae <lv_draw_sw_blend_color_to_rgb565+0x3e6>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB565_WITH_MASK(dsc)) {
            for(y = 0; y < h; y++) {
 8010370:	2300      	movs	r3, #0
 8010372:	643b      	str	r3, [r7, #64]	@ 0x40
 8010374:	e095      	b.n	80104a2 <lv_draw_sw_blend_color_to_rgb565+0x3da>
                x = 0;
 8010376:	2300      	movs	r3, #0
 8010378:	647b      	str	r3, [r7, #68]	@ 0x44
                if((lv_uintptr_t)(mask) & 0x1) {
 801037a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801037c:	f003 0301 	and.w	r3, r3, #1
 8010380:	2b00      	cmp	r3, #0
 8010382:	d060      	beq.n	8010446 <lv_draw_sw_blend_color_to_rgb565+0x37e>
                    dest_buf_u16[x] = lv_color_16_16_mix(color16, dest_buf_u16[x], mask[x]);
 8010384:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010386:	005b      	lsls	r3, r3, #1
 8010388:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801038a:	4413      	add	r3, r2
 801038c:	8819      	ldrh	r1, [r3, #0]
 801038e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010390:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8010392:	4413      	add	r3, r2
 8010394:	7818      	ldrb	r0, [r3, #0]
 8010396:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010398:	005b      	lsls	r3, r3, #1
 801039a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801039c:	18d4      	adds	r4, r2, r3
 801039e:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 80103a0:	4602      	mov	r2, r0
 80103a2:	4618      	mov	r0, r3
 80103a4:	f7ff fe4e 	bl	8010044 <lv_color_16_16_mix>
 80103a8:	4603      	mov	r3, r0
 80103aa:	8023      	strh	r3, [r4, #0]
                    x++;
 80103ac:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80103ae:	3301      	adds	r3, #1
 80103b0:	647b      	str	r3, [r7, #68]	@ 0x44
                }

                for(; x <= w - 2; x += 2) {
 80103b2:	e048      	b.n	8010446 <lv_draw_sw_blend_color_to_rgb565+0x37e>
                    uint16_t mask16 = *((uint16_t *)&mask[x]);
 80103b4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80103b6:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80103b8:	4413      	add	r3, r2
 80103ba:	881b      	ldrh	r3, [r3, #0]
 80103bc:	81fb      	strh	r3, [r7, #14]
                    if(mask16 == 0xFFFF) {
 80103be:	89fb      	ldrh	r3, [r7, #14]
 80103c0:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80103c4:	4293      	cmp	r3, r2
 80103c6:	d10d      	bne.n	80103e4 <lv_draw_sw_blend_color_to_rgb565+0x31c>
                        dest_buf_u16[x + 0] = color16;
 80103c8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80103ca:	005b      	lsls	r3, r3, #1
 80103cc:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80103ce:	4413      	add	r3, r2
 80103d0:	8d7a      	ldrh	r2, [r7, #42]	@ 0x2a
 80103d2:	801a      	strh	r2, [r3, #0]
                        dest_buf_u16[x + 1] = color16;
 80103d4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80103d6:	3301      	adds	r3, #1
 80103d8:	005b      	lsls	r3, r3, #1
 80103da:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80103dc:	4413      	add	r3, r2
 80103de:	8d7a      	ldrh	r2, [r7, #42]	@ 0x2a
 80103e0:	801a      	strh	r2, [r3, #0]
 80103e2:	e02d      	b.n	8010440 <lv_draw_sw_blend_color_to_rgb565+0x378>
                    }
                    else if(mask16 != 0) {
 80103e4:	89fb      	ldrh	r3, [r7, #14]
 80103e6:	2b00      	cmp	r3, #0
 80103e8:	d02a      	beq.n	8010440 <lv_draw_sw_blend_color_to_rgb565+0x378>
                        dest_buf_u16[x + 0] = lv_color_16_16_mix(color16, dest_buf_u16[x + 0], mask[x + 0]);
 80103ea:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80103ec:	005b      	lsls	r3, r3, #1
 80103ee:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80103f0:	4413      	add	r3, r2
 80103f2:	8819      	ldrh	r1, [r3, #0]
 80103f4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80103f6:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80103f8:	4413      	add	r3, r2
 80103fa:	7818      	ldrb	r0, [r3, #0]
 80103fc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80103fe:	005b      	lsls	r3, r3, #1
 8010400:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8010402:	18d4      	adds	r4, r2, r3
 8010404:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8010406:	4602      	mov	r2, r0
 8010408:	4618      	mov	r0, r3
 801040a:	f7ff fe1b 	bl	8010044 <lv_color_16_16_mix>
 801040e:	4603      	mov	r3, r0
 8010410:	8023      	strh	r3, [r4, #0]
                        dest_buf_u16[x + 1] = lv_color_16_16_mix(color16, dest_buf_u16[x + 1], mask[x + 1]);
 8010412:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010414:	3301      	adds	r3, #1
 8010416:	005b      	lsls	r3, r3, #1
 8010418:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801041a:	4413      	add	r3, r2
 801041c:	8819      	ldrh	r1, [r3, #0]
 801041e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010420:	3301      	adds	r3, #1
 8010422:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8010424:	4413      	add	r3, r2
 8010426:	7818      	ldrb	r0, [r3, #0]
 8010428:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801042a:	3301      	adds	r3, #1
 801042c:	005b      	lsls	r3, r3, #1
 801042e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8010430:	18d4      	adds	r4, r2, r3
 8010432:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8010434:	4602      	mov	r2, r0
 8010436:	4618      	mov	r0, r3
 8010438:	f7ff fe04 	bl	8010044 <lv_color_16_16_mix>
 801043c:	4603      	mov	r3, r0
 801043e:	8023      	strh	r3, [r4, #0]
                for(; x <= w - 2; x += 2) {
 8010440:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010442:	3302      	adds	r3, #2
 8010444:	647b      	str	r3, [r7, #68]	@ 0x44
 8010446:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010448:	3b01      	subs	r3, #1
 801044a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801044c:	429a      	cmp	r2, r3
 801044e:	dbb1      	blt.n	80103b4 <lv_draw_sw_blend_color_to_rgb565+0x2ec>
                    }
                }

                for(; x < w ; x++) {
 8010450:	e016      	b.n	8010480 <lv_draw_sw_blend_color_to_rgb565+0x3b8>
                    dest_buf_u16[x] = lv_color_16_16_mix(color16, dest_buf_u16[x], mask[x]);
 8010452:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010454:	005b      	lsls	r3, r3, #1
 8010456:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8010458:	4413      	add	r3, r2
 801045a:	8819      	ldrh	r1, [r3, #0]
 801045c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801045e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8010460:	4413      	add	r3, r2
 8010462:	7818      	ldrb	r0, [r3, #0]
 8010464:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010466:	005b      	lsls	r3, r3, #1
 8010468:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801046a:	18d4      	adds	r4, r2, r3
 801046c:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 801046e:	4602      	mov	r2, r0
 8010470:	4618      	mov	r0, r3
 8010472:	f7ff fde7 	bl	8010044 <lv_color_16_16_mix>
 8010476:	4603      	mov	r3, r0
 8010478:	8023      	strh	r3, [r4, #0]
                for(; x < w ; x++) {
 801047a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801047c:	3301      	adds	r3, #1
 801047e:	647b      	str	r3, [r7, #68]	@ 0x44
 8010480:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8010482:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010484:	429a      	cmp	r2, r3
 8010486:	dbe4      	blt.n	8010452 <lv_draw_sw_blend_color_to_rgb565+0x38a>
                }
                dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 8010488:	6a3b      	ldr	r3, [r7, #32]
 801048a:	4619      	mov	r1, r3
 801048c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 801048e:	f001 f917 	bl	80116c0 <drawbuf_next_row>
 8010492:	64b8      	str	r0, [r7, #72]	@ 0x48
                mask += mask_stride;
 8010494:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8010496:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8010498:	4413      	add	r3, r2
 801049a:	64fb      	str	r3, [r7, #76]	@ 0x4c
            for(y = 0; y < h; y++) {
 801049c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801049e:	3301      	adds	r3, #1
 80104a0:	643b      	str	r3, [r7, #64]	@ 0x40
 80104a2:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80104a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80104a6:	429a      	cmp	r2, r3
 80104a8:	f6ff af65 	blt.w	8010376 <lv_draw_sw_blend_color_to_rgb565+0x2ae>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB565_WITH_MASK(dsc)) {
 80104ac:	e040      	b.n	8010530 <lv_draw_sw_blend_color_to_rgb565+0x468>
            }
        }

    }
    /*Masked with opacity*/
    else if(mask && opa < LV_OPA_MAX) {
 80104ae:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80104b0:	2b00      	cmp	r3, #0
 80104b2:	d03d      	beq.n	8010530 <lv_draw_sw_blend_color_to_rgb565+0x468>
 80104b4:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 80104b8:	2bfc      	cmp	r3, #252	@ 0xfc
 80104ba:	d839      	bhi.n	8010530 <lv_draw_sw_blend_color_to_rgb565+0x468>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB565_MIX_MASK_OPA(dsc)) {
            for(y = 0; y < h; y++) {
 80104bc:	2300      	movs	r3, #0
 80104be:	643b      	str	r3, [r7, #64]	@ 0x40
 80104c0:	e031      	b.n	8010526 <lv_draw_sw_blend_color_to_rgb565+0x45e>
                for(x = 0; x < w; x++) {
 80104c2:	2300      	movs	r3, #0
 80104c4:	647b      	str	r3, [r7, #68]	@ 0x44
 80104c6:	e01d      	b.n	8010504 <lv_draw_sw_blend_color_to_rgb565+0x43c>
                    dest_buf_u16[x] = lv_color_16_16_mix(color16, dest_buf_u16[x], LV_OPA_MIX2(mask[x], opa));
 80104c8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80104ca:	005b      	lsls	r3, r3, #1
 80104cc:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80104ce:	4413      	add	r3, r2
 80104d0:	8819      	ldrh	r1, [r3, #0]
 80104d2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80104d4:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80104d6:	4413      	add	r3, r2
 80104d8:	781b      	ldrb	r3, [r3, #0]
 80104da:	461a      	mov	r2, r3
 80104dc:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 80104e0:	fb02 f303 	mul.w	r3, r2, r3
 80104e4:	121b      	asrs	r3, r3, #8
 80104e6:	b2d8      	uxtb	r0, r3
 80104e8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80104ea:	005b      	lsls	r3, r3, #1
 80104ec:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80104ee:	18d4      	adds	r4, r2, r3
 80104f0:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 80104f2:	4602      	mov	r2, r0
 80104f4:	4618      	mov	r0, r3
 80104f6:	f7ff fda5 	bl	8010044 <lv_color_16_16_mix>
 80104fa:	4603      	mov	r3, r0
 80104fc:	8023      	strh	r3, [r4, #0]
                for(x = 0; x < w; x++) {
 80104fe:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8010500:	3301      	adds	r3, #1
 8010502:	647b      	str	r3, [r7, #68]	@ 0x44
 8010504:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8010506:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010508:	429a      	cmp	r2, r3
 801050a:	dbdd      	blt.n	80104c8 <lv_draw_sw_blend_color_to_rgb565+0x400>
                }
                dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 801050c:	6a3b      	ldr	r3, [r7, #32]
 801050e:	4619      	mov	r1, r3
 8010510:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8010512:	f001 f8d5 	bl	80116c0 <drawbuf_next_row>
 8010516:	64b8      	str	r0, [r7, #72]	@ 0x48
                mask += mask_stride;
 8010518:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801051a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801051c:	4413      	add	r3, r2
 801051e:	64fb      	str	r3, [r7, #76]	@ 0x4c
            for(y = 0; y < h; y++) {
 8010520:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8010522:	3301      	adds	r3, #1
 8010524:	643b      	str	r3, [r7, #64]	@ 0x40
 8010526:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8010528:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801052a:	429a      	cmp	r2, r3
 801052c:	dbc9      	blt.n	80104c2 <lv_draw_sw_blend_color_to_rgb565+0x3fa>
            }
        }
    }
}
 801052e:	e7ff      	b.n	8010530 <lv_draw_sw_blend_color_to_rgb565+0x468>
 8010530:	bf00      	nop
 8010532:	3754      	adds	r7, #84	@ 0x54
 8010534:	46bd      	mov	sp, r7
 8010536:	bd90      	pop	{r4, r7, pc}

08010538 <lv_draw_sw_blend_image_to_rgb565>:

void LV_ATTRIBUTE_FAST_MEM lv_draw_sw_blend_image_to_rgb565(_lv_draw_sw_blend_image_dsc_t * dsc)
{
 8010538:	b580      	push	{r7, lr}
 801053a:	b082      	sub	sp, #8
 801053c:	af00      	add	r7, sp, #0
 801053e:	6078      	str	r0, [r7, #4]
    switch(dsc->src_color_format) {
 8010540:	687b      	ldr	r3, [r7, #4]
 8010542:	f893 3020 	ldrb.w	r3, [r3, #32]
 8010546:	3b0f      	subs	r3, #15
 8010548:	2b03      	cmp	r3, #3
 801054a:	d81d      	bhi.n	8010588 <lv_draw_sw_blend_image_to_rgb565+0x50>
 801054c:	a201      	add	r2, pc, #4	@ (adr r2, 8010554 <lv_draw_sw_blend_image_to_rgb565+0x1c>)
 801054e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8010552:	bf00      	nop
 8010554:	0801056d 	.word	0x0801056d
 8010558:	08010581 	.word	0x08010581
 801055c:	08010577 	.word	0x08010577
 8010560:	08010565 	.word	0x08010565
        case LV_COLOR_FORMAT_RGB565:
            rgb565_image_blend(dsc);
 8010564:	6878      	ldr	r0, [r7, #4]
 8010566:	f000 f815 	bl	8010594 <rgb565_image_blend>
            break;
 801056a:	e00e      	b.n	801058a <lv_draw_sw_blend_image_to_rgb565+0x52>
        case LV_COLOR_FORMAT_RGB888:
            rgb888_image_blend(dsc, 3);
 801056c:	2103      	movs	r1, #3
 801056e:	6878      	ldr	r0, [r7, #4]
 8010570:	f000 faac 	bl	8010acc <rgb888_image_blend>
            break;
 8010574:	e009      	b.n	801058a <lv_draw_sw_blend_image_to_rgb565+0x52>
        case LV_COLOR_FORMAT_XRGB8888:
            rgb888_image_blend(dsc, 4);
 8010576:	2104      	movs	r1, #4
 8010578:	6878      	ldr	r0, [r7, #4]
 801057a:	f000 faa7 	bl	8010acc <rgb888_image_blend>
            break;
 801057e:	e004      	b.n	801058a <lv_draw_sw_blend_image_to_rgb565+0x52>
        case LV_COLOR_FORMAT_ARGB8888:
            argb8888_image_blend(dsc);
 8010580:	6878      	ldr	r0, [r7, #4]
 8010582:	f000 fd47 	bl	8011014 <argb8888_image_blend>
            break;
 8010586:	e000      	b.n	801058a <lv_draw_sw_blend_image_to_rgb565+0x52>
        default:
            LV_LOG_WARN("Not supported source color format");
            break;
 8010588:	bf00      	nop
    }
}
 801058a:	bf00      	nop
 801058c:	3708      	adds	r7, #8
 801058e:	46bd      	mov	sp, r7
 8010590:	bd80      	pop	{r7, pc}
 8010592:	bf00      	nop

08010594 <rgb565_image_blend>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void LV_ATTRIBUTE_FAST_MEM rgb565_image_blend(_lv_draw_sw_blend_image_dsc_t * dsc)
{
 8010594:	b5b0      	push	{r4, r5, r7, lr}
 8010596:	b092      	sub	sp, #72	@ 0x48
 8010598:	af00      	add	r7, sp, #0
 801059a:	6078      	str	r0, [r7, #4]
    int32_t w = dsc->dest_w;
 801059c:	687b      	ldr	r3, [r7, #4]
 801059e:	685b      	ldr	r3, [r3, #4]
 80105a0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int32_t h = dsc->dest_h;
 80105a2:	687b      	ldr	r3, [r7, #4]
 80105a4:	689b      	ldr	r3, [r3, #8]
 80105a6:	62bb      	str	r3, [r7, #40]	@ 0x28
    lv_opa_t opa = dsc->opa;
 80105a8:	687b      	ldr	r3, [r7, #4]
 80105aa:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 80105ae:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    uint16_t * dest_buf_u16 = dsc->dest_buf;
 80105b2:	687b      	ldr	r3, [r7, #4]
 80105b4:	681b      	ldr	r3, [r3, #0]
 80105b6:	647b      	str	r3, [r7, #68]	@ 0x44
    int32_t dest_stride = dsc->dest_stride;
 80105b8:	687b      	ldr	r3, [r7, #4]
 80105ba:	68db      	ldr	r3, [r3, #12]
 80105bc:	623b      	str	r3, [r7, #32]
    const uint16_t * src_buf_u16 = dsc->src_buf;
 80105be:	687b      	ldr	r3, [r7, #4]
 80105c0:	699b      	ldr	r3, [r3, #24]
 80105c2:	643b      	str	r3, [r7, #64]	@ 0x40
    int32_t src_stride = dsc->src_stride;
 80105c4:	687b      	ldr	r3, [r7, #4]
 80105c6:	69db      	ldr	r3, [r3, #28]
 80105c8:	61fb      	str	r3, [r7, #28]
    const lv_opa_t * mask_buf = dsc->mask_buf;
 80105ca:	687b      	ldr	r3, [r7, #4]
 80105cc:	691b      	ldr	r3, [r3, #16]
 80105ce:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int32_t mask_stride = dsc->mask_stride;
 80105d0:	687b      	ldr	r3, [r7, #4]
 80105d2:	695b      	ldr	r3, [r3, #20]
 80105d4:	61bb      	str	r3, [r7, #24]

    int32_t x;
    int32_t y;

    if(dsc->blend_mode == LV_BLEND_MODE_NORMAL) {
 80105d6:	687b      	ldr	r3, [r7, #4]
 80105d8:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 80105dc:	2b00      	cmp	r3, #0
 80105de:	f040 80e9 	bne.w	80107b4 <rgb565_image_blend+0x220>
        if(mask_buf == NULL && opa >= LV_OPA_MAX) {
 80105e2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80105e4:	2b00      	cmp	r3, #0
 80105e6:	d122      	bne.n	801062e <rgb565_image_blend+0x9a>
 80105e8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80105ec:	2bfc      	cmp	r3, #252	@ 0xfc
 80105ee:	d91e      	bls.n	801062e <rgb565_image_blend+0x9a>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB565(dsc)) {
                uint32_t line_in_bytes = w * 2;
 80105f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80105f2:	005b      	lsls	r3, r3, #1
 80105f4:	60fb      	str	r3, [r7, #12]
                for(y = 0; y < h; y++) {
 80105f6:	2300      	movs	r3, #0
 80105f8:	637b      	str	r3, [r7, #52]	@ 0x34
 80105fa:	e013      	b.n	8010624 <rgb565_image_blend+0x90>
                    lv_memcpy(dest_buf_u16, src_buf_u16, line_in_bytes);
 80105fc:	68fa      	ldr	r2, [r7, #12]
 80105fe:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 8010600:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8010602:	f014 f9f1 	bl	80249e8 <lv_memcpy>
                    dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 8010606:	6a3b      	ldr	r3, [r7, #32]
 8010608:	4619      	mov	r1, r3
 801060a:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801060c:	f001 f858 	bl	80116c0 <drawbuf_next_row>
 8010610:	6478      	str	r0, [r7, #68]	@ 0x44
                    src_buf_u16 = drawbuf_next_row(src_buf_u16, src_stride);
 8010612:	69fb      	ldr	r3, [r7, #28]
 8010614:	4619      	mov	r1, r3
 8010616:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8010618:	f001 f852 	bl	80116c0 <drawbuf_next_row>
 801061c:	6438      	str	r0, [r7, #64]	@ 0x40
                for(y = 0; y < h; y++) {
 801061e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010620:	3301      	adds	r3, #1
 8010622:	637b      	str	r3, [r7, #52]	@ 0x34
 8010624:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8010626:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010628:	429a      	cmp	r2, r3
 801062a:	dbe7      	blt.n	80105fc <rgb565_image_blend+0x68>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB565(dsc)) {
 801062c:	e24b      	b.n	8010ac6 <rgb565_image_blend+0x532>
                }
            }
        }
        else if(mask_buf == NULL && opa < LV_OPA_MAX) {
 801062e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010630:	2b00      	cmp	r3, #0
 8010632:	d139      	bne.n	80106a8 <rgb565_image_blend+0x114>
 8010634:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8010638:	2bfc      	cmp	r3, #252	@ 0xfc
 801063a:	d835      	bhi.n	80106a8 <rgb565_image_blend+0x114>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB565_WITH_OPA(dsc)) {
                for(y = 0; y < h; y++) {
 801063c:	2300      	movs	r3, #0
 801063e:	637b      	str	r3, [r7, #52]	@ 0x34
 8010640:	e02d      	b.n	801069e <rgb565_image_blend+0x10a>
                    for(x = 0; x < w; x++) {
 8010642:	2300      	movs	r3, #0
 8010644:	63bb      	str	r3, [r7, #56]	@ 0x38
 8010646:	e017      	b.n	8010678 <rgb565_image_blend+0xe4>
                        dest_buf_u16[x] = lv_color_16_16_mix(src_buf_u16[x], dest_buf_u16[x], opa);
 8010648:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801064a:	005b      	lsls	r3, r3, #1
 801064c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801064e:	4413      	add	r3, r2
 8010650:	8818      	ldrh	r0, [r3, #0]
 8010652:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010654:	005b      	lsls	r3, r3, #1
 8010656:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8010658:	4413      	add	r3, r2
 801065a:	8819      	ldrh	r1, [r3, #0]
 801065c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801065e:	005b      	lsls	r3, r3, #1
 8010660:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8010662:	18d4      	adds	r4, r2, r3
 8010664:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8010668:	461a      	mov	r2, r3
 801066a:	f7ff fceb 	bl	8010044 <lv_color_16_16_mix>
 801066e:	4603      	mov	r3, r0
 8010670:	8023      	strh	r3, [r4, #0]
                    for(x = 0; x < w; x++) {
 8010672:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010674:	3301      	adds	r3, #1
 8010676:	63bb      	str	r3, [r7, #56]	@ 0x38
 8010678:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801067a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801067c:	429a      	cmp	r2, r3
 801067e:	dbe3      	blt.n	8010648 <rgb565_image_blend+0xb4>
                    }
                    dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 8010680:	6a3b      	ldr	r3, [r7, #32]
 8010682:	4619      	mov	r1, r3
 8010684:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8010686:	f001 f81b 	bl	80116c0 <drawbuf_next_row>
 801068a:	6478      	str	r0, [r7, #68]	@ 0x44
                    src_buf_u16 = drawbuf_next_row(src_buf_u16, src_stride);
 801068c:	69fb      	ldr	r3, [r7, #28]
 801068e:	4619      	mov	r1, r3
 8010690:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8010692:	f001 f815 	bl	80116c0 <drawbuf_next_row>
 8010696:	6438      	str	r0, [r7, #64]	@ 0x40
                for(y = 0; y < h; y++) {
 8010698:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801069a:	3301      	adds	r3, #1
 801069c:	637b      	str	r3, [r7, #52]	@ 0x34
 801069e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80106a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80106a2:	429a      	cmp	r2, r3
 80106a4:	dbcd      	blt.n	8010642 <rgb565_image_blend+0xae>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB565_WITH_OPA(dsc)) {
 80106a6:	e20e      	b.n	8010ac6 <rgb565_image_blend+0x532>
                }
            }
        }
        else if(mask_buf && opa >= LV_OPA_MAX) {
 80106a8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80106aa:	2b00      	cmp	r3, #0
 80106ac:	d03f      	beq.n	801072e <rgb565_image_blend+0x19a>
 80106ae:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80106b2:	2bfc      	cmp	r3, #252	@ 0xfc
 80106b4:	d93b      	bls.n	801072e <rgb565_image_blend+0x19a>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB565_WITH_MASK(dsc)) {
                for(y = 0; y < h; y++) {
 80106b6:	2300      	movs	r3, #0
 80106b8:	637b      	str	r3, [r7, #52]	@ 0x34
 80106ba:	e033      	b.n	8010724 <rgb565_image_blend+0x190>
                    for(x = 0; x < w; x++) {
 80106bc:	2300      	movs	r3, #0
 80106be:	63bb      	str	r3, [r7, #56]	@ 0x38
 80106c0:	e019      	b.n	80106f6 <rgb565_image_blend+0x162>
                        dest_buf_u16[x] = lv_color_16_16_mix(src_buf_u16[x], dest_buf_u16[x], mask_buf[x]);
 80106c2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80106c4:	005b      	lsls	r3, r3, #1
 80106c6:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80106c8:	4413      	add	r3, r2
 80106ca:	8818      	ldrh	r0, [r3, #0]
 80106cc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80106ce:	005b      	lsls	r3, r3, #1
 80106d0:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80106d2:	4413      	add	r3, r2
 80106d4:	8819      	ldrh	r1, [r3, #0]
 80106d6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80106d8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80106da:	4413      	add	r3, r2
 80106dc:	781d      	ldrb	r5, [r3, #0]
 80106de:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80106e0:	005b      	lsls	r3, r3, #1
 80106e2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80106e4:	18d4      	adds	r4, r2, r3
 80106e6:	462a      	mov	r2, r5
 80106e8:	f7ff fcac 	bl	8010044 <lv_color_16_16_mix>
 80106ec:	4603      	mov	r3, r0
 80106ee:	8023      	strh	r3, [r4, #0]
                    for(x = 0; x < w; x++) {
 80106f0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80106f2:	3301      	adds	r3, #1
 80106f4:	63bb      	str	r3, [r7, #56]	@ 0x38
 80106f6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80106f8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80106fa:	429a      	cmp	r2, r3
 80106fc:	dbe1      	blt.n	80106c2 <rgb565_image_blend+0x12e>
                    }
                    dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 80106fe:	6a3b      	ldr	r3, [r7, #32]
 8010700:	4619      	mov	r1, r3
 8010702:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8010704:	f000 ffdc 	bl	80116c0 <drawbuf_next_row>
 8010708:	6478      	str	r0, [r7, #68]	@ 0x44
                    src_buf_u16 = drawbuf_next_row(src_buf_u16, src_stride);
 801070a:	69fb      	ldr	r3, [r7, #28]
 801070c:	4619      	mov	r1, r3
 801070e:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8010710:	f000 ffd6 	bl	80116c0 <drawbuf_next_row>
 8010714:	6438      	str	r0, [r7, #64]	@ 0x40
                    mask_buf += mask_stride;
 8010716:	69bb      	ldr	r3, [r7, #24]
 8010718:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801071a:	4413      	add	r3, r2
 801071c:	63fb      	str	r3, [r7, #60]	@ 0x3c
                for(y = 0; y < h; y++) {
 801071e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010720:	3301      	adds	r3, #1
 8010722:	637b      	str	r3, [r7, #52]	@ 0x34
 8010724:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8010726:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010728:	429a      	cmp	r2, r3
 801072a:	dbc7      	blt.n	80106bc <rgb565_image_blend+0x128>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB565_WITH_MASK(dsc)) {
 801072c:	e1cb      	b.n	8010ac6 <rgb565_image_blend+0x532>
                }
            }
        }
        else {
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB565_MIX_MASK_OPA(dsc)) {
                for(y = 0; y < h; y++) {
 801072e:	2300      	movs	r3, #0
 8010730:	637b      	str	r3, [r7, #52]	@ 0x34
 8010732:	e03a      	b.n	80107aa <rgb565_image_blend+0x216>
                    for(x = 0; x < w; x++) {
 8010734:	2300      	movs	r3, #0
 8010736:	63bb      	str	r3, [r7, #56]	@ 0x38
 8010738:	e020      	b.n	801077c <rgb565_image_blend+0x1e8>
                        dest_buf_u16[x] = lv_color_16_16_mix(src_buf_u16[x], dest_buf_u16[x], LV_OPA_MIX2(mask_buf[x], opa));
 801073a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801073c:	005b      	lsls	r3, r3, #1
 801073e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8010740:	4413      	add	r3, r2
 8010742:	8818      	ldrh	r0, [r3, #0]
 8010744:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010746:	005b      	lsls	r3, r3, #1
 8010748:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801074a:	4413      	add	r3, r2
 801074c:	8819      	ldrh	r1, [r3, #0]
 801074e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010750:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010752:	4413      	add	r3, r2
 8010754:	781b      	ldrb	r3, [r3, #0]
 8010756:	461a      	mov	r2, r3
 8010758:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801075c:	fb02 f303 	mul.w	r3, r2, r3
 8010760:	121b      	asrs	r3, r3, #8
 8010762:	b2dd      	uxtb	r5, r3
 8010764:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010766:	005b      	lsls	r3, r3, #1
 8010768:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801076a:	18d4      	adds	r4, r2, r3
 801076c:	462a      	mov	r2, r5
 801076e:	f7ff fc69 	bl	8010044 <lv_color_16_16_mix>
 8010772:	4603      	mov	r3, r0
 8010774:	8023      	strh	r3, [r4, #0]
                    for(x = 0; x < w; x++) {
 8010776:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010778:	3301      	adds	r3, #1
 801077a:	63bb      	str	r3, [r7, #56]	@ 0x38
 801077c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801077e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010780:	429a      	cmp	r2, r3
 8010782:	dbda      	blt.n	801073a <rgb565_image_blend+0x1a6>
                    }
                    dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 8010784:	6a3b      	ldr	r3, [r7, #32]
 8010786:	4619      	mov	r1, r3
 8010788:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801078a:	f000 ff99 	bl	80116c0 <drawbuf_next_row>
 801078e:	6478      	str	r0, [r7, #68]	@ 0x44
                    src_buf_u16 = drawbuf_next_row(src_buf_u16, src_stride);
 8010790:	69fb      	ldr	r3, [r7, #28]
 8010792:	4619      	mov	r1, r3
 8010794:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8010796:	f000 ff93 	bl	80116c0 <drawbuf_next_row>
 801079a:	6438      	str	r0, [r7, #64]	@ 0x40
                    mask_buf += mask_stride;
 801079c:	69bb      	ldr	r3, [r7, #24]
 801079e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80107a0:	4413      	add	r3, r2
 80107a2:	63fb      	str	r3, [r7, #60]	@ 0x3c
                for(y = 0; y < h; y++) {
 80107a4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80107a6:	3301      	adds	r3, #1
 80107a8:	637b      	str	r3, [r7, #52]	@ 0x34
 80107aa:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80107ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80107ae:	429a      	cmp	r2, r3
 80107b0:	dbc0      	blt.n	8010734 <rgb565_image_blend+0x1a0>
 80107b2:	e188      	b.n	8010ac6 <rgb565_image_blend+0x532>
                }
            }
        }
    }
    else {
        uint16_t res = 0;
 80107b4:	2300      	movs	r3, #0
 80107b6:	867b      	strh	r3, [r7, #50]	@ 0x32
        for(y = 0; y < h; y++) {
 80107b8:	2300      	movs	r3, #0
 80107ba:	637b      	str	r3, [r7, #52]	@ 0x34
 80107bc:	e17c      	b.n	8010ab8 <rgb565_image_blend+0x524>
            lv_color16_t * dest_buf_c16 = (lv_color16_t *) dest_buf_u16;
 80107be:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80107c0:	617b      	str	r3, [r7, #20]
            lv_color16_t * src_buf_c16 = (lv_color16_t *) src_buf_u16;
 80107c2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80107c4:	613b      	str	r3, [r7, #16]
            for(x = 0; x < w; x++) {
 80107c6:	2300      	movs	r3, #0
 80107c8:	63bb      	str	r3, [r7, #56]	@ 0x38
 80107ca:	e15a      	b.n	8010a82 <rgb565_image_blend+0x4ee>
                switch(dsc->blend_mode) {
 80107cc:	687b      	ldr	r3, [r7, #4]
 80107ce:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 80107d2:	2b03      	cmp	r3, #3
 80107d4:	f000 80af 	beq.w	8010936 <rgb565_image_blend+0x3a2>
 80107d8:	2b03      	cmp	r3, #3
 80107da:	f300 8173 	bgt.w	8010ac4 <rgb565_image_blend+0x530>
 80107de:	2b01      	cmp	r3, #1
 80107e0:	d002      	beq.n	80107e8 <rgb565_image_blend+0x254>
 80107e2:	2b02      	cmp	r3, #2
 80107e4:	d055      	beq.n	8010892 <rgb565_image_blend+0x2fe>
                        res += ((dest_buf_c16[x].green * src_buf_c16[x].green) >> 6) << 5;
                        res += (dest_buf_c16[x].blue * src_buf_c16[x].blue) >> 5;
                        break;
                    default:
                        LV_LOG_WARN("Not supported blend mode: %d", dsc->blend_mode);
                        return;
 80107e6:	e16d      	b.n	8010ac4 <rgb565_image_blend+0x530>
                        if(src_buf_u16[x] == 0x0000) continue;   /*Do not add pure black*/
 80107e8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80107ea:	005b      	lsls	r3, r3, #1
 80107ec:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80107ee:	4413      	add	r3, r2
 80107f0:	881b      	ldrh	r3, [r3, #0]
 80107f2:	2b00      	cmp	r3, #0
 80107f4:	f000 813d 	beq.w	8010a72 <rgb565_image_blend+0x4de>
                        res = (LV_MIN(dest_buf_c16[x].red + src_buf_c16[x].red, 31)) << 11;
 80107f8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80107fa:	005b      	lsls	r3, r3, #1
 80107fc:	697a      	ldr	r2, [r7, #20]
 80107fe:	4413      	add	r3, r2
 8010800:	785b      	ldrb	r3, [r3, #1]
 8010802:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8010806:	b2db      	uxtb	r3, r3
 8010808:	4619      	mov	r1, r3
 801080a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801080c:	005b      	lsls	r3, r3, #1
 801080e:	693a      	ldr	r2, [r7, #16]
 8010810:	4413      	add	r3, r2
 8010812:	785b      	ldrb	r3, [r3, #1]
 8010814:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8010818:	b2db      	uxtb	r3, r3
 801081a:	440b      	add	r3, r1
 801081c:	2b1f      	cmp	r3, #31
 801081e:	bfa8      	it	ge
 8010820:	231f      	movge	r3, #31
 8010822:	b29b      	uxth	r3, r3
 8010824:	02db      	lsls	r3, r3, #11
 8010826:	867b      	strh	r3, [r7, #50]	@ 0x32
                        res += (LV_MIN(dest_buf_c16[x].green + src_buf_c16[x].green, 63)) << 5;
 8010828:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801082a:	005b      	lsls	r3, r3, #1
 801082c:	697a      	ldr	r2, [r7, #20]
 801082e:	4413      	add	r3, r2
 8010830:	881b      	ldrh	r3, [r3, #0]
 8010832:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8010836:	b2db      	uxtb	r3, r3
 8010838:	4619      	mov	r1, r3
 801083a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801083c:	005b      	lsls	r3, r3, #1
 801083e:	693a      	ldr	r2, [r7, #16]
 8010840:	4413      	add	r3, r2
 8010842:	881b      	ldrh	r3, [r3, #0]
 8010844:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8010848:	b2db      	uxtb	r3, r3
 801084a:	440b      	add	r3, r1
 801084c:	2b3f      	cmp	r3, #63	@ 0x3f
 801084e:	bfa8      	it	ge
 8010850:	233f      	movge	r3, #63	@ 0x3f
 8010852:	b29b      	uxth	r3, r3
 8010854:	015b      	lsls	r3, r3, #5
 8010856:	b29a      	uxth	r2, r3
 8010858:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 801085a:	4413      	add	r3, r2
 801085c:	867b      	strh	r3, [r7, #50]	@ 0x32
                        res += LV_MIN(dest_buf_c16[x].blue + src_buf_c16[x].blue, 31);
 801085e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010860:	005b      	lsls	r3, r3, #1
 8010862:	697a      	ldr	r2, [r7, #20]
 8010864:	4413      	add	r3, r2
 8010866:	781b      	ldrb	r3, [r3, #0]
 8010868:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801086c:	b2db      	uxtb	r3, r3
 801086e:	4619      	mov	r1, r3
 8010870:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010872:	005b      	lsls	r3, r3, #1
 8010874:	693a      	ldr	r2, [r7, #16]
 8010876:	4413      	add	r3, r2
 8010878:	781b      	ldrb	r3, [r3, #0]
 801087a:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801087e:	b2db      	uxtb	r3, r3
 8010880:	440b      	add	r3, r1
 8010882:	2b1f      	cmp	r3, #31
 8010884:	bfa8      	it	ge
 8010886:	231f      	movge	r3, #31
 8010888:	b29a      	uxth	r2, r3
 801088a:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 801088c:	4413      	add	r3, r2
 801088e:	867b      	strh	r3, [r7, #50]	@ 0x32
                        break;
 8010890:	e0a5      	b.n	80109de <rgb565_image_blend+0x44a>
                        if(src_buf_u16[x] == 0x0000) continue;   /*Do not subtract pure black*/
 8010892:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010894:	005b      	lsls	r3, r3, #1
 8010896:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8010898:	4413      	add	r3, r2
 801089a:	881b      	ldrh	r3, [r3, #0]
 801089c:	2b00      	cmp	r3, #0
 801089e:	f000 80ea 	beq.w	8010a76 <rgb565_image_blend+0x4e2>
                        res = (LV_MAX(dest_buf_c16[x].red - src_buf_c16[x].red, 0)) << 11;
 80108a2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80108a4:	005b      	lsls	r3, r3, #1
 80108a6:	697a      	ldr	r2, [r7, #20]
 80108a8:	4413      	add	r3, r2
 80108aa:	785b      	ldrb	r3, [r3, #1]
 80108ac:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80108b0:	b2db      	uxtb	r3, r3
 80108b2:	4619      	mov	r1, r3
 80108b4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80108b6:	005b      	lsls	r3, r3, #1
 80108b8:	693a      	ldr	r2, [r7, #16]
 80108ba:	4413      	add	r3, r2
 80108bc:	785b      	ldrb	r3, [r3, #1]
 80108be:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80108c2:	b2db      	uxtb	r3, r3
 80108c4:	1acb      	subs	r3, r1, r3
 80108c6:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80108ca:	b29b      	uxth	r3, r3
 80108cc:	02db      	lsls	r3, r3, #11
 80108ce:	867b      	strh	r3, [r7, #50]	@ 0x32
                        res += (LV_MAX(dest_buf_c16[x].green - src_buf_c16[x].green, 0)) << 5;
 80108d0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80108d2:	005b      	lsls	r3, r3, #1
 80108d4:	697a      	ldr	r2, [r7, #20]
 80108d6:	4413      	add	r3, r2
 80108d8:	881b      	ldrh	r3, [r3, #0]
 80108da:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80108de:	b2db      	uxtb	r3, r3
 80108e0:	4619      	mov	r1, r3
 80108e2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80108e4:	005b      	lsls	r3, r3, #1
 80108e6:	693a      	ldr	r2, [r7, #16]
 80108e8:	4413      	add	r3, r2
 80108ea:	881b      	ldrh	r3, [r3, #0]
 80108ec:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80108f0:	b2db      	uxtb	r3, r3
 80108f2:	1acb      	subs	r3, r1, r3
 80108f4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80108f8:	b29b      	uxth	r3, r3
 80108fa:	015b      	lsls	r3, r3, #5
 80108fc:	b29a      	uxth	r2, r3
 80108fe:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 8010900:	4413      	add	r3, r2
 8010902:	867b      	strh	r3, [r7, #50]	@ 0x32
                        res += LV_MAX(dest_buf_c16[x].blue - src_buf_c16[x].blue, 0);
 8010904:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010906:	005b      	lsls	r3, r3, #1
 8010908:	697a      	ldr	r2, [r7, #20]
 801090a:	4413      	add	r3, r2
 801090c:	781b      	ldrb	r3, [r3, #0]
 801090e:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8010912:	b2db      	uxtb	r3, r3
 8010914:	4619      	mov	r1, r3
 8010916:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010918:	005b      	lsls	r3, r3, #1
 801091a:	693a      	ldr	r2, [r7, #16]
 801091c:	4413      	add	r3, r2
 801091e:	781b      	ldrb	r3, [r3, #0]
 8010920:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8010924:	b2db      	uxtb	r3, r3
 8010926:	1acb      	subs	r3, r1, r3
 8010928:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 801092c:	b29a      	uxth	r2, r3
 801092e:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 8010930:	4413      	add	r3, r2
 8010932:	867b      	strh	r3, [r7, #50]	@ 0x32
                        break;
 8010934:	e053      	b.n	80109de <rgb565_image_blend+0x44a>
                        if(src_buf_u16[x] == 0xffff) continue;   /*Do not multiply with pure white (considered as 1)*/
 8010936:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010938:	005b      	lsls	r3, r3, #1
 801093a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801093c:	4413      	add	r3, r2
 801093e:	881b      	ldrh	r3, [r3, #0]
 8010940:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8010944:	4293      	cmp	r3, r2
 8010946:	f000 8098 	beq.w	8010a7a <rgb565_image_blend+0x4e6>
                        res = ((dest_buf_c16[x].red * src_buf_c16[x].red) >> 5) << 11;
 801094a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801094c:	005b      	lsls	r3, r3, #1
 801094e:	697a      	ldr	r2, [r7, #20]
 8010950:	4413      	add	r3, r2
 8010952:	785b      	ldrb	r3, [r3, #1]
 8010954:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8010958:	b2db      	uxtb	r3, r3
 801095a:	4619      	mov	r1, r3
 801095c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801095e:	005b      	lsls	r3, r3, #1
 8010960:	693a      	ldr	r2, [r7, #16]
 8010962:	4413      	add	r3, r2
 8010964:	785b      	ldrb	r3, [r3, #1]
 8010966:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801096a:	b2db      	uxtb	r3, r3
 801096c:	fb01 f303 	mul.w	r3, r1, r3
 8010970:	115b      	asrs	r3, r3, #5
 8010972:	b29b      	uxth	r3, r3
 8010974:	02db      	lsls	r3, r3, #11
 8010976:	867b      	strh	r3, [r7, #50]	@ 0x32
                        res += ((dest_buf_c16[x].green * src_buf_c16[x].green) >> 6) << 5;
 8010978:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801097a:	005b      	lsls	r3, r3, #1
 801097c:	697a      	ldr	r2, [r7, #20]
 801097e:	4413      	add	r3, r2
 8010980:	881b      	ldrh	r3, [r3, #0]
 8010982:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8010986:	b2db      	uxtb	r3, r3
 8010988:	4619      	mov	r1, r3
 801098a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801098c:	005b      	lsls	r3, r3, #1
 801098e:	693a      	ldr	r2, [r7, #16]
 8010990:	4413      	add	r3, r2
 8010992:	881b      	ldrh	r3, [r3, #0]
 8010994:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8010998:	b2db      	uxtb	r3, r3
 801099a:	fb01 f303 	mul.w	r3, r1, r3
 801099e:	119b      	asrs	r3, r3, #6
 80109a0:	b29b      	uxth	r3, r3
 80109a2:	015b      	lsls	r3, r3, #5
 80109a4:	b29a      	uxth	r2, r3
 80109a6:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 80109a8:	4413      	add	r3, r2
 80109aa:	867b      	strh	r3, [r7, #50]	@ 0x32
                        res += (dest_buf_c16[x].blue * src_buf_c16[x].blue) >> 5;
 80109ac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80109ae:	005b      	lsls	r3, r3, #1
 80109b0:	697a      	ldr	r2, [r7, #20]
 80109b2:	4413      	add	r3, r2
 80109b4:	781b      	ldrb	r3, [r3, #0]
 80109b6:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80109ba:	b2db      	uxtb	r3, r3
 80109bc:	4619      	mov	r1, r3
 80109be:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80109c0:	005b      	lsls	r3, r3, #1
 80109c2:	693a      	ldr	r2, [r7, #16]
 80109c4:	4413      	add	r3, r2
 80109c6:	781b      	ldrb	r3, [r3, #0]
 80109c8:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80109cc:	b2db      	uxtb	r3, r3
 80109ce:	fb01 f303 	mul.w	r3, r1, r3
 80109d2:	115b      	asrs	r3, r3, #5
 80109d4:	b29a      	uxth	r2, r3
 80109d6:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 80109d8:	4413      	add	r3, r2
 80109da:	867b      	strh	r3, [r7, #50]	@ 0x32
                        break;
 80109dc:	bf00      	nop
                }

                if(mask_buf == NULL) {
 80109de:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80109e0:	2b00      	cmp	r3, #0
 80109e2:	d111      	bne.n	8010a08 <rgb565_image_blend+0x474>
                    dest_buf_u16[x] = lv_color_16_16_mix(res, dest_buf_u16[x], opa);
 80109e4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80109e6:	005b      	lsls	r3, r3, #1
 80109e8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80109ea:	4413      	add	r3, r2
 80109ec:	8819      	ldrh	r1, [r3, #0]
 80109ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80109f0:	005b      	lsls	r3, r3, #1
 80109f2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80109f4:	18d4      	adds	r4, r2, r3
 80109f6:	f897 2027 	ldrb.w	r2, [r7, #39]	@ 0x27
 80109fa:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 80109fc:	4618      	mov	r0, r3
 80109fe:	f7ff fb21 	bl	8010044 <lv_color_16_16_mix>
 8010a02:	4603      	mov	r3, r0
 8010a04:	8023      	strh	r3, [r4, #0]
 8010a06:	e039      	b.n	8010a7c <rgb565_image_blend+0x4e8>
                }
                else {
                    if(opa >= LV_OPA_MAX) dest_buf_u16[x] = lv_color_16_16_mix(res, dest_buf_u16[x], mask_buf[x]);
 8010a08:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8010a0c:	2bfc      	cmp	r3, #252	@ 0xfc
 8010a0e:	d914      	bls.n	8010a3a <rgb565_image_blend+0x4a6>
 8010a10:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010a12:	005b      	lsls	r3, r3, #1
 8010a14:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8010a16:	4413      	add	r3, r2
 8010a18:	8819      	ldrh	r1, [r3, #0]
 8010a1a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010a1c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010a1e:	4413      	add	r3, r2
 8010a20:	7818      	ldrb	r0, [r3, #0]
 8010a22:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010a24:	005b      	lsls	r3, r3, #1
 8010a26:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8010a28:	18d4      	adds	r4, r2, r3
 8010a2a:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 8010a2c:	4602      	mov	r2, r0
 8010a2e:	4618      	mov	r0, r3
 8010a30:	f7ff fb08 	bl	8010044 <lv_color_16_16_mix>
 8010a34:	4603      	mov	r3, r0
 8010a36:	8023      	strh	r3, [r4, #0]
 8010a38:	e020      	b.n	8010a7c <rgb565_image_blend+0x4e8>
                    else dest_buf_u16[x] = lv_color_16_16_mix(res, dest_buf_u16[x], LV_OPA_MIX2(mask_buf[x], opa));
 8010a3a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010a3c:	005b      	lsls	r3, r3, #1
 8010a3e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8010a40:	4413      	add	r3, r2
 8010a42:	8819      	ldrh	r1, [r3, #0]
 8010a44:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010a46:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010a48:	4413      	add	r3, r2
 8010a4a:	781b      	ldrb	r3, [r3, #0]
 8010a4c:	461a      	mov	r2, r3
 8010a4e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8010a52:	fb02 f303 	mul.w	r3, r2, r3
 8010a56:	121b      	asrs	r3, r3, #8
 8010a58:	b2d8      	uxtb	r0, r3
 8010a5a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010a5c:	005b      	lsls	r3, r3, #1
 8010a5e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8010a60:	18d4      	adds	r4, r2, r3
 8010a62:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 8010a64:	4602      	mov	r2, r0
 8010a66:	4618      	mov	r0, r3
 8010a68:	f7ff faec 	bl	8010044 <lv_color_16_16_mix>
 8010a6c:	4603      	mov	r3, r0
 8010a6e:	8023      	strh	r3, [r4, #0]
 8010a70:	e004      	b.n	8010a7c <rgb565_image_blend+0x4e8>
                        if(src_buf_u16[x] == 0x0000) continue;   /*Do not add pure black*/
 8010a72:	bf00      	nop
 8010a74:	e002      	b.n	8010a7c <rgb565_image_blend+0x4e8>
                        if(src_buf_u16[x] == 0x0000) continue;   /*Do not subtract pure black*/
 8010a76:	bf00      	nop
 8010a78:	e000      	b.n	8010a7c <rgb565_image_blend+0x4e8>
                        if(src_buf_u16[x] == 0xffff) continue;   /*Do not multiply with pure white (considered as 1)*/
 8010a7a:	bf00      	nop
            for(x = 0; x < w; x++) {
 8010a7c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8010a7e:	3301      	adds	r3, #1
 8010a80:	63bb      	str	r3, [r7, #56]	@ 0x38
 8010a82:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010a84:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010a86:	429a      	cmp	r2, r3
 8010a88:	f6ff aea0 	blt.w	80107cc <rgb565_image_blend+0x238>
                }
            }

            dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 8010a8c:	6a3b      	ldr	r3, [r7, #32]
 8010a8e:	4619      	mov	r1, r3
 8010a90:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 8010a92:	f000 fe15 	bl	80116c0 <drawbuf_next_row>
 8010a96:	6478      	str	r0, [r7, #68]	@ 0x44
            src_buf_u16 = drawbuf_next_row(src_buf_u16, src_stride);
 8010a98:	69fb      	ldr	r3, [r7, #28]
 8010a9a:	4619      	mov	r1, r3
 8010a9c:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8010a9e:	f000 fe0f 	bl	80116c0 <drawbuf_next_row>
 8010aa2:	6438      	str	r0, [r7, #64]	@ 0x40
            if(mask_buf) mask_buf += mask_stride;
 8010aa4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010aa6:	2b00      	cmp	r3, #0
 8010aa8:	d003      	beq.n	8010ab2 <rgb565_image_blend+0x51e>
 8010aaa:	69bb      	ldr	r3, [r7, #24]
 8010aac:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010aae:	4413      	add	r3, r2
 8010ab0:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for(y = 0; y < h; y++) {
 8010ab2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010ab4:	3301      	adds	r3, #1
 8010ab6:	637b      	str	r3, [r7, #52]	@ 0x34
 8010ab8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8010aba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010abc:	429a      	cmp	r2, r3
 8010abe:	f6ff ae7e 	blt.w	80107be <rgb565_image_blend+0x22a>
 8010ac2:	e000      	b.n	8010ac6 <rgb565_image_blend+0x532>
                        return;
 8010ac4:	bf00      	nop
        }
    }
}
 8010ac6:	3748      	adds	r7, #72	@ 0x48
 8010ac8:	46bd      	mov	sp, r7
 8010aca:	bdb0      	pop	{r4, r5, r7, pc}

08010acc <rgb888_image_blend>:

static void LV_ATTRIBUTE_FAST_MEM rgb888_image_blend(_lv_draw_sw_blend_image_dsc_t * dsc, const uint8_t src_px_size)
{
 8010acc:	b5b0      	push	{r4, r5, r7, lr}
 8010ace:	b090      	sub	sp, #64	@ 0x40
 8010ad0:	af00      	add	r7, sp, #0
 8010ad2:	6078      	str	r0, [r7, #4]
 8010ad4:	460b      	mov	r3, r1
 8010ad6:	70fb      	strb	r3, [r7, #3]
    int32_t w = dsc->dest_w;
 8010ad8:	687b      	ldr	r3, [r7, #4]
 8010ada:	685b      	ldr	r3, [r3, #4]
 8010adc:	623b      	str	r3, [r7, #32]
    int32_t h = dsc->dest_h;
 8010ade:	687b      	ldr	r3, [r7, #4]
 8010ae0:	689b      	ldr	r3, [r3, #8]
 8010ae2:	61fb      	str	r3, [r7, #28]
    lv_opa_t opa = dsc->opa;
 8010ae4:	687b      	ldr	r3, [r7, #4]
 8010ae6:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 8010aea:	76fb      	strb	r3, [r7, #27]
    uint16_t * dest_buf_u16 = dsc->dest_buf;
 8010aec:	687b      	ldr	r3, [r7, #4]
 8010aee:	681b      	ldr	r3, [r3, #0]
 8010af0:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int32_t dest_stride = dsc->dest_stride;
 8010af2:	687b      	ldr	r3, [r7, #4]
 8010af4:	68db      	ldr	r3, [r3, #12]
 8010af6:	617b      	str	r3, [r7, #20]
    const uint8_t * src_buf_u8 = dsc->src_buf;
 8010af8:	687b      	ldr	r3, [r7, #4]
 8010afa:	699b      	ldr	r3, [r3, #24]
 8010afc:	63bb      	str	r3, [r7, #56]	@ 0x38
    int32_t src_stride = dsc->src_stride;
 8010afe:	687b      	ldr	r3, [r7, #4]
 8010b00:	69db      	ldr	r3, [r3, #28]
 8010b02:	613b      	str	r3, [r7, #16]
    const lv_opa_t * mask_buf = dsc->mask_buf;
 8010b04:	687b      	ldr	r3, [r7, #4]
 8010b06:	691b      	ldr	r3, [r3, #16]
 8010b08:	637b      	str	r3, [r7, #52]	@ 0x34
    int32_t mask_stride = dsc->mask_stride;
 8010b0a:	687b      	ldr	r3, [r7, #4]
 8010b0c:	695b      	ldr	r3, [r3, #20]
 8010b0e:	60fb      	str	r3, [r7, #12]

    int32_t dest_x;
    int32_t src_x;
    int32_t y;

    if(dsc->blend_mode == LV_BLEND_MODE_NORMAL) {
 8010b10:	687b      	ldr	r3, [r7, #4]
 8010b12:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 8010b16:	2b00      	cmp	r3, #0
 8010b18:	f040 811d 	bne.w	8010d56 <rgb888_image_blend+0x28a>
        if(mask_buf == NULL && opa >= LV_OPA_MAX) {
 8010b1c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010b1e:	2b00      	cmp	r3, #0
 8010b20:	d14e      	bne.n	8010bc0 <rgb888_image_blend+0xf4>
 8010b22:	7efb      	ldrb	r3, [r7, #27]
 8010b24:	2bfc      	cmp	r3, #252	@ 0xfc
 8010b26:	d94b      	bls.n	8010bc0 <rgb888_image_blend+0xf4>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_RGB565(dsc, src_px_size)) {
                for(y = 0; y < h; y++) {
 8010b28:	2300      	movs	r3, #0
 8010b2a:	62bb      	str	r3, [r7, #40]	@ 0x28
 8010b2c:	e043      	b.n	8010bb6 <rgb888_image_blend+0xea>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 8010b2e:	2300      	movs	r3, #0
 8010b30:	633b      	str	r3, [r7, #48]	@ 0x30
 8010b32:	2300      	movs	r3, #0
 8010b34:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010b36:	e02d      	b.n	8010b94 <rgb888_image_blend+0xc8>
                        dest_buf_u16[dest_x]  = ((src_buf_u8[src_x + 2] & 0xF8) << 8) +
 8010b38:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010b3a:	3302      	adds	r3, #2
 8010b3c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010b3e:	4413      	add	r3, r2
 8010b40:	781b      	ldrb	r3, [r3, #0]
 8010b42:	021b      	lsls	r3, r3, #8
 8010b44:	b21b      	sxth	r3, r3
 8010b46:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
 8010b4a:	f023 0307 	bic.w	r3, r3, #7
 8010b4e:	b21a      	sxth	r2, r3
                                                ((src_buf_u8[src_x + 1] & 0xFC) << 3) +
 8010b50:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010b52:	3301      	adds	r3, #1
 8010b54:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8010b56:	440b      	add	r3, r1
 8010b58:	781b      	ldrb	r3, [r3, #0]
 8010b5a:	00db      	lsls	r3, r3, #3
 8010b5c:	b21b      	sxth	r3, r3
 8010b5e:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
 8010b62:	b21b      	sxth	r3, r3
                        dest_buf_u16[dest_x]  = ((src_buf_u8[src_x + 2] & 0xF8) << 8) +
 8010b64:	4313      	orrs	r3, r2
 8010b66:	b21b      	sxth	r3, r3
 8010b68:	b29a      	uxth	r2, r3
                                                ((src_buf_u8[src_x + 0] & 0xF8) >> 3);
 8010b6a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010b6c:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8010b6e:	440b      	add	r3, r1
 8010b70:	781b      	ldrb	r3, [r3, #0]
 8010b72:	08db      	lsrs	r3, r3, #3
 8010b74:	b2db      	uxtb	r3, r3
 8010b76:	4618      	mov	r0, r3
                        dest_buf_u16[dest_x]  = ((src_buf_u8[src_x + 2] & 0xF8) << 8) +
 8010b78:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010b7a:	005b      	lsls	r3, r3, #1
 8010b7c:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8010b7e:	440b      	add	r3, r1
                                                ((src_buf_u8[src_x + 1] & 0xFC) << 3) +
 8010b80:	4402      	add	r2, r0
 8010b82:	b292      	uxth	r2, r2
                        dest_buf_u16[dest_x]  = ((src_buf_u8[src_x + 2] & 0xF8) << 8) +
 8010b84:	801a      	strh	r2, [r3, #0]
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 8010b86:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010b88:	3301      	adds	r3, #1
 8010b8a:	633b      	str	r3, [r7, #48]	@ 0x30
 8010b8c:	78fb      	ldrb	r3, [r7, #3]
 8010b8e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8010b90:	4413      	add	r3, r2
 8010b92:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010b94:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8010b96:	6a3b      	ldr	r3, [r7, #32]
 8010b98:	429a      	cmp	r2, r3
 8010b9a:	dbcd      	blt.n	8010b38 <rgb888_image_blend+0x6c>
                    }
                    dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 8010b9c:	697b      	ldr	r3, [r7, #20]
 8010b9e:	4619      	mov	r1, r3
 8010ba0:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8010ba2:	f000 fd8d 	bl	80116c0 <drawbuf_next_row>
 8010ba6:	63f8      	str	r0, [r7, #60]	@ 0x3c
                    src_buf_u8 += src_stride;
 8010ba8:	693b      	ldr	r3, [r7, #16]
 8010baa:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010bac:	4413      	add	r3, r2
 8010bae:	63bb      	str	r3, [r7, #56]	@ 0x38
                for(y = 0; y < h; y++) {
 8010bb0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010bb2:	3301      	adds	r3, #1
 8010bb4:	62bb      	str	r3, [r7, #40]	@ 0x28
 8010bb6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8010bb8:	69fb      	ldr	r3, [r7, #28]
 8010bba:	429a      	cmp	r2, r3
 8010bbc:	dbb7      	blt.n	8010b2e <rgb888_image_blend+0x62>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_RGB565(dsc, src_px_size)) {
 8010bbe:	e03b      	b.n	8010c38 <rgb888_image_blend+0x16c>
                }
            }
        }
        else if(mask_buf == NULL && opa < LV_OPA_MAX) {
 8010bc0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010bc2:	2b00      	cmp	r3, #0
 8010bc4:	d138      	bne.n	8010c38 <rgb888_image_blend+0x16c>
 8010bc6:	7efb      	ldrb	r3, [r7, #27]
 8010bc8:	2bfc      	cmp	r3, #252	@ 0xfc
 8010bca:	d835      	bhi.n	8010c38 <rgb888_image_blend+0x16c>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_RGB565_WITH_OPA(dsc, src_px_size)) {
                for(y = 0; y < h; y++) {
 8010bcc:	2300      	movs	r3, #0
 8010bce:	62bb      	str	r3, [r7, #40]	@ 0x28
 8010bd0:	e02e      	b.n	8010c30 <rgb888_image_blend+0x164>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 8010bd2:	2300      	movs	r3, #0
 8010bd4:	633b      	str	r3, [r7, #48]	@ 0x30
 8010bd6:	2300      	movs	r3, #0
 8010bd8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010bda:	e018      	b.n	8010c0e <rgb888_image_blend+0x142>
                        dest_buf_u16[dest_x] = lv_color_24_16_mix(&src_buf_u8[src_x], dest_buf_u16[dest_x], opa);
 8010bdc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010bde:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010be0:	18d0      	adds	r0, r2, r3
 8010be2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010be4:	005b      	lsls	r3, r3, #1
 8010be6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010be8:	4413      	add	r3, r2
 8010bea:	8819      	ldrh	r1, [r3, #0]
 8010bec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010bee:	005b      	lsls	r3, r3, #1
 8010bf0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010bf2:	18d4      	adds	r4, r2, r3
 8010bf4:	7efb      	ldrb	r3, [r7, #27]
 8010bf6:	461a      	mov	r2, r3
 8010bf8:	f000 fce7 	bl	80115ca <lv_color_24_16_mix>
 8010bfc:	4603      	mov	r3, r0
 8010bfe:	8023      	strh	r3, [r4, #0]
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 8010c00:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010c02:	3301      	adds	r3, #1
 8010c04:	633b      	str	r3, [r7, #48]	@ 0x30
 8010c06:	78fb      	ldrb	r3, [r7, #3]
 8010c08:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8010c0a:	4413      	add	r3, r2
 8010c0c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010c0e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8010c10:	6a3b      	ldr	r3, [r7, #32]
 8010c12:	429a      	cmp	r2, r3
 8010c14:	dbe2      	blt.n	8010bdc <rgb888_image_blend+0x110>
                    }
                    dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 8010c16:	697b      	ldr	r3, [r7, #20]
 8010c18:	4619      	mov	r1, r3
 8010c1a:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8010c1c:	f000 fd50 	bl	80116c0 <drawbuf_next_row>
 8010c20:	63f8      	str	r0, [r7, #60]	@ 0x3c
                    src_buf_u8 += src_stride;
 8010c22:	693b      	ldr	r3, [r7, #16]
 8010c24:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010c26:	4413      	add	r3, r2
 8010c28:	63bb      	str	r3, [r7, #56]	@ 0x38
                for(y = 0; y < h; y++) {
 8010c2a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010c2c:	3301      	adds	r3, #1
 8010c2e:	62bb      	str	r3, [r7, #40]	@ 0x28
 8010c30:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8010c32:	69fb      	ldr	r3, [r7, #28]
 8010c34:	429a      	cmp	r2, r3
 8010c36:	dbcc      	blt.n	8010bd2 <rgb888_image_blend+0x106>
                }
            }
        }
        if(mask_buf && opa >= LV_OPA_MAX) {
 8010c38:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010c3a:	2b00      	cmp	r3, #0
 8010c3c:	d03f      	beq.n	8010cbe <rgb888_image_blend+0x1f2>
 8010c3e:	7efb      	ldrb	r3, [r7, #27]
 8010c40:	2bfc      	cmp	r3, #252	@ 0xfc
 8010c42:	d93c      	bls.n	8010cbe <rgb888_image_blend+0x1f2>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_RGB565_WITH_MASK(dsc, src_px_size)) {
                for(y = 0; y < h; y++) {
 8010c44:	2300      	movs	r3, #0
 8010c46:	62bb      	str	r3, [r7, #40]	@ 0x28
 8010c48:	e035      	b.n	8010cb6 <rgb888_image_blend+0x1ea>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 8010c4a:	2300      	movs	r3, #0
 8010c4c:	633b      	str	r3, [r7, #48]	@ 0x30
 8010c4e:	2300      	movs	r3, #0
 8010c50:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010c52:	e01b      	b.n	8010c8c <rgb888_image_blend+0x1c0>
                        dest_buf_u16[dest_x] = lv_color_24_16_mix(&src_buf_u8[src_x], dest_buf_u16[dest_x], mask_buf[dest_x]);
 8010c54:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010c56:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010c58:	18d0      	adds	r0, r2, r3
 8010c5a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010c5c:	005b      	lsls	r3, r3, #1
 8010c5e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010c60:	4413      	add	r3, r2
 8010c62:	8819      	ldrh	r1, [r3, #0]
 8010c64:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010c66:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8010c68:	4413      	add	r3, r2
 8010c6a:	781d      	ldrb	r5, [r3, #0]
 8010c6c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010c6e:	005b      	lsls	r3, r3, #1
 8010c70:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010c72:	18d4      	adds	r4, r2, r3
 8010c74:	462a      	mov	r2, r5
 8010c76:	f000 fca8 	bl	80115ca <lv_color_24_16_mix>
 8010c7a:	4603      	mov	r3, r0
 8010c7c:	8023      	strh	r3, [r4, #0]
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 8010c7e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010c80:	3301      	adds	r3, #1
 8010c82:	633b      	str	r3, [r7, #48]	@ 0x30
 8010c84:	78fb      	ldrb	r3, [r7, #3]
 8010c86:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8010c88:	4413      	add	r3, r2
 8010c8a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010c8c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8010c8e:	6a3b      	ldr	r3, [r7, #32]
 8010c90:	429a      	cmp	r2, r3
 8010c92:	dbdf      	blt.n	8010c54 <rgb888_image_blend+0x188>
                    }
                    dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 8010c94:	697b      	ldr	r3, [r7, #20]
 8010c96:	4619      	mov	r1, r3
 8010c98:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8010c9a:	f000 fd11 	bl	80116c0 <drawbuf_next_row>
 8010c9e:	63f8      	str	r0, [r7, #60]	@ 0x3c
                    src_buf_u8 += src_stride;
 8010ca0:	693b      	ldr	r3, [r7, #16]
 8010ca2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010ca4:	4413      	add	r3, r2
 8010ca6:	63bb      	str	r3, [r7, #56]	@ 0x38
                    mask_buf += mask_stride;
 8010ca8:	68fb      	ldr	r3, [r7, #12]
 8010caa:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8010cac:	4413      	add	r3, r2
 8010cae:	637b      	str	r3, [r7, #52]	@ 0x34
                for(y = 0; y < h; y++) {
 8010cb0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010cb2:	3301      	adds	r3, #1
 8010cb4:	62bb      	str	r3, [r7, #40]	@ 0x28
 8010cb6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8010cb8:	69fb      	ldr	r3, [r7, #28]
 8010cba:	429a      	cmp	r2, r3
 8010cbc:	dbc5      	blt.n	8010c4a <rgb888_image_blend+0x17e>
                }
            }
        }
        if(mask_buf && opa < LV_OPA_MAX) {
 8010cbe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010cc0:	2b00      	cmp	r3, #0
 8010cc2:	f000 81a4 	beq.w	801100e <rgb888_image_blend+0x542>
 8010cc6:	7efb      	ldrb	r3, [r7, #27]
 8010cc8:	2bfc      	cmp	r3, #252	@ 0xfc
 8010cca:	f200 81a0 	bhi.w	801100e <rgb888_image_blend+0x542>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_RGB565_MIX_MASK_OPA(dsc, src_px_size)) {
                for(y = 0; y < h; y++) {
 8010cce:	2300      	movs	r3, #0
 8010cd0:	62bb      	str	r3, [r7, #40]	@ 0x28
 8010cd2:	e03b      	b.n	8010d4c <rgb888_image_blend+0x280>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 8010cd4:	2300      	movs	r3, #0
 8010cd6:	633b      	str	r3, [r7, #48]	@ 0x30
 8010cd8:	2300      	movs	r3, #0
 8010cda:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010cdc:	e021      	b.n	8010d22 <rgb888_image_blend+0x256>
                        dest_buf_u16[dest_x] = lv_color_24_16_mix(&src_buf_u8[src_x], dest_buf_u16[dest_x], LV_OPA_MIX2(mask_buf[dest_x], opa));
 8010cde:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010ce0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010ce2:	18d0      	adds	r0, r2, r3
 8010ce4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010ce6:	005b      	lsls	r3, r3, #1
 8010ce8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010cea:	4413      	add	r3, r2
 8010cec:	8819      	ldrh	r1, [r3, #0]
 8010cee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010cf0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8010cf2:	4413      	add	r3, r2
 8010cf4:	781b      	ldrb	r3, [r3, #0]
 8010cf6:	461a      	mov	r2, r3
 8010cf8:	7efb      	ldrb	r3, [r7, #27]
 8010cfa:	fb02 f303 	mul.w	r3, r2, r3
 8010cfe:	121b      	asrs	r3, r3, #8
 8010d00:	b2dd      	uxtb	r5, r3
 8010d02:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010d04:	005b      	lsls	r3, r3, #1
 8010d06:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010d08:	18d4      	adds	r4, r2, r3
 8010d0a:	462a      	mov	r2, r5
 8010d0c:	f000 fc5d 	bl	80115ca <lv_color_24_16_mix>
 8010d10:	4603      	mov	r3, r0
 8010d12:	8023      	strh	r3, [r4, #0]
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 8010d14:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010d16:	3301      	adds	r3, #1
 8010d18:	633b      	str	r3, [r7, #48]	@ 0x30
 8010d1a:	78fb      	ldrb	r3, [r7, #3]
 8010d1c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8010d1e:	4413      	add	r3, r2
 8010d20:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010d22:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8010d24:	6a3b      	ldr	r3, [r7, #32]
 8010d26:	429a      	cmp	r2, r3
 8010d28:	dbd9      	blt.n	8010cde <rgb888_image_blend+0x212>
                    }
                    dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 8010d2a:	697b      	ldr	r3, [r7, #20]
 8010d2c:	4619      	mov	r1, r3
 8010d2e:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8010d30:	f000 fcc6 	bl	80116c0 <drawbuf_next_row>
 8010d34:	63f8      	str	r0, [r7, #60]	@ 0x3c
                    src_buf_u8 += src_stride;
 8010d36:	693b      	ldr	r3, [r7, #16]
 8010d38:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010d3a:	4413      	add	r3, r2
 8010d3c:	63bb      	str	r3, [r7, #56]	@ 0x38
                    mask_buf += mask_stride;
 8010d3e:	68fb      	ldr	r3, [r7, #12]
 8010d40:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8010d42:	4413      	add	r3, r2
 8010d44:	637b      	str	r3, [r7, #52]	@ 0x34
                for(y = 0; y < h; y++) {
 8010d46:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010d48:	3301      	adds	r3, #1
 8010d4a:	62bb      	str	r3, [r7, #40]	@ 0x28
 8010d4c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8010d4e:	69fb      	ldr	r3, [r7, #28]
 8010d50:	429a      	cmp	r2, r3
 8010d52:	dbbf      	blt.n	8010cd4 <rgb888_image_blend+0x208>
 8010d54:	e15b      	b.n	801100e <rgb888_image_blend+0x542>
                }
            }
        }
    }
    else {
        uint16_t res = 0;
 8010d56:	2300      	movs	r3, #0
 8010d58:	84fb      	strh	r3, [r7, #38]	@ 0x26
        for(y = 0; y < h; y++) {
 8010d5a:	2300      	movs	r3, #0
 8010d5c:	62bb      	str	r3, [r7, #40]	@ 0x28
 8010d5e:	e14f      	b.n	8011000 <rgb888_image_blend+0x534>
            lv_color16_t * dest_buf_c16 = (lv_color16_t *) dest_buf_u16;
 8010d60:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010d62:	60bb      	str	r3, [r7, #8]
            for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 8010d64:	2300      	movs	r3, #0
 8010d66:	633b      	str	r3, [r7, #48]	@ 0x30
 8010d68:	2300      	movs	r3, #0
 8010d6a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010d6c:	e12f      	b.n	8010fce <rgb888_image_blend+0x502>
                switch(dsc->blend_mode) {
 8010d6e:	687b      	ldr	r3, [r7, #4]
 8010d70:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 8010d74:	2b03      	cmp	r3, #3
 8010d76:	f000 8097 	beq.w	8010ea8 <rgb888_image_blend+0x3dc>
 8010d7a:	2b03      	cmp	r3, #3
 8010d7c:	f300 8146 	bgt.w	801100c <rgb888_image_blend+0x540>
 8010d80:	2b01      	cmp	r3, #1
 8010d82:	d002      	beq.n	8010d8a <rgb888_image_blend+0x2be>
 8010d84:	2b02      	cmp	r3, #2
 8010d86:	d049      	beq.n	8010e1c <rgb888_image_blend+0x350>
                        res += ((dest_buf_c16[dest_x].green * (src_buf_u8[src_x + 1] >> 2)) >> 6) << 5;
                        res += (dest_buf_c16[dest_x].blue * (src_buf_u8[src_x + 0] >> 3)) >> 5;
                        break;
                    default:
                        LV_LOG_WARN("Not supported blend mode: %d", dsc->blend_mode);
                        return;
 8010d88:	e140      	b.n	801100c <rgb888_image_blend+0x540>
                        res = (LV_MIN(dest_buf_c16[dest_x].red + (src_buf_u8[src_x + 2] >> 3), 31)) << 11;
 8010d8a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010d8c:	005b      	lsls	r3, r3, #1
 8010d8e:	68ba      	ldr	r2, [r7, #8]
 8010d90:	4413      	add	r3, r2
 8010d92:	785b      	ldrb	r3, [r3, #1]
 8010d94:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8010d98:	b2db      	uxtb	r3, r3
 8010d9a:	4619      	mov	r1, r3
 8010d9c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010d9e:	3302      	adds	r3, #2
 8010da0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010da2:	4413      	add	r3, r2
 8010da4:	781b      	ldrb	r3, [r3, #0]
 8010da6:	08db      	lsrs	r3, r3, #3
 8010da8:	b2db      	uxtb	r3, r3
 8010daa:	440b      	add	r3, r1
 8010dac:	2b1f      	cmp	r3, #31
 8010dae:	bfa8      	it	ge
 8010db0:	231f      	movge	r3, #31
 8010db2:	b29b      	uxth	r3, r3
 8010db4:	02db      	lsls	r3, r3, #11
 8010db6:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        res += (LV_MIN(dest_buf_c16[dest_x].green + (src_buf_u8[src_x + 1] >> 2), 63)) << 5;
 8010db8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010dba:	005b      	lsls	r3, r3, #1
 8010dbc:	68ba      	ldr	r2, [r7, #8]
 8010dbe:	4413      	add	r3, r2
 8010dc0:	881b      	ldrh	r3, [r3, #0]
 8010dc2:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8010dc6:	b2db      	uxtb	r3, r3
 8010dc8:	4619      	mov	r1, r3
 8010dca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010dcc:	3301      	adds	r3, #1
 8010dce:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010dd0:	4413      	add	r3, r2
 8010dd2:	781b      	ldrb	r3, [r3, #0]
 8010dd4:	089b      	lsrs	r3, r3, #2
 8010dd6:	b2db      	uxtb	r3, r3
 8010dd8:	440b      	add	r3, r1
 8010dda:	2b3f      	cmp	r3, #63	@ 0x3f
 8010ddc:	bfa8      	it	ge
 8010dde:	233f      	movge	r3, #63	@ 0x3f
 8010de0:	b29b      	uxth	r3, r3
 8010de2:	015b      	lsls	r3, r3, #5
 8010de4:	b29a      	uxth	r2, r3
 8010de6:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8010de8:	4413      	add	r3, r2
 8010dea:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        res += LV_MIN(dest_buf_c16[dest_x].blue + (src_buf_u8[src_x + 0] >> 3), 31);
 8010dec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010dee:	005b      	lsls	r3, r3, #1
 8010df0:	68ba      	ldr	r2, [r7, #8]
 8010df2:	4413      	add	r3, r2
 8010df4:	781b      	ldrb	r3, [r3, #0]
 8010df6:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8010dfa:	b2db      	uxtb	r3, r3
 8010dfc:	4619      	mov	r1, r3
 8010dfe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010e00:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010e02:	4413      	add	r3, r2
 8010e04:	781b      	ldrb	r3, [r3, #0]
 8010e06:	08db      	lsrs	r3, r3, #3
 8010e08:	b2db      	uxtb	r3, r3
 8010e0a:	440b      	add	r3, r1
 8010e0c:	2b1f      	cmp	r3, #31
 8010e0e:	bfa8      	it	ge
 8010e10:	231f      	movge	r3, #31
 8010e12:	b29a      	uxth	r2, r3
 8010e14:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8010e16:	4413      	add	r3, r2
 8010e18:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        break;
 8010e1a:	e08b      	b.n	8010f34 <rgb888_image_blend+0x468>
                        res = (LV_MAX(dest_buf_c16[dest_x].red - (src_buf_u8[src_x + 2] >> 3), 0)) << 11;
 8010e1c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010e1e:	005b      	lsls	r3, r3, #1
 8010e20:	68ba      	ldr	r2, [r7, #8]
 8010e22:	4413      	add	r3, r2
 8010e24:	785b      	ldrb	r3, [r3, #1]
 8010e26:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8010e2a:	b2db      	uxtb	r3, r3
 8010e2c:	4619      	mov	r1, r3
 8010e2e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010e30:	3302      	adds	r3, #2
 8010e32:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010e34:	4413      	add	r3, r2
 8010e36:	781b      	ldrb	r3, [r3, #0]
 8010e38:	08db      	lsrs	r3, r3, #3
 8010e3a:	b2db      	uxtb	r3, r3
 8010e3c:	1acb      	subs	r3, r1, r3
 8010e3e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8010e42:	b29b      	uxth	r3, r3
 8010e44:	02db      	lsls	r3, r3, #11
 8010e46:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        res += (LV_MAX(dest_buf_c16[dest_x].green - (src_buf_u8[src_x + 1] >> 2), 0)) << 5;
 8010e48:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010e4a:	005b      	lsls	r3, r3, #1
 8010e4c:	68ba      	ldr	r2, [r7, #8]
 8010e4e:	4413      	add	r3, r2
 8010e50:	881b      	ldrh	r3, [r3, #0]
 8010e52:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8010e56:	b2db      	uxtb	r3, r3
 8010e58:	4619      	mov	r1, r3
 8010e5a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010e5c:	3301      	adds	r3, #1
 8010e5e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010e60:	4413      	add	r3, r2
 8010e62:	781b      	ldrb	r3, [r3, #0]
 8010e64:	089b      	lsrs	r3, r3, #2
 8010e66:	b2db      	uxtb	r3, r3
 8010e68:	1acb      	subs	r3, r1, r3
 8010e6a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8010e6e:	b29b      	uxth	r3, r3
 8010e70:	015b      	lsls	r3, r3, #5
 8010e72:	b29a      	uxth	r2, r3
 8010e74:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8010e76:	4413      	add	r3, r2
 8010e78:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        res += LV_MAX(dest_buf_c16[dest_x].blue - (src_buf_u8[src_x + 0] >> 3), 0);
 8010e7a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010e7c:	005b      	lsls	r3, r3, #1
 8010e7e:	68ba      	ldr	r2, [r7, #8]
 8010e80:	4413      	add	r3, r2
 8010e82:	781b      	ldrb	r3, [r3, #0]
 8010e84:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8010e88:	b2db      	uxtb	r3, r3
 8010e8a:	4619      	mov	r1, r3
 8010e8c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010e8e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010e90:	4413      	add	r3, r2
 8010e92:	781b      	ldrb	r3, [r3, #0]
 8010e94:	08db      	lsrs	r3, r3, #3
 8010e96:	b2db      	uxtb	r3, r3
 8010e98:	1acb      	subs	r3, r1, r3
 8010e9a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8010e9e:	b29a      	uxth	r2, r3
 8010ea0:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8010ea2:	4413      	add	r3, r2
 8010ea4:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        break;
 8010ea6:	e045      	b.n	8010f34 <rgb888_image_blend+0x468>
                        res = ((dest_buf_c16[dest_x].red * (src_buf_u8[src_x + 2] >> 3)) >> 5) << 11;
 8010ea8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010eaa:	005b      	lsls	r3, r3, #1
 8010eac:	68ba      	ldr	r2, [r7, #8]
 8010eae:	4413      	add	r3, r2
 8010eb0:	785b      	ldrb	r3, [r3, #1]
 8010eb2:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8010eb6:	b2db      	uxtb	r3, r3
 8010eb8:	4619      	mov	r1, r3
 8010eba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010ebc:	3302      	adds	r3, #2
 8010ebe:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010ec0:	4413      	add	r3, r2
 8010ec2:	781b      	ldrb	r3, [r3, #0]
 8010ec4:	08db      	lsrs	r3, r3, #3
 8010ec6:	b2db      	uxtb	r3, r3
 8010ec8:	fb01 f303 	mul.w	r3, r1, r3
 8010ecc:	115b      	asrs	r3, r3, #5
 8010ece:	b29b      	uxth	r3, r3
 8010ed0:	02db      	lsls	r3, r3, #11
 8010ed2:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        res += ((dest_buf_c16[dest_x].green * (src_buf_u8[src_x + 1] >> 2)) >> 6) << 5;
 8010ed4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010ed6:	005b      	lsls	r3, r3, #1
 8010ed8:	68ba      	ldr	r2, [r7, #8]
 8010eda:	4413      	add	r3, r2
 8010edc:	881b      	ldrh	r3, [r3, #0]
 8010ede:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8010ee2:	b2db      	uxtb	r3, r3
 8010ee4:	4619      	mov	r1, r3
 8010ee6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010ee8:	3301      	adds	r3, #1
 8010eea:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010eec:	4413      	add	r3, r2
 8010eee:	781b      	ldrb	r3, [r3, #0]
 8010ef0:	089b      	lsrs	r3, r3, #2
 8010ef2:	b2db      	uxtb	r3, r3
 8010ef4:	fb01 f303 	mul.w	r3, r1, r3
 8010ef8:	119b      	asrs	r3, r3, #6
 8010efa:	b29b      	uxth	r3, r3
 8010efc:	015b      	lsls	r3, r3, #5
 8010efe:	b29a      	uxth	r2, r3
 8010f00:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8010f02:	4413      	add	r3, r2
 8010f04:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        res += (dest_buf_c16[dest_x].blue * (src_buf_u8[src_x + 0] >> 3)) >> 5;
 8010f06:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f08:	005b      	lsls	r3, r3, #1
 8010f0a:	68ba      	ldr	r2, [r7, #8]
 8010f0c:	4413      	add	r3, r2
 8010f0e:	781b      	ldrb	r3, [r3, #0]
 8010f10:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8010f14:	b2db      	uxtb	r3, r3
 8010f16:	4619      	mov	r1, r3
 8010f18:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010f1a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010f1c:	4413      	add	r3, r2
 8010f1e:	781b      	ldrb	r3, [r3, #0]
 8010f20:	08db      	lsrs	r3, r3, #3
 8010f22:	b2db      	uxtb	r3, r3
 8010f24:	fb01 f303 	mul.w	r3, r1, r3
 8010f28:	115b      	asrs	r3, r3, #5
 8010f2a:	b29a      	uxth	r2, r3
 8010f2c:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8010f2e:	4413      	add	r3, r2
 8010f30:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        break;
 8010f32:	bf00      	nop
                }

                if(mask_buf == NULL) {
 8010f34:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010f36:	2b00      	cmp	r3, #0
 8010f38:	d110      	bne.n	8010f5c <rgb888_image_blend+0x490>
                    dest_buf_u16[dest_x] = lv_color_16_16_mix(res, dest_buf_u16[dest_x], opa);
 8010f3a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f3c:	005b      	lsls	r3, r3, #1
 8010f3e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010f40:	4413      	add	r3, r2
 8010f42:	8819      	ldrh	r1, [r3, #0]
 8010f44:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f46:	005b      	lsls	r3, r3, #1
 8010f48:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010f4a:	18d4      	adds	r4, r2, r3
 8010f4c:	7efa      	ldrb	r2, [r7, #27]
 8010f4e:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8010f50:	4618      	mov	r0, r3
 8010f52:	f7ff f877 	bl	8010044 <lv_color_16_16_mix>
 8010f56:	4603      	mov	r3, r0
 8010f58:	8023      	strh	r3, [r4, #0]
 8010f5a:	e031      	b.n	8010fc0 <rgb888_image_blend+0x4f4>
                }
                else {
                    if(opa >= LV_OPA_MAX) dest_buf_u16[dest_x] = lv_color_16_16_mix(res, dest_buf_u16[dest_x], mask_buf[dest_x]);
 8010f5c:	7efb      	ldrb	r3, [r7, #27]
 8010f5e:	2bfc      	cmp	r3, #252	@ 0xfc
 8010f60:	d914      	bls.n	8010f8c <rgb888_image_blend+0x4c0>
 8010f62:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f64:	005b      	lsls	r3, r3, #1
 8010f66:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010f68:	4413      	add	r3, r2
 8010f6a:	8819      	ldrh	r1, [r3, #0]
 8010f6c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f6e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8010f70:	4413      	add	r3, r2
 8010f72:	7818      	ldrb	r0, [r3, #0]
 8010f74:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f76:	005b      	lsls	r3, r3, #1
 8010f78:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010f7a:	18d4      	adds	r4, r2, r3
 8010f7c:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8010f7e:	4602      	mov	r2, r0
 8010f80:	4618      	mov	r0, r3
 8010f82:	f7ff f85f 	bl	8010044 <lv_color_16_16_mix>
 8010f86:	4603      	mov	r3, r0
 8010f88:	8023      	strh	r3, [r4, #0]
 8010f8a:	e019      	b.n	8010fc0 <rgb888_image_blend+0x4f4>
                    else dest_buf_u16[dest_x] = lv_color_16_16_mix(res, dest_buf_u16[dest_x], LV_OPA_MIX2(mask_buf[dest_x], opa));
 8010f8c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f8e:	005b      	lsls	r3, r3, #1
 8010f90:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010f92:	4413      	add	r3, r2
 8010f94:	8819      	ldrh	r1, [r3, #0]
 8010f96:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010f98:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8010f9a:	4413      	add	r3, r2
 8010f9c:	781b      	ldrb	r3, [r3, #0]
 8010f9e:	461a      	mov	r2, r3
 8010fa0:	7efb      	ldrb	r3, [r7, #27]
 8010fa2:	fb02 f303 	mul.w	r3, r2, r3
 8010fa6:	121b      	asrs	r3, r3, #8
 8010fa8:	b2d8      	uxtb	r0, r3
 8010faa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010fac:	005b      	lsls	r3, r3, #1
 8010fae:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8010fb0:	18d4      	adds	r4, r2, r3
 8010fb2:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8010fb4:	4602      	mov	r2, r0
 8010fb6:	4618      	mov	r0, r3
 8010fb8:	f7ff f844 	bl	8010044 <lv_color_16_16_mix>
 8010fbc:	4603      	mov	r3, r0
 8010fbe:	8023      	strh	r3, [r4, #0]
            for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += src_px_size) {
 8010fc0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8010fc2:	3301      	adds	r3, #1
 8010fc4:	633b      	str	r3, [r7, #48]	@ 0x30
 8010fc6:	78fb      	ldrb	r3, [r7, #3]
 8010fc8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8010fca:	4413      	add	r3, r2
 8010fcc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8010fce:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8010fd0:	6a3b      	ldr	r3, [r7, #32]
 8010fd2:	429a      	cmp	r2, r3
 8010fd4:	f6ff aecb 	blt.w	8010d6e <rgb888_image_blend+0x2a2>
                }
            }
            dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 8010fd8:	697b      	ldr	r3, [r7, #20]
 8010fda:	4619      	mov	r1, r3
 8010fdc:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8010fde:	f000 fb6f 	bl	80116c0 <drawbuf_next_row>
 8010fe2:	63f8      	str	r0, [r7, #60]	@ 0x3c
            src_buf_u8 += src_stride;
 8010fe4:	693b      	ldr	r3, [r7, #16]
 8010fe6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8010fe8:	4413      	add	r3, r2
 8010fea:	63bb      	str	r3, [r7, #56]	@ 0x38
            if(mask_buf) mask_buf += mask_stride;
 8010fec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8010fee:	2b00      	cmp	r3, #0
 8010ff0:	d003      	beq.n	8010ffa <rgb888_image_blend+0x52e>
 8010ff2:	68fb      	ldr	r3, [r7, #12]
 8010ff4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8010ff6:	4413      	add	r3, r2
 8010ff8:	637b      	str	r3, [r7, #52]	@ 0x34
        for(y = 0; y < h; y++) {
 8010ffa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010ffc:	3301      	adds	r3, #1
 8010ffe:	62bb      	str	r3, [r7, #40]	@ 0x28
 8011000:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011002:	69fb      	ldr	r3, [r7, #28]
 8011004:	429a      	cmp	r2, r3
 8011006:	f6ff aeab 	blt.w	8010d60 <rgb888_image_blend+0x294>
 801100a:	e000      	b.n	801100e <rgb888_image_blend+0x542>
                        return;
 801100c:	bf00      	nop
        }

    }
}
 801100e:	3740      	adds	r7, #64	@ 0x40
 8011010:	46bd      	mov	sp, r7
 8011012:	bdb0      	pop	{r4, r5, r7, pc}

08011014 <argb8888_image_blend>:

static void LV_ATTRIBUTE_FAST_MEM argb8888_image_blend(_lv_draw_sw_blend_image_dsc_t * dsc)
{
 8011014:	b5b0      	push	{r4, r5, r7, lr}
 8011016:	b090      	sub	sp, #64	@ 0x40
 8011018:	af00      	add	r7, sp, #0
 801101a:	6078      	str	r0, [r7, #4]
    int32_t w = dsc->dest_w;
 801101c:	687b      	ldr	r3, [r7, #4]
 801101e:	685b      	ldr	r3, [r3, #4]
 8011020:	623b      	str	r3, [r7, #32]
    int32_t h = dsc->dest_h;
 8011022:	687b      	ldr	r3, [r7, #4]
 8011024:	689b      	ldr	r3, [r3, #8]
 8011026:	61fb      	str	r3, [r7, #28]
    lv_opa_t opa = dsc->opa;
 8011028:	687b      	ldr	r3, [r7, #4]
 801102a:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 801102e:	76fb      	strb	r3, [r7, #27]
    uint16_t * dest_buf_u16 = dsc->dest_buf;
 8011030:	687b      	ldr	r3, [r7, #4]
 8011032:	681b      	ldr	r3, [r3, #0]
 8011034:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int32_t dest_stride = dsc->dest_stride;
 8011036:	687b      	ldr	r3, [r7, #4]
 8011038:	68db      	ldr	r3, [r3, #12]
 801103a:	617b      	str	r3, [r7, #20]
    const uint8_t * src_buf_u8 = dsc->src_buf;
 801103c:	687b      	ldr	r3, [r7, #4]
 801103e:	699b      	ldr	r3, [r3, #24]
 8011040:	63bb      	str	r3, [r7, #56]	@ 0x38
    int32_t src_stride = dsc->src_stride;
 8011042:	687b      	ldr	r3, [r7, #4]
 8011044:	69db      	ldr	r3, [r3, #28]
 8011046:	613b      	str	r3, [r7, #16]
    const lv_opa_t * mask_buf = dsc->mask_buf;
 8011048:	687b      	ldr	r3, [r7, #4]
 801104a:	691b      	ldr	r3, [r3, #16]
 801104c:	637b      	str	r3, [r7, #52]	@ 0x34
    int32_t mask_stride = dsc->mask_stride;
 801104e:	687b      	ldr	r3, [r7, #4]
 8011050:	695b      	ldr	r3, [r3, #20]
 8011052:	60fb      	str	r3, [r7, #12]

    int32_t dest_x;
    int32_t src_x;
    int32_t y;

    if(dsc->blend_mode == LV_BLEND_MODE_NORMAL) {
 8011054:	687b      	ldr	r3, [r7, #4]
 8011056:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 801105a:	2b00      	cmp	r3, #0
 801105c:	f040 8125 	bne.w	80112aa <argb8888_image_blend+0x296>
        if(mask_buf == NULL && opa >= LV_OPA_MAX) {
 8011060:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011062:	2b00      	cmp	r3, #0
 8011064:	d13c      	bne.n	80110e0 <argb8888_image_blend+0xcc>
 8011066:	7efb      	ldrb	r3, [r7, #27]
 8011068:	2bfc      	cmp	r3, #252	@ 0xfc
 801106a:	d939      	bls.n	80110e0 <argb8888_image_blend+0xcc>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB565(dsc)) {
                for(y = 0; y < h; y++) {
 801106c:	2300      	movs	r3, #0
 801106e:	62bb      	str	r3, [r7, #40]	@ 0x28
 8011070:	e031      	b.n	80110d6 <argb8888_image_blend+0xc2>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += 4) {
 8011072:	2300      	movs	r3, #0
 8011074:	633b      	str	r3, [r7, #48]	@ 0x30
 8011076:	2300      	movs	r3, #0
 8011078:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801107a:	e01b      	b.n	80110b4 <argb8888_image_blend+0xa0>
                        dest_buf_u16[dest_x] = lv_color_24_16_mix(&src_buf_u8[src_x], dest_buf_u16[dest_x], src_buf_u8[src_x + 3]);
 801107c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801107e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011080:	18d0      	adds	r0, r2, r3
 8011082:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011084:	005b      	lsls	r3, r3, #1
 8011086:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011088:	4413      	add	r3, r2
 801108a:	8819      	ldrh	r1, [r3, #0]
 801108c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801108e:	3303      	adds	r3, #3
 8011090:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011092:	4413      	add	r3, r2
 8011094:	781d      	ldrb	r5, [r3, #0]
 8011096:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011098:	005b      	lsls	r3, r3, #1
 801109a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801109c:	18d4      	adds	r4, r2, r3
 801109e:	462a      	mov	r2, r5
 80110a0:	f000 fa93 	bl	80115ca <lv_color_24_16_mix>
 80110a4:	4603      	mov	r3, r0
 80110a6:	8023      	strh	r3, [r4, #0]
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += 4) {
 80110a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80110aa:	3301      	adds	r3, #1
 80110ac:	633b      	str	r3, [r7, #48]	@ 0x30
 80110ae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80110b0:	3304      	adds	r3, #4
 80110b2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80110b4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80110b6:	6a3b      	ldr	r3, [r7, #32]
 80110b8:	429a      	cmp	r2, r3
 80110ba:	dbdf      	blt.n	801107c <argb8888_image_blend+0x68>
                    }
                    dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 80110bc:	697b      	ldr	r3, [r7, #20]
 80110be:	4619      	mov	r1, r3
 80110c0:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80110c2:	f000 fafd 	bl	80116c0 <drawbuf_next_row>
 80110c6:	63f8      	str	r0, [r7, #60]	@ 0x3c
                    src_buf_u8 += src_stride;
 80110c8:	693b      	ldr	r3, [r7, #16]
 80110ca:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80110cc:	4413      	add	r3, r2
 80110ce:	63bb      	str	r3, [r7, #56]	@ 0x38
                for(y = 0; y < h; y++) {
 80110d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80110d2:	3301      	adds	r3, #1
 80110d4:	62bb      	str	r3, [r7, #40]	@ 0x28
 80110d6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80110d8:	69fb      	ldr	r3, [r7, #28]
 80110da:	429a      	cmp	r2, r3
 80110dc:	dbc9      	blt.n	8011072 <argb8888_image_blend+0x5e>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB565(dsc)) {
 80110de:	e271      	b.n	80115c4 <argb8888_image_blend+0x5b0>
                }
            }
        }
        else if(mask_buf == NULL && opa < LV_OPA_MAX) {
 80110e0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80110e2:	2b00      	cmp	r3, #0
 80110e4:	d142      	bne.n	801116c <argb8888_image_blend+0x158>
 80110e6:	7efb      	ldrb	r3, [r7, #27]
 80110e8:	2bfc      	cmp	r3, #252	@ 0xfc
 80110ea:	d83f      	bhi.n	801116c <argb8888_image_blend+0x158>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB565_WITH_OPA(dsc)) {
                for(y = 0; y < h; y++) {
 80110ec:	2300      	movs	r3, #0
 80110ee:	62bb      	str	r3, [r7, #40]	@ 0x28
 80110f0:	e037      	b.n	8011162 <argb8888_image_blend+0x14e>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += 4) {
 80110f2:	2300      	movs	r3, #0
 80110f4:	633b      	str	r3, [r7, #48]	@ 0x30
 80110f6:	2300      	movs	r3, #0
 80110f8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80110fa:	e021      	b.n	8011140 <argb8888_image_blend+0x12c>
                        dest_buf_u16[dest_x] = lv_color_24_16_mix(&src_buf_u8[src_x], dest_buf_u16[dest_x], LV_OPA_MIX2(src_buf_u8[src_x + 3],
 80110fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80110fe:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011100:	18d0      	adds	r0, r2, r3
 8011102:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011104:	005b      	lsls	r3, r3, #1
 8011106:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011108:	4413      	add	r3, r2
 801110a:	8819      	ldrh	r1, [r3, #0]
 801110c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801110e:	3303      	adds	r3, #3
 8011110:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011112:	4413      	add	r3, r2
 8011114:	781b      	ldrb	r3, [r3, #0]
 8011116:	461a      	mov	r2, r3
 8011118:	7efb      	ldrb	r3, [r7, #27]
 801111a:	fb02 f303 	mul.w	r3, r2, r3
 801111e:	121b      	asrs	r3, r3, #8
 8011120:	b2dd      	uxtb	r5, r3
 8011122:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011124:	005b      	lsls	r3, r3, #1
 8011126:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011128:	18d4      	adds	r4, r2, r3
 801112a:	462a      	mov	r2, r5
 801112c:	f000 fa4d 	bl	80115ca <lv_color_24_16_mix>
 8011130:	4603      	mov	r3, r0
 8011132:	8023      	strh	r3, [r4, #0]
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += 4) {
 8011134:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011136:	3301      	adds	r3, #1
 8011138:	633b      	str	r3, [r7, #48]	@ 0x30
 801113a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801113c:	3304      	adds	r3, #4
 801113e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011140:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011142:	6a3b      	ldr	r3, [r7, #32]
 8011144:	429a      	cmp	r2, r3
 8011146:	dbd9      	blt.n	80110fc <argb8888_image_blend+0xe8>
                                                                                                                        opa));
                    }
                    dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 8011148:	697b      	ldr	r3, [r7, #20]
 801114a:	4619      	mov	r1, r3
 801114c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 801114e:	f000 fab7 	bl	80116c0 <drawbuf_next_row>
 8011152:	63f8      	str	r0, [r7, #60]	@ 0x3c
                    src_buf_u8 += src_stride;
 8011154:	693b      	ldr	r3, [r7, #16]
 8011156:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011158:	4413      	add	r3, r2
 801115a:	63bb      	str	r3, [r7, #56]	@ 0x38
                for(y = 0; y < h; y++) {
 801115c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801115e:	3301      	adds	r3, #1
 8011160:	62bb      	str	r3, [r7, #40]	@ 0x28
 8011162:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8011164:	69fb      	ldr	r3, [r7, #28]
 8011166:	429a      	cmp	r2, r3
 8011168:	dbc3      	blt.n	80110f2 <argb8888_image_blend+0xde>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB565_WITH_OPA(dsc)) {
 801116a:	e22b      	b.n	80115c4 <argb8888_image_blend+0x5b0>
                }
            }
        }
        else if(mask_buf && opa >= LV_OPA_MAX) {
 801116c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801116e:	2b00      	cmp	r3, #0
 8011170:	d049      	beq.n	8011206 <argb8888_image_blend+0x1f2>
 8011172:	7efb      	ldrb	r3, [r7, #27]
 8011174:	2bfc      	cmp	r3, #252	@ 0xfc
 8011176:	d946      	bls.n	8011206 <argb8888_image_blend+0x1f2>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB565_WITH_MASK(dsc)) {
                for(y = 0; y < h; y++) {
 8011178:	2300      	movs	r3, #0
 801117a:	62bb      	str	r3, [r7, #40]	@ 0x28
 801117c:	e03e      	b.n	80111fc <argb8888_image_blend+0x1e8>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += 4) {
 801117e:	2300      	movs	r3, #0
 8011180:	633b      	str	r3, [r7, #48]	@ 0x30
 8011182:	2300      	movs	r3, #0
 8011184:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011186:	e024      	b.n	80111d2 <argb8888_image_blend+0x1be>
                        dest_buf_u16[dest_x] = lv_color_24_16_mix(&src_buf_u8[src_x], dest_buf_u16[dest_x],
 8011188:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801118a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801118c:	18d0      	adds	r0, r2, r3
 801118e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011190:	005b      	lsls	r3, r3, #1
 8011192:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011194:	4413      	add	r3, r2
 8011196:	8819      	ldrh	r1, [r3, #0]
                                                                  LV_OPA_MIX2(src_buf_u8[src_x + 3], mask_buf[dest_x]));
 8011198:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801119a:	3303      	adds	r3, #3
 801119c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801119e:	4413      	add	r3, r2
 80111a0:	781b      	ldrb	r3, [r3, #0]
 80111a2:	461c      	mov	r4, r3
 80111a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80111a6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80111a8:	4413      	add	r3, r2
 80111aa:	781b      	ldrb	r3, [r3, #0]
 80111ac:	fb04 f303 	mul.w	r3, r4, r3
 80111b0:	121b      	asrs	r3, r3, #8
                        dest_buf_u16[dest_x] = lv_color_24_16_mix(&src_buf_u8[src_x], dest_buf_u16[dest_x],
 80111b2:	b2dd      	uxtb	r5, r3
 80111b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80111b6:	005b      	lsls	r3, r3, #1
 80111b8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80111ba:	18d4      	adds	r4, r2, r3
 80111bc:	462a      	mov	r2, r5
 80111be:	f000 fa04 	bl	80115ca <lv_color_24_16_mix>
 80111c2:	4603      	mov	r3, r0
 80111c4:	8023      	strh	r3, [r4, #0]
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += 4) {
 80111c6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80111c8:	3301      	adds	r3, #1
 80111ca:	633b      	str	r3, [r7, #48]	@ 0x30
 80111cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80111ce:	3304      	adds	r3, #4
 80111d0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80111d2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80111d4:	6a3b      	ldr	r3, [r7, #32]
 80111d6:	429a      	cmp	r2, r3
 80111d8:	dbd6      	blt.n	8011188 <argb8888_image_blend+0x174>
                    }
                    dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 80111da:	697b      	ldr	r3, [r7, #20]
 80111dc:	4619      	mov	r1, r3
 80111de:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80111e0:	f000 fa6e 	bl	80116c0 <drawbuf_next_row>
 80111e4:	63f8      	str	r0, [r7, #60]	@ 0x3c
                    src_buf_u8 += src_stride;
 80111e6:	693b      	ldr	r3, [r7, #16]
 80111e8:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80111ea:	4413      	add	r3, r2
 80111ec:	63bb      	str	r3, [r7, #56]	@ 0x38
                    mask_buf += mask_stride;
 80111ee:	68fb      	ldr	r3, [r7, #12]
 80111f0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80111f2:	4413      	add	r3, r2
 80111f4:	637b      	str	r3, [r7, #52]	@ 0x34
                for(y = 0; y < h; y++) {
 80111f6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80111f8:	3301      	adds	r3, #1
 80111fa:	62bb      	str	r3, [r7, #40]	@ 0x28
 80111fc:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80111fe:	69fb      	ldr	r3, [r7, #28]
 8011200:	429a      	cmp	r2, r3
 8011202:	dbbc      	blt.n	801117e <argb8888_image_blend+0x16a>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB565_WITH_MASK(dsc)) {
 8011204:	e1de      	b.n	80115c4 <argb8888_image_blend+0x5b0>
                }
            }
        }
        else if(mask_buf && opa < LV_OPA_MAX) {
 8011206:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011208:	2b00      	cmp	r3, #0
 801120a:	f000 81db 	beq.w	80115c4 <argb8888_image_blend+0x5b0>
 801120e:	7efb      	ldrb	r3, [r7, #27]
 8011210:	2bfc      	cmp	r3, #252	@ 0xfc
 8011212:	f200 81d7 	bhi.w	80115c4 <argb8888_image_blend+0x5b0>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB565_MIX_MASK_OPA(dsc)) {
                for(y = 0; y < h; y++) {
 8011216:	2300      	movs	r3, #0
 8011218:	62bb      	str	r3, [r7, #40]	@ 0x28
 801121a:	e041      	b.n	80112a0 <argb8888_image_blend+0x28c>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += 4) {
 801121c:	2300      	movs	r3, #0
 801121e:	633b      	str	r3, [r7, #48]	@ 0x30
 8011220:	2300      	movs	r3, #0
 8011222:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011224:	e027      	b.n	8011276 <argb8888_image_blend+0x262>
                        dest_buf_u16[dest_x] = lv_color_24_16_mix(&src_buf_u8[src_x], dest_buf_u16[dest_x],
 8011226:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011228:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801122a:	18d0      	adds	r0, r2, r3
 801122c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801122e:	005b      	lsls	r3, r3, #1
 8011230:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011232:	4413      	add	r3, r2
 8011234:	8819      	ldrh	r1, [r3, #0]
                                                                  LV_OPA_MIX3(src_buf_u8[src_x + 3], mask_buf[dest_x], opa));
 8011236:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011238:	3303      	adds	r3, #3
 801123a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801123c:	4413      	add	r3, r2
 801123e:	781b      	ldrb	r3, [r3, #0]
 8011240:	461c      	mov	r4, r3
 8011242:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011244:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011246:	4413      	add	r3, r2
 8011248:	781b      	ldrb	r3, [r3, #0]
 801124a:	fb04 f303 	mul.w	r3, r4, r3
 801124e:	7efa      	ldrb	r2, [r7, #27]
 8011250:	fb02 f303 	mul.w	r3, r2, r3
 8011254:	141b      	asrs	r3, r3, #16
                        dest_buf_u16[dest_x] = lv_color_24_16_mix(&src_buf_u8[src_x], dest_buf_u16[dest_x],
 8011256:	b2dd      	uxtb	r5, r3
 8011258:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801125a:	005b      	lsls	r3, r3, #1
 801125c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801125e:	18d4      	adds	r4, r2, r3
 8011260:	462a      	mov	r2, r5
 8011262:	f000 f9b2 	bl	80115ca <lv_color_24_16_mix>
 8011266:	4603      	mov	r3, r0
 8011268:	8023      	strh	r3, [r4, #0]
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += 4) {
 801126a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801126c:	3301      	adds	r3, #1
 801126e:	633b      	str	r3, [r7, #48]	@ 0x30
 8011270:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011272:	3304      	adds	r3, #4
 8011274:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011276:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011278:	6a3b      	ldr	r3, [r7, #32]
 801127a:	429a      	cmp	r2, r3
 801127c:	dbd3      	blt.n	8011226 <argb8888_image_blend+0x212>
                    }
                    dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 801127e:	697b      	ldr	r3, [r7, #20]
 8011280:	4619      	mov	r1, r3
 8011282:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8011284:	f000 fa1c 	bl	80116c0 <drawbuf_next_row>
 8011288:	63f8      	str	r0, [r7, #60]	@ 0x3c
                    src_buf_u8 += src_stride;
 801128a:	693b      	ldr	r3, [r7, #16]
 801128c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801128e:	4413      	add	r3, r2
 8011290:	63bb      	str	r3, [r7, #56]	@ 0x38
                    mask_buf += mask_stride;
 8011292:	68fb      	ldr	r3, [r7, #12]
 8011294:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011296:	4413      	add	r3, r2
 8011298:	637b      	str	r3, [r7, #52]	@ 0x34
                for(y = 0; y < h; y++) {
 801129a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801129c:	3301      	adds	r3, #1
 801129e:	62bb      	str	r3, [r7, #40]	@ 0x28
 80112a0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80112a2:	69fb      	ldr	r3, [r7, #28]
 80112a4:	429a      	cmp	r2, r3
 80112a6:	dbb9      	blt.n	801121c <argb8888_image_blend+0x208>
 80112a8:	e18c      	b.n	80115c4 <argb8888_image_blend+0x5b0>
                }
            }
        }
    }
    else {
        uint16_t res = 0;
 80112aa:	2300      	movs	r3, #0
 80112ac:	84fb      	strh	r3, [r7, #38]	@ 0x26
        for(y = 0; y < h; y++) {
 80112ae:	2300      	movs	r3, #0
 80112b0:	62bb      	str	r3, [r7, #40]	@ 0x28
 80112b2:	e180      	b.n	80115b6 <argb8888_image_blend+0x5a2>
            lv_color16_t * dest_buf_c16 = (lv_color16_t *) dest_buf_u16;
 80112b4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80112b6:	60bb      	str	r3, [r7, #8]
            for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += 4) {
 80112b8:	2300      	movs	r3, #0
 80112ba:	633b      	str	r3, [r7, #48]	@ 0x30
 80112bc:	2300      	movs	r3, #0
 80112be:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80112c0:	e160      	b.n	8011584 <argb8888_image_blend+0x570>
                switch(dsc->blend_mode) {
 80112c2:	687b      	ldr	r3, [r7, #4]
 80112c4:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 80112c8:	2b03      	cmp	r3, #3
 80112ca:	f000 8097 	beq.w	80113fc <argb8888_image_blend+0x3e8>
 80112ce:	2b03      	cmp	r3, #3
 80112d0:	f300 8177 	bgt.w	80115c2 <argb8888_image_blend+0x5ae>
 80112d4:	2b01      	cmp	r3, #1
 80112d6:	d002      	beq.n	80112de <argb8888_image_blend+0x2ca>
 80112d8:	2b02      	cmp	r3, #2
 80112da:	d049      	beq.n	8011370 <argb8888_image_blend+0x35c>
                        res += ((dest_buf_c16[dest_x].green * (src_buf_u8[src_x + 1] >> 2)) >> 6) << 5;
                        res += (dest_buf_c16[dest_x].blue * (src_buf_u8[src_x + 0] >> 3)) >> 5;
                        break;
                    default:
                        LV_LOG_WARN("Not supported blend mode: %d", dsc->blend_mode);
                        return;
 80112dc:	e171      	b.n	80115c2 <argb8888_image_blend+0x5ae>
                        res = (LV_MIN(dest_buf_c16[dest_x].red + (src_buf_u8[src_x + 2] >> 3), 31)) << 11;
 80112de:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80112e0:	005b      	lsls	r3, r3, #1
 80112e2:	68ba      	ldr	r2, [r7, #8]
 80112e4:	4413      	add	r3, r2
 80112e6:	785b      	ldrb	r3, [r3, #1]
 80112e8:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80112ec:	b2db      	uxtb	r3, r3
 80112ee:	4619      	mov	r1, r3
 80112f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80112f2:	3302      	adds	r3, #2
 80112f4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80112f6:	4413      	add	r3, r2
 80112f8:	781b      	ldrb	r3, [r3, #0]
 80112fa:	08db      	lsrs	r3, r3, #3
 80112fc:	b2db      	uxtb	r3, r3
 80112fe:	440b      	add	r3, r1
 8011300:	2b1f      	cmp	r3, #31
 8011302:	bfa8      	it	ge
 8011304:	231f      	movge	r3, #31
 8011306:	b29b      	uxth	r3, r3
 8011308:	02db      	lsls	r3, r3, #11
 801130a:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        res += (LV_MIN(dest_buf_c16[dest_x].green + (src_buf_u8[src_x + 1] >> 2), 63)) << 5;
 801130c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801130e:	005b      	lsls	r3, r3, #1
 8011310:	68ba      	ldr	r2, [r7, #8]
 8011312:	4413      	add	r3, r2
 8011314:	881b      	ldrh	r3, [r3, #0]
 8011316:	f3c3 1345 	ubfx	r3, r3, #5, #6
 801131a:	b2db      	uxtb	r3, r3
 801131c:	4619      	mov	r1, r3
 801131e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011320:	3301      	adds	r3, #1
 8011322:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011324:	4413      	add	r3, r2
 8011326:	781b      	ldrb	r3, [r3, #0]
 8011328:	089b      	lsrs	r3, r3, #2
 801132a:	b2db      	uxtb	r3, r3
 801132c:	440b      	add	r3, r1
 801132e:	2b3f      	cmp	r3, #63	@ 0x3f
 8011330:	bfa8      	it	ge
 8011332:	233f      	movge	r3, #63	@ 0x3f
 8011334:	b29b      	uxth	r3, r3
 8011336:	015b      	lsls	r3, r3, #5
 8011338:	b29a      	uxth	r2, r3
 801133a:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 801133c:	4413      	add	r3, r2
 801133e:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        res += LV_MIN(dest_buf_c16[dest_x].blue + (src_buf_u8[src_x + 0] >> 3), 31);
 8011340:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011342:	005b      	lsls	r3, r3, #1
 8011344:	68ba      	ldr	r2, [r7, #8]
 8011346:	4413      	add	r3, r2
 8011348:	781b      	ldrb	r3, [r3, #0]
 801134a:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801134e:	b2db      	uxtb	r3, r3
 8011350:	4619      	mov	r1, r3
 8011352:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011354:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011356:	4413      	add	r3, r2
 8011358:	781b      	ldrb	r3, [r3, #0]
 801135a:	08db      	lsrs	r3, r3, #3
 801135c:	b2db      	uxtb	r3, r3
 801135e:	440b      	add	r3, r1
 8011360:	2b1f      	cmp	r3, #31
 8011362:	bfa8      	it	ge
 8011364:	231f      	movge	r3, #31
 8011366:	b29a      	uxth	r2, r3
 8011368:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 801136a:	4413      	add	r3, r2
 801136c:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        break;
 801136e:	e08b      	b.n	8011488 <argb8888_image_blend+0x474>
                        res = (LV_MAX(dest_buf_c16[dest_x].red - (src_buf_u8[src_x + 2] >> 3), 0)) << 11;
 8011370:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011372:	005b      	lsls	r3, r3, #1
 8011374:	68ba      	ldr	r2, [r7, #8]
 8011376:	4413      	add	r3, r2
 8011378:	785b      	ldrb	r3, [r3, #1]
 801137a:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801137e:	b2db      	uxtb	r3, r3
 8011380:	4619      	mov	r1, r3
 8011382:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011384:	3302      	adds	r3, #2
 8011386:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011388:	4413      	add	r3, r2
 801138a:	781b      	ldrb	r3, [r3, #0]
 801138c:	08db      	lsrs	r3, r3, #3
 801138e:	b2db      	uxtb	r3, r3
 8011390:	1acb      	subs	r3, r1, r3
 8011392:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8011396:	b29b      	uxth	r3, r3
 8011398:	02db      	lsls	r3, r3, #11
 801139a:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        res += (LV_MAX(dest_buf_c16[dest_x].green - (src_buf_u8[src_x + 1] >> 2), 0)) << 5;
 801139c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801139e:	005b      	lsls	r3, r3, #1
 80113a0:	68ba      	ldr	r2, [r7, #8]
 80113a2:	4413      	add	r3, r2
 80113a4:	881b      	ldrh	r3, [r3, #0]
 80113a6:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80113aa:	b2db      	uxtb	r3, r3
 80113ac:	4619      	mov	r1, r3
 80113ae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80113b0:	3301      	adds	r3, #1
 80113b2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80113b4:	4413      	add	r3, r2
 80113b6:	781b      	ldrb	r3, [r3, #0]
 80113b8:	089b      	lsrs	r3, r3, #2
 80113ba:	b2db      	uxtb	r3, r3
 80113bc:	1acb      	subs	r3, r1, r3
 80113be:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80113c2:	b29b      	uxth	r3, r3
 80113c4:	015b      	lsls	r3, r3, #5
 80113c6:	b29a      	uxth	r2, r3
 80113c8:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80113ca:	4413      	add	r3, r2
 80113cc:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        res += LV_MAX(dest_buf_c16[dest_x].blue - (src_buf_u8[src_x + 0] >> 3), 0);
 80113ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80113d0:	005b      	lsls	r3, r3, #1
 80113d2:	68ba      	ldr	r2, [r7, #8]
 80113d4:	4413      	add	r3, r2
 80113d6:	781b      	ldrb	r3, [r3, #0]
 80113d8:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80113dc:	b2db      	uxtb	r3, r3
 80113de:	4619      	mov	r1, r3
 80113e0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80113e2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80113e4:	4413      	add	r3, r2
 80113e6:	781b      	ldrb	r3, [r3, #0]
 80113e8:	08db      	lsrs	r3, r3, #3
 80113ea:	b2db      	uxtb	r3, r3
 80113ec:	1acb      	subs	r3, r1, r3
 80113ee:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80113f2:	b29a      	uxth	r2, r3
 80113f4:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80113f6:	4413      	add	r3, r2
 80113f8:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        break;
 80113fa:	e045      	b.n	8011488 <argb8888_image_blend+0x474>
                        res = ((dest_buf_c16[dest_x].red * (src_buf_u8[src_x + 2] >> 3)) >> 5) << 11;
 80113fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80113fe:	005b      	lsls	r3, r3, #1
 8011400:	68ba      	ldr	r2, [r7, #8]
 8011402:	4413      	add	r3, r2
 8011404:	785b      	ldrb	r3, [r3, #1]
 8011406:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801140a:	b2db      	uxtb	r3, r3
 801140c:	4619      	mov	r1, r3
 801140e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011410:	3302      	adds	r3, #2
 8011412:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011414:	4413      	add	r3, r2
 8011416:	781b      	ldrb	r3, [r3, #0]
 8011418:	08db      	lsrs	r3, r3, #3
 801141a:	b2db      	uxtb	r3, r3
 801141c:	fb01 f303 	mul.w	r3, r1, r3
 8011420:	115b      	asrs	r3, r3, #5
 8011422:	b29b      	uxth	r3, r3
 8011424:	02db      	lsls	r3, r3, #11
 8011426:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        res += ((dest_buf_c16[dest_x].green * (src_buf_u8[src_x + 1] >> 2)) >> 6) << 5;
 8011428:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801142a:	005b      	lsls	r3, r3, #1
 801142c:	68ba      	ldr	r2, [r7, #8]
 801142e:	4413      	add	r3, r2
 8011430:	881b      	ldrh	r3, [r3, #0]
 8011432:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8011436:	b2db      	uxtb	r3, r3
 8011438:	4619      	mov	r1, r3
 801143a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801143c:	3301      	adds	r3, #1
 801143e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011440:	4413      	add	r3, r2
 8011442:	781b      	ldrb	r3, [r3, #0]
 8011444:	089b      	lsrs	r3, r3, #2
 8011446:	b2db      	uxtb	r3, r3
 8011448:	fb01 f303 	mul.w	r3, r1, r3
 801144c:	119b      	asrs	r3, r3, #6
 801144e:	b29b      	uxth	r3, r3
 8011450:	015b      	lsls	r3, r3, #5
 8011452:	b29a      	uxth	r2, r3
 8011454:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8011456:	4413      	add	r3, r2
 8011458:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        res += (dest_buf_c16[dest_x].blue * (src_buf_u8[src_x + 0] >> 3)) >> 5;
 801145a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801145c:	005b      	lsls	r3, r3, #1
 801145e:	68ba      	ldr	r2, [r7, #8]
 8011460:	4413      	add	r3, r2
 8011462:	781b      	ldrb	r3, [r3, #0]
 8011464:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8011468:	b2db      	uxtb	r3, r3
 801146a:	4619      	mov	r1, r3
 801146c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801146e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011470:	4413      	add	r3, r2
 8011472:	781b      	ldrb	r3, [r3, #0]
 8011474:	08db      	lsrs	r3, r3, #3
 8011476:	b2db      	uxtb	r3, r3
 8011478:	fb01 f303 	mul.w	r3, r1, r3
 801147c:	115b      	asrs	r3, r3, #5
 801147e:	b29a      	uxth	r2, r3
 8011480:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8011482:	4413      	add	r3, r2
 8011484:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        break;
 8011486:	bf00      	nop
                }

                if(mask_buf == NULL && opa >= LV_OPA_MAX) {
 8011488:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801148a:	2b00      	cmp	r3, #0
 801148c:	d118      	bne.n	80114c0 <argb8888_image_blend+0x4ac>
 801148e:	7efb      	ldrb	r3, [r7, #27]
 8011490:	2bfc      	cmp	r3, #252	@ 0xfc
 8011492:	d915      	bls.n	80114c0 <argb8888_image_blend+0x4ac>
                    dest_buf_u16[dest_x] = lv_color_16_16_mix(res, dest_buf_u16[dest_x], src_buf_u8[src_x + 3]);
 8011494:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011496:	005b      	lsls	r3, r3, #1
 8011498:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801149a:	4413      	add	r3, r2
 801149c:	8819      	ldrh	r1, [r3, #0]
 801149e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80114a0:	3303      	adds	r3, #3
 80114a2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80114a4:	4413      	add	r3, r2
 80114a6:	7818      	ldrb	r0, [r3, #0]
 80114a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80114aa:	005b      	lsls	r3, r3, #1
 80114ac:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80114ae:	18d4      	adds	r4, r2, r3
 80114b0:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80114b2:	4602      	mov	r2, r0
 80114b4:	4618      	mov	r0, r3
 80114b6:	f7fe fdc5 	bl	8010044 <lv_color_16_16_mix>
 80114ba:	4603      	mov	r3, r0
 80114bc:	8023      	strh	r3, [r4, #0]
 80114be:	e05b      	b.n	8011578 <argb8888_image_blend+0x564>
                }
                else if(mask_buf == NULL && opa < LV_OPA_MAX) {
 80114c0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80114c2:	2b00      	cmp	r3, #0
 80114c4:	d11e      	bne.n	8011504 <argb8888_image_blend+0x4f0>
 80114c6:	7efb      	ldrb	r3, [r7, #27]
 80114c8:	2bfc      	cmp	r3, #252	@ 0xfc
 80114ca:	d81b      	bhi.n	8011504 <argb8888_image_blend+0x4f0>
                    dest_buf_u16[dest_x] = lv_color_16_16_mix(res, dest_buf_u16[dest_x], LV_OPA_MIX2(opa, src_buf_u8[src_x + 3]));
 80114cc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80114ce:	005b      	lsls	r3, r3, #1
 80114d0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80114d2:	4413      	add	r3, r2
 80114d4:	8818      	ldrh	r0, [r3, #0]
 80114d6:	7efb      	ldrb	r3, [r7, #27]
 80114d8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80114da:	3203      	adds	r2, #3
 80114dc:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80114de:	440a      	add	r2, r1
 80114e0:	7812      	ldrb	r2, [r2, #0]
 80114e2:	fb02 f303 	mul.w	r3, r2, r3
 80114e6:	121b      	asrs	r3, r3, #8
 80114e8:	b2d9      	uxtb	r1, r3
 80114ea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80114ec:	005b      	lsls	r3, r3, #1
 80114ee:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80114f0:	18d4      	adds	r4, r2, r3
 80114f2:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 80114f4:	460a      	mov	r2, r1
 80114f6:	4601      	mov	r1, r0
 80114f8:	4618      	mov	r0, r3
 80114fa:	f7fe fda3 	bl	8010044 <lv_color_16_16_mix>
 80114fe:	4603      	mov	r3, r0
 8011500:	8023      	strh	r3, [r4, #0]
 8011502:	e039      	b.n	8011578 <argb8888_image_blend+0x564>
                }
                else {
                    if(opa >= LV_OPA_MAX) dest_buf_u16[dest_x] = lv_color_16_16_mix(res, dest_buf_u16[dest_x], mask_buf[dest_x]);
 8011504:	7efb      	ldrb	r3, [r7, #27]
 8011506:	2bfc      	cmp	r3, #252	@ 0xfc
 8011508:	d914      	bls.n	8011534 <argb8888_image_blend+0x520>
 801150a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801150c:	005b      	lsls	r3, r3, #1
 801150e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011510:	4413      	add	r3, r2
 8011512:	8819      	ldrh	r1, [r3, #0]
 8011514:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011516:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011518:	4413      	add	r3, r2
 801151a:	7818      	ldrb	r0, [r3, #0]
 801151c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801151e:	005b      	lsls	r3, r3, #1
 8011520:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011522:	18d4      	adds	r4, r2, r3
 8011524:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8011526:	4602      	mov	r2, r0
 8011528:	4618      	mov	r0, r3
 801152a:	f7fe fd8b 	bl	8010044 <lv_color_16_16_mix>
 801152e:	4603      	mov	r3, r0
 8011530:	8023      	strh	r3, [r4, #0]
 8011532:	e021      	b.n	8011578 <argb8888_image_blend+0x564>
                    else dest_buf_u16[dest_x] = lv_color_16_16_mix(res, dest_buf_u16[dest_x], LV_OPA_MIX3(mask_buf[dest_x], opa,
 8011534:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011536:	005b      	lsls	r3, r3, #1
 8011538:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801153a:	4413      	add	r3, r2
 801153c:	8818      	ldrh	r0, [r3, #0]
 801153e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011540:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011542:	4413      	add	r3, r2
 8011544:	781b      	ldrb	r3, [r3, #0]
 8011546:	461a      	mov	r2, r3
 8011548:	7efb      	ldrb	r3, [r7, #27]
 801154a:	fb02 f303 	mul.w	r3, r2, r3
 801154e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8011550:	3203      	adds	r2, #3
 8011552:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8011554:	440a      	add	r2, r1
 8011556:	7812      	ldrb	r2, [r2, #0]
 8011558:	fb02 f303 	mul.w	r3, r2, r3
 801155c:	141b      	asrs	r3, r3, #16
 801155e:	b2d9      	uxtb	r1, r3
 8011560:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011562:	005b      	lsls	r3, r3, #1
 8011564:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011566:	18d4      	adds	r4, r2, r3
 8011568:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 801156a:	460a      	mov	r2, r1
 801156c:	4601      	mov	r1, r0
 801156e:	4618      	mov	r0, r3
 8011570:	f7fe fd68 	bl	8010044 <lv_color_16_16_mix>
 8011574:	4603      	mov	r3, r0
 8011576:	8023      	strh	r3, [r4, #0]
            for(dest_x = 0, src_x = 0; dest_x < w; dest_x++, src_x += 4) {
 8011578:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801157a:	3301      	adds	r3, #1
 801157c:	633b      	str	r3, [r7, #48]	@ 0x30
 801157e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011580:	3304      	adds	r3, #4
 8011582:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011584:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011586:	6a3b      	ldr	r3, [r7, #32]
 8011588:	429a      	cmp	r2, r3
 801158a:	f6ff ae9a 	blt.w	80112c2 <argb8888_image_blend+0x2ae>
                                                                                                              src_buf_u8[src_x + 3]));
                }
            }

            dest_buf_u16 = drawbuf_next_row(dest_buf_u16, dest_stride);
 801158e:	697b      	ldr	r3, [r7, #20]
 8011590:	4619      	mov	r1, r3
 8011592:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8011594:	f000 f894 	bl	80116c0 <drawbuf_next_row>
 8011598:	63f8      	str	r0, [r7, #60]	@ 0x3c
            src_buf_u8 += src_stride;
 801159a:	693b      	ldr	r3, [r7, #16]
 801159c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801159e:	4413      	add	r3, r2
 80115a0:	63bb      	str	r3, [r7, #56]	@ 0x38
            if(mask_buf) mask_buf += mask_stride;
 80115a2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80115a4:	2b00      	cmp	r3, #0
 80115a6:	d003      	beq.n	80115b0 <argb8888_image_blend+0x59c>
 80115a8:	68fb      	ldr	r3, [r7, #12]
 80115aa:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80115ac:	4413      	add	r3, r2
 80115ae:	637b      	str	r3, [r7, #52]	@ 0x34
        for(y = 0; y < h; y++) {
 80115b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80115b2:	3301      	adds	r3, #1
 80115b4:	62bb      	str	r3, [r7, #40]	@ 0x28
 80115b6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80115b8:	69fb      	ldr	r3, [r7, #28]
 80115ba:	429a      	cmp	r2, r3
 80115bc:	f6ff ae7a 	blt.w	80112b4 <argb8888_image_blend+0x2a0>
 80115c0:	e000      	b.n	80115c4 <argb8888_image_blend+0x5b0>
                        return;
 80115c2:	bf00      	nop
        }
    }
}
 80115c4:	3740      	adds	r7, #64	@ 0x40
 80115c6:	46bd      	mov	sp, r7
 80115c8:	bdb0      	pop	{r4, r5, r7, pc}

080115ca <lv_color_24_16_mix>:

static inline uint16_t LV_ATTRIBUTE_FAST_MEM lv_color_24_16_mix(const uint8_t * c1, uint16_t c2, uint8_t mix)
{
 80115ca:	b480      	push	{r7}
 80115cc:	b085      	sub	sp, #20
 80115ce:	af00      	add	r7, sp, #0
 80115d0:	6078      	str	r0, [r7, #4]
 80115d2:	460b      	mov	r3, r1
 80115d4:	807b      	strh	r3, [r7, #2]
 80115d6:	4613      	mov	r3, r2
 80115d8:	707b      	strb	r3, [r7, #1]
    if(mix == 0) {
 80115da:	787b      	ldrb	r3, [r7, #1]
 80115dc:	2b00      	cmp	r3, #0
 80115de:	d101      	bne.n	80115e4 <lv_color_24_16_mix+0x1a>
        return c2;
 80115e0:	887b      	ldrh	r3, [r7, #2]
 80115e2:	e067      	b.n	80116b4 <lv_color_24_16_mix+0xea>
    }
    else if(mix == 255) {
 80115e4:	787b      	ldrb	r3, [r7, #1]
 80115e6:	2bff      	cmp	r3, #255	@ 0xff
 80115e8:	d11b      	bne.n	8011622 <lv_color_24_16_mix+0x58>
        return ((c1[2] & 0xF8) << 8)  + ((c1[1] & 0xFC) << 3) + ((c1[0] & 0xF8) >> 3);
 80115ea:	687b      	ldr	r3, [r7, #4]
 80115ec:	3302      	adds	r3, #2
 80115ee:	781b      	ldrb	r3, [r3, #0]
 80115f0:	021b      	lsls	r3, r3, #8
 80115f2:	b21b      	sxth	r3, r3
 80115f4:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
 80115f8:	f023 0307 	bic.w	r3, r3, #7
 80115fc:	b21a      	sxth	r2, r3
 80115fe:	687b      	ldr	r3, [r7, #4]
 8011600:	3301      	adds	r3, #1
 8011602:	781b      	ldrb	r3, [r3, #0]
 8011604:	00db      	lsls	r3, r3, #3
 8011606:	b21b      	sxth	r3, r3
 8011608:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
 801160c:	b21b      	sxth	r3, r3
 801160e:	4313      	orrs	r3, r2
 8011610:	b21b      	sxth	r3, r3
 8011612:	b29b      	uxth	r3, r3
 8011614:	687a      	ldr	r2, [r7, #4]
 8011616:	7812      	ldrb	r2, [r2, #0]
 8011618:	08d2      	lsrs	r2, r2, #3
 801161a:	b2d2      	uxtb	r2, r2
 801161c:	4413      	add	r3, r2
 801161e:	b29b      	uxth	r3, r3
 8011620:	e048      	b.n	80116b4 <lv_color_24_16_mix+0xea>
    }
    else {
        lv_opa_t mix_inv = 255 - mix;
 8011622:	787b      	ldrb	r3, [r7, #1]
 8011624:	43db      	mvns	r3, r3
 8011626:	73fb      	strb	r3, [r7, #15]

        return ((((c1[2] >> 3) * mix + ((c2 >> 11) & 0x1F) * mix_inv) << 3) & 0xF800) +
 8011628:	687b      	ldr	r3, [r7, #4]
 801162a:	3302      	adds	r3, #2
 801162c:	781b      	ldrb	r3, [r3, #0]
 801162e:	08db      	lsrs	r3, r3, #3
 8011630:	b2db      	uxtb	r3, r3
 8011632:	461a      	mov	r2, r3
 8011634:	787b      	ldrb	r3, [r7, #1]
 8011636:	fb03 f202 	mul.w	r2, r3, r2
 801163a:	887b      	ldrh	r3, [r7, #2]
 801163c:	0adb      	lsrs	r3, r3, #11
 801163e:	b29b      	uxth	r3, r3
 8011640:	f003 031f 	and.w	r3, r3, #31
 8011644:	7bf9      	ldrb	r1, [r7, #15]
 8011646:	fb01 f303 	mul.w	r3, r1, r3
 801164a:	4413      	add	r3, r2
 801164c:	00db      	lsls	r3, r3, #3
 801164e:	b21b      	sxth	r3, r3
 8011650:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
 8011654:	f023 0307 	bic.w	r3, r3, #7
 8011658:	b21a      	sxth	r2, r3
               ((((c1[1] >> 2) * mix + ((c2 >> 5) & 0x3F) * mix_inv) >> 3) & 0x07E0) +
 801165a:	687b      	ldr	r3, [r7, #4]
 801165c:	3301      	adds	r3, #1
 801165e:	781b      	ldrb	r3, [r3, #0]
 8011660:	089b      	lsrs	r3, r3, #2
 8011662:	b2db      	uxtb	r3, r3
 8011664:	4619      	mov	r1, r3
 8011666:	787b      	ldrb	r3, [r7, #1]
 8011668:	fb03 f101 	mul.w	r1, r3, r1
 801166c:	887b      	ldrh	r3, [r7, #2]
 801166e:	095b      	lsrs	r3, r3, #5
 8011670:	b29b      	uxth	r3, r3
 8011672:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8011676:	7bf8      	ldrb	r0, [r7, #15]
 8011678:	fb00 f303 	mul.w	r3, r0, r3
 801167c:	440b      	add	r3, r1
 801167e:	10db      	asrs	r3, r3, #3
 8011680:	b21b      	sxth	r3, r3
 8011682:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
 8011686:	b21b      	sxth	r3, r3
        return ((((c1[2] >> 3) * mix + ((c2 >> 11) & 0x1F) * mix_inv) << 3) & 0xF800) +
 8011688:	4313      	orrs	r3, r2
 801168a:	b21b      	sxth	r3, r3
 801168c:	b29a      	uxth	r2, r3
               (((c1[0] >> 3) * mix + (c2 & 0x1F) * mix_inv) >> 8);
 801168e:	687b      	ldr	r3, [r7, #4]
 8011690:	781b      	ldrb	r3, [r3, #0]
 8011692:	08db      	lsrs	r3, r3, #3
 8011694:	b2db      	uxtb	r3, r3
 8011696:	4619      	mov	r1, r3
 8011698:	787b      	ldrb	r3, [r7, #1]
 801169a:	fb03 f101 	mul.w	r1, r3, r1
 801169e:	887b      	ldrh	r3, [r7, #2]
 80116a0:	f003 031f 	and.w	r3, r3, #31
 80116a4:	7bf8      	ldrb	r0, [r7, #15]
 80116a6:	fb00 f303 	mul.w	r3, r0, r3
 80116aa:	440b      	add	r3, r1
 80116ac:	121b      	asrs	r3, r3, #8
               ((((c1[1] >> 2) * mix + ((c2 >> 5) & 0x3F) * mix_inv) >> 3) & 0x07E0) +
 80116ae:	b29b      	uxth	r3, r3
 80116b0:	4413      	add	r3, r2
 80116b2:	b29b      	uxth	r3, r3
    }
}
 80116b4:	4618      	mov	r0, r3
 80116b6:	3714      	adds	r7, #20
 80116b8:	46bd      	mov	sp, r7
 80116ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80116be:	4770      	bx	lr

080116c0 <drawbuf_next_row>:

static inline void * LV_ATTRIBUTE_FAST_MEM drawbuf_next_row(const void * buf, uint32_t stride)
{
 80116c0:	b480      	push	{r7}
 80116c2:	b083      	sub	sp, #12
 80116c4:	af00      	add	r7, sp, #0
 80116c6:	6078      	str	r0, [r7, #4]
 80116c8:	6039      	str	r1, [r7, #0]
    return (void *)((uint8_t *)buf + stride);
 80116ca:	687a      	ldr	r2, [r7, #4]
 80116cc:	683b      	ldr	r3, [r7, #0]
 80116ce:	4413      	add	r3, r2
}
 80116d0:	4618      	mov	r0, r3
 80116d2:	370c      	adds	r7, #12
 80116d4:	46bd      	mov	sp, r7
 80116d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80116da:	4770      	bx	lr

080116dc <lv_draw_sw_blend_color_to_rgb888>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void LV_ATTRIBUTE_FAST_MEM lv_draw_sw_blend_color_to_rgb888(_lv_draw_sw_blend_fill_dsc_t * dsc, uint32_t dest_px_size)
{
 80116dc:	b580      	push	{r7, lr}
 80116de:	b096      	sub	sp, #88	@ 0x58
 80116e0:	af00      	add	r7, sp, #0
 80116e2:	6078      	str	r0, [r7, #4]
 80116e4:	6039      	str	r1, [r7, #0]
    int32_t w = dsc->dest_w;
 80116e6:	687b      	ldr	r3, [r7, #4]
 80116e8:	685b      	ldr	r3, [r3, #4]
 80116ea:	657b      	str	r3, [r7, #84]	@ 0x54
    int32_t h = dsc->dest_h;
 80116ec:	687b      	ldr	r3, [r7, #4]
 80116ee:	689b      	ldr	r3, [r3, #8]
 80116f0:	62bb      	str	r3, [r7, #40]	@ 0x28
    lv_opa_t opa = dsc->opa;
 80116f2:	687b      	ldr	r3, [r7, #4]
 80116f4:	7edb      	ldrb	r3, [r3, #27]
 80116f6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    const lv_opa_t * mask = dsc->mask_buf;
 80116fa:	687b      	ldr	r3, [r7, #4]
 80116fc:	691b      	ldr	r3, [r3, #16]
 80116fe:	653b      	str	r3, [r7, #80]	@ 0x50
    int32_t mask_stride = dsc->mask_stride;
 8011700:	687b      	ldr	r3, [r7, #4]
 8011702:	695b      	ldr	r3, [r3, #20]
 8011704:	623b      	str	r3, [r7, #32]
    int32_t dest_stride = dsc->dest_stride;
 8011706:	687b      	ldr	r3, [r7, #4]
 8011708:	68db      	ldr	r3, [r3, #12]
 801170a:	61fb      	str	r3, [r7, #28]
    LV_UNUSED(mask);
    LV_UNUSED(mask_stride);
    LV_UNUSED(dest_stride);

    /*Simple fill*/
    if(mask == NULL && opa >= LV_OPA_MAX) {
 801170c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801170e:	2b00      	cmp	r3, #0
 8011710:	f040 80ef 	bne.w	80118f2 <lv_draw_sw_blend_color_to_rgb888+0x216>
 8011714:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011718:	2bfc      	cmp	r3, #252	@ 0xfc
 801171a:	f240 80ea 	bls.w	80118f2 <lv_draw_sw_blend_color_to_rgb888+0x216>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB888(dsc, dest_px_size)) {
            if(dest_px_size == 3) {
 801171e:	683b      	ldr	r3, [r7, #0]
 8011720:	2b03      	cmp	r3, #3
 8011722:	d140      	bne.n	80117a6 <lv_draw_sw_blend_color_to_rgb888+0xca>
                uint8_t * dest_buf_u8 = dsc->dest_buf;
 8011724:	687b      	ldr	r3, [r7, #4]
 8011726:	681b      	ldr	r3, [r3, #0]
 8011728:	647b      	str	r3, [r7, #68]	@ 0x44
                uint8_t * dest_buf_ori = dsc->dest_buf;
 801172a:	687b      	ldr	r3, [r7, #4]
 801172c:	681b      	ldr	r3, [r3, #0]
 801172e:	61bb      	str	r3, [r7, #24]
                w *= dest_px_size;
 8011730:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8011732:	683a      	ldr	r2, [r7, #0]
 8011734:	fb02 f303 	mul.w	r3, r2, r3
 8011738:	657b      	str	r3, [r7, #84]	@ 0x54

                for(x = 0; x < w; x += 3) {
 801173a:	2300      	movs	r3, #0
 801173c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801173e:	e016      	b.n	801176e <lv_draw_sw_blend_color_to_rgb888+0x92>
                    dest_buf_u8[x + 0] = dsc->color.blue;
 8011740:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8011742:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011744:	4413      	add	r3, r2
 8011746:	687a      	ldr	r2, [r7, #4]
 8011748:	7e12      	ldrb	r2, [r2, #24]
 801174a:	701a      	strb	r2, [r3, #0]
                    dest_buf_u8[x + 1] = dsc->color.green;
 801174c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801174e:	3301      	adds	r3, #1
 8011750:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011752:	4413      	add	r3, r2
 8011754:	687a      	ldr	r2, [r7, #4]
 8011756:	7e52      	ldrb	r2, [r2, #25]
 8011758:	701a      	strb	r2, [r3, #0]
                    dest_buf_u8[x + 2] = dsc->color.red;
 801175a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801175c:	3302      	adds	r3, #2
 801175e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011760:	4413      	add	r3, r2
 8011762:	687a      	ldr	r2, [r7, #4]
 8011764:	7e92      	ldrb	r2, [r2, #26]
 8011766:	701a      	strb	r2, [r3, #0]
                for(x = 0; x < w; x += 3) {
 8011768:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801176a:	3303      	adds	r3, #3
 801176c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801176e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8011770:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8011772:	429a      	cmp	r2, r3
 8011774:	dbe4      	blt.n	8011740 <lv_draw_sw_blend_color_to_rgb888+0x64>
                }

                dest_buf_u8 += dest_stride;
 8011776:	69fb      	ldr	r3, [r7, #28]
 8011778:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801177a:	4413      	add	r3, r2
 801177c:	647b      	str	r3, [r7, #68]	@ 0x44

                for(y = 1; y < h; y++) {
 801177e:	2301      	movs	r3, #1
 8011780:	64bb      	str	r3, [r7, #72]	@ 0x48
 8011782:	e00c      	b.n	801179e <lv_draw_sw_blend_color_to_rgb888+0xc2>
                    lv_memcpy(dest_buf_u8, dest_buf_ori, w);
 8011784:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8011786:	461a      	mov	r2, r3
 8011788:	69b9      	ldr	r1, [r7, #24]
 801178a:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801178c:	f013 f92c 	bl	80249e8 <lv_memcpy>
                    dest_buf_u8 += dest_stride;
 8011790:	69fb      	ldr	r3, [r7, #28]
 8011792:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011794:	4413      	add	r3, r2
 8011796:	647b      	str	r3, [r7, #68]	@ 0x44
                for(y = 1; y < h; y++) {
 8011798:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801179a:	3301      	adds	r3, #1
 801179c:	64bb      	str	r3, [r7, #72]	@ 0x48
 801179e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80117a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80117a2:	429a      	cmp	r2, r3
 80117a4:	dbee      	blt.n	8011784 <lv_draw_sw_blend_color_to_rgb888+0xa8>
                }
            }
            if(dest_px_size == 4) {
 80117a6:	683b      	ldr	r3, [r7, #0]
 80117a8:	2b04      	cmp	r3, #4
 80117aa:	f040 8165 	bne.w	8011a78 <lv_draw_sw_blend_color_to_rgb888+0x39c>
                uint32_t color32 = lv_color_to_u32(dsc->color);
 80117ae:	687b      	ldr	r3, [r7, #4]
 80117b0:	6998      	ldr	r0, [r3, #24]
 80117b2:	f010 ff50 	bl	8022656 <lv_color_to_u32>
 80117b6:	6178      	str	r0, [r7, #20]
                uint32_t * dest_buf_u32 = dsc->dest_buf;
 80117b8:	687b      	ldr	r3, [r7, #4]
 80117ba:	681b      	ldr	r3, [r3, #0]
 80117bc:	643b      	str	r3, [r7, #64]	@ 0x40
                for(y = 0; y < h; y++) {
 80117be:	2300      	movs	r3, #0
 80117c0:	64bb      	str	r3, [r7, #72]	@ 0x48
 80117c2:	e090      	b.n	80118e6 <lv_draw_sw_blend_color_to_rgb888+0x20a>
                    for(x = 0; x <= w - 16; x += 16) {
 80117c4:	2300      	movs	r3, #0
 80117c6:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80117c8:	e071      	b.n	80118ae <lv_draw_sw_blend_color_to_rgb888+0x1d2>
                        dest_buf_u32[x + 0] = color32;
 80117ca:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80117cc:	009b      	lsls	r3, r3, #2
 80117ce:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80117d0:	4413      	add	r3, r2
 80117d2:	697a      	ldr	r2, [r7, #20]
 80117d4:	601a      	str	r2, [r3, #0]
                        dest_buf_u32[x + 1] = color32;
 80117d6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80117d8:	3301      	adds	r3, #1
 80117da:	009b      	lsls	r3, r3, #2
 80117dc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80117de:	4413      	add	r3, r2
 80117e0:	697a      	ldr	r2, [r7, #20]
 80117e2:	601a      	str	r2, [r3, #0]
                        dest_buf_u32[x + 2] = color32;
 80117e4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80117e6:	3302      	adds	r3, #2
 80117e8:	009b      	lsls	r3, r3, #2
 80117ea:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80117ec:	4413      	add	r3, r2
 80117ee:	697a      	ldr	r2, [r7, #20]
 80117f0:	601a      	str	r2, [r3, #0]
                        dest_buf_u32[x + 3] = color32;
 80117f2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80117f4:	3303      	adds	r3, #3
 80117f6:	009b      	lsls	r3, r3, #2
 80117f8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80117fa:	4413      	add	r3, r2
 80117fc:	697a      	ldr	r2, [r7, #20]
 80117fe:	601a      	str	r2, [r3, #0]

                        dest_buf_u32[x + 4] = color32;
 8011800:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8011802:	3304      	adds	r3, #4
 8011804:	009b      	lsls	r3, r3, #2
 8011806:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011808:	4413      	add	r3, r2
 801180a:	697a      	ldr	r2, [r7, #20]
 801180c:	601a      	str	r2, [r3, #0]
                        dest_buf_u32[x + 5] = color32;
 801180e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8011810:	3305      	adds	r3, #5
 8011812:	009b      	lsls	r3, r3, #2
 8011814:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011816:	4413      	add	r3, r2
 8011818:	697a      	ldr	r2, [r7, #20]
 801181a:	601a      	str	r2, [r3, #0]
                        dest_buf_u32[x + 6] = color32;
 801181c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801181e:	3306      	adds	r3, #6
 8011820:	009b      	lsls	r3, r3, #2
 8011822:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011824:	4413      	add	r3, r2
 8011826:	697a      	ldr	r2, [r7, #20]
 8011828:	601a      	str	r2, [r3, #0]
                        dest_buf_u32[x + 7] = color32;
 801182a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801182c:	3307      	adds	r3, #7
 801182e:	009b      	lsls	r3, r3, #2
 8011830:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011832:	4413      	add	r3, r2
 8011834:	697a      	ldr	r2, [r7, #20]
 8011836:	601a      	str	r2, [r3, #0]

                        dest_buf_u32[x + 8] = color32;
 8011838:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801183a:	3308      	adds	r3, #8
 801183c:	009b      	lsls	r3, r3, #2
 801183e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011840:	4413      	add	r3, r2
 8011842:	697a      	ldr	r2, [r7, #20]
 8011844:	601a      	str	r2, [r3, #0]
                        dest_buf_u32[x + 9] = color32;
 8011846:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8011848:	3309      	adds	r3, #9
 801184a:	009b      	lsls	r3, r3, #2
 801184c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801184e:	4413      	add	r3, r2
 8011850:	697a      	ldr	r2, [r7, #20]
 8011852:	601a      	str	r2, [r3, #0]
                        dest_buf_u32[x + 10] = color32;
 8011854:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8011856:	330a      	adds	r3, #10
 8011858:	009b      	lsls	r3, r3, #2
 801185a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801185c:	4413      	add	r3, r2
 801185e:	697a      	ldr	r2, [r7, #20]
 8011860:	601a      	str	r2, [r3, #0]
                        dest_buf_u32[x + 11] = color32;
 8011862:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8011864:	330b      	adds	r3, #11
 8011866:	009b      	lsls	r3, r3, #2
 8011868:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801186a:	4413      	add	r3, r2
 801186c:	697a      	ldr	r2, [r7, #20]
 801186e:	601a      	str	r2, [r3, #0]

                        dest_buf_u32[x + 12] = color32;
 8011870:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8011872:	330c      	adds	r3, #12
 8011874:	009b      	lsls	r3, r3, #2
 8011876:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011878:	4413      	add	r3, r2
 801187a:	697a      	ldr	r2, [r7, #20]
 801187c:	601a      	str	r2, [r3, #0]
                        dest_buf_u32[x + 13] = color32;
 801187e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8011880:	330d      	adds	r3, #13
 8011882:	009b      	lsls	r3, r3, #2
 8011884:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011886:	4413      	add	r3, r2
 8011888:	697a      	ldr	r2, [r7, #20]
 801188a:	601a      	str	r2, [r3, #0]
                        dest_buf_u32[x + 14] = color32;
 801188c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801188e:	330e      	adds	r3, #14
 8011890:	009b      	lsls	r3, r3, #2
 8011892:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011894:	4413      	add	r3, r2
 8011896:	697a      	ldr	r2, [r7, #20]
 8011898:	601a      	str	r2, [r3, #0]
                        dest_buf_u32[x + 15] = color32;
 801189a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801189c:	330f      	adds	r3, #15
 801189e:	009b      	lsls	r3, r3, #2
 80118a0:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80118a2:	4413      	add	r3, r2
 80118a4:	697a      	ldr	r2, [r7, #20]
 80118a6:	601a      	str	r2, [r3, #0]
                    for(x = 0; x <= w - 16; x += 16) {
 80118a8:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80118aa:	3310      	adds	r3, #16
 80118ac:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80118ae:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80118b0:	3b0f      	subs	r3, #15
 80118b2:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80118b4:	429a      	cmp	r2, r3
 80118b6:	db88      	blt.n	80117ca <lv_draw_sw_blend_color_to_rgb888+0xee>
                    }
                    for(; x < w; x ++) {
 80118b8:	e008      	b.n	80118cc <lv_draw_sw_blend_color_to_rgb888+0x1f0>
                        dest_buf_u32[x] = color32;
 80118ba:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80118bc:	009b      	lsls	r3, r3, #2
 80118be:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80118c0:	4413      	add	r3, r2
 80118c2:	697a      	ldr	r2, [r7, #20]
 80118c4:	601a      	str	r2, [r3, #0]
                    for(; x < w; x ++) {
 80118c6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80118c8:	3301      	adds	r3, #1
 80118ca:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80118cc:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80118ce:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80118d0:	429a      	cmp	r2, r3
 80118d2:	dbf2      	blt.n	80118ba <lv_draw_sw_blend_color_to_rgb888+0x1de>
                    }

                    dest_buf_u32 = drawbuf_next_row(dest_buf_u32, dest_stride);
 80118d4:	69fb      	ldr	r3, [r7, #28]
 80118d6:	4619      	mov	r1, r3
 80118d8:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 80118da:	f000 ff72 	bl	80127c2 <drawbuf_next_row>
 80118de:	6438      	str	r0, [r7, #64]	@ 0x40
                for(y = 0; y < h; y++) {
 80118e0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80118e2:	3301      	adds	r3, #1
 80118e4:	64bb      	str	r3, [r7, #72]	@ 0x48
 80118e6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80118e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80118ea:	429a      	cmp	r2, r3
 80118ec:	f6ff af6a 	blt.w	80117c4 <lv_draw_sw_blend_color_to_rgb888+0xe8>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB888(dsc, dest_px_size)) {
 80118f0:	e0c2      	b.n	8011a78 <lv_draw_sw_blend_color_to_rgb888+0x39c>
                }
            }
        }
    }
    /*Opacity only*/
    else if(mask == NULL && opa < LV_OPA_MAX) {
 80118f2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80118f4:	2b00      	cmp	r3, #0
 80118f6:	d137      	bne.n	8011968 <lv_draw_sw_blend_color_to_rgb888+0x28c>
 80118f8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80118fc:	2bfc      	cmp	r3, #252	@ 0xfc
 80118fe:	d833      	bhi.n	8011968 <lv_draw_sw_blend_color_to_rgb888+0x28c>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB888_WITH_OPA(dsc, dest_px_size)) {
            uint32_t color32 = lv_color_to_u32(dsc->color);
 8011900:	687b      	ldr	r3, [r7, #4]
 8011902:	6998      	ldr	r0, [r3, #24]
 8011904:	f010 fea7 	bl	8022656 <lv_color_to_u32>
 8011908:	4603      	mov	r3, r0
 801190a:	613b      	str	r3, [r7, #16]
            uint8_t * dest_buf = dsc->dest_buf;
 801190c:	687b      	ldr	r3, [r7, #4]
 801190e:	681b      	ldr	r3, [r3, #0]
 8011910:	63fb      	str	r3, [r7, #60]	@ 0x3c
            w *= dest_px_size;
 8011912:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8011914:	683a      	ldr	r2, [r7, #0]
 8011916:	fb02 f303 	mul.w	r3, r2, r3
 801191a:	657b      	str	r3, [r7, #84]	@ 0x54
            for(y = 0; y < h; y++) {
 801191c:	2300      	movs	r3, #0
 801191e:	64bb      	str	r3, [r7, #72]	@ 0x48
 8011920:	e01d      	b.n	801195e <lv_draw_sw_blend_color_to_rgb888+0x282>
                for(x = 0; x < w; x += dest_px_size) {
 8011922:	2300      	movs	r3, #0
 8011924:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8011926:	e00d      	b.n	8011944 <lv_draw_sw_blend_color_to_rgb888+0x268>
                    lv_color_24_24_mix((const uint8_t *)&color32, &dest_buf[x], opa);
 8011928:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801192a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801192c:	18d1      	adds	r1, r2, r3
 801192e:	f897 2027 	ldrb.w	r2, [r7, #39]	@ 0x27
 8011932:	f107 0310 	add.w	r3, r7, #16
 8011936:	4618      	mov	r0, r3
 8011938:	f000 fee2 	bl	8012700 <lv_color_24_24_mix>
                for(x = 0; x < w; x += dest_px_size) {
 801193c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801193e:	683b      	ldr	r3, [r7, #0]
 8011940:	4413      	add	r3, r2
 8011942:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8011944:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8011946:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8011948:	429a      	cmp	r2, r3
 801194a:	dbed      	blt.n	8011928 <lv_draw_sw_blend_color_to_rgb888+0x24c>
                }

                dest_buf = drawbuf_next_row(dest_buf, dest_stride);
 801194c:	69fb      	ldr	r3, [r7, #28]
 801194e:	4619      	mov	r1, r3
 8011950:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8011952:	f000 ff36 	bl	80127c2 <drawbuf_next_row>
 8011956:	63f8      	str	r0, [r7, #60]	@ 0x3c
            for(y = 0; y < h; y++) {
 8011958:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801195a:	3301      	adds	r3, #1
 801195c:	64bb      	str	r3, [r7, #72]	@ 0x48
 801195e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8011960:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011962:	429a      	cmp	r2, r3
 8011964:	dbdd      	blt.n	8011922 <lv_draw_sw_blend_color_to_rgb888+0x246>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB888_WITH_OPA(dsc, dest_px_size)) {
 8011966:	e088      	b.n	8011a7a <lv_draw_sw_blend_color_to_rgb888+0x39e>
            }
        }
    }
    /*Masked with full opacity*/
    else if(mask && opa >= LV_OPA_MAX) {
 8011968:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801196a:	2b00      	cmp	r3, #0
 801196c:	d040      	beq.n	80119f0 <lv_draw_sw_blend_color_to_rgb888+0x314>
 801196e:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011972:	2bfc      	cmp	r3, #252	@ 0xfc
 8011974:	d93c      	bls.n	80119f0 <lv_draw_sw_blend_color_to_rgb888+0x314>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB888_WITH_MASK(dsc, dest_px_size)) {
            uint32_t color32 = lv_color_to_u32(dsc->color);
 8011976:	687b      	ldr	r3, [r7, #4]
 8011978:	6998      	ldr	r0, [r3, #24]
 801197a:	f010 fe6c 	bl	8022656 <lv_color_to_u32>
 801197e:	4603      	mov	r3, r0
 8011980:	60fb      	str	r3, [r7, #12]
            uint8_t * dest_buf = dsc->dest_buf;
 8011982:	687b      	ldr	r3, [r7, #4]
 8011984:	681b      	ldr	r3, [r3, #0]
 8011986:	63bb      	str	r3, [r7, #56]	@ 0x38
            w *= dest_px_size;
 8011988:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801198a:	683a      	ldr	r2, [r7, #0]
 801198c:	fb02 f303 	mul.w	r3, r2, r3
 8011990:	657b      	str	r3, [r7, #84]	@ 0x54

            for(y = 0; y < h; y++) {
 8011992:	2300      	movs	r3, #0
 8011994:	64bb      	str	r3, [r7, #72]	@ 0x48
 8011996:	e026      	b.n	80119e6 <lv_draw_sw_blend_color_to_rgb888+0x30a>
                uint32_t mask_x;
                for(x = 0, mask_x = 0; x < w; x += dest_px_size, mask_x++) {
 8011998:	2300      	movs	r3, #0
 801199a:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801199c:	2300      	movs	r3, #0
 801199e:	637b      	str	r3, [r7, #52]	@ 0x34
 80119a0:	e012      	b.n	80119c8 <lv_draw_sw_blend_color_to_rgb888+0x2ec>
                    lv_color_24_24_mix((const uint8_t *)&color32, &dest_buf[x], mask[mask_x]);
 80119a2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80119a4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80119a6:	18d1      	adds	r1, r2, r3
 80119a8:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 80119aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80119ac:	4413      	add	r3, r2
 80119ae:	781a      	ldrb	r2, [r3, #0]
 80119b0:	f107 030c 	add.w	r3, r7, #12
 80119b4:	4618      	mov	r0, r3
 80119b6:	f000 fea3 	bl	8012700 <lv_color_24_24_mix>
                for(x = 0, mask_x = 0; x < w; x += dest_px_size, mask_x++) {
 80119ba:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80119bc:	683b      	ldr	r3, [r7, #0]
 80119be:	4413      	add	r3, r2
 80119c0:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80119c2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80119c4:	3301      	adds	r3, #1
 80119c6:	637b      	str	r3, [r7, #52]	@ 0x34
 80119c8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80119ca:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80119cc:	429a      	cmp	r2, r3
 80119ce:	dbe8      	blt.n	80119a2 <lv_draw_sw_blend_color_to_rgb888+0x2c6>
                }
                dest_buf += dest_stride;
 80119d0:	69fb      	ldr	r3, [r7, #28]
 80119d2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80119d4:	4413      	add	r3, r2
 80119d6:	63bb      	str	r3, [r7, #56]	@ 0x38
                mask += mask_stride;
 80119d8:	6a3b      	ldr	r3, [r7, #32]
 80119da:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 80119dc:	4413      	add	r3, r2
 80119de:	653b      	str	r3, [r7, #80]	@ 0x50
            for(y = 0; y < h; y++) {
 80119e0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80119e2:	3301      	adds	r3, #1
 80119e4:	64bb      	str	r3, [r7, #72]	@ 0x48
 80119e6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80119e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80119ea:	429a      	cmp	r2, r3
 80119ec:	dbd4      	blt.n	8011998 <lv_draw_sw_blend_color_to_rgb888+0x2bc>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB888_WITH_MASK(dsc, dest_px_size)) {
 80119ee:	e044      	b.n	8011a7a <lv_draw_sw_blend_color_to_rgb888+0x39e>
        }
    }
    /*Masked with opacity*/
    else {
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB888_MIX_MASK_OPA(dsc, dest_px_size)) {
            uint32_t color32 = lv_color_to_u32(dsc->color);
 80119f0:	687b      	ldr	r3, [r7, #4]
 80119f2:	6998      	ldr	r0, [r3, #24]
 80119f4:	f010 fe2f 	bl	8022656 <lv_color_to_u32>
 80119f8:	4603      	mov	r3, r0
 80119fa:	60bb      	str	r3, [r7, #8]
            uint8_t * dest_buf = dsc->dest_buf;
 80119fc:	687b      	ldr	r3, [r7, #4]
 80119fe:	681b      	ldr	r3, [r3, #0]
 8011a00:	633b      	str	r3, [r7, #48]	@ 0x30
            w *= dest_px_size;
 8011a02:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8011a04:	683a      	ldr	r2, [r7, #0]
 8011a06:	fb02 f303 	mul.w	r3, r2, r3
 8011a0a:	657b      	str	r3, [r7, #84]	@ 0x54

            for(y = 0; y < h; y++) {
 8011a0c:	2300      	movs	r3, #0
 8011a0e:	64bb      	str	r3, [r7, #72]	@ 0x48
 8011a10:	e02d      	b.n	8011a6e <lv_draw_sw_blend_color_to_rgb888+0x392>
                uint32_t mask_x;
                for(x = 0, mask_x = 0; x < w; x += dest_px_size, mask_x++) {
 8011a12:	2300      	movs	r3, #0
 8011a14:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8011a16:	2300      	movs	r3, #0
 8011a18:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011a1a:	e019      	b.n	8011a50 <lv_draw_sw_blend_color_to_rgb888+0x374>
                    lv_color_24_24_mix((const uint8_t *) &color32, &dest_buf[x], LV_OPA_MIX2(opa, mask[mask_x]));
 8011a1c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8011a1e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011a20:	18d0      	adds	r0, r2, r3
 8011a22:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011a26:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8011a28:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8011a2a:	440a      	add	r2, r1
 8011a2c:	7812      	ldrb	r2, [r2, #0]
 8011a2e:	fb02 f303 	mul.w	r3, r2, r3
 8011a32:	121b      	asrs	r3, r3, #8
 8011a34:	b2da      	uxtb	r2, r3
 8011a36:	f107 0308 	add.w	r3, r7, #8
 8011a3a:	4601      	mov	r1, r0
 8011a3c:	4618      	mov	r0, r3
 8011a3e:	f000 fe5f 	bl	8012700 <lv_color_24_24_mix>
                for(x = 0, mask_x = 0; x < w; x += dest_px_size, mask_x++) {
 8011a42:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8011a44:	683b      	ldr	r3, [r7, #0]
 8011a46:	4413      	add	r3, r2
 8011a48:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8011a4a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011a4c:	3301      	adds	r3, #1
 8011a4e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8011a50:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8011a52:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8011a54:	429a      	cmp	r2, r3
 8011a56:	dbe1      	blt.n	8011a1c <lv_draw_sw_blend_color_to_rgb888+0x340>
                }
                dest_buf += dest_stride;
 8011a58:	69fb      	ldr	r3, [r7, #28]
 8011a5a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011a5c:	4413      	add	r3, r2
 8011a5e:	633b      	str	r3, [r7, #48]	@ 0x30
                mask += mask_stride;
 8011a60:	6a3b      	ldr	r3, [r7, #32]
 8011a62:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8011a64:	4413      	add	r3, r2
 8011a66:	653b      	str	r3, [r7, #80]	@ 0x50
            for(y = 0; y < h; y++) {
 8011a68:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8011a6a:	3301      	adds	r3, #1
 8011a6c:	64bb      	str	r3, [r7, #72]	@ 0x48
 8011a6e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8011a70:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011a72:	429a      	cmp	r2, r3
 8011a74:	dbcd      	blt.n	8011a12 <lv_draw_sw_blend_color_to_rgb888+0x336>
            }
        }
    }
}
 8011a76:	e000      	b.n	8011a7a <lv_draw_sw_blend_color_to_rgb888+0x39e>
        if(LV_RESULT_INVALID == LV_DRAW_SW_COLOR_BLEND_TO_RGB888(dsc, dest_px_size)) {
 8011a78:	bf00      	nop
}
 8011a7a:	bf00      	nop
 8011a7c:	3758      	adds	r7, #88	@ 0x58
 8011a7e:	46bd      	mov	sp, r7
 8011a80:	bd80      	pop	{r7, pc}
	...

08011a84 <lv_draw_sw_blend_image_to_rgb888>:

void LV_ATTRIBUTE_FAST_MEM lv_draw_sw_blend_image_to_rgb888(_lv_draw_sw_blend_image_dsc_t * dsc, uint32_t dest_px_size)
{
 8011a84:	b580      	push	{r7, lr}
 8011a86:	b082      	sub	sp, #8
 8011a88:	af00      	add	r7, sp, #0
 8011a8a:	6078      	str	r0, [r7, #4]
 8011a8c:	6039      	str	r1, [r7, #0]

    switch(dsc->src_color_format) {
 8011a8e:	687b      	ldr	r3, [r7, #4]
 8011a90:	f893 3020 	ldrb.w	r3, [r3, #32]
 8011a94:	3b0f      	subs	r3, #15
 8011a96:	2b03      	cmp	r3, #3
 8011a98:	d824      	bhi.n	8011ae4 <lv_draw_sw_blend_image_to_rgb888+0x60>
 8011a9a:	a201      	add	r2, pc, #4	@ (adr r2, 8011aa0 <lv_draw_sw_blend_image_to_rgb888+0x1c>)
 8011a9c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011aa0:	08011abb 	.word	0x08011abb
 8011aa4:	08011adb 	.word	0x08011adb
 8011aa8:	08011acb 	.word	0x08011acb
 8011aac:	08011ab1 	.word	0x08011ab1
        case LV_COLOR_FORMAT_RGB565:
            rgb565_image_blend(dsc, dest_px_size);
 8011ab0:	6839      	ldr	r1, [r7, #0]
 8011ab2:	6878      	ldr	r0, [r7, #4]
 8011ab4:	f000 f81c 	bl	8011af0 <rgb565_image_blend>
            break;
 8011ab8:	e015      	b.n	8011ae6 <lv_draw_sw_blend_image_to_rgb888+0x62>
        case LV_COLOR_FORMAT_RGB888:
            rgb888_image_blend(dsc, dest_px_size, 3);
 8011aba:	683b      	ldr	r3, [r7, #0]
 8011abc:	b2db      	uxtb	r3, r3
 8011abe:	2203      	movs	r2, #3
 8011ac0:	4619      	mov	r1, r3
 8011ac2:	6878      	ldr	r0, [r7, #4]
 8011ac4:	f000 fa5e 	bl	8011f84 <rgb888_image_blend>
            break;
 8011ac8:	e00d      	b.n	8011ae6 <lv_draw_sw_blend_image_to_rgb888+0x62>
        case LV_COLOR_FORMAT_XRGB8888:
            rgb888_image_blend(dsc, dest_px_size, 4);
 8011aca:	683b      	ldr	r3, [r7, #0]
 8011acc:	b2db      	uxtb	r3, r3
 8011ace:	2204      	movs	r2, #4
 8011ad0:	4619      	mov	r1, r3
 8011ad2:	6878      	ldr	r0, [r7, #4]
 8011ad4:	f000 fa56 	bl	8011f84 <rgb888_image_blend>
            break;
 8011ad8:	e005      	b.n	8011ae6 <lv_draw_sw_blend_image_to_rgb888+0x62>
        case LV_COLOR_FORMAT_ARGB8888:
            argb8888_image_blend(dsc, dest_px_size);
 8011ada:	6839      	ldr	r1, [r7, #0]
 8011adc:	6878      	ldr	r0, [r7, #4]
 8011ade:	f000 fbfc 	bl	80122da <argb8888_image_blend>
            break;
 8011ae2:	e000      	b.n	8011ae6 <lv_draw_sw_blend_image_to_rgb888+0x62>
        default:
            LV_LOG_WARN("Not supported source color format");
            break;
 8011ae4:	bf00      	nop
    }
}
 8011ae6:	bf00      	nop
 8011ae8:	3708      	adds	r7, #8
 8011aea:	46bd      	mov	sp, r7
 8011aec:	bd80      	pop	{r7, pc}
 8011aee:	bf00      	nop

08011af0 <rgb565_image_blend>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void LV_ATTRIBUTE_FAST_MEM rgb565_image_blend(_lv_draw_sw_blend_image_dsc_t * dsc, uint32_t dest_px_size)
{
 8011af0:	b580      	push	{r7, lr}
 8011af2:	b092      	sub	sp, #72	@ 0x48
 8011af4:	af00      	add	r7, sp, #0
 8011af6:	6078      	str	r0, [r7, #4]
 8011af8:	6039      	str	r1, [r7, #0]
    int32_t w = dsc->dest_w;
 8011afa:	687b      	ldr	r3, [r7, #4]
 8011afc:	685b      	ldr	r3, [r3, #4]
 8011afe:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int32_t h = dsc->dest_h;
 8011b00:	687b      	ldr	r3, [r7, #4]
 8011b02:	689b      	ldr	r3, [r3, #8]
 8011b04:	62bb      	str	r3, [r7, #40]	@ 0x28
    lv_opa_t opa = dsc->opa;
 8011b06:	687b      	ldr	r3, [r7, #4]
 8011b08:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 8011b0c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    uint8_t * dest_buf_u8 = dsc->dest_buf;
 8011b10:	687b      	ldr	r3, [r7, #4]
 8011b12:	681b      	ldr	r3, [r3, #0]
 8011b14:	647b      	str	r3, [r7, #68]	@ 0x44
    int32_t dest_stride = dsc->dest_stride;
 8011b16:	687b      	ldr	r3, [r7, #4]
 8011b18:	68db      	ldr	r3, [r3, #12]
 8011b1a:	623b      	str	r3, [r7, #32]
    const lv_color16_t * src_buf_c16 = (const lv_color16_t *) dsc->src_buf;
 8011b1c:	687b      	ldr	r3, [r7, #4]
 8011b1e:	699b      	ldr	r3, [r3, #24]
 8011b20:	643b      	str	r3, [r7, #64]	@ 0x40
    int32_t src_stride = dsc->src_stride;
 8011b22:	687b      	ldr	r3, [r7, #4]
 8011b24:	69db      	ldr	r3, [r3, #28]
 8011b26:	61fb      	str	r3, [r7, #28]
    const lv_opa_t * mask_buf = dsc->mask_buf;
 8011b28:	687b      	ldr	r3, [r7, #4]
 8011b2a:	691b      	ldr	r3, [r3, #16]
 8011b2c:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int32_t mask_stride = dsc->mask_stride;
 8011b2e:	687b      	ldr	r3, [r7, #4]
 8011b30:	695b      	ldr	r3, [r3, #20]
 8011b32:	61bb      	str	r3, [r7, #24]

    int32_t src_x;
    int32_t dest_x;
    int32_t y;

    if(dsc->blend_mode == LV_BLEND_MODE_NORMAL) {
 8011b34:	687b      	ldr	r3, [r7, #4]
 8011b36:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 8011b3a:	2b00      	cmp	r3, #0
 8011b3c:	f040 81a5 	bne.w	8011e8a <rgb565_image_blend+0x39a>
        if(mask_buf == NULL && opa >= LV_OPA_MAX) {
 8011b40:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8011b42:	2b00      	cmp	r3, #0
 8011b44:	d163      	bne.n	8011c0e <rgb565_image_blend+0x11e>
 8011b46:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011b4a:	2bfc      	cmp	r3, #252	@ 0xfc
 8011b4c:	d95f      	bls.n	8011c0e <rgb565_image_blend+0x11e>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB888(dsc, dest_px_size)) {
                for(y = 0; y < h; y++) {
 8011b4e:	2300      	movs	r3, #0
 8011b50:	633b      	str	r3, [r7, #48]	@ 0x30
 8011b52:	e057      	b.n	8011c04 <rgb565_image_blend+0x114>
                    for(src_x = 0, dest_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 8011b54:	2300      	movs	r3, #0
 8011b56:	63bb      	str	r3, [r7, #56]	@ 0x38
 8011b58:	2300      	movs	r3, #0
 8011b5a:	637b      	str	r3, [r7, #52]	@ 0x34
 8011b5c:	e041      	b.n	8011be2 <rgb565_image_blend+0xf2>
                        dest_buf_u8[dest_x + 2] = (src_buf_c16[src_x].red * 2106) >> 8;  /*To make it rounded*/
 8011b5e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011b60:	005b      	lsls	r3, r3, #1
 8011b62:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011b64:	4413      	add	r3, r2
 8011b66:	785b      	ldrb	r3, [r3, #1]
 8011b68:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8011b6c:	b2db      	uxtb	r3, r3
 8011b6e:	461a      	mov	r2, r3
 8011b70:	f640 033a 	movw	r3, #2106	@ 0x83a
 8011b74:	fb02 f303 	mul.w	r3, r2, r3
 8011b78:	1219      	asrs	r1, r3, #8
 8011b7a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011b7c:	3302      	adds	r3, #2
 8011b7e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011b80:	4413      	add	r3, r2
 8011b82:	b2ca      	uxtb	r2, r1
 8011b84:	701a      	strb	r2, [r3, #0]
                        dest_buf_u8[dest_x + 1] = (src_buf_c16[src_x].green * 1037) >> 8;
 8011b86:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011b88:	005b      	lsls	r3, r3, #1
 8011b8a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011b8c:	4413      	add	r3, r2
 8011b8e:	881b      	ldrh	r3, [r3, #0]
 8011b90:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8011b94:	b2db      	uxtb	r3, r3
 8011b96:	461a      	mov	r2, r3
 8011b98:	f240 430d 	movw	r3, #1037	@ 0x40d
 8011b9c:	fb02 f303 	mul.w	r3, r2, r3
 8011ba0:	1219      	asrs	r1, r3, #8
 8011ba2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011ba4:	3301      	adds	r3, #1
 8011ba6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011ba8:	4413      	add	r3, r2
 8011baa:	b2ca      	uxtb	r2, r1
 8011bac:	701a      	strb	r2, [r3, #0]
                        dest_buf_u8[dest_x + 0] = (src_buf_c16[src_x].blue * 2106) >> 8;
 8011bae:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011bb0:	005b      	lsls	r3, r3, #1
 8011bb2:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011bb4:	4413      	add	r3, r2
 8011bb6:	781b      	ldrb	r3, [r3, #0]
 8011bb8:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8011bbc:	b2db      	uxtb	r3, r3
 8011bbe:	461a      	mov	r2, r3
 8011bc0:	f640 033a 	movw	r3, #2106	@ 0x83a
 8011bc4:	fb02 f303 	mul.w	r3, r2, r3
 8011bc8:	1219      	asrs	r1, r3, #8
 8011bca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011bcc:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011bce:	4413      	add	r3, r2
 8011bd0:	b2ca      	uxtb	r2, r1
 8011bd2:	701a      	strb	r2, [r3, #0]
                    for(src_x = 0, dest_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 8011bd4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011bd6:	683b      	ldr	r3, [r7, #0]
 8011bd8:	4413      	add	r3, r2
 8011bda:	637b      	str	r3, [r7, #52]	@ 0x34
 8011bdc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011bde:	3301      	adds	r3, #1
 8011be0:	63bb      	str	r3, [r7, #56]	@ 0x38
 8011be2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011be4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011be6:	429a      	cmp	r2, r3
 8011be8:	dbb9      	blt.n	8011b5e <rgb565_image_blend+0x6e>
                    }
                    dest_buf_u8 += dest_stride;
 8011bea:	6a3b      	ldr	r3, [r7, #32]
 8011bec:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011bee:	4413      	add	r3, r2
 8011bf0:	647b      	str	r3, [r7, #68]	@ 0x44
                    src_buf_c16 = drawbuf_next_row(src_buf_c16, src_stride);
 8011bf2:	69fb      	ldr	r3, [r7, #28]
 8011bf4:	4619      	mov	r1, r3
 8011bf6:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8011bf8:	f000 fde3 	bl	80127c2 <drawbuf_next_row>
 8011bfc:	6438      	str	r0, [r7, #64]	@ 0x40
                for(y = 0; y < h; y++) {
 8011bfe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011c00:	3301      	adds	r3, #1
 8011c02:	633b      	str	r3, [r7, #48]	@ 0x30
 8011c04:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011c06:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011c08:	429a      	cmp	r2, r3
 8011c0a:	dba3      	blt.n	8011b54 <rgb565_image_blend+0x64>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB888(dsc, dest_px_size)) {
 8011c0c:	e1b6      	b.n	8011f7c <rgb565_image_blend+0x48c>
                }
            }
        }
        else if(mask_buf == NULL && opa < LV_OPA_MAX) {
 8011c0e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8011c10:	2b00      	cmp	r3, #0
 8011c12:	d162      	bne.n	8011cda <rgb565_image_blend+0x1ea>
 8011c14:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011c18:	2bfc      	cmp	r3, #252	@ 0xfc
 8011c1a:	d85e      	bhi.n	8011cda <rgb565_image_blend+0x1ea>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB888_WITH_OPA(dsc, dest_px_size)) {
                uint8_t res[3];
                for(y = 0; y < h; y++) {
 8011c1c:	2300      	movs	r3, #0
 8011c1e:	633b      	str	r3, [r7, #48]	@ 0x30
 8011c20:	e056      	b.n	8011cd0 <rgb565_image_blend+0x1e0>
                    for(src_x = 0, dest_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 8011c22:	2300      	movs	r3, #0
 8011c24:	63bb      	str	r3, [r7, #56]	@ 0x38
 8011c26:	2300      	movs	r3, #0
 8011c28:	637b      	str	r3, [r7, #52]	@ 0x34
 8011c2a:	e040      	b.n	8011cae <rgb565_image_blend+0x1be>
                        res[2] = (src_buf_c16[src_x].red * 2106) >> 8; /*To make it rounded*/
 8011c2c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011c2e:	005b      	lsls	r3, r3, #1
 8011c30:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011c32:	4413      	add	r3, r2
 8011c34:	785b      	ldrb	r3, [r3, #1]
 8011c36:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8011c3a:	b2db      	uxtb	r3, r3
 8011c3c:	461a      	mov	r2, r3
 8011c3e:	f640 033a 	movw	r3, #2106	@ 0x83a
 8011c42:	fb02 f303 	mul.w	r3, r2, r3
 8011c46:	121b      	asrs	r3, r3, #8
 8011c48:	b2db      	uxtb	r3, r3
 8011c4a:	75bb      	strb	r3, [r7, #22]
                        res[1] = (src_buf_c16[src_x].green * 1037) >> 8;
 8011c4c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011c4e:	005b      	lsls	r3, r3, #1
 8011c50:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011c52:	4413      	add	r3, r2
 8011c54:	881b      	ldrh	r3, [r3, #0]
 8011c56:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8011c5a:	b2db      	uxtb	r3, r3
 8011c5c:	461a      	mov	r2, r3
 8011c5e:	f240 430d 	movw	r3, #1037	@ 0x40d
 8011c62:	fb02 f303 	mul.w	r3, r2, r3
 8011c66:	121b      	asrs	r3, r3, #8
 8011c68:	b2db      	uxtb	r3, r3
 8011c6a:	757b      	strb	r3, [r7, #21]
                        res[0] = (src_buf_c16[src_x].blue * 2106) >> 8;
 8011c6c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011c6e:	005b      	lsls	r3, r3, #1
 8011c70:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011c72:	4413      	add	r3, r2
 8011c74:	781b      	ldrb	r3, [r3, #0]
 8011c76:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8011c7a:	b2db      	uxtb	r3, r3
 8011c7c:	461a      	mov	r2, r3
 8011c7e:	f640 033a 	movw	r3, #2106	@ 0x83a
 8011c82:	fb02 f303 	mul.w	r3, r2, r3
 8011c86:	121b      	asrs	r3, r3, #8
 8011c88:	b2db      	uxtb	r3, r3
 8011c8a:	753b      	strb	r3, [r7, #20]
                        lv_color_24_24_mix(res, &dest_buf_u8[dest_x], opa);
 8011c8c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011c8e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011c90:	18d1      	adds	r1, r2, r3
 8011c92:	f897 2027 	ldrb.w	r2, [r7, #39]	@ 0x27
 8011c96:	f107 0314 	add.w	r3, r7, #20
 8011c9a:	4618      	mov	r0, r3
 8011c9c:	f000 fd30 	bl	8012700 <lv_color_24_24_mix>
                    for(src_x = 0, dest_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 8011ca0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011ca2:	683b      	ldr	r3, [r7, #0]
 8011ca4:	4413      	add	r3, r2
 8011ca6:	637b      	str	r3, [r7, #52]	@ 0x34
 8011ca8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011caa:	3301      	adds	r3, #1
 8011cac:	63bb      	str	r3, [r7, #56]	@ 0x38
 8011cae:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011cb0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011cb2:	429a      	cmp	r2, r3
 8011cb4:	dbba      	blt.n	8011c2c <rgb565_image_blend+0x13c>
                    }
                    dest_buf_u8 += dest_stride;
 8011cb6:	6a3b      	ldr	r3, [r7, #32]
 8011cb8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011cba:	4413      	add	r3, r2
 8011cbc:	647b      	str	r3, [r7, #68]	@ 0x44
                    src_buf_c16 = drawbuf_next_row(src_buf_c16, src_stride);
 8011cbe:	69fb      	ldr	r3, [r7, #28]
 8011cc0:	4619      	mov	r1, r3
 8011cc2:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8011cc4:	f000 fd7d 	bl	80127c2 <drawbuf_next_row>
 8011cc8:	6438      	str	r0, [r7, #64]	@ 0x40
                for(y = 0; y < h; y++) {
 8011cca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011ccc:	3301      	adds	r3, #1
 8011cce:	633b      	str	r3, [r7, #48]	@ 0x30
 8011cd0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011cd2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011cd4:	429a      	cmp	r2, r3
 8011cd6:	dba4      	blt.n	8011c22 <rgb565_image_blend+0x132>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB888_WITH_OPA(dsc, dest_px_size)) {
 8011cd8:	e150      	b.n	8011f7c <rgb565_image_blend+0x48c>
                }
            }
        }
        else if(mask_buf && opa >= LV_OPA_MAX) {
 8011cda:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8011cdc:	2b00      	cmp	r3, #0
 8011cde:	d068      	beq.n	8011db2 <rgb565_image_blend+0x2c2>
 8011ce0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011ce4:	2bfc      	cmp	r3, #252	@ 0xfc
 8011ce6:	d964      	bls.n	8011db2 <rgb565_image_blend+0x2c2>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB888_WITH_MASK(dsc, dest_px_size)) {
                uint8_t res[3];
                for(y = 0; y < h; y++) {
 8011ce8:	2300      	movs	r3, #0
 8011cea:	633b      	str	r3, [r7, #48]	@ 0x30
 8011cec:	e05c      	b.n	8011da8 <rgb565_image_blend+0x2b8>
                    for(src_x = 0, dest_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 8011cee:	2300      	movs	r3, #0
 8011cf0:	63bb      	str	r3, [r7, #56]	@ 0x38
 8011cf2:	2300      	movs	r3, #0
 8011cf4:	637b      	str	r3, [r7, #52]	@ 0x34
 8011cf6:	e042      	b.n	8011d7e <rgb565_image_blend+0x28e>
                        res[2] = (src_buf_c16[src_x].red * 2106) >> 8;  /*To make it rounded*/
 8011cf8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011cfa:	005b      	lsls	r3, r3, #1
 8011cfc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011cfe:	4413      	add	r3, r2
 8011d00:	785b      	ldrb	r3, [r3, #1]
 8011d02:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8011d06:	b2db      	uxtb	r3, r3
 8011d08:	461a      	mov	r2, r3
 8011d0a:	f640 033a 	movw	r3, #2106	@ 0x83a
 8011d0e:	fb02 f303 	mul.w	r3, r2, r3
 8011d12:	121b      	asrs	r3, r3, #8
 8011d14:	b2db      	uxtb	r3, r3
 8011d16:	74bb      	strb	r3, [r7, #18]
                        res[1] = (src_buf_c16[src_x].green * 1037) >> 8;
 8011d18:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011d1a:	005b      	lsls	r3, r3, #1
 8011d1c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011d1e:	4413      	add	r3, r2
 8011d20:	881b      	ldrh	r3, [r3, #0]
 8011d22:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8011d26:	b2db      	uxtb	r3, r3
 8011d28:	461a      	mov	r2, r3
 8011d2a:	f240 430d 	movw	r3, #1037	@ 0x40d
 8011d2e:	fb02 f303 	mul.w	r3, r2, r3
 8011d32:	121b      	asrs	r3, r3, #8
 8011d34:	b2db      	uxtb	r3, r3
 8011d36:	747b      	strb	r3, [r7, #17]
                        res[0] = (src_buf_c16[src_x].blue * 2106) >> 8;
 8011d38:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011d3a:	005b      	lsls	r3, r3, #1
 8011d3c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011d3e:	4413      	add	r3, r2
 8011d40:	781b      	ldrb	r3, [r3, #0]
 8011d42:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8011d46:	b2db      	uxtb	r3, r3
 8011d48:	461a      	mov	r2, r3
 8011d4a:	f640 033a 	movw	r3, #2106	@ 0x83a
 8011d4e:	fb02 f303 	mul.w	r3, r2, r3
 8011d52:	121b      	asrs	r3, r3, #8
 8011d54:	b2db      	uxtb	r3, r3
 8011d56:	743b      	strb	r3, [r7, #16]
                        lv_color_24_24_mix(res, &dest_buf_u8[dest_x], mask_buf[src_x]);
 8011d58:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011d5a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011d5c:	18d1      	adds	r1, r2, r3
 8011d5e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011d60:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011d62:	4413      	add	r3, r2
 8011d64:	781a      	ldrb	r2, [r3, #0]
 8011d66:	f107 0310 	add.w	r3, r7, #16
 8011d6a:	4618      	mov	r0, r3
 8011d6c:	f000 fcc8 	bl	8012700 <lv_color_24_24_mix>
                    for(src_x = 0, dest_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 8011d70:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011d72:	683b      	ldr	r3, [r7, #0]
 8011d74:	4413      	add	r3, r2
 8011d76:	637b      	str	r3, [r7, #52]	@ 0x34
 8011d78:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011d7a:	3301      	adds	r3, #1
 8011d7c:	63bb      	str	r3, [r7, #56]	@ 0x38
 8011d7e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011d80:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011d82:	429a      	cmp	r2, r3
 8011d84:	dbb8      	blt.n	8011cf8 <rgb565_image_blend+0x208>
                    }
                    dest_buf_u8 += dest_stride;
 8011d86:	6a3b      	ldr	r3, [r7, #32]
 8011d88:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011d8a:	4413      	add	r3, r2
 8011d8c:	647b      	str	r3, [r7, #68]	@ 0x44
                    src_buf_c16 = drawbuf_next_row(src_buf_c16, src_stride);
 8011d8e:	69fb      	ldr	r3, [r7, #28]
 8011d90:	4619      	mov	r1, r3
 8011d92:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8011d94:	f000 fd15 	bl	80127c2 <drawbuf_next_row>
 8011d98:	6438      	str	r0, [r7, #64]	@ 0x40
                    mask_buf += mask_stride;
 8011d9a:	69bb      	ldr	r3, [r7, #24]
 8011d9c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011d9e:	4413      	add	r3, r2
 8011da0:	63fb      	str	r3, [r7, #60]	@ 0x3c
                for(y = 0; y < h; y++) {
 8011da2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011da4:	3301      	adds	r3, #1
 8011da6:	633b      	str	r3, [r7, #48]	@ 0x30
 8011da8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011daa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011dac:	429a      	cmp	r2, r3
 8011dae:	db9e      	blt.n	8011cee <rgb565_image_blend+0x1fe>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB888_WITH_MASK(dsc, dest_px_size)) {
 8011db0:	e0e4      	b.n	8011f7c <rgb565_image_blend+0x48c>
            }
        }
        else {
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_BLEND_NORMAL_TO_RGB888_MIX_MASK_OPA(dsc, dest_px_size)) {
                uint8_t res[3];
                for(y = 0; y < h; y++) {
 8011db2:	2300      	movs	r3, #0
 8011db4:	633b      	str	r3, [r7, #48]	@ 0x30
 8011db6:	e063      	b.n	8011e80 <rgb565_image_blend+0x390>
                    for(src_x = 0, dest_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 8011db8:	2300      	movs	r3, #0
 8011dba:	63bb      	str	r3, [r7, #56]	@ 0x38
 8011dbc:	2300      	movs	r3, #0
 8011dbe:	637b      	str	r3, [r7, #52]	@ 0x34
 8011dc0:	e049      	b.n	8011e56 <rgb565_image_blend+0x366>
                        res[2] = (src_buf_c16[src_x].red * 2106) >> 8;  /*To make it rounded*/
 8011dc2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011dc4:	005b      	lsls	r3, r3, #1
 8011dc6:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011dc8:	4413      	add	r3, r2
 8011dca:	785b      	ldrb	r3, [r3, #1]
 8011dcc:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8011dd0:	b2db      	uxtb	r3, r3
 8011dd2:	461a      	mov	r2, r3
 8011dd4:	f640 033a 	movw	r3, #2106	@ 0x83a
 8011dd8:	fb02 f303 	mul.w	r3, r2, r3
 8011ddc:	121b      	asrs	r3, r3, #8
 8011dde:	b2db      	uxtb	r3, r3
 8011de0:	73bb      	strb	r3, [r7, #14]
                        res[1] = (src_buf_c16[src_x].green * 1037) >> 8;
 8011de2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011de4:	005b      	lsls	r3, r3, #1
 8011de6:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011de8:	4413      	add	r3, r2
 8011dea:	881b      	ldrh	r3, [r3, #0]
 8011dec:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8011df0:	b2db      	uxtb	r3, r3
 8011df2:	461a      	mov	r2, r3
 8011df4:	f240 430d 	movw	r3, #1037	@ 0x40d
 8011df8:	fb02 f303 	mul.w	r3, r2, r3
 8011dfc:	121b      	asrs	r3, r3, #8
 8011dfe:	b2db      	uxtb	r3, r3
 8011e00:	737b      	strb	r3, [r7, #13]
                        res[0] = (src_buf_c16[src_x].blue * 2106) >> 8;
 8011e02:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011e04:	005b      	lsls	r3, r3, #1
 8011e06:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011e08:	4413      	add	r3, r2
 8011e0a:	781b      	ldrb	r3, [r3, #0]
 8011e0c:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8011e10:	b2db      	uxtb	r3, r3
 8011e12:	461a      	mov	r2, r3
 8011e14:	f640 033a 	movw	r3, #2106	@ 0x83a
 8011e18:	fb02 f303 	mul.w	r3, r2, r3
 8011e1c:	121b      	asrs	r3, r3, #8
 8011e1e:	b2db      	uxtb	r3, r3
 8011e20:	733b      	strb	r3, [r7, #12]
                        lv_color_24_24_mix(res, &dest_buf_u8[dest_x], LV_OPA_MIX2(opa, mask_buf[src_x]));
 8011e22:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011e24:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011e26:	18d0      	adds	r0, r2, r3
 8011e28:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011e2c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011e2e:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8011e30:	440a      	add	r2, r1
 8011e32:	7812      	ldrb	r2, [r2, #0]
 8011e34:	fb02 f303 	mul.w	r3, r2, r3
 8011e38:	121b      	asrs	r3, r3, #8
 8011e3a:	b2da      	uxtb	r2, r3
 8011e3c:	f107 030c 	add.w	r3, r7, #12
 8011e40:	4601      	mov	r1, r0
 8011e42:	4618      	mov	r0, r3
 8011e44:	f000 fc5c 	bl	8012700 <lv_color_24_24_mix>
                    for(src_x = 0, dest_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 8011e48:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011e4a:	683b      	ldr	r3, [r7, #0]
 8011e4c:	4413      	add	r3, r2
 8011e4e:	637b      	str	r3, [r7, #52]	@ 0x34
 8011e50:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011e52:	3301      	adds	r3, #1
 8011e54:	63bb      	str	r3, [r7, #56]	@ 0x38
 8011e56:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011e58:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011e5a:	429a      	cmp	r2, r3
 8011e5c:	dbb1      	blt.n	8011dc2 <rgb565_image_blend+0x2d2>
                    }
                    dest_buf_u8 += dest_stride;
 8011e5e:	6a3b      	ldr	r3, [r7, #32]
 8011e60:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011e62:	4413      	add	r3, r2
 8011e64:	647b      	str	r3, [r7, #68]	@ 0x44
                    src_buf_c16 = drawbuf_next_row(src_buf_c16, src_stride);
 8011e66:	69fb      	ldr	r3, [r7, #28]
 8011e68:	4619      	mov	r1, r3
 8011e6a:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8011e6c:	f000 fca9 	bl	80127c2 <drawbuf_next_row>
 8011e70:	6438      	str	r0, [r7, #64]	@ 0x40
                    mask_buf += mask_stride;
 8011e72:	69bb      	ldr	r3, [r7, #24]
 8011e74:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011e76:	4413      	add	r3, r2
 8011e78:	63fb      	str	r3, [r7, #60]	@ 0x3c
                for(y = 0; y < h; y++) {
 8011e7a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011e7c:	3301      	adds	r3, #1
 8011e7e:	633b      	str	r3, [r7, #48]	@ 0x30
 8011e80:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011e82:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011e84:	429a      	cmp	r2, r3
 8011e86:	db97      	blt.n	8011db8 <rgb565_image_blend+0x2c8>
            if(mask_buf) mask_buf += mask_stride;
            dest_buf_u8 += dest_stride;
            src_buf_c16 = drawbuf_next_row(src_buf_c16, src_stride);
        }
    }
}
 8011e88:	e078      	b.n	8011f7c <rgb565_image_blend+0x48c>
        for(y = 0; y < h; y++) {
 8011e8a:	2300      	movs	r3, #0
 8011e8c:	633b      	str	r3, [r7, #48]	@ 0x30
 8011e8e:	e070      	b.n	8011f72 <rgb565_image_blend+0x482>
            for(src_x = 0, dest_x = 0; src_x < w; src_x++, dest_x += dest_px_size) {
 8011e90:	2300      	movs	r3, #0
 8011e92:	63bb      	str	r3, [r7, #56]	@ 0x38
 8011e94:	2300      	movs	r3, #0
 8011e96:	637b      	str	r3, [r7, #52]	@ 0x34
 8011e98:	e053      	b.n	8011f42 <rgb565_image_blend+0x452>
                src_argb.red = (src_buf_c16[src_x].red * 2106) >> 8;
 8011e9a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011e9c:	005b      	lsls	r3, r3, #1
 8011e9e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011ea0:	4413      	add	r3, r2
 8011ea2:	785b      	ldrb	r3, [r3, #1]
 8011ea4:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8011ea8:	b2db      	uxtb	r3, r3
 8011eaa:	461a      	mov	r2, r3
 8011eac:	f640 033a 	movw	r3, #2106	@ 0x83a
 8011eb0:	fb02 f303 	mul.w	r3, r2, r3
 8011eb4:	121b      	asrs	r3, r3, #8
 8011eb6:	b2db      	uxtb	r3, r3
 8011eb8:	72bb      	strb	r3, [r7, #10]
                src_argb.green = (src_buf_c16[src_x].green * 1037) >> 8;
 8011eba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011ebc:	005b      	lsls	r3, r3, #1
 8011ebe:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011ec0:	4413      	add	r3, r2
 8011ec2:	881b      	ldrh	r3, [r3, #0]
 8011ec4:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8011ec8:	b2db      	uxtb	r3, r3
 8011eca:	461a      	mov	r2, r3
 8011ecc:	f240 430d 	movw	r3, #1037	@ 0x40d
 8011ed0:	fb02 f303 	mul.w	r3, r2, r3
 8011ed4:	121b      	asrs	r3, r3, #8
 8011ed6:	b2db      	uxtb	r3, r3
 8011ed8:	727b      	strb	r3, [r7, #9]
                src_argb.blue = (src_buf_c16[src_x].blue * 2106) >> 8;
 8011eda:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011edc:	005b      	lsls	r3, r3, #1
 8011ede:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8011ee0:	4413      	add	r3, r2
 8011ee2:	781b      	ldrb	r3, [r3, #0]
 8011ee4:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8011ee8:	b2db      	uxtb	r3, r3
 8011eea:	461a      	mov	r2, r3
 8011eec:	f640 033a 	movw	r3, #2106	@ 0x83a
 8011ef0:	fb02 f303 	mul.w	r3, r2, r3
 8011ef4:	121b      	asrs	r3, r3, #8
 8011ef6:	b2db      	uxtb	r3, r3
 8011ef8:	723b      	strb	r3, [r7, #8]
                if(mask_buf == NULL) src_argb.alpha = opa;
 8011efa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8011efc:	2b00      	cmp	r3, #0
 8011efe:	d103      	bne.n	8011f08 <rgb565_image_blend+0x418>
 8011f00:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011f04:	72fb      	strb	r3, [r7, #11]
 8011f06:	e00b      	b.n	8011f20 <rgb565_image_blend+0x430>
                else src_argb.alpha = LV_OPA_MIX2(mask_buf[src_x], opa);
 8011f08:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011f0a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011f0c:	4413      	add	r3, r2
 8011f0e:	781b      	ldrb	r3, [r3, #0]
 8011f10:	461a      	mov	r2, r3
 8011f12:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011f16:	fb02 f303 	mul.w	r3, r2, r3
 8011f1a:	121b      	asrs	r3, r3, #8
 8011f1c:	b2db      	uxtb	r3, r3
 8011f1e:	72fb      	strb	r3, [r7, #11]
                blend_non_normal_pixel(&dest_buf_u8[dest_x], src_argb, dsc->blend_mode);
 8011f20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011f22:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011f24:	18d0      	adds	r0, r2, r3
 8011f26:	687b      	ldr	r3, [r7, #4]
 8011f28:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 8011f2c:	461a      	mov	r2, r3
 8011f2e:	68b9      	ldr	r1, [r7, #8]
 8011f30:	f000 fb64 	bl	80125fc <blend_non_normal_pixel>
            for(src_x = 0, dest_x = 0; src_x < w; src_x++, dest_x += dest_px_size) {
 8011f34:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011f36:	3301      	adds	r3, #1
 8011f38:	63bb      	str	r3, [r7, #56]	@ 0x38
 8011f3a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8011f3c:	683b      	ldr	r3, [r7, #0]
 8011f3e:	4413      	add	r3, r2
 8011f40:	637b      	str	r3, [r7, #52]	@ 0x34
 8011f42:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011f44:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011f46:	429a      	cmp	r2, r3
 8011f48:	dba7      	blt.n	8011e9a <rgb565_image_blend+0x3aa>
            if(mask_buf) mask_buf += mask_stride;
 8011f4a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8011f4c:	2b00      	cmp	r3, #0
 8011f4e:	d003      	beq.n	8011f58 <rgb565_image_blend+0x468>
 8011f50:	69bb      	ldr	r3, [r7, #24]
 8011f52:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8011f54:	4413      	add	r3, r2
 8011f56:	63fb      	str	r3, [r7, #60]	@ 0x3c
            dest_buf_u8 += dest_stride;
 8011f58:	6a3b      	ldr	r3, [r7, #32]
 8011f5a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8011f5c:	4413      	add	r3, r2
 8011f5e:	647b      	str	r3, [r7, #68]	@ 0x44
            src_buf_c16 = drawbuf_next_row(src_buf_c16, src_stride);
 8011f60:	69fb      	ldr	r3, [r7, #28]
 8011f62:	4619      	mov	r1, r3
 8011f64:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 8011f66:	f000 fc2c 	bl	80127c2 <drawbuf_next_row>
 8011f6a:	6438      	str	r0, [r7, #64]	@ 0x40
        for(y = 0; y < h; y++) {
 8011f6c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8011f6e:	3301      	adds	r3, #1
 8011f70:	633b      	str	r3, [r7, #48]	@ 0x30
 8011f72:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8011f74:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011f76:	429a      	cmp	r2, r3
 8011f78:	db8a      	blt.n	8011e90 <rgb565_image_blend+0x3a0>
}
 8011f7a:	e7ff      	b.n	8011f7c <rgb565_image_blend+0x48c>
 8011f7c:	bf00      	nop
 8011f7e:	3748      	adds	r7, #72	@ 0x48
 8011f80:	46bd      	mov	sp, r7
 8011f82:	bd80      	pop	{r7, pc}

08011f84 <rgb888_image_blend>:

static void LV_ATTRIBUTE_FAST_MEM rgb888_image_blend(_lv_draw_sw_blend_image_dsc_t * dsc, const uint8_t dest_px_size,
                                                     uint32_t src_px_size)
{
 8011f84:	b590      	push	{r4, r7, lr}
 8011f86:	b095      	sub	sp, #84	@ 0x54
 8011f88:	af00      	add	r7, sp, #0
 8011f8a:	60f8      	str	r0, [r7, #12]
 8011f8c:	460b      	mov	r3, r1
 8011f8e:	607a      	str	r2, [r7, #4]
 8011f90:	72fb      	strb	r3, [r7, #11]
    int32_t w = dsc->dest_w * dest_px_size;
 8011f92:	68fb      	ldr	r3, [r7, #12]
 8011f94:	685b      	ldr	r3, [r3, #4]
 8011f96:	7afa      	ldrb	r2, [r7, #11]
 8011f98:	fb02 f303 	mul.w	r3, r2, r3
 8011f9c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int32_t h = dsc->dest_h;
 8011f9e:	68fb      	ldr	r3, [r7, #12]
 8011fa0:	689b      	ldr	r3, [r3, #8]
 8011fa2:	62bb      	str	r3, [r7, #40]	@ 0x28
    lv_opa_t opa = dsc->opa;
 8011fa4:	68fb      	ldr	r3, [r7, #12]
 8011fa6:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 8011faa:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    uint8_t * dest_buf = dsc->dest_buf;
 8011fae:	68fb      	ldr	r3, [r7, #12]
 8011fb0:	681b      	ldr	r3, [r3, #0]
 8011fb2:	64fb      	str	r3, [r7, #76]	@ 0x4c
    int32_t dest_stride = dsc->dest_stride;
 8011fb4:	68fb      	ldr	r3, [r7, #12]
 8011fb6:	68db      	ldr	r3, [r3, #12]
 8011fb8:	623b      	str	r3, [r7, #32]
    const uint8_t * src_buf = dsc->src_buf;
 8011fba:	68fb      	ldr	r3, [r7, #12]
 8011fbc:	699b      	ldr	r3, [r3, #24]
 8011fbe:	64bb      	str	r3, [r7, #72]	@ 0x48
    int32_t src_stride = dsc->src_stride;
 8011fc0:	68fb      	ldr	r3, [r7, #12]
 8011fc2:	69db      	ldr	r3, [r3, #28]
 8011fc4:	61fb      	str	r3, [r7, #28]
    const lv_opa_t * mask_buf = dsc->mask_buf;
 8011fc6:	68fb      	ldr	r3, [r7, #12]
 8011fc8:	691b      	ldr	r3, [r3, #16]
 8011fca:	647b      	str	r3, [r7, #68]	@ 0x44
    int32_t mask_stride = dsc->mask_stride;
 8011fcc:	68fb      	ldr	r3, [r7, #12]
 8011fce:	695b      	ldr	r3, [r3, #20]
 8011fd0:	61bb      	str	r3, [r7, #24]

    int32_t dest_x;
    int32_t src_x;
    int32_t y;

    if(dsc->blend_mode == LV_BLEND_MODE_NORMAL) {
 8011fd2:	68fb      	ldr	r3, [r7, #12]
 8011fd4:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 8011fd8:	2b00      	cmp	r3, #0
 8011fda:	f040 8122 	bne.w	8012222 <rgb888_image_blend+0x29e>
        /*Special case*/
        if(mask_buf == NULL && opa >= LV_OPA_MAX) {
 8011fde:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8011fe0:	2b00      	cmp	r3, #0
 8011fe2:	d15f      	bne.n	80120a4 <rgb888_image_blend+0x120>
 8011fe4:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8011fe8:	2bfc      	cmp	r3, #252	@ 0xfc
 8011fea:	d95b      	bls.n	80120a4 <rgb888_image_blend+0x120>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_RGB888(dsc, dest_px_size, src_px_size)) {
                if(src_px_size == dest_px_size) {
 8011fec:	7afb      	ldrb	r3, [r7, #11]
 8011fee:	687a      	ldr	r2, [r7, #4]
 8011ff0:	429a      	cmp	r2, r3
 8011ff2:	d118      	bne.n	8012026 <rgb888_image_blend+0xa2>
                    for(y = 0; y < h; y++) {
 8011ff4:	2300      	movs	r3, #0
 8011ff6:	63bb      	str	r3, [r7, #56]	@ 0x38
 8011ff8:	e010      	b.n	801201c <rgb888_image_blend+0x98>
                        lv_memcpy(dest_buf, src_buf, w);
 8011ffa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011ffc:	461a      	mov	r2, r3
 8011ffe:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8012000:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8012002:	f012 fcf1 	bl	80249e8 <lv_memcpy>
                        dest_buf += dest_stride;
 8012006:	6a3b      	ldr	r3, [r7, #32]
 8012008:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801200a:	4413      	add	r3, r2
 801200c:	64fb      	str	r3, [r7, #76]	@ 0x4c
                        src_buf += src_stride;
 801200e:	69fb      	ldr	r3, [r7, #28]
 8012010:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8012012:	4413      	add	r3, r2
 8012014:	64bb      	str	r3, [r7, #72]	@ 0x48
                    for(y = 0; y < h; y++) {
 8012016:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8012018:	3301      	adds	r3, #1
 801201a:	63bb      	str	r3, [r7, #56]	@ 0x38
 801201c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801201e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012020:	429a      	cmp	r2, r3
 8012022:	dbea      	blt.n	8011ffa <rgb888_image_blend+0x76>
 8012024:	e03e      	b.n	80120a4 <rgb888_image_blend+0x120>
                    }
                }
                else {
                    for(y = 0; y < h; y++) {
 8012026:	2300      	movs	r3, #0
 8012028:	63bb      	str	r3, [r7, #56]	@ 0x38
 801202a:	e037      	b.n	801209c <rgb888_image_blend+0x118>
                        for(dest_x = 0, src_x = 0; dest_x < w; dest_x += dest_px_size, src_x += src_px_size) {
 801202c:	2300      	movs	r3, #0
 801202e:	643b      	str	r3, [r7, #64]	@ 0x40
 8012030:	2300      	movs	r3, #0
 8012032:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8012034:	e023      	b.n	801207e <rgb888_image_blend+0xfa>
                            dest_buf[dest_x + 0] = src_buf[src_x + 0];
 8012036:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012038:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801203a:	441a      	add	r2, r3
 801203c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801203e:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 8012040:	440b      	add	r3, r1
 8012042:	7812      	ldrb	r2, [r2, #0]
 8012044:	701a      	strb	r2, [r3, #0]
                            dest_buf[dest_x + 1] = src_buf[src_x + 1];
 8012046:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012048:	3301      	adds	r3, #1
 801204a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801204c:	441a      	add	r2, r3
 801204e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8012050:	3301      	adds	r3, #1
 8012052:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 8012054:	440b      	add	r3, r1
 8012056:	7812      	ldrb	r2, [r2, #0]
 8012058:	701a      	strb	r2, [r3, #0]
                            dest_buf[dest_x + 2] = src_buf[src_x + 2];
 801205a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801205c:	3302      	adds	r3, #2
 801205e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8012060:	441a      	add	r2, r3
 8012062:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8012064:	3302      	adds	r3, #2
 8012066:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 8012068:	440b      	add	r3, r1
 801206a:	7812      	ldrb	r2, [r2, #0]
 801206c:	701a      	strb	r2, [r3, #0]
                        for(dest_x = 0, src_x = 0; dest_x < w; dest_x += dest_px_size, src_x += src_px_size) {
 801206e:	7afb      	ldrb	r3, [r7, #11]
 8012070:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8012072:	4413      	add	r3, r2
 8012074:	643b      	str	r3, [r7, #64]	@ 0x40
 8012076:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8012078:	687b      	ldr	r3, [r7, #4]
 801207a:	4413      	add	r3, r2
 801207c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801207e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8012080:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012082:	429a      	cmp	r2, r3
 8012084:	dbd7      	blt.n	8012036 <rgb888_image_blend+0xb2>
                        }
                        dest_buf += dest_stride;
 8012086:	6a3b      	ldr	r3, [r7, #32]
 8012088:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801208a:	4413      	add	r3, r2
 801208c:	64fb      	str	r3, [r7, #76]	@ 0x4c
                        src_buf += src_stride;
 801208e:	69fb      	ldr	r3, [r7, #28]
 8012090:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8012092:	4413      	add	r3, r2
 8012094:	64bb      	str	r3, [r7, #72]	@ 0x48
                    for(y = 0; y < h; y++) {
 8012096:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8012098:	3301      	adds	r3, #1
 801209a:	63bb      	str	r3, [r7, #56]	@ 0x38
 801209c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801209e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80120a0:	429a      	cmp	r2, r3
 80120a2:	dbc3      	blt.n	801202c <rgb888_image_blend+0xa8>
                    }
                }
            }
        }
        if(mask_buf == NULL && opa < LV_OPA_MAX) {
 80120a4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80120a6:	2b00      	cmp	r3, #0
 80120a8:	d131      	bne.n	801210e <rgb888_image_blend+0x18a>
 80120aa:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80120ae:	2bfc      	cmp	r3, #252	@ 0xfc
 80120b0:	d82d      	bhi.n	801210e <rgb888_image_blend+0x18a>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_RGB888_WITH_OPA(dsc, dest_px_size, src_px_size)) {
                for(y = 0; y < h; y++) {
 80120b2:	2300      	movs	r3, #0
 80120b4:	63bb      	str	r3, [r7, #56]	@ 0x38
 80120b6:	e026      	b.n	8012106 <rgb888_image_blend+0x182>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x += dest_px_size, src_x += src_px_size) {
 80120b8:	2300      	movs	r3, #0
 80120ba:	643b      	str	r3, [r7, #64]	@ 0x40
 80120bc:	2300      	movs	r3, #0
 80120be:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80120c0:	e012      	b.n	80120e8 <rgb888_image_blend+0x164>
                        lv_color_24_24_mix(&src_buf[src_x], &dest_buf[dest_x], opa);
 80120c2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80120c4:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80120c6:	18d0      	adds	r0, r2, r3
 80120c8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80120ca:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80120cc:	4413      	add	r3, r2
 80120ce:	f897 2027 	ldrb.w	r2, [r7, #39]	@ 0x27
 80120d2:	4619      	mov	r1, r3
 80120d4:	f000 fb14 	bl	8012700 <lv_color_24_24_mix>
                    for(dest_x = 0, src_x = 0; dest_x < w; dest_x += dest_px_size, src_x += src_px_size) {
 80120d8:	7afb      	ldrb	r3, [r7, #11]
 80120da:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80120dc:	4413      	add	r3, r2
 80120de:	643b      	str	r3, [r7, #64]	@ 0x40
 80120e0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80120e2:	687b      	ldr	r3, [r7, #4]
 80120e4:	4413      	add	r3, r2
 80120e6:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80120e8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80120ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80120ec:	429a      	cmp	r2, r3
 80120ee:	dbe8      	blt.n	80120c2 <rgb888_image_blend+0x13e>
                    }
                    dest_buf += dest_stride;
 80120f0:	6a3b      	ldr	r3, [r7, #32]
 80120f2:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80120f4:	4413      	add	r3, r2
 80120f6:	64fb      	str	r3, [r7, #76]	@ 0x4c
                    src_buf += src_stride;
 80120f8:	69fb      	ldr	r3, [r7, #28]
 80120fa:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80120fc:	4413      	add	r3, r2
 80120fe:	64bb      	str	r3, [r7, #72]	@ 0x48
                for(y = 0; y < h; y++) {
 8012100:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8012102:	3301      	adds	r3, #1
 8012104:	63bb      	str	r3, [r7, #56]	@ 0x38
 8012106:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8012108:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801210a:	429a      	cmp	r2, r3
 801210c:	dbd4      	blt.n	80120b8 <rgb888_image_blend+0x134>
                }
            }
        }
        if(mask_buf && opa >= LV_OPA_MAX) {
 801210e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8012110:	2b00      	cmp	r3, #0
 8012112:	d03c      	beq.n	801218e <rgb888_image_blend+0x20a>
 8012114:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8012118:	2bfc      	cmp	r3, #252	@ 0xfc
 801211a:	d938      	bls.n	801218e <rgb888_image_blend+0x20a>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_RGB888_WITH_MASK(dsc, dest_px_size, src_px_size)) {
                uint32_t mask_x;
                for(y = 0; y < h; y++) {
 801211c:	2300      	movs	r3, #0
 801211e:	63bb      	str	r3, [r7, #56]	@ 0x38
 8012120:	e031      	b.n	8012186 <rgb888_image_blend+0x202>
                    for(mask_x = 0, dest_x = 0, src_x = 0; dest_x < w; mask_x++, dest_x += dest_px_size, src_x += src_px_size) {
 8012122:	2300      	movs	r3, #0
 8012124:	637b      	str	r3, [r7, #52]	@ 0x34
 8012126:	2300      	movs	r3, #0
 8012128:	643b      	str	r3, [r7, #64]	@ 0x40
 801212a:	2300      	movs	r3, #0
 801212c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801212e:	e017      	b.n	8012160 <rgb888_image_blend+0x1dc>
                        lv_color_24_24_mix(&src_buf[src_x], &dest_buf[dest_x], mask_buf[mask_x]);
 8012130:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012132:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8012134:	18d0      	adds	r0, r2, r3
 8012136:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8012138:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801213a:	18d1      	adds	r1, r2, r3
 801213c:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801213e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8012140:	4413      	add	r3, r2
 8012142:	781b      	ldrb	r3, [r3, #0]
 8012144:	461a      	mov	r2, r3
 8012146:	f000 fadb 	bl	8012700 <lv_color_24_24_mix>
                    for(mask_x = 0, dest_x = 0, src_x = 0; dest_x < w; mask_x++, dest_x += dest_px_size, src_x += src_px_size) {
 801214a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801214c:	3301      	adds	r3, #1
 801214e:	637b      	str	r3, [r7, #52]	@ 0x34
 8012150:	7afb      	ldrb	r3, [r7, #11]
 8012152:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8012154:	4413      	add	r3, r2
 8012156:	643b      	str	r3, [r7, #64]	@ 0x40
 8012158:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801215a:	687b      	ldr	r3, [r7, #4]
 801215c:	4413      	add	r3, r2
 801215e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8012160:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8012162:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012164:	429a      	cmp	r2, r3
 8012166:	dbe3      	blt.n	8012130 <rgb888_image_blend+0x1ac>
                    }
                    dest_buf += dest_stride;
 8012168:	6a3b      	ldr	r3, [r7, #32]
 801216a:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801216c:	4413      	add	r3, r2
 801216e:	64fb      	str	r3, [r7, #76]	@ 0x4c
                    src_buf += src_stride;
 8012170:	69fb      	ldr	r3, [r7, #28]
 8012172:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8012174:	4413      	add	r3, r2
 8012176:	64bb      	str	r3, [r7, #72]	@ 0x48
                    mask_buf += mask_stride;
 8012178:	69bb      	ldr	r3, [r7, #24]
 801217a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801217c:	4413      	add	r3, r2
 801217e:	647b      	str	r3, [r7, #68]	@ 0x44
                for(y = 0; y < h; y++) {
 8012180:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8012182:	3301      	adds	r3, #1
 8012184:	63bb      	str	r3, [r7, #56]	@ 0x38
 8012186:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8012188:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801218a:	429a      	cmp	r2, r3
 801218c:	dbc9      	blt.n	8012122 <rgb888_image_blend+0x19e>
                }
            }
        }
        if(mask_buf && opa < LV_OPA_MAX) {
 801218e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8012190:	2b00      	cmp	r3, #0
 8012192:	f000 809e 	beq.w	80122d2 <rgb888_image_blend+0x34e>
 8012196:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801219a:	2bfc      	cmp	r3, #252	@ 0xfc
 801219c:	f200 8099 	bhi.w	80122d2 <rgb888_image_blend+0x34e>
            if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_BLEND_NORMAL_TO_RGB888_MIX_MASK_OPA(dsc, dest_px_size, src_px_size)) {
                uint32_t mask_x;
                for(y = 0; y < h; y++) {
 80121a0:	2300      	movs	r3, #0
 80121a2:	63bb      	str	r3, [r7, #56]	@ 0x38
 80121a4:	e038      	b.n	8012218 <rgb888_image_blend+0x294>
                    for(mask_x = 0, dest_x = 0, src_x = 0; dest_x < w; mask_x++, dest_x += dest_px_size, src_x += src_px_size) {
 80121a6:	2300      	movs	r3, #0
 80121a8:	633b      	str	r3, [r7, #48]	@ 0x30
 80121aa:	2300      	movs	r3, #0
 80121ac:	643b      	str	r3, [r7, #64]	@ 0x40
 80121ae:	2300      	movs	r3, #0
 80121b0:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80121b2:	e01e      	b.n	80121f2 <rgb888_image_blend+0x26e>
                        lv_color_24_24_mix(&src_buf[src_x], &dest_buf[dest_x], LV_OPA_MIX2(opa, mask_buf[mask_x]));
 80121b4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80121b6:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80121b8:	18d0      	adds	r0, r2, r3
 80121ba:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80121bc:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80121be:	18d4      	adds	r4, r2, r3
 80121c0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 80121c4:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 80121c6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80121c8:	440a      	add	r2, r1
 80121ca:	7812      	ldrb	r2, [r2, #0]
 80121cc:	fb02 f303 	mul.w	r3, r2, r3
 80121d0:	121b      	asrs	r3, r3, #8
 80121d2:	b2db      	uxtb	r3, r3
 80121d4:	461a      	mov	r2, r3
 80121d6:	4621      	mov	r1, r4
 80121d8:	f000 fa92 	bl	8012700 <lv_color_24_24_mix>
                    for(mask_x = 0, dest_x = 0, src_x = 0; dest_x < w; mask_x++, dest_x += dest_px_size, src_x += src_px_size) {
 80121dc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80121de:	3301      	adds	r3, #1
 80121e0:	633b      	str	r3, [r7, #48]	@ 0x30
 80121e2:	7afb      	ldrb	r3, [r7, #11]
 80121e4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80121e6:	4413      	add	r3, r2
 80121e8:	643b      	str	r3, [r7, #64]	@ 0x40
 80121ea:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80121ec:	687b      	ldr	r3, [r7, #4]
 80121ee:	4413      	add	r3, r2
 80121f0:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80121f2:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80121f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80121f6:	429a      	cmp	r2, r3
 80121f8:	dbdc      	blt.n	80121b4 <rgb888_image_blend+0x230>
                    }
                    dest_buf += dest_stride;
 80121fa:	6a3b      	ldr	r3, [r7, #32]
 80121fc:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80121fe:	4413      	add	r3, r2
 8012200:	64fb      	str	r3, [r7, #76]	@ 0x4c
                    src_buf += src_stride;
 8012202:	69fb      	ldr	r3, [r7, #28]
 8012204:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8012206:	4413      	add	r3, r2
 8012208:	64bb      	str	r3, [r7, #72]	@ 0x48
                    mask_buf += mask_stride;
 801220a:	69bb      	ldr	r3, [r7, #24]
 801220c:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801220e:	4413      	add	r3, r2
 8012210:	647b      	str	r3, [r7, #68]	@ 0x44
                for(y = 0; y < h; y++) {
 8012212:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8012214:	3301      	adds	r3, #1
 8012216:	63bb      	str	r3, [r7, #56]	@ 0x38
 8012218:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801221a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801221c:	429a      	cmp	r2, r3
 801221e:	dbc2      	blt.n	80121a6 <rgb888_image_blend+0x222>
            if(mask_buf) mask_buf += mask_stride;
            dest_buf += dest_stride;
            src_buf += src_stride;
        }
    }
}
 8012220:	e057      	b.n	80122d2 <rgb888_image_blend+0x34e>
        for(y = 0; y < h; y++) {
 8012222:	2300      	movs	r3, #0
 8012224:	63bb      	str	r3, [r7, #56]	@ 0x38
 8012226:	e050      	b.n	80122ca <rgb888_image_blend+0x346>
            for(dest_x = 0, src_x = 0; dest_x < w; dest_x += dest_px_size, src_x += src_px_size) {
 8012228:	2300      	movs	r3, #0
 801222a:	643b      	str	r3, [r7, #64]	@ 0x40
 801222c:	2300      	movs	r3, #0
 801222e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8012230:	e035      	b.n	801229e <rgb888_image_blend+0x31a>
                src_argb.red = src_buf[src_x + 2];
 8012232:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012234:	3302      	adds	r3, #2
 8012236:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8012238:	4413      	add	r3, r2
 801223a:	781b      	ldrb	r3, [r3, #0]
 801223c:	75bb      	strb	r3, [r7, #22]
                src_argb.green = src_buf[src_x + 1];
 801223e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012240:	3301      	adds	r3, #1
 8012242:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8012244:	4413      	add	r3, r2
 8012246:	781b      	ldrb	r3, [r3, #0]
 8012248:	757b      	strb	r3, [r7, #21]
                src_argb.blue = src_buf[src_x + 0];
 801224a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801224c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801224e:	4413      	add	r3, r2
 8012250:	781b      	ldrb	r3, [r3, #0]
 8012252:	753b      	strb	r3, [r7, #20]
                if(mask_buf == NULL) src_argb.alpha = opa;
 8012254:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8012256:	2b00      	cmp	r3, #0
 8012258:	d103      	bne.n	8012262 <rgb888_image_blend+0x2de>
 801225a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801225e:	75fb      	strb	r3, [r7, #23]
 8012260:	e00b      	b.n	801227a <rgb888_image_blend+0x2f6>
                else src_argb.alpha = LV_OPA_MIX2(mask_buf[dest_x], opa);
 8012262:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8012264:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8012266:	4413      	add	r3, r2
 8012268:	781b      	ldrb	r3, [r3, #0]
 801226a:	461a      	mov	r2, r3
 801226c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8012270:	fb02 f303 	mul.w	r3, r2, r3
 8012274:	121b      	asrs	r3, r3, #8
 8012276:	b2db      	uxtb	r3, r3
 8012278:	75fb      	strb	r3, [r7, #23]
                blend_non_normal_pixel(&dest_buf[dest_x], src_argb, dsc->blend_mode);
 801227a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801227c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801227e:	18d0      	adds	r0, r2, r3
 8012280:	68fb      	ldr	r3, [r7, #12]
 8012282:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 8012286:	461a      	mov	r2, r3
 8012288:	6979      	ldr	r1, [r7, #20]
 801228a:	f000 f9b7 	bl	80125fc <blend_non_normal_pixel>
            for(dest_x = 0, src_x = 0; dest_x < w; dest_x += dest_px_size, src_x += src_px_size) {
 801228e:	7afb      	ldrb	r3, [r7, #11]
 8012290:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8012292:	4413      	add	r3, r2
 8012294:	643b      	str	r3, [r7, #64]	@ 0x40
 8012296:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8012298:	687b      	ldr	r3, [r7, #4]
 801229a:	4413      	add	r3, r2
 801229c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801229e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80122a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80122a2:	429a      	cmp	r2, r3
 80122a4:	dbc5      	blt.n	8012232 <rgb888_image_blend+0x2ae>
            if(mask_buf) mask_buf += mask_stride;
 80122a6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80122a8:	2b00      	cmp	r3, #0
 80122aa:	d003      	beq.n	80122b4 <rgb888_image_blend+0x330>
 80122ac:	69bb      	ldr	r3, [r7, #24]
 80122ae:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80122b0:	4413      	add	r3, r2
 80122b2:	647b      	str	r3, [r7, #68]	@ 0x44
            dest_buf += dest_stride;
 80122b4:	6a3b      	ldr	r3, [r7, #32]
 80122b6:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80122b8:	4413      	add	r3, r2
 80122ba:	64fb      	str	r3, [r7, #76]	@ 0x4c
            src_buf += src_stride;
 80122bc:	69fb      	ldr	r3, [r7, #28]
 80122be:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80122c0:	4413      	add	r3, r2
 80122c2:	64bb      	str	r3, [r7, #72]	@ 0x48
        for(y = 0; y < h; y++) {
 80122c4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80122c6:	3301      	adds	r3, #1
 80122c8:	63bb      	str	r3, [r7, #56]	@ 0x38
 80122ca:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80122cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80122ce:	429a      	cmp	r2, r3
 80122d0:	dbaa      	blt.n	8012228 <rgb888_image_blend+0x2a4>
}
 80122d2:	bf00      	nop
 80122d4:	3754      	adds	r7, #84	@ 0x54
 80122d6:	46bd      	mov	sp, r7
 80122d8:	bd90      	pop	{r4, r7, pc}

080122da <argb8888_image_blend>:

static void LV_ATTRIBUTE_FAST_MEM argb8888_image_blend(_lv_draw_sw_blend_image_dsc_t * dsc, uint32_t dest_px_size)
{
 80122da:	b590      	push	{r4, r7, lr}
 80122dc:	b091      	sub	sp, #68	@ 0x44
 80122de:	af00      	add	r7, sp, #0
 80122e0:	6078      	str	r0, [r7, #4]
 80122e2:	6039      	str	r1, [r7, #0]
    int32_t w = dsc->dest_w;
 80122e4:	687b      	ldr	r3, [r7, #4]
 80122e6:	685b      	ldr	r3, [r3, #4]
 80122e8:	627b      	str	r3, [r7, #36]	@ 0x24
    int32_t h = dsc->dest_h;
 80122ea:	687b      	ldr	r3, [r7, #4]
 80122ec:	689b      	ldr	r3, [r3, #8]
 80122ee:	623b      	str	r3, [r7, #32]
    lv_opa_t opa = dsc->opa;
 80122f0:	687b      	ldr	r3, [r7, #4]
 80122f2:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 80122f6:	77fb      	strb	r3, [r7, #31]
    uint8_t * dest_buf = dsc->dest_buf;
 80122f8:	687b      	ldr	r3, [r7, #4]
 80122fa:	681b      	ldr	r3, [r3, #0]
 80122fc:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int32_t dest_stride = dsc->dest_stride;
 80122fe:	687b      	ldr	r3, [r7, #4]
 8012300:	68db      	ldr	r3, [r3, #12]
 8012302:	61bb      	str	r3, [r7, #24]
    const lv_color32_t * src_buf_c32 = dsc->src_buf;
 8012304:	687b      	ldr	r3, [r7, #4]
 8012306:	699b      	ldr	r3, [r3, #24]
 8012308:	63bb      	str	r3, [r7, #56]	@ 0x38
    int32_t src_stride = dsc->src_stride;
 801230a:	687b      	ldr	r3, [r7, #4]
 801230c:	69db      	ldr	r3, [r3, #28]
 801230e:	617b      	str	r3, [r7, #20]
    const lv_opa_t * mask_buf = dsc->mask_buf;
 8012310:	687b      	ldr	r3, [r7, #4]
 8012312:	691b      	ldr	r3, [r3, #16]
 8012314:	637b      	str	r3, [r7, #52]	@ 0x34
    int32_t mask_stride = dsc->mask_stride;
 8012316:	687b      	ldr	r3, [r7, #4]
 8012318:	695b      	ldr	r3, [r3, #20]
 801231a:	613b      	str	r3, [r7, #16]

    int32_t dest_x;
    int32_t src_x;
    int32_t y;

    if(dsc->blend_mode == LV_BLEND_MODE_NORMAL) {
 801231c:	687b      	ldr	r3, [r7, #4]
 801231e:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 8012322:	2b00      	cmp	r3, #0
 8012324:	f040 810d 	bne.w	8012542 <argb8888_image_blend+0x268>
        if(mask_buf == NULL && opa >= LV_OPA_MAX) {
 8012328:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801232a:	2b00      	cmp	r3, #0
 801232c:	d136      	bne.n	801239c <argb8888_image_blend+0xc2>
 801232e:	7ffb      	ldrb	r3, [r7, #31]
 8012330:	2bfc      	cmp	r3, #252	@ 0xfc
 8012332:	d933      	bls.n	801239c <argb8888_image_blend+0xc2>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB888(dsc, dest_px_size)) {
                for(y = 0; y < h; y++) {
 8012334:	2300      	movs	r3, #0
 8012336:	62bb      	str	r3, [r7, #40]	@ 0x28
 8012338:	e02b      	b.n	8012392 <argb8888_image_blend+0xb8>
                    for(dest_x = 0, src_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 801233a:	2300      	movs	r3, #0
 801233c:	633b      	str	r3, [r7, #48]	@ 0x30
 801233e:	2300      	movs	r3, #0
 8012340:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012342:	e015      	b.n	8012370 <argb8888_image_blend+0x96>
                        lv_color_24_24_mix((const uint8_t *)&src_buf_c32[src_x], &dest_buf[dest_x], src_buf_c32[src_x].alpha);
 8012344:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012346:	009b      	lsls	r3, r3, #2
 8012348:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801234a:	18d0      	adds	r0, r2, r3
 801234c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801234e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8012350:	18d1      	adds	r1, r2, r3
 8012352:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012354:	009b      	lsls	r3, r3, #2
 8012356:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8012358:	4413      	add	r3, r2
 801235a:	78db      	ldrb	r3, [r3, #3]
 801235c:	461a      	mov	r2, r3
 801235e:	f000 f9cf 	bl	8012700 <lv_color_24_24_mix>
                    for(dest_x = 0, src_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 8012362:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8012364:	683b      	ldr	r3, [r7, #0]
 8012366:	4413      	add	r3, r2
 8012368:	633b      	str	r3, [r7, #48]	@ 0x30
 801236a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801236c:	3301      	adds	r3, #1
 801236e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012370:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012372:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012374:	429a      	cmp	r2, r3
 8012376:	dbe5      	blt.n	8012344 <argb8888_image_blend+0x6a>
                    }
                    dest_buf += dest_stride;
 8012378:	69bb      	ldr	r3, [r7, #24]
 801237a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801237c:	4413      	add	r3, r2
 801237e:	63fb      	str	r3, [r7, #60]	@ 0x3c
                    src_buf_c32 = drawbuf_next_row(src_buf_c32, src_stride);
 8012380:	697b      	ldr	r3, [r7, #20]
 8012382:	4619      	mov	r1, r3
 8012384:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8012386:	f000 fa1c 	bl	80127c2 <drawbuf_next_row>
 801238a:	63b8      	str	r0, [r7, #56]	@ 0x38
                for(y = 0; y < h; y++) {
 801238c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801238e:	3301      	adds	r3, #1
 8012390:	62bb      	str	r3, [r7, #40]	@ 0x28
 8012392:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8012394:	6a3b      	ldr	r3, [r7, #32]
 8012396:	429a      	cmp	r2, r3
 8012398:	dbcf      	blt.n	801233a <argb8888_image_blend+0x60>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB888(dsc, dest_px_size)) {
 801239a:	e12a      	b.n	80125f2 <argb8888_image_blend+0x318>
                }
            }
        }
        else if(mask_buf == NULL && opa < LV_OPA_MAX) {
 801239c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801239e:	2b00      	cmp	r3, #0
 80123a0:	d13c      	bne.n	801241c <argb8888_image_blend+0x142>
 80123a2:	7ffb      	ldrb	r3, [r7, #31]
 80123a4:	2bfc      	cmp	r3, #252	@ 0xfc
 80123a6:	d839      	bhi.n	801241c <argb8888_image_blend+0x142>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB888_WITH_OPA(dsc, dest_px_size)) {
                for(y = 0; y < h; y++) {
 80123a8:	2300      	movs	r3, #0
 80123aa:	62bb      	str	r3, [r7, #40]	@ 0x28
 80123ac:	e031      	b.n	8012412 <argb8888_image_blend+0x138>
                    for(dest_x = 0, src_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 80123ae:	2300      	movs	r3, #0
 80123b0:	633b      	str	r3, [r7, #48]	@ 0x30
 80123b2:	2300      	movs	r3, #0
 80123b4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80123b6:	e01b      	b.n	80123f0 <argb8888_image_blend+0x116>
                        lv_color_24_24_mix((const uint8_t *)&src_buf_c32[src_x], &dest_buf[dest_x], LV_OPA_MIX2(src_buf_c32[src_x].alpha, opa));
 80123b8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80123ba:	009b      	lsls	r3, r3, #2
 80123bc:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80123be:	18d0      	adds	r0, r2, r3
 80123c0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80123c2:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80123c4:	18d1      	adds	r1, r2, r3
 80123c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80123c8:	009b      	lsls	r3, r3, #2
 80123ca:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80123cc:	4413      	add	r3, r2
 80123ce:	78db      	ldrb	r3, [r3, #3]
 80123d0:	461a      	mov	r2, r3
 80123d2:	7ffb      	ldrb	r3, [r7, #31]
 80123d4:	fb02 f303 	mul.w	r3, r2, r3
 80123d8:	121b      	asrs	r3, r3, #8
 80123da:	b2db      	uxtb	r3, r3
 80123dc:	461a      	mov	r2, r3
 80123de:	f000 f98f 	bl	8012700 <lv_color_24_24_mix>
                    for(dest_x = 0, src_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 80123e2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80123e4:	683b      	ldr	r3, [r7, #0]
 80123e6:	4413      	add	r3, r2
 80123e8:	633b      	str	r3, [r7, #48]	@ 0x30
 80123ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80123ec:	3301      	adds	r3, #1
 80123ee:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80123f0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80123f2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80123f4:	429a      	cmp	r2, r3
 80123f6:	dbdf      	blt.n	80123b8 <argb8888_image_blend+0xde>
                    }
                    dest_buf += dest_stride;
 80123f8:	69bb      	ldr	r3, [r7, #24]
 80123fa:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80123fc:	4413      	add	r3, r2
 80123fe:	63fb      	str	r3, [r7, #60]	@ 0x3c
                    src_buf_c32 = drawbuf_next_row(src_buf_c32, src_stride);
 8012400:	697b      	ldr	r3, [r7, #20]
 8012402:	4619      	mov	r1, r3
 8012404:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8012406:	f000 f9dc 	bl	80127c2 <drawbuf_next_row>
 801240a:	63b8      	str	r0, [r7, #56]	@ 0x38
                for(y = 0; y < h; y++) {
 801240c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801240e:	3301      	adds	r3, #1
 8012410:	62bb      	str	r3, [r7, #40]	@ 0x28
 8012412:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8012414:	6a3b      	ldr	r3, [r7, #32]
 8012416:	429a      	cmp	r2, r3
 8012418:	dbc9      	blt.n	80123ae <argb8888_image_blend+0xd4>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB888_WITH_OPA(dsc, dest_px_size)) {
 801241a:	e0ea      	b.n	80125f2 <argb8888_image_blend+0x318>
                }
            }
        }
        else if(mask_buf && opa >= LV_OPA_MAX) {
 801241c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801241e:	2b00      	cmp	r3, #0
 8012420:	d043      	beq.n	80124aa <argb8888_image_blend+0x1d0>
 8012422:	7ffb      	ldrb	r3, [r7, #31]
 8012424:	2bfc      	cmp	r3, #252	@ 0xfc
 8012426:	d940      	bls.n	80124aa <argb8888_image_blend+0x1d0>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB888_WITH_MASK(dsc, dest_px_size)) {
                for(y = 0; y < h; y++) {
 8012428:	2300      	movs	r3, #0
 801242a:	62bb      	str	r3, [r7, #40]	@ 0x28
 801242c:	e038      	b.n	80124a0 <argb8888_image_blend+0x1c6>
                    for(dest_x = 0, src_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 801242e:	2300      	movs	r3, #0
 8012430:	633b      	str	r3, [r7, #48]	@ 0x30
 8012432:	2300      	movs	r3, #0
 8012434:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012436:	e01e      	b.n	8012476 <argb8888_image_blend+0x19c>
                        lv_color_24_24_mix((const uint8_t *)&src_buf_c32[src_x], &dest_buf[dest_x],
 8012438:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801243a:	009b      	lsls	r3, r3, #2
 801243c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801243e:	18d0      	adds	r0, r2, r3
 8012440:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012442:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8012444:	18d1      	adds	r1, r2, r3
                                           LV_OPA_MIX2(src_buf_c32[src_x].alpha, mask_buf[src_x]));
 8012446:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012448:	009b      	lsls	r3, r3, #2
 801244a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801244c:	4413      	add	r3, r2
 801244e:	78db      	ldrb	r3, [r3, #3]
 8012450:	461c      	mov	r4, r3
 8012452:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012454:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8012456:	4413      	add	r3, r2
 8012458:	781b      	ldrb	r3, [r3, #0]
 801245a:	fb04 f303 	mul.w	r3, r4, r3
 801245e:	121b      	asrs	r3, r3, #8
                        lv_color_24_24_mix((const uint8_t *)&src_buf_c32[src_x], &dest_buf[dest_x],
 8012460:	b2db      	uxtb	r3, r3
 8012462:	461a      	mov	r2, r3
 8012464:	f000 f94c 	bl	8012700 <lv_color_24_24_mix>
                    for(dest_x = 0, src_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 8012468:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801246a:	683b      	ldr	r3, [r7, #0]
 801246c:	4413      	add	r3, r2
 801246e:	633b      	str	r3, [r7, #48]	@ 0x30
 8012470:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012472:	3301      	adds	r3, #1
 8012474:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012476:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012478:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801247a:	429a      	cmp	r2, r3
 801247c:	dbdc      	blt.n	8012438 <argb8888_image_blend+0x15e>
                    }
                    dest_buf += dest_stride;
 801247e:	69bb      	ldr	r3, [r7, #24]
 8012480:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8012482:	4413      	add	r3, r2
 8012484:	63fb      	str	r3, [r7, #60]	@ 0x3c
                    src_buf_c32 = drawbuf_next_row(src_buf_c32, src_stride);
 8012486:	697b      	ldr	r3, [r7, #20]
 8012488:	4619      	mov	r1, r3
 801248a:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801248c:	f000 f999 	bl	80127c2 <drawbuf_next_row>
 8012490:	63b8      	str	r0, [r7, #56]	@ 0x38
                    mask_buf += mask_stride;
 8012492:	693b      	ldr	r3, [r7, #16]
 8012494:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8012496:	4413      	add	r3, r2
 8012498:	637b      	str	r3, [r7, #52]	@ 0x34
                for(y = 0; y < h; y++) {
 801249a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801249c:	3301      	adds	r3, #1
 801249e:	62bb      	str	r3, [r7, #40]	@ 0x28
 80124a0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80124a2:	6a3b      	ldr	r3, [r7, #32]
 80124a4:	429a      	cmp	r2, r3
 80124a6:	dbc2      	blt.n	801242e <argb8888_image_blend+0x154>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB888_WITH_MASK(dsc, dest_px_size)) {
 80124a8:	e0a3      	b.n	80125f2 <argb8888_image_blend+0x318>
                }
            }
        }
        else if(mask_buf && opa < LV_OPA_MAX) {
 80124aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80124ac:	2b00      	cmp	r3, #0
 80124ae:	f000 80a0 	beq.w	80125f2 <argb8888_image_blend+0x318>
 80124b2:	7ffb      	ldrb	r3, [r7, #31]
 80124b4:	2bfc      	cmp	r3, #252	@ 0xfc
 80124b6:	f200 809c 	bhi.w	80125f2 <argb8888_image_blend+0x318>
            if(LV_RESULT_INVALID == LV_DRAW_SW_ARGB8888_BLEND_NORMAL_TO_RGB888_MIX_MASK_OPA(dsc, dest_px_size)) {
                for(y = 0; y < h; y++) {
 80124ba:	2300      	movs	r3, #0
 80124bc:	62bb      	str	r3, [r7, #40]	@ 0x28
 80124be:	e03b      	b.n	8012538 <argb8888_image_blend+0x25e>
                    for(dest_x = 0, src_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 80124c0:	2300      	movs	r3, #0
 80124c2:	633b      	str	r3, [r7, #48]	@ 0x30
 80124c4:	2300      	movs	r3, #0
 80124c6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80124c8:	e021      	b.n	801250e <argb8888_image_blend+0x234>
                        lv_color_24_24_mix((const uint8_t *)&src_buf_c32[src_x], &dest_buf[dest_x],
 80124ca:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80124cc:	009b      	lsls	r3, r3, #2
 80124ce:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80124d0:	18d0      	adds	r0, r2, r3
 80124d2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80124d4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80124d6:	18d1      	adds	r1, r2, r3
                                           LV_OPA_MIX3(src_buf_c32[src_x].alpha, mask_buf[src_x], opa));
 80124d8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80124da:	009b      	lsls	r3, r3, #2
 80124dc:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80124de:	4413      	add	r3, r2
 80124e0:	78db      	ldrb	r3, [r3, #3]
 80124e2:	461c      	mov	r4, r3
 80124e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80124e6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80124e8:	4413      	add	r3, r2
 80124ea:	781b      	ldrb	r3, [r3, #0]
 80124ec:	fb04 f303 	mul.w	r3, r4, r3
 80124f0:	7ffa      	ldrb	r2, [r7, #31]
 80124f2:	fb02 f303 	mul.w	r3, r2, r3
 80124f6:	141b      	asrs	r3, r3, #16
                        lv_color_24_24_mix((const uint8_t *)&src_buf_c32[src_x], &dest_buf[dest_x],
 80124f8:	b2db      	uxtb	r3, r3
 80124fa:	461a      	mov	r2, r3
 80124fc:	f000 f900 	bl	8012700 <lv_color_24_24_mix>
                    for(dest_x = 0, src_x = 0; src_x < w; dest_x += dest_px_size, src_x++) {
 8012500:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8012502:	683b      	ldr	r3, [r7, #0]
 8012504:	4413      	add	r3, r2
 8012506:	633b      	str	r3, [r7, #48]	@ 0x30
 8012508:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801250a:	3301      	adds	r3, #1
 801250c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801250e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012510:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012512:	429a      	cmp	r2, r3
 8012514:	dbd9      	blt.n	80124ca <argb8888_image_blend+0x1f0>
                    }
                    dest_buf += dest_stride;
 8012516:	69bb      	ldr	r3, [r7, #24]
 8012518:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801251a:	4413      	add	r3, r2
 801251c:	63fb      	str	r3, [r7, #60]	@ 0x3c
                    src_buf_c32 = drawbuf_next_row(src_buf_c32, src_stride);
 801251e:	697b      	ldr	r3, [r7, #20]
 8012520:	4619      	mov	r1, r3
 8012522:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8012524:	f000 f94d 	bl	80127c2 <drawbuf_next_row>
 8012528:	63b8      	str	r0, [r7, #56]	@ 0x38
                    mask_buf += mask_stride;
 801252a:	693b      	ldr	r3, [r7, #16]
 801252c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801252e:	4413      	add	r3, r2
 8012530:	637b      	str	r3, [r7, #52]	@ 0x34
                for(y = 0; y < h; y++) {
 8012532:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012534:	3301      	adds	r3, #1
 8012536:	62bb      	str	r3, [r7, #40]	@ 0x28
 8012538:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801253a:	6a3b      	ldr	r3, [r7, #32]
 801253c:	429a      	cmp	r2, r3
 801253e:	dbbf      	blt.n	80124c0 <argb8888_image_blend+0x1e6>
            if(mask_buf) mask_buf += mask_stride;
            dest_buf += dest_stride;
            src_buf_c32 = drawbuf_next_row(src_buf_c32, src_stride);
        }
    }
}
 8012540:	e057      	b.n	80125f2 <argb8888_image_blend+0x318>
        for(y = 0; y < h; y++) {
 8012542:	2300      	movs	r3, #0
 8012544:	62bb      	str	r3, [r7, #40]	@ 0x28
 8012546:	e04f      	b.n	80125e8 <argb8888_image_blend+0x30e>
            for(dest_x = 0, src_x = 0; src_x < w; dest_x += dest_px_size, src_x ++) {
 8012548:	2300      	movs	r3, #0
 801254a:	633b      	str	r3, [r7, #48]	@ 0x30
 801254c:	2300      	movs	r3, #0
 801254e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8012550:	e032      	b.n	80125b8 <argb8888_image_blend+0x2de>
                src_argb = src_buf_c32[src_x];
 8012552:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012554:	009b      	lsls	r3, r3, #2
 8012556:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8012558:	441a      	add	r2, r3
 801255a:	f107 030c 	add.w	r3, r7, #12
 801255e:	6810      	ldr	r0, [r2, #0]
 8012560:	6018      	str	r0, [r3, #0]
                if(mask_buf == NULL) src_argb.alpha = LV_OPA_MIX2(src_argb.alpha, opa);
 8012562:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8012564:	2b00      	cmp	r3, #0
 8012566:	d108      	bne.n	801257a <argb8888_image_blend+0x2a0>
 8012568:	7bfb      	ldrb	r3, [r7, #15]
 801256a:	461a      	mov	r2, r3
 801256c:	7ffb      	ldrb	r3, [r7, #31]
 801256e:	fb02 f303 	mul.w	r3, r2, r3
 8012572:	121b      	asrs	r3, r3, #8
 8012574:	b2db      	uxtb	r3, r3
 8012576:	73fb      	strb	r3, [r7, #15]
 8012578:	e00d      	b.n	8012596 <argb8888_image_blend+0x2bc>
                else src_argb.alpha = LV_OPA_MIX3(src_argb.alpha, mask_buf[dest_x], opa);
 801257a:	7bfb      	ldrb	r3, [r7, #15]
 801257c:	4619      	mov	r1, r3
 801257e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012580:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8012582:	4413      	add	r3, r2
 8012584:	781b      	ldrb	r3, [r3, #0]
 8012586:	fb01 f303 	mul.w	r3, r1, r3
 801258a:	7ffa      	ldrb	r2, [r7, #31]
 801258c:	fb02 f303 	mul.w	r3, r2, r3
 8012590:	141b      	asrs	r3, r3, #16
 8012592:	b2db      	uxtb	r3, r3
 8012594:	73fb      	strb	r3, [r7, #15]
                blend_non_normal_pixel(&dest_buf[dest_x], src_argb, dsc->blend_mode);
 8012596:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012598:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801259a:	18d0      	adds	r0, r2, r3
 801259c:	687b      	ldr	r3, [r7, #4]
 801259e:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 80125a2:	461a      	mov	r2, r3
 80125a4:	68f9      	ldr	r1, [r7, #12]
 80125a6:	f000 f829 	bl	80125fc <blend_non_normal_pixel>
            for(dest_x = 0, src_x = 0; src_x < w; dest_x += dest_px_size, src_x ++) {
 80125aa:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80125ac:	683b      	ldr	r3, [r7, #0]
 80125ae:	4413      	add	r3, r2
 80125b0:	633b      	str	r3, [r7, #48]	@ 0x30
 80125b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80125b4:	3301      	adds	r3, #1
 80125b6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80125b8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80125ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80125bc:	429a      	cmp	r2, r3
 80125be:	dbc8      	blt.n	8012552 <argb8888_image_blend+0x278>
            if(mask_buf) mask_buf += mask_stride;
 80125c0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80125c2:	2b00      	cmp	r3, #0
 80125c4:	d003      	beq.n	80125ce <argb8888_image_blend+0x2f4>
 80125c6:	693b      	ldr	r3, [r7, #16]
 80125c8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80125ca:	4413      	add	r3, r2
 80125cc:	637b      	str	r3, [r7, #52]	@ 0x34
            dest_buf += dest_stride;
 80125ce:	69bb      	ldr	r3, [r7, #24]
 80125d0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80125d2:	4413      	add	r3, r2
 80125d4:	63fb      	str	r3, [r7, #60]	@ 0x3c
            src_buf_c32 = drawbuf_next_row(src_buf_c32, src_stride);
 80125d6:	697b      	ldr	r3, [r7, #20]
 80125d8:	4619      	mov	r1, r3
 80125da:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 80125dc:	f000 f8f1 	bl	80127c2 <drawbuf_next_row>
 80125e0:	63b8      	str	r0, [r7, #56]	@ 0x38
        for(y = 0; y < h; y++) {
 80125e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80125e4:	3301      	adds	r3, #1
 80125e6:	62bb      	str	r3, [r7, #40]	@ 0x28
 80125e8:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80125ea:	6a3b      	ldr	r3, [r7, #32]
 80125ec:	429a      	cmp	r2, r3
 80125ee:	dbab      	blt.n	8012548 <argb8888_image_blend+0x26e>
}
 80125f0:	e7ff      	b.n	80125f2 <argb8888_image_blend+0x318>
 80125f2:	bf00      	nop
 80125f4:	3744      	adds	r7, #68	@ 0x44
 80125f6:	46bd      	mov	sp, r7
 80125f8:	bd90      	pop	{r4, r7, pc}
	...

080125fc <blend_non_normal_pixel>:

static inline void LV_ATTRIBUTE_FAST_MEM blend_non_normal_pixel(uint8_t * dest, lv_color32_t src, lv_blend_mode_t mode)
{
 80125fc:	b580      	push	{r7, lr}
 80125fe:	b086      	sub	sp, #24
 8012600:	af00      	add	r7, sp, #0
 8012602:	60f8      	str	r0, [r7, #12]
 8012604:	60b9      	str	r1, [r7, #8]
 8012606:	4613      	mov	r3, r2
 8012608:	71fb      	strb	r3, [r7, #7]
    uint8_t res[3] = {0, 0, 0};
 801260a:	4a3c      	ldr	r2, [pc, #240]	@ (80126fc <blend_non_normal_pixel+0x100>)
 801260c:	f107 0314 	add.w	r3, r7, #20
 8012610:	6812      	ldr	r2, [r2, #0]
 8012612:	4611      	mov	r1, r2
 8012614:	8019      	strh	r1, [r3, #0]
 8012616:	3302      	adds	r3, #2
 8012618:	0c12      	lsrs	r2, r2, #16
 801261a:	701a      	strb	r2, [r3, #0]
    switch(mode) {
 801261c:	79fb      	ldrb	r3, [r7, #7]
 801261e:	2b03      	cmp	r3, #3
 8012620:	d045      	beq.n	80126ae <blend_non_normal_pixel+0xb2>
 8012622:	2b03      	cmp	r3, #3
 8012624:	dc66      	bgt.n	80126f4 <blend_non_normal_pixel+0xf8>
 8012626:	2b01      	cmp	r3, #1
 8012628:	d002      	beq.n	8012630 <blend_non_normal_pixel+0x34>
 801262a:	2b02      	cmp	r3, #2
 801262c:	d021      	beq.n	8012672 <blend_non_normal_pixel+0x76>
            res[1] = (dest[1] * src.green) >> 8;
            res[2] = (dest[2] * src.red) >> 8;
            break;
        default:
            LV_LOG_WARN("Not supported blend mode: %d", mode);
            return;
 801262e:	e061      	b.n	80126f4 <blend_non_normal_pixel+0xf8>
            res[0] = LV_MIN(dest[0] + src.blue, 255);
 8012630:	68fb      	ldr	r3, [r7, #12]
 8012632:	781b      	ldrb	r3, [r3, #0]
 8012634:	461a      	mov	r2, r3
 8012636:	7a3b      	ldrb	r3, [r7, #8]
 8012638:	4413      	add	r3, r2
 801263a:	2bff      	cmp	r3, #255	@ 0xff
 801263c:	bfa8      	it	ge
 801263e:	23ff      	movge	r3, #255	@ 0xff
 8012640:	b2db      	uxtb	r3, r3
 8012642:	753b      	strb	r3, [r7, #20]
            res[1] = LV_MIN(dest[1] + src.green, 255);
 8012644:	68fb      	ldr	r3, [r7, #12]
 8012646:	3301      	adds	r3, #1
 8012648:	781b      	ldrb	r3, [r3, #0]
 801264a:	461a      	mov	r2, r3
 801264c:	7a7b      	ldrb	r3, [r7, #9]
 801264e:	4413      	add	r3, r2
 8012650:	2bff      	cmp	r3, #255	@ 0xff
 8012652:	bfa8      	it	ge
 8012654:	23ff      	movge	r3, #255	@ 0xff
 8012656:	b2db      	uxtb	r3, r3
 8012658:	757b      	strb	r3, [r7, #21]
            res[2] = LV_MIN(dest[2] + src.red, 255);
 801265a:	68fb      	ldr	r3, [r7, #12]
 801265c:	3302      	adds	r3, #2
 801265e:	781b      	ldrb	r3, [r3, #0]
 8012660:	461a      	mov	r2, r3
 8012662:	7abb      	ldrb	r3, [r7, #10]
 8012664:	4413      	add	r3, r2
 8012666:	2bff      	cmp	r3, #255	@ 0xff
 8012668:	bfa8      	it	ge
 801266a:	23ff      	movge	r3, #255	@ 0xff
 801266c:	b2db      	uxtb	r3, r3
 801266e:	75bb      	strb	r3, [r7, #22]
            break;
 8012670:	e038      	b.n	80126e4 <blend_non_normal_pixel+0xe8>
            res[0] = LV_MAX(dest[0] - src.blue, 0);
 8012672:	68fb      	ldr	r3, [r7, #12]
 8012674:	781b      	ldrb	r3, [r3, #0]
 8012676:	461a      	mov	r2, r3
 8012678:	7a3b      	ldrb	r3, [r7, #8]
 801267a:	1ad3      	subs	r3, r2, r3
 801267c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8012680:	b2db      	uxtb	r3, r3
 8012682:	753b      	strb	r3, [r7, #20]
            res[1] = LV_MAX(dest[1] - src.green, 0);
 8012684:	68fb      	ldr	r3, [r7, #12]
 8012686:	3301      	adds	r3, #1
 8012688:	781b      	ldrb	r3, [r3, #0]
 801268a:	461a      	mov	r2, r3
 801268c:	7a7b      	ldrb	r3, [r7, #9]
 801268e:	1ad3      	subs	r3, r2, r3
 8012690:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8012694:	b2db      	uxtb	r3, r3
 8012696:	757b      	strb	r3, [r7, #21]
            res[2] = LV_MAX(dest[2] - src.red, 0);
 8012698:	68fb      	ldr	r3, [r7, #12]
 801269a:	3302      	adds	r3, #2
 801269c:	781b      	ldrb	r3, [r3, #0]
 801269e:	461a      	mov	r2, r3
 80126a0:	7abb      	ldrb	r3, [r7, #10]
 80126a2:	1ad3      	subs	r3, r2, r3
 80126a4:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 80126a8:	b2db      	uxtb	r3, r3
 80126aa:	75bb      	strb	r3, [r7, #22]
            break;
 80126ac:	e01a      	b.n	80126e4 <blend_non_normal_pixel+0xe8>
            res[0] = (dest[0] * src.blue) >> 8;
 80126ae:	68fb      	ldr	r3, [r7, #12]
 80126b0:	781b      	ldrb	r3, [r3, #0]
 80126b2:	7a3a      	ldrb	r2, [r7, #8]
 80126b4:	fb02 f303 	mul.w	r3, r2, r3
 80126b8:	121b      	asrs	r3, r3, #8
 80126ba:	b2db      	uxtb	r3, r3
 80126bc:	753b      	strb	r3, [r7, #20]
            res[1] = (dest[1] * src.green) >> 8;
 80126be:	68fb      	ldr	r3, [r7, #12]
 80126c0:	3301      	adds	r3, #1
 80126c2:	781b      	ldrb	r3, [r3, #0]
 80126c4:	7a7a      	ldrb	r2, [r7, #9]
 80126c6:	fb02 f303 	mul.w	r3, r2, r3
 80126ca:	121b      	asrs	r3, r3, #8
 80126cc:	b2db      	uxtb	r3, r3
 80126ce:	757b      	strb	r3, [r7, #21]
            res[2] = (dest[2] * src.red) >> 8;
 80126d0:	68fb      	ldr	r3, [r7, #12]
 80126d2:	3302      	adds	r3, #2
 80126d4:	781b      	ldrb	r3, [r3, #0]
 80126d6:	7aba      	ldrb	r2, [r7, #10]
 80126d8:	fb02 f303 	mul.w	r3, r2, r3
 80126dc:	121b      	asrs	r3, r3, #8
 80126de:	b2db      	uxtb	r3, r3
 80126e0:	75bb      	strb	r3, [r7, #22]
            break;
 80126e2:	bf00      	nop
    }
    lv_color_24_24_mix(res, dest, src.alpha);
 80126e4:	7afa      	ldrb	r2, [r7, #11]
 80126e6:	f107 0314 	add.w	r3, r7, #20
 80126ea:	68f9      	ldr	r1, [r7, #12]
 80126ec:	4618      	mov	r0, r3
 80126ee:	f000 f807 	bl	8012700 <lv_color_24_24_mix>
 80126f2:	e000      	b.n	80126f6 <blend_non_normal_pixel+0xfa>
            return;
 80126f4:	bf00      	nop
}
 80126f6:	3718      	adds	r7, #24
 80126f8:	46bd      	mov	sp, r7
 80126fa:	bd80      	pop	{r7, pc}
 80126fc:	08027b90 	.word	0x08027b90

08012700 <lv_color_24_24_mix>:

static inline void LV_ATTRIBUTE_FAST_MEM lv_color_24_24_mix(const uint8_t * src, uint8_t * dest, uint8_t mix)
{
 8012700:	b480      	push	{r7}
 8012702:	b087      	sub	sp, #28
 8012704:	af00      	add	r7, sp, #0
 8012706:	60f8      	str	r0, [r7, #12]
 8012708:	60b9      	str	r1, [r7, #8]
 801270a:	4613      	mov	r3, r2
 801270c:	71fb      	strb	r3, [r7, #7]

    if(mix == 0) return;
 801270e:	79fb      	ldrb	r3, [r7, #7]
 8012710:	2b00      	cmp	r3, #0
 8012712:	d050      	beq.n	80127b6 <lv_color_24_24_mix+0xb6>

    if(mix >= LV_OPA_MAX) {
 8012714:	79fb      	ldrb	r3, [r7, #7]
 8012716:	2bfc      	cmp	r3, #252	@ 0xfc
 8012718:	d910      	bls.n	801273c <lv_color_24_24_mix+0x3c>
        dest[0] = src[0];
 801271a:	68fb      	ldr	r3, [r7, #12]
 801271c:	781a      	ldrb	r2, [r3, #0]
 801271e:	68bb      	ldr	r3, [r7, #8]
 8012720:	701a      	strb	r2, [r3, #0]
        dest[1] = src[1];
 8012722:	68fb      	ldr	r3, [r7, #12]
 8012724:	1c5a      	adds	r2, r3, #1
 8012726:	68bb      	ldr	r3, [r7, #8]
 8012728:	3301      	adds	r3, #1
 801272a:	7812      	ldrb	r2, [r2, #0]
 801272c:	701a      	strb	r2, [r3, #0]
        dest[2] = src[2];
 801272e:	68fb      	ldr	r3, [r7, #12]
 8012730:	1c9a      	adds	r2, r3, #2
 8012732:	68bb      	ldr	r3, [r7, #8]
 8012734:	3302      	adds	r3, #2
 8012736:	7812      	ldrb	r2, [r2, #0]
 8012738:	701a      	strb	r2, [r3, #0]
 801273a:	e03d      	b.n	80127b8 <lv_color_24_24_mix+0xb8>
    }
    else {
        lv_opa_t mix_inv = 255 - mix;
 801273c:	79fb      	ldrb	r3, [r7, #7]
 801273e:	43db      	mvns	r3, r3
 8012740:	75fb      	strb	r3, [r7, #23]
        dest[0] = (uint32_t)((uint32_t)src[0] * mix + dest[0] * mix_inv) >> 8;
 8012742:	68fb      	ldr	r3, [r7, #12]
 8012744:	781b      	ldrb	r3, [r3, #0]
 8012746:	461a      	mov	r2, r3
 8012748:	79fb      	ldrb	r3, [r7, #7]
 801274a:	fb02 f303 	mul.w	r3, r2, r3
 801274e:	68ba      	ldr	r2, [r7, #8]
 8012750:	7812      	ldrb	r2, [r2, #0]
 8012752:	4611      	mov	r1, r2
 8012754:	7dfa      	ldrb	r2, [r7, #23]
 8012756:	fb01 f202 	mul.w	r2, r1, r2
 801275a:	4413      	add	r3, r2
 801275c:	0a1b      	lsrs	r3, r3, #8
 801275e:	b2da      	uxtb	r2, r3
 8012760:	68bb      	ldr	r3, [r7, #8]
 8012762:	701a      	strb	r2, [r3, #0]
        dest[1] = (uint32_t)((uint32_t)src[1] * mix + dest[1] * mix_inv) >> 8;
 8012764:	68fb      	ldr	r3, [r7, #12]
 8012766:	3301      	adds	r3, #1
 8012768:	781b      	ldrb	r3, [r3, #0]
 801276a:	461a      	mov	r2, r3
 801276c:	79fb      	ldrb	r3, [r7, #7]
 801276e:	fb02 f303 	mul.w	r3, r2, r3
 8012772:	68ba      	ldr	r2, [r7, #8]
 8012774:	3201      	adds	r2, #1
 8012776:	7812      	ldrb	r2, [r2, #0]
 8012778:	4611      	mov	r1, r2
 801277a:	7dfa      	ldrb	r2, [r7, #23]
 801277c:	fb01 f202 	mul.w	r2, r1, r2
 8012780:	4413      	add	r3, r2
 8012782:	0a1a      	lsrs	r2, r3, #8
 8012784:	68bb      	ldr	r3, [r7, #8]
 8012786:	3301      	adds	r3, #1
 8012788:	b2d2      	uxtb	r2, r2
 801278a:	701a      	strb	r2, [r3, #0]
        dest[2] = (uint32_t)((uint32_t)src[2] * mix + dest[2] * mix_inv) >> 8;
 801278c:	68fb      	ldr	r3, [r7, #12]
 801278e:	3302      	adds	r3, #2
 8012790:	781b      	ldrb	r3, [r3, #0]
 8012792:	461a      	mov	r2, r3
 8012794:	79fb      	ldrb	r3, [r7, #7]
 8012796:	fb02 f303 	mul.w	r3, r2, r3
 801279a:	68ba      	ldr	r2, [r7, #8]
 801279c:	3202      	adds	r2, #2
 801279e:	7812      	ldrb	r2, [r2, #0]
 80127a0:	4611      	mov	r1, r2
 80127a2:	7dfa      	ldrb	r2, [r7, #23]
 80127a4:	fb01 f202 	mul.w	r2, r1, r2
 80127a8:	4413      	add	r3, r2
 80127aa:	0a1a      	lsrs	r2, r3, #8
 80127ac:	68bb      	ldr	r3, [r7, #8]
 80127ae:	3302      	adds	r3, #2
 80127b0:	b2d2      	uxtb	r2, r2
 80127b2:	701a      	strb	r2, [r3, #0]
 80127b4:	e000      	b.n	80127b8 <lv_color_24_24_mix+0xb8>
    if(mix == 0) return;
 80127b6:	bf00      	nop
    }
}
 80127b8:	371c      	adds	r7, #28
 80127ba:	46bd      	mov	sp, r7
 80127bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80127c0:	4770      	bx	lr

080127c2 <drawbuf_next_row>:

static inline void * LV_ATTRIBUTE_FAST_MEM drawbuf_next_row(const void * buf, uint32_t stride)
{
 80127c2:	b480      	push	{r7}
 80127c4:	b083      	sub	sp, #12
 80127c6:	af00      	add	r7, sp, #0
 80127c8:	6078      	str	r0, [r7, #4]
 80127ca:	6039      	str	r1, [r7, #0]
    return (void *)((uint8_t *)buf + stride);
 80127cc:	687a      	ldr	r2, [r7, #4]
 80127ce:	683b      	ldr	r3, [r7, #0]
 80127d0:	4413      	add	r3, r2
}
 80127d2:	4618      	mov	r0, r3
 80127d4:	370c      	adds	r7, #12
 80127d6:	46bd      	mov	sp, r7
 80127d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80127dc:	4770      	bx	lr
	...

080127e0 <lv_draw_sw_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_sw_init(void)
{
 80127e0:	b580      	push	{r7, lr}
 80127e2:	b082      	sub	sp, #8
 80127e4:	af00      	add	r7, sp, #0

#if LV_DRAW_SW_COMPLEX == 1
    lv_draw_sw_mask_init();
 80127e6:	f005 fcb7 	bl	8018158 <lv_draw_sw_mask_init>
#endif

    uint32_t i;
    for(i = 0; i < LV_DRAW_SW_DRAW_UNIT_CNT; i++) {
 80127ea:	2300      	movs	r3, #0
 80127ec:	607b      	str	r3, [r7, #4]
 80127ee:	e012      	b.n	8012816 <lv_draw_sw_init+0x36>
        lv_draw_sw_unit_t * draw_sw_unit = lv_draw_create_unit(sizeof(lv_draw_sw_unit_t));
 80127f0:	2020      	movs	r0, #32
 80127f2:	f7f8 fe1d 	bl	800b430 <lv_draw_create_unit>
 80127f6:	6038      	str	r0, [r7, #0]
        draw_sw_unit->base_unit.dispatch_cb = dispatch;
 80127f8:	683b      	ldr	r3, [r7, #0]
 80127fa:	4a0b      	ldr	r2, [pc, #44]	@ (8012828 <lv_draw_sw_init+0x48>)
 80127fc:	60da      	str	r2, [r3, #12]
        draw_sw_unit->base_unit.evaluate_cb = evaluate;
 80127fe:	683b      	ldr	r3, [r7, #0]
 8012800:	4a0a      	ldr	r2, [pc, #40]	@ (801282c <lv_draw_sw_init+0x4c>)
 8012802:	611a      	str	r2, [r3, #16]
        draw_sw_unit->idx = i;
 8012804:	683b      	ldr	r3, [r7, #0]
 8012806:	687a      	ldr	r2, [r7, #4]
 8012808:	61da      	str	r2, [r3, #28]
        draw_sw_unit->base_unit.delete_cb = LV_USE_OS ? lv_draw_sw_delete : NULL;
 801280a:	683b      	ldr	r3, [r7, #0]
 801280c:	2200      	movs	r2, #0
 801280e:	615a      	str	r2, [r3, #20]
    for(i = 0; i < LV_DRAW_SW_DRAW_UNIT_CNT; i++) {
 8012810:	687b      	ldr	r3, [r7, #4]
 8012812:	3301      	adds	r3, #1
 8012814:	607b      	str	r3, [r7, #4]
 8012816:	687b      	ldr	r3, [r7, #4]
 8012818:	2b00      	cmp	r3, #0
 801281a:	d0e9      	beq.n	80127f0 <lv_draw_sw_init+0x10>
    }

#if LV_USE_VECTOR_GRAPHIC && LV_USE_THORVG
    tvg_engine_init(TVG_ENGINE_SW, 0);
#endif
}
 801281c:	bf00      	nop
 801281e:	bf00      	nop
 8012820:	3708      	adds	r7, #8
 8012822:	46bd      	mov	sp, r7
 8012824:	bd80      	pop	{r7, pc}
 8012826:	bf00      	nop
 8012828:	0801291d 	.word	0x0801291d
 801282c:	08012859 	.word	0x08012859

08012830 <execute_drawing_unit>:

/**********************
 *   STATIC FUNCTIONS
 **********************/
static inline void execute_drawing_unit(lv_draw_sw_unit_t * u)
{
 8012830:	b580      	push	{r7, lr}
 8012832:	b082      	sub	sp, #8
 8012834:	af00      	add	r7, sp, #0
 8012836:	6078      	str	r0, [r7, #4]
    execute_drawing(u);
 8012838:	6878      	ldr	r0, [r7, #4]
 801283a:	f000 f8ab 	bl	8012994 <execute_drawing>

    u->task_act->state = LV_DRAW_TASK_STATE_READY;
 801283e:	687b      	ldr	r3, [r7, #4]
 8012840:	699b      	ldr	r3, [r3, #24]
 8012842:	2203      	movs	r2, #3
 8012844:	649a      	str	r2, [r3, #72]	@ 0x48
    u->task_act = NULL;
 8012846:	687b      	ldr	r3, [r7, #4]
 8012848:	2200      	movs	r2, #0
 801284a:	619a      	str	r2, [r3, #24]

    /*The draw unit is free now. Request a new dispatching as it can get a new task*/
    lv_draw_dispatch_request();
 801284c:	f7f8 ffe0 	bl	800b810 <lv_draw_dispatch_request>
}
 8012850:	bf00      	nop
 8012852:	3708      	adds	r7, #8
 8012854:	46bd      	mov	sp, r7
 8012856:	bd80      	pop	{r7, pc}

08012858 <evaluate>:

static int32_t evaluate(lv_draw_unit_t * draw_unit, lv_draw_task_t * task)
{
 8012858:	b480      	push	{r7}
 801285a:	b085      	sub	sp, #20
 801285c:	af00      	add	r7, sp, #0
 801285e:	6078      	str	r0, [r7, #4]
 8012860:	6039      	str	r1, [r7, #0]
    LV_UNUSED(draw_unit);

    switch(task->type) {
 8012862:	683b      	ldr	r3, [r7, #0]
 8012864:	791b      	ldrb	r3, [r3, #4]
 8012866:	3b04      	subs	r3, #4
 8012868:	2b01      	cmp	r3, #1
 801286a:	d840      	bhi.n	80128ee <evaluate+0x96>
        case LV_DRAW_TASK_TYPE_IMAGE:
        case LV_DRAW_TASK_TYPE_LAYER: {
                lv_draw_image_dsc_t * draw_dsc = task->draw_dsc;
 801286c:	683b      	ldr	r3, [r7, #0]
 801286e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8012870:	60fb      	str	r3, [r7, #12]

                /* not support skew */
                if(draw_dsc->skew_x != 0 || draw_dsc->skew_y != 0) {
 8012872:	68fb      	ldr	r3, [r7, #12]
 8012874:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012876:	2b00      	cmp	r3, #0
 8012878:	d103      	bne.n	8012882 <evaluate+0x2a>
 801287a:	68fb      	ldr	r3, [r7, #12]
 801287c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801287e:	2b00      	cmp	r3, #0
 8012880:	d001      	beq.n	8012886 <evaluate+0x2e>
                    return 0;
 8012882:	2300      	movs	r3, #0
 8012884:	e044      	b.n	8012910 <evaluate+0xb8>
                }

                bool transformed = draw_dsc->rotation != 0 || draw_dsc->scale_x != LV_SCALE_NONE ||
 8012886:	68fb      	ldr	r3, [r7, #12]
 8012888:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
                                   draw_dsc->scale_y != LV_SCALE_NONE ? true : false;
 801288a:	2b00      	cmp	r3, #0
 801288c:	d109      	bne.n	80128a2 <evaluate+0x4a>
                bool transformed = draw_dsc->rotation != 0 || draw_dsc->scale_x != LV_SCALE_NONE ||
 801288e:	68fb      	ldr	r3, [r7, #12]
 8012890:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8012892:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8012896:	d104      	bne.n	80128a2 <evaluate+0x4a>
                                   draw_dsc->scale_y != LV_SCALE_NONE ? true : false;
 8012898:	68fb      	ldr	r3, [r7, #12]
 801289a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801289c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80128a0:	d001      	beq.n	80128a6 <evaluate+0x4e>
 80128a2:	2301      	movs	r3, #1
 80128a4:	e000      	b.n	80128a8 <evaluate+0x50>
 80128a6:	2300      	movs	r3, #0
                bool transformed = draw_dsc->rotation != 0 || draw_dsc->scale_x != LV_SCALE_NONE ||
 80128a8:	72fb      	strb	r3, [r7, #11]
 80128aa:	7afb      	ldrb	r3, [r7, #11]
 80128ac:	f003 0301 	and.w	r3, r3, #1
 80128b0:	72fb      	strb	r3, [r7, #11]

                bool masked = draw_dsc->bitmap_mask_src != NULL;
 80128b2:	68fb      	ldr	r3, [r7, #12]
 80128b4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80128b6:	2b00      	cmp	r3, #0
 80128b8:	bf14      	ite	ne
 80128ba:	2301      	movne	r3, #1
 80128bc:	2300      	moveq	r3, #0
 80128be:	72bb      	strb	r3, [r7, #10]
                if(masked && transformed)  return 0;
 80128c0:	7abb      	ldrb	r3, [r7, #10]
 80128c2:	2b00      	cmp	r3, #0
 80128c4:	d004      	beq.n	80128d0 <evaluate+0x78>
 80128c6:	7afb      	ldrb	r3, [r7, #11]
 80128c8:	2b00      	cmp	r3, #0
 80128ca:	d001      	beq.n	80128d0 <evaluate+0x78>
 80128cc:	2300      	movs	r3, #0
 80128ce:	e01f      	b.n	8012910 <evaluate+0xb8>

                lv_color_format_t cf = draw_dsc->header.cf;
 80128d0:	68fb      	ldr	r3, [r7, #12]
 80128d2:	f893 3021 	ldrb.w	r3, [r3, #33]	@ 0x21
 80128d6:	727b      	strb	r3, [r7, #9]
                if(masked && (cf == LV_COLOR_FORMAT_A8 || cf == LV_COLOR_FORMAT_RGB565A8)) {
 80128d8:	7abb      	ldrb	r3, [r7, #10]
 80128da:	2b00      	cmp	r3, #0
 80128dc:	d009      	beq.n	80128f2 <evaluate+0x9a>
 80128de:	7a7b      	ldrb	r3, [r7, #9]
 80128e0:	2b0e      	cmp	r3, #14
 80128e2:	d002      	beq.n	80128ea <evaluate+0x92>
 80128e4:	7a7b      	ldrb	r3, [r7, #9]
 80128e6:	2b14      	cmp	r3, #20
 80128e8:	d103      	bne.n	80128f2 <evaluate+0x9a>
                    return 0;
 80128ea:	2300      	movs	r3, #0
 80128ec:	e010      	b.n	8012910 <evaluate+0xb8>
                }
            }
            break;
        default:
            break;
 80128ee:	bf00      	nop
 80128f0:	e000      	b.n	80128f4 <evaluate+0x9c>
            break;
 80128f2:	bf00      	nop
    }

    if(task->preference_score >= 100) {
 80128f4:	683b      	ldr	r3, [r7, #0]
 80128f6:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 80128fa:	2b63      	cmp	r3, #99	@ 0x63
 80128fc:	d907      	bls.n	801290e <evaluate+0xb6>
        task->preference_score = 100;
 80128fe:	683b      	ldr	r3, [r7, #0]
 8012900:	2264      	movs	r2, #100	@ 0x64
 8012902:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
        task->preferred_draw_unit_id = DRAW_UNIT_ID_SW;
 8012906:	683b      	ldr	r3, [r7, #0]
 8012908:	2201      	movs	r2, #1
 801290a:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
    }

    return 0;
 801290e:	2300      	movs	r3, #0
}
 8012910:	4618      	mov	r0, r3
 8012912:	3714      	adds	r7, #20
 8012914:	46bd      	mov	sp, r7
 8012916:	f85d 7b04 	ldr.w	r7, [sp], #4
 801291a:	4770      	bx	lr

0801291c <dispatch>:

static int32_t dispatch(lv_draw_unit_t * draw_unit, lv_layer_t * layer)
{
 801291c:	b580      	push	{r7, lr}
 801291e:	b086      	sub	sp, #24
 8012920:	af00      	add	r7, sp, #0
 8012922:	6078      	str	r0, [r7, #4]
 8012924:	6039      	str	r1, [r7, #0]
    LV_PROFILER_BEGIN;
    lv_draw_sw_unit_t * draw_sw_unit = (lv_draw_sw_unit_t *) draw_unit;
 8012926:	687b      	ldr	r3, [r7, #4]
 8012928:	617b      	str	r3, [r7, #20]

    /*Return immediately if it's busy with draw task*/
    if(draw_sw_unit->task_act) {
 801292a:	697b      	ldr	r3, [r7, #20]
 801292c:	699b      	ldr	r3, [r3, #24]
 801292e:	2b00      	cmp	r3, #0
 8012930:	d001      	beq.n	8012936 <dispatch+0x1a>
        LV_PROFILER_END;
        return 0;
 8012932:	2300      	movs	r3, #0
 8012934:	e029      	b.n	801298a <dispatch+0x6e>
    }

    lv_draw_task_t * t = NULL;
 8012936:	2300      	movs	r3, #0
 8012938:	613b      	str	r3, [r7, #16]
    t = lv_draw_get_next_available_task(layer, NULL, DRAW_UNIT_ID_SW);
 801293a:	2201      	movs	r2, #1
 801293c:	2100      	movs	r1, #0
 801293e:	6838      	ldr	r0, [r7, #0]
 8012940:	f7f8 ff74 	bl	800b82c <lv_draw_get_next_available_task>
 8012944:	6138      	str	r0, [r7, #16]
    if(t == NULL) {
 8012946:	693b      	ldr	r3, [r7, #16]
 8012948:	2b00      	cmp	r3, #0
 801294a:	d102      	bne.n	8012952 <dispatch+0x36>
        LV_PROFILER_END;
        return -1;
 801294c:	f04f 33ff 	mov.w	r3, #4294967295
 8012950:	e01b      	b.n	801298a <dispatch+0x6e>
    }

    void * buf = lv_draw_layer_alloc_buf(layer);
 8012952:	6838      	ldr	r0, [r7, #0]
 8012954:	f7f8 ffce 	bl	800b8f4 <lv_draw_layer_alloc_buf>
 8012958:	60f8      	str	r0, [r7, #12]
    if(buf == NULL) {
 801295a:	68fb      	ldr	r3, [r7, #12]
 801295c:	2b00      	cmp	r3, #0
 801295e:	d102      	bne.n	8012966 <dispatch+0x4a>
        LV_PROFILER_END;
        return -1;
 8012960:	f04f 33ff 	mov.w	r3, #4294967295
 8012964:	e011      	b.n	801298a <dispatch+0x6e>
    }

    t->state = LV_DRAW_TASK_STATE_IN_PROGRESS;
 8012966:	693b      	ldr	r3, [r7, #16]
 8012968:	2202      	movs	r2, #2
 801296a:	649a      	str	r2, [r3, #72]	@ 0x48
    draw_sw_unit->base_unit.target_layer = layer;
 801296c:	697b      	ldr	r3, [r7, #20]
 801296e:	683a      	ldr	r2, [r7, #0]
 8012970:	605a      	str	r2, [r3, #4]
    draw_sw_unit->base_unit.clip_area = &t->clip_area;
 8012972:	693b      	ldr	r3, [r7, #16]
 8012974:	f103 0238 	add.w	r2, r3, #56	@ 0x38
 8012978:	697b      	ldr	r3, [r7, #20]
 801297a:	609a      	str	r2, [r3, #8]
    draw_sw_unit->task_act = t;
 801297c:	697b      	ldr	r3, [r7, #20]
 801297e:	693a      	ldr	r2, [r7, #16]
 8012980:	619a      	str	r2, [r3, #24]

#if LV_USE_OS
    /*Let the render thread work*/
    if(draw_sw_unit->inited) lv_thread_sync_signal(&draw_sw_unit->sync);
#else
    execute_drawing_unit(draw_sw_unit);
 8012982:	6978      	ldr	r0, [r7, #20]
 8012984:	f7ff ff54 	bl	8012830 <execute_drawing_unit>
#endif
    LV_PROFILER_END;
    return 1;
 8012988:	2301      	movs	r3, #1
}
 801298a:	4618      	mov	r0, r3
 801298c:	3718      	adds	r7, #24
 801298e:	46bd      	mov	sp, r7
 8012990:	bd80      	pop	{r7, pc}
	...

08012994 <execute_drawing>:
    LV_LOG_INFO("exit software rendering thread");
}
#endif

static void execute_drawing(lv_draw_sw_unit_t * u)
{
 8012994:	b580      	push	{r7, lr}
 8012996:	b084      	sub	sp, #16
 8012998:	af00      	add	r7, sp, #0
 801299a:	6078      	str	r0, [r7, #4]
    LV_PROFILER_BEGIN;
    /*Render the draw task*/
    lv_draw_task_t * t = u->task_act;
 801299c:	687b      	ldr	r3, [r7, #4]
 801299e:	699b      	ldr	r3, [r3, #24]
 80129a0:	60fb      	str	r3, [r7, #12]
    switch(t->type) {
 80129a2:	68fb      	ldr	r3, [r7, #12]
 80129a4:	791b      	ldrb	r3, [r3, #4]
 80129a6:	2b09      	cmp	r3, #9
 80129a8:	d86c      	bhi.n	8012a84 <execute_drawing+0xf0>
 80129aa:	a201      	add	r2, pc, #4	@ (adr r2, 80129b0 <execute_drawing+0x1c>)
 80129ac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80129b0:	080129d9 	.word	0x080129d9
 80129b4:	080129eb 	.word	0x080129eb
 80129b8:	080129fd 	.word	0x080129fd
 80129bc:	08012a0f 	.word	0x08012a0f
 80129c0:	08012a21 	.word	0x08012a21
 80129c4:	08012a61 	.word	0x08012a61
 80129c8:	08012a45 	.word	0x08012a45
 80129cc:	08012a33 	.word	0x08012a33
 80129d0:	08012a53 	.word	0x08012a53
 80129d4:	08012a73 	.word	0x08012a73
        case LV_DRAW_TASK_TYPE_FILL:
            lv_draw_sw_fill((lv_draw_unit_t *)u, t->draw_dsc, &t->area);
 80129d8:	68fb      	ldr	r3, [r7, #12]
 80129da:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 80129dc:	68fb      	ldr	r3, [r7, #12]
 80129de:	3308      	adds	r3, #8
 80129e0:	461a      	mov	r2, r3
 80129e2:	6878      	ldr	r0, [r7, #4]
 80129e4:	f003 f883 	bl	8015aee <lv_draw_sw_fill>
            break;
 80129e8:	e04d      	b.n	8012a86 <execute_drawing+0xf2>
        case LV_DRAW_TASK_TYPE_BORDER:
            lv_draw_sw_border((lv_draw_unit_t *)u, t->draw_dsc, &t->area);
 80129ea:	68fb      	ldr	r3, [r7, #12]
 80129ec:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 80129ee:	68fb      	ldr	r3, [r7, #12]
 80129f0:	3308      	adds	r3, #8
 80129f2:	461a      	mov	r2, r3
 80129f4:	6878      	ldr	r0, [r7, #4]
 80129f6:	f000 fe0a 	bl	801360e <lv_draw_sw_border>
            break;
 80129fa:	e044      	b.n	8012a86 <execute_drawing+0xf2>
        case LV_DRAW_TASK_TYPE_BOX_SHADOW:
            lv_draw_sw_box_shadow((lv_draw_unit_t *)u, t->draw_dsc, &t->area);
 80129fc:	68fb      	ldr	r3, [r7, #12]
 80129fe:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 8012a00:	68fb      	ldr	r3, [r7, #12]
 8012a02:	3308      	adds	r3, #8
 8012a04:	461a      	mov	r2, r3
 8012a06:	6878      	ldr	r0, [r7, #4]
 8012a08:	f001 fabc 	bl	8013f84 <lv_draw_sw_box_shadow>
            break;
 8012a0c:	e03b      	b.n	8012a86 <execute_drawing+0xf2>
        case LV_DRAW_TASK_TYPE_LABEL:
            lv_draw_sw_label((lv_draw_unit_t *)u, t->draw_dsc, &t->area);
 8012a0e:	68fb      	ldr	r3, [r7, #12]
 8012a10:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 8012a12:	68fb      	ldr	r3, [r7, #12]
 8012a14:	3308      	adds	r3, #8
 8012a16:	461a      	mov	r2, r3
 8012a18:	6878      	ldr	r0, [r7, #4]
 8012a1a:	f004 fc39 	bl	8017290 <lv_draw_sw_label>
            break;
 8012a1e:	e032      	b.n	8012a86 <execute_drawing+0xf2>
        case LV_DRAW_TASK_TYPE_IMAGE:
            lv_draw_sw_image((lv_draw_unit_t *)u, t->draw_dsc, &t->area);
 8012a20:	68fb      	ldr	r3, [r7, #12]
 8012a22:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 8012a24:	68fb      	ldr	r3, [r7, #12]
 8012a26:	3308      	adds	r3, #8
 8012a28:	461a      	mov	r2, r3
 8012a2a:	6878      	ldr	r0, [r7, #4]
 8012a2c:	f003 fdec 	bl	8016608 <lv_draw_sw_image>
            break;
 8012a30:	e029      	b.n	8012a86 <execute_drawing+0xf2>
        case LV_DRAW_TASK_TYPE_ARC:
            lv_draw_sw_arc((lv_draw_unit_t *)u, t->draw_dsc, &t->area);
 8012a32:	68fb      	ldr	r3, [r7, #12]
 8012a34:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 8012a36:	68fb      	ldr	r3, [r7, #12]
 8012a38:	3308      	adds	r3, #8
 8012a3a:	461a      	mov	r2, r3
 8012a3c:	6878      	ldr	r0, [r7, #4]
 8012a3e:	f000 f881 	bl	8012b44 <lv_draw_sw_arc>
            break;
 8012a42:	e020      	b.n	8012a86 <execute_drawing+0xf2>
        case LV_DRAW_TASK_TYPE_LINE:
            lv_draw_sw_line((lv_draw_unit_t *)u, t->draw_dsc);
 8012a44:	68fb      	ldr	r3, [r7, #12]
 8012a46:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8012a48:	4619      	mov	r1, r3
 8012a4a:	6878      	ldr	r0, [r7, #4]
 8012a4c:	f004 fd05 	bl	801745a <lv_draw_sw_line>
            break;
 8012a50:	e019      	b.n	8012a86 <execute_drawing+0xf2>
        case LV_DRAW_TASK_TYPE_TRIANGLE:
            lv_draw_sw_triangle((lv_draw_unit_t *)u, t->draw_dsc);
 8012a52:	68fb      	ldr	r3, [r7, #12]
 8012a54:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8012a56:	4619      	mov	r1, r3
 8012a58:	6878      	ldr	r0, [r7, #4]
 8012a5a:	f008 ffbb 	bl	801b9d4 <lv_draw_sw_triangle>
            break;
 8012a5e:	e012      	b.n	8012a86 <execute_drawing+0xf2>
        case LV_DRAW_TASK_TYPE_LAYER:
            lv_draw_sw_layer((lv_draw_unit_t *)u, t->draw_dsc, &t->area);
 8012a60:	68fb      	ldr	r3, [r7, #12]
 8012a62:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 8012a64:	68fb      	ldr	r3, [r7, #12]
 8012a66:	3308      	adds	r3, #8
 8012a68:	461a      	mov	r2, r3
 8012a6a:	6878      	ldr	r0, [r7, #4]
 8012a6c:	f003 fda7 	bl	80165be <lv_draw_sw_layer>
            break;
 8012a70:	e009      	b.n	8012a86 <execute_drawing+0xf2>
        case LV_DRAW_TASK_TYPE_MASK_RECTANGLE:
            lv_draw_sw_mask_rect((lv_draw_unit_t *)u, t->draw_dsc, &t->area);
 8012a72:	68fb      	ldr	r3, [r7, #12]
 8012a74:	6cd9      	ldr	r1, [r3, #76]	@ 0x4c
 8012a76:	68fb      	ldr	r3, [r7, #12]
 8012a78:	3308      	adds	r3, #8
 8012a7a:	461a      	mov	r2, r3
 8012a7c:	6878      	ldr	r0, [r7, #4]
 8012a7e:	f007 fb8a 	bl	801a196 <lv_draw_sw_mask_rect>
            break;
 8012a82:	e000      	b.n	8012a86 <execute_drawing+0xf2>
        case LV_DRAW_TASK_TYPE_VECTOR:
            lv_draw_sw_vector((lv_draw_unit_t *)u, t->draw_dsc);
            break;
#endif
        default:
            break;
 8012a84:	bf00      	nop
        label_dsc.text = buf;
        lv_draw_sw_label((lv_draw_unit_t *)u, &label_dsc, &txt_area);
    }
#endif
    LV_PROFILER_END;
}
 8012a86:	bf00      	nop
 8012a88:	3710      	adds	r7, #16
 8012a8a:	46bd      	mov	sp, r7
 8012a8c:	bd80      	pop	{r7, pc}
 8012a8e:	bf00      	nop

08012a90 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 8012a90:	b480      	push	{r7}
 8012a92:	b083      	sub	sp, #12
 8012a94:	af00      	add	r7, sp, #0
 8012a96:	6078      	str	r0, [r7, #4]
 8012a98:	6039      	str	r1, [r7, #0]
    dest->x1 = src->x1;
 8012a9a:	683b      	ldr	r3, [r7, #0]
 8012a9c:	681a      	ldr	r2, [r3, #0]
 8012a9e:	687b      	ldr	r3, [r7, #4]
 8012aa0:	601a      	str	r2, [r3, #0]
    dest->y1 = src->y1;
 8012aa2:	683b      	ldr	r3, [r7, #0]
 8012aa4:	685a      	ldr	r2, [r3, #4]
 8012aa6:	687b      	ldr	r3, [r7, #4]
 8012aa8:	605a      	str	r2, [r3, #4]
    dest->x2 = src->x2;
 8012aaa:	683b      	ldr	r3, [r7, #0]
 8012aac:	689a      	ldr	r2, [r3, #8]
 8012aae:	687b      	ldr	r3, [r7, #4]
 8012ab0:	609a      	str	r2, [r3, #8]
    dest->y2 = src->y2;
 8012ab2:	683b      	ldr	r3, [r7, #0]
 8012ab4:	68da      	ldr	r2, [r3, #12]
 8012ab6:	687b      	ldr	r3, [r7, #4]
 8012ab8:	60da      	str	r2, [r3, #12]
}
 8012aba:	bf00      	nop
 8012abc:	370c      	adds	r7, #12
 8012abe:	46bd      	mov	sp, r7
 8012ac0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012ac4:	4770      	bx	lr

08012ac6 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline int32_t lv_area_get_width(const lv_area_t * area_p)
{
 8012ac6:	b480      	push	{r7}
 8012ac8:	b083      	sub	sp, #12
 8012aca:	af00      	add	r7, sp, #0
 8012acc:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 8012ace:	687b      	ldr	r3, [r7, #4]
 8012ad0:	689a      	ldr	r2, [r3, #8]
 8012ad2:	687b      	ldr	r3, [r7, #4]
 8012ad4:	681b      	ldr	r3, [r3, #0]
 8012ad6:	1ad3      	subs	r3, r2, r3
 8012ad8:	3301      	adds	r3, #1
}
 8012ada:	4618      	mov	r0, r3
 8012adc:	370c      	adds	r7, #12
 8012ade:	46bd      	mov	sp, r7
 8012ae0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012ae4:	4770      	bx	lr

08012ae6 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline int32_t lv_area_get_height(const lv_area_t * area_p)
{
 8012ae6:	b480      	push	{r7}
 8012ae8:	b083      	sub	sp, #12
 8012aea:	af00      	add	r7, sp, #0
 8012aec:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 8012aee:	687b      	ldr	r3, [r7, #4]
 8012af0:	68da      	ldr	r2, [r3, #12]
 8012af2:	687b      	ldr	r3, [r7, #4]
 8012af4:	685b      	ldr	r3, [r3, #4]
 8012af6:	1ad3      	subs	r3, r2, r3
 8012af8:	3301      	adds	r3, #1
}
 8012afa:	4618      	mov	r0, r3
 8012afc:	370c      	adds	r7, #12
 8012afe:	46bd      	mov	sp, r7
 8012b00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012b04:	4770      	bx	lr

08012b06 <lv_trigo_cos>:
 * @return sinus of 'angle'. sin(-90) = -32767, sin(90) = 32767
 */
int32_t /* LV_ATTRIBUTE_FAST_MEM */ lv_trigo_sin(int16_t angle);

static inline int32_t LV_ATTRIBUTE_FAST_MEM lv_trigo_cos(int16_t angle)
{
 8012b06:	b580      	push	{r7, lr}
 8012b08:	b082      	sub	sp, #8
 8012b0a:	af00      	add	r7, sp, #0
 8012b0c:	4603      	mov	r3, r0
 8012b0e:	80fb      	strh	r3, [r7, #6]
    return lv_trigo_sin(angle + 90);
 8012b10:	88fb      	ldrh	r3, [r7, #6]
 8012b12:	335a      	adds	r3, #90	@ 0x5a
 8012b14:	b29b      	uxth	r3, r3
 8012b16:	b21b      	sxth	r3, r3
 8012b18:	4618      	mov	r0, r3
 8012b1a:	f010 fbe3 	bl	80232e4 <lv_trigo_sin>
 8012b1e:	4603      	mov	r3, r0
}
 8012b20:	4618      	mov	r0, r3
 8012b22:	3708      	adds	r7, #8
 8012b24:	46bd      	mov	sp, r7
 8012b26:	bd80      	pop	{r7, pc}

08012b28 <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 8012b28:	b580      	push	{r7, lr}
 8012b2a:	b082      	sub	sp, #8
 8012b2c:	af00      	add	r7, sp, #0
 8012b2e:	6078      	str	r0, [r7, #4]
 8012b30:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 8012b32:	683a      	ldr	r2, [r7, #0]
 8012b34:	2100      	movs	r1, #0
 8012b36:	6878      	ldr	r0, [r7, #4]
 8012b38:	f012 f973 	bl	8024e22 <lv_memset>
}
 8012b3c:	bf00      	nop
 8012b3e:	3708      	adds	r7, #8
 8012b40:	46bd      	mov	sp, r7
 8012b42:	bd80      	pop	{r7, pc}

08012b44 <lv_draw_sw_arc>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_sw_arc(lv_draw_unit_t * draw_unit, const lv_draw_arc_dsc_t * dsc, const lv_area_t * coords)
{
 8012b44:	b590      	push	{r4, r7, lr}
 8012b46:	f5ad 7d13 	sub.w	sp, sp, #588	@ 0x24c
 8012b4a:	af02      	add	r7, sp, #8
 8012b4c:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012b50:	f5a3 730d 	sub.w	r3, r3, #564	@ 0x234
 8012b54:	6018      	str	r0, [r3, #0]
 8012b56:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012b5a:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012b5e:	6019      	str	r1, [r3, #0]
 8012b60:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012b64:	f5a3 730f 	sub.w	r3, r3, #572	@ 0x23c
 8012b68:	601a      	str	r2, [r3, #0]
#if LV_DRAW_SW_COMPLEX
    if(dsc->opa <= LV_OPA_MIN) return;
 8012b6a:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012b6e:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012b72:	681b      	ldr	r3, [r3, #0]
 8012b74:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8012b78:	2b02      	cmp	r3, #2
 8012b7a:	f240 8422 	bls.w	80133c2 <lv_draw_sw_arc+0x87e>
    if(dsc->width == 0) return;
 8012b7e:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012b82:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012b86:	681b      	ldr	r3, [r3, #0]
 8012b88:	6a1b      	ldr	r3, [r3, #32]
 8012b8a:	2b00      	cmp	r3, #0
 8012b8c:	f000 841b 	beq.w	80133c6 <lv_draw_sw_arc+0x882>
    if(dsc->start_angle == dsc->end_angle) return;
 8012b90:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012b94:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012b98:	681b      	ldr	r3, [r3, #0]
 8012b9a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8012b9c:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012ba0:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012ba4:	681b      	ldr	r3, [r3, #0]
 8012ba6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012ba8:	429a      	cmp	r2, r3
 8012baa:	f000 840e 	beq.w	80133ca <lv_draw_sw_arc+0x886>

    int32_t width = dsc->width;
 8012bae:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012bb2:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012bb6:	681b      	ldr	r3, [r3, #0]
 8012bb8:	6a1b      	ldr	r3, [r3, #32]
 8012bba:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
    if(width > dsc->radius) width = dsc->radius;
 8012bbe:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012bc2:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012bc6:	681b      	ldr	r3, [r3, #0]
 8012bc8:	8e9b      	ldrh	r3, [r3, #52]	@ 0x34
 8012bca:	461a      	mov	r2, r3
 8012bcc:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8012bd0:	4293      	cmp	r3, r2
 8012bd2:	dd07      	ble.n	8012be4 <lv_draw_sw_arc+0xa0>
 8012bd4:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012bd8:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012bdc:	681b      	ldr	r3, [r3, #0]
 8012bde:	8e9b      	ldrh	r3, [r3, #52]	@ 0x34
 8012be0:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c

    lv_area_t area_out = *coords;
 8012be4:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012be8:	f5a3 730f 	sub.w	r3, r3, #572	@ 0x23c
 8012bec:	681b      	ldr	r3, [r3, #0]
 8012bee:	f507 7400 	add.w	r4, r7, #512	@ 0x200
 8012bf2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8012bf4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    lv_area_t clipped_area;
    if(!_lv_area_intersect(&clipped_area, &area_out, draw_unit->clip_area)) return;
 8012bf8:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012bfc:	f5a3 730d 	sub.w	r3, r3, #564	@ 0x234
 8012c00:	681b      	ldr	r3, [r3, #0]
 8012c02:	689a      	ldr	r2, [r3, #8]
 8012c04:	f507 7100 	add.w	r1, r7, #512	@ 0x200
 8012c08:	f507 73f8 	add.w	r3, r7, #496	@ 0x1f0
 8012c0c:	4618      	mov	r0, r3
 8012c0e:	f00e fe9b 	bl	8021948 <_lv_area_intersect>
 8012c12:	4603      	mov	r3, r0
 8012c14:	f083 0301 	eor.w	r3, r3, #1
 8012c18:	b2db      	uxtb	r3, r3
 8012c1a:	2b00      	cmp	r3, #0
 8012c1c:	f040 83d7 	bne.w	80133ce <lv_draw_sw_arc+0x88a>

    /*Draw a full ring*/
    if(dsc->img_src == NULL &&
 8012c20:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012c24:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012c28:	681b      	ldr	r3, [r3, #0]
 8012c2a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012c2c:	2b00      	cmp	r3, #0
 8012c2e:	d167      	bne.n	8012d00 <lv_draw_sw_arc+0x1bc>
       (dsc->start_angle + 360 == dsc->end_angle || dsc->start_angle == dsc->end_angle + 360)) {
 8012c30:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012c34:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012c38:	681b      	ldr	r3, [r3, #0]
 8012c3a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012c3c:	f503 72b4 	add.w	r2, r3, #360	@ 0x168
 8012c40:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012c44:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012c48:	681b      	ldr	r3, [r3, #0]
 8012c4a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
    if(dsc->img_src == NULL &&
 8012c4c:	429a      	cmp	r2, r3
 8012c4e:	d00f      	beq.n	8012c70 <lv_draw_sw_arc+0x12c>
       (dsc->start_angle + 360 == dsc->end_angle || dsc->start_angle == dsc->end_angle + 360)) {
 8012c50:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012c54:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012c58:	681b      	ldr	r3, [r3, #0]
 8012c5a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8012c5c:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012c60:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012c64:	681b      	ldr	r3, [r3, #0]
 8012c66:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012c68:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 8012c6c:	429a      	cmp	r2, r3
 8012c6e:	d147      	bne.n	8012d00 <lv_draw_sw_arc+0x1bc>
        lv_draw_border_dsc_t cir_dsc;
        lv_draw_border_dsc_init(&cir_dsc);
 8012c70:	f107 0310 	add.w	r3, r7, #16
 8012c74:	4618      	mov	r0, r3
 8012c76:	f7fb f862 	bl	800dd3e <lv_draw_border_dsc_init>
        cir_dsc.opa = dsc->opa;
 8012c7a:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012c7e:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012c82:	681b      	ldr	r3, [r3, #0]
 8012c84:	f893 203c 	ldrb.w	r2, [r3, #60]	@ 0x3c
 8012c88:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012c8c:	f5a3 730c 	sub.w	r3, r3, #560	@ 0x230
 8012c90:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
        cir_dsc.color = dsc->color;
 8012c94:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012c98:	f5a3 730c 	sub.w	r3, r3, #560	@ 0x230
 8012c9c:	f507 7210 	add.w	r2, r7, #576	@ 0x240
 8012ca0:	f5a2 720e 	sub.w	r2, r2, #568	@ 0x238
 8012ca4:	6812      	ldr	r2, [r2, #0]
 8012ca6:	3320      	adds	r3, #32
 8012ca8:	321c      	adds	r2, #28
 8012caa:	6812      	ldr	r2, [r2, #0]
 8012cac:	4611      	mov	r1, r2
 8012cae:	8019      	strh	r1, [r3, #0]
 8012cb0:	3302      	adds	r3, #2
 8012cb2:	0c12      	lsrs	r2, r2, #16
 8012cb4:	701a      	strb	r2, [r3, #0]
        cir_dsc.width = width;
 8012cb6:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012cba:	f5a3 730c 	sub.w	r3, r3, #560	@ 0x230
 8012cbe:	f8d7 223c 	ldr.w	r2, [r7, #572]	@ 0x23c
 8012cc2:	625a      	str	r2, [r3, #36]	@ 0x24
        cir_dsc.radius = LV_RADIUS_CIRCLE;
 8012cc4:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012cc8:	f5a3 730c 	sub.w	r3, r3, #560	@ 0x230
 8012ccc:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 8012cd0:	61da      	str	r2, [r3, #28]
        cir_dsc.side = LV_BORDER_SIDE_FULL;
 8012cd2:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012cd6:	f5a3 720c 	sub.w	r2, r3, #560	@ 0x230
 8012cda:	f892 3029 	ldrb.w	r3, [r2, #41]	@ 0x29
 8012cde:	210f      	movs	r1, #15
 8012ce0:	f361 0304 	bfi	r3, r1, #0, #5
 8012ce4:	f882 3029 	strb.w	r3, [r2, #41]	@ 0x29
        lv_draw_sw_border(draw_unit, &cir_dsc, &area_out);
 8012ce8:	f507 7200 	add.w	r2, r7, #512	@ 0x200
 8012cec:	f107 0110 	add.w	r1, r7, #16
 8012cf0:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012cf4:	f5a3 730d 	sub.w	r3, r3, #564	@ 0x234
 8012cf8:	6818      	ldr	r0, [r3, #0]
 8012cfa:	f000 fc88 	bl	801360e <lv_draw_sw_border>
 8012cfe:	e367      	b.n	80133d0 <lv_draw_sw_arc+0x88c>
        return;
    }

    lv_area_t area_in;
    lv_area_copy(&area_in, &area_out);
 8012d00:	f507 7200 	add.w	r2, r7, #512	@ 0x200
 8012d04:	f507 73f0 	add.w	r3, r7, #480	@ 0x1e0
 8012d08:	4611      	mov	r1, r2
 8012d0a:	4618      	mov	r0, r3
 8012d0c:	f7ff fec0 	bl	8012a90 <lv_area_copy>
    area_in.x1 += dsc->width;
 8012d10:	f8d7 21e0 	ldr.w	r2, [r7, #480]	@ 0x1e0
 8012d14:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012d18:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012d1c:	681b      	ldr	r3, [r3, #0]
 8012d1e:	6a1b      	ldr	r3, [r3, #32]
 8012d20:	4413      	add	r3, r2
 8012d22:	f8c7 31e0 	str.w	r3, [r7, #480]	@ 0x1e0
    area_in.y1 += dsc->width;
 8012d26:	f8d7 21e4 	ldr.w	r2, [r7, #484]	@ 0x1e4
 8012d2a:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012d2e:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012d32:	681b      	ldr	r3, [r3, #0]
 8012d34:	6a1b      	ldr	r3, [r3, #32]
 8012d36:	4413      	add	r3, r2
 8012d38:	f8c7 31e4 	str.w	r3, [r7, #484]	@ 0x1e4
    area_in.x2 -= dsc->width;
 8012d3c:	f8d7 21e8 	ldr.w	r2, [r7, #488]	@ 0x1e8
 8012d40:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012d44:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012d48:	681b      	ldr	r3, [r3, #0]
 8012d4a:	6a1b      	ldr	r3, [r3, #32]
 8012d4c:	1ad3      	subs	r3, r2, r3
 8012d4e:	f8c7 31e8 	str.w	r3, [r7, #488]	@ 0x1e8
    area_in.y2 -= dsc->width;
 8012d52:	f8d7 21ec 	ldr.w	r2, [r7, #492]	@ 0x1ec
 8012d56:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012d5a:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012d5e:	681b      	ldr	r3, [r3, #0]
 8012d60:	6a1b      	ldr	r3, [r3, #32]
 8012d62:	1ad3      	subs	r3, r2, r3
 8012d64:	f8c7 31ec 	str.w	r3, [r7, #492]	@ 0x1ec

    int32_t start_angle = (int32_t)dsc->start_angle;
 8012d68:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012d6c:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012d70:	681b      	ldr	r3, [r3, #0]
 8012d72:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8012d74:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
    int32_t end_angle = (int32_t)dsc->end_angle;
 8012d78:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012d7c:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012d80:	681b      	ldr	r3, [r3, #0]
 8012d82:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012d84:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
    while(start_angle >= 360) start_angle -= 360;
 8012d88:	e005      	b.n	8012d96 <lv_draw_sw_arc+0x252>
 8012d8a:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8012d8e:	f5a3 73b4 	sub.w	r3, r3, #360	@ 0x168
 8012d92:	f8c7 3238 	str.w	r3, [r7, #568]	@ 0x238
 8012d96:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8012d9a:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 8012d9e:	daf4      	bge.n	8012d8a <lv_draw_sw_arc+0x246>
    while(end_angle >= 360) end_angle -= 360;
 8012da0:	e005      	b.n	8012dae <lv_draw_sw_arc+0x26a>
 8012da2:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8012da6:	f5a3 73b4 	sub.w	r3, r3, #360	@ 0x168
 8012daa:	f8c7 3234 	str.w	r3, [r7, #564]	@ 0x234
 8012dae:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8012db2:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 8012db6:	daf4      	bge.n	8012da2 <lv_draw_sw_arc+0x25e>

    void * mask_list[4] = {0};
 8012db8:	f507 73e8 	add.w	r3, r7, #464	@ 0x1d0
 8012dbc:	2200      	movs	r2, #0
 8012dbe:	601a      	str	r2, [r3, #0]
 8012dc0:	605a      	str	r2, [r3, #4]
 8012dc2:	609a      	str	r2, [r3, #8]
 8012dc4:	60da      	str	r2, [r3, #12]
    /*Create an angle mask*/
    lv_draw_sw_mask_angle_param_t mask_angle_param;
    lv_draw_sw_mask_angle_init(&mask_angle_param, dsc->center.x, dsc->center.y, start_angle, end_angle);
 8012dc6:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012dca:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012dce:	681b      	ldr	r3, [r3, #0]
 8012dd0:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8012dd2:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012dd6:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012dda:	681b      	ldr	r3, [r3, #0]
 8012ddc:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012dde:	f507 70a2 	add.w	r0, r7, #324	@ 0x144
 8012de2:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8012de6:	9300      	str	r3, [sp, #0]
 8012de8:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 8012dec:	f005 fb94 	bl	8018518 <lv_draw_sw_mask_angle_init>
    mask_list[0] = &mask_angle_param;
 8012df0:	f507 73a2 	add.w	r3, r7, #324	@ 0x144
 8012df4:	f8c7 31d0 	str.w	r3, [r7, #464]	@ 0x1d0

    /*Create an outer mask*/
    lv_draw_sw_mask_radius_param_t mask_out_param;
    lv_draw_sw_mask_radius_init(&mask_out_param, &area_out, LV_RADIUS_CIRCLE, false);
 8012df8:	f507 7100 	add.w	r1, r7, #512	@ 0x200
 8012dfc:	f507 7090 	add.w	r0, r7, #288	@ 0x120
 8012e00:	2300      	movs	r3, #0
 8012e02:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 8012e06:	f005 fc27 	bl	8018658 <lv_draw_sw_mask_radius_init>
    mask_list[1] = &mask_out_param;
 8012e0a:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 8012e0e:	f8c7 31d4 	str.w	r3, [r7, #468]	@ 0x1d4

    /*Create inner the mask*/
    lv_draw_sw_mask_radius_param_t mask_in_param;
    bool mask_in_param_valid = false;
 8012e12:	2300      	movs	r3, #0
 8012e14:	f887 3233 	strb.w	r3, [r7, #563]	@ 0x233
    if(lv_area_get_width(&area_in) > 0 && lv_area_get_height(&area_in) > 0) {
 8012e18:	f507 73f0 	add.w	r3, r7, #480	@ 0x1e0
 8012e1c:	4618      	mov	r0, r3
 8012e1e:	f7ff fe52 	bl	8012ac6 <lv_area_get_width>
 8012e22:	4603      	mov	r3, r0
 8012e24:	2b00      	cmp	r3, #0
 8012e26:	dd17      	ble.n	8012e58 <lv_draw_sw_arc+0x314>
 8012e28:	f507 73f0 	add.w	r3, r7, #480	@ 0x1e0
 8012e2c:	4618      	mov	r0, r3
 8012e2e:	f7ff fe5a 	bl	8012ae6 <lv_area_get_height>
 8012e32:	4603      	mov	r3, r0
 8012e34:	2b00      	cmp	r3, #0
 8012e36:	dd0f      	ble.n	8012e58 <lv_draw_sw_arc+0x314>
        lv_draw_sw_mask_radius_init(&mask_in_param, &area_in, LV_RADIUS_CIRCLE, true);
 8012e38:	f507 71f0 	add.w	r1, r7, #480	@ 0x1e0
 8012e3c:	f107 00fc 	add.w	r0, r7, #252	@ 0xfc
 8012e40:	2301      	movs	r3, #1
 8012e42:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 8012e46:	f005 fc07 	bl	8018658 <lv_draw_sw_mask_radius_init>
        mask_list[2] = &mask_in_param;
 8012e4a:	f107 03fc 	add.w	r3, r7, #252	@ 0xfc
 8012e4e:	f8c7 31d8 	str.w	r3, [r7, #472]	@ 0x1d8
        mask_in_param_valid = true;
 8012e52:	2301      	movs	r3, #1
 8012e54:	f887 3233 	strb.w	r3, [r7, #563]	@ 0x233
    }

    int32_t blend_h = lv_area_get_height(&clipped_area);
 8012e58:	f507 73f8 	add.w	r3, r7, #496	@ 0x1f0
 8012e5c:	4618      	mov	r0, r3
 8012e5e:	f7ff fe42 	bl	8012ae6 <lv_area_get_height>
 8012e62:	f8c7 0220 	str.w	r0, [r7, #544]	@ 0x220
    int32_t blend_w = lv_area_get_width(&clipped_area);
 8012e66:	f507 73f8 	add.w	r3, r7, #496	@ 0x1f0
 8012e6a:	4618      	mov	r0, r3
 8012e6c:	f7ff fe2b 	bl	8012ac6 <lv_area_get_width>
 8012e70:	f8c7 021c 	str.w	r0, [r7, #540]	@ 0x21c
    int32_t h;
    lv_opa_t * mask_buf = lv_malloc(blend_w);
 8012e74:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 8012e78:	4618      	mov	r0, r3
 8012e7a:	f012 ffa5 	bl	8025dc8 <lv_malloc>
 8012e7e:	f8c7 0218 	str.w	r0, [r7, #536]	@ 0x218

    lv_area_t blend_area = clipped_area;
 8012e82:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012e86:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 8012e8a:	461c      	mov	r4, r3
 8012e8c:	f507 73f8 	add.w	r3, r7, #496	@ 0x1f0
 8012e90:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8012e92:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    lv_area_t img_area;
    lv_draw_sw_blend_dsc_t blend_dsc = {0};
 8012e96:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012e9a:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 8012e9e:	4618      	mov	r0, r3
 8012ea0:	232c      	movs	r3, #44	@ 0x2c
 8012ea2:	461a      	mov	r2, r3
 8012ea4:	2100      	movs	r1, #0
 8012ea6:	f014 fe1d 	bl	8027ae4 <memset>
    blend_dsc.mask_buf = mask_buf;
 8012eaa:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012eae:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 8012eb2:	f8d7 2218 	ldr.w	r2, [r7, #536]	@ 0x218
 8012eb6:	619a      	str	r2, [r3, #24]
    blend_dsc.opa = dsc->opa;
 8012eb8:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012ebc:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012ec0:	681b      	ldr	r3, [r3, #0]
 8012ec2:	f893 203c 	ldrb.w	r2, [r3, #60]	@ 0x3c
 8012ec6:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012eca:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 8012ece:	751a      	strb	r2, [r3, #20]
    blend_dsc.blend_area = &blend_area;
 8012ed0:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012ed4:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 8012ed8:	f107 02ec 	add.w	r2, r7, #236	@ 0xec
 8012edc:	601a      	str	r2, [r3, #0]
    blend_dsc.mask_area = &blend_area;
 8012ede:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012ee2:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 8012ee6:	f107 02ec 	add.w	r2, r7, #236	@ 0xec
 8012eea:	621a      	str	r2, [r3, #32]
    lv_image_decoder_dsc_t decoder_dsc;
    if(dsc->img_src == NULL) {
 8012eec:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012ef0:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012ef4:	681b      	ldr	r3, [r3, #0]
 8012ef6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012ef8:	2b00      	cmp	r3, #0
 8012efa:	d10f      	bne.n	8012f1c <lv_draw_sw_arc+0x3d8>
        blend_dsc.color = dsc->color;
 8012efc:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012f00:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 8012f04:	f507 7210 	add.w	r2, r7, #576	@ 0x240
 8012f08:	f5a2 720e 	sub.w	r2, r2, #568	@ 0x238
 8012f0c:	6812      	ldr	r2, [r2, #0]
 8012f0e:	3315      	adds	r3, #21
 8012f10:	321c      	adds	r2, #28
 8012f12:	8811      	ldrh	r1, [r2, #0]
 8012f14:	7892      	ldrb	r2, [r2, #2]
 8012f16:	8019      	strh	r1, [r3, #0]
 8012f18:	709a      	strb	r2, [r3, #2]
 8012f1a:	e079      	b.n	8013010 <lv_draw_sw_arc+0x4cc>
    }
    else {
        lv_image_decoder_open(&decoder_dsc, dsc->img_src, NULL);
 8012f1c:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012f20:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012f24:	681b      	ldr	r3, [r3, #0]
 8012f26:	6b99      	ldr	r1, [r3, #56]	@ 0x38
 8012f28:	f107 0374 	add.w	r3, r7, #116	@ 0x74
 8012f2c:	2200      	movs	r2, #0
 8012f2e:	4618      	mov	r0, r3
 8012f30:	f7fb faf0 	bl	800e514 <lv_image_decoder_open>
        img_area.x1 = 0;
 8012f34:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012f38:	f5a3 73b2 	sub.w	r3, r3, #356	@ 0x164
 8012f3c:	2200      	movs	r2, #0
 8012f3e:	601a      	str	r2, [r3, #0]
        img_area.y1 = 0;
 8012f40:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012f44:	f5a3 73b2 	sub.w	r3, r3, #356	@ 0x164
 8012f48:	2200      	movs	r2, #0
 8012f4a:	605a      	str	r2, [r3, #4]
        img_area.x2 = decoder_dsc.decoded->header.w - 1;
 8012f4c:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012f50:	f5a3 73e6 	sub.w	r3, r3, #460	@ 0x1cc
 8012f54:	69db      	ldr	r3, [r3, #28]
 8012f56:	889b      	ldrh	r3, [r3, #4]
 8012f58:	1e5a      	subs	r2, r3, #1
 8012f5a:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012f5e:	f5a3 73b2 	sub.w	r3, r3, #356	@ 0x164
 8012f62:	609a      	str	r2, [r3, #8]
        img_area.y2 = decoder_dsc.decoded->header.h - 1;
 8012f64:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012f68:	f5a3 73e6 	sub.w	r3, r3, #460	@ 0x1cc
 8012f6c:	69db      	ldr	r3, [r3, #28]
 8012f6e:	88db      	ldrh	r3, [r3, #6]
 8012f70:	1e5a      	subs	r2, r3, #1
 8012f72:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012f76:	f5a3 73b2 	sub.w	r3, r3, #356	@ 0x164
 8012f7a:	60da      	str	r2, [r3, #12]
        int32_t ofs = decoder_dsc.decoded->header.w / 2;
 8012f7c:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012f80:	f5a3 73e6 	sub.w	r3, r3, #460	@ 0x1cc
 8012f84:	69db      	ldr	r3, [r3, #28]
 8012f86:	889b      	ldrh	r3, [r3, #4]
 8012f88:	085b      	lsrs	r3, r3, #1
 8012f8a:	b29b      	uxth	r3, r3
 8012f8c:	f8c7 3214 	str.w	r3, [r7, #532]	@ 0x214
        lv_area_move(&img_area, dsc->center.x - ofs, dsc->center.y - ofs);
 8012f90:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012f94:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012f98:	681b      	ldr	r3, [r3, #0]
 8012f9a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8012f9c:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8012fa0:	1ad1      	subs	r1, r2, r3
 8012fa2:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012fa6:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8012faa:	681b      	ldr	r3, [r3, #0]
 8012fac:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8012fae:	f8d7 3214 	ldr.w	r3, [r7, #532]	@ 0x214
 8012fb2:	1ad2      	subs	r2, r2, r3
 8012fb4:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8012fb8:	4618      	mov	r0, r3
 8012fba:	f00e fca1 	bl	8021900 <lv_area_move>
        blend_dsc.src_area = &img_area;
 8012fbe:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012fc2:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 8012fc6:	f107 02dc 	add.w	r2, r7, #220	@ 0xdc
 8012fca:	611a      	str	r2, [r3, #16]
        blend_dsc.src_buf = decoder_dsc.decoded->data;
 8012fcc:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012fd0:	f5a3 73e6 	sub.w	r3, r3, #460	@ 0x1cc
 8012fd4:	69db      	ldr	r3, [r3, #28]
 8012fd6:	691a      	ldr	r2, [r3, #16]
 8012fd8:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012fdc:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 8012fe0:	605a      	str	r2, [r3, #4]
        blend_dsc.src_color_format = decoder_dsc.decoded->header.cf;
 8012fe2:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012fe6:	f5a3 73e6 	sub.w	r3, r3, #460	@ 0x1cc
 8012fea:	69db      	ldr	r3, [r3, #28]
 8012fec:	785a      	ldrb	r2, [r3, #1]
 8012fee:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012ff2:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 8012ff6:	731a      	strb	r2, [r3, #12]
        blend_dsc.src_stride = decoder_dsc.decoded->header.stride;
 8012ff8:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8012ffc:	f5a3 73e6 	sub.w	r3, r3, #460	@ 0x1cc
 8013000:	69db      	ldr	r3, [r3, #28]
 8013002:	891b      	ldrh	r3, [r3, #8]
 8013004:	461a      	mov	r2, r3
 8013006:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 801300a:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 801300e:	609a      	str	r2, [r3, #8]
    }

    lv_opa_t * circle_mask = NULL;
 8013010:	2300      	movs	r3, #0
 8013012:	f8c7 3228 	str.w	r3, [r7, #552]	@ 0x228
    lv_area_t round_area_1;
    lv_area_t round_area_2;
    if(dsc->rounded) {
 8013016:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 801301a:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 801301e:	681b      	ldr	r3, [r3, #0]
 8013020:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8013024:	f003 0301 	and.w	r3, r3, #1
 8013028:	b2db      	uxtb	r3, r3
 801302a:	2b00      	cmp	r3, #0
 801302c:	f000 80c1 	beq.w	80131b2 <lv_draw_sw_arc+0x66e>
        circle_mask = lv_malloc(width * width);
 8013030:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8013034:	fb03 f303 	mul.w	r3, r3, r3
 8013038:	4618      	mov	r0, r3
 801303a:	f012 fec5 	bl	8025dc8 <lv_malloc>
 801303e:	f8c7 0228 	str.w	r0, [r7, #552]	@ 0x228
        lv_memset(circle_mask, 0xff, width * width);
 8013042:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8013046:	fb03 f303 	mul.w	r3, r3, r3
 801304a:	461a      	mov	r2, r3
 801304c:	21ff      	movs	r1, #255	@ 0xff
 801304e:	f8d7 0228 	ldr.w	r0, [r7, #552]	@ 0x228
 8013052:	f011 fee6 	bl	8024e22 <lv_memset>
        lv_area_t circle_area = {0, 0, width - 1, width - 1};
 8013056:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 801305a:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
 801305e:	2200      	movs	r2, #0
 8013060:	601a      	str	r2, [r3, #0]
 8013062:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013066:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
 801306a:	2200      	movs	r2, #0
 801306c:	605a      	str	r2, [r3, #4]
 801306e:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8013072:	1e5a      	subs	r2, r3, #1
 8013074:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013078:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
 801307c:	609a      	str	r2, [r3, #8]
 801307e:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8013082:	1e5a      	subs	r2, r3, #1
 8013084:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013088:	f5a3 73fe 	sub.w	r3, r3, #508	@ 0x1fc
 801308c:	60da      	str	r2, [r3, #12]
        lv_draw_sw_mask_radius_param_t circle_mask_param;
        lv_draw_sw_mask_radius_init(&circle_mask_param, &circle_area, width / 2, false);
 801308e:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8013092:	0fda      	lsrs	r2, r3, #31
 8013094:	4413      	add	r3, r2
 8013096:	105b      	asrs	r3, r3, #1
 8013098:	461a      	mov	r2, r3
 801309a:	f107 0144 	add.w	r1, r7, #68	@ 0x44
 801309e:	f107 0010 	add.w	r0, r7, #16
 80130a2:	2300      	movs	r3, #0
 80130a4:	f005 fad8 	bl	8018658 <lv_draw_sw_mask_radius_init>
        void * circle_mask_list[2] = {&circle_mask_param, NULL};
 80130a8:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80130ac:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 80130b0:	f107 0210 	add.w	r2, r7, #16
 80130b4:	601a      	str	r2, [r3, #0]
 80130b6:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80130ba:	f5a3 7301 	sub.w	r3, r3, #516	@ 0x204
 80130be:	2200      	movs	r2, #0
 80130c0:	605a      	str	r2, [r3, #4]

        lv_opa_t * circle_mask_tmp = circle_mask;
 80130c2:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80130c6:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
        for(h = 0; h < width; h++) {
 80130ca:	2300      	movs	r3, #0
 80130cc:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 80130d0:	e025      	b.n	801311e <lv_draw_sw_arc+0x5da>
            lv_draw_sw_mask_res_t res = lv_draw_sw_mask_apply(circle_mask_list, circle_mask_tmp, 0, h, width);
 80130d2:	f107 003c 	add.w	r0, r7, #60	@ 0x3c
 80130d6:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80130da:	9300      	str	r3, [sp, #0]
 80130dc:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 80130e0:	2200      	movs	r2, #0
 80130e2:	f8d7 1224 	ldr.w	r1, [r7, #548]	@ 0x224
 80130e6:	f005 f841 	bl	801816c <lv_draw_sw_mask_apply>
 80130ea:	4603      	mov	r3, r0
 80130ec:	f887 3213 	strb.w	r3, [r7, #531]	@ 0x213
            if(res == LV_DRAW_SW_MASK_RES_TRANSP) {
 80130f0:	f897 3213 	ldrb.w	r3, [r7, #531]	@ 0x213
 80130f4:	2b00      	cmp	r3, #0
 80130f6:	d106      	bne.n	8013106 <lv_draw_sw_arc+0x5c2>
                lv_memzero(circle_mask_tmp, width);
 80130f8:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 80130fc:	4619      	mov	r1, r3
 80130fe:	f8d7 0224 	ldr.w	r0, [r7, #548]	@ 0x224
 8013102:	f7ff fd11 	bl	8012b28 <lv_memzero>
            }

            circle_mask_tmp += width;
 8013106:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 801310a:	f8d7 2224 	ldr.w	r2, [r7, #548]	@ 0x224
 801310e:	4413      	add	r3, r2
 8013110:	f8c7 3224 	str.w	r3, [r7, #548]	@ 0x224
        for(h = 0; h < width; h++) {
 8013114:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8013118:	3301      	adds	r3, #1
 801311a:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 801311e:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 8013122:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8013126:	429a      	cmp	r2, r3
 8013128:	dbd3      	blt.n	80130d2 <lv_draw_sw_arc+0x58e>
        }
        get_rounded_area(start_angle, dsc->radius, width, &round_area_1);
 801312a:	f8d7 3238 	ldr.w	r3, [r7, #568]	@ 0x238
 801312e:	b218      	sxth	r0, r3
 8013130:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013134:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8013138:	681b      	ldr	r3, [r3, #0]
 801313a:	8e9b      	ldrh	r3, [r3, #52]	@ 0x34
 801313c:	4619      	mov	r1, r3
 801313e:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8013142:	b2da      	uxtb	r2, r3
 8013144:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 8013148:	f000 f99c 	bl	8013484 <get_rounded_area>
        lv_area_move(&round_area_1, dsc->center.x, dsc->center.y);
 801314c:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013150:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8013154:	681b      	ldr	r3, [r3, #0]
 8013156:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8013158:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 801315c:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8013160:	681b      	ldr	r3, [r3, #0]
 8013162:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8013164:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 8013168:	4618      	mov	r0, r3
 801316a:	f00e fbc9 	bl	8021900 <lv_area_move>
        get_rounded_area(end_angle, dsc->radius, width, &round_area_2);
 801316e:	f8d7 3234 	ldr.w	r3, [r7, #564]	@ 0x234
 8013172:	b218      	sxth	r0, r3
 8013174:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013178:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 801317c:	681b      	ldr	r3, [r3, #0]
 801317e:	8e9b      	ldrh	r3, [r3, #52]	@ 0x34
 8013180:	4619      	mov	r1, r3
 8013182:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8013186:	b2da      	uxtb	r2, r3
 8013188:	f107 0354 	add.w	r3, r7, #84	@ 0x54
 801318c:	f000 f97a 	bl	8013484 <get_rounded_area>
        lv_area_move(&round_area_2, dsc->center.x, dsc->center.y);
 8013190:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013194:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 8013198:	681b      	ldr	r3, [r3, #0]
 801319a:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 801319c:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80131a0:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 80131a4:	681b      	ldr	r3, [r3, #0]
 80131a6:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80131a8:	f107 0354 	add.w	r3, r7, #84	@ 0x54
 80131ac:	4618      	mov	r0, r3
 80131ae:	f00e fba7 	bl	8021900 <lv_area_move>

    }

    blend_area.y2 = blend_area.y1;
 80131b2:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80131b6:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 80131ba:	685a      	ldr	r2, [r3, #4]
 80131bc:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80131c0:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 80131c4:	60da      	str	r2, [r3, #12]
    for(h = 0; h < blend_h; h++) {
 80131c6:	2300      	movs	r3, #0
 80131c8:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 80131cc:	e0c5      	b.n	801335a <lv_draw_sw_arc+0x816>
        lv_memset(mask_buf, 0xff, blend_w);
 80131ce:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 80131d2:	461a      	mov	r2, r3
 80131d4:	21ff      	movs	r1, #255	@ 0xff
 80131d6:	f8d7 0218 	ldr.w	r0, [r7, #536]	@ 0x218
 80131da:	f011 fe22 	bl	8024e22 <lv_memset>
        blend_dsc.mask_res = lv_draw_sw_mask_apply(mask_list, mask_buf, blend_area.x1, blend_area.y1, blend_w);
 80131de:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80131e2:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 80131e6:	681a      	ldr	r2, [r3, #0]
 80131e8:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80131ec:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 80131f0:	6859      	ldr	r1, [r3, #4]
 80131f2:	f507 70e8 	add.w	r0, r7, #464	@ 0x1d0
 80131f6:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 80131fa:	9300      	str	r3, [sp, #0]
 80131fc:	460b      	mov	r3, r1
 80131fe:	f8d7 1218 	ldr.w	r1, [r7, #536]	@ 0x218
 8013202:	f004 ffb3 	bl	801816c <lv_draw_sw_mask_apply>
 8013206:	4603      	mov	r3, r0
 8013208:	461a      	mov	r2, r3
 801320a:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 801320e:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 8013212:	771a      	strb	r2, [r3, #28]

        if(dsc->rounded) {
 8013214:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013218:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 801321c:	681b      	ldr	r3, [r3, #0]
 801321e:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8013222:	f003 0301 	and.w	r3, r3, #1
 8013226:	b2db      	uxtb	r3, r3
 8013228:	2b00      	cmp	r3, #0
 801322a:	d071      	beq.n	8013310 <lv_draw_sw_arc+0x7cc>
            if(blend_area.y1 >= round_area_1.y1 && blend_area.y1 <= round_area_1.y2) {
 801322c:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013230:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 8013234:	685a      	ldr	r2, [r3, #4]
 8013236:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 801323a:	f5a3 73ee 	sub.w	r3, r3, #476	@ 0x1dc
 801323e:	685b      	ldr	r3, [r3, #4]
 8013240:	429a      	cmp	r2, r3
 8013242:	db2c      	blt.n	801329e <lv_draw_sw_arc+0x75a>
 8013244:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013248:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 801324c:	685a      	ldr	r2, [r3, #4]
 801324e:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013252:	f5a3 73ee 	sub.w	r3, r3, #476	@ 0x1dc
 8013256:	68db      	ldr	r3, [r3, #12]
 8013258:	429a      	cmp	r2, r3
 801325a:	dc20      	bgt.n	801329e <lv_draw_sw_arc+0x75a>
                if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_TRANSP) {
 801325c:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013260:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 8013264:	7f1b      	ldrb	r3, [r3, #28]
 8013266:	2b00      	cmp	r3, #0
 8013268:	d10c      	bne.n	8013284 <lv_draw_sw_arc+0x740>
                    lv_memzero(mask_buf, blend_w);
 801326a:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 801326e:	4619      	mov	r1, r3
 8013270:	f8d7 0218 	ldr.w	r0, [r7, #536]	@ 0x218
 8013274:	f7ff fc58 	bl	8012b28 <lv_memzero>
                    blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8013278:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 801327c:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 8013280:	2202      	movs	r2, #2
 8013282:	771a      	strb	r2, [r3, #28]
                }
                add_circle(circle_mask, &blend_area, &round_area_1, mask_buf, width);
 8013284:	f107 0264 	add.w	r2, r7, #100	@ 0x64
 8013288:	f107 01ec 	add.w	r1, r7, #236	@ 0xec
 801328c:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8013290:	9300      	str	r3, [sp, #0]
 8013292:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8013296:	f8d7 0228 	ldr.w	r0, [r7, #552]	@ 0x228
 801329a:	f000 f89d 	bl	80133d8 <add_circle>
            }
            if(blend_area.y1 >= round_area_2.y1 && blend_area.y1 <= round_area_2.y2) {
 801329e:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80132a2:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 80132a6:	685a      	ldr	r2, [r3, #4]
 80132a8:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80132ac:	f5a3 73f6 	sub.w	r3, r3, #492	@ 0x1ec
 80132b0:	685b      	ldr	r3, [r3, #4]
 80132b2:	429a      	cmp	r2, r3
 80132b4:	db2c      	blt.n	8013310 <lv_draw_sw_arc+0x7cc>
 80132b6:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80132ba:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 80132be:	685a      	ldr	r2, [r3, #4]
 80132c0:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80132c4:	f5a3 73f6 	sub.w	r3, r3, #492	@ 0x1ec
 80132c8:	68db      	ldr	r3, [r3, #12]
 80132ca:	429a      	cmp	r2, r3
 80132cc:	dc20      	bgt.n	8013310 <lv_draw_sw_arc+0x7cc>
                if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_TRANSP) {
 80132ce:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80132d2:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 80132d6:	7f1b      	ldrb	r3, [r3, #28]
 80132d8:	2b00      	cmp	r3, #0
 80132da:	d10c      	bne.n	80132f6 <lv_draw_sw_arc+0x7b2>
                    lv_memzero(mask_buf, blend_w);
 80132dc:	f8d7 321c 	ldr.w	r3, [r7, #540]	@ 0x21c
 80132e0:	4619      	mov	r1, r3
 80132e2:	f8d7 0218 	ldr.w	r0, [r7, #536]	@ 0x218
 80132e6:	f7ff fc1f 	bl	8012b28 <lv_memzero>
                    blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 80132ea:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 80132ee:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
 80132f2:	2202      	movs	r2, #2
 80132f4:	771a      	strb	r2, [r3, #28]
                }
                add_circle(circle_mask, &blend_area, &round_area_2, mask_buf, width);
 80132f6:	f107 0254 	add.w	r2, r7, #84	@ 0x54
 80132fa:	f107 01ec 	add.w	r1, r7, #236	@ 0xec
 80132fe:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8013302:	9300      	str	r3, [sp, #0]
 8013304:	f8d7 3218 	ldr.w	r3, [r7, #536]	@ 0x218
 8013308:	f8d7 0228 	ldr.w	r0, [r7, #552]	@ 0x228
 801330c:	f000 f864 	bl	80133d8 <add_circle>
            }
        }

        lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013310:	f107 02b0 	add.w	r2, r7, #176	@ 0xb0
 8013314:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013318:	f5a3 730d 	sub.w	r3, r3, #564	@ 0x234
 801331c:	4611      	mov	r1, r2
 801331e:	6818      	ldr	r0, [r3, #0]
 8013320:	f7fb faf8 	bl	800e914 <lv_draw_sw_blend>

        blend_area.y1 ++;
 8013324:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013328:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 801332c:	685b      	ldr	r3, [r3, #4]
 801332e:	1c5a      	adds	r2, r3, #1
 8013330:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8013334:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 8013338:	605a      	str	r2, [r3, #4]
        blend_area.y2 ++;
 801333a:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 801333e:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 8013342:	68db      	ldr	r3, [r3, #12]
 8013344:	1c5a      	adds	r2, r3, #1
 8013346:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 801334a:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 801334e:	60da      	str	r2, [r3, #12]
    for(h = 0; h < blend_h; h++) {
 8013350:	f8d7 322c 	ldr.w	r3, [r7, #556]	@ 0x22c
 8013354:	3301      	adds	r3, #1
 8013356:	f8c7 322c 	str.w	r3, [r7, #556]	@ 0x22c
 801335a:	f8d7 222c 	ldr.w	r2, [r7, #556]	@ 0x22c
 801335e:	f8d7 3220 	ldr.w	r3, [r7, #544]	@ 0x220
 8013362:	429a      	cmp	r2, r3
 8013364:	f6ff af33 	blt.w	80131ce <lv_draw_sw_arc+0x68a>
    }

    lv_draw_sw_mask_free_param(&mask_angle_param);
 8013368:	f507 73a2 	add.w	r3, r7, #324	@ 0x144
 801336c:	4618      	mov	r0, r3
 801336e:	f004 ff3f 	bl	80181f0 <lv_draw_sw_mask_free_param>
    lv_draw_sw_mask_free_param(&mask_out_param);
 8013372:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 8013376:	4618      	mov	r0, r3
 8013378:	f004 ff3a 	bl	80181f0 <lv_draw_sw_mask_free_param>
    if(mask_in_param_valid) {
 801337c:	f897 3233 	ldrb.w	r3, [r7, #563]	@ 0x233
 8013380:	2b00      	cmp	r3, #0
 8013382:	d004      	beq.n	801338e <lv_draw_sw_arc+0x84a>
        lv_draw_sw_mask_free_param(&mask_in_param);
 8013384:	f107 03fc 	add.w	r3, r7, #252	@ 0xfc
 8013388:	4618      	mov	r0, r3
 801338a:	f004 ff31 	bl	80181f0 <lv_draw_sw_mask_free_param>
    }

    lv_free(mask_buf);
 801338e:	f8d7 0218 	ldr.w	r0, [r7, #536]	@ 0x218
 8013392:	f012 fd51 	bl	8025e38 <lv_free>
    if(dsc->img_src) lv_image_decoder_close(&decoder_dsc);
 8013396:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 801339a:	f5a3 730e 	sub.w	r3, r3, #568	@ 0x238
 801339e:	681b      	ldr	r3, [r3, #0]
 80133a0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80133a2:	2b00      	cmp	r3, #0
 80133a4:	d004      	beq.n	80133b0 <lv_draw_sw_arc+0x86c>
 80133a6:	f107 0374 	add.w	r3, r7, #116	@ 0x74
 80133aa:	4618      	mov	r0, r3
 80133ac:	f7fb f912 	bl	800e5d4 <lv_image_decoder_close>
    if(circle_mask) lv_free(circle_mask);
 80133b0:	f8d7 3228 	ldr.w	r3, [r7, #552]	@ 0x228
 80133b4:	2b00      	cmp	r3, #0
 80133b6:	d00b      	beq.n	80133d0 <lv_draw_sw_arc+0x88c>
 80133b8:	f8d7 0228 	ldr.w	r0, [r7, #552]	@ 0x228
 80133bc:	f012 fd3c 	bl	8025e38 <lv_free>
 80133c0:	e006      	b.n	80133d0 <lv_draw_sw_arc+0x88c>
    if(dsc->opa <= LV_OPA_MIN) return;
 80133c2:	bf00      	nop
 80133c4:	e004      	b.n	80133d0 <lv_draw_sw_arc+0x88c>
    if(dsc->width == 0) return;
 80133c6:	bf00      	nop
 80133c8:	e002      	b.n	80133d0 <lv_draw_sw_arc+0x88c>
    if(dsc->start_angle == dsc->end_angle) return;
 80133ca:	bf00      	nop
 80133cc:	e000      	b.n	80133d0 <lv_draw_sw_arc+0x88c>
    if(!_lv_area_intersect(&clipped_area, &area_out, draw_unit->clip_area)) return;
 80133ce:	bf00      	nop
    LV_UNUSED(start_angle);
    LV_UNUSED(end_angle);
    LV_UNUSED(layer);
    LV_UNUSED(dsc);
#endif /*LV_DRAW_SW_COMPLEX*/
}
 80133d0:	f507 7711 	add.w	r7, r7, #580	@ 0x244
 80133d4:	46bd      	mov	sp, r7
 80133d6:	bd90      	pop	{r4, r7, pc}

080133d8 <add_circle>:
 *   STATIC FUNCTIONS
 **********************/

static void add_circle(const lv_opa_t * circle_mask, const lv_area_t * blend_area, const lv_area_t * circle_area,
                       lv_opa_t * mask_buf,  int32_t width)
{
 80133d8:	b580      	push	{r7, lr}
 80133da:	b08e      	sub	sp, #56	@ 0x38
 80133dc:	af00      	add	r7, sp, #0
 80133de:	60f8      	str	r0, [r7, #12]
 80133e0:	60b9      	str	r1, [r7, #8]
 80133e2:	607a      	str	r2, [r7, #4]
 80133e4:	603b      	str	r3, [r7, #0]
    lv_area_t circle_common_area;
    if(_lv_area_intersect(&circle_common_area, circle_area, blend_area)) {
 80133e6:	f107 0314 	add.w	r3, r7, #20
 80133ea:	68ba      	ldr	r2, [r7, #8]
 80133ec:	6879      	ldr	r1, [r7, #4]
 80133ee:	4618      	mov	r0, r3
 80133f0:	f00e faaa 	bl	8021948 <_lv_area_intersect>
 80133f4:	4603      	mov	r3, r0
 80133f6:	2b00      	cmp	r3, #0
 80133f8:	d040      	beq.n	801347c <add_circle+0xa4>
        const lv_opa_t * circle_mask_tmp = circle_mask + width * (circle_common_area.y1 - circle_area->y1);
 80133fa:	69ba      	ldr	r2, [r7, #24]
 80133fc:	687b      	ldr	r3, [r7, #4]
 80133fe:	685b      	ldr	r3, [r3, #4]
 8013400:	1ad3      	subs	r3, r2, r3
 8013402:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8013404:	fb02 f303 	mul.w	r3, r2, r3
 8013408:	461a      	mov	r2, r3
 801340a:	68fb      	ldr	r3, [r7, #12]
 801340c:	4413      	add	r3, r2
 801340e:	633b      	str	r3, [r7, #48]	@ 0x30
        circle_mask_tmp += circle_common_area.x1 - circle_area->x1;
 8013410:	697a      	ldr	r2, [r7, #20]
 8013412:	687b      	ldr	r3, [r7, #4]
 8013414:	681b      	ldr	r3, [r3, #0]
 8013416:	1ad3      	subs	r3, r2, r3
 8013418:	461a      	mov	r2, r3
 801341a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801341c:	4413      	add	r3, r2
 801341e:	633b      	str	r3, [r7, #48]	@ 0x30

        lv_opa_t * mask_buf_tmp = mask_buf + circle_common_area.x1 - blend_area->x1;
 8013420:	697b      	ldr	r3, [r7, #20]
 8013422:	461a      	mov	r2, r3
 8013424:	68bb      	ldr	r3, [r7, #8]
 8013426:	681b      	ldr	r3, [r3, #0]
 8013428:	1ad3      	subs	r3, r2, r3
 801342a:	683a      	ldr	r2, [r7, #0]
 801342c:	4413      	add	r3, r2
 801342e:	62fb      	str	r3, [r7, #44]	@ 0x2c

        uint32_t x;
        uint32_t w = lv_area_get_width(&circle_common_area);
 8013430:	f107 0314 	add.w	r3, r7, #20
 8013434:	4618      	mov	r0, r3
 8013436:	f7ff fb46 	bl	8012ac6 <lv_area_get_width>
 801343a:	4603      	mov	r3, r0
 801343c:	62bb      	str	r3, [r7, #40]	@ 0x28
        for(x = 0; x < w; x++) {
 801343e:	2300      	movs	r3, #0
 8013440:	637b      	str	r3, [r7, #52]	@ 0x34
 8013442:	e017      	b.n	8013474 <add_circle+0x9c>
            uint32_t res = mask_buf_tmp[x] + circle_mask_tmp[x];
 8013444:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013446:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013448:	4413      	add	r3, r2
 801344a:	781b      	ldrb	r3, [r3, #0]
 801344c:	4619      	mov	r1, r3
 801344e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8013450:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013452:	4413      	add	r3, r2
 8013454:	781b      	ldrb	r3, [r3, #0]
 8013456:	440b      	add	r3, r1
 8013458:	627b      	str	r3, [r7, #36]	@ 0x24
            mask_buf_tmp[x] = res > 255 ? 255 : res;
 801345a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801345c:	2bff      	cmp	r3, #255	@ 0xff
 801345e:	bf28      	it	cs
 8013460:	23ff      	movcs	r3, #255	@ 0xff
 8013462:	4619      	mov	r1, r3
 8013464:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8013466:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013468:	4413      	add	r3, r2
 801346a:	b2ca      	uxtb	r2, r1
 801346c:	701a      	strb	r2, [r3, #0]
        for(x = 0; x < w; x++) {
 801346e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013470:	3301      	adds	r3, #1
 8013472:	637b      	str	r3, [r7, #52]	@ 0x34
 8013474:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8013476:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013478:	429a      	cmp	r2, r3
 801347a:	d3e3      	bcc.n	8013444 <add_circle+0x6c>
        }
    }

}
 801347c:	bf00      	nop
 801347e:	3738      	adds	r7, #56	@ 0x38
 8013480:	46bd      	mov	sp, r7
 8013482:	bd80      	pop	{r7, pc}

08013484 <get_rounded_area>:

static void get_rounded_area(int16_t angle, int32_t radius, uint8_t thickness, lv_area_t * res_area)
{
 8013484:	b590      	push	{r4, r7, lr}
 8013486:	b089      	sub	sp, #36	@ 0x24
 8013488:	af00      	add	r7, sp, #0
 801348a:	60b9      	str	r1, [r7, #8]
 801348c:	607b      	str	r3, [r7, #4]
 801348e:	4603      	mov	r3, r0
 8013490:	81fb      	strh	r3, [r7, #14]
 8013492:	4613      	mov	r3, r2
 8013494:	737b      	strb	r3, [r7, #13]
    int32_t thick_half = thickness / 2;
 8013496:	7b7b      	ldrb	r3, [r7, #13]
 8013498:	085b      	lsrs	r3, r3, #1
 801349a:	b2db      	uxtb	r3, r3
 801349c:	61fb      	str	r3, [r7, #28]
    uint8_t thick_corr = (thickness & 0x01) ? 0 : 1;
 801349e:	7b7b      	ldrb	r3, [r7, #13]
 80134a0:	f003 0301 	and.w	r3, r3, #1
 80134a4:	2b00      	cmp	r3, #0
 80134a6:	bf0c      	ite	eq
 80134a8:	2301      	moveq	r3, #1
 80134aa:	2300      	movne	r3, #0
 80134ac:	b2db      	uxtb	r3, r3
 80134ae:	76fb      	strb	r3, [r7, #27]

    int32_t cir_x;
    int32_t cir_y;

    cir_x = ((radius - thick_half) * lv_trigo_cos(angle)) >> (LV_TRIGO_SHIFT - 8);
 80134b0:	68ba      	ldr	r2, [r7, #8]
 80134b2:	69fb      	ldr	r3, [r7, #28]
 80134b4:	1ad4      	subs	r4, r2, r3
 80134b6:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80134ba:	4618      	mov	r0, r3
 80134bc:	f7ff fb23 	bl	8012b06 <lv_trigo_cos>
 80134c0:	4603      	mov	r3, r0
 80134c2:	fb04 f303 	mul.w	r3, r4, r3
 80134c6:	11db      	asrs	r3, r3, #7
 80134c8:	617b      	str	r3, [r7, #20]
    cir_y = ((radius - thick_half) * lv_trigo_sin(angle)) >> (LV_TRIGO_SHIFT - 8);
 80134ca:	68ba      	ldr	r2, [r7, #8]
 80134cc:	69fb      	ldr	r3, [r7, #28]
 80134ce:	1ad4      	subs	r4, r2, r3
 80134d0:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80134d4:	4618      	mov	r0, r3
 80134d6:	f00f ff05 	bl	80232e4 <lv_trigo_sin>
 80134da:	4603      	mov	r3, r0
 80134dc:	fb04 f303 	mul.w	r3, r4, r3
 80134e0:	11db      	asrs	r3, r3, #7
 80134e2:	613b      	str	r3, [r7, #16]

    /*The center of the pixel need to be calculated so apply 1/2 px offset*/
    if(cir_x > 0) {
 80134e4:	697b      	ldr	r3, [r7, #20]
 80134e6:	2b00      	cmp	r3, #0
 80134e8:	dd10      	ble.n	801350c <get_rounded_area+0x88>
        cir_x = (cir_x - 128) >> 8;
 80134ea:	697b      	ldr	r3, [r7, #20]
 80134ec:	3b80      	subs	r3, #128	@ 0x80
 80134ee:	121b      	asrs	r3, r3, #8
 80134f0:	617b      	str	r3, [r7, #20]
        res_area->x1 = cir_x - thick_half + thick_corr;
 80134f2:	697a      	ldr	r2, [r7, #20]
 80134f4:	69fb      	ldr	r3, [r7, #28]
 80134f6:	1ad2      	subs	r2, r2, r3
 80134f8:	7efb      	ldrb	r3, [r7, #27]
 80134fa:	441a      	add	r2, r3
 80134fc:	687b      	ldr	r3, [r7, #4]
 80134fe:	601a      	str	r2, [r3, #0]
        res_area->x2 = cir_x + thick_half;
 8013500:	697a      	ldr	r2, [r7, #20]
 8013502:	69fb      	ldr	r3, [r7, #28]
 8013504:	441a      	add	r2, r3
 8013506:	687b      	ldr	r3, [r7, #4]
 8013508:	609a      	str	r2, [r3, #8]
 801350a:	e00f      	b.n	801352c <get_rounded_area+0xa8>
    }
    else {
        cir_x = (cir_x + 128) >> 8;
 801350c:	697b      	ldr	r3, [r7, #20]
 801350e:	3380      	adds	r3, #128	@ 0x80
 8013510:	121b      	asrs	r3, r3, #8
 8013512:	617b      	str	r3, [r7, #20]
        res_area->x1 = cir_x - thick_half;
 8013514:	697a      	ldr	r2, [r7, #20]
 8013516:	69fb      	ldr	r3, [r7, #28]
 8013518:	1ad2      	subs	r2, r2, r3
 801351a:	687b      	ldr	r3, [r7, #4]
 801351c:	601a      	str	r2, [r3, #0]
        res_area->x2 = cir_x + thick_half - thick_corr;
 801351e:	697a      	ldr	r2, [r7, #20]
 8013520:	69fb      	ldr	r3, [r7, #28]
 8013522:	441a      	add	r2, r3
 8013524:	7efb      	ldrb	r3, [r7, #27]
 8013526:	1ad2      	subs	r2, r2, r3
 8013528:	687b      	ldr	r3, [r7, #4]
 801352a:	609a      	str	r2, [r3, #8]
    }

    if(cir_y > 0) {
 801352c:	693b      	ldr	r3, [r7, #16]
 801352e:	2b00      	cmp	r3, #0
 8013530:	dd10      	ble.n	8013554 <get_rounded_area+0xd0>
        cir_y = (cir_y - 128) >> 8;
 8013532:	693b      	ldr	r3, [r7, #16]
 8013534:	3b80      	subs	r3, #128	@ 0x80
 8013536:	121b      	asrs	r3, r3, #8
 8013538:	613b      	str	r3, [r7, #16]
        res_area->y1 = cir_y - thick_half + thick_corr;
 801353a:	693a      	ldr	r2, [r7, #16]
 801353c:	69fb      	ldr	r3, [r7, #28]
 801353e:	1ad2      	subs	r2, r2, r3
 8013540:	7efb      	ldrb	r3, [r7, #27]
 8013542:	441a      	add	r2, r3
 8013544:	687b      	ldr	r3, [r7, #4]
 8013546:	605a      	str	r2, [r3, #4]
        res_area->y2 = cir_y + thick_half;
 8013548:	693a      	ldr	r2, [r7, #16]
 801354a:	69fb      	ldr	r3, [r7, #28]
 801354c:	441a      	add	r2, r3
 801354e:	687b      	ldr	r3, [r7, #4]
 8013550:	60da      	str	r2, [r3, #12]
    else {
        cir_y = (cir_y + 128) >> 8;
        res_area->y1 = cir_y - thick_half;
        res_area->y2 = cir_y + thick_half - thick_corr;
    }
}
 8013552:	e00f      	b.n	8013574 <get_rounded_area+0xf0>
        cir_y = (cir_y + 128) >> 8;
 8013554:	693b      	ldr	r3, [r7, #16]
 8013556:	3380      	adds	r3, #128	@ 0x80
 8013558:	121b      	asrs	r3, r3, #8
 801355a:	613b      	str	r3, [r7, #16]
        res_area->y1 = cir_y - thick_half;
 801355c:	693a      	ldr	r2, [r7, #16]
 801355e:	69fb      	ldr	r3, [r7, #28]
 8013560:	1ad2      	subs	r2, r2, r3
 8013562:	687b      	ldr	r3, [r7, #4]
 8013564:	605a      	str	r2, [r3, #4]
        res_area->y2 = cir_y + thick_half - thick_corr;
 8013566:	693a      	ldr	r2, [r7, #16]
 8013568:	69fb      	ldr	r3, [r7, #28]
 801356a:	441a      	add	r2, r3
 801356c:	7efb      	ldrb	r3, [r7, #27]
 801356e:	1ad2      	subs	r2, r2, r3
 8013570:	687b      	ldr	r3, [r7, #4]
 8013572:	60da      	str	r2, [r3, #12]
}
 8013574:	bf00      	nop
 8013576:	3724      	adds	r7, #36	@ 0x24
 8013578:	46bd      	mov	sp, r7
 801357a:	bd90      	pop	{r4, r7, pc}

0801357c <lv_area_copy>:
{
 801357c:	b480      	push	{r7}
 801357e:	b083      	sub	sp, #12
 8013580:	af00      	add	r7, sp, #0
 8013582:	6078      	str	r0, [r7, #4]
 8013584:	6039      	str	r1, [r7, #0]
    dest->x1 = src->x1;
 8013586:	683b      	ldr	r3, [r7, #0]
 8013588:	681a      	ldr	r2, [r3, #0]
 801358a:	687b      	ldr	r3, [r7, #4]
 801358c:	601a      	str	r2, [r3, #0]
    dest->y1 = src->y1;
 801358e:	683b      	ldr	r3, [r7, #0]
 8013590:	685a      	ldr	r2, [r3, #4]
 8013592:	687b      	ldr	r3, [r7, #4]
 8013594:	605a      	str	r2, [r3, #4]
    dest->x2 = src->x2;
 8013596:	683b      	ldr	r3, [r7, #0]
 8013598:	689a      	ldr	r2, [r3, #8]
 801359a:	687b      	ldr	r3, [r7, #4]
 801359c:	609a      	str	r2, [r3, #8]
    dest->y2 = src->y2;
 801359e:	683b      	ldr	r3, [r7, #0]
 80135a0:	68da      	ldr	r2, [r3, #12]
 80135a2:	687b      	ldr	r3, [r7, #4]
 80135a4:	60da      	str	r2, [r3, #12]
}
 80135a6:	bf00      	nop
 80135a8:	370c      	adds	r7, #12
 80135aa:	46bd      	mov	sp, r7
 80135ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80135b0:	4770      	bx	lr

080135b2 <lv_area_get_width>:
{
 80135b2:	b480      	push	{r7}
 80135b4:	b083      	sub	sp, #12
 80135b6:	af00      	add	r7, sp, #0
 80135b8:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 80135ba:	687b      	ldr	r3, [r7, #4]
 80135bc:	689a      	ldr	r2, [r3, #8]
 80135be:	687b      	ldr	r3, [r7, #4]
 80135c0:	681b      	ldr	r3, [r3, #0]
 80135c2:	1ad3      	subs	r3, r2, r3
 80135c4:	3301      	adds	r3, #1
}
 80135c6:	4618      	mov	r0, r3
 80135c8:	370c      	adds	r7, #12
 80135ca:	46bd      	mov	sp, r7
 80135cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80135d0:	4770      	bx	lr

080135d2 <lv_area_get_height>:
{
 80135d2:	b480      	push	{r7}
 80135d4:	b083      	sub	sp, #12
 80135d6:	af00      	add	r7, sp, #0
 80135d8:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 80135da:	687b      	ldr	r3, [r7, #4]
 80135dc:	68da      	ldr	r2, [r3, #12]
 80135de:	687b      	ldr	r3, [r7, #4]
 80135e0:	685b      	ldr	r3, [r3, #4]
 80135e2:	1ad3      	subs	r3, r2, r3
 80135e4:	3301      	adds	r3, #1
}
 80135e6:	4618      	mov	r0, r3
 80135e8:	370c      	adds	r7, #12
 80135ea:	46bd      	mov	sp, r7
 80135ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80135f0:	4770      	bx	lr

080135f2 <lv_memzero>:
{
 80135f2:	b580      	push	{r7, lr}
 80135f4:	b082      	sub	sp, #8
 80135f6:	af00      	add	r7, sp, #0
 80135f8:	6078      	str	r0, [r7, #4]
 80135fa:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 80135fc:	683a      	ldr	r2, [r7, #0]
 80135fe:	2100      	movs	r1, #0
 8013600:	6878      	ldr	r0, [r7, #4]
 8013602:	f011 fc0e 	bl	8024e22 <lv_memset>
}
 8013606:	bf00      	nop
 8013608:	3708      	adds	r7, #8
 801360a:	46bd      	mov	sp, r7
 801360c:	bd80      	pop	{r7, pc}

0801360e <lv_draw_sw_border>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_sw_border(lv_draw_unit_t * draw_unit, const lv_draw_border_dsc_t * dsc, const lv_area_t * coords)
{
 801360e:	b580      	push	{r7, lr}
 8013610:	b092      	sub	sp, #72	@ 0x48
 8013612:	af04      	add	r7, sp, #16
 8013614:	60f8      	str	r0, [r7, #12]
 8013616:	60b9      	str	r1, [r7, #8]
 8013618:	607a      	str	r2, [r7, #4]
    if(dsc->opa <= LV_OPA_MIN) return;
 801361a:	68bb      	ldr	r3, [r7, #8]
 801361c:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 8013620:	2b02      	cmp	r3, #2
 8013622:	f240 80b7 	bls.w	8013794 <lv_draw_sw_border+0x186>
    if(dsc->width == 0) return;
 8013626:	68bb      	ldr	r3, [r7, #8]
 8013628:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801362a:	2b00      	cmp	r3, #0
 801362c:	f000 80b4 	beq.w	8013798 <lv_draw_sw_border+0x18a>
    if(dsc->side == LV_BORDER_SIDE_NONE) return;
 8013630:	68bb      	ldr	r3, [r7, #8]
 8013632:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
 8013636:	f003 031f 	and.w	r3, r3, #31
 801363a:	b2db      	uxtb	r3, r3
 801363c:	2b00      	cmp	r3, #0
 801363e:	f000 80ad 	beq.w	801379c <lv_draw_sw_border+0x18e>

    int32_t coords_w = lv_area_get_width(coords);
 8013642:	6878      	ldr	r0, [r7, #4]
 8013644:	f7ff ffb5 	bl	80135b2 <lv_area_get_width>
 8013648:	62f8      	str	r0, [r7, #44]	@ 0x2c
    int32_t coords_h = lv_area_get_height(coords);
 801364a:	6878      	ldr	r0, [r7, #4]
 801364c:	f7ff ffc1 	bl	80135d2 <lv_area_get_height>
 8013650:	62b8      	str	r0, [r7, #40]	@ 0x28
    int32_t rout = dsc->radius;
 8013652:	68bb      	ldr	r3, [r7, #8]
 8013654:	69db      	ldr	r3, [r3, #28]
 8013656:	637b      	str	r3, [r7, #52]	@ 0x34
    int32_t short_side = LV_MIN(coords_w, coords_h);
 8013658:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801365a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801365c:	4293      	cmp	r3, r2
 801365e:	bfa8      	it	ge
 8013660:	4613      	movge	r3, r2
 8013662:	627b      	str	r3, [r7, #36]	@ 0x24
    if(rout > short_side >> 1) rout = short_side >> 1;
 8013664:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013666:	105b      	asrs	r3, r3, #1
 8013668:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801366a:	429a      	cmp	r2, r3
 801366c:	dd02      	ble.n	8013674 <lv_draw_sw_border+0x66>
 801366e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8013670:	105b      	asrs	r3, r3, #1
 8013672:	637b      	str	r3, [r7, #52]	@ 0x34

    /*Get the inner area*/
    lv_area_t area_inner;
    lv_area_copy(&area_inner, coords);
 8013674:	f107 0314 	add.w	r3, r7, #20
 8013678:	6879      	ldr	r1, [r7, #4]
 801367a:	4618      	mov	r0, r3
 801367c:	f7ff ff7e 	bl	801357c <lv_area_copy>
    area_inner.x1 += ((dsc->side & LV_BORDER_SIDE_LEFT) ? dsc->width : - (dsc->width + rout));
 8013680:	697a      	ldr	r2, [r7, #20]
 8013682:	68bb      	ldr	r3, [r7, #8]
 8013684:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
 8013688:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801368c:	b2db      	uxtb	r3, r3
 801368e:	f003 0304 	and.w	r3, r3, #4
 8013692:	2b00      	cmp	r3, #0
 8013694:	d002      	beq.n	801369c <lv_draw_sw_border+0x8e>
 8013696:	68bb      	ldr	r3, [r7, #8]
 8013698:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801369a:	e004      	b.n	80136a6 <lv_draw_sw_border+0x98>
 801369c:	68bb      	ldr	r3, [r7, #8]
 801369e:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 80136a0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80136a2:	440b      	add	r3, r1
 80136a4:	425b      	negs	r3, r3
 80136a6:	4413      	add	r3, r2
 80136a8:	617b      	str	r3, [r7, #20]
    area_inner.x2 -= ((dsc->side & LV_BORDER_SIDE_RIGHT) ? dsc->width : - (dsc->width + rout));
 80136aa:	69fa      	ldr	r2, [r7, #28]
 80136ac:	68bb      	ldr	r3, [r7, #8]
 80136ae:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
 80136b2:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80136b6:	b2db      	uxtb	r3, r3
 80136b8:	f003 0308 	and.w	r3, r3, #8
 80136bc:	2b00      	cmp	r3, #0
 80136be:	d002      	beq.n	80136c6 <lv_draw_sw_border+0xb8>
 80136c0:	68bb      	ldr	r3, [r7, #8]
 80136c2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80136c4:	e004      	b.n	80136d0 <lv_draw_sw_border+0xc2>
 80136c6:	68bb      	ldr	r3, [r7, #8]
 80136c8:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 80136ca:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80136cc:	440b      	add	r3, r1
 80136ce:	425b      	negs	r3, r3
 80136d0:	1ad3      	subs	r3, r2, r3
 80136d2:	61fb      	str	r3, [r7, #28]
    area_inner.y1 += ((dsc->side & LV_BORDER_SIDE_TOP) ? dsc->width : - (dsc->width + rout));
 80136d4:	69ba      	ldr	r2, [r7, #24]
 80136d6:	68bb      	ldr	r3, [r7, #8]
 80136d8:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
 80136dc:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80136e0:	b2db      	uxtb	r3, r3
 80136e2:	f003 0302 	and.w	r3, r3, #2
 80136e6:	2b00      	cmp	r3, #0
 80136e8:	d002      	beq.n	80136f0 <lv_draw_sw_border+0xe2>
 80136ea:	68bb      	ldr	r3, [r7, #8]
 80136ec:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80136ee:	e004      	b.n	80136fa <lv_draw_sw_border+0xec>
 80136f0:	68bb      	ldr	r3, [r7, #8]
 80136f2:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 80136f4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80136f6:	440b      	add	r3, r1
 80136f8:	425b      	negs	r3, r3
 80136fa:	4413      	add	r3, r2
 80136fc:	61bb      	str	r3, [r7, #24]
    area_inner.y2 -= ((dsc->side & LV_BORDER_SIDE_BOTTOM) ? dsc->width : - (dsc->width + rout));
 80136fe:	6a3a      	ldr	r2, [r7, #32]
 8013700:	68bb      	ldr	r3, [r7, #8]
 8013702:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
 8013706:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801370a:	b2db      	uxtb	r3, r3
 801370c:	f003 0301 	and.w	r3, r3, #1
 8013710:	2b00      	cmp	r3, #0
 8013712:	d002      	beq.n	801371a <lv_draw_sw_border+0x10c>
 8013714:	68bb      	ldr	r3, [r7, #8]
 8013716:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8013718:	e004      	b.n	8013724 <lv_draw_sw_border+0x116>
 801371a:	68bb      	ldr	r3, [r7, #8]
 801371c:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 801371e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013720:	440b      	add	r3, r1
 8013722:	425b      	negs	r3, r3
 8013724:	1ad3      	subs	r3, r2, r3
 8013726:	623b      	str	r3, [r7, #32]

    int32_t rin = rout - dsc->width;
 8013728:	68bb      	ldr	r3, [r7, #8]
 801372a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801372c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801372e:	1ad3      	subs	r3, r2, r3
 8013730:	633b      	str	r3, [r7, #48]	@ 0x30
    if(rin < 0) rin = 0;
 8013732:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013734:	2b00      	cmp	r3, #0
 8013736:	da01      	bge.n	801373c <lv_draw_sw_border+0x12e>
 8013738:	2300      	movs	r3, #0
 801373a:	633b      	str	r3, [r7, #48]	@ 0x30

    if(rout == 0 && rin == 0) {
 801373c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801373e:	2b00      	cmp	r3, #0
 8013740:	d110      	bne.n	8013764 <lv_draw_sw_border+0x156>
 8013742:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013744:	2b00      	cmp	r3, #0
 8013746:	d10d      	bne.n	8013764 <lv_draw_sw_border+0x156>
        draw_border_simple(draw_unit, coords, &area_inner, dsc->color, dsc->opa);
 8013748:	68bb      	ldr	r3, [r7, #8]
 801374a:	f893 2028 	ldrb.w	r2, [r3, #40]	@ 0x28
 801374e:	68bb      	ldr	r3, [r7, #8]
 8013750:	f107 0114 	add.w	r1, r7, #20
 8013754:	9200      	str	r2, [sp, #0]
 8013756:	6a1b      	ldr	r3, [r3, #32]
 8013758:	460a      	mov	r2, r1
 801375a:	6879      	ldr	r1, [r7, #4]
 801375c:	68f8      	ldr	r0, [r7, #12]
 801375e:	f000 fb23 	bl	8013da8 <draw_border_simple>
 8013762:	e01c      	b.n	801379e <lv_draw_sw_border+0x190>
    }
    else {
        draw_border_complex(draw_unit, coords, &area_inner, rout, rin, dsc->color, dsc->opa);
 8013764:	68bb      	ldr	r3, [r7, #8]
 8013766:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 801376a:	f107 0114 	add.w	r1, r7, #20
 801376e:	9302      	str	r3, [sp, #8]
 8013770:	68ba      	ldr	r2, [r7, #8]
 8013772:	ab01      	add	r3, sp, #4
 8013774:	3220      	adds	r2, #32
 8013776:	6812      	ldr	r2, [r2, #0]
 8013778:	4610      	mov	r0, r2
 801377a:	8018      	strh	r0, [r3, #0]
 801377c:	3302      	adds	r3, #2
 801377e:	0c12      	lsrs	r2, r2, #16
 8013780:	701a      	strb	r2, [r3, #0]
 8013782:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8013784:	9300      	str	r3, [sp, #0]
 8013786:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8013788:	460a      	mov	r2, r1
 801378a:	6879      	ldr	r1, [r7, #4]
 801378c:	68f8      	ldr	r0, [r7, #12]
 801378e:	f000 f809 	bl	80137a4 <draw_border_complex>
 8013792:	e004      	b.n	801379e <lv_draw_sw_border+0x190>
    if(dsc->opa <= LV_OPA_MIN) return;
 8013794:	bf00      	nop
 8013796:	e002      	b.n	801379e <lv_draw_sw_border+0x190>
    if(dsc->width == 0) return;
 8013798:	bf00      	nop
 801379a:	e000      	b.n	801379e <lv_draw_sw_border+0x190>
    if(dsc->side == LV_BORDER_SIDE_NONE) return;
 801379c:	bf00      	nop
    }

}
 801379e:	3738      	adds	r7, #56	@ 0x38
 80137a0:	46bd      	mov	sp, r7
 80137a2:	bd80      	pop	{r7, pc}

080137a4 <draw_border_complex>:
 *   STATIC FUNCTIONS
 **********************/

void draw_border_complex(lv_draw_unit_t * draw_unit, const lv_area_t * outer_area, const lv_area_t * inner_area,
                         int32_t rout, int32_t rin, lv_color_t color, lv_opa_t opa)
{
 80137a4:	b580      	push	{r7, lr}
 80137a6:	b0bc      	sub	sp, #240	@ 0xf0
 80137a8:	af02      	add	r7, sp, #8
 80137aa:	60f8      	str	r0, [r7, #12]
 80137ac:	60b9      	str	r1, [r7, #8]
 80137ae:	607a      	str	r2, [r7, #4]
 80137b0:	603b      	str	r3, [r7, #0]
#if LV_DRAW_SW_COMPLEX
    /*Get clipped draw area which is the real draw area.
     *It is always the same or inside `coords`*/
    lv_area_t draw_area;
    if(!_lv_area_intersect(&draw_area, outer_area, draw_unit->clip_area)) return;
 80137b2:	68fb      	ldr	r3, [r7, #12]
 80137b4:	689a      	ldr	r2, [r3, #8]
 80137b6:	f107 03b0 	add.w	r3, r7, #176	@ 0xb0
 80137ba:	68b9      	ldr	r1, [r7, #8]
 80137bc:	4618      	mov	r0, r3
 80137be:	f00e f8c3 	bl	8021948 <_lv_area_intersect>
 80137c2:	4603      	mov	r3, r0
 80137c4:	f083 0301 	eor.w	r3, r3, #1
 80137c8:	b2db      	uxtb	r3, r3
 80137ca:	2b00      	cmp	r3, #0
 80137cc:	f040 82e8 	bne.w	8013da0 <draw_border_complex+0x5fc>
    int32_t draw_area_w = lv_area_get_width(&draw_area);
 80137d0:	f107 03b0 	add.w	r3, r7, #176	@ 0xb0
 80137d4:	4618      	mov	r0, r3
 80137d6:	f7ff feec 	bl	80135b2 <lv_area_get_width>
 80137da:	f8c7 00dc 	str.w	r0, [r7, #220]	@ 0xdc

    lv_draw_sw_blend_dsc_t blend_dsc;
    lv_memzero(&blend_dsc, sizeof(blend_dsc));
 80137de:	f107 0384 	add.w	r3, r7, #132	@ 0x84
 80137e2:	212c      	movs	r1, #44	@ 0x2c
 80137e4:	4618      	mov	r0, r3
 80137e6:	f7ff ff04 	bl	80135f2 <lv_memzero>
    lv_opa_t * mask_buf = lv_malloc(draw_area_w);
 80137ea:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80137ee:	4618      	mov	r0, r3
 80137f0:	f012 faea 	bl	8025dc8 <lv_malloc>
 80137f4:	f8c7 00d8 	str.w	r0, [r7, #216]	@ 0xd8
    blend_dsc.mask_buf = mask_buf;
 80137f8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80137fc:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c

    void * mask_list[3] = {0};
 8013800:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8013804:	2200      	movs	r2, #0
 8013806:	601a      	str	r2, [r3, #0]
 8013808:	605a      	str	r2, [r3, #4]
 801380a:	609a      	str	r2, [r3, #8]

    /*Create mask for the inner mask*/
    lv_draw_sw_mask_radius_param_t mask_rin_param;
    lv_draw_sw_mask_radius_init(&mask_rin_param, inner_area, rin, true);
 801380c:	f107 0054 	add.w	r0, r7, #84	@ 0x54
 8013810:	2301      	movs	r3, #1
 8013812:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 8013816:	6879      	ldr	r1, [r7, #4]
 8013818:	f004 ff1e 	bl	8018658 <lv_draw_sw_mask_radius_init>
    mask_list[0] = &mask_rin_param;
 801381c:	f107 0354 	add.w	r3, r7, #84	@ 0x54
 8013820:	67bb      	str	r3, [r7, #120]	@ 0x78

    /*Create mask for the outer area*/
    lv_draw_sw_mask_radius_param_t mask_rout_param;
    if(rout > 0) {
 8013822:	683b      	ldr	r3, [r7, #0]
 8013824:	2b00      	cmp	r3, #0
 8013826:	dd09      	ble.n	801383c <draw_border_complex+0x98>
        lv_draw_sw_mask_radius_init(&mask_rout_param, outer_area, rout, false);
 8013828:	f107 0030 	add.w	r0, r7, #48	@ 0x30
 801382c:	2300      	movs	r3, #0
 801382e:	683a      	ldr	r2, [r7, #0]
 8013830:	68b9      	ldr	r1, [r7, #8]
 8013832:	f004 ff11 	bl	8018658 <lv_draw_sw_mask_radius_init>
        mask_list[1] = &mask_rout_param;
 8013836:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 801383a:	67fb      	str	r3, [r7, #124]	@ 0x7c
    }

    int32_t h;
    lv_area_t blend_area;
    blend_dsc.blend_area = &blend_area;
 801383c:	f107 0320 	add.w	r3, r7, #32
 8013840:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    blend_dsc.mask_area = &blend_area;
 8013844:	f107 0320 	add.w	r3, r7, #32
 8013848:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    blend_dsc.color = color;
 801384c:	f107 0399 	add.w	r3, r7, #153	@ 0x99
 8013850:	f107 02f4 	add.w	r2, r7, #244	@ 0xf4
 8013854:	8811      	ldrh	r1, [r2, #0]
 8013856:	7892      	ldrb	r2, [r2, #2]
 8013858:	8019      	strh	r1, [r3, #0]
 801385a:	709a      	strb	r2, [r3, #2]
    blend_dsc.opa = opa;
 801385c:	f897 30f8 	ldrb.w	r3, [r7, #248]	@ 0xf8
 8013860:	f887 3098 	strb.w	r3, [r7, #152]	@ 0x98

    /*Calculate the x and y coordinates where the straight parts area is*/
    lv_area_t core_area;
    core_area.x1 = LV_MAX(outer_area->x1 + rout, inner_area->x1);
 8013864:	687b      	ldr	r3, [r7, #4]
 8013866:	681a      	ldr	r2, [r3, #0]
 8013868:	68bb      	ldr	r3, [r7, #8]
 801386a:	6819      	ldr	r1, [r3, #0]
 801386c:	683b      	ldr	r3, [r7, #0]
 801386e:	440b      	add	r3, r1
 8013870:	4293      	cmp	r3, r2
 8013872:	bfb8      	it	lt
 8013874:	4613      	movlt	r3, r2
 8013876:	613b      	str	r3, [r7, #16]
    core_area.x2 = LV_MIN(outer_area->x2 - rout, inner_area->x2);
 8013878:	687b      	ldr	r3, [r7, #4]
 801387a:	689a      	ldr	r2, [r3, #8]
 801387c:	68bb      	ldr	r3, [r7, #8]
 801387e:	6899      	ldr	r1, [r3, #8]
 8013880:	683b      	ldr	r3, [r7, #0]
 8013882:	1acb      	subs	r3, r1, r3
 8013884:	4293      	cmp	r3, r2
 8013886:	bfa8      	it	ge
 8013888:	4613      	movge	r3, r2
 801388a:	61bb      	str	r3, [r7, #24]
    core_area.y1 = LV_MAX(outer_area->y1 + rout, inner_area->y1);
 801388c:	687b      	ldr	r3, [r7, #4]
 801388e:	685a      	ldr	r2, [r3, #4]
 8013890:	68bb      	ldr	r3, [r7, #8]
 8013892:	6859      	ldr	r1, [r3, #4]
 8013894:	683b      	ldr	r3, [r7, #0]
 8013896:	440b      	add	r3, r1
 8013898:	4293      	cmp	r3, r2
 801389a:	bfb8      	it	lt
 801389c:	4613      	movlt	r3, r2
 801389e:	617b      	str	r3, [r7, #20]
    core_area.y2 = LV_MIN(outer_area->y2 - rout, inner_area->y2);
 80138a0:	687b      	ldr	r3, [r7, #4]
 80138a2:	68da      	ldr	r2, [r3, #12]
 80138a4:	68bb      	ldr	r3, [r7, #8]
 80138a6:	68d9      	ldr	r1, [r3, #12]
 80138a8:	683b      	ldr	r3, [r7, #0]
 80138aa:	1acb      	subs	r3, r1, r3
 80138ac:	4293      	cmp	r3, r2
 80138ae:	bfa8      	it	ge
 80138b0:	4613      	movge	r3, r2
 80138b2:	61fb      	str	r3, [r7, #28]
    int32_t core_w = lv_area_get_width(&core_area);
 80138b4:	f107 0310 	add.w	r3, r7, #16
 80138b8:	4618      	mov	r0, r3
 80138ba:	f7ff fe7a 	bl	80135b2 <lv_area_get_width>
 80138be:	f8c7 00d4 	str.w	r0, [r7, #212]	@ 0xd4

    bool top_side = outer_area->y1 <= inner_area->y1;
 80138c2:	68bb      	ldr	r3, [r7, #8]
 80138c4:	685a      	ldr	r2, [r3, #4]
 80138c6:	687b      	ldr	r3, [r7, #4]
 80138c8:	685b      	ldr	r3, [r3, #4]
 80138ca:	429a      	cmp	r2, r3
 80138cc:	bfd4      	ite	le
 80138ce:	2301      	movle	r3, #1
 80138d0:	2300      	movgt	r3, #0
 80138d2:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
    bool bottom_side = outer_area->y2 >= inner_area->y2;
 80138d6:	68bb      	ldr	r3, [r7, #8]
 80138d8:	68da      	ldr	r2, [r3, #12]
 80138da:	687b      	ldr	r3, [r7, #4]
 80138dc:	68db      	ldr	r3, [r3, #12]
 80138de:	429a      	cmp	r2, r3
 80138e0:	bfac      	ite	ge
 80138e2:	2301      	movge	r3, #1
 80138e4:	2300      	movlt	r3, #0
 80138e6:	f887 30d2 	strb.w	r3, [r7, #210]	@ 0xd2

    /*No masks*/
    bool left_side = outer_area->x1 <= inner_area->x1;
 80138ea:	68bb      	ldr	r3, [r7, #8]
 80138ec:	681a      	ldr	r2, [r3, #0]
 80138ee:	687b      	ldr	r3, [r7, #4]
 80138f0:	681b      	ldr	r3, [r3, #0]
 80138f2:	429a      	cmp	r2, r3
 80138f4:	bfd4      	ite	le
 80138f6:	2301      	movle	r3, #1
 80138f8:	2300      	movgt	r3, #0
 80138fa:	f887 30d1 	strb.w	r3, [r7, #209]	@ 0xd1
    bool right_side = outer_area->x2 >= inner_area->x2;
 80138fe:	68bb      	ldr	r3, [r7, #8]
 8013900:	689a      	ldr	r2, [r3, #8]
 8013902:	687b      	ldr	r3, [r7, #4]
 8013904:	689b      	ldr	r3, [r3, #8]
 8013906:	429a      	cmp	r2, r3
 8013908:	bfac      	ite	ge
 801390a:	2301      	movge	r3, #1
 801390c:	2300      	movlt	r3, #0
 801390e:	f887 30d0 	strb.w	r3, [r7, #208]	@ 0xd0

    bool split_hor = true;
 8013912:	2301      	movs	r3, #1
 8013914:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
    if(left_side && right_side && top_side && bottom_side &&
 8013918:	f897 30d1 	ldrb.w	r3, [r7, #209]	@ 0xd1
 801391c:	2b00      	cmp	r3, #0
 801391e:	d012      	beq.n	8013946 <draw_border_complex+0x1a2>
 8013920:	f897 30d0 	ldrb.w	r3, [r7, #208]	@ 0xd0
 8013924:	2b00      	cmp	r3, #0
 8013926:	d00e      	beq.n	8013946 <draw_border_complex+0x1a2>
 8013928:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 801392c:	2b00      	cmp	r3, #0
 801392e:	d00a      	beq.n	8013946 <draw_border_complex+0x1a2>
 8013930:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
 8013934:	2b00      	cmp	r3, #0
 8013936:	d006      	beq.n	8013946 <draw_border_complex+0x1a2>
 8013938:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801393c:	2b31      	cmp	r3, #49	@ 0x31
 801393e:	dc02      	bgt.n	8013946 <draw_border_complex+0x1a2>
       core_w < SPLIT_LIMIT) {
        split_hor = false;
 8013940:	2300      	movs	r3, #0
 8013942:	f887 30e3 	strb.w	r3, [r7, #227]	@ 0xe3
    }

    blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_FULL_COVER;
 8013946:	2301      	movs	r3, #1
 8013948:	f887 30a0 	strb.w	r3, [r7, #160]	@ 0xa0
    /*Draw the straight lines first if they are long enough*/
    if(top_side && split_hor) {
 801394c:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 8013950:	2b00      	cmp	r3, #0
 8013952:	d014      	beq.n	801397e <draw_border_complex+0x1da>
 8013954:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013958:	2b00      	cmp	r3, #0
 801395a:	d010      	beq.n	801397e <draw_border_complex+0x1da>
        blend_area.x1 = core_area.x1;
 801395c:	693b      	ldr	r3, [r7, #16]
 801395e:	623b      	str	r3, [r7, #32]
        blend_area.x2 = core_area.x2;
 8013960:	69bb      	ldr	r3, [r7, #24]
 8013962:	62bb      	str	r3, [r7, #40]	@ 0x28
        blend_area.y1 = outer_area->y1;
 8013964:	68bb      	ldr	r3, [r7, #8]
 8013966:	685b      	ldr	r3, [r3, #4]
 8013968:	627b      	str	r3, [r7, #36]	@ 0x24
        blend_area.y2 = inner_area->y1 - 1;
 801396a:	687b      	ldr	r3, [r7, #4]
 801396c:	685b      	ldr	r3, [r3, #4]
 801396e:	3b01      	subs	r3, #1
 8013970:	62fb      	str	r3, [r7, #44]	@ 0x2c
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013972:	f107 0384 	add.w	r3, r7, #132	@ 0x84
 8013976:	4619      	mov	r1, r3
 8013978:	68f8      	ldr	r0, [r7, #12]
 801397a:	f7fa ffcb 	bl	800e914 <lv_draw_sw_blend>
    }

    if(bottom_side && split_hor) {
 801397e:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
 8013982:	2b00      	cmp	r3, #0
 8013984:	d014      	beq.n	80139b0 <draw_border_complex+0x20c>
 8013986:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 801398a:	2b00      	cmp	r3, #0
 801398c:	d010      	beq.n	80139b0 <draw_border_complex+0x20c>
        blend_area.x1 = core_area.x1;
 801398e:	693b      	ldr	r3, [r7, #16]
 8013990:	623b      	str	r3, [r7, #32]
        blend_area.x2 = core_area.x2;
 8013992:	69bb      	ldr	r3, [r7, #24]
 8013994:	62bb      	str	r3, [r7, #40]	@ 0x28
        blend_area.y1 = inner_area->y2 + 1;
 8013996:	687b      	ldr	r3, [r7, #4]
 8013998:	68db      	ldr	r3, [r3, #12]
 801399a:	3301      	adds	r3, #1
 801399c:	627b      	str	r3, [r7, #36]	@ 0x24
        blend_area.y2 = outer_area->y2;
 801399e:	68bb      	ldr	r3, [r7, #8]
 80139a0:	68db      	ldr	r3, [r3, #12]
 80139a2:	62fb      	str	r3, [r7, #44]	@ 0x2c
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 80139a4:	f107 0384 	add.w	r3, r7, #132	@ 0x84
 80139a8:	4619      	mov	r1, r3
 80139aa:	68f8      	ldr	r0, [r7, #12]
 80139ac:	f7fa ffb2 	bl	800e914 <lv_draw_sw_blend>
    }

    /*If the border is very thick and the vertical sides overlap horizontally draw a single rectangle*/
    if(inner_area->x1 >= inner_area->x2 && left_side && right_side) {
 80139b0:	687b      	ldr	r3, [r7, #4]
 80139b2:	681a      	ldr	r2, [r3, #0]
 80139b4:	687b      	ldr	r3, [r7, #4]
 80139b6:	689b      	ldr	r3, [r3, #8]
 80139b8:	429a      	cmp	r2, r3
 80139ba:	db18      	blt.n	80139ee <draw_border_complex+0x24a>
 80139bc:	f897 30d1 	ldrb.w	r3, [r7, #209]	@ 0xd1
 80139c0:	2b00      	cmp	r3, #0
 80139c2:	d014      	beq.n	80139ee <draw_border_complex+0x24a>
 80139c4:	f897 30d0 	ldrb.w	r3, [r7, #208]	@ 0xd0
 80139c8:	2b00      	cmp	r3, #0
 80139ca:	d010      	beq.n	80139ee <draw_border_complex+0x24a>
        blend_area.x1 = outer_area->x1;
 80139cc:	68bb      	ldr	r3, [r7, #8]
 80139ce:	681b      	ldr	r3, [r3, #0]
 80139d0:	623b      	str	r3, [r7, #32]
        blend_area.x2 = outer_area->x2;
 80139d2:	68bb      	ldr	r3, [r7, #8]
 80139d4:	689b      	ldr	r3, [r3, #8]
 80139d6:	62bb      	str	r3, [r7, #40]	@ 0x28
        blend_area.y1 = core_area.y1;
 80139d8:	697b      	ldr	r3, [r7, #20]
 80139da:	627b      	str	r3, [r7, #36]	@ 0x24
        blend_area.y2 = core_area.y2;
 80139dc:	69fb      	ldr	r3, [r7, #28]
 80139de:	62fb      	str	r3, [r7, #44]	@ 0x2c
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 80139e0:	f107 0384 	add.w	r3, r7, #132	@ 0x84
 80139e4:	4619      	mov	r1, r3
 80139e6:	68f8      	ldr	r0, [r7, #12]
 80139e8:	f7fa ff94 	bl	800e914 <lv_draw_sw_blend>
 80139ec:	e029      	b.n	8013a42 <draw_border_complex+0x29e>
    }
    else {
        if(left_side) {
 80139ee:	f897 30d1 	ldrb.w	r3, [r7, #209]	@ 0xd1
 80139f2:	2b00      	cmp	r3, #0
 80139f4:	d010      	beq.n	8013a18 <draw_border_complex+0x274>
            blend_area.x1 = outer_area->x1;
 80139f6:	68bb      	ldr	r3, [r7, #8]
 80139f8:	681b      	ldr	r3, [r3, #0]
 80139fa:	623b      	str	r3, [r7, #32]
            blend_area.x2 = inner_area->x1 - 1;
 80139fc:	687b      	ldr	r3, [r7, #4]
 80139fe:	681b      	ldr	r3, [r3, #0]
 8013a00:	3b01      	subs	r3, #1
 8013a02:	62bb      	str	r3, [r7, #40]	@ 0x28
            blend_area.y1 = core_area.y1;
 8013a04:	697b      	ldr	r3, [r7, #20]
 8013a06:	627b      	str	r3, [r7, #36]	@ 0x24
            blend_area.y2 = core_area.y2;
 8013a08:	69fb      	ldr	r3, [r7, #28]
 8013a0a:	62fb      	str	r3, [r7, #44]	@ 0x2c
            lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013a0c:	f107 0384 	add.w	r3, r7, #132	@ 0x84
 8013a10:	4619      	mov	r1, r3
 8013a12:	68f8      	ldr	r0, [r7, #12]
 8013a14:	f7fa ff7e 	bl	800e914 <lv_draw_sw_blend>
        }

        if(right_side) {
 8013a18:	f897 30d0 	ldrb.w	r3, [r7, #208]	@ 0xd0
 8013a1c:	2b00      	cmp	r3, #0
 8013a1e:	d010      	beq.n	8013a42 <draw_border_complex+0x29e>
            blend_area.x1 = inner_area->x2 + 1;
 8013a20:	687b      	ldr	r3, [r7, #4]
 8013a22:	689b      	ldr	r3, [r3, #8]
 8013a24:	3301      	adds	r3, #1
 8013a26:	623b      	str	r3, [r7, #32]
            blend_area.x2 = outer_area->x2;
 8013a28:	68bb      	ldr	r3, [r7, #8]
 8013a2a:	689b      	ldr	r3, [r3, #8]
 8013a2c:	62bb      	str	r3, [r7, #40]	@ 0x28
            blend_area.y1 = core_area.y1;
 8013a2e:	697b      	ldr	r3, [r7, #20]
 8013a30:	627b      	str	r3, [r7, #36]	@ 0x24
            blend_area.y2 = core_area.y2;
 8013a32:	69fb      	ldr	r3, [r7, #28]
 8013a34:	62fb      	str	r3, [r7, #44]	@ 0x2c
            lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013a36:	f107 0384 	add.w	r3, r7, #132	@ 0x84
 8013a3a:	4619      	mov	r1, r3
 8013a3c:	68f8      	ldr	r0, [r7, #12]
 8013a3e:	f7fa ff69 	bl	800e914 <lv_draw_sw_blend>

    /*Draw the corners*/
    int32_t blend_w;

    /*Left and right corner together if they are close to each other*/
    if(!split_hor) {
 8013a42:	f897 30e3 	ldrb.w	r3, [r7, #227]	@ 0xe3
 8013a46:	f083 0301 	eor.w	r3, r3, #1
 8013a4a:	b2db      	uxtb	r3, r3
 8013a4c:	2b00      	cmp	r3, #0
 8013a4e:	d077      	beq.n	8013b40 <draw_border_complex+0x39c>
        /*Calculate the top corner and mirror it to the bottom*/
        blend_area.x1 = draw_area.x1;
 8013a50:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8013a54:	623b      	str	r3, [r7, #32]
        blend_area.x2 = draw_area.x2;
 8013a56:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8013a5a:	62bb      	str	r3, [r7, #40]	@ 0x28
        int32_t max_h = LV_MAX(rout, inner_area->y1 - outer_area->y1);
 8013a5c:	687b      	ldr	r3, [r7, #4]
 8013a5e:	685a      	ldr	r2, [r3, #4]
 8013a60:	68bb      	ldr	r3, [r7, #8]
 8013a62:	685b      	ldr	r3, [r3, #4]
 8013a64:	1ad3      	subs	r3, r2, r3
 8013a66:	683a      	ldr	r2, [r7, #0]
 8013a68:	4293      	cmp	r3, r2
 8013a6a:	bfb8      	it	lt
 8013a6c:	4613      	movlt	r3, r2
 8013a6e:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
        for(h = 0; h < max_h; h++) {
 8013a72:	2300      	movs	r3, #0
 8013a74:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8013a78:	e05b      	b.n	8013b32 <draw_border_complex+0x38e>
            int32_t top_y = outer_area->y1 + h;
 8013a7a:	68bb      	ldr	r3, [r7, #8]
 8013a7c:	685b      	ldr	r3, [r3, #4]
 8013a7e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8013a82:	4413      	add	r3, r2
 8013a84:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
            int32_t bottom_y = outer_area->y2 - h;
 8013a88:	68bb      	ldr	r3, [r7, #8]
 8013a8a:	68da      	ldr	r2, [r3, #12]
 8013a8c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013a90:	1ad3      	subs	r3, r2, r3
 8013a92:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
            if(top_y < draw_area.y1 && bottom_y > draw_area.y2) continue;   /*This line is clipped now*/
 8013a96:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8013a9a:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8013a9e:	429a      	cmp	r2, r3
 8013aa0:	da05      	bge.n	8013aae <draw_border_complex+0x30a>
 8013aa2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8013aa6:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 8013aaa:	429a      	cmp	r2, r3
 8013aac:	dc3b      	bgt.n	8013b26 <draw_border_complex+0x382>

            lv_memset(mask_buf, 0xff, draw_area_w);
 8013aae:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8013ab2:	461a      	mov	r2, r3
 8013ab4:	21ff      	movs	r1, #255	@ 0xff
 8013ab6:	f8d7 00d8 	ldr.w	r0, [r7, #216]	@ 0xd8
 8013aba:	f011 f9b2 	bl	8024e22 <lv_memset>
            blend_dsc.mask_res = lv_draw_sw_mask_apply(mask_list, mask_buf, blend_area.x1, top_y, draw_area_w);
 8013abe:	6a3a      	ldr	r2, [r7, #32]
 8013ac0:	f107 0078 	add.w	r0, r7, #120	@ 0x78
 8013ac4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8013ac8:	9300      	str	r3, [sp, #0]
 8013aca:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8013ace:	f8d7 10d8 	ldr.w	r1, [r7, #216]	@ 0xd8
 8013ad2:	f004 fb4b 	bl	801816c <lv_draw_sw_mask_apply>
 8013ad6:	4603      	mov	r3, r0
 8013ad8:	f887 30a0 	strb.w	r3, [r7, #160]	@ 0xa0

            if(top_y >= draw_area.y1) {
 8013adc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8013ae0:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8013ae4:	429a      	cmp	r2, r3
 8013ae6:	db0b      	blt.n	8013b00 <draw_border_complex+0x35c>
                blend_area.y1 = top_y;
 8013ae8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8013aec:	627b      	str	r3, [r7, #36]	@ 0x24
                blend_area.y2 = top_y;
 8013aee:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8013af2:	62fb      	str	r3, [r7, #44]	@ 0x2c
                lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013af4:	f107 0384 	add.w	r3, r7, #132	@ 0x84
 8013af8:	4619      	mov	r1, r3
 8013afa:	68f8      	ldr	r0, [r7, #12]
 8013afc:	f7fa ff0a 	bl	800e914 <lv_draw_sw_blend>
            }

            if(bottom_y <= draw_area.y2) {
 8013b00:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8013b04:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 8013b08:	429a      	cmp	r2, r3
 8013b0a:	dc0d      	bgt.n	8013b28 <draw_border_complex+0x384>
                blend_area.y1 = bottom_y;
 8013b0c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8013b10:	627b      	str	r3, [r7, #36]	@ 0x24
                blend_area.y2 = bottom_y;
 8013b12:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8013b16:	62fb      	str	r3, [r7, #44]	@ 0x2c
                lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013b18:	f107 0384 	add.w	r3, r7, #132	@ 0x84
 8013b1c:	4619      	mov	r1, r3
 8013b1e:	68f8      	ldr	r0, [r7, #12]
 8013b20:	f7fa fef8 	bl	800e914 <lv_draw_sw_blend>
 8013b24:	e000      	b.n	8013b28 <draw_border_complex+0x384>
            if(top_y < draw_area.y1 && bottom_y > draw_area.y2) continue;   /*This line is clipped now*/
 8013b26:	bf00      	nop
        for(h = 0; h < max_h; h++) {
 8013b28:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013b2c:	3301      	adds	r3, #1
 8013b2e:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8013b32:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8013b36:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8013b3a:	429a      	cmp	r2, r3
 8013b3c:	db9d      	blt.n	8013a7a <draw_border_complex+0x2d6>
 8013b3e:	e11d      	b.n	8013d7c <draw_border_complex+0x5d8>
            }
        }
    }
    else {
        /*Left corners*/
        blend_area.x1 = draw_area.x1;
 8013b40:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8013b44:	623b      	str	r3, [r7, #32]
        blend_area.x2 = LV_MIN(draw_area.x2, core_area.x1 - 1);
 8013b46:	693b      	ldr	r3, [r7, #16]
 8013b48:	1e5a      	subs	r2, r3, #1
 8013b4a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8013b4e:	4293      	cmp	r3, r2
 8013b50:	bfa8      	it	ge
 8013b52:	4613      	movge	r3, r2
 8013b54:	62bb      	str	r3, [r7, #40]	@ 0x28
        blend_w = lv_area_get_width(&blend_area);
 8013b56:	f107 0320 	add.w	r3, r7, #32
 8013b5a:	4618      	mov	r0, r3
 8013b5c:	f7ff fd29 	bl	80135b2 <lv_area_get_width>
 8013b60:	f8c7 00cc 	str.w	r0, [r7, #204]	@ 0xcc
        if(blend_w > 0) {
 8013b64:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8013b68:	2b00      	cmp	r3, #0
 8013b6a:	dd74      	ble.n	8013c56 <draw_border_complex+0x4b2>
            if(left_side || top_side) {
 8013b6c:	f897 30d1 	ldrb.w	r3, [r7, #209]	@ 0xd1
 8013b70:	2b00      	cmp	r3, #0
 8013b72:	d103      	bne.n	8013b7c <draw_border_complex+0x3d8>
 8013b74:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 8013b78:	2b00      	cmp	r3, #0
 8013b7a:	d031      	beq.n	8013be0 <draw_border_complex+0x43c>
                for(h = draw_area.y1; h < core_area.y1; h++) {
 8013b7c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8013b80:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8013b84:	e027      	b.n	8013bd6 <draw_border_complex+0x432>
                    blend_area.y1 = h;
 8013b86:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013b8a:	627b      	str	r3, [r7, #36]	@ 0x24
                    blend_area.y2 = h;
 8013b8c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013b90:	62fb      	str	r3, [r7, #44]	@ 0x2c

                    lv_memset(mask_buf, 0xff, blend_w);
 8013b92:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8013b96:	461a      	mov	r2, r3
 8013b98:	21ff      	movs	r1, #255	@ 0xff
 8013b9a:	f8d7 00d8 	ldr.w	r0, [r7, #216]	@ 0xd8
 8013b9e:	f011 f940 	bl	8024e22 <lv_memset>
                    blend_dsc.mask_res = lv_draw_sw_mask_apply(mask_list, mask_buf, blend_area.x1, h, blend_w);
 8013ba2:	6a3a      	ldr	r2, [r7, #32]
 8013ba4:	f107 0078 	add.w	r0, r7, #120	@ 0x78
 8013ba8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8013bac:	9300      	str	r3, [sp, #0]
 8013bae:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013bb2:	f8d7 10d8 	ldr.w	r1, [r7, #216]	@ 0xd8
 8013bb6:	f004 fad9 	bl	801816c <lv_draw_sw_mask_apply>
 8013bba:	4603      	mov	r3, r0
 8013bbc:	f887 30a0 	strb.w	r3, [r7, #160]	@ 0xa0
                    lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013bc0:	f107 0384 	add.w	r3, r7, #132	@ 0x84
 8013bc4:	4619      	mov	r1, r3
 8013bc6:	68f8      	ldr	r0, [r7, #12]
 8013bc8:	f7fa fea4 	bl	800e914 <lv_draw_sw_blend>
                for(h = draw_area.y1; h < core_area.y1; h++) {
 8013bcc:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013bd0:	3301      	adds	r3, #1
 8013bd2:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8013bd6:	697b      	ldr	r3, [r7, #20]
 8013bd8:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8013bdc:	429a      	cmp	r2, r3
 8013bde:	dbd2      	blt.n	8013b86 <draw_border_complex+0x3e2>
                }
            }

            if(left_side || bottom_side) {
 8013be0:	f897 30d1 	ldrb.w	r3, [r7, #209]	@ 0xd1
 8013be4:	2b00      	cmp	r3, #0
 8013be6:	d103      	bne.n	8013bf0 <draw_border_complex+0x44c>
 8013be8:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
 8013bec:	2b00      	cmp	r3, #0
 8013bee:	d032      	beq.n	8013c56 <draw_border_complex+0x4b2>
                for(h = core_area.y2 + 1; h <= draw_area.y2; h++) {
 8013bf0:	69fb      	ldr	r3, [r7, #28]
 8013bf2:	3301      	adds	r3, #1
 8013bf4:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8013bf8:	e027      	b.n	8013c4a <draw_border_complex+0x4a6>
                    blend_area.y1 = h;
 8013bfa:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013bfe:	627b      	str	r3, [r7, #36]	@ 0x24
                    blend_area.y2 = h;
 8013c00:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013c04:	62fb      	str	r3, [r7, #44]	@ 0x2c

                    lv_memset(mask_buf, 0xff, blend_w);
 8013c06:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8013c0a:	461a      	mov	r2, r3
 8013c0c:	21ff      	movs	r1, #255	@ 0xff
 8013c0e:	f8d7 00d8 	ldr.w	r0, [r7, #216]	@ 0xd8
 8013c12:	f011 f906 	bl	8024e22 <lv_memset>
                    blend_dsc.mask_res = lv_draw_sw_mask_apply(mask_list, mask_buf, blend_area.x1, h, blend_w);
 8013c16:	6a3a      	ldr	r2, [r7, #32]
 8013c18:	f107 0078 	add.w	r0, r7, #120	@ 0x78
 8013c1c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8013c20:	9300      	str	r3, [sp, #0]
 8013c22:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013c26:	f8d7 10d8 	ldr.w	r1, [r7, #216]	@ 0xd8
 8013c2a:	f004 fa9f 	bl	801816c <lv_draw_sw_mask_apply>
 8013c2e:	4603      	mov	r3, r0
 8013c30:	f887 30a0 	strb.w	r3, [r7, #160]	@ 0xa0
                    lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013c34:	f107 0384 	add.w	r3, r7, #132	@ 0x84
 8013c38:	4619      	mov	r1, r3
 8013c3a:	68f8      	ldr	r0, [r7, #12]
 8013c3c:	f7fa fe6a 	bl	800e914 <lv_draw_sw_blend>
                for(h = core_area.y2 + 1; h <= draw_area.y2; h++) {
 8013c40:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013c44:	3301      	adds	r3, #1
 8013c46:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8013c4a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8013c4e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8013c52:	429a      	cmp	r2, r3
 8013c54:	ddd1      	ble.n	8013bfa <draw_border_complex+0x456>
                }
            }
        }

        /*Right corners*/
        blend_area.x1 = LV_MAX(draw_area.x1, blend_area.x2 + 1);    /*To not overlap with the left side*/
 8013c56:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8013c58:	1c5a      	adds	r2, r3, #1
 8013c5a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8013c5e:	4293      	cmp	r3, r2
 8013c60:	bfb8      	it	lt
 8013c62:	4613      	movlt	r3, r2
 8013c64:	623b      	str	r3, [r7, #32]
        blend_area.x1 = LV_MAX(draw_area.x1, core_area.x2 + 1);
 8013c66:	69bb      	ldr	r3, [r7, #24]
 8013c68:	1c5a      	adds	r2, r3, #1
 8013c6a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8013c6e:	4293      	cmp	r3, r2
 8013c70:	bfb8      	it	lt
 8013c72:	4613      	movlt	r3, r2
 8013c74:	623b      	str	r3, [r7, #32]

        blend_area.x2 = draw_area.x2;
 8013c76:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8013c7a:	62bb      	str	r3, [r7, #40]	@ 0x28
        blend_w = lv_area_get_width(&blend_area);
 8013c7c:	f107 0320 	add.w	r3, r7, #32
 8013c80:	4618      	mov	r0, r3
 8013c82:	f7ff fc96 	bl	80135b2 <lv_area_get_width>
 8013c86:	f8c7 00cc 	str.w	r0, [r7, #204]	@ 0xcc

        if(blend_w > 0) {
 8013c8a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8013c8e:	2b00      	cmp	r3, #0
 8013c90:	dd74      	ble.n	8013d7c <draw_border_complex+0x5d8>
            if(right_side || top_side) {
 8013c92:	f897 30d0 	ldrb.w	r3, [r7, #208]	@ 0xd0
 8013c96:	2b00      	cmp	r3, #0
 8013c98:	d103      	bne.n	8013ca2 <draw_border_complex+0x4fe>
 8013c9a:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 8013c9e:	2b00      	cmp	r3, #0
 8013ca0:	d031      	beq.n	8013d06 <draw_border_complex+0x562>
                for(h = draw_area.y1; h < core_area.y1; h++) {
 8013ca2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8013ca6:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8013caa:	e027      	b.n	8013cfc <draw_border_complex+0x558>
                    blend_area.y1 = h;
 8013cac:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013cb0:	627b      	str	r3, [r7, #36]	@ 0x24
                    blend_area.y2 = h;
 8013cb2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013cb6:	62fb      	str	r3, [r7, #44]	@ 0x2c

                    lv_memset(mask_buf, 0xff, blend_w);
 8013cb8:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8013cbc:	461a      	mov	r2, r3
 8013cbe:	21ff      	movs	r1, #255	@ 0xff
 8013cc0:	f8d7 00d8 	ldr.w	r0, [r7, #216]	@ 0xd8
 8013cc4:	f011 f8ad 	bl	8024e22 <lv_memset>
                    blend_dsc.mask_res = lv_draw_sw_mask_apply(mask_list, mask_buf, blend_area.x1, h, blend_w);
 8013cc8:	6a3a      	ldr	r2, [r7, #32]
 8013cca:	f107 0078 	add.w	r0, r7, #120	@ 0x78
 8013cce:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8013cd2:	9300      	str	r3, [sp, #0]
 8013cd4:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013cd8:	f8d7 10d8 	ldr.w	r1, [r7, #216]	@ 0xd8
 8013cdc:	f004 fa46 	bl	801816c <lv_draw_sw_mask_apply>
 8013ce0:	4603      	mov	r3, r0
 8013ce2:	f887 30a0 	strb.w	r3, [r7, #160]	@ 0xa0
                    lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013ce6:	f107 0384 	add.w	r3, r7, #132	@ 0x84
 8013cea:	4619      	mov	r1, r3
 8013cec:	68f8      	ldr	r0, [r7, #12]
 8013cee:	f7fa fe11 	bl	800e914 <lv_draw_sw_blend>
                for(h = draw_area.y1; h < core_area.y1; h++) {
 8013cf2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013cf6:	3301      	adds	r3, #1
 8013cf8:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8013cfc:	697b      	ldr	r3, [r7, #20]
 8013cfe:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8013d02:	429a      	cmp	r2, r3
 8013d04:	dbd2      	blt.n	8013cac <draw_border_complex+0x508>
                }
            }

            if(right_side || bottom_side) {
 8013d06:	f897 30d0 	ldrb.w	r3, [r7, #208]	@ 0xd0
 8013d0a:	2b00      	cmp	r3, #0
 8013d0c:	d103      	bne.n	8013d16 <draw_border_complex+0x572>
 8013d0e:	f897 30d2 	ldrb.w	r3, [r7, #210]	@ 0xd2
 8013d12:	2b00      	cmp	r3, #0
 8013d14:	d032      	beq.n	8013d7c <draw_border_complex+0x5d8>
                for(h = core_area.y2 + 1; h <= draw_area.y2; h++) {
 8013d16:	69fb      	ldr	r3, [r7, #28]
 8013d18:	3301      	adds	r3, #1
 8013d1a:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8013d1e:	e027      	b.n	8013d70 <draw_border_complex+0x5cc>
                    blend_area.y1 = h;
 8013d20:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013d24:	627b      	str	r3, [r7, #36]	@ 0x24
                    blend_area.y2 = h;
 8013d26:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013d2a:	62fb      	str	r3, [r7, #44]	@ 0x2c

                    lv_memset(mask_buf, 0xff, blend_w);
 8013d2c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8013d30:	461a      	mov	r2, r3
 8013d32:	21ff      	movs	r1, #255	@ 0xff
 8013d34:	f8d7 00d8 	ldr.w	r0, [r7, #216]	@ 0xd8
 8013d38:	f011 f873 	bl	8024e22 <lv_memset>
                    blend_dsc.mask_res = lv_draw_sw_mask_apply(mask_list, mask_buf, blend_area.x1, h, blend_w);
 8013d3c:	6a3a      	ldr	r2, [r7, #32]
 8013d3e:	f107 0078 	add.w	r0, r7, #120	@ 0x78
 8013d42:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8013d46:	9300      	str	r3, [sp, #0]
 8013d48:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013d4c:	f8d7 10d8 	ldr.w	r1, [r7, #216]	@ 0xd8
 8013d50:	f004 fa0c 	bl	801816c <lv_draw_sw_mask_apply>
 8013d54:	4603      	mov	r3, r0
 8013d56:	f887 30a0 	strb.w	r3, [r7, #160]	@ 0xa0
                    lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013d5a:	f107 0384 	add.w	r3, r7, #132	@ 0x84
 8013d5e:	4619      	mov	r1, r3
 8013d60:	68f8      	ldr	r0, [r7, #12]
 8013d62:	f7fa fdd7 	bl	800e914 <lv_draw_sw_blend>
                for(h = core_area.y2 + 1; h <= draw_area.y2; h++) {
 8013d66:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8013d6a:	3301      	adds	r3, #1
 8013d6c:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8013d70:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8013d74:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8013d78:	429a      	cmp	r2, r3
 8013d7a:	ddd1      	ble.n	8013d20 <draw_border_complex+0x57c>
                }
            }
        }
    }

    lv_draw_sw_mask_free_param(&mask_rin_param);
 8013d7c:	f107 0354 	add.w	r3, r7, #84	@ 0x54
 8013d80:	4618      	mov	r0, r3
 8013d82:	f004 fa35 	bl	80181f0 <lv_draw_sw_mask_free_param>
    if(rout > 0) lv_draw_sw_mask_free_param(&mask_rout_param);
 8013d86:	683b      	ldr	r3, [r7, #0]
 8013d88:	2b00      	cmp	r3, #0
 8013d8a:	dd04      	ble.n	8013d96 <draw_border_complex+0x5f2>
 8013d8c:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8013d90:	4618      	mov	r0, r3
 8013d92:	f004 fa2d 	bl	80181f0 <lv_draw_sw_mask_free_param>
    lv_free(mask_buf);
 8013d96:	f8d7 00d8 	ldr.w	r0, [r7, #216]	@ 0xd8
 8013d9a:	f012 f84d 	bl	8025e38 <lv_free>
 8013d9e:	e000      	b.n	8013da2 <draw_border_complex+0x5fe>
    if(!_lv_area_intersect(&draw_area, outer_area, draw_unit->clip_area)) return;
 8013da0:	bf00      	nop

#endif /*LV_DRAW_SW_COMPLEX*/
}
 8013da2:	37e8      	adds	r7, #232	@ 0xe8
 8013da4:	46bd      	mov	sp, r7
 8013da6:	bd80      	pop	{r7, pc}

08013da8 <draw_border_simple>:
static void draw_border_simple(lv_draw_unit_t * draw_unit, const lv_area_t * outer_area, const lv_area_t * inner_area,
                               lv_color_t color, lv_opa_t opa)
{
 8013da8:	b580      	push	{r7, lr}
 8013daa:	b094      	sub	sp, #80	@ 0x50
 8013dac:	af00      	add	r7, sp, #0
 8013dae:	60f8      	str	r0, [r7, #12]
 8013db0:	60b9      	str	r1, [r7, #8]
 8013db2:	607a      	str	r2, [r7, #4]
 8013db4:	603b      	str	r3, [r7, #0]
    lv_area_t a;
    lv_draw_sw_blend_dsc_t blend_dsc;
    lv_memzero(&blend_dsc, sizeof(lv_draw_sw_blend_dsc_t));
 8013db6:	f107 0310 	add.w	r3, r7, #16
 8013dba:	212c      	movs	r1, #44	@ 0x2c
 8013dbc:	4618      	mov	r0, r3
 8013dbe:	f7ff fc18 	bl	80135f2 <lv_memzero>
    blend_dsc.blend_area = &a;
 8013dc2:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8013dc6:	613b      	str	r3, [r7, #16]
    blend_dsc.color = color;
 8013dc8:	f107 0325 	add.w	r3, r7, #37	@ 0x25
 8013dcc:	463a      	mov	r2, r7
 8013dce:	8811      	ldrh	r1, [r2, #0]
 8013dd0:	7892      	ldrb	r2, [r2, #2]
 8013dd2:	8019      	strh	r1, [r3, #0]
 8013dd4:	709a      	strb	r2, [r3, #2]
    blend_dsc.opa = opa;
 8013dd6:	f897 3058 	ldrb.w	r3, [r7, #88]	@ 0x58
 8013dda:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24

    bool top_side = outer_area->y1 <= inner_area->y1;
 8013dde:	68bb      	ldr	r3, [r7, #8]
 8013de0:	685a      	ldr	r2, [r3, #4]
 8013de2:	687b      	ldr	r3, [r7, #4]
 8013de4:	685b      	ldr	r3, [r3, #4]
 8013de6:	429a      	cmp	r2, r3
 8013de8:	bfd4      	ite	le
 8013dea:	2301      	movle	r3, #1
 8013dec:	2300      	movgt	r3, #0
 8013dee:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
    bool bottom_side = outer_area->y2 >= inner_area->y2;
 8013df2:	68bb      	ldr	r3, [r7, #8]
 8013df4:	68da      	ldr	r2, [r3, #12]
 8013df6:	687b      	ldr	r3, [r7, #4]
 8013df8:	68db      	ldr	r3, [r3, #12]
 8013dfa:	429a      	cmp	r2, r3
 8013dfc:	bfac      	ite	ge
 8013dfe:	2301      	movge	r3, #1
 8013e00:	2300      	movlt	r3, #0
 8013e02:	f887 304e 	strb.w	r3, [r7, #78]	@ 0x4e
    bool left_side = outer_area->x1 <= inner_area->x1;
 8013e06:	68bb      	ldr	r3, [r7, #8]
 8013e08:	681a      	ldr	r2, [r3, #0]
 8013e0a:	687b      	ldr	r3, [r7, #4]
 8013e0c:	681b      	ldr	r3, [r3, #0]
 8013e0e:	429a      	cmp	r2, r3
 8013e10:	bfd4      	ite	le
 8013e12:	2301      	movle	r3, #1
 8013e14:	2300      	movgt	r3, #0
 8013e16:	f887 304d 	strb.w	r3, [r7, #77]	@ 0x4d
    bool right_side = outer_area->x2 >= inner_area->x2;
 8013e1a:	68bb      	ldr	r3, [r7, #8]
 8013e1c:	689a      	ldr	r2, [r3, #8]
 8013e1e:	687b      	ldr	r3, [r7, #4]
 8013e20:	689b      	ldr	r3, [r3, #8]
 8013e22:	429a      	cmp	r2, r3
 8013e24:	bfac      	ite	ge
 8013e26:	2301      	movge	r3, #1
 8013e28:	2300      	movlt	r3, #0
 8013e2a:	f887 304c 	strb.w	r3, [r7, #76]	@ 0x4c

    /*Top*/
    a.x1 = outer_area->x1;
 8013e2e:	68bb      	ldr	r3, [r7, #8]
 8013e30:	681b      	ldr	r3, [r3, #0]
 8013e32:	63fb      	str	r3, [r7, #60]	@ 0x3c
    a.x2 = outer_area->x2;
 8013e34:	68bb      	ldr	r3, [r7, #8]
 8013e36:	689b      	ldr	r3, [r3, #8]
 8013e38:	647b      	str	r3, [r7, #68]	@ 0x44
    a.y1 = outer_area->y1;
 8013e3a:	68bb      	ldr	r3, [r7, #8]
 8013e3c:	685b      	ldr	r3, [r3, #4]
 8013e3e:	643b      	str	r3, [r7, #64]	@ 0x40
    a.y2 = inner_area->y1 - 1;
 8013e40:	687b      	ldr	r3, [r7, #4]
 8013e42:	685b      	ldr	r3, [r3, #4]
 8013e44:	3b01      	subs	r3, #1
 8013e46:	64bb      	str	r3, [r7, #72]	@ 0x48
    if(top_side) {
 8013e48:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 8013e4c:	2b00      	cmp	r3, #0
 8013e4e:	d005      	beq.n	8013e5c <draw_border_simple+0xb4>
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013e50:	f107 0310 	add.w	r3, r7, #16
 8013e54:	4619      	mov	r1, r3
 8013e56:	68f8      	ldr	r0, [r7, #12]
 8013e58:	f7fa fd5c 	bl	800e914 <lv_draw_sw_blend>
    }

    /*Bottom*/
    a.y1 = inner_area->y2 + 1;
 8013e5c:	687b      	ldr	r3, [r7, #4]
 8013e5e:	68db      	ldr	r3, [r3, #12]
 8013e60:	3301      	adds	r3, #1
 8013e62:	643b      	str	r3, [r7, #64]	@ 0x40
    a.y2 = outer_area->y2;
 8013e64:	68bb      	ldr	r3, [r7, #8]
 8013e66:	68db      	ldr	r3, [r3, #12]
 8013e68:	64bb      	str	r3, [r7, #72]	@ 0x48
    if(bottom_side) {
 8013e6a:	f897 304e 	ldrb.w	r3, [r7, #78]	@ 0x4e
 8013e6e:	2b00      	cmp	r3, #0
 8013e70:	d005      	beq.n	8013e7e <draw_border_simple+0xd6>
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013e72:	f107 0310 	add.w	r3, r7, #16
 8013e76:	4619      	mov	r1, r3
 8013e78:	68f8      	ldr	r0, [r7, #12]
 8013e7a:	f7fa fd4b 	bl	800e914 <lv_draw_sw_blend>
    }

    /*Left*/
    a.x1 = outer_area->x1;
 8013e7e:	68bb      	ldr	r3, [r7, #8]
 8013e80:	681b      	ldr	r3, [r3, #0]
 8013e82:	63fb      	str	r3, [r7, #60]	@ 0x3c
    a.x2 = inner_area->x1 - 1;
 8013e84:	687b      	ldr	r3, [r7, #4]
 8013e86:	681b      	ldr	r3, [r3, #0]
 8013e88:	3b01      	subs	r3, #1
 8013e8a:	647b      	str	r3, [r7, #68]	@ 0x44
    a.y1 = (top_side) ? inner_area->y1 : outer_area->y1;
 8013e8c:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 8013e90:	2b00      	cmp	r3, #0
 8013e92:	d002      	beq.n	8013e9a <draw_border_simple+0xf2>
 8013e94:	687b      	ldr	r3, [r7, #4]
 8013e96:	685b      	ldr	r3, [r3, #4]
 8013e98:	e001      	b.n	8013e9e <draw_border_simple+0xf6>
 8013e9a:	68bb      	ldr	r3, [r7, #8]
 8013e9c:	685b      	ldr	r3, [r3, #4]
 8013e9e:	643b      	str	r3, [r7, #64]	@ 0x40
    a.y2 = (bottom_side) ? inner_area->y2 : outer_area->y2;
 8013ea0:	f897 304e 	ldrb.w	r3, [r7, #78]	@ 0x4e
 8013ea4:	2b00      	cmp	r3, #0
 8013ea6:	d002      	beq.n	8013eae <draw_border_simple+0x106>
 8013ea8:	687b      	ldr	r3, [r7, #4]
 8013eaa:	68db      	ldr	r3, [r3, #12]
 8013eac:	e001      	b.n	8013eb2 <draw_border_simple+0x10a>
 8013eae:	68bb      	ldr	r3, [r7, #8]
 8013eb0:	68db      	ldr	r3, [r3, #12]
 8013eb2:	64bb      	str	r3, [r7, #72]	@ 0x48
    if(left_side) {
 8013eb4:	f897 304d 	ldrb.w	r3, [r7, #77]	@ 0x4d
 8013eb8:	2b00      	cmp	r3, #0
 8013eba:	d005      	beq.n	8013ec8 <draw_border_simple+0x120>
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013ebc:	f107 0310 	add.w	r3, r7, #16
 8013ec0:	4619      	mov	r1, r3
 8013ec2:	68f8      	ldr	r0, [r7, #12]
 8013ec4:	f7fa fd26 	bl	800e914 <lv_draw_sw_blend>
    }

    /*Right*/
    a.x1 = inner_area->x2 + 1;
 8013ec8:	687b      	ldr	r3, [r7, #4]
 8013eca:	689b      	ldr	r3, [r3, #8]
 8013ecc:	3301      	adds	r3, #1
 8013ece:	63fb      	str	r3, [r7, #60]	@ 0x3c
    a.x2 = outer_area->x2;
 8013ed0:	68bb      	ldr	r3, [r7, #8]
 8013ed2:	689b      	ldr	r3, [r3, #8]
 8013ed4:	647b      	str	r3, [r7, #68]	@ 0x44
    if(right_side) {
 8013ed6:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
 8013eda:	2b00      	cmp	r3, #0
 8013edc:	d005      	beq.n	8013eea <draw_border_simple+0x142>
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 8013ede:	f107 0310 	add.w	r3, r7, #16
 8013ee2:	4619      	mov	r1, r3
 8013ee4:	68f8      	ldr	r0, [r7, #12]
 8013ee6:	f7fa fd15 	bl	800e914 <lv_draw_sw_blend>
    }
}
 8013eea:	bf00      	nop
 8013eec:	3750      	adds	r7, #80	@ 0x50
 8013eee:	46bd      	mov	sp, r7
 8013ef0:	bd80      	pop	{r7, pc}

08013ef2 <lv_area_copy>:
{
 8013ef2:	b480      	push	{r7}
 8013ef4:	b083      	sub	sp, #12
 8013ef6:	af00      	add	r7, sp, #0
 8013ef8:	6078      	str	r0, [r7, #4]
 8013efa:	6039      	str	r1, [r7, #0]
    dest->x1 = src->x1;
 8013efc:	683b      	ldr	r3, [r7, #0]
 8013efe:	681a      	ldr	r2, [r3, #0]
 8013f00:	687b      	ldr	r3, [r7, #4]
 8013f02:	601a      	str	r2, [r3, #0]
    dest->y1 = src->y1;
 8013f04:	683b      	ldr	r3, [r7, #0]
 8013f06:	685a      	ldr	r2, [r3, #4]
 8013f08:	687b      	ldr	r3, [r7, #4]
 8013f0a:	605a      	str	r2, [r3, #4]
    dest->x2 = src->x2;
 8013f0c:	683b      	ldr	r3, [r7, #0]
 8013f0e:	689a      	ldr	r2, [r3, #8]
 8013f10:	687b      	ldr	r3, [r7, #4]
 8013f12:	609a      	str	r2, [r3, #8]
    dest->y2 = src->y2;
 8013f14:	683b      	ldr	r3, [r7, #0]
 8013f16:	68da      	ldr	r2, [r3, #12]
 8013f18:	687b      	ldr	r3, [r7, #4]
 8013f1a:	60da      	str	r2, [r3, #12]
}
 8013f1c:	bf00      	nop
 8013f1e:	370c      	adds	r7, #12
 8013f20:	46bd      	mov	sp, r7
 8013f22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f26:	4770      	bx	lr

08013f28 <lv_area_get_width>:
{
 8013f28:	b480      	push	{r7}
 8013f2a:	b083      	sub	sp, #12
 8013f2c:	af00      	add	r7, sp, #0
 8013f2e:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 8013f30:	687b      	ldr	r3, [r7, #4]
 8013f32:	689a      	ldr	r2, [r3, #8]
 8013f34:	687b      	ldr	r3, [r7, #4]
 8013f36:	681b      	ldr	r3, [r3, #0]
 8013f38:	1ad3      	subs	r3, r2, r3
 8013f3a:	3301      	adds	r3, #1
}
 8013f3c:	4618      	mov	r0, r3
 8013f3e:	370c      	adds	r7, #12
 8013f40:	46bd      	mov	sp, r7
 8013f42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f46:	4770      	bx	lr

08013f48 <lv_area_get_height>:
{
 8013f48:	b480      	push	{r7}
 8013f4a:	b083      	sub	sp, #12
 8013f4c:	af00      	add	r7, sp, #0
 8013f4e:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 8013f50:	687b      	ldr	r3, [r7, #4]
 8013f52:	68da      	ldr	r2, [r3, #12]
 8013f54:	687b      	ldr	r3, [r7, #4]
 8013f56:	685b      	ldr	r3, [r3, #4]
 8013f58:	1ad3      	subs	r3, r2, r3
 8013f5a:	3301      	adds	r3, #1
}
 8013f5c:	4618      	mov	r0, r3
 8013f5e:	370c      	adds	r7, #12
 8013f60:	46bd      	mov	sp, r7
 8013f62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f66:	4770      	bx	lr

08013f68 <lv_memzero>:
{
 8013f68:	b580      	push	{r7, lr}
 8013f6a:	b082      	sub	sp, #8
 8013f6c:	af00      	add	r7, sp, #0
 8013f6e:	6078      	str	r0, [r7, #4]
 8013f70:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 8013f72:	683a      	ldr	r2, [r7, #0]
 8013f74:	2100      	movs	r1, #0
 8013f76:	6878      	ldr	r0, [r7, #4]
 8013f78:	f010 ff53 	bl	8024e22 <lv_memset>
}
 8013f7c:	bf00      	nop
 8013f7e:	3708      	adds	r7, #8
 8013f80:	46bd      	mov	sp, r7
 8013f82:	bd80      	pop	{r7, pc}

08013f84 <lv_draw_sw_box_shadow>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_sw_box_shadow(lv_draw_unit_t * draw_unit, const lv_draw_box_shadow_dsc_t * dsc, const lv_area_t * coords)
{
 8013f84:	b590      	push	{r4, r7, lr}
 8013f86:	b0cf      	sub	sp, #316	@ 0x13c
 8013f88:	af02      	add	r7, sp, #8
 8013f8a:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8013f8e:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8013f92:	6018      	str	r0, [r3, #0]
 8013f94:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8013f98:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8013f9c:	6019      	str	r1, [r3, #0]
 8013f9e:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8013fa2:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8013fa6:	601a      	str	r2, [r3, #0]
    /*Calculate the rectangle which is blurred to get the shadow in `shadow_area`*/
    lv_area_t core_area;
    core_area.x1 = coords->x1  + dsc->ofs_x - dsc->spread;
 8013fa8:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8013fac:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8013fb0:	681b      	ldr	r3, [r3, #0]
 8013fb2:	681a      	ldr	r2, [r3, #0]
 8013fb4:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8013fb8:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8013fbc:	681b      	ldr	r3, [r3, #0]
 8013fbe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8013fc0:	441a      	add	r2, r3
 8013fc2:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8013fc6:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8013fca:	681b      	ldr	r3, [r3, #0]
 8013fcc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013fce:	1ad3      	subs	r3, r2, r3
 8013fd0:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    core_area.x2 = coords->x2  + dsc->ofs_x + dsc->spread;
 8013fd4:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8013fd8:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8013fdc:	681b      	ldr	r3, [r3, #0]
 8013fde:	689a      	ldr	r2, [r3, #8]
 8013fe0:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8013fe4:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8013fe8:	681b      	ldr	r3, [r3, #0]
 8013fea:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8013fec:	441a      	add	r2, r3
 8013fee:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8013ff2:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8013ff6:	681b      	ldr	r3, [r3, #0]
 8013ff8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8013ffa:	4413      	add	r3, r2
 8013ffc:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
    core_area.y1 = coords->y1  + dsc->ofs_y - dsc->spread;
 8014000:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014004:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8014008:	681b      	ldr	r3, [r3, #0]
 801400a:	685a      	ldr	r2, [r3, #4]
 801400c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014010:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8014014:	681b      	ldr	r3, [r3, #0]
 8014016:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8014018:	441a      	add	r2, r3
 801401a:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801401e:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8014022:	681b      	ldr	r3, [r3, #0]
 8014024:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8014026:	1ad3      	subs	r3, r2, r3
 8014028:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    core_area.y2 = coords->y2  + dsc->ofs_y + dsc->spread;
 801402c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014030:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8014034:	681b      	ldr	r3, [r3, #0]
 8014036:	68da      	ldr	r2, [r3, #12]
 8014038:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801403c:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8014040:	681b      	ldr	r3, [r3, #0]
 8014042:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8014044:	441a      	add	r2, r3
 8014046:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801404a:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 801404e:	681b      	ldr	r3, [r3, #0]
 8014050:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8014052:	4413      	add	r3, r2
 8014054:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4

    /*Calculate the bounding box of the shadow*/
    lv_area_t shadow_area;
    shadow_area.x1 = core_area.x1 - dsc->width / 2 - 1;
 8014058:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 801405c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014060:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8014064:	681b      	ldr	r3, [r3, #0]
 8014066:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8014068:	0fd9      	lsrs	r1, r3, #31
 801406a:	440b      	add	r3, r1
 801406c:	105b      	asrs	r3, r3, #1
 801406e:	425b      	negs	r3, r3
 8014070:	4413      	add	r3, r2
 8014072:	3b01      	subs	r3, #1
 8014074:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    shadow_area.x2 = core_area.x2 + dsc->width / 2 + 1;
 8014078:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 801407c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014080:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8014084:	681b      	ldr	r3, [r3, #0]
 8014086:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8014088:	0fd9      	lsrs	r1, r3, #31
 801408a:	440b      	add	r3, r1
 801408c:	105b      	asrs	r3, r3, #1
 801408e:	4413      	add	r3, r2
 8014090:	3301      	adds	r3, #1
 8014092:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
    shadow_area.y1 = core_area.y1 - dsc->width / 2 - 1;
 8014096:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 801409a:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801409e:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 80140a2:	681b      	ldr	r3, [r3, #0]
 80140a4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80140a6:	0fd9      	lsrs	r1, r3, #31
 80140a8:	440b      	add	r3, r1
 80140aa:	105b      	asrs	r3, r3, #1
 80140ac:	425b      	negs	r3, r3
 80140ae:	4413      	add	r3, r2
 80140b0:	3b01      	subs	r3, #1
 80140b2:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    shadow_area.y2 = core_area.y2 + dsc->width / 2 + 1;
 80140b6:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 80140ba:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80140be:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 80140c2:	681b      	ldr	r3, [r3, #0]
 80140c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80140c6:	0fd9      	lsrs	r1, r3, #31
 80140c8:	440b      	add	r3, r1
 80140ca:	105b      	asrs	r3, r3, #1
 80140cc:	4413      	add	r3, r2
 80140ce:	3301      	adds	r3, #1
 80140d0:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4

    lv_opa_t opa = dsc->opa;
 80140d4:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80140d8:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 80140dc:	681b      	ldr	r3, [r3, #0]
 80140de:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 80140e2:	f887 312f 	strb.w	r3, [r7, #303]	@ 0x12f
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 80140e6:	f897 312f 	ldrb.w	r3, [r7, #303]	@ 0x12f
 80140ea:	2bfd      	cmp	r3, #253	@ 0xfd
 80140ec:	d902      	bls.n	80140f4 <lv_draw_sw_box_shadow+0x170>
 80140ee:	23ff      	movs	r3, #255	@ 0xff
 80140f0:	f887 312f 	strb.w	r3, [r7, #303]	@ 0x12f

    /*Get clipped draw area which is the real draw area.
     *It is always the same or inside `shadow_area`*/
    lv_area_t draw_area;
    if(!_lv_area_intersect(&draw_area, &shadow_area, draw_unit->clip_area)) return;
 80140f4:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80140f8:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80140fc:	681b      	ldr	r3, [r3, #0]
 80140fe:	689a      	ldr	r2, [r3, #8]
 8014100:	f107 01a8 	add.w	r1, r7, #168	@ 0xa8
 8014104:	f107 0398 	add.w	r3, r7, #152	@ 0x98
 8014108:	4618      	mov	r0, r3
 801410a:	f00d fc1d 	bl	8021948 <_lv_area_intersect>
 801410e:	4603      	mov	r3, r0
 8014110:	f083 0301 	eor.w	r3, r3, #1
 8014114:	b2db      	uxtb	r3, r3
 8014116:	2b00      	cmp	r3, #0
 8014118:	f041 8214 	bne.w	8015544 <lv_draw_sw_box_shadow+0x15c0>

    /*Consider 1 px smaller bg to be sure the edge will be covered by the shadow*/
    lv_area_t bg_area;
    lv_area_copy(&bg_area, coords);
 801411c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014120:	f5a3 7396 	sub.w	r3, r3, #300	@ 0x12c
 8014124:	f107 0288 	add.w	r2, r7, #136	@ 0x88
 8014128:	6819      	ldr	r1, [r3, #0]
 801412a:	4610      	mov	r0, r2
 801412c:	f7ff fee1 	bl	8013ef2 <lv_area_copy>
    lv_area_increase(&bg_area, -1, -1);
 8014130:	f107 0388 	add.w	r3, r7, #136	@ 0x88
 8014134:	f04f 32ff 	mov.w	r2, #4294967295
 8014138:	f04f 31ff 	mov.w	r1, #4294967295
 801413c:	4618      	mov	r0, r3
 801413e:	f00d fbbb 	bl	80218b8 <lv_area_increase>

    /*Get the clamped radius*/
    int32_t r_bg = dsc->radius;
 8014142:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014146:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 801414a:	681b      	ldr	r3, [r3, #0]
 801414c:	69db      	ldr	r3, [r3, #28]
 801414e:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128
    int32_t short_side = LV_MIN(lv_area_get_width(&bg_area), lv_area_get_height(&bg_area));
 8014152:	f107 0388 	add.w	r3, r7, #136	@ 0x88
 8014156:	4618      	mov	r0, r3
 8014158:	f7ff fee6 	bl	8013f28 <lv_area_get_width>
 801415c:	4604      	mov	r4, r0
 801415e:	f107 0388 	add.w	r3, r7, #136	@ 0x88
 8014162:	4618      	mov	r0, r3
 8014164:	f7ff fef0 	bl	8013f48 <lv_area_get_height>
 8014168:	4603      	mov	r3, r0
 801416a:	429c      	cmp	r4, r3
 801416c:	da06      	bge.n	801417c <lv_draw_sw_box_shadow+0x1f8>
 801416e:	f107 0388 	add.w	r3, r7, #136	@ 0x88
 8014172:	4618      	mov	r0, r3
 8014174:	f7ff fed8 	bl	8013f28 <lv_area_get_width>
 8014178:	4603      	mov	r3, r0
 801417a:	e005      	b.n	8014188 <lv_draw_sw_box_shadow+0x204>
 801417c:	f107 0388 	add.w	r3, r7, #136	@ 0x88
 8014180:	4618      	mov	r0, r3
 8014182:	f7ff fee1 	bl	8013f48 <lv_area_get_height>
 8014186:	4603      	mov	r3, r0
 8014188:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    if(r_bg > short_side >> 1) r_bg = short_side >> 1;
 801418c:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8014190:	105b      	asrs	r3, r3, #1
 8014192:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8014196:	429a      	cmp	r2, r3
 8014198:	dd04      	ble.n	80141a4 <lv_draw_sw_box_shadow+0x220>
 801419a:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 801419e:	105b      	asrs	r3, r3, #1
 80141a0:	f8c7 3128 	str.w	r3, [r7, #296]	@ 0x128

    /*Get the clamped radius*/
    int32_t r_sh = dsc->radius;
 80141a4:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80141a8:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 80141ac:	681b      	ldr	r3, [r3, #0]
 80141ae:	69db      	ldr	r3, [r3, #28]
 80141b0:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
    short_side = LV_MIN(lv_area_get_width(&core_area), lv_area_get_height(&core_area));
 80141b4:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 80141b8:	4618      	mov	r0, r3
 80141ba:	f7ff feb5 	bl	8013f28 <lv_area_get_width>
 80141be:	4604      	mov	r4, r0
 80141c0:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 80141c4:	4618      	mov	r0, r3
 80141c6:	f7ff febf 	bl	8013f48 <lv_area_get_height>
 80141ca:	4603      	mov	r3, r0
 80141cc:	429c      	cmp	r4, r3
 80141ce:	da06      	bge.n	80141de <lv_draw_sw_box_shadow+0x25a>
 80141d0:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 80141d4:	4618      	mov	r0, r3
 80141d6:	f7ff fea7 	bl	8013f28 <lv_area_get_width>
 80141da:	4603      	mov	r3, r0
 80141dc:	e005      	b.n	80141ea <lv_draw_sw_box_shadow+0x266>
 80141de:	f107 03b8 	add.w	r3, r7, #184	@ 0xb8
 80141e2:	4618      	mov	r0, r3
 80141e4:	f7ff feb0 	bl	8013f48 <lv_area_get_height>
 80141e8:	4603      	mov	r3, r0
 80141ea:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
    if(r_sh > short_side >> 1) r_sh = short_side >> 1;
 80141ee:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 80141f2:	105b      	asrs	r3, r3, #1
 80141f4:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 80141f8:	429a      	cmp	r2, r3
 80141fa:	dd04      	ble.n	8014206 <lv_draw_sw_box_shadow+0x282>
 80141fc:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 8014200:	105b      	asrs	r3, r3, #1
 8014202:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124

    /*Get how many pixels are affected by the blur on the corners*/
    int32_t corner_size = dsc->width  + r_sh;
 8014206:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801420a:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 801420e:	681b      	ldr	r3, [r3, #0]
 8014210:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8014212:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 8014216:	4413      	add	r3, r2
 8014218:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
            cache->cache_size = corner_size;
            cache->cache_r = r_sh;
        }
    }
#else
    sh_buf = lv_malloc(corner_size * corner_size * sizeof(uint16_t));
 801421c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014220:	fb03 f303 	mul.w	r3, r3, r3
 8014224:	005b      	lsls	r3, r3, #1
 8014226:	4618      	mov	r0, r3
 8014228:	f011 fdce 	bl	8025dc8 <lv_malloc>
 801422c:	f8c7 0100 	str.w	r0, [r7, #256]	@ 0x100
    shadow_draw_corner_buf(&core_area, (uint16_t *)sh_buf, dsc->width, r_sh);
 8014230:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014234:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8014238:	681b      	ldr	r3, [r3, #0]
 801423a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801423c:	f107 00b8 	add.w	r0, r7, #184	@ 0xb8
 8014240:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 8014244:	f8d7 1100 	ldr.w	r1, [r7, #256]	@ 0x100
 8014248:	f001 f981 	bl	801554e <shadow_draw_corner_buf>
#endif /*LV_DRAW_SW_SHADOW_CACHE_SIZE*/

    /*Skip a lot of masking if the background will cover the shadow that would be masked out*/
    bool simple = dsc->bg_cover;
 801424c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014250:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8014254:	681b      	ldr	r3, [r3, #0]
 8014256:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 801425a:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801425e:	b2db      	uxtb	r3, r3
 8014260:	2b00      	cmp	r3, #0
 8014262:	bf14      	ite	ne
 8014264:	2301      	movne	r3, #1
 8014266:	2300      	moveq	r3, #0
 8014268:	f887 30ff 	strb.w	r3, [r7, #255]	@ 0xff

    /*Create a radius mask to clip remove shadow on the bg area*/

    lv_draw_sw_mask_radius_param_t mask_rout_param;
    void * masks[2] = {0};
 801426c:	f107 035c 	add.w	r3, r7, #92	@ 0x5c
 8014270:	2200      	movs	r2, #0
 8014272:	601a      	str	r2, [r3, #0]
 8014274:	605a      	str	r2, [r3, #4]
    if(!simple) {
 8014276:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 801427a:	f083 0301 	eor.w	r3, r3, #1
 801427e:	b2db      	uxtb	r3, r3
 8014280:	2b00      	cmp	r3, #0
 8014282:	d00b      	beq.n	801429c <lv_draw_sw_box_shadow+0x318>
        lv_draw_sw_mask_radius_init(&mask_rout_param, &bg_area, r_bg, true);
 8014284:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8014288:	f107 0064 	add.w	r0, r7, #100	@ 0x64
 801428c:	2301      	movs	r3, #1
 801428e:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8014292:	f004 f9e1 	bl	8018658 <lv_draw_sw_mask_radius_init>
        masks[0] = &mask_rout_param;
 8014296:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 801429a:	65fb      	str	r3, [r7, #92]	@ 0x5c
    }

    lv_opa_t * mask_buf = lv_malloc(lv_area_get_width(&shadow_area));
 801429c:	f107 03a8 	add.w	r3, r7, #168	@ 0xa8
 80142a0:	4618      	mov	r0, r3
 80142a2:	f7ff fe41 	bl	8013f28 <lv_area_get_width>
 80142a6:	4603      	mov	r3, r0
 80142a8:	4618      	mov	r0, r3
 80142aa:	f011 fd8d 	bl	8025dc8 <lv_malloc>
 80142ae:	f8c7 00f8 	str.w	r0, [r7, #248]	@ 0xf8
    lv_opa_t * sh_buf_tmp;
    int32_t y;
    bool simple_sub;

    lv_draw_sw_blend_dsc_t blend_dsc;
    lv_memzero(&blend_dsc, sizeof(blend_dsc));
 80142b2:	f107 0310 	add.w	r3, r7, #16
 80142b6:	212c      	movs	r1, #44	@ 0x2c
 80142b8:	4618      	mov	r0, r3
 80142ba:	f7ff fe55 	bl	8013f68 <lv_memzero>
    blend_dsc.blend_area = &blend_area;
 80142be:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80142c2:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80142c6:	f107 024c 	add.w	r2, r7, #76	@ 0x4c
 80142ca:	601a      	str	r2, [r3, #0]
    blend_dsc.mask_area = &blend_area;
 80142cc:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80142d0:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80142d4:	f107 024c 	add.w	r2, r7, #76	@ 0x4c
 80142d8:	621a      	str	r2, [r3, #32]
    blend_dsc.mask_buf = mask_buf;
 80142da:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80142de:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80142e2:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 80142e6:	619a      	str	r2, [r3, #24]
    blend_dsc.color = dsc->color;
 80142e8:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80142ec:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80142f0:	f507 7298 	add.w	r2, r7, #304	@ 0x130
 80142f4:	f5a2 7294 	sub.w	r2, r2, #296	@ 0x128
 80142f8:	6812      	ldr	r2, [r2, #0]
 80142fa:	3315      	adds	r3, #21
 80142fc:	3220      	adds	r2, #32
 80142fe:	8811      	ldrh	r1, [r2, #0]
 8014300:	7892      	ldrb	r2, [r2, #2]
 8014302:	8019      	strh	r1, [r3, #0]
 8014304:	709a      	strb	r2, [r3, #2]
    blend_dsc.opa = dsc->opa;
 8014306:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801430a:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 801430e:	681b      	ldr	r3, [r3, #0]
 8014310:	f893 2034 	ldrb.w	r2, [r3, #52]	@ 0x34
 8014314:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014318:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801431c:	751a      	strb	r2, [r3, #20]

    int32_t w_half = shadow_area.x1 + lv_area_get_width(&shadow_area) / 2;
 801431e:	f8d7 40a8 	ldr.w	r4, [r7, #168]	@ 0xa8
 8014322:	f107 03a8 	add.w	r3, r7, #168	@ 0xa8
 8014326:	4618      	mov	r0, r3
 8014328:	f7ff fdfe 	bl	8013f28 <lv_area_get_width>
 801432c:	4603      	mov	r3, r0
 801432e:	0fda      	lsrs	r2, r3, #31
 8014330:	4413      	add	r3, r2
 8014332:	105b      	asrs	r3, r3, #1
 8014334:	4423      	add	r3, r4
 8014336:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
    int32_t h_half = shadow_area.y1 + lv_area_get_height(&shadow_area) / 2;
 801433a:	f8d7 40ac 	ldr.w	r4, [r7, #172]	@ 0xac
 801433e:	f107 03a8 	add.w	r3, r7, #168	@ 0xa8
 8014342:	4618      	mov	r0, r3
 8014344:	f7ff fe00 	bl	8013f48 <lv_area_get_height>
 8014348:	4603      	mov	r3, r0
 801434a:	0fda      	lsrs	r2, r3, #31
 801434c:	4413      	add	r3, r2
 801434e:	105b      	asrs	r3, r3, #1
 8014350:	4423      	add	r3, r4
 8014352:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0

    /*Draw the corners if they are on the current clip area and not fully covered by the bg*/

    /*Top right corner*/
    blend_area.x2 = shadow_area.x2;
 8014356:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801435a:	657b      	str	r3, [r7, #84]	@ 0x54
    blend_area.x1 = shadow_area.x2 - corner_size + 1;
 801435c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8014360:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014364:	1ad3      	subs	r3, r2, r3
 8014366:	3301      	adds	r3, #1
 8014368:	64fb      	str	r3, [r7, #76]	@ 0x4c
    blend_area.y1 = shadow_area.y1;
 801436a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 801436e:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.y2 = shadow_area.y1 + corner_size - 1;
 8014370:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8014374:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014378:	4413      	add	r3, r2
 801437a:	3b01      	subs	r3, #1
 801437c:	65bb      	str	r3, [r7, #88]	@ 0x58
    /*Do not overdraw the other top corners*/
    blend_area.x1 = LV_MAX(blend_area.x1, w_half);
 801437e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8014380:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8014384:	4293      	cmp	r3, r2
 8014386:	bfb8      	it	lt
 8014388:	4613      	movlt	r3, r2
 801438a:	64fb      	str	r3, [r7, #76]	@ 0x4c
    blend_area.y2 = LV_MIN(blend_area.y2, h_half);
 801438c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801438e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8014392:	4293      	cmp	r3, r2
 8014394:	bfa8      	it	ge
 8014396:	4613      	movge	r3, r2
 8014398:	65bb      	str	r3, [r7, #88]	@ 0x58

    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 801439a:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801439e:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80143a2:	681b      	ldr	r3, [r3, #0]
 80143a4:	689a      	ldr	r2, [r3, #8]
 80143a6:	f107 014c 	add.w	r1, r7, #76	@ 0x4c
 80143aa:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80143ae:	4618      	mov	r0, r3
 80143b0:	f00d faca 	bl	8021948 <_lv_area_intersect>
 80143b4:	4603      	mov	r3, r0
 80143b6:	2b00      	cmp	r3, #0
 80143b8:	f000 80c1 	beq.w	801453e <lv_draw_sw_box_shadow+0x5ba>
       !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {
 80143bc:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 80143c0:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80143c4:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 80143c8:	4618      	mov	r0, r3
 80143ca:	f00d fbe1 	bl	8021b90 <_lv_area_is_in>
 80143ce:	4603      	mov	r3, r0
 80143d0:	f083 0301 	eor.w	r3, r3, #1
 80143d4:	b2db      	uxtb	r3, r3
    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 80143d6:	2b00      	cmp	r3, #0
 80143d8:	f000 80b1 	beq.w	801453e <lv_draw_sw_box_shadow+0x5ba>
        int32_t w = lv_area_get_width(&clip_area_sub);
 80143dc:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80143e0:	4618      	mov	r0, r3
 80143e2:	f7ff fda1 	bl	8013f28 <lv_area_get_width>
 80143e6:	f8c7 00ec 	str.w	r0, [r7, #236]	@ 0xec
        sh_buf_tmp = sh_buf;
 80143ea:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 80143ee:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += (clip_area_sub.y1 - shadow_area.y1) * corner_size;
 80143f2:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80143f4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 80143f8:	1ad3      	subs	r3, r2, r3
 80143fa:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 80143fe:	fb02 f303 	mul.w	r3, r2, r3
 8014402:	461a      	mov	r2, r3
 8014404:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014408:	4413      	add	r3, r2
 801440a:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += clip_area_sub.x1 - (shadow_area.x2 - corner_size + 1);
 801440e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014410:	f8d7 10b0 	ldr.w	r1, [r7, #176]	@ 0xb0
 8014414:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014418:	1acb      	subs	r3, r1, r3
 801441a:	3301      	adds	r3, #1
 801441c:	1ad3      	subs	r3, r2, r3
 801441e:	461a      	mov	r2, r3
 8014420:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014424:	4413      	add	r3, r2
 8014426:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120

        /*Do not mask if out of the bg*/
        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;
 801442a:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 801442e:	2b00      	cmp	r3, #0
 8014430:	d00f      	beq.n	8014452 <lv_draw_sw_box_shadow+0x4ce>
 8014432:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8014436:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801443a:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801443e:	4618      	mov	r0, r3
 8014440:	f00d fc3a 	bl	8021cb8 <_lv_area_is_out>
 8014444:	4603      	mov	r3, r0
 8014446:	2b00      	cmp	r3, #0
 8014448:	d003      	beq.n	8014452 <lv_draw_sw_box_shadow+0x4ce>
 801444a:	2301      	movs	r3, #1
 801444c:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
 8014450:	e003      	b.n	801445a <lv_draw_sw_box_shadow+0x4d6>
        else simple_sub = simple;
 8014452:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 8014456:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
        if(w > 0) {
 801445a:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 801445e:	2b00      	cmp	r3, #0
 8014460:	dd6d      	ble.n	801453e <lv_draw_sw_box_shadow+0x5ba>
            blend_dsc.mask_buf = mask_buf;
 8014462:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014466:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801446a:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801446e:	619a      	str	r2, [r3, #24]
            blend_area.x1 = clip_area_sub.x1;
 8014470:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014472:	64fb      	str	r3, [r7, #76]	@ 0x4c
            blend_area.x2 = clip_area_sub.x2;
 8014474:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8014476:	657b      	str	r3, [r7, #84]	@ 0x54
            blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/
 8014478:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801447c:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014480:	2202      	movs	r2, #2
 8014482:	771a      	strb	r2, [r3, #28]
            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {
 8014484:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8014486:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 801448a:	e053      	b.n	8014534 <lv_draw_sw_box_shadow+0x5b0>
                blend_area.y1 = y;
 801448c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014490:	653b      	str	r3, [r7, #80]	@ 0x50
                blend_area.y2 = y;
 8014492:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014496:	65bb      	str	r3, [r7, #88]	@ 0x58

                if(!simple_sub) {
 8014498:	f897 311b 	ldrb.w	r3, [r7, #283]	@ 0x11b
 801449c:	f083 0301 	eor.w	r3, r3, #1
 80144a0:	b2db      	uxtb	r3, r3
 80144a2:	2b00      	cmp	r3, #0
 80144a4:	d029      	beq.n	80144fa <lv_draw_sw_box_shadow+0x576>
                    lv_memcpy(mask_buf, sh_buf_tmp, corner_size);
 80144a6:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 80144aa:	461a      	mov	r2, r3
 80144ac:	f8d7 1120 	ldr.w	r1, [r7, #288]	@ 0x120
 80144b0:	f8d7 00f8 	ldr.w	r0, [r7, #248]	@ 0xf8
 80144b4:	f010 fa98 	bl	80249e8 <lv_memcpy>
                    blend_dsc.mask_res = lv_draw_sw_mask_apply(masks, mask_buf, clip_area_sub.x1, y, w);
 80144b8:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80144ba:	f107 005c 	add.w	r0, r7, #92	@ 0x5c
 80144be:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 80144c2:	9300      	str	r3, [sp, #0]
 80144c4:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80144c8:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 80144cc:	f003 fe4e 	bl	801816c <lv_draw_sw_mask_apply>
 80144d0:	4603      	mov	r3, r0
 80144d2:	461a      	mov	r2, r3
 80144d4:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80144d8:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80144dc:	771a      	strb	r2, [r3, #28]
                    if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_FULL_COVER) blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 80144de:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80144e2:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80144e6:	7f1b      	ldrb	r3, [r3, #28]
 80144e8:	2b01      	cmp	r3, #1
 80144ea:	d10d      	bne.n	8014508 <lv_draw_sw_box_shadow+0x584>
 80144ec:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80144f0:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80144f4:	2202      	movs	r2, #2
 80144f6:	771a      	strb	r2, [r3, #28]
 80144f8:	e006      	b.n	8014508 <lv_draw_sw_box_shadow+0x584>
                }
                else {
                    blend_dsc.mask_buf = sh_buf_tmp;
 80144fa:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80144fe:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014502:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8014506:	619a      	str	r2, [r3, #24]
                }
                lv_draw_sw_blend(draw_unit, &blend_dsc);
 8014508:	f107 0210 	add.w	r2, r7, #16
 801450c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014510:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8014514:	4611      	mov	r1, r2
 8014516:	6818      	ldr	r0, [r3, #0]
 8014518:	f7fa f9fc 	bl	800e914 <lv_draw_sw_blend>
                sh_buf_tmp += corner_size;
 801451c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014520:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8014524:	4413      	add	r3, r2
 8014526:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {
 801452a:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801452e:	3301      	adds	r3, #1
 8014530:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8014534:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8014536:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 801453a:	429a      	cmp	r2, r3
 801453c:	dda6      	ble.n	801448c <lv_draw_sw_box_shadow+0x508>
        }
    }

    /*Bottom right corner.
     *Almost the same as top right just read the lines of `sh_buf` from then end*/
    blend_area.x2 = shadow_area.x2;
 801453e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8014542:	657b      	str	r3, [r7, #84]	@ 0x54
    blend_area.x1 = shadow_area.x2 - corner_size + 1;
 8014544:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8014548:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801454c:	1ad3      	subs	r3, r2, r3
 801454e:	3301      	adds	r3, #1
 8014550:	64fb      	str	r3, [r7, #76]	@ 0x4c
    blend_area.y1 = shadow_area.y2 - corner_size + 1;
 8014552:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8014556:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801455a:	1ad3      	subs	r3, r2, r3
 801455c:	3301      	adds	r3, #1
 801455e:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.y2 = shadow_area.y2;
 8014560:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8014564:	65bb      	str	r3, [r7, #88]	@ 0x58
    /*Do not overdraw the other corners*/
    blend_area.x1 = LV_MAX(blend_area.x1, w_half);
 8014566:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8014568:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801456c:	4293      	cmp	r3, r2
 801456e:	bfb8      	it	lt
 8014570:	4613      	movlt	r3, r2
 8014572:	64fb      	str	r3, [r7, #76]	@ 0x4c
    blend_area.y1 = LV_MAX(blend_area.y1, h_half + 1);
 8014574:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8014578:	1c5a      	adds	r2, r3, #1
 801457a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801457c:	4293      	cmp	r3, r2
 801457e:	bfb8      	it	lt
 8014580:	4613      	movlt	r3, r2
 8014582:	653b      	str	r3, [r7, #80]	@ 0x50

    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 8014584:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014588:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 801458c:	681b      	ldr	r3, [r3, #0]
 801458e:	689a      	ldr	r2, [r3, #8]
 8014590:	f107 014c 	add.w	r1, r7, #76	@ 0x4c
 8014594:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014598:	4618      	mov	r0, r3
 801459a:	f00d f9d5 	bl	8021948 <_lv_area_intersect>
 801459e:	4603      	mov	r3, r0
 80145a0:	2b00      	cmp	r3, #0
 80145a2:	f000 80c0 	beq.w	8014726 <lv_draw_sw_box_shadow+0x7a2>
       !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {
 80145a6:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 80145aa:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80145ae:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 80145b2:	4618      	mov	r0, r3
 80145b4:	f00d faec 	bl	8021b90 <_lv_area_is_in>
 80145b8:	4603      	mov	r3, r0
 80145ba:	f083 0301 	eor.w	r3, r3, #1
 80145be:	b2db      	uxtb	r3, r3
    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 80145c0:	2b00      	cmp	r3, #0
 80145c2:	f000 80b0 	beq.w	8014726 <lv_draw_sw_box_shadow+0x7a2>
        int32_t w = lv_area_get_width(&clip_area_sub);
 80145c6:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80145ca:	4618      	mov	r0, r3
 80145cc:	f7ff fcac 	bl	8013f28 <lv_area_get_width>
 80145d0:	f8c7 00e8 	str.w	r0, [r7, #232]	@ 0xe8
        sh_buf_tmp = sh_buf;
 80145d4:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 80145d8:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += (blend_area.y2 - clip_area_sub.y2) * corner_size;
 80145dc:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80145de:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80145e0:	1ad3      	subs	r3, r2, r3
 80145e2:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 80145e6:	fb02 f303 	mul.w	r3, r2, r3
 80145ea:	461a      	mov	r2, r3
 80145ec:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80145f0:	4413      	add	r3, r2
 80145f2:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += clip_area_sub.x1 - (shadow_area.x2 - corner_size + 1);
 80145f6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80145f8:	f8d7 10b0 	ldr.w	r1, [r7, #176]	@ 0xb0
 80145fc:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014600:	1acb      	subs	r3, r1, r3
 8014602:	3301      	adds	r3, #1
 8014604:	1ad3      	subs	r3, r2, r3
 8014606:	461a      	mov	r2, r3
 8014608:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801460c:	4413      	add	r3, r2
 801460e:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        /*Do not mask if out of the bg*/
        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;
 8014612:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 8014616:	2b00      	cmp	r3, #0
 8014618:	d00f      	beq.n	801463a <lv_draw_sw_box_shadow+0x6b6>
 801461a:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 801461e:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014622:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8014626:	4618      	mov	r0, r3
 8014628:	f00d fb46 	bl	8021cb8 <_lv_area_is_out>
 801462c:	4603      	mov	r3, r0
 801462e:	2b00      	cmp	r3, #0
 8014630:	d003      	beq.n	801463a <lv_draw_sw_box_shadow+0x6b6>
 8014632:	2301      	movs	r3, #1
 8014634:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
 8014638:	e003      	b.n	8014642 <lv_draw_sw_box_shadow+0x6be>
        else simple_sub = simple;
 801463a:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 801463e:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b

        if(w > 0) {
 8014642:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8014646:	2b00      	cmp	r3, #0
 8014648:	dd6d      	ble.n	8014726 <lv_draw_sw_box_shadow+0x7a2>
            blend_dsc.mask_buf = mask_buf;
 801464a:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801464e:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014652:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8014656:	619a      	str	r2, [r3, #24]
            blend_area.x1 = clip_area_sub.x1;
 8014658:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801465a:	64fb      	str	r3, [r7, #76]	@ 0x4c
            blend_area.x2 = clip_area_sub.x2;
 801465c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801465e:	657b      	str	r3, [r7, #84]	@ 0x54
            blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/
 8014660:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014664:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014668:	2202      	movs	r2, #2
 801466a:	771a      	strb	r2, [r3, #28]
            for(y = clip_area_sub.y2; y >= clip_area_sub.y1; y--) {
 801466c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801466e:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8014672:	e053      	b.n	801471c <lv_draw_sw_box_shadow+0x798>
                blend_area.y1 = y;
 8014674:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014678:	653b      	str	r3, [r7, #80]	@ 0x50
                blend_area.y2 = y;
 801467a:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801467e:	65bb      	str	r3, [r7, #88]	@ 0x58

                if(!simple_sub) {
 8014680:	f897 311b 	ldrb.w	r3, [r7, #283]	@ 0x11b
 8014684:	f083 0301 	eor.w	r3, r3, #1
 8014688:	b2db      	uxtb	r3, r3
 801468a:	2b00      	cmp	r3, #0
 801468c:	d029      	beq.n	80146e2 <lv_draw_sw_box_shadow+0x75e>
                    lv_memcpy(mask_buf, sh_buf_tmp, corner_size);
 801468e:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014692:	461a      	mov	r2, r3
 8014694:	f8d7 1120 	ldr.w	r1, [r7, #288]	@ 0x120
 8014698:	f8d7 00f8 	ldr.w	r0, [r7, #248]	@ 0xf8
 801469c:	f010 f9a4 	bl	80249e8 <lv_memcpy>
                    blend_dsc.mask_res = lv_draw_sw_mask_apply(masks, mask_buf, clip_area_sub.x1, y, w);
 80146a0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80146a2:	f107 005c 	add.w	r0, r7, #92	@ 0x5c
 80146a6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80146aa:	9300      	str	r3, [sp, #0]
 80146ac:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80146b0:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 80146b4:	f003 fd5a 	bl	801816c <lv_draw_sw_mask_apply>
 80146b8:	4603      	mov	r3, r0
 80146ba:	461a      	mov	r2, r3
 80146bc:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80146c0:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80146c4:	771a      	strb	r2, [r3, #28]
                    if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_FULL_COVER) blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 80146c6:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80146ca:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80146ce:	7f1b      	ldrb	r3, [r3, #28]
 80146d0:	2b01      	cmp	r3, #1
 80146d2:	d10d      	bne.n	80146f0 <lv_draw_sw_box_shadow+0x76c>
 80146d4:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80146d8:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80146dc:	2202      	movs	r2, #2
 80146de:	771a      	strb	r2, [r3, #28]
 80146e0:	e006      	b.n	80146f0 <lv_draw_sw_box_shadow+0x76c>
                }
                else {
                    blend_dsc.mask_buf = sh_buf_tmp;
 80146e2:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80146e6:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80146ea:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 80146ee:	619a      	str	r2, [r3, #24]
                }
                lv_draw_sw_blend(draw_unit, &blend_dsc);
 80146f0:	f107 0210 	add.w	r2, r7, #16
 80146f4:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80146f8:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80146fc:	4611      	mov	r1, r2
 80146fe:	6818      	ldr	r0, [r3, #0]
 8014700:	f7fa f908 	bl	800e914 <lv_draw_sw_blend>
                sh_buf_tmp += corner_size;
 8014704:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014708:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801470c:	4413      	add	r3, r2
 801470e:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
            for(y = clip_area_sub.y2; y >= clip_area_sub.y1; y--) {
 8014712:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014716:	3b01      	subs	r3, #1
 8014718:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 801471c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801471e:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8014722:	429a      	cmp	r2, r3
 8014724:	daa6      	bge.n	8014674 <lv_draw_sw_box_shadow+0x6f0>
            }
        }
    }

    /*Top side*/
    blend_area.x1 = shadow_area.x1 + corner_size;
 8014726:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 801472a:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801472e:	4413      	add	r3, r2
 8014730:	64fb      	str	r3, [r7, #76]	@ 0x4c
    blend_area.x2 = shadow_area.x2 - corner_size;
 8014732:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8014736:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801473a:	1ad3      	subs	r3, r2, r3
 801473c:	657b      	str	r3, [r7, #84]	@ 0x54
    blend_area.y1 = shadow_area.y1;
 801473e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8014742:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.y2 = shadow_area.y1 + corner_size - 1;
 8014744:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8014748:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801474c:	4413      	add	r3, r2
 801474e:	3b01      	subs	r3, #1
 8014750:	65bb      	str	r3, [r7, #88]	@ 0x58
    blend_area.y2 = LV_MIN(blend_area.y2, h_half);
 8014752:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8014754:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8014758:	4293      	cmp	r3, r2
 801475a:	bfa8      	it	ge
 801475c:	4613      	movge	r3, r2
 801475e:	65bb      	str	r3, [r7, #88]	@ 0x58

    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 8014760:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014764:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8014768:	681b      	ldr	r3, [r3, #0]
 801476a:	689a      	ldr	r2, [r3, #8]
 801476c:	f107 014c 	add.w	r1, r7, #76	@ 0x4c
 8014770:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014774:	4618      	mov	r0, r3
 8014776:	f00d f8e7 	bl	8021948 <_lv_area_intersect>
 801477a:	4603      	mov	r3, r0
 801477c:	2b00      	cmp	r3, #0
 801477e:	f000 80db 	beq.w	8014938 <lv_draw_sw_box_shadow+0x9b4>
       !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {
 8014782:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8014786:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801478a:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801478e:	4618      	mov	r0, r3
 8014790:	f00d f9fe 	bl	8021b90 <_lv_area_is_in>
 8014794:	4603      	mov	r3, r0
 8014796:	f083 0301 	eor.w	r3, r3, #1
 801479a:	b2db      	uxtb	r3, r3
    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 801479c:	2b00      	cmp	r3, #0
 801479e:	f000 80cb 	beq.w	8014938 <lv_draw_sw_box_shadow+0x9b4>
        int32_t w = lv_area_get_width(&clip_area_sub);
 80147a2:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80147a6:	4618      	mov	r0, r3
 80147a8:	f7ff fbbe 	bl	8013f28 <lv_area_get_width>
 80147ac:	f8c7 00e4 	str.w	r0, [r7, #228]	@ 0xe4
        sh_buf_tmp = sh_buf;
 80147b0:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 80147b4:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += (clip_area_sub.y1 - blend_area.y1) * corner_size;
 80147b8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80147ba:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80147bc:	1ad3      	subs	r3, r2, r3
 80147be:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 80147c2:	fb02 f303 	mul.w	r3, r2, r3
 80147c6:	461a      	mov	r2, r3
 80147c8:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80147cc:	4413      	add	r3, r2
 80147ce:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120

        /*Do not mask if out of the bg*/
        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;
 80147d2:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 80147d6:	2b00      	cmp	r3, #0
 80147d8:	d00f      	beq.n	80147fa <lv_draw_sw_box_shadow+0x876>
 80147da:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 80147de:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80147e2:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 80147e6:	4618      	mov	r0, r3
 80147e8:	f00d fa66 	bl	8021cb8 <_lv_area_is_out>
 80147ec:	4603      	mov	r3, r0
 80147ee:	2b00      	cmp	r3, #0
 80147f0:	d003      	beq.n	80147fa <lv_draw_sw_box_shadow+0x876>
 80147f2:	2301      	movs	r3, #1
 80147f4:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
 80147f8:	e003      	b.n	8014802 <lv_draw_sw_box_shadow+0x87e>
        else simple_sub = simple;
 80147fa:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 80147fe:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b

        if(w > 0) {
 8014802:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8014806:	2b00      	cmp	r3, #0
 8014808:	f340 8096 	ble.w	8014938 <lv_draw_sw_box_shadow+0x9b4>
            if(!simple_sub) {
 801480c:	f897 311b 	ldrb.w	r3, [r7, #283]	@ 0x11b
 8014810:	f083 0301 	eor.w	r3, r3, #1
 8014814:	b2db      	uxtb	r3, r3
 8014816:	2b00      	cmp	r3, #0
 8014818:	d007      	beq.n	801482a <lv_draw_sw_box_shadow+0x8a6>
                blend_dsc.mask_buf = mask_buf;
 801481a:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801481e:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014822:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8014826:	619a      	str	r2, [r3, #24]
 8014828:	e005      	b.n	8014836 <lv_draw_sw_box_shadow+0x8b2>
            }
            else {
                blend_dsc.mask_buf = NULL;
 801482a:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801482e:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014832:	2200      	movs	r2, #0
 8014834:	619a      	str	r2, [r3, #24]
            }
            blend_area.x1 = clip_area_sub.x1;
 8014836:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014838:	64fb      	str	r3, [r7, #76]	@ 0x4c
            blend_area.x2 = clip_area_sub.x2;
 801483a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801483c:	657b      	str	r3, [r7, #84]	@ 0x54

            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {
 801483e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8014840:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8014844:	e073      	b.n	801492e <lv_draw_sw_box_shadow+0x9aa>
                blend_area.y1 = y;
 8014846:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801484a:	653b      	str	r3, [r7, #80]	@ 0x50
                blend_area.y2 = y;
 801484c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014850:	65bb      	str	r3, [r7, #88]	@ 0x58

                if(!simple_sub) {
 8014852:	f897 311b 	ldrb.w	r3, [r7, #283]	@ 0x11b
 8014856:	f083 0301 	eor.w	r3, r3, #1
 801485a:	b2db      	uxtb	r3, r3
 801485c:	2b00      	cmp	r3, #0
 801485e:	d034      	beq.n	80148ca <lv_draw_sw_box_shadow+0x946>
                    lv_memset(mask_buf, sh_buf_tmp[0], w);
 8014860:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014864:	781b      	ldrb	r3, [r3, #0]
 8014866:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 801486a:	4619      	mov	r1, r3
 801486c:	f8d7 00f8 	ldr.w	r0, [r7, #248]	@ 0xf8
 8014870:	f010 fad7 	bl	8024e22 <lv_memset>
                    blend_dsc.mask_res = lv_draw_sw_mask_apply(masks, mask_buf, clip_area_sub.x1, y, w);
 8014874:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014876:	f107 005c 	add.w	r0, r7, #92	@ 0x5c
 801487a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 801487e:	9300      	str	r3, [sp, #0]
 8014880:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014884:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 8014888:	f003 fc70 	bl	801816c <lv_draw_sw_mask_apply>
 801488c:	4603      	mov	r3, r0
 801488e:	461a      	mov	r2, r3
 8014890:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014894:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014898:	771a      	strb	r2, [r3, #28]
                    if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_FULL_COVER) blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 801489a:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801489e:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80148a2:	7f1b      	ldrb	r3, [r3, #28]
 80148a4:	2b01      	cmp	r3, #1
 80148a6:	d105      	bne.n	80148b4 <lv_draw_sw_box_shadow+0x930>
 80148a8:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80148ac:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80148b0:	2202      	movs	r2, #2
 80148b2:	771a      	strb	r2, [r3, #28]
                    lv_draw_sw_blend(draw_unit, &blend_dsc);
 80148b4:	f107 0210 	add.w	r2, r7, #16
 80148b8:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80148bc:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80148c0:	4611      	mov	r1, r2
 80148c2:	6818      	ldr	r0, [r3, #0]
 80148c4:	f7fa f826 	bl	800e914 <lv_draw_sw_blend>
 80148c8:	e025      	b.n	8014916 <lv_draw_sw_box_shadow+0x992>
                }
                else {
                    blend_dsc.opa = opa == LV_OPA_COVER ? sh_buf_tmp[0] : LV_OPA_MIX2(sh_buf_tmp[0], dsc->opa);
 80148ca:	f897 312f 	ldrb.w	r3, [r7, #303]	@ 0x12f
 80148ce:	2bff      	cmp	r3, #255	@ 0xff
 80148d0:	d103      	bne.n	80148da <lv_draw_sw_box_shadow+0x956>
 80148d2:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80148d6:	781b      	ldrb	r3, [r3, #0]
 80148d8:	e00e      	b.n	80148f8 <lv_draw_sw_box_shadow+0x974>
 80148da:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80148de:	781b      	ldrb	r3, [r3, #0]
 80148e0:	461a      	mov	r2, r3
 80148e2:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80148e6:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 80148ea:	681b      	ldr	r3, [r3, #0]
 80148ec:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 80148f0:	fb02 f303 	mul.w	r3, r2, r3
 80148f4:	121b      	asrs	r3, r3, #8
 80148f6:	b2db      	uxtb	r3, r3
 80148f8:	f507 7298 	add.w	r2, r7, #304	@ 0x130
 80148fc:	f5a2 7290 	sub.w	r2, r2, #288	@ 0x120
 8014900:	7513      	strb	r3, [r2, #20]
                    lv_draw_sw_blend(draw_unit, &blend_dsc);
 8014902:	f107 0210 	add.w	r2, r7, #16
 8014906:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801490a:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 801490e:	4611      	mov	r1, r2
 8014910:	6818      	ldr	r0, [r3, #0]
 8014912:	f7f9 ffff 	bl	800e914 <lv_draw_sw_blend>
                }
                sh_buf_tmp += corner_size;
 8014916:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801491a:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801491e:	4413      	add	r3, r2
 8014920:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {
 8014924:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014928:	3301      	adds	r3, #1
 801492a:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 801492e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8014930:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8014934:	429a      	cmp	r2, r3
 8014936:	dd86      	ble.n	8014846 <lv_draw_sw_box_shadow+0x8c2>
            }
        }
    }
    blend_dsc.opa = dsc->opa;    /*Restore*/
 8014938:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801493c:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8014940:	681b      	ldr	r3, [r3, #0]
 8014942:	f893 2034 	ldrb.w	r2, [r3, #52]	@ 0x34
 8014946:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801494a:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801494e:	751a      	strb	r2, [r3, #20]

    /*Bottom side*/
    blend_area.x1 = shadow_area.x1 + corner_size;
 8014950:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8014954:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014958:	4413      	add	r3, r2
 801495a:	64fb      	str	r3, [r7, #76]	@ 0x4c
    blend_area.x2 = shadow_area.x2 - corner_size;
 801495c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8014960:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014964:	1ad3      	subs	r3, r2, r3
 8014966:	657b      	str	r3, [r7, #84]	@ 0x54
    blend_area.y1 = shadow_area.y2 - corner_size + 1;
 8014968:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 801496c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014970:	1ad3      	subs	r3, r2, r3
 8014972:	3301      	adds	r3, #1
 8014974:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.y2 = shadow_area.y2;
 8014976:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 801497a:	65bb      	str	r3, [r7, #88]	@ 0x58
    blend_area.y1 = LV_MAX(blend_area.y1, h_half + 1);
 801497c:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8014980:	1c5a      	adds	r2, r3, #1
 8014982:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8014984:	4293      	cmp	r3, r2
 8014986:	bfb8      	it	lt
 8014988:	4613      	movlt	r3, r2
 801498a:	653b      	str	r3, [r7, #80]	@ 0x50

    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 801498c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014990:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8014994:	681b      	ldr	r3, [r3, #0]
 8014996:	689a      	ldr	r2, [r3, #8]
 8014998:	f107 014c 	add.w	r1, r7, #76	@ 0x4c
 801499c:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80149a0:	4618      	mov	r0, r3
 80149a2:	f00c ffd1 	bl	8021948 <_lv_area_intersect>
 80149a6:	4603      	mov	r3, r0
 80149a8:	2b00      	cmp	r3, #0
 80149aa:	f000 80f4 	beq.w	8014b96 <lv_draw_sw_box_shadow+0xc12>
       !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {
 80149ae:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 80149b2:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80149b6:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 80149ba:	4618      	mov	r0, r3
 80149bc:	f00d f8e8 	bl	8021b90 <_lv_area_is_in>
 80149c0:	4603      	mov	r3, r0
 80149c2:	f083 0301 	eor.w	r3, r3, #1
 80149c6:	b2db      	uxtb	r3, r3
    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 80149c8:	2b00      	cmp	r3, #0
 80149ca:	f000 80e4 	beq.w	8014b96 <lv_draw_sw_box_shadow+0xc12>
        int32_t w = lv_area_get_width(&clip_area_sub);
 80149ce:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80149d2:	4618      	mov	r0, r3
 80149d4:	f7ff faa8 	bl	8013f28 <lv_area_get_width>
 80149d8:	f8c7 00e0 	str.w	r0, [r7, #224]	@ 0xe0
        sh_buf_tmp = sh_buf;
 80149dc:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 80149e0:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += (blend_area.y2 - clip_area_sub.y2) * corner_size;
 80149e4:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80149e6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80149e8:	1ad3      	subs	r3, r2, r3
 80149ea:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 80149ee:	fb02 f303 	mul.w	r3, r2, r3
 80149f2:	461a      	mov	r2, r3
 80149f4:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80149f8:	4413      	add	r3, r2
 80149fa:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        if(w > 0) {
 80149fe:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8014a02:	2b00      	cmp	r3, #0
 8014a04:	f340 80c7 	ble.w	8014b96 <lv_draw_sw_box_shadow+0xc12>
            /*Do not mask if out of the bg*/
            if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;
 8014a08:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 8014a0c:	2b00      	cmp	r3, #0
 8014a0e:	d00f      	beq.n	8014a30 <lv_draw_sw_box_shadow+0xaac>
 8014a10:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8014a14:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014a18:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8014a1c:	4618      	mov	r0, r3
 8014a1e:	f00d f94b 	bl	8021cb8 <_lv_area_is_out>
 8014a22:	4603      	mov	r3, r0
 8014a24:	2b00      	cmp	r3, #0
 8014a26:	d003      	beq.n	8014a30 <lv_draw_sw_box_shadow+0xaac>
 8014a28:	2301      	movs	r3, #1
 8014a2a:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
 8014a2e:	e003      	b.n	8014a38 <lv_draw_sw_box_shadow+0xab4>
            else simple_sub = simple;
 8014a30:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 8014a34:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b

            if(!simple_sub) {
 8014a38:	f897 311b 	ldrb.w	r3, [r7, #283]	@ 0x11b
 8014a3c:	f083 0301 	eor.w	r3, r3, #1
 8014a40:	b2db      	uxtb	r3, r3
 8014a42:	2b00      	cmp	r3, #0
 8014a44:	d007      	beq.n	8014a56 <lv_draw_sw_box_shadow+0xad2>
                blend_dsc.mask_buf = mask_buf;
 8014a46:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014a4a:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014a4e:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8014a52:	619a      	str	r2, [r3, #24]
 8014a54:	e005      	b.n	8014a62 <lv_draw_sw_box_shadow+0xade>
            }
            else {
                blend_dsc.mask_buf = NULL;
 8014a56:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014a5a:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014a5e:	2200      	movs	r2, #0
 8014a60:	619a      	str	r2, [r3, #24]
            }
            blend_area.x1 = clip_area_sub.x1;
 8014a62:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014a64:	64fb      	str	r3, [r7, #76]	@ 0x4c
            blend_area.x2 = clip_area_sub.x2;
 8014a66:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8014a68:	657b      	str	r3, [r7, #84]	@ 0x54

            for(y = clip_area_sub.y2; y >= clip_area_sub.y1; y--) {
 8014a6a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8014a6c:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8014a70:	e08b      	b.n	8014b8a <lv_draw_sw_box_shadow+0xc06>
                blend_area.y1 = y;
 8014a72:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014a76:	653b      	str	r3, [r7, #80]	@ 0x50
                blend_area.y2 = y;
 8014a78:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014a7c:	65bb      	str	r3, [r7, #88]	@ 0x58

                /*Do not mask if out of the bg*/
                if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;
 8014a7e:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 8014a82:	2b00      	cmp	r3, #0
 8014a84:	d00f      	beq.n	8014aa6 <lv_draw_sw_box_shadow+0xb22>
 8014a86:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8014a8a:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014a8e:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8014a92:	4618      	mov	r0, r3
 8014a94:	f00d f910 	bl	8021cb8 <_lv_area_is_out>
 8014a98:	4603      	mov	r3, r0
 8014a9a:	2b00      	cmp	r3, #0
 8014a9c:	d003      	beq.n	8014aa6 <lv_draw_sw_box_shadow+0xb22>
 8014a9e:	2301      	movs	r3, #1
 8014aa0:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
 8014aa4:	e003      	b.n	8014aae <lv_draw_sw_box_shadow+0xb2a>
                else simple_sub = simple;
 8014aa6:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 8014aaa:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b

                if(!simple_sub) {
 8014aae:	f897 311b 	ldrb.w	r3, [r7, #283]	@ 0x11b
 8014ab2:	f083 0301 	eor.w	r3, r3, #1
 8014ab6:	b2db      	uxtb	r3, r3
 8014ab8:	2b00      	cmp	r3, #0
 8014aba:	d034      	beq.n	8014b26 <lv_draw_sw_box_shadow+0xba2>
                    lv_memset(mask_buf, sh_buf_tmp[0], w);
 8014abc:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014ac0:	781b      	ldrb	r3, [r3, #0]
 8014ac2:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8014ac6:	4619      	mov	r1, r3
 8014ac8:	f8d7 00f8 	ldr.w	r0, [r7, #248]	@ 0xf8
 8014acc:	f010 f9a9 	bl	8024e22 <lv_memset>
                    blend_dsc.mask_res = lv_draw_sw_mask_apply(masks, mask_buf, clip_area_sub.x1, y, w);
 8014ad0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014ad2:	f107 005c 	add.w	r0, r7, #92	@ 0x5c
 8014ad6:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8014ada:	9300      	str	r3, [sp, #0]
 8014adc:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014ae0:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 8014ae4:	f003 fb42 	bl	801816c <lv_draw_sw_mask_apply>
 8014ae8:	4603      	mov	r3, r0
 8014aea:	461a      	mov	r2, r3
 8014aec:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014af0:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014af4:	771a      	strb	r2, [r3, #28]
                    if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_FULL_COVER) blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8014af6:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014afa:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014afe:	7f1b      	ldrb	r3, [r3, #28]
 8014b00:	2b01      	cmp	r3, #1
 8014b02:	d105      	bne.n	8014b10 <lv_draw_sw_box_shadow+0xb8c>
 8014b04:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014b08:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014b0c:	2202      	movs	r2, #2
 8014b0e:	771a      	strb	r2, [r3, #28]
                    lv_draw_sw_blend(draw_unit, &blend_dsc);
 8014b10:	f107 0210 	add.w	r2, r7, #16
 8014b14:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014b18:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8014b1c:	4611      	mov	r1, r2
 8014b1e:	6818      	ldr	r0, [r3, #0]
 8014b20:	f7f9 fef8 	bl	800e914 <lv_draw_sw_blend>
 8014b24:	e025      	b.n	8014b72 <lv_draw_sw_box_shadow+0xbee>
                }
                else {
                    blend_dsc.opa = opa == LV_OPA_COVER ? sh_buf_tmp[0] : (sh_buf_tmp[0] * dsc->opa) >> 8;
 8014b26:	f897 312f 	ldrb.w	r3, [r7, #303]	@ 0x12f
 8014b2a:	2bff      	cmp	r3, #255	@ 0xff
 8014b2c:	d103      	bne.n	8014b36 <lv_draw_sw_box_shadow+0xbb2>
 8014b2e:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014b32:	781b      	ldrb	r3, [r3, #0]
 8014b34:	e00e      	b.n	8014b54 <lv_draw_sw_box_shadow+0xbd0>
 8014b36:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014b3a:	781b      	ldrb	r3, [r3, #0]
 8014b3c:	461a      	mov	r2, r3
 8014b3e:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014b42:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8014b46:	681b      	ldr	r3, [r3, #0]
 8014b48:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8014b4c:	fb02 f303 	mul.w	r3, r2, r3
 8014b50:	121b      	asrs	r3, r3, #8
 8014b52:	b2db      	uxtb	r3, r3
 8014b54:	f507 7298 	add.w	r2, r7, #304	@ 0x130
 8014b58:	f5a2 7290 	sub.w	r2, r2, #288	@ 0x120
 8014b5c:	7513      	strb	r3, [r2, #20]
                    lv_draw_sw_blend(draw_unit, &blend_dsc);
 8014b5e:	f107 0210 	add.w	r2, r7, #16
 8014b62:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014b66:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8014b6a:	4611      	mov	r1, r2
 8014b6c:	6818      	ldr	r0, [r3, #0]
 8014b6e:	f7f9 fed1 	bl	800e914 <lv_draw_sw_blend>

                }
                sh_buf_tmp += corner_size;
 8014b72:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014b76:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8014b7a:	4413      	add	r3, r2
 8014b7c:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
            for(y = clip_area_sub.y2; y >= clip_area_sub.y1; y--) {
 8014b80:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014b84:	3b01      	subs	r3, #1
 8014b86:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8014b8a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8014b8c:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8014b90:	429a      	cmp	r2, r3
 8014b92:	f6bf af6e 	bge.w	8014a72 <lv_draw_sw_box_shadow+0xaee>
            }
        }
    }

    blend_dsc.opa = dsc->opa;    /*Restore*/
 8014b96:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014b9a:	f5a3 7394 	sub.w	r3, r3, #296	@ 0x128
 8014b9e:	681b      	ldr	r3, [r3, #0]
 8014ba0:	f893 2034 	ldrb.w	r2, [r3, #52]	@ 0x34
 8014ba4:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014ba8:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014bac:	751a      	strb	r2, [r3, #20]

    /*Right side*/
    blend_area.x1 = shadow_area.x2 - corner_size + 1;
 8014bae:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8014bb2:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014bb6:	1ad3      	subs	r3, r2, r3
 8014bb8:	3301      	adds	r3, #1
 8014bba:	64fb      	str	r3, [r7, #76]	@ 0x4c
    blend_area.x2 = shadow_area.x2;
 8014bbc:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8014bc0:	657b      	str	r3, [r7, #84]	@ 0x54
    blend_area.y1 = shadow_area.y1 + corner_size;
 8014bc2:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8014bc6:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014bca:	4413      	add	r3, r2
 8014bcc:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.y2 = shadow_area.y2 - corner_size;
 8014bce:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8014bd2:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014bd6:	1ad3      	subs	r3, r2, r3
 8014bd8:	65bb      	str	r3, [r7, #88]	@ 0x58
    /*Do not overdraw the other corners*/
    blend_area.y1 = LV_MIN(blend_area.y1, h_half + 1);
 8014bda:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8014bdc:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 8014be0:	429a      	cmp	r2, r3
 8014be2:	db01      	blt.n	8014be8 <lv_draw_sw_box_shadow+0xc64>
 8014be4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8014be6:	e002      	b.n	8014bee <lv_draw_sw_box_shadow+0xc6a>
 8014be8:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8014bec:	3301      	adds	r3, #1
 8014bee:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.y2 = LV_MAX(blend_area.y2, h_half);
 8014bf0:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8014bf2:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8014bf6:	4293      	cmp	r3, r2
 8014bf8:	bfb8      	it	lt
 8014bfa:	4613      	movlt	r3, r2
 8014bfc:	65bb      	str	r3, [r7, #88]	@ 0x58
    blend_area.x1 = LV_MAX(blend_area.x1, w_half);
 8014bfe:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8014c00:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8014c04:	4293      	cmp	r3, r2
 8014c06:	bfb8      	it	lt
 8014c08:	4613      	movlt	r3, r2
 8014c0a:	64fb      	str	r3, [r7, #76]	@ 0x4c

    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 8014c0c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014c10:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8014c14:	681b      	ldr	r3, [r3, #0]
 8014c16:	689a      	ldr	r2, [r3, #8]
 8014c18:	f107 014c 	add.w	r1, r7, #76	@ 0x4c
 8014c1c:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014c20:	4618      	mov	r0, r3
 8014c22:	f00c fe91 	bl	8021948 <_lv_area_intersect>
 8014c26:	4603      	mov	r3, r0
 8014c28:	2b00      	cmp	r3, #0
 8014c2a:	f000 80b8 	beq.w	8014d9e <lv_draw_sw_box_shadow+0xe1a>
       !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {
 8014c2e:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8014c32:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014c36:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8014c3a:	4618      	mov	r0, r3
 8014c3c:	f00c ffa8 	bl	8021b90 <_lv_area_is_in>
 8014c40:	4603      	mov	r3, r0
 8014c42:	f083 0301 	eor.w	r3, r3, #1
 8014c46:	b2db      	uxtb	r3, r3
    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 8014c48:	2b00      	cmp	r3, #0
 8014c4a:	f000 80a8 	beq.w	8014d9e <lv_draw_sw_box_shadow+0xe1a>
        int32_t w = lv_area_get_width(&clip_area_sub);
 8014c4e:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014c52:	4618      	mov	r0, r3
 8014c54:	f7ff f968 	bl	8013f28 <lv_area_get_width>
 8014c58:	f8c7 00dc 	str.w	r0, [r7, #220]	@ 0xdc
        sh_buf_tmp = sh_buf;
 8014c5c:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8014c60:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += (corner_size - 1) * corner_size;
 8014c64:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014c68:	3b01      	subs	r3, #1
 8014c6a:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8014c6e:	fb02 f303 	mul.w	r3, r2, r3
 8014c72:	461a      	mov	r2, r3
 8014c74:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014c78:	4413      	add	r3, r2
 8014c7a:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += clip_area_sub.x1 - (shadow_area.x2 - corner_size + 1);
 8014c7e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014c80:	f8d7 10b0 	ldr.w	r1, [r7, #176]	@ 0xb0
 8014c84:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014c88:	1acb      	subs	r3, r1, r3
 8014c8a:	3301      	adds	r3, #1
 8014c8c:	1ad3      	subs	r3, r2, r3
 8014c8e:	461a      	mov	r2, r3
 8014c90:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014c94:	4413      	add	r3, r2
 8014c96:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120

        /*Do not mask if out of the bg*/
        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;
 8014c9a:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 8014c9e:	2b00      	cmp	r3, #0
 8014ca0:	d00f      	beq.n	8014cc2 <lv_draw_sw_box_shadow+0xd3e>
 8014ca2:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8014ca6:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014caa:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8014cae:	4618      	mov	r0, r3
 8014cb0:	f00d f802 	bl	8021cb8 <_lv_area_is_out>
 8014cb4:	4603      	mov	r3, r0
 8014cb6:	2b00      	cmp	r3, #0
 8014cb8:	d003      	beq.n	8014cc2 <lv_draw_sw_box_shadow+0xd3e>
 8014cba:	2301      	movs	r3, #1
 8014cbc:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
 8014cc0:	e003      	b.n	8014cca <lv_draw_sw_box_shadow+0xd46>
        else simple_sub = simple;
 8014cc2:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 8014cc6:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
        blend_dsc.mask_buf = simple_sub ? sh_buf_tmp : mask_buf;
 8014cca:	f897 311b 	ldrb.w	r3, [r7, #283]	@ 0x11b
 8014cce:	2b00      	cmp	r3, #0
 8014cd0:	d002      	beq.n	8014cd8 <lv_draw_sw_box_shadow+0xd54>
 8014cd2:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014cd6:	e001      	b.n	8014cdc <lv_draw_sw_box_shadow+0xd58>
 8014cd8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8014cdc:	f507 7298 	add.w	r2, r7, #304	@ 0x130
 8014ce0:	f5a2 7290 	sub.w	r2, r2, #288	@ 0x120
 8014ce4:	6193      	str	r3, [r2, #24]

        if(w > 0) {
 8014ce6:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8014cea:	2b00      	cmp	r3, #0
 8014cec:	dd57      	ble.n	8014d9e <lv_draw_sw_box_shadow+0xe1a>
            blend_area.x1 = clip_area_sub.x1;
 8014cee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014cf0:	64fb      	str	r3, [r7, #76]	@ 0x4c
            blend_area.x2 = clip_area_sub.x2;
 8014cf2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8014cf4:	657b      	str	r3, [r7, #84]	@ 0x54
            blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/
 8014cf6:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014cfa:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014cfe:	2202      	movs	r2, #2
 8014d00:	771a      	strb	r2, [r3, #28]
            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {
 8014d02:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8014d04:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8014d08:	e044      	b.n	8014d94 <lv_draw_sw_box_shadow+0xe10>
                blend_area.y1 = y;
 8014d0a:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014d0e:	653b      	str	r3, [r7, #80]	@ 0x50
                blend_area.y2 = y;
 8014d10:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014d14:	65bb      	str	r3, [r7, #88]	@ 0x58

                if(!simple_sub) {
 8014d16:	f897 311b 	ldrb.w	r3, [r7, #283]	@ 0x11b
 8014d1a:	f083 0301 	eor.w	r3, r3, #1
 8014d1e:	b2db      	uxtb	r3, r3
 8014d20:	2b00      	cmp	r3, #0
 8014d22:	d028      	beq.n	8014d76 <lv_draw_sw_box_shadow+0xdf2>
                    lv_memcpy(mask_buf, sh_buf_tmp, w);
 8014d24:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8014d28:	461a      	mov	r2, r3
 8014d2a:	f8d7 1120 	ldr.w	r1, [r7, #288]	@ 0x120
 8014d2e:	f8d7 00f8 	ldr.w	r0, [r7, #248]	@ 0xf8
 8014d32:	f00f fe59 	bl	80249e8 <lv_memcpy>
                    blend_dsc.mask_res = lv_draw_sw_mask_apply(masks, mask_buf, clip_area_sub.x1, y, w);
 8014d36:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014d38:	f107 005c 	add.w	r0, r7, #92	@ 0x5c
 8014d3c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8014d40:	9300      	str	r3, [sp, #0]
 8014d42:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014d46:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 8014d4a:	f003 fa0f 	bl	801816c <lv_draw_sw_mask_apply>
 8014d4e:	4603      	mov	r3, r0
 8014d50:	461a      	mov	r2, r3
 8014d52:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014d56:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014d5a:	771a      	strb	r2, [r3, #28]
                    if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_FULL_COVER) blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8014d5c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014d60:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014d64:	7f1b      	ldrb	r3, [r3, #28]
 8014d66:	2b01      	cmp	r3, #1
 8014d68:	d105      	bne.n	8014d76 <lv_draw_sw_box_shadow+0xdf2>
 8014d6a:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014d6e:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014d72:	2202      	movs	r2, #2
 8014d74:	771a      	strb	r2, [r3, #28]
                }
                lv_draw_sw_blend(draw_unit, &blend_dsc);
 8014d76:	f107 0210 	add.w	r2, r7, #16
 8014d7a:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014d7e:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8014d82:	4611      	mov	r1, r2
 8014d84:	6818      	ldr	r0, [r3, #0]
 8014d86:	f7f9 fdc5 	bl	800e914 <lv_draw_sw_blend>
            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {
 8014d8a:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014d8e:	3301      	adds	r3, #1
 8014d90:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8014d94:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8014d96:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8014d9a:	429a      	cmp	r2, r3
 8014d9c:	ddb5      	ble.n	8014d0a <lv_draw_sw_box_shadow+0xd86>
            }
        }
    }

    /*Mirror the shadow corner buffer horizontally*/
    sh_buf_tmp = sh_buf ;
 8014d9e:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8014da2:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    for(y = 0; y < corner_size; y++) {
 8014da6:	2300      	movs	r3, #0
 8014da8:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8014dac:	e044      	b.n	8014e38 <lv_draw_sw_box_shadow+0xeb4>
        int32_t x;
        lv_opa_t * start = sh_buf_tmp;
 8014dae:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014db2:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
        lv_opa_t * end = sh_buf_tmp + corner_size - 1;
 8014db6:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014dba:	3b01      	subs	r3, #1
 8014dbc:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8014dc0:	4413      	add	r3, r2
 8014dc2:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
        for(x = 0; x < corner_size / 2; x++) {
 8014dc6:	2300      	movs	r3, #0
 8014dc8:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
 8014dcc:	e01e      	b.n	8014e0c <lv_draw_sw_box_shadow+0xe88>
            lv_opa_t tmp = *start;
 8014dce:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8014dd2:	781b      	ldrb	r3, [r3, #0]
 8014dd4:	f887 30cb 	strb.w	r3, [r7, #203]	@ 0xcb
            *start = *end;
 8014dd8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8014ddc:	781a      	ldrb	r2, [r3, #0]
 8014dde:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8014de2:	701a      	strb	r2, [r3, #0]
            *end = tmp;
 8014de4:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8014de8:	f897 20cb 	ldrb.w	r2, [r7, #203]	@ 0xcb
 8014dec:	701a      	strb	r2, [r3, #0]

            start++;
 8014dee:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
 8014df2:	3301      	adds	r3, #1
 8014df4:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
            end--;
 8014df8:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8014dfc:	3b01      	subs	r3, #1
 8014dfe:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
        for(x = 0; x < corner_size / 2; x++) {
 8014e02:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8014e06:	3301      	adds	r3, #1
 8014e08:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
 8014e0c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014e10:	0fda      	lsrs	r2, r3, #31
 8014e12:	4413      	add	r3, r2
 8014e14:	105b      	asrs	r3, r3, #1
 8014e16:	461a      	mov	r2, r3
 8014e18:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8014e1c:	4293      	cmp	r3, r2
 8014e1e:	dbd6      	blt.n	8014dce <lv_draw_sw_box_shadow+0xe4a>
        }
        sh_buf_tmp += corner_size;
 8014e20:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014e24:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 8014e28:	4413      	add	r3, r2
 8014e2a:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
    for(y = 0; y < corner_size; y++) {
 8014e2e:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014e32:	3301      	adds	r3, #1
 8014e34:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8014e38:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8014e3c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014e40:	429a      	cmp	r2, r3
 8014e42:	dbb4      	blt.n	8014dae <lv_draw_sw_box_shadow+0xe2a>
    }

    /*Left side*/
    blend_area.x1 = shadow_area.x1;
 8014e44:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8014e48:	64fb      	str	r3, [r7, #76]	@ 0x4c
    blend_area.x2 = shadow_area.x1 + corner_size - 1;
 8014e4a:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8014e4e:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014e52:	4413      	add	r3, r2
 8014e54:	3b01      	subs	r3, #1
 8014e56:	657b      	str	r3, [r7, #84]	@ 0x54
    blend_area.y1 = shadow_area.y1 + corner_size;
 8014e58:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8014e5c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014e60:	4413      	add	r3, r2
 8014e62:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.y2 = shadow_area.y2 - corner_size;
 8014e64:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8014e68:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014e6c:	1ad3      	subs	r3, r2, r3
 8014e6e:	65bb      	str	r3, [r7, #88]	@ 0x58
    /*Do not overdraw the other corners*/
    blend_area.y1 = LV_MIN(blend_area.y1, h_half + 1);
 8014e70:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8014e72:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 8014e76:	429a      	cmp	r2, r3
 8014e78:	db01      	blt.n	8014e7e <lv_draw_sw_box_shadow+0xefa>
 8014e7a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8014e7c:	e002      	b.n	8014e84 <lv_draw_sw_box_shadow+0xf00>
 8014e7e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8014e82:	3301      	adds	r3, #1
 8014e84:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.y2 = LV_MAX(blend_area.y2, h_half);
 8014e86:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8014e88:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8014e8c:	4293      	cmp	r3, r2
 8014e8e:	bfb8      	it	lt
 8014e90:	4613      	movlt	r3, r2
 8014e92:	65bb      	str	r3, [r7, #88]	@ 0x58
    blend_area.x2 = LV_MIN(blend_area.x2, w_half - 1);
 8014e94:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8014e98:	1e5a      	subs	r2, r3, #1
 8014e9a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8014e9c:	4293      	cmp	r3, r2
 8014e9e:	bfa8      	it	ge
 8014ea0:	4613      	movge	r3, r2
 8014ea2:	657b      	str	r3, [r7, #84]	@ 0x54

    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 8014ea4:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014ea8:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8014eac:	681b      	ldr	r3, [r3, #0]
 8014eae:	689a      	ldr	r2, [r3, #8]
 8014eb0:	f107 014c 	add.w	r1, r7, #76	@ 0x4c
 8014eb4:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014eb8:	4618      	mov	r0, r3
 8014eba:	f00c fd45 	bl	8021948 <_lv_area_intersect>
 8014ebe:	4603      	mov	r3, r0
 8014ec0:	2b00      	cmp	r3, #0
 8014ec2:	f000 80b3 	beq.w	801502c <lv_draw_sw_box_shadow+0x10a8>
       !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {
 8014ec6:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8014eca:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014ece:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8014ed2:	4618      	mov	r0, r3
 8014ed4:	f00c fe5c 	bl	8021b90 <_lv_area_is_in>
 8014ed8:	4603      	mov	r3, r0
 8014eda:	f083 0301 	eor.w	r3, r3, #1
 8014ede:	b2db      	uxtb	r3, r3
    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 8014ee0:	2b00      	cmp	r3, #0
 8014ee2:	f000 80a3 	beq.w	801502c <lv_draw_sw_box_shadow+0x10a8>
        int32_t w = lv_area_get_width(&clip_area_sub);
 8014ee6:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014eea:	4618      	mov	r0, r3
 8014eec:	f7ff f81c 	bl	8013f28 <lv_area_get_width>
 8014ef0:	f8c7 00d8 	str.w	r0, [r7, #216]	@ 0xd8
        sh_buf_tmp = sh_buf;
 8014ef4:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 8014ef8:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += (corner_size - 1) * corner_size;
 8014efc:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8014f00:	3b01      	subs	r3, #1
 8014f02:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8014f06:	fb02 f303 	mul.w	r3, r2, r3
 8014f0a:	461a      	mov	r2, r3
 8014f0c:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014f10:	4413      	add	r3, r2
 8014f12:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += clip_area_sub.x1 - blend_area.x1;
 8014f16:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014f18:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8014f1a:	1ad3      	subs	r3, r2, r3
 8014f1c:	461a      	mov	r2, r3
 8014f1e:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014f22:	4413      	add	r3, r2
 8014f24:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120

        /*Do not mask if out of the bg*/
        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;
 8014f28:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 8014f2c:	2b00      	cmp	r3, #0
 8014f2e:	d00f      	beq.n	8014f50 <lv_draw_sw_box_shadow+0xfcc>
 8014f30:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8014f34:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8014f38:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8014f3c:	4618      	mov	r0, r3
 8014f3e:	f00c febb 	bl	8021cb8 <_lv_area_is_out>
 8014f42:	4603      	mov	r3, r0
 8014f44:	2b00      	cmp	r3, #0
 8014f46:	d003      	beq.n	8014f50 <lv_draw_sw_box_shadow+0xfcc>
 8014f48:	2301      	movs	r3, #1
 8014f4a:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
 8014f4e:	e003      	b.n	8014f58 <lv_draw_sw_box_shadow+0xfd4>
        else simple_sub = simple;
 8014f50:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 8014f54:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
        blend_dsc.mask_buf = simple_sub ? sh_buf_tmp : mask_buf;
 8014f58:	f897 311b 	ldrb.w	r3, [r7, #283]	@ 0x11b
 8014f5c:	2b00      	cmp	r3, #0
 8014f5e:	d002      	beq.n	8014f66 <lv_draw_sw_box_shadow+0xfe2>
 8014f60:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8014f64:	e001      	b.n	8014f6a <lv_draw_sw_box_shadow+0xfe6>
 8014f66:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8014f6a:	f507 7298 	add.w	r2, r7, #304	@ 0x130
 8014f6e:	f5a2 7290 	sub.w	r2, r2, #288	@ 0x120
 8014f72:	6193      	str	r3, [r2, #24]
        if(w > 0) {
 8014f74:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8014f78:	2b00      	cmp	r3, #0
 8014f7a:	dd57      	ble.n	801502c <lv_draw_sw_box_shadow+0x10a8>
            blend_area.x1 = clip_area_sub.x1;
 8014f7c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8014f7e:	64fb      	str	r3, [r7, #76]	@ 0x4c
            blend_area.x2 = clip_area_sub.x2;
 8014f80:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8014f82:	657b      	str	r3, [r7, #84]	@ 0x54
            blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/
 8014f84:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014f88:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014f8c:	2202      	movs	r2, #2
 8014f8e:	771a      	strb	r2, [r3, #28]
            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {
 8014f90:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8014f92:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8014f96:	e044      	b.n	8015022 <lv_draw_sw_box_shadow+0x109e>
                blend_area.y1 = y;
 8014f98:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014f9c:	653b      	str	r3, [r7, #80]	@ 0x50
                blend_area.y2 = y;
 8014f9e:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014fa2:	65bb      	str	r3, [r7, #88]	@ 0x58

                if(!simple_sub) {
 8014fa4:	f897 311b 	ldrb.w	r3, [r7, #283]	@ 0x11b
 8014fa8:	f083 0301 	eor.w	r3, r3, #1
 8014fac:	b2db      	uxtb	r3, r3
 8014fae:	2b00      	cmp	r3, #0
 8014fb0:	d028      	beq.n	8015004 <lv_draw_sw_box_shadow+0x1080>
                    lv_memcpy(mask_buf, sh_buf_tmp, w);
 8014fb2:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8014fb6:	461a      	mov	r2, r3
 8014fb8:	f8d7 1120 	ldr.w	r1, [r7, #288]	@ 0x120
 8014fbc:	f8d7 00f8 	ldr.w	r0, [r7, #248]	@ 0xf8
 8014fc0:	f00f fd12 	bl	80249e8 <lv_memcpy>
                    blend_dsc.mask_res = lv_draw_sw_mask_apply(masks, mask_buf, clip_area_sub.x1, y, w);
 8014fc4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8014fc6:	f107 005c 	add.w	r0, r7, #92	@ 0x5c
 8014fca:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8014fce:	9300      	str	r3, [sp, #0]
 8014fd0:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8014fd4:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 8014fd8:	f003 f8c8 	bl	801816c <lv_draw_sw_mask_apply>
 8014fdc:	4603      	mov	r3, r0
 8014fde:	461a      	mov	r2, r3
 8014fe0:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014fe4:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014fe8:	771a      	strb	r2, [r3, #28]
                    if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_FULL_COVER) blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8014fea:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014fee:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8014ff2:	7f1b      	ldrb	r3, [r3, #28]
 8014ff4:	2b01      	cmp	r3, #1
 8014ff6:	d105      	bne.n	8015004 <lv_draw_sw_box_shadow+0x1080>
 8014ff8:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8014ffc:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8015000:	2202      	movs	r2, #2
 8015002:	771a      	strb	r2, [r3, #28]
                }

                lv_draw_sw_blend(draw_unit, &blend_dsc);
 8015004:	f107 0210 	add.w	r2, r7, #16
 8015008:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801500c:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015010:	4611      	mov	r1, r2
 8015012:	6818      	ldr	r0, [r3, #0]
 8015014:	f7f9 fc7e 	bl	800e914 <lv_draw_sw_blend>
            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {
 8015018:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801501c:	3301      	adds	r3, #1
 801501e:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8015022:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015024:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8015028:	429a      	cmp	r2, r3
 801502a:	ddb5      	ble.n	8014f98 <lv_draw_sw_box_shadow+0x1014>
            }
        }
    }

    /*Top left corner*/
    blend_area.x1 = shadow_area.x1;
 801502c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8015030:	64fb      	str	r3, [r7, #76]	@ 0x4c
    blend_area.x2 = shadow_area.x1 + corner_size - 1;
 8015032:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8015036:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801503a:	4413      	add	r3, r2
 801503c:	3b01      	subs	r3, #1
 801503e:	657b      	str	r3, [r7, #84]	@ 0x54
    blend_area.y1 = shadow_area.y1;
 8015040:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8015044:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.y2 = shadow_area.y1 + corner_size - 1;
 8015046:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 801504a:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801504e:	4413      	add	r3, r2
 8015050:	3b01      	subs	r3, #1
 8015052:	65bb      	str	r3, [r7, #88]	@ 0x58
    /*Do not overdraw the other corners*/
    blend_area.x2 = LV_MIN(blend_area.x2, w_half - 1);
 8015054:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015058:	1e5a      	subs	r2, r3, #1
 801505a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801505c:	4293      	cmp	r3, r2
 801505e:	bfa8      	it	ge
 8015060:	4613      	movge	r3, r2
 8015062:	657b      	str	r3, [r7, #84]	@ 0x54
    blend_area.y2 = LV_MIN(blend_area.y2, h_half);
 8015064:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8015066:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801506a:	4293      	cmp	r3, r2
 801506c:	bfa8      	it	ge
 801506e:	4613      	movge	r3, r2
 8015070:	65bb      	str	r3, [r7, #88]	@ 0x58

    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 8015072:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8015076:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 801507a:	681b      	ldr	r3, [r3, #0]
 801507c:	689a      	ldr	r2, [r3, #8]
 801507e:	f107 014c 	add.w	r1, r7, #76	@ 0x4c
 8015082:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8015086:	4618      	mov	r0, r3
 8015088:	f00c fc5e 	bl	8021948 <_lv_area_intersect>
 801508c:	4603      	mov	r3, r0
 801508e:	2b00      	cmp	r3, #0
 8015090:	f000 80bb 	beq.w	801520a <lv_draw_sw_box_shadow+0x1286>
       !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {
 8015094:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8015098:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801509c:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 80150a0:	4618      	mov	r0, r3
 80150a2:	f00c fd75 	bl	8021b90 <_lv_area_is_in>
 80150a6:	4603      	mov	r3, r0
 80150a8:	f083 0301 	eor.w	r3, r3, #1
 80150ac:	b2db      	uxtb	r3, r3
    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 80150ae:	2b00      	cmp	r3, #0
 80150b0:	f000 80ab 	beq.w	801520a <lv_draw_sw_box_shadow+0x1286>
        int32_t w = lv_area_get_width(&clip_area_sub);
 80150b4:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80150b8:	4618      	mov	r0, r3
 80150ba:	f7fe ff35 	bl	8013f28 <lv_area_get_width>
 80150be:	f8c7 00d4 	str.w	r0, [r7, #212]	@ 0xd4
        sh_buf_tmp = sh_buf;
 80150c2:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 80150c6:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += (clip_area_sub.y1 - blend_area.y1) * corner_size;
 80150ca:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80150cc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80150ce:	1ad3      	subs	r3, r2, r3
 80150d0:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 80150d4:	fb02 f303 	mul.w	r3, r2, r3
 80150d8:	461a      	mov	r2, r3
 80150da:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80150de:	4413      	add	r3, r2
 80150e0:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += clip_area_sub.x1 - blend_area.x1;
 80150e4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80150e6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80150e8:	1ad3      	subs	r3, r2, r3
 80150ea:	461a      	mov	r2, r3
 80150ec:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80150f0:	4413      	add	r3, r2
 80150f2:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120

        /*Do not mask if out of the bg*/
        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;
 80150f6:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 80150fa:	2b00      	cmp	r3, #0
 80150fc:	d00f      	beq.n	801511e <lv_draw_sw_box_shadow+0x119a>
 80150fe:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8015102:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8015106:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 801510a:	4618      	mov	r0, r3
 801510c:	f00c fdd4 	bl	8021cb8 <_lv_area_is_out>
 8015110:	4603      	mov	r3, r0
 8015112:	2b00      	cmp	r3, #0
 8015114:	d003      	beq.n	801511e <lv_draw_sw_box_shadow+0x119a>
 8015116:	2301      	movs	r3, #1
 8015118:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
 801511c:	e003      	b.n	8015126 <lv_draw_sw_box_shadow+0x11a2>
        else simple_sub = simple;
 801511e:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 8015122:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
        blend_dsc.mask_buf = mask_buf;
 8015126:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801512a:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801512e:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8015132:	619a      	str	r2, [r3, #24]

        if(w > 0) {
 8015134:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8015138:	2b00      	cmp	r3, #0
 801513a:	dd66      	ble.n	801520a <lv_draw_sw_box_shadow+0x1286>
            blend_area.x1 = clip_area_sub.x1;
 801513c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801513e:	64fb      	str	r3, [r7, #76]	@ 0x4c
            blend_area.x2 = clip_area_sub.x2;
 8015140:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015142:	657b      	str	r3, [r7, #84]	@ 0x54
            blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/
 8015144:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8015148:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801514c:	2202      	movs	r2, #2
 801514e:	771a      	strb	r2, [r3, #28]
            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {
 8015150:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015152:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8015156:	e053      	b.n	8015200 <lv_draw_sw_box_shadow+0x127c>
                blend_area.y1 = y;
 8015158:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801515c:	653b      	str	r3, [r7, #80]	@ 0x50
                blend_area.y2 = y;
 801515e:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8015162:	65bb      	str	r3, [r7, #88]	@ 0x58

                if(!simple_sub) {
 8015164:	f897 311b 	ldrb.w	r3, [r7, #283]	@ 0x11b
 8015168:	f083 0301 	eor.w	r3, r3, #1
 801516c:	b2db      	uxtb	r3, r3
 801516e:	2b00      	cmp	r3, #0
 8015170:	d029      	beq.n	80151c6 <lv_draw_sw_box_shadow+0x1242>
                    lv_memcpy(mask_buf, sh_buf_tmp, corner_size);
 8015172:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8015176:	461a      	mov	r2, r3
 8015178:	f8d7 1120 	ldr.w	r1, [r7, #288]	@ 0x120
 801517c:	f8d7 00f8 	ldr.w	r0, [r7, #248]	@ 0xf8
 8015180:	f00f fc32 	bl	80249e8 <lv_memcpy>
                    blend_dsc.mask_res = lv_draw_sw_mask_apply(masks, mask_buf, clip_area_sub.x1, y, w);
 8015184:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8015186:	f107 005c 	add.w	r0, r7, #92	@ 0x5c
 801518a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801518e:	9300      	str	r3, [sp, #0]
 8015190:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8015194:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 8015198:	f002 ffe8 	bl	801816c <lv_draw_sw_mask_apply>
 801519c:	4603      	mov	r3, r0
 801519e:	461a      	mov	r2, r3
 80151a0:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80151a4:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80151a8:	771a      	strb	r2, [r3, #28]
                    if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_FULL_COVER) blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 80151aa:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80151ae:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80151b2:	7f1b      	ldrb	r3, [r3, #28]
 80151b4:	2b01      	cmp	r3, #1
 80151b6:	d10d      	bne.n	80151d4 <lv_draw_sw_box_shadow+0x1250>
 80151b8:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80151bc:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80151c0:	2202      	movs	r2, #2
 80151c2:	771a      	strb	r2, [r3, #28]
 80151c4:	e006      	b.n	80151d4 <lv_draw_sw_box_shadow+0x1250>
                }
                else {
                    blend_dsc.mask_buf = sh_buf_tmp;
 80151c6:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80151ca:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80151ce:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 80151d2:	619a      	str	r2, [r3, #24]
                }

                lv_draw_sw_blend(draw_unit, &blend_dsc);
 80151d4:	f107 0210 	add.w	r2, r7, #16
 80151d8:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80151dc:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80151e0:	4611      	mov	r1, r2
 80151e2:	6818      	ldr	r0, [r3, #0]
 80151e4:	f7f9 fb96 	bl	800e914 <lv_draw_sw_blend>
                sh_buf_tmp += corner_size;
 80151e8:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 80151ec:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 80151f0:	4413      	add	r3, r2
 80151f2:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {
 80151f6:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80151fa:	3301      	adds	r3, #1
 80151fc:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8015200:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015202:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8015206:	429a      	cmp	r2, r3
 8015208:	dda6      	ble.n	8015158 <lv_draw_sw_box_shadow+0x11d4>
        }
    }

    /*Bottom left corner.
     *Almost the same as bottom right just read the lines of `sh_buf` from then end*/
    blend_area.x1 = shadow_area.x1 ;
 801520a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801520e:	64fb      	str	r3, [r7, #76]	@ 0x4c
    blend_area.x2 = shadow_area.x1 + corner_size - 1;
 8015210:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8015214:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8015218:	4413      	add	r3, r2
 801521a:	3b01      	subs	r3, #1
 801521c:	657b      	str	r3, [r7, #84]	@ 0x54
    blend_area.y1 = shadow_area.y2 - corner_size + 1;
 801521e:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8015222:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8015226:	1ad3      	subs	r3, r2, r3
 8015228:	3301      	adds	r3, #1
 801522a:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.y2 = shadow_area.y2;
 801522c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8015230:	65bb      	str	r3, [r7, #88]	@ 0x58
    /*Do not overdraw the other corners*/
    blend_area.y1 = LV_MAX(blend_area.y1, h_half + 1);
 8015232:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8015236:	1c5a      	adds	r2, r3, #1
 8015238:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801523a:	4293      	cmp	r3, r2
 801523c:	bfb8      	it	lt
 801523e:	4613      	movlt	r3, r2
 8015240:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.x2 = LV_MIN(blend_area.x2, w_half - 1);
 8015242:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8015246:	1e5a      	subs	r2, r3, #1
 8015248:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801524a:	4293      	cmp	r3, r2
 801524c:	bfa8      	it	ge
 801524e:	4613      	movge	r3, r2
 8015250:	657b      	str	r3, [r7, #84]	@ 0x54

    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 8015252:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8015256:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 801525a:	681b      	ldr	r3, [r3, #0]
 801525c:	689a      	ldr	r2, [r3, #8]
 801525e:	f107 014c 	add.w	r1, r7, #76	@ 0x4c
 8015262:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8015266:	4618      	mov	r0, r3
 8015268:	f00c fb6e 	bl	8021948 <_lv_area_intersect>
 801526c:	4603      	mov	r3, r0
 801526e:	2b00      	cmp	r3, #0
 8015270:	f000 80bb 	beq.w	80153ea <lv_draw_sw_box_shadow+0x1466>
       !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {
 8015274:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8015278:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801527c:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8015280:	4618      	mov	r0, r3
 8015282:	f00c fc85 	bl	8021b90 <_lv_area_is_in>
 8015286:	4603      	mov	r3, r0
 8015288:	f083 0301 	eor.w	r3, r3, #1
 801528c:	b2db      	uxtb	r3, r3
    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 801528e:	2b00      	cmp	r3, #0
 8015290:	f000 80ab 	beq.w	80153ea <lv_draw_sw_box_shadow+0x1466>
        int32_t w = lv_area_get_width(&clip_area_sub);
 8015294:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8015298:	4618      	mov	r0, r3
 801529a:	f7fe fe45 	bl	8013f28 <lv_area_get_width>
 801529e:	f8c7 00d0 	str.w	r0, [r7, #208]	@ 0xd0
        sh_buf_tmp = sh_buf;
 80152a2:	f8d7 3100 	ldr.w	r3, [r7, #256]	@ 0x100
 80152a6:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += (blend_area.y2 - clip_area_sub.y2) * corner_size;
 80152aa:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80152ac:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80152ae:	1ad3      	subs	r3, r2, r3
 80152b0:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 80152b4:	fb02 f303 	mul.w	r3, r2, r3
 80152b8:	461a      	mov	r2, r3
 80152ba:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80152be:	4413      	add	r3, r2
 80152c0:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
        sh_buf_tmp += clip_area_sub.x1 - blend_area.x1;
 80152c4:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80152c6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80152c8:	1ad3      	subs	r3, r2, r3
 80152ca:	461a      	mov	r2, r3
 80152cc:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 80152d0:	4413      	add	r3, r2
 80152d2:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120

        /*Do not mask if out of the bg*/
        if(simple && _lv_area_is_out(&clip_area_sub, &bg_area, r_bg)) simple_sub = true;
 80152d6:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 80152da:	2b00      	cmp	r3, #0
 80152dc:	d00f      	beq.n	80152fe <lv_draw_sw_box_shadow+0x137a>
 80152de:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 80152e2:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80152e6:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 80152ea:	4618      	mov	r0, r3
 80152ec:	f00c fce4 	bl	8021cb8 <_lv_area_is_out>
 80152f0:	4603      	mov	r3, r0
 80152f2:	2b00      	cmp	r3, #0
 80152f4:	d003      	beq.n	80152fe <lv_draw_sw_box_shadow+0x137a>
 80152f6:	2301      	movs	r3, #1
 80152f8:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
 80152fc:	e003      	b.n	8015306 <lv_draw_sw_box_shadow+0x1382>
        else simple_sub = simple;
 80152fe:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 8015302:	f887 311b 	strb.w	r3, [r7, #283]	@ 0x11b
        blend_dsc.mask_buf = mask_buf;
 8015306:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801530a:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801530e:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8015312:	619a      	str	r2, [r3, #24]
        if(w > 0) {
 8015314:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 8015318:	2b00      	cmp	r3, #0
 801531a:	dd66      	ble.n	80153ea <lv_draw_sw_box_shadow+0x1466>
            blend_area.x1 = clip_area_sub.x1;
 801531c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801531e:	64fb      	str	r3, [r7, #76]	@ 0x4c
            blend_area.x2 = clip_area_sub.x2;
 8015320:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015322:	657b      	str	r3, [r7, #84]	@ 0x54
            blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;    /*In simple mode it won't be overwritten*/
 8015324:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8015328:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801532c:	2202      	movs	r2, #2
 801532e:	771a      	strb	r2, [r3, #28]
            for(y = clip_area_sub.y2; y >= clip_area_sub.y1; y--) {
 8015330:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015332:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8015336:	e053      	b.n	80153e0 <lv_draw_sw_box_shadow+0x145c>
                blend_area.y1 = y;
 8015338:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801533c:	653b      	str	r3, [r7, #80]	@ 0x50
                blend_area.y2 = y;
 801533e:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8015342:	65bb      	str	r3, [r7, #88]	@ 0x58

                if(!simple_sub) {
 8015344:	f897 311b 	ldrb.w	r3, [r7, #283]	@ 0x11b
 8015348:	f083 0301 	eor.w	r3, r3, #1
 801534c:	b2db      	uxtb	r3, r3
 801534e:	2b00      	cmp	r3, #0
 8015350:	d029      	beq.n	80153a6 <lv_draw_sw_box_shadow+0x1422>
                    lv_memcpy(mask_buf, sh_buf_tmp, corner_size);
 8015352:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8015356:	461a      	mov	r2, r3
 8015358:	f8d7 1120 	ldr.w	r1, [r7, #288]	@ 0x120
 801535c:	f8d7 00f8 	ldr.w	r0, [r7, #248]	@ 0xf8
 8015360:	f00f fb42 	bl	80249e8 <lv_memcpy>
                    blend_dsc.mask_res = lv_draw_sw_mask_apply(masks, mask_buf, clip_area_sub.x1, y, w);
 8015364:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8015366:	f107 005c 	add.w	r0, r7, #92	@ 0x5c
 801536a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801536e:	9300      	str	r3, [sp, #0]
 8015370:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8015374:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 8015378:	f002 fef8 	bl	801816c <lv_draw_sw_mask_apply>
 801537c:	4603      	mov	r3, r0
 801537e:	461a      	mov	r2, r3
 8015380:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8015384:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8015388:	771a      	strb	r2, [r3, #28]
                    if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_FULL_COVER) blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 801538a:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801538e:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8015392:	7f1b      	ldrb	r3, [r3, #28]
 8015394:	2b01      	cmp	r3, #1
 8015396:	d10d      	bne.n	80153b4 <lv_draw_sw_box_shadow+0x1430>
 8015398:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801539c:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80153a0:	2202      	movs	r2, #2
 80153a2:	771a      	strb	r2, [r3, #28]
 80153a4:	e006      	b.n	80153b4 <lv_draw_sw_box_shadow+0x1430>
                }
                else {
                    blend_dsc.mask_buf = sh_buf_tmp;
 80153a6:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80153aa:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80153ae:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 80153b2:	619a      	str	r2, [r3, #24]
                }
                lv_draw_sw_blend(draw_unit, &blend_dsc);
 80153b4:	f107 0210 	add.w	r2, r7, #16
 80153b8:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80153bc:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80153c0:	4611      	mov	r1, r2
 80153c2:	6818      	ldr	r0, [r3, #0]
 80153c4:	f7f9 faa6 	bl	800e914 <lv_draw_sw_blend>
                sh_buf_tmp += corner_size;
 80153c8:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 80153cc:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 80153d0:	4413      	add	r3, r2
 80153d2:	f8c7 3120 	str.w	r3, [r7, #288]	@ 0x120
            for(y = clip_area_sub.y2; y >= clip_area_sub.y1; y--) {
 80153d6:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80153da:	3b01      	subs	r3, #1
 80153dc:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 80153e0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80153e2:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 80153e6:	429a      	cmp	r2, r3
 80153e8:	daa6      	bge.n	8015338 <lv_draw_sw_box_shadow+0x13b4>
            }
        }
    }

    /*Draw the center rectangle.*/
    blend_area.x1 = shadow_area.x1 + corner_size ;
 80153ea:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 80153ee:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 80153f2:	4413      	add	r3, r2
 80153f4:	64fb      	str	r3, [r7, #76]	@ 0x4c
    blend_area.x2 = shadow_area.x2 - corner_size;
 80153f6:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 80153fa:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 80153fe:	1ad3      	subs	r3, r2, r3
 8015400:	657b      	str	r3, [r7, #84]	@ 0x54
    blend_area.y1 = shadow_area.y1 + corner_size;
 8015402:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 8015406:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801540a:	4413      	add	r3, r2
 801540c:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.y2 = shadow_area.y2 - corner_size;
 801540e:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8015412:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8015416:	1ad3      	subs	r3, r2, r3
 8015418:	65bb      	str	r3, [r7, #88]	@ 0x58
    blend_area.y1 = LV_MIN(blend_area.y1, h_half + 1);
 801541a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801541c:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 8015420:	429a      	cmp	r2, r3
 8015422:	db01      	blt.n	8015428 <lv_draw_sw_box_shadow+0x14a4>
 8015424:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8015426:	e002      	b.n	801542e <lv_draw_sw_box_shadow+0x14aa>
 8015428:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801542c:	3301      	adds	r3, #1
 801542e:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_area.y2 = LV_MAX(blend_area.y2, h_half);
 8015430:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8015432:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8015436:	4293      	cmp	r3, r2
 8015438:	bfb8      	it	lt
 801543a:	4613      	movlt	r3, r2
 801543c:	65bb      	str	r3, [r7, #88]	@ 0x58
    blend_dsc.mask_buf = mask_buf;
 801543e:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8015442:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8015446:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801544a:	619a      	str	r2, [r3, #24]

    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 801544c:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 8015450:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 8015454:	681b      	ldr	r3, [r3, #0]
 8015456:	689a      	ldr	r2, [r3, #8]
 8015458:	f107 014c 	add.w	r1, r7, #76	@ 0x4c
 801545c:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8015460:	4618      	mov	r0, r3
 8015462:	f00c fa71 	bl	8021948 <_lv_area_intersect>
 8015466:	4603      	mov	r3, r0
 8015468:	2b00      	cmp	r3, #0
 801546a:	d056      	beq.n	801551a <lv_draw_sw_box_shadow+0x1596>
       !_lv_area_is_in(&clip_area_sub, &bg_area, r_bg)) {
 801546c:	f107 0188 	add.w	r1, r7, #136	@ 0x88
 8015470:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 8015474:	f8d7 2128 	ldr.w	r2, [r7, #296]	@ 0x128
 8015478:	4618      	mov	r0, r3
 801547a:	f00c fb89 	bl	8021b90 <_lv_area_is_in>
 801547e:	4603      	mov	r3, r0
 8015480:	f083 0301 	eor.w	r3, r3, #1
 8015484:	b2db      	uxtb	r3, r3
    if(_lv_area_intersect(&clip_area_sub, &blend_area, draw_unit->clip_area) &&
 8015486:	2b00      	cmp	r3, #0
 8015488:	d047      	beq.n	801551a <lv_draw_sw_box_shadow+0x1596>
        int32_t w = lv_area_get_width(&clip_area_sub);
 801548a:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801548e:	4618      	mov	r0, r3
 8015490:	f7fe fd4a 	bl	8013f28 <lv_area_get_width>
 8015494:	f8c7 00cc 	str.w	r0, [r7, #204]	@ 0xcc
        if(w > 0) {
 8015498:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 801549c:	2b00      	cmp	r3, #0
 801549e:	dd3c      	ble.n	801551a <lv_draw_sw_box_shadow+0x1596>
            blend_area.x1 = clip_area_sub.x1;
 80154a0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80154a2:	64fb      	str	r3, [r7, #76]	@ 0x4c
            blend_area.x2 = clip_area_sub.x2;
 80154a4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80154a6:	657b      	str	r3, [r7, #84]	@ 0x54
            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {
 80154a8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80154aa:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 80154ae:	e02f      	b.n	8015510 <lv_draw_sw_box_shadow+0x158c>
                blend_area.y1 = y;
 80154b0:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80154b4:	653b      	str	r3, [r7, #80]	@ 0x50
                blend_area.y2 = y;
 80154b6:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80154ba:	65bb      	str	r3, [r7, #88]	@ 0x58

                lv_memset(mask_buf, 0xff, w);
 80154bc:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80154c0:	461a      	mov	r2, r3
 80154c2:	21ff      	movs	r1, #255	@ 0xff
 80154c4:	f8d7 00f8 	ldr.w	r0, [r7, #248]	@ 0xf8
 80154c8:	f00f fcab 	bl	8024e22 <lv_memset>
                blend_dsc.mask_res = lv_draw_sw_mask_apply(masks, mask_buf, clip_area_sub.x1, y, w);
 80154cc:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80154ce:	f107 005c 	add.w	r0, r7, #92	@ 0x5c
 80154d2:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80154d6:	9300      	str	r3, [sp, #0]
 80154d8:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 80154dc:	f8d7 10f8 	ldr.w	r1, [r7, #248]	@ 0xf8
 80154e0:	f002 fe44 	bl	801816c <lv_draw_sw_mask_apply>
 80154e4:	4603      	mov	r3, r0
 80154e6:	461a      	mov	r2, r3
 80154e8:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80154ec:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80154f0:	771a      	strb	r2, [r3, #28]
                lv_draw_sw_blend(draw_unit, &blend_dsc);
 80154f2:	f107 0210 	add.w	r2, r7, #16
 80154f6:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 80154fa:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80154fe:	4611      	mov	r1, r2
 8015500:	6818      	ldr	r0, [r3, #0]
 8015502:	f7f9 fa07 	bl	800e914 <lv_draw_sw_blend>
            for(y = clip_area_sub.y1; y <= clip_area_sub.y2; y++) {
 8015506:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801550a:	3301      	adds	r3, #1
 801550c:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
 8015510:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015512:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8015516:	429a      	cmp	r2, r3
 8015518:	ddca      	ble.n	80154b0 <lv_draw_sw_box_shadow+0x152c>
            }
        }
    }

    if(!simple) {
 801551a:	f897 30ff 	ldrb.w	r3, [r7, #255]	@ 0xff
 801551e:	f083 0301 	eor.w	r3, r3, #1
 8015522:	b2db      	uxtb	r3, r3
 8015524:	2b00      	cmp	r3, #0
 8015526:	d004      	beq.n	8015532 <lv_draw_sw_box_shadow+0x15ae>
        lv_draw_sw_mask_free_param(&mask_rout_param);
 8015528:	f107 0364 	add.w	r3, r7, #100	@ 0x64
 801552c:	4618      	mov	r0, r3
 801552e:	f002 fe5f 	bl	80181f0 <lv_draw_sw_mask_free_param>
    }
    lv_free(sh_buf);
 8015532:	f8d7 0100 	ldr.w	r0, [r7, #256]	@ 0x100
 8015536:	f010 fc7f 	bl	8025e38 <lv_free>
    lv_free(mask_buf);
 801553a:	f8d7 00f8 	ldr.w	r0, [r7, #248]	@ 0xf8
 801553e:	f010 fc7b 	bl	8025e38 <lv_free>
 8015542:	e000      	b.n	8015546 <lv_draw_sw_box_shadow+0x15c2>
    if(!_lv_area_intersect(&draw_area, &shadow_area, draw_unit->clip_area)) return;
 8015544:	bf00      	nop
}
 8015546:	f507 779a 	add.w	r7, r7, #308	@ 0x134
 801554a:	46bd      	mov	sp, r7
 801554c:	bd90      	pop	{r4, r7, pc}

0801554e <shadow_draw_corner_buf>:
 * @param sw shadow width
 * @param r radius
 */
static void LV_ATTRIBUTE_FAST_MEM shadow_draw_corner_buf(const lv_area_t * coords, uint16_t * sh_buf, int32_t sw,
                                                         int32_t r)
{
 801554e:	b590      	push	{r4, r7, lr}
 8015550:	b0a1      	sub	sp, #132	@ 0x84
 8015552:	af02      	add	r7, sp, #8
 8015554:	60f8      	str	r0, [r7, #12]
 8015556:	60b9      	str	r1, [r7, #8]
 8015558:	607a      	str	r2, [r7, #4]
 801555a:	603b      	str	r3, [r7, #0]
    int32_t sw_ori = sw;
 801555c:	687b      	ldr	r3, [r7, #4]
 801555e:	65fb      	str	r3, [r7, #92]	@ 0x5c
    int32_t size = sw_ori  + r;
 8015560:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8015562:	683b      	ldr	r3, [r7, #0]
 8015564:	4413      	add	r3, r2
 8015566:	65bb      	str	r3, [r7, #88]	@ 0x58

    lv_area_t sh_area;
    lv_area_copy(&sh_area, coords);
 8015568:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 801556c:	68f9      	ldr	r1, [r7, #12]
 801556e:	4618      	mov	r0, r3
 8015570:	f7fe fcbf 	bl	8013ef2 <lv_area_copy>
    sh_area.x2 = sw / 2 + r - 1  - ((sw & 1) ? 0 : 1);
 8015574:	687b      	ldr	r3, [r7, #4]
 8015576:	0fda      	lsrs	r2, r3, #31
 8015578:	4413      	add	r3, r2
 801557a:	105b      	asrs	r3, r3, #1
 801557c:	461a      	mov	r2, r3
 801557e:	683b      	ldr	r3, [r7, #0]
 8015580:	4413      	add	r3, r2
 8015582:	3b01      	subs	r3, #1
 8015584:	687a      	ldr	r2, [r7, #4]
 8015586:	f002 0201 	and.w	r2, r2, #1
 801558a:	2a00      	cmp	r2, #0
 801558c:	bf0c      	ite	eq
 801558e:	2201      	moveq	r2, #1
 8015590:	2200      	movne	r2, #0
 8015592:	b2d2      	uxtb	r2, r2
 8015594:	1a9b      	subs	r3, r3, r2
 8015596:	63fb      	str	r3, [r7, #60]	@ 0x3c
    sh_area.y1 = sw / 2 + 1;
 8015598:	687b      	ldr	r3, [r7, #4]
 801559a:	0fda      	lsrs	r2, r3, #31
 801559c:	4413      	add	r3, r2
 801559e:	105b      	asrs	r3, r3, #1
 80155a0:	3301      	adds	r3, #1
 80155a2:	63bb      	str	r3, [r7, #56]	@ 0x38

    sh_area.x1 = sh_area.x2 - lv_area_get_width(coords);
 80155a4:	6bfc      	ldr	r4, [r7, #60]	@ 0x3c
 80155a6:	68f8      	ldr	r0, [r7, #12]
 80155a8:	f7fe fcbe 	bl	8013f28 <lv_area_get_width>
 80155ac:	4603      	mov	r3, r0
 80155ae:	1ae3      	subs	r3, r4, r3
 80155b0:	637b      	str	r3, [r7, #52]	@ 0x34
    sh_area.y2 = sh_area.y1 + lv_area_get_height(coords);
 80155b2:	6bbc      	ldr	r4, [r7, #56]	@ 0x38
 80155b4:	68f8      	ldr	r0, [r7, #12]
 80155b6:	f7fe fcc7 	bl	8013f48 <lv_area_get_height>
 80155ba:	4603      	mov	r3, r0
 80155bc:	4423      	add	r3, r4
 80155be:	643b      	str	r3, [r7, #64]	@ 0x40

    lv_draw_sw_mask_radius_param_t mask_param;
    lv_draw_sw_mask_radius_init(&mask_param, &sh_area, r, false);
 80155c0:	f107 0134 	add.w	r1, r7, #52	@ 0x34
 80155c4:	f107 0010 	add.w	r0, r7, #16
 80155c8:	2300      	movs	r3, #0
 80155ca:	683a      	ldr	r2, [r7, #0]
 80155cc:	f003 f844 	bl	8018658 <lv_draw_sw_mask_radius_init>

#if SHADOW_ENHANCE
    /*Set half shadow width width because blur will be repeated*/
    if(sw_ori == 1) sw = 1;
 80155d0:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80155d2:	2b01      	cmp	r3, #1
 80155d4:	d102      	bne.n	80155dc <shadow_draw_corner_buf+0x8e>
 80155d6:	2301      	movs	r3, #1
 80155d8:	607b      	str	r3, [r7, #4]
 80155da:	e002      	b.n	80155e2 <shadow_draw_corner_buf+0x94>
    else sw = sw_ori >> 1;
 80155dc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80155de:	105b      	asrs	r3, r3, #1
 80155e0:	607b      	str	r3, [r7, #4]
#endif /*SHADOW_ENHANCE*/

    int32_t y;
    lv_opa_t * mask_line = lv_malloc(size);
 80155e2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80155e4:	4618      	mov	r0, r3
 80155e6:	f010 fbef 	bl	8025dc8 <lv_malloc>
 80155ea:	6578      	str	r0, [r7, #84]	@ 0x54
    uint16_t * sh_ups_tmp_buf = (uint16_t *)sh_buf;
 80155ec:	68bb      	ldr	r3, [r7, #8]
 80155ee:	673b      	str	r3, [r7, #112]	@ 0x70
    for(y = 0; y < size; y++) {
 80155f0:	2300      	movs	r3, #0
 80155f2:	677b      	str	r3, [r7, #116]	@ 0x74
 80155f4:	e05e      	b.n	80156b4 <shadow_draw_corner_buf+0x166>
        lv_memset(mask_line, 0xff, size);
 80155f6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80155f8:	461a      	mov	r2, r3
 80155fa:	21ff      	movs	r1, #255	@ 0xff
 80155fc:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80155fe:	f00f fc10 	bl	8024e22 <lv_memset>
        lv_draw_sw_mask_res_t mask_res = mask_param.dsc.cb(mask_line, 0, y, size, &mask_param);
 8015602:	693c      	ldr	r4, [r7, #16]
 8015604:	f107 0310 	add.w	r3, r7, #16
 8015608:	9300      	str	r3, [sp, #0]
 801560a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801560c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 801560e:	2100      	movs	r1, #0
 8015610:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 8015612:	47a0      	blx	r4
 8015614:	4603      	mov	r3, r0
 8015616:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
        if(mask_res == LV_DRAW_SW_MASK_RES_TRANSP) {
 801561a:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 801561e:	2b00      	cmp	r3, #0
 8015620:	d106      	bne.n	8015630 <shadow_draw_corner_buf+0xe2>
            lv_memzero(sh_ups_tmp_buf, size * sizeof(sh_ups_tmp_buf[0]));
 8015622:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8015624:	005b      	lsls	r3, r3, #1
 8015626:	4619      	mov	r1, r3
 8015628:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 801562a:	f7fe fc9d 	bl	8013f68 <lv_memzero>
 801562e:	e039      	b.n	80156a4 <shadow_draw_corner_buf+0x156>
        }
        else {
            int32_t i;
            sh_ups_tmp_buf[0] = (mask_line[0] << SHADOW_UPSCALE_SHIFT) / sw;
 8015630:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8015632:	781b      	ldrb	r3, [r3, #0]
 8015634:	019a      	lsls	r2, r3, #6
 8015636:	687b      	ldr	r3, [r7, #4]
 8015638:	fb92 f3f3 	sdiv	r3, r2, r3
 801563c:	b29a      	uxth	r2, r3
 801563e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8015640:	801a      	strh	r2, [r3, #0]
            for(i = 1; i < size; i++) {
 8015642:	2301      	movs	r3, #1
 8015644:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8015646:	e029      	b.n	801569c <shadow_draw_corner_buf+0x14e>
                if(mask_line[i] == mask_line[i - 1]) sh_ups_tmp_buf[i] = sh_ups_tmp_buf[i - 1];
 8015648:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801564a:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801564c:	4413      	add	r3, r2
 801564e:	781a      	ldrb	r2, [r3, #0]
 8015650:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8015652:	3b01      	subs	r3, #1
 8015654:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8015656:	440b      	add	r3, r1
 8015658:	781b      	ldrb	r3, [r3, #0]
 801565a:	429a      	cmp	r2, r3
 801565c:	d10d      	bne.n	801567a <shadow_draw_corner_buf+0x12c>
 801565e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8015660:	f103 4300 	add.w	r3, r3, #2147483648	@ 0x80000000
 8015664:	3b01      	subs	r3, #1
 8015666:	005b      	lsls	r3, r3, #1
 8015668:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801566a:	441a      	add	r2, r3
 801566c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801566e:	005b      	lsls	r3, r3, #1
 8015670:	6f39      	ldr	r1, [r7, #112]	@ 0x70
 8015672:	440b      	add	r3, r1
 8015674:	8812      	ldrh	r2, [r2, #0]
 8015676:	801a      	strh	r2, [r3, #0]
 8015678:	e00d      	b.n	8015696 <shadow_draw_corner_buf+0x148>
                else  sh_ups_tmp_buf[i] = (mask_line[i] << SHADOW_UPSCALE_SHIFT) / sw;
 801567a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801567c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801567e:	4413      	add	r3, r2
 8015680:	781b      	ldrb	r3, [r3, #0]
 8015682:	019a      	lsls	r2, r3, #6
 8015684:	687b      	ldr	r3, [r7, #4]
 8015686:	fb92 f1f3 	sdiv	r1, r2, r3
 801568a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801568c:	005b      	lsls	r3, r3, #1
 801568e:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8015690:	4413      	add	r3, r2
 8015692:	b28a      	uxth	r2, r1
 8015694:	801a      	strh	r2, [r3, #0]
            for(i = 1; i < size; i++) {
 8015696:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8015698:	3301      	adds	r3, #1
 801569a:	66fb      	str	r3, [r7, #108]	@ 0x6c
 801569c:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801569e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80156a0:	429a      	cmp	r2, r3
 80156a2:	dbd1      	blt.n	8015648 <shadow_draw_corner_buf+0xfa>
            }
        }

        sh_ups_tmp_buf += size;
 80156a4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80156a6:	005b      	lsls	r3, r3, #1
 80156a8:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80156aa:	4413      	add	r3, r2
 80156ac:	673b      	str	r3, [r7, #112]	@ 0x70
    for(y = 0; y < size; y++) {
 80156ae:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 80156b0:	3301      	adds	r3, #1
 80156b2:	677b      	str	r3, [r7, #116]	@ 0x74
 80156b4:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 80156b6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80156b8:	429a      	cmp	r2, r3
 80156ba:	db9c      	blt.n	80155f6 <shadow_draw_corner_buf+0xa8>
    }
    lv_free(mask_line);
 80156bc:	6d78      	ldr	r0, [r7, #84]	@ 0x54
 80156be:	f010 fbbb 	bl	8025e38 <lv_free>

    lv_draw_sw_mask_free_param(&mask_param);
 80156c2:	f107 0310 	add.w	r3, r7, #16
 80156c6:	4618      	mov	r0, r3
 80156c8:	f002 fd92 	bl	80181f0 <lv_draw_sw_mask_free_param>

    if(sw == 1) {
 80156cc:	687b      	ldr	r3, [r7, #4]
 80156ce:	2b01      	cmp	r3, #1
 80156d0:	d11a      	bne.n	8015708 <shadow_draw_corner_buf+0x1ba>
        int32_t i;
        lv_opa_t * res_buf = (lv_opa_t *)sh_buf;
 80156d2:	68bb      	ldr	r3, [r7, #8]
 80156d4:	64bb      	str	r3, [r7, #72]	@ 0x48
        for(i = 0; i < size * size; i++) {
 80156d6:	2300      	movs	r3, #0
 80156d8:	66bb      	str	r3, [r7, #104]	@ 0x68
 80156da:	e00e      	b.n	80156fa <shadow_draw_corner_buf+0x1ac>
            res_buf[i] = (sh_buf[i] >> SHADOW_UPSCALE_SHIFT);
 80156dc:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80156de:	005b      	lsls	r3, r3, #1
 80156e0:	68ba      	ldr	r2, [r7, #8]
 80156e2:	4413      	add	r3, r2
 80156e4:	881b      	ldrh	r3, [r3, #0]
 80156e6:	099b      	lsrs	r3, r3, #6
 80156e8:	b299      	uxth	r1, r3
 80156ea:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80156ec:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 80156ee:	4413      	add	r3, r2
 80156f0:	b2ca      	uxtb	r2, r1
 80156f2:	701a      	strb	r2, [r3, #0]
        for(i = 0; i < size * size; i++) {
 80156f4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80156f6:	3301      	adds	r3, #1
 80156f8:	66bb      	str	r3, [r7, #104]	@ 0x68
 80156fa:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80156fc:	fb03 f303 	mul.w	r3, r3, r3
 8015700:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8015702:	429a      	cmp	r2, r3
 8015704:	dbea      	blt.n	80156dc <shadow_draw_corner_buf+0x18e>
        }
        return;
 8015706:	e064      	b.n	80157d2 <shadow_draw_corner_buf+0x284>
    }

    shadow_blur_corner(size, sw, sh_buf);
 8015708:	68ba      	ldr	r2, [r7, #8]
 801570a:	6879      	ldr	r1, [r7, #4]
 801570c:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801570e:	f000 f863 	bl	80157d8 <shadow_blur_corner>
    lv_opa_t * res_buf = (lv_opa_t *)sh_buf;
    for(x = 0; x < size * size; x++) {
        res_buf[x] = sh_buf[x];
    }
#else
    sw += sw_ori & 1;
 8015712:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8015714:	f003 0301 	and.w	r3, r3, #1
 8015718:	687a      	ldr	r2, [r7, #4]
 801571a:	4413      	add	r3, r2
 801571c:	607b      	str	r3, [r7, #4]
    if(sw > 1) {
 801571e:	687b      	ldr	r3, [r7, #4]
 8015720:	2b01      	cmp	r3, #1
 8015722:	dd3e      	ble.n	80157a2 <shadow_draw_corner_buf+0x254>
        uint32_t i;
        uint32_t max_v_div = (LV_OPA_COVER << SHADOW_UPSCALE_SHIFT) / sw;
 8015724:	f44f 527f 	mov.w	r2, #16320	@ 0x3fc0
 8015728:	687b      	ldr	r3, [r7, #4]
 801572a:	fb92 f3f3 	sdiv	r3, r2, r3
 801572e:	653b      	str	r3, [r7, #80]	@ 0x50
        for(i = 0; i < (uint32_t)size * size; i++) {
 8015730:	2300      	movs	r3, #0
 8015732:	667b      	str	r3, [r7, #100]	@ 0x64
 8015734:	e029      	b.n	801578a <shadow_draw_corner_buf+0x23c>
            if(sh_buf[i] == 0) continue;
 8015736:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8015738:	005b      	lsls	r3, r3, #1
 801573a:	68ba      	ldr	r2, [r7, #8]
 801573c:	4413      	add	r3, r2
 801573e:	881b      	ldrh	r3, [r3, #0]
 8015740:	2b00      	cmp	r3, #0
 8015742:	d01e      	beq.n	8015782 <shadow_draw_corner_buf+0x234>
            else if(sh_buf[i] == LV_OPA_COVER) sh_buf[i] = max_v_div;
 8015744:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8015746:	005b      	lsls	r3, r3, #1
 8015748:	68ba      	ldr	r2, [r7, #8]
 801574a:	4413      	add	r3, r2
 801574c:	881b      	ldrh	r3, [r3, #0]
 801574e:	2bff      	cmp	r3, #255	@ 0xff
 8015750:	d107      	bne.n	8015762 <shadow_draw_corner_buf+0x214>
 8015752:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8015754:	005b      	lsls	r3, r3, #1
 8015756:	68ba      	ldr	r2, [r7, #8]
 8015758:	4413      	add	r3, r2
 801575a:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801575c:	b292      	uxth	r2, r2
 801575e:	801a      	strh	r2, [r3, #0]
 8015760:	e010      	b.n	8015784 <shadow_draw_corner_buf+0x236>
            else  sh_buf[i] = (sh_buf[i] << SHADOW_UPSCALE_SHIFT) / sw;
 8015762:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8015764:	005b      	lsls	r3, r3, #1
 8015766:	68ba      	ldr	r2, [r7, #8]
 8015768:	4413      	add	r3, r2
 801576a:	881b      	ldrh	r3, [r3, #0]
 801576c:	019a      	lsls	r2, r3, #6
 801576e:	687b      	ldr	r3, [r7, #4]
 8015770:	fb92 f1f3 	sdiv	r1, r2, r3
 8015774:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8015776:	005b      	lsls	r3, r3, #1
 8015778:	68ba      	ldr	r2, [r7, #8]
 801577a:	4413      	add	r3, r2
 801577c:	b28a      	uxth	r2, r1
 801577e:	801a      	strh	r2, [r3, #0]
 8015780:	e000      	b.n	8015784 <shadow_draw_corner_buf+0x236>
            if(sh_buf[i] == 0) continue;
 8015782:	bf00      	nop
        for(i = 0; i < (uint32_t)size * size; i++) {
 8015784:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8015786:	3301      	adds	r3, #1
 8015788:	667b      	str	r3, [r7, #100]	@ 0x64
 801578a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801578c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801578e:	fb02 f303 	mul.w	r3, r2, r3
 8015792:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8015794:	429a      	cmp	r2, r3
 8015796:	d3ce      	bcc.n	8015736 <shadow_draw_corner_buf+0x1e8>
        }

        shadow_blur_corner(size, sw, sh_buf);
 8015798:	68ba      	ldr	r2, [r7, #8]
 801579a:	6879      	ldr	r1, [r7, #4]
 801579c:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 801579e:	f000 f81b 	bl	80157d8 <shadow_blur_corner>
    }
    int32_t x;
    lv_opa_t * res_buf = (lv_opa_t *)sh_buf;
 80157a2:	68bb      	ldr	r3, [r7, #8]
 80157a4:	64fb      	str	r3, [r7, #76]	@ 0x4c
    for(x = 0; x < size * size; x++) {
 80157a6:	2300      	movs	r3, #0
 80157a8:	663b      	str	r3, [r7, #96]	@ 0x60
 80157aa:	e00c      	b.n	80157c6 <shadow_draw_corner_buf+0x278>
        res_buf[x] = sh_buf[x];
 80157ac:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80157ae:	005b      	lsls	r3, r3, #1
 80157b0:	68ba      	ldr	r2, [r7, #8]
 80157b2:	4413      	add	r3, r2
 80157b4:	8819      	ldrh	r1, [r3, #0]
 80157b6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80157b8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80157ba:	4413      	add	r3, r2
 80157bc:	b2ca      	uxtb	r2, r1
 80157be:	701a      	strb	r2, [r3, #0]
    for(x = 0; x < size * size; x++) {
 80157c0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80157c2:	3301      	adds	r3, #1
 80157c4:	663b      	str	r3, [r7, #96]	@ 0x60
 80157c6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80157c8:	fb03 f303 	mul.w	r3, r3, r3
 80157cc:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 80157ce:	429a      	cmp	r2, r3
 80157d0:	dbec      	blt.n	80157ac <shadow_draw_corner_buf+0x25e>
    }
#endif

}
 80157d2:	377c      	adds	r7, #124	@ 0x7c
 80157d4:	46bd      	mov	sp, r7
 80157d6:	bd90      	pop	{r4, r7, pc}

080157d8 <shadow_blur_corner>:

static void LV_ATTRIBUTE_FAST_MEM shadow_blur_corner(int32_t size, int32_t sw, uint16_t * sh_ups_buf)
{
 80157d8:	b580      	push	{r7, lr}
 80157da:	b094      	sub	sp, #80	@ 0x50
 80157dc:	af00      	add	r7, sp, #0
 80157de:	60f8      	str	r0, [r7, #12]
 80157e0:	60b9      	str	r1, [r7, #8]
 80157e2:	607a      	str	r2, [r7, #4]
    int32_t s_left = sw >> 1;
 80157e4:	68bb      	ldr	r3, [r7, #8]
 80157e6:	105b      	asrs	r3, r3, #1
 80157e8:	64fb      	str	r3, [r7, #76]	@ 0x4c
    int32_t s_right = (sw >> 1);
 80157ea:	68bb      	ldr	r3, [r7, #8]
 80157ec:	105b      	asrs	r3, r3, #1
 80157ee:	623b      	str	r3, [r7, #32]
    if((sw & 1) == 0) s_left--;
 80157f0:	68bb      	ldr	r3, [r7, #8]
 80157f2:	f003 0301 	and.w	r3, r3, #1
 80157f6:	2b00      	cmp	r3, #0
 80157f8:	d102      	bne.n	8015800 <shadow_blur_corner+0x28>
 80157fa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80157fc:	3b01      	subs	r3, #1
 80157fe:	64fb      	str	r3, [r7, #76]	@ 0x4c

    /*Horizontal blur*/
    uint16_t * sh_ups_blur_buf = lv_malloc(size * sizeof(uint16_t));
 8015800:	68fb      	ldr	r3, [r7, #12]
 8015802:	005b      	lsls	r3, r3, #1
 8015804:	4618      	mov	r0, r3
 8015806:	f010 fadf 	bl	8025dc8 <lv_malloc>
 801580a:	61f8      	str	r0, [r7, #28]

    int32_t x;
    int32_t y;

    uint16_t * sh_ups_tmp_buf = sh_ups_buf;
 801580c:	687b      	ldr	r3, [r7, #4]
 801580e:	643b      	str	r3, [r7, #64]	@ 0x40

    for(y = 0; y < size; y++) {
 8015810:	2300      	movs	r3, #0
 8015812:	647b      	str	r3, [r7, #68]	@ 0x44
 8015814:	e058      	b.n	80158c8 <shadow_blur_corner+0xf0>
        int32_t v = sh_ups_tmp_buf[size - 1] * sw;
 8015816:	68fb      	ldr	r3, [r7, #12]
 8015818:	f103 4300 	add.w	r3, r3, #2147483648	@ 0x80000000
 801581c:	3b01      	subs	r3, #1
 801581e:	005b      	lsls	r3, r3, #1
 8015820:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8015822:	4413      	add	r3, r2
 8015824:	881b      	ldrh	r3, [r3, #0]
 8015826:	461a      	mov	r2, r3
 8015828:	68bb      	ldr	r3, [r7, #8]
 801582a:	fb02 f303 	mul.w	r3, r2, r3
 801582e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for(x = size - 1; x >= 0; x--) {
 8015830:	68fb      	ldr	r3, [r7, #12]
 8015832:	3b01      	subs	r3, #1
 8015834:	64bb      	str	r3, [r7, #72]	@ 0x48
 8015836:	e035      	b.n	80158a4 <shadow_blur_corner+0xcc>
            sh_ups_blur_buf[x] = v;
 8015838:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801583a:	005b      	lsls	r3, r3, #1
 801583c:	69fa      	ldr	r2, [r7, #28]
 801583e:	4413      	add	r3, r2
 8015840:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8015842:	b292      	uxth	r2, r2
 8015844:	801a      	strh	r2, [r3, #0]

            /*Forget the right pixel*/
            uint32_t right_val = 0;
 8015846:	2300      	movs	r3, #0
 8015848:	63bb      	str	r3, [r7, #56]	@ 0x38
            if(x + s_right < size) right_val = sh_ups_tmp_buf[x + s_right];
 801584a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801584c:	6a3b      	ldr	r3, [r7, #32]
 801584e:	4413      	add	r3, r2
 8015850:	68fa      	ldr	r2, [r7, #12]
 8015852:	429a      	cmp	r2, r3
 8015854:	dd07      	ble.n	8015866 <shadow_blur_corner+0x8e>
 8015856:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8015858:	6a3b      	ldr	r3, [r7, #32]
 801585a:	4413      	add	r3, r2
 801585c:	005b      	lsls	r3, r3, #1
 801585e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8015860:	4413      	add	r3, r2
 8015862:	881b      	ldrh	r3, [r3, #0]
 8015864:	63bb      	str	r3, [r7, #56]	@ 0x38
            v -= right_val;
 8015866:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8015868:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801586a:	1ad3      	subs	r3, r2, r3
 801586c:	63fb      	str	r3, [r7, #60]	@ 0x3c

            /*Add the left pixel*/
            uint32_t left_val;
            if(x - s_left - 1 < 0) left_val = sh_ups_tmp_buf[0];
 801586e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8015870:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8015872:	1ad3      	subs	r3, r2, r3
 8015874:	2b00      	cmp	r3, #0
 8015876:	dc03      	bgt.n	8015880 <shadow_blur_corner+0xa8>
 8015878:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801587a:	881b      	ldrh	r3, [r3, #0]
 801587c:	637b      	str	r3, [r7, #52]	@ 0x34
 801587e:	e00a      	b.n	8015896 <shadow_blur_corner+0xbe>
            else left_val = sh_ups_tmp_buf[x - s_left - 1];
 8015880:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8015882:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8015884:	1ad3      	subs	r3, r2, r3
 8015886:	f103 4300 	add.w	r3, r3, #2147483648	@ 0x80000000
 801588a:	3b01      	subs	r3, #1
 801588c:	005b      	lsls	r3, r3, #1
 801588e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8015890:	4413      	add	r3, r2
 8015892:	881b      	ldrh	r3, [r3, #0]
 8015894:	637b      	str	r3, [r7, #52]	@ 0x34
            v += left_val;
 8015896:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8015898:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801589a:	4413      	add	r3, r2
 801589c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        for(x = size - 1; x >= 0; x--) {
 801589e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80158a0:	3b01      	subs	r3, #1
 80158a2:	64bb      	str	r3, [r7, #72]	@ 0x48
 80158a4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80158a6:	2b00      	cmp	r3, #0
 80158a8:	dac6      	bge.n	8015838 <shadow_blur_corner+0x60>
        }
        lv_memcpy(sh_ups_tmp_buf, sh_ups_blur_buf, size * sizeof(uint16_t));
 80158aa:	68fb      	ldr	r3, [r7, #12]
 80158ac:	005b      	lsls	r3, r3, #1
 80158ae:	461a      	mov	r2, r3
 80158b0:	69f9      	ldr	r1, [r7, #28]
 80158b2:	6c38      	ldr	r0, [r7, #64]	@ 0x40
 80158b4:	f00f f898 	bl	80249e8 <lv_memcpy>
        sh_ups_tmp_buf += size;
 80158b8:	68fb      	ldr	r3, [r7, #12]
 80158ba:	005b      	lsls	r3, r3, #1
 80158bc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80158be:	4413      	add	r3, r2
 80158c0:	643b      	str	r3, [r7, #64]	@ 0x40
    for(y = 0; y < size; y++) {
 80158c2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80158c4:	3301      	adds	r3, #1
 80158c6:	647b      	str	r3, [r7, #68]	@ 0x44
 80158c8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80158ca:	68fb      	ldr	r3, [r7, #12]
 80158cc:	429a      	cmp	r2, r3
 80158ce:	dba2      	blt.n	8015816 <shadow_blur_corner+0x3e>
    }

    /*Vertical blur*/
    uint32_t i;
    uint32_t max_v = LV_OPA_COVER << SHADOW_UPSCALE_SHIFT;
 80158d0:	f44f 537f 	mov.w	r3, #16320	@ 0x3fc0
 80158d4:	61bb      	str	r3, [r7, #24]
    uint32_t max_v_div = max_v / sw;
 80158d6:	68bb      	ldr	r3, [r7, #8]
 80158d8:	69ba      	ldr	r2, [r7, #24]
 80158da:	fbb2 f3f3 	udiv	r3, r2, r3
 80158de:	617b      	str	r3, [r7, #20]
    for(i = 0; i < (uint32_t)size * size; i++) {
 80158e0:	2300      	movs	r3, #0
 80158e2:	633b      	str	r3, [r7, #48]	@ 0x30
 80158e4:	e02b      	b.n	801593e <shadow_blur_corner+0x166>
        if(sh_ups_buf[i] == 0) continue;
 80158e6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80158e8:	005b      	lsls	r3, r3, #1
 80158ea:	687a      	ldr	r2, [r7, #4]
 80158ec:	4413      	add	r3, r2
 80158ee:	881b      	ldrh	r3, [r3, #0]
 80158f0:	2b00      	cmp	r3, #0
 80158f2:	d020      	beq.n	8015936 <shadow_blur_corner+0x15e>
        else if(sh_ups_buf[i] == max_v) sh_ups_buf[i] = max_v_div;
 80158f4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80158f6:	005b      	lsls	r3, r3, #1
 80158f8:	687a      	ldr	r2, [r7, #4]
 80158fa:	4413      	add	r3, r2
 80158fc:	881b      	ldrh	r3, [r3, #0]
 80158fe:	461a      	mov	r2, r3
 8015900:	69bb      	ldr	r3, [r7, #24]
 8015902:	4293      	cmp	r3, r2
 8015904:	d107      	bne.n	8015916 <shadow_blur_corner+0x13e>
 8015906:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015908:	005b      	lsls	r3, r3, #1
 801590a:	687a      	ldr	r2, [r7, #4]
 801590c:	4413      	add	r3, r2
 801590e:	697a      	ldr	r2, [r7, #20]
 8015910:	b292      	uxth	r2, r2
 8015912:	801a      	strh	r2, [r3, #0]
 8015914:	e010      	b.n	8015938 <shadow_blur_corner+0x160>
        else sh_ups_buf[i] = sh_ups_buf[i] / sw;
 8015916:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8015918:	005b      	lsls	r3, r3, #1
 801591a:	687a      	ldr	r2, [r7, #4]
 801591c:	4413      	add	r3, r2
 801591e:	881b      	ldrh	r3, [r3, #0]
 8015920:	461a      	mov	r2, r3
 8015922:	68bb      	ldr	r3, [r7, #8]
 8015924:	fb92 f1f3 	sdiv	r1, r2, r3
 8015928:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801592a:	005b      	lsls	r3, r3, #1
 801592c:	687a      	ldr	r2, [r7, #4]
 801592e:	4413      	add	r3, r2
 8015930:	b28a      	uxth	r2, r1
 8015932:	801a      	strh	r2, [r3, #0]
 8015934:	e000      	b.n	8015938 <shadow_blur_corner+0x160>
        if(sh_ups_buf[i] == 0) continue;
 8015936:	bf00      	nop
    for(i = 0; i < (uint32_t)size * size; i++) {
 8015938:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801593a:	3301      	adds	r3, #1
 801593c:	633b      	str	r3, [r7, #48]	@ 0x30
 801593e:	68fb      	ldr	r3, [r7, #12]
 8015940:	68fa      	ldr	r2, [r7, #12]
 8015942:	fb02 f303 	mul.w	r3, r2, r3
 8015946:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8015948:	429a      	cmp	r2, r3
 801594a:	d3cc      	bcc.n	80158e6 <shadow_blur_corner+0x10e>
    }

    for(x = 0; x < size; x++) {
 801594c:	2300      	movs	r3, #0
 801594e:	64bb      	str	r3, [r7, #72]	@ 0x48
 8015950:	e086      	b.n	8015a60 <shadow_blur_corner+0x288>
        sh_ups_tmp_buf = &sh_ups_buf[x];
 8015952:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015954:	005b      	lsls	r3, r3, #1
 8015956:	687a      	ldr	r2, [r7, #4]
 8015958:	4413      	add	r3, r2
 801595a:	643b      	str	r3, [r7, #64]	@ 0x40
        int32_t v = sh_ups_tmp_buf[0] * sw;
 801595c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801595e:	881b      	ldrh	r3, [r3, #0]
 8015960:	461a      	mov	r2, r3
 8015962:	68bb      	ldr	r3, [r7, #8]
 8015964:	fb02 f303 	mul.w	r3, r2, r3
 8015968:	62fb      	str	r3, [r7, #44]	@ 0x2c
        for(y = 0; y < size ; y++, sh_ups_tmp_buf += size) {
 801596a:	2300      	movs	r3, #0
 801596c:	647b      	str	r3, [r7, #68]	@ 0x44
 801596e:	e055      	b.n	8015a1c <shadow_blur_corner+0x244>
            sh_ups_blur_buf[y] = v < 0 ? 0 : (v >> SHADOW_UPSCALE_SHIFT);
 8015970:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8015972:	2b00      	cmp	r3, #0
 8015974:	db03      	blt.n	801597e <shadow_blur_corner+0x1a6>
 8015976:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8015978:	119b      	asrs	r3, r3, #6
 801597a:	b299      	uxth	r1, r3
 801597c:	e000      	b.n	8015980 <shadow_blur_corner+0x1a8>
 801597e:	2100      	movs	r1, #0
 8015980:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015982:	005b      	lsls	r3, r3, #1
 8015984:	69fa      	ldr	r2, [r7, #28]
 8015986:	4413      	add	r3, r2
 8015988:	460a      	mov	r2, r1
 801598a:	801a      	strh	r2, [r3, #0]

            /*Forget the top pixel*/
            uint32_t top_val;
            if(y - s_right <= 0) top_val = sh_ups_tmp_buf[0];
 801598c:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801598e:	6a3b      	ldr	r3, [r7, #32]
 8015990:	1ad3      	subs	r3, r2, r3
 8015992:	2b00      	cmp	r3, #0
 8015994:	dc03      	bgt.n	801599e <shadow_blur_corner+0x1c6>
 8015996:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015998:	881b      	ldrh	r3, [r3, #0]
 801599a:	62bb      	str	r3, [r7, #40]	@ 0x28
 801599c:	e00c      	b.n	80159b8 <shadow_blur_corner+0x1e0>
            else top_val = sh_ups_buf[(y - s_right) * size + x];
 801599e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80159a0:	6a3b      	ldr	r3, [r7, #32]
 80159a2:	1ad3      	subs	r3, r2, r3
 80159a4:	68fa      	ldr	r2, [r7, #12]
 80159a6:	fb03 f202 	mul.w	r2, r3, r2
 80159aa:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80159ac:	4413      	add	r3, r2
 80159ae:	005b      	lsls	r3, r3, #1
 80159b0:	687a      	ldr	r2, [r7, #4]
 80159b2:	4413      	add	r3, r2
 80159b4:	881b      	ldrh	r3, [r3, #0]
 80159b6:	62bb      	str	r3, [r7, #40]	@ 0x28
            v -= top_val;
 80159b8:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80159ba:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80159bc:	1ad3      	subs	r3, r2, r3
 80159be:	62fb      	str	r3, [r7, #44]	@ 0x2c

            /*Add the bottom pixel*/
            uint32_t bottom_val;
            if(y + s_left + 1 < size) bottom_val = sh_ups_buf[(y + s_left + 1) * size + x];
 80159c0:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80159c2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80159c4:	4413      	add	r3, r2
 80159c6:	3301      	adds	r3, #1
 80159c8:	68fa      	ldr	r2, [r7, #12]
 80159ca:	429a      	cmp	r2, r3
 80159cc:	dd0e      	ble.n	80159ec <shadow_blur_corner+0x214>
 80159ce:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80159d0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80159d2:	4413      	add	r3, r2
 80159d4:	3301      	adds	r3, #1
 80159d6:	68fa      	ldr	r2, [r7, #12]
 80159d8:	fb03 f202 	mul.w	r2, r3, r2
 80159dc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80159de:	4413      	add	r3, r2
 80159e0:	005b      	lsls	r3, r3, #1
 80159e2:	687a      	ldr	r2, [r7, #4]
 80159e4:	4413      	add	r3, r2
 80159e6:	881b      	ldrh	r3, [r3, #0]
 80159e8:	627b      	str	r3, [r7, #36]	@ 0x24
 80159ea:	e00b      	b.n	8015a04 <shadow_blur_corner+0x22c>
            else bottom_val = sh_ups_buf[(size - 1) * size + x];
 80159ec:	68fb      	ldr	r3, [r7, #12]
 80159ee:	3b01      	subs	r3, #1
 80159f0:	68fa      	ldr	r2, [r7, #12]
 80159f2:	fb03 f202 	mul.w	r2, r3, r2
 80159f6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80159f8:	4413      	add	r3, r2
 80159fa:	005b      	lsls	r3, r3, #1
 80159fc:	687a      	ldr	r2, [r7, #4]
 80159fe:	4413      	add	r3, r2
 8015a00:	881b      	ldrh	r3, [r3, #0]
 8015a02:	627b      	str	r3, [r7, #36]	@ 0x24
            v += bottom_val;
 8015a04:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8015a06:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8015a08:	4413      	add	r3, r2
 8015a0a:	62fb      	str	r3, [r7, #44]	@ 0x2c
        for(y = 0; y < size ; y++, sh_ups_tmp_buf += size) {
 8015a0c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015a0e:	3301      	adds	r3, #1
 8015a10:	647b      	str	r3, [r7, #68]	@ 0x44
 8015a12:	68fb      	ldr	r3, [r7, #12]
 8015a14:	005b      	lsls	r3, r3, #1
 8015a16:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8015a18:	4413      	add	r3, r2
 8015a1a:	643b      	str	r3, [r7, #64]	@ 0x40
 8015a1c:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8015a1e:	68fb      	ldr	r3, [r7, #12]
 8015a20:	429a      	cmp	r2, r3
 8015a22:	dba5      	blt.n	8015970 <shadow_blur_corner+0x198>
        }

        /*Write back the result into `sh_ups_buf`*/
        sh_ups_tmp_buf = &sh_ups_buf[x];
 8015a24:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015a26:	005b      	lsls	r3, r3, #1
 8015a28:	687a      	ldr	r2, [r7, #4]
 8015a2a:	4413      	add	r3, r2
 8015a2c:	643b      	str	r3, [r7, #64]	@ 0x40
        for(y = 0; y < size; y++, sh_ups_tmp_buf += size) {
 8015a2e:	2300      	movs	r3, #0
 8015a30:	647b      	str	r3, [r7, #68]	@ 0x44
 8015a32:	e00e      	b.n	8015a52 <shadow_blur_corner+0x27a>
            (*sh_ups_tmp_buf) = sh_ups_blur_buf[y];
 8015a34:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015a36:	005b      	lsls	r3, r3, #1
 8015a38:	69fa      	ldr	r2, [r7, #28]
 8015a3a:	4413      	add	r3, r2
 8015a3c:	881a      	ldrh	r2, [r3, #0]
 8015a3e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8015a40:	801a      	strh	r2, [r3, #0]
        for(y = 0; y < size; y++, sh_ups_tmp_buf += size) {
 8015a42:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8015a44:	3301      	adds	r3, #1
 8015a46:	647b      	str	r3, [r7, #68]	@ 0x44
 8015a48:	68fb      	ldr	r3, [r7, #12]
 8015a4a:	005b      	lsls	r3, r3, #1
 8015a4c:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8015a4e:	4413      	add	r3, r2
 8015a50:	643b      	str	r3, [r7, #64]	@ 0x40
 8015a52:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8015a54:	68fb      	ldr	r3, [r7, #12]
 8015a56:	429a      	cmp	r2, r3
 8015a58:	dbec      	blt.n	8015a34 <shadow_blur_corner+0x25c>
    for(x = 0; x < size; x++) {
 8015a5a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8015a5c:	3301      	adds	r3, #1
 8015a5e:	64bb      	str	r3, [r7, #72]	@ 0x48
 8015a60:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8015a62:	68fb      	ldr	r3, [r7, #12]
 8015a64:	429a      	cmp	r2, r3
 8015a66:	f6ff af74 	blt.w	8015952 <shadow_blur_corner+0x17a>
        }
    }

    lv_free(sh_ups_blur_buf);
 8015a6a:	69f8      	ldr	r0, [r7, #28]
 8015a6c:	f010 f9e4 	bl	8025e38 <lv_free>
}
 8015a70:	bf00      	nop
 8015a72:	3750      	adds	r7, #80	@ 0x50
 8015a74:	46bd      	mov	sp, r7
 8015a76:	bd80      	pop	{r7, pc}

08015a78 <lv_area_copy>:
{
 8015a78:	b480      	push	{r7}
 8015a7a:	b083      	sub	sp, #12
 8015a7c:	af00      	add	r7, sp, #0
 8015a7e:	6078      	str	r0, [r7, #4]
 8015a80:	6039      	str	r1, [r7, #0]
    dest->x1 = src->x1;
 8015a82:	683b      	ldr	r3, [r7, #0]
 8015a84:	681a      	ldr	r2, [r3, #0]
 8015a86:	687b      	ldr	r3, [r7, #4]
 8015a88:	601a      	str	r2, [r3, #0]
    dest->y1 = src->y1;
 8015a8a:	683b      	ldr	r3, [r7, #0]
 8015a8c:	685a      	ldr	r2, [r3, #4]
 8015a8e:	687b      	ldr	r3, [r7, #4]
 8015a90:	605a      	str	r2, [r3, #4]
    dest->x2 = src->x2;
 8015a92:	683b      	ldr	r3, [r7, #0]
 8015a94:	689a      	ldr	r2, [r3, #8]
 8015a96:	687b      	ldr	r3, [r7, #4]
 8015a98:	609a      	str	r2, [r3, #8]
    dest->y2 = src->y2;
 8015a9a:	683b      	ldr	r3, [r7, #0]
 8015a9c:	68da      	ldr	r2, [r3, #12]
 8015a9e:	687b      	ldr	r3, [r7, #4]
 8015aa0:	60da      	str	r2, [r3, #12]
}
 8015aa2:	bf00      	nop
 8015aa4:	370c      	adds	r7, #12
 8015aa6:	46bd      	mov	sp, r7
 8015aa8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015aac:	4770      	bx	lr

08015aae <lv_area_get_width>:
{
 8015aae:	b480      	push	{r7}
 8015ab0:	b083      	sub	sp, #12
 8015ab2:	af00      	add	r7, sp, #0
 8015ab4:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 8015ab6:	687b      	ldr	r3, [r7, #4]
 8015ab8:	689a      	ldr	r2, [r3, #8]
 8015aba:	687b      	ldr	r3, [r7, #4]
 8015abc:	681b      	ldr	r3, [r3, #0]
 8015abe:	1ad3      	subs	r3, r2, r3
 8015ac0:	3301      	adds	r3, #1
}
 8015ac2:	4618      	mov	r0, r3
 8015ac4:	370c      	adds	r7, #12
 8015ac6:	46bd      	mov	sp, r7
 8015ac8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015acc:	4770      	bx	lr

08015ace <lv_area_get_height>:
{
 8015ace:	b480      	push	{r7}
 8015ad0:	b083      	sub	sp, #12
 8015ad2:	af00      	add	r7, sp, #0
 8015ad4:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 8015ad6:	687b      	ldr	r3, [r7, #4]
 8015ad8:	68da      	ldr	r2, [r3, #12]
 8015ada:	687b      	ldr	r3, [r7, #4]
 8015adc:	685b      	ldr	r3, [r3, #4]
 8015ade:	1ad3      	subs	r3, r2, r3
 8015ae0:	3301      	adds	r3, #1
}
 8015ae2:	4618      	mov	r0, r3
 8015ae4:	370c      	adds	r7, #12
 8015ae6:	46bd      	mov	sp, r7
 8015ae8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015aec:	4770      	bx	lr

08015aee <lv_draw_sw_fill>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_sw_fill(lv_draw_unit_t * draw_unit, const lv_draw_fill_dsc_t * dsc, const lv_area_t * coords)
{
 8015aee:	b580      	push	{r7, lr}
 8015af0:	b0bc      	sub	sp, #240	@ 0xf0
 8015af2:	af02      	add	r7, sp, #8
 8015af4:	60f8      	str	r0, [r7, #12]
 8015af6:	60b9      	str	r1, [r7, #8]
 8015af8:	607a      	str	r2, [r7, #4]
    if(dsc->opa <= LV_OPA_MIN) return;
 8015afa:	68bb      	ldr	r3, [r7, #8]
 8015afc:	f893 3020 	ldrb.w	r3, [r3, #32]
 8015b00:	2b02      	cmp	r3, #2
 8015b02:	f240 82fd 	bls.w	8016100 <lv_draw_sw_fill+0x612>

    lv_area_t bg_coords;
    lv_area_copy(&bg_coords, coords);
 8015b06:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8015b0a:	6879      	ldr	r1, [r7, #4]
 8015b0c:	4618      	mov	r0, r3
 8015b0e:	f7ff ffb3 	bl	8015a78 <lv_area_copy>

    lv_area_t clipped_coords;
    if(!_lv_area_intersect(&clipped_coords, &bg_coords, draw_unit->clip_area)) return;
 8015b12:	68fb      	ldr	r3, [r7, #12]
 8015b14:	689a      	ldr	r2, [r3, #8]
 8015b16:	f107 0190 	add.w	r1, r7, #144	@ 0x90
 8015b1a:	f107 0380 	add.w	r3, r7, #128	@ 0x80
 8015b1e:	4618      	mov	r0, r3
 8015b20:	f00b ff12 	bl	8021948 <_lv_area_intersect>
 8015b24:	4603      	mov	r3, r0
 8015b26:	f083 0301 	eor.w	r3, r3, #1
 8015b2a:	b2db      	uxtb	r3, r3
 8015b2c:	2b00      	cmp	r3, #0
 8015b2e:	f040 82e9 	bne.w	8016104 <lv_draw_sw_fill+0x616>

    lv_grad_dir_t grad_dir = dsc->grad.dir;
 8015b32:	68bb      	ldr	r3, [r7, #8]
 8015b34:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
 8015b38:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8015b3c:	b2db      	uxtb	r3, r3
 8015b3e:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7
    lv_color_t bg_color    = grad_dir == LV_GRAD_DIR_NONE ? dsc->color : dsc->grad.stops[0].color;
 8015b42:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 8015b46:	2b00      	cmp	r3, #0
 8015b48:	d108      	bne.n	8015b5c <lv_draw_sw_fill+0x6e>
 8015b4a:	68ba      	ldr	r2, [r7, #8]
 8015b4c:	f107 037c 	add.w	r3, r7, #124	@ 0x7c
 8015b50:	3221      	adds	r2, #33	@ 0x21
 8015b52:	8811      	ldrh	r1, [r2, #0]
 8015b54:	7892      	ldrb	r2, [r2, #2]
 8015b56:	8019      	strh	r1, [r3, #0]
 8015b58:	709a      	strb	r2, [r3, #2]
 8015b5a:	e009      	b.n	8015b70 <lv_draw_sw_fill+0x82>
 8015b5c:	68ba      	ldr	r2, [r7, #8]
 8015b5e:	f107 037c 	add.w	r3, r7, #124	@ 0x7c
 8015b62:	3224      	adds	r2, #36	@ 0x24
 8015b64:	6812      	ldr	r2, [r2, #0]
 8015b66:	4611      	mov	r1, r2
 8015b68:	8019      	strh	r1, [r3, #0]
 8015b6a:	3302      	adds	r3, #2
 8015b6c:	0c12      	lsrs	r2, r2, #16
 8015b6e:	701a      	strb	r2, [r3, #0]

    lv_draw_sw_blend_dsc_t blend_dsc = {0};
 8015b70:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 8015b74:	222c      	movs	r2, #44	@ 0x2c
 8015b76:	2100      	movs	r1, #0
 8015b78:	4618      	mov	r0, r3
 8015b7a:	f011 ffb3 	bl	8027ae4 <memset>
    blend_dsc.color = bg_color;
 8015b7e:	f107 0365 	add.w	r3, r7, #101	@ 0x65
 8015b82:	f107 027c 	add.w	r2, r7, #124	@ 0x7c
 8015b86:	8811      	ldrh	r1, [r2, #0]
 8015b88:	7892      	ldrb	r2, [r2, #2]
 8015b8a:	8019      	strh	r1, [r3, #0]
 8015b8c:	709a      	strb	r2, [r3, #2]

    /*Most simple case: just a plain rectangle*/
    if(dsc->radius == 0 && (grad_dir == LV_GRAD_DIR_NONE)) {
 8015b8e:	68bb      	ldr	r3, [r7, #8]
 8015b90:	69db      	ldr	r3, [r3, #28]
 8015b92:	2b00      	cmp	r3, #0
 8015b94:	d112      	bne.n	8015bbc <lv_draw_sw_fill+0xce>
 8015b96:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 8015b9a:	2b00      	cmp	r3, #0
 8015b9c:	d10e      	bne.n	8015bbc <lv_draw_sw_fill+0xce>
        blend_dsc.blend_area = &bg_coords;
 8015b9e:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8015ba2:	653b      	str	r3, [r7, #80]	@ 0x50
        blend_dsc.opa = dsc->opa;
 8015ba4:	68bb      	ldr	r3, [r7, #8]
 8015ba6:	f893 3020 	ldrb.w	r3, [r3, #32]
 8015baa:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 8015bae:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 8015bb2:	4619      	mov	r1, r3
 8015bb4:	68f8      	ldr	r0, [r7, #12]
 8015bb6:	f7f8 fead 	bl	800e914 <lv_draw_sw_blend>
        return;
 8015bba:	e2a4      	b.n	8016106 <lv_draw_sw_fill+0x618>

    /*Complex case: there is gradient, mask, or radius*/
#if LV_DRAW_SW_COMPLEX == 0
    LV_LOG_WARN("Can't draw complex rectangle because LV_DRAW_SW_COMPLEX = 0");
#else
    lv_opa_t opa = dsc->opa >= LV_OPA_MAX ? LV_OPA_COVER : dsc->opa;
 8015bbc:	68bb      	ldr	r3, [r7, #8]
 8015bbe:	f893 3020 	ldrb.w	r3, [r3, #32]
 8015bc2:	2bfc      	cmp	r3, #252	@ 0xfc
 8015bc4:	d803      	bhi.n	8015bce <lv_draw_sw_fill+0xe0>
 8015bc6:	68bb      	ldr	r3, [r7, #8]
 8015bc8:	f893 3020 	ldrb.w	r3, [r3, #32]
 8015bcc:	e000      	b.n	8015bd0 <lv_draw_sw_fill+0xe2>
 8015bce:	23ff      	movs	r3, #255	@ 0xff
 8015bd0:	f887 30c6 	strb.w	r3, [r7, #198]	@ 0xc6

    /*Get the real radius. Can't be larger than the half of the shortest side */
    int32_t coords_bg_w = lv_area_get_width(&bg_coords);
 8015bd4:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8015bd8:	4618      	mov	r0, r3
 8015bda:	f7ff ff68 	bl	8015aae <lv_area_get_width>
 8015bde:	f8c7 00c0 	str.w	r0, [r7, #192]	@ 0xc0
    int32_t coords_bg_h = lv_area_get_height(&bg_coords);
 8015be2:	f107 0390 	add.w	r3, r7, #144	@ 0x90
 8015be6:	4618      	mov	r0, r3
 8015be8:	f7ff ff71 	bl	8015ace <lv_area_get_height>
 8015bec:	f8c7 00bc 	str.w	r0, [r7, #188]	@ 0xbc
    int32_t short_side = LV_MIN(coords_bg_w, coords_bg_h);
 8015bf0:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8015bf4:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8015bf8:	4293      	cmp	r3, r2
 8015bfa:	bfa8      	it	ge
 8015bfc:	4613      	movge	r3, r2
 8015bfe:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    int32_t rout = LV_MIN(dsc->radius, short_side >> 1);
 8015c02:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8015c06:	105a      	asrs	r2, r3, #1
 8015c08:	68bb      	ldr	r3, [r7, #8]
 8015c0a:	69db      	ldr	r3, [r3, #28]
 8015c0c:	4293      	cmp	r3, r2
 8015c0e:	bfa8      	it	ge
 8015c10:	4613      	movge	r3, r2
 8015c12:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4

    /*Add a radius mask if there is a radius*/
    int32_t clipped_w = lv_area_get_width(&clipped_coords);
 8015c16:	f107 0380 	add.w	r3, r7, #128	@ 0x80
 8015c1a:	4618      	mov	r0, r3
 8015c1c:	f7ff ff47 	bl	8015aae <lv_area_get_width>
 8015c20:	f8c7 00b0 	str.w	r0, [r7, #176]	@ 0xb0
    lv_opa_t * mask_buf = NULL;
 8015c24:	2300      	movs	r3, #0
 8015c26:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    lv_draw_sw_mask_radius_param_t mask_rout_param;
    void * mask_list[2] = {NULL, NULL};
 8015c2a:	2300      	movs	r3, #0
 8015c2c:	627b      	str	r3, [r7, #36]	@ 0x24
 8015c2e:	2300      	movs	r3, #0
 8015c30:	62bb      	str	r3, [r7, #40]	@ 0x28
    if(rout > 0) {
 8015c32:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8015c36:	2b00      	cmp	r3, #0
 8015c38:	dd12      	ble.n	8015c60 <lv_draw_sw_fill+0x172>
        mask_buf = lv_malloc(clipped_w);
 8015c3a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8015c3e:	4618      	mov	r0, r3
 8015c40:	f010 f8c2 	bl	8025dc8 <lv_malloc>
 8015c44:	f8c7 00e4 	str.w	r0, [r7, #228]	@ 0xe4
        lv_draw_sw_mask_radius_init(&mask_rout_param, &bg_coords, rout, false);
 8015c48:	f107 0190 	add.w	r1, r7, #144	@ 0x90
 8015c4c:	f107 002c 	add.w	r0, r7, #44	@ 0x2c
 8015c50:	2300      	movs	r3, #0
 8015c52:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8015c56:	f002 fcff 	bl	8018658 <lv_draw_sw_mask_radius_init>
        mask_list[0] = &mask_rout_param;
 8015c5a:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8015c5e:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    int32_t h;

    lv_area_t blend_area;
    blend_area.x1 = clipped_coords.x1;
 8015c60:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8015c64:	617b      	str	r3, [r7, #20]
    blend_area.x2 = clipped_coords.x2;
 8015c66:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8015c6a:	61fb      	str	r3, [r7, #28]

    blend_dsc.mask_buf = mask_buf;
 8015c6c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8015c70:	66bb      	str	r3, [r7, #104]	@ 0x68
    blend_dsc.blend_area = &blend_area;
 8015c72:	f107 0314 	add.w	r3, r7, #20
 8015c76:	653b      	str	r3, [r7, #80]	@ 0x50
    blend_dsc.mask_area = &blend_area;
 8015c78:	f107 0314 	add.w	r3, r7, #20
 8015c7c:	673b      	str	r3, [r7, #112]	@ 0x70
    blend_dsc.opa = LV_OPA_COVER;
 8015c7e:	23ff      	movs	r3, #255	@ 0xff
 8015c80:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64

    /*Get gradient if appropriate*/
    lv_grad_t * grad = lv_gradient_get(&dsc->grad, coords_bg_w, coords_bg_h);
 8015c84:	68bb      	ldr	r3, [r7, #8]
 8015c86:	3324      	adds	r3, #36	@ 0x24
 8015c88:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8015c8c:	f8d7 10c0 	ldr.w	r1, [r7, #192]	@ 0xc0
 8015c90:	4618      	mov	r0, r3
 8015c92:	f000 faac 	bl	80161ee <lv_gradient_get>
 8015c96:	f8c7 00ac 	str.w	r0, [r7, #172]	@ 0xac
    lv_opa_t * grad_opa_map = NULL;
 8015c9a:	2300      	movs	r3, #0
 8015c9c:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    if(grad && grad_dir == LV_GRAD_DIR_HOR) {
 8015ca0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8015ca4:	2b00      	cmp	r3, #0
 8015ca6:	d04a      	beq.n	8015d3e <lv_draw_sw_fill+0x250>
 8015ca8:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 8015cac:	2b02      	cmp	r3, #2
 8015cae:	d146      	bne.n	8015d3e <lv_draw_sw_fill+0x250>
        blend_dsc.src_area = &blend_area;
 8015cb0:	f107 0314 	add.w	r3, r7, #20
 8015cb4:	663b      	str	r3, [r7, #96]	@ 0x60
        blend_dsc.src_buf = grad->color_map + clipped_coords.x1 - bg_coords.x1;
 8015cb6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8015cba:	6819      	ldr	r1, [r3, #0]
 8015cbc:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8015cc0:	461a      	mov	r2, r3
 8015cc2:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015cc6:	1ad2      	subs	r2, r2, r3
 8015cc8:	4613      	mov	r3, r2
 8015cca:	005b      	lsls	r3, r3, #1
 8015ccc:	4413      	add	r3, r2
 8015cce:	440b      	add	r3, r1
 8015cd0:	657b      	str	r3, [r7, #84]	@ 0x54
        bool transp = false;
 8015cd2:	2300      	movs	r3, #0
 8015cd4:	f887 30db 	strb.w	r3, [r7, #219]	@ 0xdb
        uint32_t s;
        for(s = 0; s < dsc->grad.stops_count; s++) {
 8015cd8:	2300      	movs	r3, #0
 8015cda:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 8015cde:	e013      	b.n	8015d08 <lv_draw_sw_fill+0x21a>
            if(dsc->grad.stops[s].opa != LV_OPA_COVER) {
 8015ce0:	68b9      	ldr	r1, [r7, #8]
 8015ce2:	f8d7 20d4 	ldr.w	r2, [r7, #212]	@ 0xd4
 8015ce6:	4613      	mov	r3, r2
 8015ce8:	009b      	lsls	r3, r3, #2
 8015cea:	4413      	add	r3, r2
 8015cec:	440b      	add	r3, r1
 8015cee:	3327      	adds	r3, #39	@ 0x27
 8015cf0:	781b      	ldrb	r3, [r3, #0]
 8015cf2:	2bff      	cmp	r3, #255	@ 0xff
 8015cf4:	d003      	beq.n	8015cfe <lv_draw_sw_fill+0x210>
                transp = true;
 8015cf6:	2301      	movs	r3, #1
 8015cf8:	f887 30db 	strb.w	r3, [r7, #219]	@ 0xdb
                break;
 8015cfc:	e00c      	b.n	8015d18 <lv_draw_sw_fill+0x22a>
        for(s = 0; s < dsc->grad.stops_count; s++) {
 8015cfe:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8015d02:	3301      	adds	r3, #1
 8015d04:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 8015d08:	68bb      	ldr	r3, [r7, #8]
 8015d0a:	f893 302e 	ldrb.w	r3, [r3, #46]	@ 0x2e
 8015d0e:	461a      	mov	r2, r3
 8015d10:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8015d14:	4293      	cmp	r3, r2
 8015d16:	d3e3      	bcc.n	8015ce0 <lv_draw_sw_fill+0x1f2>
            }
        }

        if(transp) grad_opa_map = grad->opa_map + clipped_coords.x1 - bg_coords.x1;
 8015d18:	f897 30db 	ldrb.w	r3, [r7, #219]	@ 0xdb
 8015d1c:	2b00      	cmp	r3, #0
 8015d1e:	d00b      	beq.n	8015d38 <lv_draw_sw_fill+0x24a>
 8015d20:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8015d24:	685a      	ldr	r2, [r3, #4]
 8015d26:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8015d2a:	4619      	mov	r1, r3
 8015d2c:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8015d30:	1acb      	subs	r3, r1, r3
 8015d32:	4413      	add	r3, r2
 8015d34:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc

        blend_dsc.src_color_format = LV_COLOR_FORMAT_RGB888;
 8015d38:	230f      	movs	r3, #15
 8015d3a:	f887 305c 	strb.w	r3, [r7, #92]	@ 0x5c
    }

    /* Draw the top of the rectangle line by line and mirror it to the bottom. */
    for(h = 0; h < rout; h++) {
 8015d3e:	2300      	movs	r3, #0
 8015d40:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 8015d44:	e12b      	b.n	8015f9e <lv_draw_sw_fill+0x4b0>
        int32_t top_y = bg_coords.y1 + h;
 8015d46:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8015d4a:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8015d4e:	4413      	add	r3, r2
 8015d50:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
        int32_t bottom_y = bg_coords.y2 - h;
 8015d54:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8015d58:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8015d5c:	1ad3      	subs	r3, r2, r3
 8015d5e:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
        if(top_y < clipped_coords.y1 && bottom_y > clipped_coords.y2) continue;   /*This line is clipped now*/
 8015d62:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8015d66:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8015d6a:	429a      	cmp	r2, r3
 8015d6c:	da06      	bge.n	8015d7c <lv_draw_sw_fill+0x28e>
 8015d6e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8015d72:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8015d76:	429a      	cmp	r2, r3
 8015d78:	f300 810b 	bgt.w	8015f92 <lv_draw_sw_fill+0x4a4>

        /* Initialize the mask to opa instead of 0xFF and blend with LV_OPA_COVER.
         * It saves calculating the final opa in lv_draw_sw_blend*/
        lv_memset(mask_buf, opa, clipped_w);
 8015d7c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8015d80:	f897 30c6 	ldrb.w	r3, [r7, #198]	@ 0xc6
 8015d84:	4619      	mov	r1, r3
 8015d86:	f8d7 00e4 	ldr.w	r0, [r7, #228]	@ 0xe4
 8015d8a:	f00f f84a 	bl	8024e22 <lv_memset>
        blend_dsc.mask_res = lv_draw_sw_mask_apply(mask_list, mask_buf, blend_area.x1, top_y, clipped_w);
 8015d8e:	697a      	ldr	r2, [r7, #20]
 8015d90:	f107 0024 	add.w	r0, r7, #36	@ 0x24
 8015d94:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8015d98:	9300      	str	r3, [sp, #0]
 8015d9a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8015d9e:	f8d7 10e4 	ldr.w	r1, [r7, #228]	@ 0xe4
 8015da2:	f002 f9e3 	bl	801816c <lv_draw_sw_mask_apply>
 8015da6:	4603      	mov	r3, r0
 8015da8:	f887 306c 	strb.w	r3, [r7, #108]	@ 0x6c
        if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_FULL_COVER) blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8015dac:	f897 306c 	ldrb.w	r3, [r7, #108]	@ 0x6c
 8015db0:	2b01      	cmp	r3, #1
 8015db2:	d102      	bne.n	8015dba <lv_draw_sw_fill+0x2cc>
 8015db4:	2302      	movs	r3, #2
 8015db6:	f887 306c 	strb.w	r3, [r7, #108]	@ 0x6c

        bool hor_grad_processed = false;
 8015dba:	2300      	movs	r3, #0
 8015dbc:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
        if(top_y >= clipped_coords.y1) {
 8015dc0:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8015dc4:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 8015dc8:	429a      	cmp	r2, r3
 8015dca:	db6b      	blt.n	8015ea4 <lv_draw_sw_fill+0x3b6>
            blend_area.y1 = top_y;
 8015dcc:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8015dd0:	61bb      	str	r3, [r7, #24]
            blend_area.y2 = top_y;
 8015dd2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8015dd6:	623b      	str	r3, [r7, #32]

            if(grad_dir == LV_GRAD_DIR_VER) {
 8015dd8:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 8015ddc:	2b01      	cmp	r3, #1
 8015dde:	d11f      	bne.n	8015e20 <lv_draw_sw_fill+0x332>
                blend_dsc.color = grad->color_map[top_y - bg_coords.y1];
 8015de0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8015de4:	681a      	ldr	r2, [r3, #0]
 8015de6:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8015dea:	f8d7 10a4 	ldr.w	r1, [r7, #164]	@ 0xa4
 8015dee:	1acb      	subs	r3, r1, r3
 8015df0:	4619      	mov	r1, r3
 8015df2:	460b      	mov	r3, r1
 8015df4:	005b      	lsls	r3, r3, #1
 8015df6:	440b      	add	r3, r1
 8015df8:	441a      	add	r2, r3
 8015dfa:	f107 0365 	add.w	r3, r7, #101	@ 0x65
 8015dfe:	8811      	ldrh	r1, [r2, #0]
 8015e00:	7892      	ldrb	r2, [r2, #2]
 8015e02:	8019      	strh	r1, [r3, #0]
 8015e04:	709a      	strb	r2, [r3, #2]
                blend_dsc.opa = grad->opa_map[top_y - bg_coords.y1];
 8015e06:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8015e0a:	685b      	ldr	r3, [r3, #4]
 8015e0c:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8015e10:	f8d7 10a4 	ldr.w	r1, [r7, #164]	@ 0xa4
 8015e14:	1a8a      	subs	r2, r1, r2
 8015e16:	4413      	add	r3, r2
 8015e18:	781b      	ldrb	r3, [r3, #0]
 8015e1a:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
 8015e1e:	e03b      	b.n	8015e98 <lv_draw_sw_fill+0x3aa>
            }
            else if(grad_dir == LV_GRAD_DIR_HOR) {
 8015e20:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 8015e24:	2b02      	cmp	r3, #2
 8015e26:	d137      	bne.n	8015e98 <lv_draw_sw_fill+0x3aa>
                hor_grad_processed = true;
 8015e28:	2301      	movs	r3, #1
 8015e2a:	f887 30d3 	strb.w	r3, [r7, #211]	@ 0xd3
                if(grad_opa_map) {
 8015e2e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8015e32:	2b00      	cmp	r3, #0
 8015e34:	d030      	beq.n	8015e98 <lv_draw_sw_fill+0x3aa>
                    int32_t i;
                    for(i = 0; i < clipped_w; i++) {
 8015e36:	2300      	movs	r3, #0
 8015e38:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 8015e3c:	e023      	b.n	8015e86 <lv_draw_sw_fill+0x398>
                        if(grad_opa_map[i] < LV_OPA_MAX) mask_buf[i] = (mask_buf[i] * grad_opa_map[i]) >> 8;
 8015e3e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8015e42:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8015e46:	4413      	add	r3, r2
 8015e48:	781b      	ldrb	r3, [r3, #0]
 8015e4a:	2bfc      	cmp	r3, #252	@ 0xfc
 8015e4c:	d816      	bhi.n	8015e7c <lv_draw_sw_fill+0x38e>
 8015e4e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8015e52:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8015e56:	4413      	add	r3, r2
 8015e58:	781b      	ldrb	r3, [r3, #0]
 8015e5a:	4619      	mov	r1, r3
 8015e5c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8015e60:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8015e64:	4413      	add	r3, r2
 8015e66:	781b      	ldrb	r3, [r3, #0]
 8015e68:	fb01 f303 	mul.w	r3, r1, r3
 8015e6c:	1219      	asrs	r1, r3, #8
 8015e6e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8015e72:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8015e76:	4413      	add	r3, r2
 8015e78:	b2ca      	uxtb	r2, r1
 8015e7a:	701a      	strb	r2, [r3, #0]
                    for(i = 0; i < clipped_w; i++) {
 8015e7c:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8015e80:	3301      	adds	r3, #1
 8015e82:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 8015e86:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 8015e8a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8015e8e:	429a      	cmp	r2, r3
 8015e90:	dbd5      	blt.n	8015e3e <lv_draw_sw_fill+0x350>
                    }
                    blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8015e92:	2302      	movs	r3, #2
 8015e94:	f887 306c 	strb.w	r3, [r7, #108]	@ 0x6c
                }
            }
            lv_draw_sw_blend(draw_unit, &blend_dsc);
 8015e98:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 8015e9c:	4619      	mov	r1, r3
 8015e9e:	68f8      	ldr	r0, [r7, #12]
 8015ea0:	f7f8 fd38 	bl	800e914 <lv_draw_sw_blend>
        }

        if(bottom_y <= clipped_coords.y2) {
 8015ea4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8015ea8:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 8015eac:	429a      	cmp	r2, r3
 8015eae:	dc71      	bgt.n	8015f94 <lv_draw_sw_fill+0x4a6>
            blend_area.y1 = bottom_y;
 8015eb0:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8015eb4:	61bb      	str	r3, [r7, #24]
            blend_area.y2 = bottom_y;
 8015eb6:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8015eba:	623b      	str	r3, [r7, #32]

            if(grad_dir == LV_GRAD_DIR_VER) {
 8015ebc:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 8015ec0:	2b01      	cmp	r3, #1
 8015ec2:	d11f      	bne.n	8015f04 <lv_draw_sw_fill+0x416>
                blend_dsc.color = grad->color_map[bottom_y - bg_coords.y1];
 8015ec4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8015ec8:	681a      	ldr	r2, [r3, #0]
 8015eca:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8015ece:	f8d7 10a0 	ldr.w	r1, [r7, #160]	@ 0xa0
 8015ed2:	1acb      	subs	r3, r1, r3
 8015ed4:	4619      	mov	r1, r3
 8015ed6:	460b      	mov	r3, r1
 8015ed8:	005b      	lsls	r3, r3, #1
 8015eda:	440b      	add	r3, r1
 8015edc:	441a      	add	r2, r3
 8015ede:	f107 0365 	add.w	r3, r7, #101	@ 0x65
 8015ee2:	8811      	ldrh	r1, [r2, #0]
 8015ee4:	7892      	ldrb	r2, [r2, #2]
 8015ee6:	8019      	strh	r1, [r3, #0]
 8015ee8:	709a      	strb	r2, [r3, #2]
                blend_dsc.opa = grad->opa_map[bottom_y - bg_coords.y1];
 8015eea:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8015eee:	685b      	ldr	r3, [r3, #4]
 8015ef0:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8015ef4:	f8d7 10a0 	ldr.w	r1, [r7, #160]	@ 0xa0
 8015ef8:	1a8a      	subs	r2, r1, r2
 8015efa:	4413      	add	r3, r2
 8015efc:	781b      	ldrb	r3, [r3, #0]
 8015efe:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
 8015f02:	e03f      	b.n	8015f84 <lv_draw_sw_fill+0x496>
            }
            else if(hor_grad_processed == false && grad_dir == LV_GRAD_DIR_HOR) {
 8015f04:	f897 30d3 	ldrb.w	r3, [r7, #211]	@ 0xd3
 8015f08:	f083 0301 	eor.w	r3, r3, #1
 8015f0c:	b2db      	uxtb	r3, r3
 8015f0e:	2b00      	cmp	r3, #0
 8015f10:	d038      	beq.n	8015f84 <lv_draw_sw_fill+0x496>
 8015f12:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 8015f16:	2b02      	cmp	r3, #2
 8015f18:	d134      	bne.n	8015f84 <lv_draw_sw_fill+0x496>
                if(grad_opa_map) {
 8015f1a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8015f1e:	2b00      	cmp	r3, #0
 8015f20:	d030      	beq.n	8015f84 <lv_draw_sw_fill+0x496>
                    int32_t i;
                    for(i = 0; i < clipped_w; i++) {
 8015f22:	2300      	movs	r3, #0
 8015f24:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8015f28:	e023      	b.n	8015f72 <lv_draw_sw_fill+0x484>
                        if(grad_opa_map[i] < LV_OPA_MAX) mask_buf[i] = (mask_buf[i] * grad_opa_map[i]) >> 8;
 8015f2a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8015f2e:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8015f32:	4413      	add	r3, r2
 8015f34:	781b      	ldrb	r3, [r3, #0]
 8015f36:	2bfc      	cmp	r3, #252	@ 0xfc
 8015f38:	d816      	bhi.n	8015f68 <lv_draw_sw_fill+0x47a>
 8015f3a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8015f3e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8015f42:	4413      	add	r3, r2
 8015f44:	781b      	ldrb	r3, [r3, #0]
 8015f46:	4619      	mov	r1, r3
 8015f48:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8015f4c:	f8d7 20dc 	ldr.w	r2, [r7, #220]	@ 0xdc
 8015f50:	4413      	add	r3, r2
 8015f52:	781b      	ldrb	r3, [r3, #0]
 8015f54:	fb01 f303 	mul.w	r3, r1, r3
 8015f58:	1219      	asrs	r1, r3, #8
 8015f5a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8015f5e:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8015f62:	4413      	add	r3, r2
 8015f64:	b2ca      	uxtb	r2, r1
 8015f66:	701a      	strb	r2, [r3, #0]
                    for(i = 0; i < clipped_w; i++) {
 8015f68:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8015f6c:	3301      	adds	r3, #1
 8015f6e:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8015f72:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8015f76:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8015f7a:	429a      	cmp	r2, r3
 8015f7c:	dbd5      	blt.n	8015f2a <lv_draw_sw_fill+0x43c>
                    }
                    blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8015f7e:	2302      	movs	r3, #2
 8015f80:	f887 306c 	strb.w	r3, [r7, #108]	@ 0x6c
                }
            }
            lv_draw_sw_blend(draw_unit, &blend_dsc);
 8015f84:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 8015f88:	4619      	mov	r1, r3
 8015f8a:	68f8      	ldr	r0, [r7, #12]
 8015f8c:	f7f8 fcc2 	bl	800e914 <lv_draw_sw_blend>
 8015f90:	e000      	b.n	8015f94 <lv_draw_sw_fill+0x4a6>
        if(top_y < clipped_coords.y1 && bottom_y > clipped_coords.y2) continue;   /*This line is clipped now*/
 8015f92:	bf00      	nop
    for(h = 0; h < rout; h++) {
 8015f94:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8015f98:	3301      	adds	r3, #1
 8015f9a:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 8015f9e:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 8015fa2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8015fa6:	429a      	cmp	r2, r3
 8015fa8:	f6ff aecd 	blt.w	8015d46 <lv_draw_sw_fill+0x258>
    }

    /* Draw the center of the rectangle.*/

    /*If no gradient, the center is a simple rectangle*/
    if(grad_dir == LV_GRAD_DIR_NONE) {
 8015fac:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 8015fb0:	2b00      	cmp	r3, #0
 8015fb2:	d118      	bne.n	8015fe6 <lv_draw_sw_fill+0x4f8>
        blend_area.y1 = bg_coords.y1 + rout;
 8015fb4:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8015fb8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8015fbc:	4413      	add	r3, r2
 8015fbe:	61bb      	str	r3, [r7, #24]
        blend_area.y2 = bg_coords.y2 - rout;
 8015fc0:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8015fc4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8015fc8:	1ad3      	subs	r3, r2, r3
 8015fca:	623b      	str	r3, [r7, #32]
        blend_dsc.opa = opa;
 8015fcc:	f897 30c6 	ldrb.w	r3, [r7, #198]	@ 0xc6
 8015fd0:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
        blend_dsc.mask_buf = NULL;
 8015fd4:	2300      	movs	r3, #0
 8015fd6:	66bb      	str	r3, [r7, #104]	@ 0x68
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 8015fd8:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 8015fdc:	4619      	mov	r1, r3
 8015fde:	68f8      	ldr	r0, [r7, #12]
 8015fe0:	f7f8 fc98 	bl	800e914 <lv_draw_sw_blend>
 8015fe4:	e076      	b.n	80160d4 <lv_draw_sw_fill+0x5e6>
    }
    /*With gradient draw line by line*/
    else {
        blend_dsc.opa = opa;
 8015fe6:	f897 30c6 	ldrb.w	r3, [r7, #198]	@ 0xc6
 8015fea:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
        if(grad_dir == LV_GRAD_DIR_VER) {
 8015fee:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 8015ff2:	2b01      	cmp	r3, #1
 8015ff4:	d103      	bne.n	8015ffe <lv_draw_sw_fill+0x510>
            blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_FULL_COVER;
 8015ff6:	2301      	movs	r3, #1
 8015ff8:	f887 306c 	strb.w	r3, [r7, #108]	@ 0x6c
 8015ffc:	e009      	b.n	8016012 <lv_draw_sw_fill+0x524>
        }
        else if(grad_dir == LV_GRAD_DIR_HOR) {
 8015ffe:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 8016002:	2b02      	cmp	r3, #2
 8016004:	d105      	bne.n	8016012 <lv_draw_sw_fill+0x524>
            blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8016006:	2302      	movs	r3, #2
 8016008:	f887 306c 	strb.w	r3, [r7, #108]	@ 0x6c
            blend_dsc.mask_buf = grad_opa_map;
 801600c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8016010:	66bb      	str	r3, [r7, #104]	@ 0x68
        }

        int32_t h_end = bg_coords.y2 - rout;
 8016012:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8016016:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 801601a:	1ad3      	subs	r3, r2, r3
 801601c:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
        for(h = bg_coords.y1 + rout; h <= h_end; h++) {
 8016020:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8016024:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8016028:	4413      	add	r3, r2
 801602a:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 801602e:	e04b      	b.n	80160c8 <lv_draw_sw_fill+0x5da>
            blend_area.y1 = h;
 8016030:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8016034:	61bb      	str	r3, [r7, #24]
            blend_area.y2 = h;
 8016036:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801603a:	623b      	str	r3, [r7, #32]

            if(grad_dir == LV_GRAD_DIR_VER) {
 801603c:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 8016040:	2b01      	cmp	r3, #1
 8016042:	d136      	bne.n	80160b2 <lv_draw_sw_fill+0x5c4>
                blend_dsc.color = grad->color_map[h - bg_coords.y1];
 8016044:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8016048:	681a      	ldr	r2, [r3, #0]
 801604a:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801604e:	f8d7 10e0 	ldr.w	r1, [r7, #224]	@ 0xe0
 8016052:	1acb      	subs	r3, r1, r3
 8016054:	4619      	mov	r1, r3
 8016056:	460b      	mov	r3, r1
 8016058:	005b      	lsls	r3, r3, #1
 801605a:	440b      	add	r3, r1
 801605c:	441a      	add	r2, r3
 801605e:	f107 0365 	add.w	r3, r7, #101	@ 0x65
 8016062:	8811      	ldrh	r1, [r2, #0]
 8016064:	7892      	ldrb	r2, [r2, #2]
 8016066:	8019      	strh	r1, [r3, #0]
 8016068:	709a      	strb	r2, [r3, #2]
                if(opa >= LV_OPA_MAX) blend_dsc.opa = grad->opa_map[h - bg_coords.y1];
 801606a:	f897 30c6 	ldrb.w	r3, [r7, #198]	@ 0xc6
 801606e:	2bfc      	cmp	r3, #252	@ 0xfc
 8016070:	d90c      	bls.n	801608c <lv_draw_sw_fill+0x59e>
 8016072:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8016076:	685b      	ldr	r3, [r3, #4]
 8016078:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 801607c:	f8d7 10e0 	ldr.w	r1, [r7, #224]	@ 0xe0
 8016080:	1a8a      	subs	r2, r1, r2
 8016082:	4413      	add	r3, r2
 8016084:	781b      	ldrb	r3, [r3, #0]
 8016086:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
 801608a:	e012      	b.n	80160b2 <lv_draw_sw_fill+0x5c4>
                else blend_dsc.opa = LV_OPA_MIX2(grad->opa_map[h - bg_coords.y1], opa);
 801608c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8016090:	685b      	ldr	r3, [r3, #4]
 8016092:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8016096:	f8d7 10e0 	ldr.w	r1, [r7, #224]	@ 0xe0
 801609a:	1a8a      	subs	r2, r1, r2
 801609c:	4413      	add	r3, r2
 801609e:	781b      	ldrb	r3, [r3, #0]
 80160a0:	461a      	mov	r2, r3
 80160a2:	f897 30c6 	ldrb.w	r3, [r7, #198]	@ 0xc6
 80160a6:	fb02 f303 	mul.w	r3, r2, r3
 80160aa:	121b      	asrs	r3, r3, #8
 80160ac:	b2db      	uxtb	r3, r3
 80160ae:	f887 3064 	strb.w	r3, [r7, #100]	@ 0x64
            }
            lv_draw_sw_blend(draw_unit, &blend_dsc);
 80160b2:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 80160b6:	4619      	mov	r1, r3
 80160b8:	68f8      	ldr	r0, [r7, #12]
 80160ba:	f7f8 fc2b 	bl	800e914 <lv_draw_sw_blend>
        for(h = bg_coords.y1 + rout; h <= h_end; h++) {
 80160be:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80160c2:	3301      	adds	r3, #1
 80160c4:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 80160c8:	f8d7 20e0 	ldr.w	r2, [r7, #224]	@ 0xe0
 80160cc:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 80160d0:	429a      	cmp	r2, r3
 80160d2:	ddad      	ble.n	8016030 <lv_draw_sw_fill+0x542>
        }
    }

    if(mask_buf) {
 80160d4:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80160d8:	2b00      	cmp	r3, #0
 80160da:	d008      	beq.n	80160ee <lv_draw_sw_fill+0x600>
        lv_free(mask_buf);
 80160dc:	f8d7 00e4 	ldr.w	r0, [r7, #228]	@ 0xe4
 80160e0:	f00f feaa 	bl	8025e38 <lv_free>
        lv_draw_sw_mask_free_param(&mask_rout_param);
 80160e4:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 80160e8:	4618      	mov	r0, r3
 80160ea:	f002 f881 	bl	80181f0 <lv_draw_sw_mask_free_param>
    }
    if(grad) {
 80160ee:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 80160f2:	2b00      	cmp	r3, #0
 80160f4:	d007      	beq.n	8016106 <lv_draw_sw_fill+0x618>
        lv_gradient_cleanup(grad);
 80160f6:	f8d7 00ac 	ldr.w	r0, [r7, #172]	@ 0xac
 80160fa:	f000 f9fb 	bl	80164f4 <lv_gradient_cleanup>
 80160fe:	e002      	b.n	8016106 <lv_draw_sw_fill+0x618>
    if(dsc->opa <= LV_OPA_MIN) return;
 8016100:	bf00      	nop
 8016102:	e000      	b.n	8016106 <lv_draw_sw_fill+0x618>
    if(!_lv_area_intersect(&clipped_coords, &bg_coords, draw_unit->clip_area)) return;
 8016104:	bf00      	nop
    }

#endif
}
 8016106:	37e8      	adds	r7, #232	@ 0xe8
 8016108:	46bd      	mov	sp, r7
 801610a:	bd80      	pop	{r7, pc}

0801610c <lv_color_make>:
 * @param g     the green channel (0..255)
 * @param b     the blue channel (0..255)
 * @return      the color
 */
static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
{
 801610c:	b480      	push	{r7}
 801610e:	b085      	sub	sp, #20
 8016110:	af00      	add	r7, sp, #0
 8016112:	4603      	mov	r3, r0
 8016114:	71fb      	strb	r3, [r7, #7]
 8016116:	460b      	mov	r3, r1
 8016118:	71bb      	strb	r3, [r7, #6]
 801611a:	4613      	mov	r3, r2
 801611c:	717b      	strb	r3, [r7, #5]
    lv_color_t ret;
    ret.red = r;
 801611e:	79fb      	ldrb	r3, [r7, #7]
 8016120:	72bb      	strb	r3, [r7, #10]
    ret.green = g;
 8016122:	79bb      	ldrb	r3, [r7, #6]
 8016124:	727b      	strb	r3, [r7, #9]
    ret.blue = b;
 8016126:	797b      	ldrb	r3, [r7, #5]
 8016128:	723b      	strb	r3, [r7, #8]
    return ret;
 801612a:	f107 030c 	add.w	r3, r7, #12
 801612e:	f107 0208 	add.w	r2, r7, #8
 8016132:	6812      	ldr	r2, [r2, #0]
 8016134:	4611      	mov	r1, r2
 8016136:	8019      	strh	r1, [r3, #0]
 8016138:	3302      	adds	r3, #2
 801613a:	0c12      	lsrs	r2, r2, #16
 801613c:	701a      	strb	r2, [r3, #0]
 801613e:	2300      	movs	r3, #0
 8016140:	7b3a      	ldrb	r2, [r7, #12]
 8016142:	f362 0307 	bfi	r3, r2, #0, #8
 8016146:	7b7a      	ldrb	r2, [r7, #13]
 8016148:	f362 230f 	bfi	r3, r2, #8, #8
 801614c:	7bba      	ldrb	r2, [r7, #14]
 801614e:	f362 4317 	bfi	r3, r2, #16, #8
}
 8016152:	4618      	mov	r0, r3
 8016154:	3714      	adds	r7, #20
 8016156:	46bd      	mov	sp, r7
 8016158:	f85d 7b04 	ldr.w	r7, [sp], #4
 801615c:	4770      	bx	lr

0801615e <allocate_item>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static lv_grad_t * allocate_item(const lv_grad_dsc_t * g, int32_t w, int32_t h)
{
 801615e:	b580      	push	{r7, lr}
 8016160:	b088      	sub	sp, #32
 8016162:	af00      	add	r7, sp, #0
 8016164:	60f8      	str	r0, [r7, #12]
 8016166:	60b9      	str	r1, [r7, #8]
 8016168:	607a      	str	r2, [r7, #4]
    int32_t size = g->dir == LV_GRAD_DIR_HOR ? w : h;
 801616a:	68fb      	ldr	r3, [r7, #12]
 801616c:	7adb      	ldrb	r3, [r3, #11]
 801616e:	f003 0307 	and.w	r3, r3, #7
 8016172:	b2db      	uxtb	r3, r3
 8016174:	2b02      	cmp	r3, #2
 8016176:	d101      	bne.n	801617c <allocate_item+0x1e>
 8016178:	68bb      	ldr	r3, [r7, #8]
 801617a:	e000      	b.n	801617e <allocate_item+0x20>
 801617c:	687b      	ldr	r3, [r7, #4]
 801617e:	61fb      	str	r3, [r7, #28]

    size_t req_size = ALIGN(sizeof(lv_grad_t)) + ALIGN(size * sizeof(lv_color_t)) + ALIGN(size * sizeof(lv_opa_t));
 8016180:	69fb      	ldr	r3, [r7, #28]
 8016182:	1c5a      	adds	r2, r3, #1
 8016184:	4613      	mov	r3, r2
 8016186:	005b      	lsls	r3, r3, #1
 8016188:	4413      	add	r3, r2
 801618a:	f023 0203 	bic.w	r2, r3, #3
 801618e:	69fb      	ldr	r3, [r7, #28]
 8016190:	3303      	adds	r3, #3
 8016192:	f023 0303 	bic.w	r3, r3, #3
 8016196:	4413      	add	r3, r2
 8016198:	330c      	adds	r3, #12
 801619a:	61bb      	str	r3, [r7, #24]
    lv_grad_t * item  = lv_malloc(req_size);
 801619c:	69b8      	ldr	r0, [r7, #24]
 801619e:	f00f fe13 	bl	8025dc8 <lv_malloc>
 80161a2:	6178      	str	r0, [r7, #20]
    LV_ASSERT_MALLOC(item);
 80161a4:	697b      	ldr	r3, [r7, #20]
 80161a6:	2b00      	cmp	r3, #0
 80161a8:	d101      	bne.n	80161ae <allocate_item+0x50>
 80161aa:	bf00      	nop
 80161ac:	e7fd      	b.n	80161aa <allocate_item+0x4c>
    if(item == NULL) return NULL;
 80161ae:	697b      	ldr	r3, [r7, #20]
 80161b0:	2b00      	cmp	r3, #0
 80161b2:	d101      	bne.n	80161b8 <allocate_item+0x5a>
 80161b4:	2300      	movs	r3, #0
 80161b6:	e016      	b.n	80161e6 <allocate_item+0x88>

    uint8_t * p = (uint8_t *)item;
 80161b8:	697b      	ldr	r3, [r7, #20]
 80161ba:	613b      	str	r3, [r7, #16]
    item->color_map = (lv_color_t *)(p + ALIGN(sizeof(*item)));
 80161bc:	693b      	ldr	r3, [r7, #16]
 80161be:	f103 020c 	add.w	r2, r3, #12
 80161c2:	697b      	ldr	r3, [r7, #20]
 80161c4:	601a      	str	r2, [r3, #0]
    item->opa_map = (lv_opa_t *)(p + ALIGN(sizeof(*item)) + ALIGN(size * sizeof(lv_color_t)));
 80161c6:	69fb      	ldr	r3, [r7, #28]
 80161c8:	1c5a      	adds	r2, r3, #1
 80161ca:	4613      	mov	r3, r2
 80161cc:	005b      	lsls	r3, r3, #1
 80161ce:	4413      	add	r3, r2
 80161d0:	f023 0303 	bic.w	r3, r3, #3
 80161d4:	330c      	adds	r3, #12
 80161d6:	693a      	ldr	r2, [r7, #16]
 80161d8:	441a      	add	r2, r3
 80161da:	697b      	ldr	r3, [r7, #20]
 80161dc:	605a      	str	r2, [r3, #4]
    item->size = size;
 80161de:	69fa      	ldr	r2, [r7, #28]
 80161e0:	697b      	ldr	r3, [r7, #20]
 80161e2:	609a      	str	r2, [r3, #8]
    return item;
 80161e4:	697b      	ldr	r3, [r7, #20]
}
 80161e6:	4618      	mov	r0, r3
 80161e8:	3720      	adds	r7, #32
 80161ea:	46bd      	mov	sp, r7
 80161ec:	bd80      	pop	{r7, pc}

080161ee <lv_gradient_get>:
/**********************
 *     FUNCTIONS
 **********************/

lv_grad_t * lv_gradient_get(const lv_grad_dsc_t * g, int32_t w, int32_t h)
{
 80161ee:	b590      	push	{r4, r7, lr}
 80161f0:	b089      	sub	sp, #36	@ 0x24
 80161f2:	af02      	add	r7, sp, #8
 80161f4:	60f8      	str	r0, [r7, #12]
 80161f6:	60b9      	str	r1, [r7, #8]
 80161f8:	607a      	str	r2, [r7, #4]
    /* No gradient, no cache */
    if(g->dir == LV_GRAD_DIR_NONE) return NULL;
 80161fa:	68fb      	ldr	r3, [r7, #12]
 80161fc:	7adb      	ldrb	r3, [r3, #11]
 80161fe:	f003 0307 	and.w	r3, r3, #7
 8016202:	b2db      	uxtb	r3, r3
 8016204:	2b00      	cmp	r3, #0
 8016206:	d101      	bne.n	801620c <lv_gradient_get+0x1e>
 8016208:	2300      	movs	r3, #0
 801620a:	e02c      	b.n	8016266 <lv_gradient_get+0x78>

    /* Step 1: Search cache for the given key */
    lv_grad_t * item = allocate_item(g, w, h);
 801620c:	687a      	ldr	r2, [r7, #4]
 801620e:	68b9      	ldr	r1, [r7, #8]
 8016210:	68f8      	ldr	r0, [r7, #12]
 8016212:	f7ff ffa4 	bl	801615e <allocate_item>
 8016216:	6138      	str	r0, [r7, #16]
    if(item == NULL) {
 8016218:	693b      	ldr	r3, [r7, #16]
 801621a:	2b00      	cmp	r3, #0
 801621c:	d101      	bne.n	8016222 <lv_gradient_get+0x34>
        LV_LOG_WARN("Failed to allocate item for the gradient");
        return item;
 801621e:	693b      	ldr	r3, [r7, #16]
 8016220:	e021      	b.n	8016266 <lv_gradient_get+0x78>
    }

    /* Step 3: Fill it with the gradient, as expected */
    uint32_t i;
    for(i = 0; i < item->size; i++) {
 8016222:	2300      	movs	r3, #0
 8016224:	617b      	str	r3, [r7, #20]
 8016226:	e018      	b.n	801625a <lv_gradient_get+0x6c>
        lv_gradient_color_calculate(g, item->size, i, &item->color_map[i], &item->opa_map[i]);
 8016228:	693b      	ldr	r3, [r7, #16]
 801622a:	689b      	ldr	r3, [r3, #8]
 801622c:	461c      	mov	r4, r3
 801622e:	6978      	ldr	r0, [r7, #20]
 8016230:	693b      	ldr	r3, [r7, #16]
 8016232:	6819      	ldr	r1, [r3, #0]
 8016234:	697a      	ldr	r2, [r7, #20]
 8016236:	4613      	mov	r3, r2
 8016238:	005b      	lsls	r3, r3, #1
 801623a:	4413      	add	r3, r2
 801623c:	4419      	add	r1, r3
 801623e:	693b      	ldr	r3, [r7, #16]
 8016240:	685a      	ldr	r2, [r3, #4]
 8016242:	697b      	ldr	r3, [r7, #20]
 8016244:	4413      	add	r3, r2
 8016246:	9300      	str	r3, [sp, #0]
 8016248:	460b      	mov	r3, r1
 801624a:	4602      	mov	r2, r0
 801624c:	4621      	mov	r1, r4
 801624e:	68f8      	ldr	r0, [r7, #12]
 8016250:	f000 f80d 	bl	801626e <lv_gradient_color_calculate>
    for(i = 0; i < item->size; i++) {
 8016254:	697b      	ldr	r3, [r7, #20]
 8016256:	3301      	adds	r3, #1
 8016258:	617b      	str	r3, [r7, #20]
 801625a:	693b      	ldr	r3, [r7, #16]
 801625c:	689b      	ldr	r3, [r3, #8]
 801625e:	697a      	ldr	r2, [r7, #20]
 8016260:	429a      	cmp	r2, r3
 8016262:	d3e1      	bcc.n	8016228 <lv_gradient_get+0x3a>
    }
    return item;
 8016264:	693b      	ldr	r3, [r7, #16]
}
 8016266:	4618      	mov	r0, r3
 8016268:	371c      	adds	r7, #28
 801626a:	46bd      	mov	sp, r7
 801626c:	bd90      	pop	{r4, r7, pc}

0801626e <lv_gradient_color_calculate>:

void LV_ATTRIBUTE_FAST_MEM lv_gradient_color_calculate(const lv_grad_dsc_t * dsc, int32_t range,
                                                       int32_t frac, lv_grad_color_t * color_out, lv_opa_t * opa_out)
{
 801626e:	b590      	push	{r4, r7, lr}
 8016270:	b08f      	sub	sp, #60	@ 0x3c
 8016272:	af00      	add	r7, sp, #0
 8016274:	60f8      	str	r0, [r7, #12]
 8016276:	60b9      	str	r1, [r7, #8]
 8016278:	607a      	str	r2, [r7, #4]
 801627a:	603b      	str	r3, [r7, #0]
    lv_grad_color_t tmp;
    /*Clip out-of-bounds first*/
    int32_t min = (dsc->stops[0].frac * range) >> 8;
 801627c:	68fb      	ldr	r3, [r7, #12]
 801627e:	791b      	ldrb	r3, [r3, #4]
 8016280:	461a      	mov	r2, r3
 8016282:	68bb      	ldr	r3, [r7, #8]
 8016284:	fb02 f303 	mul.w	r3, r2, r3
 8016288:	121b      	asrs	r3, r3, #8
 801628a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    if(frac <= min) {
 801628c:	687a      	ldr	r2, [r7, #4]
 801628e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016290:	429a      	cmp	r2, r3
 8016292:	dc13      	bgt.n	80162bc <lv_gradient_color_calculate+0x4e>
        GRAD_CONV(tmp, dsc->stops[0].color);
 8016294:	68fa      	ldr	r2, [r7, #12]
 8016296:	f107 0318 	add.w	r3, r7, #24
 801629a:	8811      	ldrh	r1, [r2, #0]
 801629c:	7892      	ldrb	r2, [r2, #2]
 801629e:	8019      	strh	r1, [r3, #0]
 80162a0:	709a      	strb	r2, [r3, #2]
        *color_out = tmp;
 80162a2:	683b      	ldr	r3, [r7, #0]
 80162a4:	461a      	mov	r2, r3
 80162a6:	f107 0318 	add.w	r3, r7, #24
 80162aa:	8819      	ldrh	r1, [r3, #0]
 80162ac:	789b      	ldrb	r3, [r3, #2]
 80162ae:	8011      	strh	r1, [r2, #0]
 80162b0:	7093      	strb	r3, [r2, #2]
        *opa_out = dsc->stops[0].opa;
 80162b2:	68fb      	ldr	r3, [r7, #12]
 80162b4:	78da      	ldrb	r2, [r3, #3]
 80162b6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80162b8:	701a      	strb	r2, [r3, #0]
        return;
 80162ba:	e118      	b.n	80164ee <lv_gradient_color_calculate+0x280>
    }

    int32_t max = (dsc->stops[dsc->stops_count - 1].frac * range) >> 8;
 80162bc:	68fb      	ldr	r3, [r7, #12]
 80162be:	7a9b      	ldrb	r3, [r3, #10]
 80162c0:	1e5a      	subs	r2, r3, #1
 80162c2:	68f9      	ldr	r1, [r7, #12]
 80162c4:	4613      	mov	r3, r2
 80162c6:	009b      	lsls	r3, r3, #2
 80162c8:	4413      	add	r3, r2
 80162ca:	440b      	add	r3, r1
 80162cc:	3304      	adds	r3, #4
 80162ce:	781b      	ldrb	r3, [r3, #0]
 80162d0:	461a      	mov	r2, r3
 80162d2:	68bb      	ldr	r3, [r7, #8]
 80162d4:	fb02 f303 	mul.w	r3, r2, r3
 80162d8:	121b      	asrs	r3, r3, #8
 80162da:	62bb      	str	r3, [r7, #40]	@ 0x28
    if(frac >= max) {
 80162dc:	687a      	ldr	r2, [r7, #4]
 80162de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80162e0:	429a      	cmp	r2, r3
 80162e2:	db22      	blt.n	801632a <lv_gradient_color_calculate+0xbc>
        GRAD_CONV(tmp, dsc->stops[dsc->stops_count - 1].color);
 80162e4:	68fb      	ldr	r3, [r7, #12]
 80162e6:	7a9b      	ldrb	r3, [r3, #10]
 80162e8:	1e5a      	subs	r2, r3, #1
 80162ea:	68f9      	ldr	r1, [r7, #12]
 80162ec:	4613      	mov	r3, r2
 80162ee:	009b      	lsls	r3, r3, #2
 80162f0:	4413      	add	r3, r2
 80162f2:	18ca      	adds	r2, r1, r3
 80162f4:	f107 0318 	add.w	r3, r7, #24
 80162f8:	8811      	ldrh	r1, [r2, #0]
 80162fa:	7892      	ldrb	r2, [r2, #2]
 80162fc:	8019      	strh	r1, [r3, #0]
 80162fe:	709a      	strb	r2, [r3, #2]
        *color_out = tmp;
 8016300:	683b      	ldr	r3, [r7, #0]
 8016302:	461a      	mov	r2, r3
 8016304:	f107 0318 	add.w	r3, r7, #24
 8016308:	8819      	ldrh	r1, [r3, #0]
 801630a:	789b      	ldrb	r3, [r3, #2]
 801630c:	8011      	strh	r1, [r2, #0]
 801630e:	7093      	strb	r3, [r2, #2]
        *opa_out = dsc->stops[dsc->stops_count - 1].opa;
 8016310:	68fb      	ldr	r3, [r7, #12]
 8016312:	7a9b      	ldrb	r3, [r3, #10]
 8016314:	1e5a      	subs	r2, r3, #1
 8016316:	68f9      	ldr	r1, [r7, #12]
 8016318:	4613      	mov	r3, r2
 801631a:	009b      	lsls	r3, r3, #2
 801631c:	4413      	add	r3, r2
 801631e:	440b      	add	r3, r1
 8016320:	3303      	adds	r3, #3
 8016322:	781a      	ldrb	r2, [r3, #0]
 8016324:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8016326:	701a      	strb	r2, [r3, #0]
        return;
 8016328:	e0e1      	b.n	80164ee <lv_gradient_color_calculate+0x280>
    }

    /*Find the 2 closest stop now*/
    int32_t d = 0;
 801632a:	2300      	movs	r3, #0
 801632c:	627b      	str	r3, [r7, #36]	@ 0x24
    int32_t found_i = 0;
 801632e:	2300      	movs	r3, #0
 8016330:	637b      	str	r3, [r7, #52]	@ 0x34
    for(uint8_t i = 1; i < dsc->stops_count; i++) {
 8016332:	2301      	movs	r3, #1
 8016334:	f887 3033 	strb.w	r3, [r7, #51]	@ 0x33
 8016338:	e01b      	b.n	8016372 <lv_gradient_color_calculate+0x104>
        int32_t cur = (dsc->stops[i].frac * range) >> 8;
 801633a:	f897 2033 	ldrb.w	r2, [r7, #51]	@ 0x33
 801633e:	68f9      	ldr	r1, [r7, #12]
 8016340:	4613      	mov	r3, r2
 8016342:	009b      	lsls	r3, r3, #2
 8016344:	4413      	add	r3, r2
 8016346:	440b      	add	r3, r1
 8016348:	3304      	adds	r3, #4
 801634a:	781b      	ldrb	r3, [r3, #0]
 801634c:	461a      	mov	r2, r3
 801634e:	68bb      	ldr	r3, [r7, #8]
 8016350:	fb02 f303 	mul.w	r3, r2, r3
 8016354:	121b      	asrs	r3, r3, #8
 8016356:	623b      	str	r3, [r7, #32]
        if(frac <= cur) {
 8016358:	687a      	ldr	r2, [r7, #4]
 801635a:	6a3b      	ldr	r3, [r7, #32]
 801635c:	429a      	cmp	r2, r3
 801635e:	dc03      	bgt.n	8016368 <lv_gradient_color_calculate+0xfa>
            found_i = i;
 8016360:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 8016364:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8016366:	e00a      	b.n	801637e <lv_gradient_color_calculate+0x110>
    for(uint8_t i = 1; i < dsc->stops_count; i++) {
 8016368:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 801636c:	3301      	adds	r3, #1
 801636e:	f887 3033 	strb.w	r3, [r7, #51]	@ 0x33
 8016372:	68fb      	ldr	r3, [r7, #12]
 8016374:	7a9b      	ldrb	r3, [r3, #10]
 8016376:	f897 2033 	ldrb.w	r2, [r7, #51]	@ 0x33
 801637a:	429a      	cmp	r2, r3
 801637c:	d3dd      	bcc.n	801633a <lv_gradient_color_calculate+0xcc>
        }
    }

    LV_ASSERT(found_i != 0);
 801637e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8016380:	2b00      	cmp	r3, #0
 8016382:	d101      	bne.n	8016388 <lv_gradient_color_calculate+0x11a>
 8016384:	bf00      	nop
 8016386:	e7fd      	b.n	8016384 <lv_gradient_color_calculate+0x116>

    lv_color_t one, two;
    one = dsc->stops[found_i - 1].color;
 8016388:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801638a:	1e5a      	subs	r2, r3, #1
 801638c:	68f9      	ldr	r1, [r7, #12]
 801638e:	4613      	mov	r3, r2
 8016390:	009b      	lsls	r3, r3, #2
 8016392:	4413      	add	r3, r2
 8016394:	18ca      	adds	r2, r1, r3
 8016396:	f107 0314 	add.w	r3, r7, #20
 801639a:	8811      	ldrh	r1, [r2, #0]
 801639c:	7892      	ldrb	r2, [r2, #2]
 801639e:	8019      	strh	r1, [r3, #0]
 80163a0:	709a      	strb	r2, [r3, #2]
    two = dsc->stops[found_i].color;
 80163a2:	68f9      	ldr	r1, [r7, #12]
 80163a4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80163a6:	4613      	mov	r3, r2
 80163a8:	009b      	lsls	r3, r3, #2
 80163aa:	4413      	add	r3, r2
 80163ac:	18ca      	adds	r2, r1, r3
 80163ae:	f107 0310 	add.w	r3, r7, #16
 80163b2:	8811      	ldrh	r1, [r2, #0]
 80163b4:	7892      	ldrb	r2, [r2, #2]
 80163b6:	8019      	strh	r1, [r3, #0]
 80163b8:	709a      	strb	r2, [r3, #2]
    min = (dsc->stops[found_i - 1].frac * range) >> 8;
 80163ba:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80163bc:	1e5a      	subs	r2, r3, #1
 80163be:	68f9      	ldr	r1, [r7, #12]
 80163c0:	4613      	mov	r3, r2
 80163c2:	009b      	lsls	r3, r3, #2
 80163c4:	4413      	add	r3, r2
 80163c6:	440b      	add	r3, r1
 80163c8:	3304      	adds	r3, #4
 80163ca:	781b      	ldrb	r3, [r3, #0]
 80163cc:	461a      	mov	r2, r3
 80163ce:	68bb      	ldr	r3, [r7, #8]
 80163d0:	fb02 f303 	mul.w	r3, r2, r3
 80163d4:	121b      	asrs	r3, r3, #8
 80163d6:	62fb      	str	r3, [r7, #44]	@ 0x2c
    max = (dsc->stops[found_i].frac * range) >> 8;
 80163d8:	68f9      	ldr	r1, [r7, #12]
 80163da:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80163dc:	4613      	mov	r3, r2
 80163de:	009b      	lsls	r3, r3, #2
 80163e0:	4413      	add	r3, r2
 80163e2:	440b      	add	r3, r1
 80163e4:	3304      	adds	r3, #4
 80163e6:	781b      	ldrb	r3, [r3, #0]
 80163e8:	461a      	mov	r2, r3
 80163ea:	68bb      	ldr	r3, [r7, #8]
 80163ec:	fb02 f303 	mul.w	r3, r2, r3
 80163f0:	121b      	asrs	r3, r3, #8
 80163f2:	62bb      	str	r3, [r7, #40]	@ 0x28
    d = max - min;
 80163f4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80163f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80163f8:	1ad3      	subs	r3, r2, r3
 80163fa:	627b      	str	r3, [r7, #36]	@ 0x24

    /*Then interpolate*/
    frac -= min;
 80163fc:	687a      	ldr	r2, [r7, #4]
 80163fe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8016400:	1ad3      	subs	r3, r2, r3
 8016402:	607b      	str	r3, [r7, #4]
    lv_opa_t mix = (frac * 255) / d;
 8016404:	687a      	ldr	r2, [r7, #4]
 8016406:	4613      	mov	r3, r2
 8016408:	021b      	lsls	r3, r3, #8
 801640a:	1a9a      	subs	r2, r3, r2
 801640c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801640e:	fb92 f3f3 	sdiv	r3, r2, r3
 8016412:	77fb      	strb	r3, [r7, #31]
    lv_opa_t imix = 255 - mix;
 8016414:	7ffb      	ldrb	r3, [r7, #31]
 8016416:	43db      	mvns	r3, r3
 8016418:	77bb      	strb	r3, [r7, #30]

    *color_out = GRAD_CM(LV_UDIV255(two.red * mix   + one.red * imix),
 801641a:	7cbb      	ldrb	r3, [r7, #18]
 801641c:	461a      	mov	r2, r3
 801641e:	7ffb      	ldrb	r3, [r7, #31]
 8016420:	fb03 f202 	mul.w	r2, r3, r2
 8016424:	7dbb      	ldrb	r3, [r7, #22]
 8016426:	4619      	mov	r1, r3
 8016428:	7fbb      	ldrb	r3, [r7, #30]
 801642a:	fb01 f303 	mul.w	r3, r1, r3
 801642e:	4413      	add	r3, r2
 8016430:	461a      	mov	r2, r3
 8016432:	4613      	mov	r3, r2
 8016434:	021b      	lsls	r3, r3, #8
 8016436:	4413      	add	r3, r2
 8016438:	01db      	lsls	r3, r3, #7
 801643a:	4413      	add	r3, r2
 801643c:	0ddb      	lsrs	r3, r3, #23
 801643e:	b2d8      	uxtb	r0, r3
 8016440:	7c7b      	ldrb	r3, [r7, #17]
 8016442:	461a      	mov	r2, r3
 8016444:	7ffb      	ldrb	r3, [r7, #31]
 8016446:	fb03 f202 	mul.w	r2, r3, r2
 801644a:	7d7b      	ldrb	r3, [r7, #21]
 801644c:	4619      	mov	r1, r3
 801644e:	7fbb      	ldrb	r3, [r7, #30]
 8016450:	fb01 f303 	mul.w	r3, r1, r3
 8016454:	4413      	add	r3, r2
 8016456:	461a      	mov	r2, r3
 8016458:	4613      	mov	r3, r2
 801645a:	021b      	lsls	r3, r3, #8
 801645c:	4413      	add	r3, r2
 801645e:	01db      	lsls	r3, r3, #7
 8016460:	4413      	add	r3, r2
 8016462:	0ddb      	lsrs	r3, r3, #23
 8016464:	b2d9      	uxtb	r1, r3
 8016466:	7c3b      	ldrb	r3, [r7, #16]
 8016468:	461a      	mov	r2, r3
 801646a:	7ffb      	ldrb	r3, [r7, #31]
 801646c:	fb03 f202 	mul.w	r2, r3, r2
 8016470:	7d3b      	ldrb	r3, [r7, #20]
 8016472:	461c      	mov	r4, r3
 8016474:	7fbb      	ldrb	r3, [r7, #30]
 8016476:	fb04 f303 	mul.w	r3, r4, r3
 801647a:	4413      	add	r3, r2
 801647c:	461a      	mov	r2, r3
 801647e:	4613      	mov	r3, r2
 8016480:	021b      	lsls	r3, r3, #8
 8016482:	4413      	add	r3, r2
 8016484:	01db      	lsls	r3, r3, #7
 8016486:	4413      	add	r3, r2
 8016488:	0ddb      	lsrs	r3, r3, #23
 801648a:	b2db      	uxtb	r3, r3
 801648c:	461a      	mov	r2, r3
 801648e:	f7ff fe3d 	bl	801610c <lv_color_make>
 8016492:	4602      	mov	r2, r0
 8016494:	683b      	ldr	r3, [r7, #0]
 8016496:	4611      	mov	r1, r2
 8016498:	7019      	strb	r1, [r3, #0]
 801649a:	f3c2 2107 	ubfx	r1, r2, #8, #8
 801649e:	7059      	strb	r1, [r3, #1]
 80164a0:	f3c2 4207 	ubfx	r2, r2, #16, #8
 80164a4:	709a      	strb	r2, [r3, #2]
                         LV_UDIV255(two.green * mix + one.green * imix),
                         LV_UDIV255(two.blue * mix  + one.blue * imix));

    *opa_out = LV_UDIV255(dsc->stops[found_i].opa * mix   + dsc->stops[found_i - 1].opa * imix);
 80164a6:	68f9      	ldr	r1, [r7, #12]
 80164a8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80164aa:	4613      	mov	r3, r2
 80164ac:	009b      	lsls	r3, r3, #2
 80164ae:	4413      	add	r3, r2
 80164b0:	440b      	add	r3, r1
 80164b2:	3303      	adds	r3, #3
 80164b4:	781b      	ldrb	r3, [r3, #0]
 80164b6:	461a      	mov	r2, r3
 80164b8:	7ffb      	ldrb	r3, [r7, #31]
 80164ba:	fb03 f102 	mul.w	r1, r3, r2
 80164be:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80164c0:	1e5a      	subs	r2, r3, #1
 80164c2:	68f8      	ldr	r0, [r7, #12]
 80164c4:	4613      	mov	r3, r2
 80164c6:	009b      	lsls	r3, r3, #2
 80164c8:	4413      	add	r3, r2
 80164ca:	4403      	add	r3, r0
 80164cc:	3303      	adds	r3, #3
 80164ce:	781b      	ldrb	r3, [r3, #0]
 80164d0:	461a      	mov	r2, r3
 80164d2:	7fbb      	ldrb	r3, [r7, #30]
 80164d4:	fb02 f303 	mul.w	r3, r2, r3
 80164d8:	440b      	add	r3, r1
 80164da:	461a      	mov	r2, r3
 80164dc:	4613      	mov	r3, r2
 80164de:	021b      	lsls	r3, r3, #8
 80164e0:	4413      	add	r3, r2
 80164e2:	01db      	lsls	r3, r3, #7
 80164e4:	4413      	add	r3, r2
 80164e6:	0ddb      	lsrs	r3, r3, #23
 80164e8:	b2da      	uxtb	r2, r3
 80164ea:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80164ec:	701a      	strb	r2, [r3, #0]
}
 80164ee:	373c      	adds	r7, #60	@ 0x3c
 80164f0:	46bd      	mov	sp, r7
 80164f2:	bd90      	pop	{r4, r7, pc}

080164f4 <lv_gradient_cleanup>:

void lv_gradient_cleanup(lv_grad_t * grad)
{
 80164f4:	b580      	push	{r7, lr}
 80164f6:	b082      	sub	sp, #8
 80164f8:	af00      	add	r7, sp, #0
 80164fa:	6078      	str	r0, [r7, #4]
    lv_free(grad);
 80164fc:	6878      	ldr	r0, [r7, #4]
 80164fe:	f00f fc9b 	bl	8025e38 <lv_free>
}
 8016502:	bf00      	nop
 8016504:	3708      	adds	r7, #8
 8016506:	46bd      	mov	sp, r7
 8016508:	bd80      	pop	{r7, pc}

0801650a <lv_area_copy>:
{
 801650a:	b480      	push	{r7}
 801650c:	b083      	sub	sp, #12
 801650e:	af00      	add	r7, sp, #0
 8016510:	6078      	str	r0, [r7, #4]
 8016512:	6039      	str	r1, [r7, #0]
    dest->x1 = src->x1;
 8016514:	683b      	ldr	r3, [r7, #0]
 8016516:	681a      	ldr	r2, [r3, #0]
 8016518:	687b      	ldr	r3, [r7, #4]
 801651a:	601a      	str	r2, [r3, #0]
    dest->y1 = src->y1;
 801651c:	683b      	ldr	r3, [r7, #0]
 801651e:	685a      	ldr	r2, [r3, #4]
 8016520:	687b      	ldr	r3, [r7, #4]
 8016522:	605a      	str	r2, [r3, #4]
    dest->x2 = src->x2;
 8016524:	683b      	ldr	r3, [r7, #0]
 8016526:	689a      	ldr	r2, [r3, #8]
 8016528:	687b      	ldr	r3, [r7, #4]
 801652a:	609a      	str	r2, [r3, #8]
    dest->y2 = src->y2;
 801652c:	683b      	ldr	r3, [r7, #0]
 801652e:	68da      	ldr	r2, [r3, #12]
 8016530:	687b      	ldr	r3, [r7, #4]
 8016532:	60da      	str	r2, [r3, #12]
}
 8016534:	bf00      	nop
 8016536:	370c      	adds	r7, #12
 8016538:	46bd      	mov	sp, r7
 801653a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801653e:	4770      	bx	lr

08016540 <lv_area_get_width>:
{
 8016540:	b480      	push	{r7}
 8016542:	b083      	sub	sp, #12
 8016544:	af00      	add	r7, sp, #0
 8016546:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 8016548:	687b      	ldr	r3, [r7, #4]
 801654a:	689a      	ldr	r2, [r3, #8]
 801654c:	687b      	ldr	r3, [r7, #4]
 801654e:	681b      	ldr	r3, [r3, #0]
 8016550:	1ad3      	subs	r3, r2, r3
 8016552:	3301      	adds	r3, #1
}
 8016554:	4618      	mov	r0, r3
 8016556:	370c      	adds	r7, #12
 8016558:	46bd      	mov	sp, r7
 801655a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801655e:	4770      	bx	lr

08016560 <lv_area_get_height>:
{
 8016560:	b480      	push	{r7}
 8016562:	b083      	sub	sp, #12
 8016564:	af00      	add	r7, sp, #0
 8016566:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 8016568:	687b      	ldr	r3, [r7, #4]
 801656a:	68da      	ldr	r2, [r3, #12]
 801656c:	687b      	ldr	r3, [r7, #4]
 801656e:	685b      	ldr	r3, [r3, #4]
 8016570:	1ad3      	subs	r3, r2, r3
 8016572:	3301      	adds	r3, #1
}
 8016574:	4618      	mov	r0, r3
 8016576:	370c      	adds	r7, #12
 8016578:	46bd      	mov	sp, r7
 801657a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801657e:	4770      	bx	lr

08016580 <lv_color_format_get_size>:
 * Get the pixel size of a color format in bytes
 * @param src_cf    a color format (`LV_COLOR_FORMAT_...`)
 * @return          the pixel size in bytes
 */
static inline uint8_t lv_color_format_get_size(lv_color_format_t cf)
{
 8016580:	b580      	push	{r7, lr}
 8016582:	b082      	sub	sp, #8
 8016584:	af00      	add	r7, sp, #0
 8016586:	4603      	mov	r3, r0
 8016588:	71fb      	strb	r3, [r7, #7]
    return (lv_color_format_get_bpp(cf) + 7) >> 3;
 801658a:	79fb      	ldrb	r3, [r7, #7]
 801658c:	4618      	mov	r0, r3
 801658e:	f00b ffbb 	bl	8022508 <lv_color_format_get_bpp>
 8016592:	4603      	mov	r3, r0
 8016594:	3307      	adds	r3, #7
 8016596:	10db      	asrs	r3, r3, #3
 8016598:	b2db      	uxtb	r3, r3
}
 801659a:	4618      	mov	r0, r3
 801659c:	3708      	adds	r7, #8
 801659e:	46bd      	mov	sp, r7
 80165a0:	bd80      	pop	{r7, pc}

080165a2 <lv_memzero>:
{
 80165a2:	b580      	push	{r7, lr}
 80165a4:	b082      	sub	sp, #8
 80165a6:	af00      	add	r7, sp, #0
 80165a8:	6078      	str	r0, [r7, #4]
 80165aa:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 80165ac:	683a      	ldr	r2, [r7, #0]
 80165ae:	2100      	movs	r1, #0
 80165b0:	6878      	ldr	r0, [r7, #4]
 80165b2:	f00e fc36 	bl	8024e22 <lv_memset>
}
 80165b6:	bf00      	nop
 80165b8:	3708      	adds	r7, #8
 80165ba:	46bd      	mov	sp, r7
 80165bc:	bd80      	pop	{r7, pc}

080165be <lv_draw_sw_layer>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_sw_layer(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc, const lv_area_t * coords)
{
 80165be:	b580      	push	{r7, lr}
 80165c0:	b0a0      	sub	sp, #128	@ 0x80
 80165c2:	af00      	add	r7, sp, #0
 80165c4:	60f8      	str	r0, [r7, #12]
 80165c6:	60b9      	str	r1, [r7, #8]
 80165c8:	607a      	str	r2, [r7, #4]
    lv_layer_t * layer_to_draw = (lv_layer_t *)draw_dsc->src;
 80165ca:	68bb      	ldr	r3, [r7, #8]
 80165cc:	69db      	ldr	r3, [r3, #28]
 80165ce:	67fb      	str	r3, [r7, #124]	@ 0x7c

    /*It can happen that nothing was draw on a layer and therefore its buffer is not allocated.
     *In this case just return. */
    if(layer_to_draw->draw_buf == NULL) return;
 80165d0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80165d2:	681b      	ldr	r3, [r3, #0]
 80165d4:	2b00      	cmp	r3, #0
 80165d6:	d012      	beq.n	80165fe <lv_draw_sw_layer+0x40>

    lv_draw_image_dsc_t new_draw_dsc = *draw_dsc;
 80165d8:	68ba      	ldr	r2, [r7, #8]
 80165da:	f107 0314 	add.w	r3, r7, #20
 80165de:	4611      	mov	r1, r2
 80165e0:	2268      	movs	r2, #104	@ 0x68
 80165e2:	4618      	mov	r0, r3
 80165e4:	f011 faaa 	bl	8027b3c <memcpy>
    new_draw_dsc.src = layer_to_draw->draw_buf;
 80165e8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 80165ea:	681b      	ldr	r3, [r3, #0]
 80165ec:	633b      	str	r3, [r7, #48]	@ 0x30
    lv_draw_sw_image(draw_unit, &new_draw_dsc, coords);
 80165ee:	f107 0314 	add.w	r3, r7, #20
 80165f2:	687a      	ldr	r2, [r7, #4]
 80165f4:	4619      	mov	r1, r3
 80165f6:	68f8      	ldr	r0, [r7, #12]
 80165f8:	f000 f806 	bl	8016608 <lv_draw_sw_image>
 80165fc:	e000      	b.n	8016600 <lv_draw_sw_layer+0x42>
    if(layer_to_draw->draw_buf == NULL) return;
 80165fe:	bf00      	nop
    lv_draw_label_dsc_init(&label_dsc);
    label_dsc.color = lv_color_white();
    label_dsc.text = buf;
    lv_draw_sw_label(draw_unit, &label_dsc, &txt_area);
#endif
}
 8016600:	3780      	adds	r7, #128	@ 0x80
 8016602:	46bd      	mov	sp, r7
 8016604:	bd80      	pop	{r7, pc}
	...

08016608 <lv_draw_sw_image>:

void lv_draw_sw_image(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                      const lv_area_t * coords)
{
 8016608:	b580      	push	{r7, lr}
 801660a:	b084      	sub	sp, #16
 801660c:	af00      	add	r7, sp, #0
 801660e:	60f8      	str	r0, [r7, #12]
 8016610:	60b9      	str	r1, [r7, #8]
 8016612:	607a      	str	r2, [r7, #4]
    if(!draw_dsc->tile) {
 8016614:	68bb      	ldr	r3, [r7, #8]
 8016616:	f893 304d 	ldrb.w	r3, [r3, #77]	@ 0x4d
 801661a:	f003 0320 	and.w	r3, r3, #32
 801661e:	b2db      	uxtb	r3, r3
 8016620:	2b00      	cmp	r3, #0
 8016622:	d106      	bne.n	8016632 <lv_draw_sw_image+0x2a>
        _lv_draw_image_normal_helper(draw_unit, draw_dsc, coords, img_draw_core);
 8016624:	4b08      	ldr	r3, [pc, #32]	@ (8016648 <lv_draw_sw_image+0x40>)
 8016626:	687a      	ldr	r2, [r7, #4]
 8016628:	68b9      	ldr	r1, [r7, #8]
 801662a:	68f8      	ldr	r0, [r7, #12]
 801662c:	f7f6 f8a6 	bl	800c77c <_lv_draw_image_normal_helper>
    }
    else {
        _lv_draw_image_tiled_helper(draw_unit, draw_dsc, coords, img_draw_core);
    }
}
 8016630:	e005      	b.n	801663e <lv_draw_sw_image+0x36>
        _lv_draw_image_tiled_helper(draw_unit, draw_dsc, coords, img_draw_core);
 8016632:	4b05      	ldr	r3, [pc, #20]	@ (8016648 <lv_draw_sw_image+0x40>)
 8016634:	687a      	ldr	r2, [r7, #4]
 8016636:	68b9      	ldr	r1, [r7, #8]
 8016638:	68f8      	ldr	r0, [r7, #12]
 801663a:	f7f6 f927 	bl	800c88c <_lv_draw_image_tiled_helper>
}
 801663e:	bf00      	nop
 8016640:	3710      	adds	r7, #16
 8016642:	46bd      	mov	sp, r7
 8016644:	bd80      	pop	{r7, pc}
 8016646:	bf00      	nop
 8016648:	0801664d 	.word	0x0801664d

0801664c <img_draw_core>:
 **********************/

static void img_draw_core(lv_draw_unit_t * draw_unit, const lv_draw_image_dsc_t * draw_dsc,
                          const lv_image_decoder_dsc_t * decoder_dsc, lv_draw_image_sup_t * sup,
                          const lv_area_t * img_coords, const lv_area_t * clipped_img_area)
{
 801664c:	b590      	push	{r4, r7, lr}
 801664e:	b0d1      	sub	sp, #324	@ 0x144
 8016650:	af06      	add	r7, sp, #24
 8016652:	f507 7494 	add.w	r4, r7, #296	@ 0x128
 8016656:	f5a4 748e 	sub.w	r4, r4, #284	@ 0x11c
 801665a:	6020      	str	r0, [r4, #0]
 801665c:	f507 7094 	add.w	r0, r7, #296	@ 0x128
 8016660:	f5a0 7090 	sub.w	r0, r0, #288	@ 0x120
 8016664:	6001      	str	r1, [r0, #0]
 8016666:	f507 7194 	add.w	r1, r7, #296	@ 0x128
 801666a:	f5a1 7192 	sub.w	r1, r1, #292	@ 0x124
 801666e:	600a      	str	r2, [r1, #0]
 8016670:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 8016674:	f5a2 7294 	sub.w	r2, r2, #296	@ 0x128
 8016678:	6013      	str	r3, [r2, #0]
    bool transformed = draw_dsc->rotation != 0 || draw_dsc->scale_x != LV_SCALE_NONE ||
 801667a:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 801667e:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016682:	681b      	ldr	r3, [r3, #0]
 8016684:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
                       draw_dsc->scale_y != LV_SCALE_NONE ? true : false;
 8016686:	2b00      	cmp	r3, #0
 8016688:	d111      	bne.n	80166ae <img_draw_core+0x62>
    bool transformed = draw_dsc->rotation != 0 || draw_dsc->scale_x != LV_SCALE_NONE ||
 801668a:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 801668e:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016692:	681b      	ldr	r3, [r3, #0]
 8016694:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8016696:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 801669a:	d108      	bne.n	80166ae <img_draw_core+0x62>
                       draw_dsc->scale_y != LV_SCALE_NONE ? true : false;
 801669c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80166a0:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80166a4:	681b      	ldr	r3, [r3, #0]
 80166a6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80166a8:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80166ac:	d001      	beq.n	80166b2 <img_draw_core+0x66>
 80166ae:	2301      	movs	r3, #1
 80166b0:	e000      	b.n	80166b4 <img_draw_core+0x68>
 80166b2:	2300      	movs	r3, #0
    bool transformed = draw_dsc->rotation != 0 || draw_dsc->scale_x != LV_SCALE_NONE ||
 80166b4:	f887 30ef 	strb.w	r3, [r7, #239]	@ 0xef
 80166b8:	f897 30ef 	ldrb.w	r3, [r7, #239]	@ 0xef
 80166bc:	f003 0301 	and.w	r3, r3, #1
 80166c0:	f887 30ef 	strb.w	r3, [r7, #239]	@ 0xef

    bool masked = draw_dsc->bitmap_mask_src != NULL;
 80166c4:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80166c8:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80166cc:	681b      	ldr	r3, [r3, #0]
 80166ce:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80166d0:	2b00      	cmp	r3, #0
 80166d2:	bf14      	ite	ne
 80166d4:	2301      	movne	r3, #1
 80166d6:	2300      	moveq	r3, #0
 80166d8:	f887 30ee 	strb.w	r3, [r7, #238]	@ 0xee

    lv_draw_sw_blend_dsc_t blend_dsc;
    const lv_draw_buf_t * decoded = decoder_dsc->decoded;
 80166dc:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80166e0:	f5a3 7392 	sub.w	r3, r3, #292	@ 0x124
 80166e4:	681b      	ldr	r3, [r3, #0]
 80166e6:	69db      	ldr	r3, [r3, #28]
 80166e8:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
    const uint8_t * src_buf = decoded->data;
 80166ec:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80166f0:	691b      	ldr	r3, [r3, #16]
 80166f2:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    const lv_image_header_t * header = &decoded->header;
 80166f6:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 80166fa:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    uint32_t img_stride = decoded->header.stride;
 80166fe:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 8016702:	891b      	ldrh	r3, [r3, #8]
 8016704:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    lv_color_format_t cf = decoded->header.cf;
 8016708:	f8d7 30e8 	ldr.w	r3, [r7, #232]	@ 0xe8
 801670c:	785b      	ldrb	r3, [r3, #1]
 801670e:	f887 30db 	strb.w	r3, [r7, #219]	@ 0xdb

    lv_memzero(&blend_dsc, sizeof(lv_draw_sw_blend_dsc_t));
 8016712:	f107 0368 	add.w	r3, r7, #104	@ 0x68
 8016716:	212c      	movs	r1, #44	@ 0x2c
 8016718:	4618      	mov	r0, r3
 801671a:	f7ff ff42 	bl	80165a2 <lv_memzero>
    blend_dsc.opa = draw_dsc->opa;
 801671e:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016722:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016726:	681b      	ldr	r3, [r3, #0]
 8016728:	f893 304c 	ldrb.w	r3, [r3, #76]	@ 0x4c
 801672c:	f887 307c 	strb.w	r3, [r7, #124]	@ 0x7c
    blend_dsc.blend_mode = draw_dsc->blend_mode;
 8016730:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016734:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016738:	681b      	ldr	r3, [r3, #0]
 801673a:	f893 304d 	ldrb.w	r3, [r3, #77]	@ 0x4d
 801673e:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8016742:	b2db      	uxtb	r3, r3
 8016744:	f887 3090 	strb.w	r3, [r7, #144]	@ 0x90
    blend_dsc.src_stride = img_stride;
 8016748:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801674c:	673b      	str	r3, [r7, #112]	@ 0x70

    if(!transformed && !masked && cf == LV_COLOR_FORMAT_A8) {
 801674e:	f897 30ef 	ldrb.w	r3, [r7, #239]	@ 0xef
 8016752:	f083 0301 	eor.w	r3, r3, #1
 8016756:	b2db      	uxtb	r3, r3
 8016758:	2b00      	cmp	r3, #0
 801675a:	d04a      	beq.n	80167f2 <img_draw_core+0x1a6>
 801675c:	f897 30ee 	ldrb.w	r3, [r7, #238]	@ 0xee
 8016760:	f083 0301 	eor.w	r3, r3, #1
 8016764:	b2db      	uxtb	r3, r3
 8016766:	2b00      	cmp	r3, #0
 8016768:	d043      	beq.n	80167f2 <img_draw_core+0x1a6>
 801676a:	f897 30db 	ldrb.w	r3, [r7, #219]	@ 0xdb
 801676e:	2b0e      	cmp	r3, #14
 8016770:	d13f      	bne.n	80167f2 <img_draw_core+0x1a6>
        lv_area_t clipped_coords;
        if(!_lv_area_intersect(&clipped_coords, img_coords, draw_unit->clip_area)) return;
 8016772:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016776:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 801677a:	681b      	ldr	r3, [r3, #0]
 801677c:	689a      	ldr	r2, [r3, #8]
 801677e:	f107 0358 	add.w	r3, r7, #88	@ 0x58
 8016782:	f8d7 1138 	ldr.w	r1, [r7, #312]	@ 0x138
 8016786:	4618      	mov	r0, r3
 8016788:	f00b f8de 	bl	8021948 <_lv_area_intersect>
 801678c:	4603      	mov	r3, r0
 801678e:	f083 0301 	eor.w	r3, r3, #1
 8016792:	b2db      	uxtb	r3, r3
 8016794:	2b00      	cmp	r3, #0
 8016796:	f040 8558 	bne.w	801724a <img_draw_core+0xbfe>

        blend_dsc.mask_buf = (lv_opa_t *)src_buf;
 801679a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 801679e:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        blend_dsc.mask_area = img_coords;
 80167a2:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80167a6:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
        blend_dsc.mask_stride = img_stride;
 80167aa:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80167ae:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
        blend_dsc.src_buf = NULL;
 80167b2:	2300      	movs	r3, #0
 80167b4:	66fb      	str	r3, [r7, #108]	@ 0x6c
        blend_dsc.color = draw_dsc->recolor;
 80167b6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80167ba:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80167be:	681a      	ldr	r2, [r3, #0]
 80167c0:	f107 037d 	add.w	r3, r7, #125	@ 0x7d
 80167c4:	3248      	adds	r2, #72	@ 0x48
 80167c6:	8811      	ldrh	r1, [r2, #0]
 80167c8:	7892      	ldrb	r2, [r2, #2]
 80167ca:	8019      	strh	r1, [r3, #0]
 80167cc:	709a      	strb	r2, [r3, #2]
        blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 80167ce:	2302      	movs	r3, #2
 80167d0:	f887 3084 	strb.w	r3, [r7, #132]	@ 0x84

        blend_dsc.blend_area = img_coords;
 80167d4:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80167d8:	66bb      	str	r3, [r7, #104]	@ 0x68
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 80167da:	f107 0268 	add.w	r2, r7, #104	@ 0x68
 80167de:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80167e2:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80167e6:	4611      	mov	r1, r2
 80167e8:	6818      	ldr	r0, [r3, #0]
 80167ea:	f7f8 f893 	bl	800e914 <lv_draw_sw_blend>
    if(!transformed && !masked && cf == LV_COLOR_FORMAT_A8) {
 80167ee:	f000 bd2c 	b.w	801724a <img_draw_core+0xbfe>
    }
    else if(!transformed && !masked && cf == LV_COLOR_FORMAT_RGB565A8 && draw_dsc->recolor_opa <= LV_OPA_MIN) {
 80167f2:	f897 30ef 	ldrb.w	r3, [r7, #239]	@ 0xef
 80167f6:	f083 0301 	eor.w	r3, r3, #1
 80167fa:	b2db      	uxtb	r3, r3
 80167fc:	2b00      	cmp	r3, #0
 80167fe:	d05b      	beq.n	80168b8 <img_draw_core+0x26c>
 8016800:	f897 30ee 	ldrb.w	r3, [r7, #238]	@ 0xee
 8016804:	f083 0301 	eor.w	r3, r3, #1
 8016808:	b2db      	uxtb	r3, r3
 801680a:	2b00      	cmp	r3, #0
 801680c:	d054      	beq.n	80168b8 <img_draw_core+0x26c>
 801680e:	f897 30db 	ldrb.w	r3, [r7, #219]	@ 0xdb
 8016812:	2b14      	cmp	r3, #20
 8016814:	d150      	bne.n	80168b8 <img_draw_core+0x26c>
 8016816:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 801681a:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801681e:	681b      	ldr	r3, [r3, #0]
 8016820:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 8016824:	2b02      	cmp	r3, #2
 8016826:	d847      	bhi.n	80168b8 <img_draw_core+0x26c>
        int32_t src_h = lv_area_get_height(img_coords);
 8016828:	f8d7 0138 	ldr.w	r0, [r7, #312]	@ 0x138
 801682c:	f7ff fe98 	bl	8016560 <lv_area_get_height>
 8016830:	f8c7 00d4 	str.w	r0, [r7, #212]	@ 0xd4
        int32_t src_w = lv_area_get_width(img_coords);
 8016834:	f8d7 0138 	ldr.w	r0, [r7, #312]	@ 0x138
 8016838:	f7ff fe82 	bl	8016540 <lv_area_get_width>
 801683c:	f8c7 00d0 	str.w	r0, [r7, #208]	@ 0xd0
        blend_dsc.src_area = img_coords;
 8016840:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8016844:	67bb      	str	r3, [r7, #120]	@ 0x78
        blend_dsc.src_buf = src_buf;
 8016846:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 801684a:	66fb      	str	r3, [r7, #108]	@ 0x6c
        blend_dsc.mask_buf = (lv_opa_t *)src_buf;
 801684c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8016850:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        blend_dsc.mask_buf += img_stride * src_w / header->w * src_h;
 8016854:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 8016858:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801685c:	f8d7 10dc 	ldr.w	r1, [r7, #220]	@ 0xdc
 8016860:	fb01 f303 	mul.w	r3, r1, r3
 8016864:	f8d7 10e0 	ldr.w	r1, [r7, #224]	@ 0xe0
 8016868:	8889      	ldrh	r1, [r1, #4]
 801686a:	fbb3 f3f1 	udiv	r3, r3, r1
 801686e:	f8d7 10d4 	ldr.w	r1, [r7, #212]	@ 0xd4
 8016872:	fb01 f303 	mul.w	r3, r1, r3
 8016876:	4413      	add	r3, r2
 8016878:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        /**
         * Note, for RGB565A8, lacking of stride parameter, we always use
         * always half of RGB map stride as alpha map stride. The image should
         * be generated in this way too.
         */
        blend_dsc.mask_stride = img_stride / 2;
 801687c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8016880:	085b      	lsrs	r3, r3, #1
 8016882:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
        blend_dsc.blend_area = img_coords;
 8016886:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801688a:	66bb      	str	r3, [r7, #104]	@ 0x68
        blend_dsc.mask_area = img_coords;
 801688c:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8016890:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
        blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8016894:	2302      	movs	r3, #2
 8016896:	f887 3084 	strb.w	r3, [r7, #132]	@ 0x84
        blend_dsc.src_color_format = LV_COLOR_FORMAT_RGB565;
 801689a:	2312      	movs	r3, #18
 801689c:	f887 3074 	strb.w	r3, [r7, #116]	@ 0x74
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 80168a0:	f107 0268 	add.w	r2, r7, #104	@ 0x68
 80168a4:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80168a8:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80168ac:	4611      	mov	r1, r2
 80168ae:	6818      	ldr	r0, [r3, #0]
 80168b0:	f7f8 f830 	bl	800e914 <lv_draw_sw_blend>
    else if(!transformed && !masked && cf == LV_COLOR_FORMAT_RGB565A8 && draw_dsc->recolor_opa <= LV_OPA_MIN) {
 80168b4:	f000 bcc9 	b.w	801724a <img_draw_core+0xbfe>
    }
    /*The simplest case just copy the pixels into the draw_buf. Blending will convert the colors if needed*/
    else if(!transformed && !masked && draw_dsc->recolor_opa <= LV_OPA_MIN) {
 80168b8:	f897 30ef 	ldrb.w	r3, [r7, #239]	@ 0xef
 80168bc:	f083 0301 	eor.w	r3, r3, #1
 80168c0:	b2db      	uxtb	r3, r3
 80168c2:	2b00      	cmp	r3, #0
 80168c4:	d028      	beq.n	8016918 <img_draw_core+0x2cc>
 80168c6:	f897 30ee 	ldrb.w	r3, [r7, #238]	@ 0xee
 80168ca:	f083 0301 	eor.w	r3, r3, #1
 80168ce:	b2db      	uxtb	r3, r3
 80168d0:	2b00      	cmp	r3, #0
 80168d2:	d021      	beq.n	8016918 <img_draw_core+0x2cc>
 80168d4:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80168d8:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80168dc:	681b      	ldr	r3, [r3, #0]
 80168de:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 80168e2:	2b02      	cmp	r3, #2
 80168e4:	d818      	bhi.n	8016918 <img_draw_core+0x2cc>
        blend_dsc.src_area = img_coords;
 80168e6:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80168ea:	67bb      	str	r3, [r7, #120]	@ 0x78
        blend_dsc.src_buf = src_buf;
 80168ec:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80168f0:	66fb      	str	r3, [r7, #108]	@ 0x6c
        blend_dsc.blend_area = img_coords;
 80168f2:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 80168f6:	66bb      	str	r3, [r7, #104]	@ 0x68
        blend_dsc.src_color_format = cf;
 80168f8:	f897 30db 	ldrb.w	r3, [r7, #219]	@ 0xdb
 80168fc:	f887 3074 	strb.w	r3, [r7, #116]	@ 0x74
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 8016900:	f107 0268 	add.w	r2, r7, #104	@ 0x68
 8016904:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016908:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 801690c:	4611      	mov	r1, r2
 801690e:	6818      	ldr	r0, [r3, #0]
 8016910:	f7f8 f800 	bl	800e914 <lv_draw_sw_blend>
 8016914:	f000 bc99 	b.w	801724a <img_draw_core+0xbfe>
    }
    /*Handle masked RGB565, RGB888, XRGB888, or ARGB8888 images*/
    else if(!transformed && masked && draw_dsc->recolor_opa <= LV_OPA_MIN) {
 8016918:	f897 30ef 	ldrb.w	r3, [r7, #239]	@ 0xef
 801691c:	f083 0301 	eor.w	r3, r3, #1
 8016920:	b2db      	uxtb	r3, r3
 8016922:	2b00      	cmp	r3, #0
 8016924:	d077      	beq.n	8016a16 <img_draw_core+0x3ca>
 8016926:	f897 30ee 	ldrb.w	r3, [r7, #238]	@ 0xee
 801692a:	2b00      	cmp	r3, #0
 801692c:	d073      	beq.n	8016a16 <img_draw_core+0x3ca>
 801692e:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016932:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016936:	681b      	ldr	r3, [r3, #0]
 8016938:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 801693c:	2b02      	cmp	r3, #2
 801693e:	d86a      	bhi.n	8016a16 <img_draw_core+0x3ca>
        blend_dsc.src_area = img_coords;
 8016940:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8016944:	67bb      	str	r3, [r7, #120]	@ 0x78
        blend_dsc.src_buf = src_buf;
 8016946:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 801694a:	66fb      	str	r3, [r7, #108]	@ 0x6c
        blend_dsc.blend_area = img_coords;
 801694c:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8016950:	66bb      	str	r3, [r7, #104]	@ 0x68
        blend_dsc.src_color_format = cf;
 8016952:	f897 30db 	ldrb.w	r3, [r7, #219]	@ 0xdb
 8016956:	f887 3074 	strb.w	r3, [r7, #116]	@ 0x74
        blend_dsc.mask_buf = draw_dsc->bitmap_mask_src->data;
 801695a:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 801695e:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016962:	681b      	ldr	r3, [r3, #0]
 8016964:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8016966:	691b      	ldr	r3, [r3, #16]
 8016968:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        blend_dsc.mask_stride = draw_dsc->bitmap_mask_src->header.stride;
 801696c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016970:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016974:	681b      	ldr	r3, [r3, #0]
 8016976:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8016978:	891b      	ldrh	r3, [r3, #8]
 801697a:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

        const lv_area_t * original_area;
        if(lv_area_get_width(&draw_dsc->original_area) < 0) original_area = img_coords;
 801697e:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016982:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016986:	681b      	ldr	r3, [r3, #0]
 8016988:	3354      	adds	r3, #84	@ 0x54
 801698a:	4618      	mov	r0, r3
 801698c:	f7ff fdd8 	bl	8016540 <lv_area_get_width>
 8016990:	4603      	mov	r3, r0
 8016992:	2b00      	cmp	r3, #0
 8016994:	da04      	bge.n	80169a0 <img_draw_core+0x354>
 8016996:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 801699a:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124
 801699e:	e007      	b.n	80169b0 <img_draw_core+0x364>
        else original_area = &draw_dsc->original_area;
 80169a0:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80169a4:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80169a8:	681b      	ldr	r3, [r3, #0]
 80169aa:	3354      	adds	r3, #84	@ 0x54
 80169ac:	f8c7 3124 	str.w	r3, [r7, #292]	@ 0x124

        lv_area_t a = {0, 0, draw_dsc->bitmap_mask_src->header.w - 1, draw_dsc->bitmap_mask_src->header.h - 1};
 80169b0:	2300      	movs	r3, #0
 80169b2:	64bb      	str	r3, [r7, #72]	@ 0x48
 80169b4:	2300      	movs	r3, #0
 80169b6:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80169b8:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80169bc:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80169c0:	681b      	ldr	r3, [r3, #0]
 80169c2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80169c4:	889b      	ldrh	r3, [r3, #4]
 80169c6:	3b01      	subs	r3, #1
 80169c8:	653b      	str	r3, [r7, #80]	@ 0x50
 80169ca:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80169ce:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 80169d2:	681b      	ldr	r3, [r3, #0]
 80169d4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80169d6:	88db      	ldrh	r3, [r3, #6]
 80169d8:	3b01      	subs	r3, #1
 80169da:	657b      	str	r3, [r7, #84]	@ 0x54
        lv_area_align(original_area, &a, LV_ALIGN_CENTER, 0, 0);
 80169dc:	f107 0148 	add.w	r1, r7, #72	@ 0x48
 80169e0:	2300      	movs	r3, #0
 80169e2:	9300      	str	r3, [sp, #0]
 80169e4:	2300      	movs	r3, #0
 80169e6:	2209      	movs	r2, #9
 80169e8:	f8d7 0124 	ldr.w	r0, [r7, #292]	@ 0x124
 80169ec:	f00b f9e2 	bl	8021db4 <lv_area_align>
        blend_dsc.mask_area = &a;
 80169f0:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 80169f4:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
        blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 80169f8:	2302      	movs	r3, #2
 80169fa:	f887 3084 	strb.w	r3, [r7, #132]	@ 0x84
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 80169fe:	f107 0268 	add.w	r2, r7, #104	@ 0x68
 8016a02:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016a06:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 8016a0a:	4611      	mov	r1, r2
 8016a0c:	6818      	ldr	r0, [r3, #0]
 8016a0e:	f7f7 ff81 	bl	800e914 <lv_draw_sw_blend>
    else if(!transformed && masked && draw_dsc->recolor_opa <= LV_OPA_MIN) {
 8016a12:	f000 bc1a 	b.w	801724a <img_draw_core+0xbfe>
                                                  clipped_img_area, /* blend area */
                                                  draw_unit,        /* target buffer, buffer width, buffer height, buffer stride */
                                                  draw_dsc)) {      /* opa, recolour_opa and colour */
        /*In the other cases every pixel need to be checked one-by-one*/

        lv_area_t blend_area = *clipped_img_area;
 8016a16:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 8016a1a:	f107 0438 	add.w	r4, r7, #56	@ 0x38
 8016a1e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8016a20:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        blend_dsc.blend_area = &blend_area;
 8016a24:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8016a28:	66bb      	str	r3, [r7, #104]	@ 0x68

        int32_t src_w = lv_area_get_width(img_coords);
 8016a2a:	f8d7 0138 	ldr.w	r0, [r7, #312]	@ 0x138
 8016a2e:	f7ff fd87 	bl	8016540 <lv_area_get_width>
 8016a32:	f8c7 00cc 	str.w	r0, [r7, #204]	@ 0xcc
        int32_t src_h = lv_area_get_height(img_coords);
 8016a36:	f8d7 0138 	ldr.w	r0, [r7, #312]	@ 0x138
 8016a3a:	f7ff fd91 	bl	8016560 <lv_area_get_height>
 8016a3e:	f8c7 00c8 	str.w	r0, [r7, #200]	@ 0xc8
        int32_t blend_w = lv_area_get_width(&blend_area);
 8016a42:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8016a46:	4618      	mov	r0, r3
 8016a48:	f7ff fd7a 	bl	8016540 <lv_area_get_width>
 8016a4c:	f8c7 00c4 	str.w	r0, [r7, #196]	@ 0xc4
        int32_t blend_h = lv_area_get_height(&blend_area);
 8016a50:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8016a54:	4618      	mov	r0, r3
 8016a56:	f7ff fd83 	bl	8016560 <lv_area_get_height>
 8016a5a:	f8c7 00c0 	str.w	r0, [r7, #192]	@ 0xc0

        lv_color_format_t cf_final = cf;
 8016a5e:	f897 30db 	ldrb.w	r3, [r7, #219]	@ 0xdb
 8016a62:	f887 3123 	strb.w	r3, [r7, #291]	@ 0x123
        if(transformed) {
 8016a66:	f897 30ef 	ldrb.w	r3, [r7, #239]	@ 0xef
 8016a6a:	2b00      	cmp	r3, #0
 8016a6c:	d012      	beq.n	8016a94 <img_draw_core+0x448>
            if(cf == LV_COLOR_FORMAT_RGB888 || cf == LV_COLOR_FORMAT_XRGB8888) cf_final = LV_COLOR_FORMAT_ARGB8888;
 8016a6e:	f897 30db 	ldrb.w	r3, [r7, #219]	@ 0xdb
 8016a72:	2b0f      	cmp	r3, #15
 8016a74:	d003      	beq.n	8016a7e <img_draw_core+0x432>
 8016a76:	f897 30db 	ldrb.w	r3, [r7, #219]	@ 0xdb
 8016a7a:	2b11      	cmp	r3, #17
 8016a7c:	d103      	bne.n	8016a86 <img_draw_core+0x43a>
 8016a7e:	2310      	movs	r3, #16
 8016a80:	f887 3123 	strb.w	r3, [r7, #291]	@ 0x123
 8016a84:	e006      	b.n	8016a94 <img_draw_core+0x448>
            else if(cf == LV_COLOR_FORMAT_RGB565) cf_final = LV_COLOR_FORMAT_RGB565A8;
 8016a86:	f897 30db 	ldrb.w	r3, [r7, #219]	@ 0xdb
 8016a8a:	2b12      	cmp	r3, #18
 8016a8c:	d102      	bne.n	8016a94 <img_draw_core+0x448>
 8016a8e:	2314      	movs	r3, #20
 8016a90:	f887 3123 	strb.w	r3, [r7, #291]	@ 0x123
        }

        uint8_t * tmp_buf;
        uint32_t px_size = lv_color_format_get_size(cf_final);
 8016a94:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8016a98:	4618      	mov	r0, r3
 8016a9a:	f7ff fd71 	bl	8016580 <lv_color_format_get_size>
 8016a9e:	4603      	mov	r3, r0
 8016aa0:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
        int32_t buf_h;
        if(cf_final == LV_COLOR_FORMAT_RGB565A8) {
 8016aa4:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8016aa8:	2b14      	cmp	r3, #20
 8016aaa:	d138      	bne.n	8016b1e <img_draw_core+0x4d2>
            uint32_t buf_stride = blend_w * 3;
 8016aac:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 8016ab0:	4613      	mov	r3, r2
 8016ab2:	005b      	lsls	r3, r3, #1
 8016ab4:	4413      	add	r3, r2
 8016ab6:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
            buf_h = MAX_BUF_SIZE / buf_stride;
 8016aba:	f7f4 faf7 	bl	800b0ac <_lv_refr_get_disp_refreshing>
 8016abe:	4603      	mov	r3, r0
 8016ac0:	4618      	mov	r0, r3
 8016ac2:	f7f4 fb31 	bl	800b128 <lv_display_get_horizontal_resolution>
 8016ac6:	4604      	mov	r4, r0
 8016ac8:	f7f4 faf0 	bl	800b0ac <_lv_refr_get_disp_refreshing>
 8016acc:	4603      	mov	r3, r0
 8016ace:	4618      	mov	r0, r3
 8016ad0:	f7f4 fb83 	bl	800b1da <lv_display_get_color_format>
 8016ad4:	4603      	mov	r3, r0
 8016ad6:	4618      	mov	r0, r3
 8016ad8:	f7ff fd52 	bl	8016580 <lv_color_format_get_size>
 8016adc:	4603      	mov	r3, r0
 8016ade:	fb04 f303 	mul.w	r3, r4, r3
 8016ae2:	009b      	lsls	r3, r3, #2
 8016ae4:	461a      	mov	r2, r3
 8016ae6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8016aea:	fbb2 f3f3 	udiv	r3, r2, r3
 8016aee:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
            if(buf_h > blend_h) buf_h = blend_h;
 8016af2:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8016af6:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8016afa:	429a      	cmp	r2, r3
 8016afc:	dd03      	ble.n	8016b06 <img_draw_core+0x4ba>
 8016afe:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8016b02:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
            tmp_buf = lv_malloc(buf_stride * buf_h);
 8016b06:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8016b0a:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 8016b0e:	fb02 f303 	mul.w	r3, r2, r3
 8016b12:	4618      	mov	r0, r3
 8016b14:	f00f f958 	bl	8025dc8 <lv_malloc>
 8016b18:	f8c7 011c 	str.w	r0, [r7, #284]	@ 0x11c
 8016b1c:	e03d      	b.n	8016b9a <img_draw_core+0x54e>
        }
        else {
            uint32_t buf_stride = blend_w * lv_color_format_get_size(cf_final);
 8016b1e:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8016b22:	4618      	mov	r0, r3
 8016b24:	f7ff fd2c 	bl	8016580 <lv_color_format_get_size>
 8016b28:	4603      	mov	r3, r0
 8016b2a:	461a      	mov	r2, r3
 8016b2c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8016b30:	fb02 f303 	mul.w	r3, r2, r3
 8016b34:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
            buf_h = MAX_BUF_SIZE / buf_stride;
 8016b38:	f7f4 fab8 	bl	800b0ac <_lv_refr_get_disp_refreshing>
 8016b3c:	4603      	mov	r3, r0
 8016b3e:	4618      	mov	r0, r3
 8016b40:	f7f4 faf2 	bl	800b128 <lv_display_get_horizontal_resolution>
 8016b44:	4604      	mov	r4, r0
 8016b46:	f7f4 fab1 	bl	800b0ac <_lv_refr_get_disp_refreshing>
 8016b4a:	4603      	mov	r3, r0
 8016b4c:	4618      	mov	r0, r3
 8016b4e:	f7f4 fb44 	bl	800b1da <lv_display_get_color_format>
 8016b52:	4603      	mov	r3, r0
 8016b54:	4618      	mov	r0, r3
 8016b56:	f7ff fd13 	bl	8016580 <lv_color_format_get_size>
 8016b5a:	4603      	mov	r3, r0
 8016b5c:	fb04 f303 	mul.w	r3, r4, r3
 8016b60:	009b      	lsls	r3, r3, #2
 8016b62:	461a      	mov	r2, r3
 8016b64:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8016b68:	fbb2 f3f3 	udiv	r3, r2, r3
 8016b6c:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
            if(buf_h > blend_h) buf_h = blend_h;
 8016b70:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8016b74:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8016b78:	429a      	cmp	r2, r3
 8016b7a:	dd03      	ble.n	8016b84 <img_draw_core+0x538>
 8016b7c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 8016b80:	f8c7 3118 	str.w	r3, [r7, #280]	@ 0x118
            tmp_buf = lv_malloc(buf_stride * buf_h);
 8016b84:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8016b88:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8016b8c:	fb02 f303 	mul.w	r3, r2, r3
 8016b90:	4618      	mov	r0, r3
 8016b92:	f00f f919 	bl	8025dc8 <lv_malloc>
 8016b96:	f8c7 011c 	str.w	r0, [r7, #284]	@ 0x11c
        }
        LV_ASSERT_MALLOC(tmp_buf);
 8016b9a:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8016b9e:	2b00      	cmp	r3, #0
 8016ba0:	d101      	bne.n	8016ba6 <img_draw_core+0x55a>
 8016ba2:	bf00      	nop
 8016ba4:	e7fd      	b.n	8016ba2 <img_draw_core+0x556>

        blend_dsc.src_buf = tmp_buf;
 8016ba6:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8016baa:	66fb      	str	r3, [r7, #108]	@ 0x6c
        blend_dsc.src_color_format = cf_final;
 8016bac:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8016bb0:	f887 3074 	strb.w	r3, [r7, #116]	@ 0x74
        int32_t y_last = blend_area.y2;
 8016bb4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8016bb6:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
        blend_area.y2 = blend_area.y1 + buf_h - 1;
 8016bba:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8016bbc:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 8016bc0:	4413      	add	r3, r2
 8016bc2:	3b01      	subs	r3, #1
 8016bc4:	647b      	str	r3, [r7, #68]	@ 0x44

        blend_dsc.src_area = &blend_area;
 8016bc6:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8016bca:	67bb      	str	r3, [r7, #120]	@ 0x78
        if(cf_final == LV_COLOR_FORMAT_RGB565A8) {
 8016bcc:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8016bd0:	2b14      	cmp	r3, #20
 8016bd2:	d11f      	bne.n	8016c14 <img_draw_core+0x5c8>
            /*RGB565A8 images will blended as RGB565 + mask
             *Therefore the stride can be different. */
            blend_dsc.src_stride = blend_w * 2;
 8016bd4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8016bd8:	005b      	lsls	r3, r3, #1
 8016bda:	673b      	str	r3, [r7, #112]	@ 0x70
            blend_dsc.mask_buf =  tmp_buf + blend_w * 2 * buf_h;
 8016bdc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8016be0:	f8d7 2118 	ldr.w	r2, [r7, #280]	@ 0x118
 8016be4:	fb02 f303 	mul.w	r3, r2, r3
 8016be8:	005b      	lsls	r3, r3, #1
 8016bea:	461a      	mov	r2, r3
 8016bec:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8016bf0:	4413      	add	r3, r2
 8016bf2:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
            blend_dsc.mask_stride = blend_w;
 8016bf6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8016bfa:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
            blend_dsc.mask_area = &blend_area;
 8016bfe:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8016c02:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
            blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8016c06:	2302      	movs	r3, #2
 8016c08:	f887 3084 	strb.w	r3, [r7, #132]	@ 0x84
            blend_dsc.src_color_format = LV_COLOR_FORMAT_RGB565;
 8016c0c:	2312      	movs	r3, #18
 8016c0e:	f887 3074 	strb.w	r3, [r7, #116]	@ 0x74
 8016c12:	e310      	b.n	8017236 <img_draw_core+0xbea>
        }
        else if(cf_final == LV_COLOR_FORMAT_A8) {
 8016c14:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8016c18:	2b0e      	cmp	r3, #14
 8016c1a:	d11c      	bne.n	8016c56 <img_draw_core+0x60a>
            blend_dsc.mask_buf = blend_dsc.src_buf;
 8016c1c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8016c1e:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
            blend_dsc.mask_stride = blend_w;
 8016c22:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8016c26:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
            blend_dsc.mask_area = &blend_area;
 8016c2a:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8016c2e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
            blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8016c32:	2302      	movs	r3, #2
 8016c34:	f887 3084 	strb.w	r3, [r7, #132]	@ 0x84
            blend_dsc.color = draw_dsc->recolor;
 8016c38:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016c3c:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016c40:	681a      	ldr	r2, [r3, #0]
 8016c42:	f107 037d 	add.w	r3, r7, #125	@ 0x7d
 8016c46:	3248      	adds	r2, #72	@ 0x48
 8016c48:	8811      	ldrh	r1, [r2, #0]
 8016c4a:	7892      	ldrb	r2, [r2, #2]
 8016c4c:	8019      	strh	r1, [r3, #0]
 8016c4e:	709a      	strb	r2, [r3, #2]
            blend_dsc.src_buf = NULL;
 8016c50:	2300      	movs	r3, #0
 8016c52:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8016c54:	e2ef      	b.n	8017236 <img_draw_core+0xbea>
        }
        else {
            blend_dsc.src_stride = blend_w * lv_color_format_get_size(cf_final);
 8016c56:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8016c5a:	4618      	mov	r0, r3
 8016c5c:	f7ff fc90 	bl	8016580 <lv_color_format_get_size>
 8016c60:	4603      	mov	r3, r0
 8016c62:	461a      	mov	r2, r3
 8016c64:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8016c68:	fb02 f303 	mul.w	r3, r2, r3
 8016c6c:	673b      	str	r3, [r7, #112]	@ 0x70
        }

        while(blend_area.y1 <= y_last) {
 8016c6e:	e2e2      	b.n	8017236 <img_draw_core+0xbea>
            /*Apply transformations if any or separate the channels*/
            lv_area_t relative_area;
            lv_area_copy(&relative_area, &blend_area);
 8016c70:	f107 0238 	add.w	r2, r7, #56	@ 0x38
 8016c74:	f107 0328 	add.w	r3, r7, #40	@ 0x28
 8016c78:	4611      	mov	r1, r2
 8016c7a:	4618      	mov	r0, r3
 8016c7c:	f7ff fc45 	bl	801650a <lv_area_copy>
            lv_area_move(&relative_area, -img_coords->x1, -img_coords->y1);
 8016c80:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8016c84:	681b      	ldr	r3, [r3, #0]
 8016c86:	4259      	negs	r1, r3
 8016c88:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8016c8c:	685b      	ldr	r3, [r3, #4]
 8016c8e:	425a      	negs	r2, r3
 8016c90:	f107 0328 	add.w	r3, r7, #40	@ 0x28
 8016c94:	4618      	mov	r0, r3
 8016c96:	f00a fe33 	bl	8021900 <lv_area_move>
            if(transformed) {
 8016c9a:	f897 30ef 	ldrb.w	r3, [r7, #239]	@ 0xef
 8016c9e:	2b00      	cmp	r3, #0
 8016ca0:	d025      	beq.n	8016cee <img_draw_core+0x6a2>
                lv_draw_sw_transform(draw_unit, &relative_area, src_buf, src_w, src_h, img_stride,
 8016ca2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8016ca6:	f107 0128 	add.w	r1, r7, #40	@ 0x28
 8016caa:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 8016cae:	f5a2 708e 	sub.w	r0, r2, #284	@ 0x11c
 8016cb2:	f8d7 211c 	ldr.w	r2, [r7, #284]	@ 0x11c
 8016cb6:	9205      	str	r2, [sp, #20]
 8016cb8:	f897 20db 	ldrb.w	r2, [r7, #219]	@ 0xdb
 8016cbc:	9204      	str	r2, [sp, #16]
 8016cbe:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 8016cc2:	f5a2 7294 	sub.w	r2, r2, #296	@ 0x128
 8016cc6:	6812      	ldr	r2, [r2, #0]
 8016cc8:	9203      	str	r2, [sp, #12]
 8016cca:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 8016cce:	f5a2 7290 	sub.w	r2, r2, #288	@ 0x120
 8016cd2:	6812      	ldr	r2, [r2, #0]
 8016cd4:	9202      	str	r2, [sp, #8]
 8016cd6:	9301      	str	r3, [sp, #4]
 8016cd8:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8016cdc:	9300      	str	r3, [sp, #0]
 8016cde:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8016ce2:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8016ce6:	6800      	ldr	r0, [r0, #0]
 8016ce8:	f003 fc5c 	bl	801a5a4 <lv_draw_sw_transform>
 8016cec:	e0e8      	b.n	8016ec0 <img_draw_core+0x874>
                                     draw_dsc, sup, cf, tmp_buf);
            }
            else if(draw_dsc->recolor_opa >= LV_OPA_MIN) {
 8016cee:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016cf2:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016cf6:	681b      	ldr	r3, [r3, #0]
 8016cf8:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 8016cfc:	2b01      	cmp	r3, #1
 8016cfe:	f240 80df 	bls.w	8016ec0 <img_draw_core+0x874>
                int32_t h = lv_area_get_height(&relative_area);
 8016d02:	f107 0328 	add.w	r3, r7, #40	@ 0x28
 8016d06:	4618      	mov	r0, r3
 8016d08:	f7ff fc2a 	bl	8016560 <lv_area_get_height>
 8016d0c:	f8c7 00ac 	str.w	r0, [r7, #172]	@ 0xac
                if(cf_final == LV_COLOR_FORMAT_RGB565A8) {
 8016d10:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8016d14:	2b14      	cmp	r3, #20
 8016d16:	f040 8083 	bne.w	8016e20 <img_draw_core+0x7d4>
                    uint32_t stride_px = img_stride / 2;
 8016d1a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8016d1e:	085b      	lsrs	r3, r3, #1
 8016d20:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
                    const uint8_t * rgb_src_buf = src_buf + stride_px * 2 * relative_area.y1 + relative_area.x1 * 2;
 8016d24:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016d28:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 8016d2c:	685b      	ldr	r3, [r3, #4]
 8016d2e:	461a      	mov	r2, r3
 8016d30:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8016d34:	fb02 f303 	mul.w	r3, r2, r3
 8016d38:	005b      	lsls	r3, r3, #1
 8016d3a:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 8016d3e:	f5a2 7280 	sub.w	r2, r2, #256	@ 0x100
 8016d42:	6812      	ldr	r2, [r2, #0]
 8016d44:	0052      	lsls	r2, r2, #1
 8016d46:	4413      	add	r3, r2
 8016d48:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8016d4c:	4413      	add	r3, r2
 8016d4e:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
                    const uint8_t * a_src_buf = src_buf + stride_px * 2 * src_h + stride_px * relative_area.y1 +
 8016d52:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8016d56:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8016d5a:	fb02 f303 	mul.w	r3, r2, r3
 8016d5e:	005a      	lsls	r2, r3, #1
 8016d60:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016d64:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 8016d68:	685b      	ldr	r3, [r3, #4]
 8016d6a:	4619      	mov	r1, r3
 8016d6c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8016d70:	fb01 f303 	mul.w	r3, r1, r3
 8016d74:	4413      	add	r3, r2
                                                relative_area.x1;
 8016d76:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 8016d7a:	f5a2 7280 	sub.w	r2, r2, #256	@ 0x100
 8016d7e:	6812      	ldr	r2, [r2, #0]
                    const uint8_t * a_src_buf = src_buf + stride_px * 2 * src_h + stride_px * relative_area.y1 +
 8016d80:	4413      	add	r3, r2
 8016d82:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8016d86:	4413      	add	r3, r2
 8016d88:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
                    uint8_t * rgb_dest_buf = tmp_buf;
 8016d8c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8016d90:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
                    uint8_t * a_dest_buf = (uint8_t *)blend_dsc.mask_buf;
 8016d94:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8016d98:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
                    int32_t i;
                    for(i = 0; i < h; i++) {
 8016d9c:	2300      	movs	r3, #0
 8016d9e:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
 8016da2:	e036      	b.n	8016e12 <img_draw_core+0x7c6>
                        lv_memcpy(rgb_dest_buf, rgb_src_buf, blend_w * 2);
 8016da4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8016da8:	005b      	lsls	r3, r3, #1
 8016daa:	461a      	mov	r2, r3
 8016dac:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 8016db0:	f8d7 010c 	ldr.w	r0, [r7, #268]	@ 0x10c
 8016db4:	f00d fe18 	bl	80249e8 <lv_memcpy>
                        lv_memcpy(a_dest_buf, a_src_buf, blend_w);
 8016db8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8016dbc:	461a      	mov	r2, r3
 8016dbe:	f8d7 1110 	ldr.w	r1, [r7, #272]	@ 0x110
 8016dc2:	f8d7 0108 	ldr.w	r0, [r7, #264]	@ 0x108
 8016dc6:	f00d fe0f 	bl	80249e8 <lv_memcpy>
                        rgb_src_buf += stride_px * 2;
 8016dca:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8016dce:	005b      	lsls	r3, r3, #1
 8016dd0:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8016dd4:	4413      	add	r3, r2
 8016dd6:	f8c7 3114 	str.w	r3, [r7, #276]	@ 0x114
                        a_src_buf += stride_px;
 8016dda:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 8016dde:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8016de2:	4413      	add	r3, r2
 8016de4:	f8c7 3110 	str.w	r3, [r7, #272]	@ 0x110
                        rgb_dest_buf +=  blend_w * 2;
 8016de8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8016dec:	005b      	lsls	r3, r3, #1
 8016dee:	461a      	mov	r2, r3
 8016df0:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 8016df4:	4413      	add	r3, r2
 8016df6:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
                        a_dest_buf += blend_w;
 8016dfa:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8016dfe:	f8d7 2108 	ldr.w	r2, [r7, #264]	@ 0x108
 8016e02:	4413      	add	r3, r2
 8016e04:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
                    for(i = 0; i < h; i++) {
 8016e08:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8016e0c:	3301      	adds	r3, #1
 8016e0e:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
 8016e12:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 8016e16:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8016e1a:	429a      	cmp	r2, r3
 8016e1c:	dbc2      	blt.n	8016da4 <img_draw_core+0x758>
 8016e1e:	e04f      	b.n	8016ec0 <img_draw_core+0x874>
                    }
                }
                else if(cf_final != LV_COLOR_FORMAT_A8) {
 8016e20:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8016e24:	2b0e      	cmp	r3, #14
 8016e26:	d04b      	beq.n	8016ec0 <img_draw_core+0x874>
                    const uint8_t * src_buf_tmp = src_buf + img_stride * relative_area.y1 + relative_area.x1 * px_size;
 8016e28:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016e2c:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 8016e30:	685b      	ldr	r3, [r3, #4]
 8016e32:	461a      	mov	r2, r3
 8016e34:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8016e38:	fb03 f202 	mul.w	r2, r3, r2
 8016e3c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016e40:	f5a3 7380 	sub.w	r3, r3, #256	@ 0x100
 8016e44:	681b      	ldr	r3, [r3, #0]
 8016e46:	4619      	mov	r1, r3
 8016e48:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8016e4c:	fb01 f303 	mul.w	r3, r1, r3
 8016e50:	4413      	add	r3, r2
 8016e52:	f8d7 20e4 	ldr.w	r2, [r7, #228]	@ 0xe4
 8016e56:	4413      	add	r3, r2
 8016e58:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
                    uint8_t * dest_buf_tmp = tmp_buf;
 8016e5c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8016e60:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
                    int32_t i;
                    for(i = 0; i < h; i++) {
 8016e64:	2300      	movs	r3, #0
 8016e66:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 8016e6a:	e023      	b.n	8016eb4 <img_draw_core+0x868>
                        lv_memcpy(dest_buf_tmp, src_buf_tmp, blend_w * px_size);
 8016e6c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8016e70:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8016e74:	fb02 f303 	mul.w	r3, r2, r3
 8016e78:	461a      	mov	r2, r3
 8016e7a:	f8d7 1100 	ldr.w	r1, [r7, #256]	@ 0x100
 8016e7e:	f8d7 00fc 	ldr.w	r0, [r7, #252]	@ 0xfc
 8016e82:	f00d fdb1 	bl	80249e8 <lv_memcpy>
                        dest_buf_tmp += blend_w * px_size;
 8016e86:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8016e8a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8016e8e:	fb02 f303 	mul.w	r3, r2, r3
 8016e92:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 8016e96:	4413      	add	r3, r2
 8016e98:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
                        src_buf_tmp += img_stride;
 8016e9c:	f8d7 2100 	ldr.w	r2, [r7, #256]	@ 0x100
 8016ea0:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8016ea4:	4413      	add	r3, r2
 8016ea6:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
                    for(i = 0; i < h; i++) {
 8016eaa:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 8016eae:	3301      	adds	r3, #1
 8016eb0:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 8016eb4:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 8016eb8:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8016ebc:	429a      	cmp	r2, r3
 8016ebe:	dbd5      	blt.n	8016e6c <img_draw_core+0x820>
                    }
                }
            }

            /*Apply recolor*/
            if(draw_dsc->recolor_opa > LV_OPA_MIN) {
 8016ec0:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016ec4:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016ec8:	681b      	ldr	r3, [r3, #0]
 8016eca:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 8016ece:	2b02      	cmp	r3, #2
 8016ed0:	f240 8181 	bls.w	80171d6 <img_draw_core+0xb8a>
                lv_color_t color = draw_dsc->recolor;
 8016ed4:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016ed8:	f5a3 7182 	sub.w	r1, r3, #260	@ 0x104
 8016edc:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016ee0:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016ee4:	681a      	ldr	r2, [r3, #0]
 8016ee6:	460b      	mov	r3, r1
 8016ee8:	3248      	adds	r2, #72	@ 0x48
 8016eea:	6812      	ldr	r2, [r2, #0]
 8016eec:	4611      	mov	r1, r2
 8016eee:	8019      	strh	r1, [r3, #0]
 8016ef0:	3302      	adds	r3, #2
 8016ef2:	0c12      	lsrs	r2, r2, #16
 8016ef4:	701a      	strb	r2, [r3, #0]
                lv_opa_t mix = draw_dsc->recolor_opa;
 8016ef6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016efa:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 8016efe:	681b      	ldr	r3, [r3, #0]
 8016f00:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
 8016f04:	f887 30a7 	strb.w	r3, [r7, #167]	@ 0xa7
                lv_opa_t mix_inv = 255 - mix;
 8016f08:	f897 30a7 	ldrb.w	r3, [r7, #167]	@ 0xa7
 8016f0c:	43db      	mvns	r3, r3
 8016f0e:	f887 30a6 	strb.w	r3, [r7, #166]	@ 0xa6
                if(cf_final == LV_COLOR_FORMAT_RGB565A8 || cf_final == LV_COLOR_FORMAT_RGB565) {
 8016f12:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8016f16:	2b14      	cmp	r3, #20
 8016f18:	d004      	beq.n	8016f24 <img_draw_core+0x8d8>
 8016f1a:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8016f1e:	2b12      	cmp	r3, #18
 8016f20:	f040 80af 	bne.w	8017082 <img_draw_core+0xa36>
                    if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_RECOLOR(tmp_buf, blend_area, color, mix)) {
                        uint16_t c_mult[3];
                        c_mult[0] = (color.blue >> 3) * mix;
 8016f24:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016f28:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8016f2c:	781b      	ldrb	r3, [r3, #0]
 8016f2e:	08db      	lsrs	r3, r3, #3
 8016f30:	b2db      	uxtb	r3, r3
 8016f32:	461a      	mov	r2, r3
 8016f34:	f897 30a7 	ldrb.w	r3, [r7, #167]	@ 0xa7
 8016f38:	b29b      	uxth	r3, r3
 8016f3a:	fb12 f303 	smulbb	r3, r2, r3
 8016f3e:	b29a      	uxth	r2, r3
 8016f40:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016f44:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 8016f48:	801a      	strh	r2, [r3, #0]
                        c_mult[1] = (color.green >> 2) * mix;
 8016f4a:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016f4e:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8016f52:	785b      	ldrb	r3, [r3, #1]
 8016f54:	089b      	lsrs	r3, r3, #2
 8016f56:	b2db      	uxtb	r3, r3
 8016f58:	461a      	mov	r2, r3
 8016f5a:	f897 30a7 	ldrb.w	r3, [r7, #167]	@ 0xa7
 8016f5e:	b29b      	uxth	r3, r3
 8016f60:	fb12 f303 	smulbb	r3, r2, r3
 8016f64:	b29a      	uxth	r2, r3
 8016f66:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016f6a:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 8016f6e:	805a      	strh	r2, [r3, #2]
                        c_mult[2] = (color.red >> 3) * mix;
 8016f70:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016f74:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8016f78:	789b      	ldrb	r3, [r3, #2]
 8016f7a:	08db      	lsrs	r3, r3, #3
 8016f7c:	b2db      	uxtb	r3, r3
 8016f7e:	461a      	mov	r2, r3
 8016f80:	f897 30a7 	ldrb.w	r3, [r7, #167]	@ 0xa7
 8016f84:	b29b      	uxth	r3, r3
 8016f86:	fb12 f303 	smulbb	r3, r2, r3
 8016f8a:	b29a      	uxth	r2, r3
 8016f8c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016f90:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 8016f94:	809a      	strh	r2, [r3, #4]
                        uint16_t * buf16 = (uint16_t *)tmp_buf;
 8016f96:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8016f9a:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
                        int32_t i;
                        int32_t size = lv_area_get_size(&blend_area);
 8016f9e:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8016fa2:	4618      	mov	r0, r3
 8016fa4:	f00a fc6d 	bl	8021882 <lv_area_get_size>
 8016fa8:	4603      	mov	r3, r0
 8016faa:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
                        for(i = 0; i < size; i++) {
 8016fae:	2300      	movs	r3, #0
 8016fb0:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 8016fb4:	e05e      	b.n	8017074 <img_draw_core+0xa28>
                            buf16[i] = (((c_mult[2] + ((buf16[i] >> 11) & 0x1F) * mix_inv) << 3) & 0xF800) +
 8016fb6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016fba:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 8016fbe:	889b      	ldrh	r3, [r3, #4]
 8016fc0:	4619      	mov	r1, r3
 8016fc2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8016fc6:	005b      	lsls	r3, r3, #1
 8016fc8:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 8016fcc:	4413      	add	r3, r2
 8016fce:	881b      	ldrh	r3, [r3, #0]
 8016fd0:	0adb      	lsrs	r3, r3, #11
 8016fd2:	b29b      	uxth	r3, r3
 8016fd4:	f003 031f 	and.w	r3, r3, #31
 8016fd8:	f897 20a6 	ldrb.w	r2, [r7, #166]	@ 0xa6
 8016fdc:	fb02 f303 	mul.w	r3, r2, r3
 8016fe0:	440b      	add	r3, r1
 8016fe2:	00db      	lsls	r3, r3, #3
 8016fe4:	b21b      	sxth	r3, r3
 8016fe6:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
 8016fea:	f023 0307 	bic.w	r3, r3, #7
 8016fee:	b21a      	sxth	r2, r3
                                       (((c_mult[1] + ((buf16[i] >> 5) & 0x3F) * mix_inv) >> 3) & 0x07E0) +
 8016ff0:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8016ff4:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 8016ff8:	885b      	ldrh	r3, [r3, #2]
 8016ffa:	4618      	mov	r0, r3
 8016ffc:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8017000:	005b      	lsls	r3, r3, #1
 8017002:	f8d7 1098 	ldr.w	r1, [r7, #152]	@ 0x98
 8017006:	440b      	add	r3, r1
 8017008:	881b      	ldrh	r3, [r3, #0]
 801700a:	095b      	lsrs	r3, r3, #5
 801700c:	b29b      	uxth	r3, r3
 801700e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8017012:	f897 10a6 	ldrb.w	r1, [r7, #166]	@ 0xa6
 8017016:	fb01 f303 	mul.w	r3, r1, r3
 801701a:	4403      	add	r3, r0
 801701c:	10db      	asrs	r3, r3, #3
 801701e:	b21b      	sxth	r3, r3
 8017020:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
 8017024:	b21b      	sxth	r3, r3
                            buf16[i] = (((c_mult[2] + ((buf16[i] >> 11) & 0x1F) * mix_inv) << 3) & 0xF800) +
 8017026:	4313      	orrs	r3, r2
 8017028:	b21b      	sxth	r3, r3
 801702a:	b299      	uxth	r1, r3
                                       ((c_mult[0] + (buf16[i] & 0x1F) * mix_inv) >> 8);
 801702c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8017030:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 8017034:	881b      	ldrh	r3, [r3, #0]
 8017036:	4618      	mov	r0, r3
 8017038:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801703c:	005b      	lsls	r3, r3, #1
 801703e:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 8017042:	4413      	add	r3, r2
 8017044:	881b      	ldrh	r3, [r3, #0]
 8017046:	f003 031f 	and.w	r3, r3, #31
 801704a:	f897 20a6 	ldrb.w	r2, [r7, #166]	@ 0xa6
 801704e:	fb02 f303 	mul.w	r3, r2, r3
 8017052:	4403      	add	r3, r0
 8017054:	121b      	asrs	r3, r3, #8
                                       (((c_mult[1] + ((buf16[i] >> 5) & 0x3F) * mix_inv) >> 3) & 0x07E0) +
 8017056:	b29a      	uxth	r2, r3
                            buf16[i] = (((c_mult[2] + ((buf16[i] >> 11) & 0x1F) * mix_inv) << 3) & 0xF800) +
 8017058:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801705c:	005b      	lsls	r3, r3, #1
 801705e:	f8d7 0098 	ldr.w	r0, [r7, #152]	@ 0x98
 8017062:	4403      	add	r3, r0
                                       (((c_mult[1] + ((buf16[i] >> 5) & 0x3F) * mix_inv) >> 3) & 0x07E0) +
 8017064:	440a      	add	r2, r1
 8017066:	b292      	uxth	r2, r2
                            buf16[i] = (((c_mult[2] + ((buf16[i] >> 11) & 0x1F) * mix_inv) << 3) & 0xF800) +
 8017068:	801a      	strh	r2, [r3, #0]
                        for(i = 0; i < size; i++) {
 801706a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801706e:	3301      	adds	r3, #1
 8017070:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 8017074:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 8017078:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801707c:	429a      	cmp	r2, r3
 801707e:	db9a      	blt.n	8016fb6 <img_draw_core+0x96a>
                    if(LV_RESULT_INVALID == LV_DRAW_SW_RGB565_RECOLOR(tmp_buf, blend_area, color, mix)) {
 8017080:	e0a9      	b.n	80171d6 <img_draw_core+0xb8a>
                        }
                    }
                }
                else  if(cf_final != LV_COLOR_FORMAT_A8) {
 8017082:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8017086:	2b0e      	cmp	r3, #14
 8017088:	f000 80a5 	beq.w	80171d6 <img_draw_core+0xb8a>
                    if(LV_RESULT_INVALID == LV_DRAW_SW_RGB888_RECOLOR(tmp_buf, blend_area, color, mix, cf_final)) {
                        uint32_t size = lv_area_get_size(&blend_area);
 801708c:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8017090:	4618      	mov	r0, r3
 8017092:	f00a fbf6 	bl	8021882 <lv_area_get_size>
 8017096:	f8c7 00a0 	str.w	r0, [r7, #160]	@ 0xa0
                        uint32_t i;
                        uint16_t c_mult[3];
                        c_mult[0] = color.blue * mix;
 801709a:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 801709e:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 80170a2:	781b      	ldrb	r3, [r3, #0]
 80170a4:	461a      	mov	r2, r3
 80170a6:	f897 30a7 	ldrb.w	r3, [r7, #167]	@ 0xa7
 80170aa:	b29b      	uxth	r3, r3
 80170ac:	fb12 f303 	smulbb	r3, r2, r3
 80170b0:	b29a      	uxth	r2, r3
 80170b2:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80170b6:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 80170ba:	801a      	strh	r2, [r3, #0]
                        c_mult[1] = color.green * mix;
 80170bc:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80170c0:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 80170c4:	785b      	ldrb	r3, [r3, #1]
 80170c6:	461a      	mov	r2, r3
 80170c8:	f897 30a7 	ldrb.w	r3, [r7, #167]	@ 0xa7
 80170cc:	b29b      	uxth	r3, r3
 80170ce:	fb12 f303 	smulbb	r3, r2, r3
 80170d2:	b29a      	uxth	r2, r3
 80170d4:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80170d8:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 80170dc:	805a      	strh	r2, [r3, #2]
                        c_mult[2] = color.red * mix;
 80170de:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80170e2:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 80170e6:	789b      	ldrb	r3, [r3, #2]
 80170e8:	461a      	mov	r2, r3
 80170ea:	f897 30a7 	ldrb.w	r3, [r7, #167]	@ 0xa7
 80170ee:	b29b      	uxth	r3, r3
 80170f0:	fb12 f303 	smulbb	r3, r2, r3
 80170f4:	b29a      	uxth	r2, r3
 80170f6:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80170fa:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 80170fe:	809a      	strh	r2, [r3, #4]
                        uint8_t * tmp_buf_2 = tmp_buf;
 8017100:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8017104:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
                        for(i = 0; i < size * px_size; i += px_size) {
 8017108:	2300      	movs	r3, #0
 801710a:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 801710e:	e058      	b.n	80171c2 <img_draw_core+0xb76>
                            tmp_buf_2[i + 0] = (c_mult[0] + (tmp_buf_2[i + 0] * mix_inv)) >> 8;
 8017110:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8017114:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 8017118:	881b      	ldrh	r3, [r3, #0]
 801711a:	4619      	mov	r1, r3
 801711c:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8017120:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8017124:	4413      	add	r3, r2
 8017126:	781b      	ldrb	r3, [r3, #0]
 8017128:	461a      	mov	r2, r3
 801712a:	f897 30a6 	ldrb.w	r3, [r7, #166]	@ 0xa6
 801712e:	fb02 f303 	mul.w	r3, r2, r3
 8017132:	440b      	add	r3, r1
 8017134:	1219      	asrs	r1, r3, #8
 8017136:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801713a:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801713e:	4413      	add	r3, r2
 8017140:	b2ca      	uxtb	r2, r1
 8017142:	701a      	strb	r2, [r3, #0]
                            tmp_buf_2[i + 1] = (c_mult[1] + (tmp_buf_2[i + 1] * mix_inv)) >> 8;
 8017144:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8017148:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 801714c:	885b      	ldrh	r3, [r3, #2]
 801714e:	4619      	mov	r1, r3
 8017150:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8017154:	3301      	adds	r3, #1
 8017156:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 801715a:	4413      	add	r3, r2
 801715c:	781b      	ldrb	r3, [r3, #0]
 801715e:	461a      	mov	r2, r3
 8017160:	f897 30a6 	ldrb.w	r3, [r7, #166]	@ 0xa6
 8017164:	fb02 f303 	mul.w	r3, r2, r3
 8017168:	440b      	add	r3, r1
 801716a:	1219      	asrs	r1, r3, #8
 801716c:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 8017170:	3301      	adds	r3, #1
 8017172:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8017176:	4413      	add	r3, r2
 8017178:	b2ca      	uxtb	r2, r1
 801717a:	701a      	strb	r2, [r3, #0]
                            tmp_buf_2[i + 2] = (c_mult[2] + (tmp_buf_2[i + 2] * mix_inv)) >> 8;
 801717c:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 8017180:	f5a3 738a 	sub.w	r3, r3, #276	@ 0x114
 8017184:	889b      	ldrh	r3, [r3, #4]
 8017186:	4619      	mov	r1, r3
 8017188:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801718c:	3302      	adds	r3, #2
 801718e:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 8017192:	4413      	add	r3, r2
 8017194:	781b      	ldrb	r3, [r3, #0]
 8017196:	461a      	mov	r2, r3
 8017198:	f897 30a6 	ldrb.w	r3, [r7, #166]	@ 0xa6
 801719c:	fb02 f303 	mul.w	r3, r2, r3
 80171a0:	440b      	add	r3, r1
 80171a2:	1219      	asrs	r1, r3, #8
 80171a4:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 80171a8:	3302      	adds	r3, #2
 80171aa:	f8d7 209c 	ldr.w	r2, [r7, #156]	@ 0x9c
 80171ae:	4413      	add	r3, r2
 80171b0:	b2ca      	uxtb	r2, r1
 80171b2:	701a      	strb	r2, [r3, #0]
                        for(i = 0; i < size * px_size; i += px_size) {
 80171b4:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 80171b8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 80171bc:	4413      	add	r3, r2
 80171be:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 80171c2:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 80171c6:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 80171ca:	fb02 f303 	mul.w	r3, r2, r3
 80171ce:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 80171d2:	429a      	cmp	r2, r3
 80171d4:	d39c      	bcc.n	8017110 <img_draw_core+0xac4>
                    }
                }
            }

            /*Blend*/
            lv_draw_sw_blend(draw_unit, &blend_dsc);
 80171d6:	f107 0268 	add.w	r2, r7, #104	@ 0x68
 80171da:	f507 7394 	add.w	r3, r7, #296	@ 0x128
 80171de:	f5a3 738e 	sub.w	r3, r3, #284	@ 0x11c
 80171e2:	4611      	mov	r1, r2
 80171e4:	6818      	ldr	r0, [r3, #0]
 80171e6:	f7f7 fb95 	bl	800e914 <lv_draw_sw_blend>

            /*Go to the next area*/
            blend_area.y1 = blend_area.y2 + 1;
 80171ea:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80171ec:	3301      	adds	r3, #1
 80171ee:	63fb      	str	r3, [r7, #60]	@ 0x3c
            blend_area.y2 = blend_area.y1 + buf_h - 1;
 80171f0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80171f2:	f8d7 3118 	ldr.w	r3, [r7, #280]	@ 0x118
 80171f6:	4413      	add	r3, r2
 80171f8:	3b01      	subs	r3, #1
 80171fa:	647b      	str	r3, [r7, #68]	@ 0x44
            if(blend_area.y2 > y_last) {
 80171fc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80171fe:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 8017202:	429a      	cmp	r2, r3
 8017204:	da17      	bge.n	8017236 <img_draw_core+0xbea>
                blend_area.y2 = y_last;
 8017206:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801720a:	647b      	str	r3, [r7, #68]	@ 0x44
                if(cf_final == LV_COLOR_FORMAT_RGB565A8) {
 801720c:	f897 3123 	ldrb.w	r3, [r7, #291]	@ 0x123
 8017210:	2b14      	cmp	r3, #20
 8017212:	d110      	bne.n	8017236 <img_draw_core+0xbea>
                    blend_dsc.mask_buf =  tmp_buf + blend_w * 2 * lv_area_get_height(&blend_area);
 8017214:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8017218:	4618      	mov	r0, r3
 801721a:	f7ff f9a1 	bl	8016560 <lv_area_get_height>
 801721e:	4602      	mov	r2, r0
 8017220:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 8017224:	fb02 f303 	mul.w	r3, r2, r3
 8017228:	005b      	lsls	r3, r3, #1
 801722a:	461a      	mov	r2, r3
 801722c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8017230:	4413      	add	r3, r2
 8017232:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        while(blend_area.y1 <= y_last) {
 8017236:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017238:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 801723c:	429a      	cmp	r2, r3
 801723e:	f6bf ad17 	bge.w	8016c70 <img_draw_core+0x624>
                }
            }
        }

        lv_free(tmp_buf);
 8017242:	f8d7 011c 	ldr.w	r0, [r7, #284]	@ 0x11c
 8017246:	f00e fdf7 	bl	8025e38 <lv_free>
    }
}
 801724a:	f507 7796 	add.w	r7, r7, #300	@ 0x12c
 801724e:	46bd      	mov	sp, r7
 8017250:	bd90      	pop	{r4, r7, pc}

08017252 <lv_area_get_width>:
{
 8017252:	b480      	push	{r7}
 8017254:	b083      	sub	sp, #12
 8017256:	af00      	add	r7, sp, #0
 8017258:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 801725a:	687b      	ldr	r3, [r7, #4]
 801725c:	689a      	ldr	r2, [r3, #8]
 801725e:	687b      	ldr	r3, [r7, #4]
 8017260:	681b      	ldr	r3, [r3, #0]
 8017262:	1ad3      	subs	r3, r2, r3
 8017264:	3301      	adds	r3, #1
}
 8017266:	4618      	mov	r0, r3
 8017268:	370c      	adds	r7, #12
 801726a:	46bd      	mov	sp, r7
 801726c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017270:	4770      	bx	lr

08017272 <lv_memzero>:
{
 8017272:	b580      	push	{r7, lr}
 8017274:	b082      	sub	sp, #8
 8017276:	af00      	add	r7, sp, #0
 8017278:	6078      	str	r0, [r7, #4]
 801727a:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 801727c:	683a      	ldr	r2, [r7, #0]
 801727e:	2100      	movs	r1, #0
 8017280:	6878      	ldr	r0, [r7, #4]
 8017282:	f00d fdce 	bl	8024e22 <lv_memset>
}
 8017286:	bf00      	nop
 8017288:	3708      	adds	r7, #8
 801728a:	46bd      	mov	sp, r7
 801728c:	bd80      	pop	{r7, pc}
	...

08017290 <lv_draw_sw_label>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_sw_label(lv_draw_unit_t * draw_unit, const lv_draw_label_dsc_t * dsc, const lv_area_t * coords)
{
 8017290:	b580      	push	{r7, lr}
 8017292:	b084      	sub	sp, #16
 8017294:	af00      	add	r7, sp, #0
 8017296:	60f8      	str	r0, [r7, #12]
 8017298:	60b9      	str	r1, [r7, #8]
 801729a:	607a      	str	r2, [r7, #4]
    if(dsc->opa <= LV_OPA_MIN) return;
 801729c:	68bb      	ldr	r3, [r7, #8]
 801729e:	f893 3048 	ldrb.w	r3, [r3, #72]	@ 0x48
 80172a2:	2b02      	cmp	r3, #2
 80172a4:	d906      	bls.n	80172b4 <lv_draw_sw_label+0x24>

    LV_PROFILER_BEGIN;
    lv_draw_label_iterate_characters(draw_unit, dsc, coords, draw_letter_cb);
 80172a6:	4b05      	ldr	r3, [pc, #20]	@ (80172bc <lv_draw_sw_label+0x2c>)
 80172a8:	687a      	ldr	r2, [r7, #4]
 80172aa:	68b9      	ldr	r1, [r7, #8]
 80172ac:	68f8      	ldr	r0, [r7, #12]
 80172ae:	f7f5 fe83 	bl	800cfb8 <lv_draw_label_iterate_characters>
 80172b2:	e000      	b.n	80172b6 <lv_draw_sw_label+0x26>
    if(dsc->opa <= LV_OPA_MIN) return;
 80172b4:	bf00      	nop
    LV_PROFILER_END;
}
 80172b6:	3710      	adds	r7, #16
 80172b8:	46bd      	mov	sp, r7
 80172ba:	bd80      	pop	{r7, pc}
 80172bc:	080172c1 	.word	0x080172c1

080172c0 <draw_letter_cb>:
 *   STATIC FUNCTIONS
 **********************/

static void LV_ATTRIBUTE_FAST_MEM draw_letter_cb(lv_draw_unit_t * draw_unit, lv_draw_glyph_dsc_t * glyph_draw_dsc,
                                                 lv_draw_fill_dsc_t * fill_draw_dsc, const lv_area_t * fill_area)
{
 80172c0:	b590      	push	{r4, r7, lr}
 80172c2:	b095      	sub	sp, #84	@ 0x54
 80172c4:	af00      	add	r7, sp, #0
 80172c6:	60f8      	str	r0, [r7, #12]
 80172c8:	60b9      	str	r1, [r7, #8]
 80172ca:	607a      	str	r2, [r7, #4]
 80172cc:	603b      	str	r3, [r7, #0]
    if(glyph_draw_dsc) {
 80172ce:	68bb      	ldr	r3, [r7, #8]
 80172d0:	2b00      	cmp	r3, #0
 80172d2:	d07c      	beq.n	80173ce <draw_letter_cb+0x10e>
        switch(glyph_draw_dsc->format) {
 80172d4:	68bb      	ldr	r3, [r7, #8]
 80172d6:	791b      	ldrb	r3, [r3, #4]
 80172d8:	2b09      	cmp	r3, #9
 80172da:	d877      	bhi.n	80173cc <draw_letter_cb+0x10c>
 80172dc:	a201      	add	r2, pc, #4	@ (adr r2, 80172e4 <draw_letter_cb+0x24>)
 80172de:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80172e2:	bf00      	nop
 80172e4:	0801730d 	.word	0x0801730d
 80172e8:	08017349 	.word	0x08017349
 80172ec:	08017349 	.word	0x08017349
 80172f0:	080173cd 	.word	0x080173cd
 80172f4:	08017349 	.word	0x08017349
 80172f8:	080173cd 	.word	0x080173cd
 80172fc:	080173cd 	.word	0x080173cd
 8017300:	080173cd 	.word	0x080173cd
 8017304:	08017349 	.word	0x08017349
 8017308:	080173cd 	.word	0x080173cd
            case LV_FONT_GLYPH_FORMAT_NONE: {
#if LV_USE_FONT_PLACEHOLDER
                    /* Draw a placeholder rectangle*/
                    lv_draw_border_dsc_t border_draw_dsc;
                    lv_draw_border_dsc_init(&border_draw_dsc);
 801730c:	f107 0310 	add.w	r3, r7, #16
 8017310:	4618      	mov	r0, r3
 8017312:	f7f6 fd14 	bl	800dd3e <lv_draw_border_dsc_init>
                    border_draw_dsc.opa = glyph_draw_dsc->opa;
 8017316:	68bb      	ldr	r3, [r7, #8]
 8017318:	7ddb      	ldrb	r3, [r3, #23]
 801731a:	f887 3038 	strb.w	r3, [r7, #56]	@ 0x38
                    border_draw_dsc.color = glyph_draw_dsc->color;
 801731e:	68ba      	ldr	r2, [r7, #8]
 8017320:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8017324:	3214      	adds	r2, #20
 8017326:	6812      	ldr	r2, [r2, #0]
 8017328:	4611      	mov	r1, r2
 801732a:	8019      	strh	r1, [r3, #0]
 801732c:	3302      	adds	r3, #2
 801732e:	0c12      	lsrs	r2, r2, #16
 8017330:	701a      	strb	r2, [r3, #0]
                    border_draw_dsc.width = 1;
 8017332:	2301      	movs	r3, #1
 8017334:	637b      	str	r3, [r7, #52]	@ 0x34
                    lv_draw_sw_border(draw_unit, &border_draw_dsc, glyph_draw_dsc->bg_coords);
 8017336:	68bb      	ldr	r3, [r7, #8]
 8017338:	68da      	ldr	r2, [r3, #12]
 801733a:	f107 0310 	add.w	r3, r7, #16
 801733e:	4619      	mov	r1, r3
 8017340:	68f8      	ldr	r0, [r7, #12]
 8017342:	f7fc f964 	bl	801360e <lv_draw_sw_border>
#endif
                }
                break;
 8017346:	e042      	b.n	80173ce <draw_letter_cb+0x10e>
            case LV_FONT_GLYPH_FORMAT_A1:
            case LV_FONT_GLYPH_FORMAT_A2:
            case LV_FONT_GLYPH_FORMAT_A4:
            case LV_FONT_GLYPH_FORMAT_A8: {
                    lv_area_t mask_area = *glyph_draw_dsc->letter_coords;
 8017348:	68bb      	ldr	r3, [r7, #8]
 801734a:	689b      	ldr	r3, [r3, #8]
 801734c:	f107 043c 	add.w	r4, r7, #60	@ 0x3c
 8017350:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8017352:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
                    mask_area.x2 = mask_area.x1 + lv_draw_buf_width_to_stride(lv_area_get_width(&mask_area), LV_COLOR_FORMAT_A8) - 1;
 8017356:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017358:	461c      	mov	r4, r3
 801735a:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801735e:	4618      	mov	r0, r3
 8017360:	f7ff ff77 	bl	8017252 <lv_area_get_width>
 8017364:	4603      	mov	r3, r0
 8017366:	210e      	movs	r1, #14
 8017368:	4618      	mov	r0, r3
 801736a:	f7f4 fc2b 	bl	800bbc4 <lv_draw_buf_width_to_stride>
 801736e:	4603      	mov	r3, r0
 8017370:	4423      	add	r3, r4
 8017372:	3b01      	subs	r3, #1
 8017374:	647b      	str	r3, [r7, #68]	@ 0x44
                    lv_draw_sw_blend_dsc_t blend_dsc;
                    lv_memzero(&blend_dsc, sizeof(blend_dsc));
 8017376:	f107 0310 	add.w	r3, r7, #16
 801737a:	212c      	movs	r1, #44	@ 0x2c
 801737c:	4618      	mov	r0, r3
 801737e:	f7ff ff78 	bl	8017272 <lv_memzero>
                    blend_dsc.color = glyph_draw_dsc->color;
 8017382:	68ba      	ldr	r2, [r7, #8]
 8017384:	f107 0325 	add.w	r3, r7, #37	@ 0x25
 8017388:	3214      	adds	r2, #20
 801738a:	8811      	ldrh	r1, [r2, #0]
 801738c:	7892      	ldrb	r2, [r2, #2]
 801738e:	8019      	strh	r1, [r3, #0]
 8017390:	709a      	strb	r2, [r3, #2]
                    blend_dsc.opa = glyph_draw_dsc->opa;
 8017392:	68bb      	ldr	r3, [r7, #8]
 8017394:	7ddb      	ldrb	r3, [r3, #23]
 8017396:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
                    lv_draw_buf_t * draw_buf = glyph_draw_dsc->glyph_data;
 801739a:	68bb      	ldr	r3, [r7, #8]
 801739c:	681b      	ldr	r3, [r3, #0]
 801739e:	64fb      	str	r3, [r7, #76]	@ 0x4c
                    blend_dsc.mask_buf = draw_buf->data;
 80173a0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80173a2:	691b      	ldr	r3, [r3, #16]
 80173a4:	62bb      	str	r3, [r7, #40]	@ 0x28
                    blend_dsc.mask_area = &mask_area;
 80173a6:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 80173aa:	633b      	str	r3, [r7, #48]	@ 0x30
                    blend_dsc.mask_stride = draw_buf->header.stride;
 80173ac:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80173ae:	891b      	ldrh	r3, [r3, #8]
 80173b0:	637b      	str	r3, [r7, #52]	@ 0x34
                    blend_dsc.blend_area = glyph_draw_dsc->letter_coords;
 80173b2:	68bb      	ldr	r3, [r7, #8]
 80173b4:	689b      	ldr	r3, [r3, #8]
 80173b6:	613b      	str	r3, [r7, #16]
                    blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 80173b8:	2302      	movs	r3, #2
 80173ba:	f887 302c 	strb.w	r3, [r7, #44]	@ 0x2c

                    lv_draw_sw_blend(draw_unit, &blend_dsc);
 80173be:	f107 0310 	add.w	r3, r7, #16
 80173c2:	4619      	mov	r1, r3
 80173c4:	68f8      	ldr	r0, [r7, #12]
 80173c6:	f7f7 faa5 	bl	800e914 <lv_draw_sw_blend>
                }
                break;
 80173ca:	e000      	b.n	80173ce <draw_letter_cb+0x10e>
                    lv_draw_sw_image(draw_unit, &img_dsc, glyph_draw_dsc->letter_coords);
#endif
                }
                break;
            default:
                break;
 80173cc:	bf00      	nop
        }

    }

    if(fill_draw_dsc && fill_area) {
 80173ce:	687b      	ldr	r3, [r7, #4]
 80173d0:	2b00      	cmp	r3, #0
 80173d2:	d007      	beq.n	80173e4 <draw_letter_cb+0x124>
 80173d4:	683b      	ldr	r3, [r7, #0]
 80173d6:	2b00      	cmp	r3, #0
 80173d8:	d004      	beq.n	80173e4 <draw_letter_cb+0x124>
        lv_draw_sw_fill(draw_unit, fill_draw_dsc, fill_area);
 80173da:	683a      	ldr	r2, [r7, #0]
 80173dc:	6879      	ldr	r1, [r7, #4]
 80173de:	68f8      	ldr	r0, [r7, #12]
 80173e0:	f7fe fb85 	bl	8015aee <lv_draw_sw_fill>
    }
}
 80173e4:	bf00      	nop
 80173e6:	3754      	adds	r7, #84	@ 0x54
 80173e8:	46bd      	mov	sp, r7
 80173ea:	bd90      	pop	{r4, r7, pc}

080173ec <lv_area_get_width>:
{
 80173ec:	b480      	push	{r7}
 80173ee:	b083      	sub	sp, #12
 80173f0:	af00      	add	r7, sp, #0
 80173f2:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 80173f4:	687b      	ldr	r3, [r7, #4]
 80173f6:	689a      	ldr	r2, [r3, #8]
 80173f8:	687b      	ldr	r3, [r7, #4]
 80173fa:	681b      	ldr	r3, [r3, #0]
 80173fc:	1ad3      	subs	r3, r2, r3
 80173fe:	3301      	adds	r3, #1
}
 8017400:	4618      	mov	r0, r3
 8017402:	370c      	adds	r7, #12
 8017404:	46bd      	mov	sp, r7
 8017406:	f85d 7b04 	ldr.w	r7, [sp], #4
 801740a:	4770      	bx	lr

0801740c <lv_point_from_precise>:

void lv_point_transform(lv_point_t * p, int32_t angle, int32_t scale_x, int32_t scale_y, const lv_point_t * pivot,
                        bool zoom_first);

static inline lv_point_t lv_point_from_precise(const lv_point_precise_t * p)
{
 801740c:	b480      	push	{r7}
 801740e:	b085      	sub	sp, #20
 8017410:	af00      	add	r7, sp, #0
 8017412:	6078      	str	r0, [r7, #4]
 8017414:	6039      	str	r1, [r7, #0]
    lv_point_t point = {
        (int32_t)p->x, (int32_t)p->y
 8017416:	683b      	ldr	r3, [r7, #0]
 8017418:	681b      	ldr	r3, [r3, #0]
    lv_point_t point = {
 801741a:	60bb      	str	r3, [r7, #8]
        (int32_t)p->x, (int32_t)p->y
 801741c:	683b      	ldr	r3, [r7, #0]
 801741e:	685b      	ldr	r3, [r3, #4]
    lv_point_t point = {
 8017420:	60fb      	str	r3, [r7, #12]
    };

    return point;
 8017422:	687b      	ldr	r3, [r7, #4]
 8017424:	461a      	mov	r2, r3
 8017426:	f107 0308 	add.w	r3, r7, #8
 801742a:	e893 0003 	ldmia.w	r3, {r0, r1}
 801742e:	e882 0003 	stmia.w	r2, {r0, r1}
}
 8017432:	6878      	ldr	r0, [r7, #4]
 8017434:	3714      	adds	r7, #20
 8017436:	46bd      	mov	sp, r7
 8017438:	f85d 7b04 	ldr.w	r7, [sp], #4
 801743c:	4770      	bx	lr

0801743e <lv_memzero>:
{
 801743e:	b580      	push	{r7, lr}
 8017440:	b082      	sub	sp, #8
 8017442:	af00      	add	r7, sp, #0
 8017444:	6078      	str	r0, [r7, #4]
 8017446:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 8017448:	683a      	ldr	r2, [r7, #0]
 801744a:	2100      	movs	r1, #0
 801744c:	6878      	ldr	r0, [r7, #4]
 801744e:	f00d fce8 	bl	8024e22 <lv_memset>
}
 8017452:	bf00      	nop
 8017454:	3708      	adds	r7, #8
 8017456:	46bd      	mov	sp, r7
 8017458:	bd80      	pop	{r7, pc}

0801745a <lv_draw_sw_line>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_sw_line(lv_draw_unit_t * draw_unit, const lv_draw_line_dsc_t * dsc)
{
 801745a:	b580      	push	{r7, lr}
 801745c:	b09a      	sub	sp, #104	@ 0x68
 801745e:	af00      	add	r7, sp, #0
 8017460:	6078      	str	r0, [r7, #4]
 8017462:	6039      	str	r1, [r7, #0]
    if(dsc->width == 0) return;
 8017464:	683b      	ldr	r3, [r7, #0]
 8017466:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8017468:	2b00      	cmp	r3, #0
 801746a:	f000 80ff 	beq.w	801766c <lv_draw_sw_line+0x212>
    if(dsc->opa <= LV_OPA_MIN) return;
 801746e:	683b      	ldr	r3, [r7, #0]
 8017470:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8017474:	2b02      	cmp	r3, #2
 8017476:	f240 80fb 	bls.w	8017670 <lv_draw_sw_line+0x216>

    if(dsc->p1.x == dsc->p2.x && dsc->p1.y == dsc->p2.y) return;
 801747a:	683b      	ldr	r3, [r7, #0]
 801747c:	69da      	ldr	r2, [r3, #28]
 801747e:	683b      	ldr	r3, [r7, #0]
 8017480:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8017482:	429a      	cmp	r2, r3
 8017484:	d106      	bne.n	8017494 <lv_draw_sw_line+0x3a>
 8017486:	683b      	ldr	r3, [r7, #0]
 8017488:	6a1a      	ldr	r2, [r3, #32]
 801748a:	683b      	ldr	r3, [r7, #0]
 801748c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801748e:	429a      	cmp	r2, r3
 8017490:	f000 80f0 	beq.w	8017674 <lv_draw_sw_line+0x21a>

    lv_area_t clip_line;
    clip_line.x1 = (int32_t)LV_MIN(dsc->p1.x, dsc->p2.x) - dsc->width / 2;
 8017494:	683b      	ldr	r3, [r7, #0]
 8017496:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8017498:	683b      	ldr	r3, [r7, #0]
 801749a:	69db      	ldr	r3, [r3, #28]
 801749c:	429a      	cmp	r2, r3
 801749e:	bfa8      	it	ge
 80174a0:	461a      	movge	r2, r3
 80174a2:	683b      	ldr	r3, [r7, #0]
 80174a4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80174a6:	0fd9      	lsrs	r1, r3, #31
 80174a8:	440b      	add	r3, r1
 80174aa:	105b      	asrs	r3, r3, #1
 80174ac:	425b      	negs	r3, r3
 80174ae:	4413      	add	r3, r2
 80174b0:	64fb      	str	r3, [r7, #76]	@ 0x4c
    clip_line.x2 = (int32_t)LV_MAX(dsc->p1.x, dsc->p2.x) + dsc->width / 2;
 80174b2:	683b      	ldr	r3, [r7, #0]
 80174b4:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80174b6:	683b      	ldr	r3, [r7, #0]
 80174b8:	69db      	ldr	r3, [r3, #28]
 80174ba:	429a      	cmp	r2, r3
 80174bc:	bfb8      	it	lt
 80174be:	461a      	movlt	r2, r3
 80174c0:	683b      	ldr	r3, [r7, #0]
 80174c2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80174c4:	0fd9      	lsrs	r1, r3, #31
 80174c6:	440b      	add	r3, r1
 80174c8:	105b      	asrs	r3, r3, #1
 80174ca:	4413      	add	r3, r2
 80174cc:	657b      	str	r3, [r7, #84]	@ 0x54
    clip_line.y1 = (int32_t)LV_MIN(dsc->p1.y, dsc->p2.y) - dsc->width / 2;
 80174ce:	683b      	ldr	r3, [r7, #0]
 80174d0:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80174d2:	683b      	ldr	r3, [r7, #0]
 80174d4:	6a1b      	ldr	r3, [r3, #32]
 80174d6:	429a      	cmp	r2, r3
 80174d8:	bfa8      	it	ge
 80174da:	461a      	movge	r2, r3
 80174dc:	683b      	ldr	r3, [r7, #0]
 80174de:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80174e0:	0fd9      	lsrs	r1, r3, #31
 80174e2:	440b      	add	r3, r1
 80174e4:	105b      	asrs	r3, r3, #1
 80174e6:	425b      	negs	r3, r3
 80174e8:	4413      	add	r3, r2
 80174ea:	653b      	str	r3, [r7, #80]	@ 0x50
    clip_line.y2 = (int32_t)LV_MAX(dsc->p1.y, dsc->p2.y) + dsc->width / 2;
 80174ec:	683b      	ldr	r3, [r7, #0]
 80174ee:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80174f0:	683b      	ldr	r3, [r7, #0]
 80174f2:	6a1b      	ldr	r3, [r3, #32]
 80174f4:	429a      	cmp	r2, r3
 80174f6:	bfb8      	it	lt
 80174f8:	461a      	movlt	r2, r3
 80174fa:	683b      	ldr	r3, [r7, #0]
 80174fc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80174fe:	0fd9      	lsrs	r1, r3, #31
 8017500:	440b      	add	r3, r1
 8017502:	105b      	asrs	r3, r3, #1
 8017504:	4413      	add	r3, r2
 8017506:	65bb      	str	r3, [r7, #88]	@ 0x58

    bool is_common;
    is_common = _lv_area_intersect(&clip_line, &clip_line, draw_unit->clip_area);
 8017508:	687b      	ldr	r3, [r7, #4]
 801750a:	689a      	ldr	r2, [r3, #8]
 801750c:	f107 014c 	add.w	r1, r7, #76	@ 0x4c
 8017510:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
 8017514:	4618      	mov	r0, r3
 8017516:	f00a fa17 	bl	8021948 <_lv_area_intersect>
 801751a:	4603      	mov	r3, r0
 801751c:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
    if(!is_common) return;
 8017520:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8017524:	f083 0301 	eor.w	r3, r3, #1
 8017528:	b2db      	uxtb	r3, r3
 801752a:	2b00      	cmp	r3, #0
 801752c:	f040 80a4 	bne.w	8017678 <lv_draw_sw_line+0x21e>

    LV_PROFILER_BEGIN;
    if(dsc->p1.y == dsc->p2.y) draw_line_hor(draw_unit, dsc);
 8017530:	683b      	ldr	r3, [r7, #0]
 8017532:	6a1a      	ldr	r2, [r3, #32]
 8017534:	683b      	ldr	r3, [r7, #0]
 8017536:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8017538:	429a      	cmp	r2, r3
 801753a:	d104      	bne.n	8017546 <lv_draw_sw_line+0xec>
 801753c:	6839      	ldr	r1, [r7, #0]
 801753e:	6878      	ldr	r0, [r7, #4]
 8017540:	f000 f89e 	bl	8017680 <draw_line_hor>
 8017544:	e00e      	b.n	8017564 <lv_draw_sw_line+0x10a>
    else if(dsc->p1.x == dsc->p2.x) draw_line_ver(draw_unit, dsc);
 8017546:	683b      	ldr	r3, [r7, #0]
 8017548:	69da      	ldr	r2, [r3, #28]
 801754a:	683b      	ldr	r3, [r7, #0]
 801754c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801754e:	429a      	cmp	r2, r3
 8017550:	d104      	bne.n	801755c <lv_draw_sw_line+0x102>
 8017552:	6839      	ldr	r1, [r7, #0]
 8017554:	6878      	ldr	r0, [r7, #4]
 8017556:	f000 f98d 	bl	8017874 <draw_line_ver>
 801755a:	e003      	b.n	8017564 <lv_draw_sw_line+0x10a>
    else draw_line_skew(draw_unit, dsc);
 801755c:	6839      	ldr	r1, [r7, #0]
 801755e:	6878      	ldr	r0, [r7, #4]
 8017560:	f000 fa62 	bl	8017a28 <draw_line_skew>

    if(dsc->round_end || dsc->round_start) {
 8017564:	683b      	ldr	r3, [r7, #0]
 8017566:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 801756a:	f003 0308 	and.w	r3, r3, #8
 801756e:	b2db      	uxtb	r3, r3
 8017570:	2b00      	cmp	r3, #0
 8017572:	d107      	bne.n	8017584 <lv_draw_sw_line+0x12a>
 8017574:	683b      	ldr	r3, [r7, #0]
 8017576:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 801757a:	f003 0304 	and.w	r3, r3, #4
 801757e:	b2db      	uxtb	r3, r3
 8017580:	2b00      	cmp	r3, #0
 8017582:	d07a      	beq.n	801767a <lv_draw_sw_line+0x220>
        lv_draw_fill_dsc_t cir_dsc;
        lv_draw_fill_dsc_init(&cir_dsc);
 8017584:	f107 030c 	add.w	r3, r7, #12
 8017588:	4618      	mov	r0, r3
 801758a:	f7f6 fbc5 	bl	800dd18 <lv_draw_fill_dsc_init>
        cir_dsc.color = dsc->color;
 801758e:	683a      	ldr	r2, [r7, #0]
 8017590:	f107 032d 	add.w	r3, r7, #45	@ 0x2d
 8017594:	322c      	adds	r2, #44	@ 0x2c
 8017596:	8811      	ldrh	r1, [r2, #0]
 8017598:	7892      	ldrb	r2, [r2, #2]
 801759a:	8019      	strh	r1, [r3, #0]
 801759c:	709a      	strb	r2, [r3, #2]
        cir_dsc.radius = LV_RADIUS_CIRCLE;
 801759e:	f647 73ff 	movw	r3, #32767	@ 0x7fff
 80175a2:	62bb      	str	r3, [r7, #40]	@ 0x28
        cir_dsc.opa = dsc->opa;
 80175a4:	683b      	ldr	r3, [r7, #0]
 80175a6:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 80175aa:	f887 302c 	strb.w	r3, [r7, #44]	@ 0x2c

        int32_t r = (dsc->width >> 1);
 80175ae:	683b      	ldr	r3, [r7, #0]
 80175b0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80175b2:	105b      	asrs	r3, r3, #1
 80175b4:	663b      	str	r3, [r7, #96]	@ 0x60
        int32_t r_corr = (dsc->width & 1) ? 0 : 1;
 80175b6:	683b      	ldr	r3, [r7, #0]
 80175b8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80175ba:	f003 0301 	and.w	r3, r3, #1
 80175be:	2b00      	cmp	r3, #0
 80175c0:	bf0c      	ite	eq
 80175c2:	2301      	moveq	r3, #1
 80175c4:	2300      	movne	r3, #0
 80175c6:	b2db      	uxtb	r3, r3
 80175c8:	65fb      	str	r3, [r7, #92]	@ 0x5c
        lv_area_t cir_area;

        if(dsc->round_start) {
 80175ca:	683b      	ldr	r3, [r7, #0]
 80175cc:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 80175d0:	f003 0304 	and.w	r3, r3, #4
 80175d4:	b2db      	uxtb	r3, r3
 80175d6:	2b00      	cmp	r3, #0
 80175d8:	d01f      	beq.n	801761a <lv_draw_sw_line+0x1c0>
            cir_area.x1 = (int32_t)dsc->p1.x - r;
 80175da:	683b      	ldr	r3, [r7, #0]
 80175dc:	69da      	ldr	r2, [r3, #28]
 80175de:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80175e0:	1ad3      	subs	r3, r2, r3
 80175e2:	63fb      	str	r3, [r7, #60]	@ 0x3c
            cir_area.y1 = (int32_t)dsc->p1.y - r;
 80175e4:	683b      	ldr	r3, [r7, #0]
 80175e6:	6a1a      	ldr	r2, [r3, #32]
 80175e8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80175ea:	1ad3      	subs	r3, r2, r3
 80175ec:	643b      	str	r3, [r7, #64]	@ 0x40
            cir_area.x2 = (int32_t)dsc->p1.x + r - r_corr;
 80175ee:	683b      	ldr	r3, [r7, #0]
 80175f0:	69da      	ldr	r2, [r3, #28]
 80175f2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80175f4:	441a      	add	r2, r3
 80175f6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 80175f8:	1ad3      	subs	r3, r2, r3
 80175fa:	647b      	str	r3, [r7, #68]	@ 0x44
            cir_area.y2 = (int32_t)dsc->p1.y + r - r_corr ;
 80175fc:	683b      	ldr	r3, [r7, #0]
 80175fe:	6a1a      	ldr	r2, [r3, #32]
 8017600:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017602:	441a      	add	r2, r3
 8017604:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017606:	1ad3      	subs	r3, r2, r3
 8017608:	64bb      	str	r3, [r7, #72]	@ 0x48
            lv_draw_sw_fill(draw_unit, &cir_dsc, &cir_area);
 801760a:	f107 023c 	add.w	r2, r7, #60	@ 0x3c
 801760e:	f107 030c 	add.w	r3, r7, #12
 8017612:	4619      	mov	r1, r3
 8017614:	6878      	ldr	r0, [r7, #4]
 8017616:	f7fe fa6a 	bl	8015aee <lv_draw_sw_fill>
        }

        if(dsc->round_end) {
 801761a:	683b      	ldr	r3, [r7, #0]
 801761c:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8017620:	f003 0308 	and.w	r3, r3, #8
 8017624:	b2db      	uxtb	r3, r3
 8017626:	2b00      	cmp	r3, #0
 8017628:	d027      	beq.n	801767a <lv_draw_sw_line+0x220>
            cir_area.x1 = (int32_t)dsc->p2.x - r;
 801762a:	683b      	ldr	r3, [r7, #0]
 801762c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801762e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017630:	1ad3      	subs	r3, r2, r3
 8017632:	63fb      	str	r3, [r7, #60]	@ 0x3c
            cir_area.y1 = (int32_t)dsc->p2.y - r;
 8017634:	683b      	ldr	r3, [r7, #0]
 8017636:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8017638:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801763a:	1ad3      	subs	r3, r2, r3
 801763c:	643b      	str	r3, [r7, #64]	@ 0x40
            cir_area.x2 = (int32_t)dsc->p2.x + r - r_corr;
 801763e:	683b      	ldr	r3, [r7, #0]
 8017640:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8017642:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017644:	441a      	add	r2, r3
 8017646:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017648:	1ad3      	subs	r3, r2, r3
 801764a:	647b      	str	r3, [r7, #68]	@ 0x44
            cir_area.y2 = (int32_t)dsc->p2.y + r - r_corr ;
 801764c:	683b      	ldr	r3, [r7, #0]
 801764e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8017650:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017652:	441a      	add	r2, r3
 8017654:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017656:	1ad3      	subs	r3, r2, r3
 8017658:	64bb      	str	r3, [r7, #72]	@ 0x48
            lv_draw_sw_fill(draw_unit, &cir_dsc, &cir_area);
 801765a:	f107 023c 	add.w	r2, r7, #60	@ 0x3c
 801765e:	f107 030c 	add.w	r3, r7, #12
 8017662:	4619      	mov	r1, r3
 8017664:	6878      	ldr	r0, [r7, #4]
 8017666:	f7fe fa42 	bl	8015aee <lv_draw_sw_fill>
 801766a:	e006      	b.n	801767a <lv_draw_sw_line+0x220>
    if(dsc->width == 0) return;
 801766c:	bf00      	nop
 801766e:	e004      	b.n	801767a <lv_draw_sw_line+0x220>
    if(dsc->opa <= LV_OPA_MIN) return;
 8017670:	bf00      	nop
 8017672:	e002      	b.n	801767a <lv_draw_sw_line+0x220>
    if(dsc->p1.x == dsc->p2.x && dsc->p1.y == dsc->p2.y) return;
 8017674:	bf00      	nop
 8017676:	e000      	b.n	801767a <lv_draw_sw_line+0x220>
    if(!is_common) return;
 8017678:	bf00      	nop
        }
    }
    LV_PROFILER_END;
}
 801767a:	3768      	adds	r7, #104	@ 0x68
 801767c:	46bd      	mov	sp, r7
 801767e:	bd80      	pop	{r7, pc}

08017680 <draw_line_hor>:

/**********************
 *   STATIC FUNCTIONS
 **********************/
static void LV_ATTRIBUTE_FAST_MEM draw_line_hor(lv_draw_unit_t * draw_unit, const lv_draw_line_dsc_t * dsc)
{
 8017680:	b580      	push	{r7, lr}
 8017682:	b09e      	sub	sp, #120	@ 0x78
 8017684:	af00      	add	r7, sp, #0
 8017686:	6078      	str	r0, [r7, #4]
 8017688:	6039      	str	r1, [r7, #0]
    int32_t w = dsc->width - 1;
 801768a:	683b      	ldr	r3, [r7, #0]
 801768c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801768e:	3b01      	subs	r3, #1
 8017690:	66bb      	str	r3, [r7, #104]	@ 0x68
    int32_t w_half0 = w >> 1;
 8017692:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017694:	105b      	asrs	r3, r3, #1
 8017696:	667b      	str	r3, [r7, #100]	@ 0x64
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
 8017698:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801769a:	f003 0301 	and.w	r3, r3, #1
 801769e:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 80176a0:	4413      	add	r3, r2
 80176a2:	663b      	str	r3, [r7, #96]	@ 0x60

    lv_area_t blend_area;
    blend_area.x1 = (int32_t)LV_MIN(dsc->p1.x, dsc->p2.x);
 80176a4:	683b      	ldr	r3, [r7, #0]
 80176a6:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80176a8:	683b      	ldr	r3, [r7, #0]
 80176aa:	69db      	ldr	r3, [r3, #28]
 80176ac:	4293      	cmp	r3, r2
 80176ae:	bfa8      	it	ge
 80176b0:	4613      	movge	r3, r2
 80176b2:	63bb      	str	r3, [r7, #56]	@ 0x38
    blend_area.x2 = (int32_t)LV_MAX(dsc->p1.x, dsc->p2.x)  - 1;
 80176b4:	683b      	ldr	r3, [r7, #0]
 80176b6:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80176b8:	683b      	ldr	r3, [r7, #0]
 80176ba:	69db      	ldr	r3, [r3, #28]
 80176bc:	4293      	cmp	r3, r2
 80176be:	bfb8      	it	lt
 80176c0:	4613      	movlt	r3, r2
 80176c2:	3b01      	subs	r3, #1
 80176c4:	643b      	str	r3, [r7, #64]	@ 0x40
    blend_area.y1 = (int32_t)dsc->p1.y - w_half1;
 80176c6:	683b      	ldr	r3, [r7, #0]
 80176c8:	6a1a      	ldr	r2, [r3, #32]
 80176ca:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80176cc:	1ad3      	subs	r3, r2, r3
 80176ce:	63fb      	str	r3, [r7, #60]	@ 0x3c
    blend_area.y2 = (int32_t)dsc->p1.y + w_half0;
 80176d0:	683b      	ldr	r3, [r7, #0]
 80176d2:	6a1a      	ldr	r2, [r3, #32]
 80176d4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80176d6:	4413      	add	r3, r2
 80176d8:	647b      	str	r3, [r7, #68]	@ 0x44

    bool is_common;
    is_common = _lv_area_intersect(&blend_area, &blend_area, draw_unit->clip_area);
 80176da:	687b      	ldr	r3, [r7, #4]
 80176dc:	689a      	ldr	r2, [r3, #8]
 80176de:	f107 0138 	add.w	r1, r7, #56	@ 0x38
 80176e2:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 80176e6:	4618      	mov	r0, r3
 80176e8:	f00a f92e 	bl	8021948 <_lv_area_intersect>
 80176ec:	4603      	mov	r3, r0
 80176ee:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
    if(!is_common) return;
 80176f2:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 80176f6:	f083 0301 	eor.w	r3, r3, #1
 80176fa:	b2db      	uxtb	r3, r3
 80176fc:	2b00      	cmp	r3, #0
 80176fe:	f040 80b5 	bne.w	801786c <draw_line_hor+0x1ec>

    bool dashed = dsc->dash_gap && dsc->dash_width;
 8017702:	683b      	ldr	r3, [r7, #0]
 8017704:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8017706:	2b00      	cmp	r3, #0
 8017708:	d005      	beq.n	8017716 <draw_line_hor+0x96>
 801770a:	683b      	ldr	r3, [r7, #0]
 801770c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801770e:	2b00      	cmp	r3, #0
 8017710:	d001      	beq.n	8017716 <draw_line_hor+0x96>
 8017712:	2301      	movs	r3, #1
 8017714:	e000      	b.n	8017718 <draw_line_hor+0x98>
 8017716:	2300      	movs	r3, #0
 8017718:	f887 305e 	strb.w	r3, [r7, #94]	@ 0x5e
 801771c:	f897 305e 	ldrb.w	r3, [r7, #94]	@ 0x5e
 8017720:	f003 0301 	and.w	r3, r3, #1
 8017724:	f887 305e 	strb.w	r3, [r7, #94]	@ 0x5e

    lv_draw_sw_blend_dsc_t blend_dsc;
    lv_memzero(&blend_dsc, sizeof(blend_dsc));
 8017728:	f107 030c 	add.w	r3, r7, #12
 801772c:	212c      	movs	r1, #44	@ 0x2c
 801772e:	4618      	mov	r0, r3
 8017730:	f7ff fe85 	bl	801743e <lv_memzero>
    blend_dsc.blend_area = &blend_area;
 8017734:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8017738:	60fb      	str	r3, [r7, #12]
    blend_dsc.color = dsc->color;
 801773a:	683a      	ldr	r2, [r7, #0]
 801773c:	f107 0321 	add.w	r3, r7, #33	@ 0x21
 8017740:	322c      	adds	r2, #44	@ 0x2c
 8017742:	8811      	ldrh	r1, [r2, #0]
 8017744:	7892      	ldrb	r2, [r2, #2]
 8017746:	8019      	strh	r1, [r3, #0]
 8017748:	709a      	strb	r2, [r3, #2]
    blend_dsc.opa = dsc->opa;
 801774a:	683b      	ldr	r3, [r7, #0]
 801774c:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8017750:	f887 3020 	strb.w	r3, [r7, #32]

    /*If there is no mask then simply draw a rectangle*/
    if(!dashed) {
 8017754:	f897 305e 	ldrb.w	r3, [r7, #94]	@ 0x5e
 8017758:	f083 0301 	eor.w	r3, r3, #1
 801775c:	b2db      	uxtb	r3, r3
 801775e:	2b00      	cmp	r3, #0
 8017760:	d006      	beq.n	8017770 <draw_line_hor+0xf0>
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 8017762:	f107 030c 	add.w	r3, r7, #12
 8017766:	4619      	mov	r1, r3
 8017768:	6878      	ldr	r0, [r7, #4]
 801776a:	f7f7 f8d3 	bl	800e914 <lv_draw_sw_blend>
 801776e:	e07e      	b.n	801786e <draw_line_hor+0x1ee>
    }
#if LV_DRAW_SW_COMPLEX
    /*If there other mask apply it*/
    else {

        int32_t blend_area_w = lv_area_get_width(&blend_area);
 8017770:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8017774:	4618      	mov	r0, r3
 8017776:	f7ff fe39 	bl	80173ec <lv_area_get_width>
 801777a:	65b8      	str	r0, [r7, #88]	@ 0x58

        int32_t y2 = blend_area.y2;
 801777c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801777e:	657b      	str	r3, [r7, #84]	@ 0x54
        blend_area.y2 = blend_area.y1;
 8017780:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017782:	647b      	str	r3, [r7, #68]	@ 0x44

        int32_t dash_start = blend_area.x1 % (dsc->dash_gap + dsc->dash_width);
 8017784:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017786:	683a      	ldr	r2, [r7, #0]
 8017788:	6b91      	ldr	r1, [r2, #56]	@ 0x38
 801778a:	683a      	ldr	r2, [r7, #0]
 801778c:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 801778e:	440a      	add	r2, r1
 8017790:	fb93 f1f2 	sdiv	r1, r3, r2
 8017794:	fb01 f202 	mul.w	r2, r1, r2
 8017798:	1a9b      	subs	r3, r3, r2
 801779a:	653b      	str	r3, [r7, #80]	@ 0x50

        lv_opa_t * mask_buf = lv_malloc(blend_area_w);
 801779c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801779e:	4618      	mov	r0, r3
 80177a0:	f00e fb12 	bl	8025dc8 <lv_malloc>
 80177a4:	64f8      	str	r0, [r7, #76]	@ 0x4c
        blend_dsc.mask_buf = mask_buf;
 80177a6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80177a8:	627b      	str	r3, [r7, #36]	@ 0x24
        blend_dsc.mask_area = &blend_area;
 80177aa:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 80177ae:	62fb      	str	r3, [r7, #44]	@ 0x2c
        blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 80177b0:	2302      	movs	r3, #2
 80177b2:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
        int32_t h;
        for(h = blend_area.y1; h <= y2; h++) {
 80177b6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80177b8:	677b      	str	r3, [r7, #116]	@ 0x74
 80177ba:	e04f      	b.n	801785c <draw_line_hor+0x1dc>
            lv_memset(mask_buf, 0xff, blend_area_w);
 80177bc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80177be:	461a      	mov	r2, r3
 80177c0:	21ff      	movs	r1, #255	@ 0xff
 80177c2:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 80177c4:	f00d fb2d 	bl	8024e22 <lv_memset>

            int32_t dash_cnt = dash_start;
 80177c8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80177ca:	673b      	str	r3, [r7, #112]	@ 0x70
            int32_t i;
            for(i = 0; i < blend_area_w; i++, dash_cnt++) {
 80177cc:	2300      	movs	r3, #0
 80177ce:	66fb      	str	r3, [r7, #108]	@ 0x6c
 80177d0:	e031      	b.n	8017836 <draw_line_hor+0x1b6>
                if(dash_cnt <= dsc->dash_width) {
 80177d2:	683b      	ldr	r3, [r7, #0]
 80177d4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80177d6:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80177d8:	429a      	cmp	r2, r3
 80177da:	dc13      	bgt.n	8017804 <draw_line_hor+0x184>
                    int16_t diff = dsc->dash_width - dash_cnt;
 80177dc:	683b      	ldr	r3, [r7, #0]
 80177de:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80177e0:	b29a      	uxth	r2, r3
 80177e2:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 80177e4:	b29b      	uxth	r3, r3
 80177e6:	1ad3      	subs	r3, r2, r3
 80177e8:	b29b      	uxth	r3, r3
 80177ea:	f8a7 304a 	strh.w	r3, [r7, #74]	@ 0x4a
                    i += diff;
 80177ee:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	@ 0x4a
 80177f2:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80177f4:	4413      	add	r3, r2
 80177f6:	66fb      	str	r3, [r7, #108]	@ 0x6c
                    dash_cnt += diff;
 80177f8:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	@ 0x4a
 80177fc:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80177fe:	4413      	add	r3, r2
 8017800:	673b      	str	r3, [r7, #112]	@ 0x70
 8017802:	e00f      	b.n	8017824 <draw_line_hor+0x1a4>
                }
                else if(dash_cnt > dsc->dash_gap + dsc->dash_width) {
 8017804:	683b      	ldr	r3, [r7, #0]
 8017806:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8017808:	683b      	ldr	r3, [r7, #0]
 801780a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801780c:	4413      	add	r3, r2
 801780e:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8017810:	429a      	cmp	r2, r3
 8017812:	dd02      	ble.n	801781a <draw_line_hor+0x19a>
                    dash_cnt = 0;
 8017814:	2300      	movs	r3, #0
 8017816:	673b      	str	r3, [r7, #112]	@ 0x70
 8017818:	e004      	b.n	8017824 <draw_line_hor+0x1a4>
                }
                else {
                    mask_buf[i] = 0x00;
 801781a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801781c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801781e:	4413      	add	r3, r2
 8017820:	2200      	movs	r2, #0
 8017822:	701a      	strb	r2, [r3, #0]
                }

                blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8017824:	2302      	movs	r3, #2
 8017826:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
            for(i = 0; i < blend_area_w; i++, dash_cnt++) {
 801782a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801782c:	3301      	adds	r3, #1
 801782e:	66fb      	str	r3, [r7, #108]	@ 0x6c
 8017830:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8017832:	3301      	adds	r3, #1
 8017834:	673b      	str	r3, [r7, #112]	@ 0x70
 8017836:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8017838:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801783a:	429a      	cmp	r2, r3
 801783c:	dbc9      	blt.n	80177d2 <draw_line_hor+0x152>
            }

            lv_draw_sw_blend(draw_unit, &blend_dsc);
 801783e:	f107 030c 	add.w	r3, r7, #12
 8017842:	4619      	mov	r1, r3
 8017844:	6878      	ldr	r0, [r7, #4]
 8017846:	f7f7 f865 	bl	800e914 <lv_draw_sw_blend>

            blend_area.y1++;
 801784a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801784c:	3301      	adds	r3, #1
 801784e:	63fb      	str	r3, [r7, #60]	@ 0x3c
            blend_area.y2++;
 8017850:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8017852:	3301      	adds	r3, #1
 8017854:	647b      	str	r3, [r7, #68]	@ 0x44
        for(h = blend_area.y1; h <= y2; h++) {
 8017856:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8017858:	3301      	adds	r3, #1
 801785a:	677b      	str	r3, [r7, #116]	@ 0x74
 801785c:	6f7a      	ldr	r2, [r7, #116]	@ 0x74
 801785e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8017860:	429a      	cmp	r2, r3
 8017862:	ddab      	ble.n	80177bc <draw_line_hor+0x13c>
        }
        lv_free(mask_buf);
 8017864:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8017866:	f00e fae7 	bl	8025e38 <lv_free>
 801786a:	e000      	b.n	801786e <draw_line_hor+0x1ee>
    if(!is_common) return;
 801786c:	bf00      	nop
    }
#endif /*LV_DRAW_SW_COMPLEX*/
}
 801786e:	3778      	adds	r7, #120	@ 0x78
 8017870:	46bd      	mov	sp, r7
 8017872:	bd80      	pop	{r7, pc}

08017874 <draw_line_ver>:

static void LV_ATTRIBUTE_FAST_MEM draw_line_ver(lv_draw_unit_t * draw_unit, const lv_draw_line_dsc_t * dsc)
{
 8017874:	b580      	push	{r7, lr}
 8017876:	b09c      	sub	sp, #112	@ 0x70
 8017878:	af00      	add	r7, sp, #0
 801787a:	6078      	str	r0, [r7, #4]
 801787c:	6039      	str	r1, [r7, #0]
    int32_t w = dsc->width - 1;
 801787e:	683b      	ldr	r3, [r7, #0]
 8017880:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8017882:	3b01      	subs	r3, #1
 8017884:	667b      	str	r3, [r7, #100]	@ 0x64
    int32_t w_half0 = w >> 1;
 8017886:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8017888:	105b      	asrs	r3, r3, #1
 801788a:	663b      	str	r3, [r7, #96]	@ 0x60
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
 801788c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801788e:	f003 0301 	and.w	r3, r3, #1
 8017892:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8017894:	4413      	add	r3, r2
 8017896:	65fb      	str	r3, [r7, #92]	@ 0x5c

    lv_area_t blend_area;
    blend_area.x1 = (int32_t)dsc->p1.x - w_half1;
 8017898:	683b      	ldr	r3, [r7, #0]
 801789a:	69da      	ldr	r2, [r3, #28]
 801789c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801789e:	1ad3      	subs	r3, r2, r3
 80178a0:	63bb      	str	r3, [r7, #56]	@ 0x38
    blend_area.x2 = (int32_t)dsc->p1.x + w_half0;
 80178a2:	683b      	ldr	r3, [r7, #0]
 80178a4:	69da      	ldr	r2, [r3, #28]
 80178a6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80178a8:	4413      	add	r3, r2
 80178aa:	643b      	str	r3, [r7, #64]	@ 0x40
    blend_area.y1 = (int32_t)LV_MIN(dsc->p1.y, dsc->p2.y);
 80178ac:	683b      	ldr	r3, [r7, #0]
 80178ae:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80178b0:	683b      	ldr	r3, [r7, #0]
 80178b2:	6a1b      	ldr	r3, [r3, #32]
 80178b4:	4293      	cmp	r3, r2
 80178b6:	bfa8      	it	ge
 80178b8:	4613      	movge	r3, r2
 80178ba:	63fb      	str	r3, [r7, #60]	@ 0x3c
    blend_area.y2 = (int32_t)LV_MAX(dsc->p1.y, dsc->p2.y) - 1;
 80178bc:	683b      	ldr	r3, [r7, #0]
 80178be:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 80178c0:	683b      	ldr	r3, [r7, #0]
 80178c2:	6a1b      	ldr	r3, [r3, #32]
 80178c4:	4293      	cmp	r3, r2
 80178c6:	bfb8      	it	lt
 80178c8:	4613      	movlt	r3, r2
 80178ca:	3b01      	subs	r3, #1
 80178cc:	647b      	str	r3, [r7, #68]	@ 0x44

    bool is_common;
    is_common = _lv_area_intersect(&blend_area, &blend_area, draw_unit->clip_area);
 80178ce:	687b      	ldr	r3, [r7, #4]
 80178d0:	689a      	ldr	r2, [r3, #8]
 80178d2:	f107 0138 	add.w	r1, r7, #56	@ 0x38
 80178d6:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 80178da:	4618      	mov	r0, r3
 80178dc:	f00a f834 	bl	8021948 <_lv_area_intersect>
 80178e0:	4603      	mov	r3, r0
 80178e2:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
    if(!is_common) return;
 80178e6:	f897 305b 	ldrb.w	r3, [r7, #91]	@ 0x5b
 80178ea:	f083 0301 	eor.w	r3, r3, #1
 80178ee:	b2db      	uxtb	r3, r3
 80178f0:	2b00      	cmp	r3, #0
 80178f2:	f040 8095 	bne.w	8017a20 <draw_line_ver+0x1ac>

    bool dashed = dsc->dash_gap && dsc->dash_width;
 80178f6:	683b      	ldr	r3, [r7, #0]
 80178f8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80178fa:	2b00      	cmp	r3, #0
 80178fc:	d005      	beq.n	801790a <draw_line_ver+0x96>
 80178fe:	683b      	ldr	r3, [r7, #0]
 8017900:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8017902:	2b00      	cmp	r3, #0
 8017904:	d001      	beq.n	801790a <draw_line_ver+0x96>
 8017906:	2301      	movs	r3, #1
 8017908:	e000      	b.n	801790c <draw_line_ver+0x98>
 801790a:	2300      	movs	r3, #0
 801790c:	f887 305a 	strb.w	r3, [r7, #90]	@ 0x5a
 8017910:	f897 305a 	ldrb.w	r3, [r7, #90]	@ 0x5a
 8017914:	f003 0301 	and.w	r3, r3, #1
 8017918:	f887 305a 	strb.w	r3, [r7, #90]	@ 0x5a

    lv_draw_sw_blend_dsc_t blend_dsc;
    lv_memzero(&blend_dsc, sizeof(blend_dsc));
 801791c:	f107 030c 	add.w	r3, r7, #12
 8017920:	212c      	movs	r1, #44	@ 0x2c
 8017922:	4618      	mov	r0, r3
 8017924:	f7ff fd8b 	bl	801743e <lv_memzero>
    blend_dsc.blend_area = &blend_area;
 8017928:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 801792c:	60fb      	str	r3, [r7, #12]
    blend_dsc.color = dsc->color;
 801792e:	683a      	ldr	r2, [r7, #0]
 8017930:	f107 0321 	add.w	r3, r7, #33	@ 0x21
 8017934:	322c      	adds	r2, #44	@ 0x2c
 8017936:	8811      	ldrh	r1, [r2, #0]
 8017938:	7892      	ldrb	r2, [r2, #2]
 801793a:	8019      	strh	r1, [r3, #0]
 801793c:	709a      	strb	r2, [r3, #2]
    blend_dsc.opa = dsc->opa;
 801793e:	683b      	ldr	r3, [r7, #0]
 8017940:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8017944:	f887 3020 	strb.w	r3, [r7, #32]

    /*If there is no mask then simply draw a rectangle*/
    if(!dashed) {
 8017948:	f897 305a 	ldrb.w	r3, [r7, #90]	@ 0x5a
 801794c:	f083 0301 	eor.w	r3, r3, #1
 8017950:	b2db      	uxtb	r3, r3
 8017952:	2b00      	cmp	r3, #0
 8017954:	d006      	beq.n	8017964 <draw_line_ver+0xf0>
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 8017956:	f107 030c 	add.w	r3, r7, #12
 801795a:	4619      	mov	r1, r3
 801795c:	6878      	ldr	r0, [r7, #4]
 801795e:	f7f6 ffd9 	bl	800e914 <lv_draw_sw_blend>
 8017962:	e05e      	b.n	8017a22 <draw_line_ver+0x1ae>
    }

#if LV_DRAW_SW_COMPLEX
    /*If there other mask apply it*/
    else {
        int32_t draw_area_w = lv_area_get_width(&blend_area);
 8017964:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8017968:	4618      	mov	r0, r3
 801796a:	f7ff fd3f 	bl	80173ec <lv_area_get_width>
 801796e:	6578      	str	r0, [r7, #84]	@ 0x54

        int32_t y2 = blend_area.y2;
 8017970:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8017972:	653b      	str	r3, [r7, #80]	@ 0x50
        blend_area.y2 = blend_area.y1;
 8017974:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017976:	647b      	str	r3, [r7, #68]	@ 0x44

        lv_opa_t * mask_buf = lv_malloc(draw_area_w);
 8017978:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801797a:	4618      	mov	r0, r3
 801797c:	f00e fa24 	bl	8025dc8 <lv_malloc>
 8017980:	64f8      	str	r0, [r7, #76]	@ 0x4c
        blend_dsc.mask_buf = mask_buf;
 8017982:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8017984:	627b      	str	r3, [r7, #36]	@ 0x24
        blend_dsc.mask_area = &blend_area;
 8017986:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 801798a:	62fb      	str	r3, [r7, #44]	@ 0x2c
        blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 801798c:	2302      	movs	r3, #2
 801798e:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
        int32_t dash_start = (blend_area.y1) % (dsc->dash_gap + dsc->dash_width);
 8017992:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017994:	683a      	ldr	r2, [r7, #0]
 8017996:	6b91      	ldr	r1, [r2, #56]	@ 0x38
 8017998:	683a      	ldr	r2, [r7, #0]
 801799a:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 801799c:	440a      	add	r2, r1
 801799e:	fb93 f1f2 	sdiv	r1, r3, r2
 80179a2:	fb01 f202 	mul.w	r2, r1, r2
 80179a6:	1a9b      	subs	r3, r3, r2
 80179a8:	64bb      	str	r3, [r7, #72]	@ 0x48

        int32_t dash_cnt = dash_start;
 80179aa:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80179ac:	66fb      	str	r3, [r7, #108]	@ 0x6c

        int32_t h;
        for(h = blend_area.y1; h <= y2; h++) {
 80179ae:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80179b0:	66bb      	str	r3, [r7, #104]	@ 0x68
 80179b2:	e02d      	b.n	8017a10 <draw_line_ver+0x19c>
            lv_memset(mask_buf, 0xff, draw_area_w);
 80179b4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 80179b6:	461a      	mov	r2, r3
 80179b8:	21ff      	movs	r1, #255	@ 0xff
 80179ba:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 80179bc:	f00d fa31 	bl	8024e22 <lv_memset>

            if(dash_cnt > dsc->dash_width) {
 80179c0:	683b      	ldr	r3, [r7, #0]
 80179c2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80179c4:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80179c6:	429a      	cmp	r2, r3
 80179c8:	dd03      	ble.n	80179d2 <draw_line_ver+0x15e>
                blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_TRANSP;
 80179ca:	2300      	movs	r3, #0
 80179cc:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
 80179d0:	e002      	b.n	80179d8 <draw_line_ver+0x164>
            }
            else {
                blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_FULL_COVER;
 80179d2:	2301      	movs	r3, #1
 80179d4:	f887 3028 	strb.w	r3, [r7, #40]	@ 0x28
            }

            if(dash_cnt >= dsc->dash_gap + dsc->dash_width) {
 80179d8:	683b      	ldr	r3, [r7, #0]
 80179da:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 80179dc:	683b      	ldr	r3, [r7, #0]
 80179de:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80179e0:	4413      	add	r3, r2
 80179e2:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80179e4:	429a      	cmp	r2, r3
 80179e6:	db01      	blt.n	80179ec <draw_line_ver+0x178>
                dash_cnt = 0;
 80179e8:	2300      	movs	r3, #0
 80179ea:	66fb      	str	r3, [r7, #108]	@ 0x6c
            }
            dash_cnt ++;
 80179ec:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80179ee:	3301      	adds	r3, #1
 80179f0:	66fb      	str	r3, [r7, #108]	@ 0x6c

            lv_draw_sw_blend(draw_unit, &blend_dsc);
 80179f2:	f107 030c 	add.w	r3, r7, #12
 80179f6:	4619      	mov	r1, r3
 80179f8:	6878      	ldr	r0, [r7, #4]
 80179fa:	f7f6 ff8b 	bl	800e914 <lv_draw_sw_blend>

            blend_area.y1++;
 80179fe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017a00:	3301      	adds	r3, #1
 8017a02:	63fb      	str	r3, [r7, #60]	@ 0x3c
            blend_area.y2++;
 8017a04:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8017a06:	3301      	adds	r3, #1
 8017a08:	647b      	str	r3, [r7, #68]	@ 0x44
        for(h = blend_area.y1; h <= y2; h++) {
 8017a0a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8017a0c:	3301      	adds	r3, #1
 8017a0e:	66bb      	str	r3, [r7, #104]	@ 0x68
 8017a10:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8017a12:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8017a14:	429a      	cmp	r2, r3
 8017a16:	ddcd      	ble.n	80179b4 <draw_line_ver+0x140>
        }
        lv_free(mask_buf);
 8017a18:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 8017a1a:	f00e fa0d 	bl	8025e38 <lv_free>
 8017a1e:	e000      	b.n	8017a22 <draw_line_ver+0x1ae>
    if(!is_common) return;
 8017a20:	bf00      	nop
    }
#endif /*LV_DRAW_SW_COMPLEX*/
}
 8017a22:	3770      	adds	r7, #112	@ 0x70
 8017a24:	46bd      	mov	sp, r7
 8017a26:	bd80      	pop	{r7, pc}

08017a28 <draw_line_skew>:

static void LV_ATTRIBUTE_FAST_MEM draw_line_skew(lv_draw_unit_t * draw_unit, const lv_draw_line_dsc_t * dsc)
{
 8017a28:	b5b0      	push	{r4, r5, r7, lr}
 8017a2a:	b0e6      	sub	sp, #408	@ 0x198
 8017a2c:	af02      	add	r7, sp, #8
 8017a2e:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017a32:	f5a3 73c2 	sub.w	r3, r3, #388	@ 0x184
 8017a36:	6018      	str	r0, [r3, #0]
 8017a38:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017a3c:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 8017a40:	6019      	str	r1, [r3, #0]
#if LV_DRAW_SW_COMPLEX
    /*Keep the great y in p1*/
    lv_point_t p1;
    lv_point_t p2;
    if(dsc->p1.y < dsc->p2.y) {
 8017a42:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017a46:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 8017a4a:	681b      	ldr	r3, [r3, #0]
 8017a4c:	6a1a      	ldr	r2, [r3, #32]
 8017a4e:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017a52:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 8017a56:	681b      	ldr	r3, [r3, #0]
 8017a58:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8017a5a:	429a      	cmp	r2, r3
 8017a5c:	da1a      	bge.n	8017a94 <draw_line_skew+0x6c>
        p1 = lv_point_from_precise(&dsc->p1);
 8017a5e:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017a62:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 8017a66:	681b      	ldr	r3, [r3, #0]
 8017a68:	f103 021c 	add.w	r2, r3, #28
 8017a6c:	f507 73a6 	add.w	r3, r7, #332	@ 0x14c
 8017a70:	4611      	mov	r1, r2
 8017a72:	4618      	mov	r0, r3
 8017a74:	f7ff fcca 	bl	801740c <lv_point_from_precise>
        p2 = lv_point_from_precise(&dsc->p2);
 8017a78:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017a7c:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 8017a80:	681b      	ldr	r3, [r3, #0]
 8017a82:	f103 0224 	add.w	r2, r3, #36	@ 0x24
 8017a86:	f507 73a2 	add.w	r3, r7, #324	@ 0x144
 8017a8a:	4611      	mov	r1, r2
 8017a8c:	4618      	mov	r0, r3
 8017a8e:	f7ff fcbd 	bl	801740c <lv_point_from_precise>
 8017a92:	e02b      	b.n	8017aec <draw_line_skew+0xc4>
    }
    else {
        p1 = lv_point_from_precise(&dsc->p2);
 8017a94:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017a98:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 8017a9c:	681b      	ldr	r3, [r3, #0]
 8017a9e:	f103 0224 	add.w	r2, r3, #36	@ 0x24
 8017aa2:	463b      	mov	r3, r7
 8017aa4:	4611      	mov	r1, r2
 8017aa6:	4618      	mov	r0, r3
 8017aa8:	f7ff fcb0 	bl	801740c <lv_point_from_precise>
 8017aac:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017ab0:	f5a3 72c8 	sub.w	r2, r3, #400	@ 0x190
 8017ab4:	f507 73a6 	add.w	r3, r7, #332	@ 0x14c
 8017ab8:	e892 0003 	ldmia.w	r2, {r0, r1}
 8017abc:	e883 0003 	stmia.w	r3, {r0, r1}
        p2 = lv_point_from_precise(&dsc->p1);
 8017ac0:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017ac4:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 8017ac8:	681b      	ldr	r3, [r3, #0]
 8017aca:	f103 021c 	add.w	r2, r3, #28
 8017ace:	463b      	mov	r3, r7
 8017ad0:	4611      	mov	r1, r2
 8017ad2:	4618      	mov	r0, r3
 8017ad4:	f7ff fc9a 	bl	801740c <lv_point_from_precise>
 8017ad8:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017adc:	f5a3 72c8 	sub.w	r2, r3, #400	@ 0x190
 8017ae0:	f507 73a2 	add.w	r3, r7, #324	@ 0x144
 8017ae4:	e892 0003 	ldmia.w	r2, {r0, r1}
 8017ae8:	e883 0003 	stmia.w	r3, {r0, r1}
    }

    int32_t xdiff = p2.x - p1.x;
 8017aec:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8017af0:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8017af4:	1ad3      	subs	r3, r2, r3
 8017af6:	f8c7 3180 	str.w	r3, [r7, #384]	@ 0x180
    int32_t ydiff = p2.y - p1.y;
 8017afa:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8017afe:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8017b02:	1ad3      	subs	r3, r2, r3
 8017b04:	f8c7 317c 	str.w	r3, [r7, #380]	@ 0x17c
    bool flat = LV_ABS(xdiff) > LV_ABS(ydiff);
 8017b08:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8017b0c:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8017b10:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 8017b14:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8017b18:	2b00      	cmp	r3, #0
 8017b1a:	bfb8      	it	lt
 8017b1c:	425b      	neglt	r3, r3
 8017b1e:	429a      	cmp	r2, r3
 8017b20:	bfcc      	ite	gt
 8017b22:	2301      	movgt	r3, #1
 8017b24:	2300      	movle	r3, #0
 8017b26:	f887 317b 	strb.w	r3, [r7, #379]	@ 0x17b
        143, 145, 147, 149, 151, 153, 155, 158,
        160, 162, 165, 167, 170, 173, 175, 178,
        181,
    };

    int32_t w = dsc->width;
 8017b2a:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017b2e:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 8017b32:	681b      	ldr	r3, [r3, #0]
 8017b34:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8017b36:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
    int32_t wcorr_i = 0;
 8017b3a:	2300      	movs	r3, #0
 8017b3c:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
    if(flat) wcorr_i = (LV_ABS(ydiff) << 5) / LV_ABS(xdiff);
 8017b40:	f897 317b 	ldrb.w	r3, [r7, #379]	@ 0x17b
 8017b44:	2b00      	cmp	r3, #0
 8017b46:	d00f      	beq.n	8017b68 <draw_line_skew+0x140>
 8017b48:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8017b4c:	2b00      	cmp	r3, #0
 8017b4e:	bfb8      	it	lt
 8017b50:	425b      	neglt	r3, r3
 8017b52:	015a      	lsls	r2, r3, #5
 8017b54:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8017b58:	2b00      	cmp	r3, #0
 8017b5a:	bfb8      	it	lt
 8017b5c:	425b      	neglt	r3, r3
 8017b5e:	fb92 f3f3 	sdiv	r3, r2, r3
 8017b62:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c
 8017b66:	e00e      	b.n	8017b86 <draw_line_skew+0x15e>
    else wcorr_i = (LV_ABS(xdiff) << 5) / LV_ABS(ydiff);
 8017b68:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8017b6c:	2b00      	cmp	r3, #0
 8017b6e:	bfb8      	it	lt
 8017b70:	425b      	neglt	r3, r3
 8017b72:	015a      	lsls	r2, r3, #5
 8017b74:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8017b78:	2b00      	cmp	r3, #0
 8017b7a:	bfb8      	it	lt
 8017b7c:	425b      	neglt	r3, r3
 8017b7e:	fb92 f3f3 	sdiv	r3, r2, r3
 8017b82:	f8c7 318c 	str.w	r3, [r7, #396]	@ 0x18c

    w = (w * wcorr[wcorr_i] + 63) >> 7;     /*+ 63 for rounding*/
 8017b86:	4ac0      	ldr	r2, [pc, #768]	@ (8017e88 <draw_line_skew+0x460>)
 8017b88:	f8d7 318c 	ldr.w	r3, [r7, #396]	@ 0x18c
 8017b8c:	4413      	add	r3, r2
 8017b8e:	781b      	ldrb	r3, [r3, #0]
 8017b90:	461a      	mov	r2, r3
 8017b92:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8017b96:	fb02 f303 	mul.w	r3, r2, r3
 8017b9a:	333f      	adds	r3, #63	@ 0x3f
 8017b9c:	11db      	asrs	r3, r3, #7
 8017b9e:	f8c7 3174 	str.w	r3, [r7, #372]	@ 0x174
    int32_t w_half0 = w >> 1;
 8017ba2:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8017ba6:	105b      	asrs	r3, r3, #1
 8017ba8:	f8c7 3170 	str.w	r3, [r7, #368]	@ 0x170
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
 8017bac:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8017bb0:	f003 0301 	and.w	r3, r3, #1
 8017bb4:	f8d7 2170 	ldr.w	r2, [r7, #368]	@ 0x170
 8017bb8:	4413      	add	r3, r2
 8017bba:	f8c7 316c 	str.w	r3, [r7, #364]	@ 0x16c

    lv_area_t blend_area;
    blend_area.x1 = LV_MIN(p1.x, p2.x) - w;
 8017bbe:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8017bc2:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8017bc6:	429a      	cmp	r2, r3
 8017bc8:	bfa8      	it	ge
 8017bca:	461a      	movge	r2, r3
 8017bcc:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8017bd0:	1ad3      	subs	r3, r2, r3
 8017bd2:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    blend_area.x2 = LV_MAX(p1.x, p2.x) + w;
 8017bd6:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8017bda:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 8017bde:	429a      	cmp	r2, r3
 8017be0:	bfb8      	it	lt
 8017be2:	461a      	movlt	r2, r3
 8017be4:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8017be8:	4413      	add	r3, r2
 8017bea:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
    blend_area.y1 = LV_MIN(p1.y, p2.y) - w;
 8017bee:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8017bf2:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8017bf6:	429a      	cmp	r2, r3
 8017bf8:	bfa8      	it	ge
 8017bfa:	461a      	movge	r2, r3
 8017bfc:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8017c00:	1ad3      	subs	r3, r2, r3
 8017c02:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    blend_area.y2 = LV_MAX(p1.y, p2.y) + w;
 8017c06:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8017c0a:	f8d7 3150 	ldr.w	r3, [r7, #336]	@ 0x150
 8017c0e:	429a      	cmp	r2, r3
 8017c10:	bfb8      	it	lt
 8017c12:	461a      	movlt	r2, r3
 8017c14:	f8d7 3174 	ldr.w	r3, [r7, #372]	@ 0x174
 8017c18:	4413      	add	r3, r2
 8017c1a:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

    /*Get the union of `coords` and `clip`*/
    /*`clip` is already truncated to the `draw_buf` size
     *in 'lv_refr_area' function*/
    bool is_common = _lv_area_intersect(&blend_area, &blend_area, draw_unit->clip_area);
 8017c1e:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017c22:	f5a3 73c2 	sub.w	r3, r3, #388	@ 0x184
 8017c26:	681b      	ldr	r3, [r3, #0]
 8017c28:	689a      	ldr	r2, [r3, #8]
 8017c2a:	f507 719a 	add.w	r1, r7, #308	@ 0x134
 8017c2e:	f507 739a 	add.w	r3, r7, #308	@ 0x134
 8017c32:	4618      	mov	r0, r3
 8017c34:	f009 fe88 	bl	8021948 <_lv_area_intersect>
 8017c38:	4603      	mov	r3, r0
 8017c3a:	f887 316b 	strb.w	r3, [r7, #363]	@ 0x16b
    if(is_common == false) return;
 8017c3e:	f897 316b 	ldrb.w	r3, [r7, #363]	@ 0x16b
 8017c42:	f083 0301 	eor.w	r3, r3, #1
 8017c46:	b2db      	uxtb	r3, r3
 8017c48:	2b00      	cmp	r3, #0
 8017c4a:	f040 8223 	bne.w	8018094 <draw_line_skew+0x66c>
    lv_draw_sw_mask_line_param_t mask_left_param;
    lv_draw_sw_mask_line_param_t mask_right_param;
    lv_draw_sw_mask_line_param_t mask_top_param;
    lv_draw_sw_mask_line_param_t mask_bottom_param;

    void * masks[5] = {&mask_left_param, & mask_right_param, NULL, NULL, NULL};
 8017c4e:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017c52:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 8017c56:	f107 02fc 	add.w	r2, r7, #252	@ 0xfc
 8017c5a:	601a      	str	r2, [r3, #0]
 8017c5c:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017c60:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 8017c64:	f107 02c4 	add.w	r2, r7, #196	@ 0xc4
 8017c68:	605a      	str	r2, [r3, #4]
 8017c6a:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017c6e:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 8017c72:	2200      	movs	r2, #0
 8017c74:	609a      	str	r2, [r3, #8]
 8017c76:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017c7a:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 8017c7e:	2200      	movs	r2, #0
 8017c80:	60da      	str	r2, [r3, #12]
 8017c82:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017c86:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 8017c8a:	2200      	movs	r2, #0
 8017c8c:	611a      	str	r2, [r3, #16]

    if(flat) {
 8017c8e:	f897 317b 	ldrb.w	r3, [r7, #379]	@ 0x17b
 8017c92:	2b00      	cmp	r3, #0
 8017c94:	d061      	beq.n	8017d5a <draw_line_skew+0x332>
        if(xdiff > 0) {
 8017c96:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8017c9a:	2b00      	cmp	r3, #0
 8017c9c:	dd2e      	ble.n	8017cfc <draw_line_skew+0x2d4>
            lv_draw_sw_mask_line_points_init(&mask_left_param, p1.x, p1.y - w_half0, p2.x, p2.y - w_half0,
 8017c9e:	f8d7 114c 	ldr.w	r1, [r7, #332]	@ 0x14c
 8017ca2:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8017ca6:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8017caa:	1ad4      	subs	r4, r2, r3
 8017cac:	f8d7 5144 	ldr.w	r5, [r7, #324]	@ 0x144
 8017cb0:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8017cb4:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8017cb8:	1ad3      	subs	r3, r2, r3
 8017cba:	f107 00fc 	add.w	r0, r7, #252	@ 0xfc
 8017cbe:	2200      	movs	r2, #0
 8017cc0:	9201      	str	r2, [sp, #4]
 8017cc2:	9300      	str	r3, [sp, #0]
 8017cc4:	462b      	mov	r3, r5
 8017cc6:	4622      	mov	r2, r4
 8017cc8:	f000 fac4 	bl	8018254 <lv_draw_sw_mask_line_points_init>
                                             LV_DRAW_SW_MASK_LINE_SIDE_LEFT);
            lv_draw_sw_mask_line_points_init(&mask_right_param, p1.x, p1.y + w_half1, p2.x, p2.y + w_half1,
 8017ccc:	f8d7 114c 	ldr.w	r1, [r7, #332]	@ 0x14c
 8017cd0:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8017cd4:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8017cd8:	18d4      	adds	r4, r2, r3
 8017cda:	f8d7 5144 	ldr.w	r5, [r7, #324]	@ 0x144
 8017cde:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8017ce2:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8017ce6:	4413      	add	r3, r2
 8017ce8:	f107 00c4 	add.w	r0, r7, #196	@ 0xc4
 8017cec:	2201      	movs	r2, #1
 8017cee:	9201      	str	r2, [sp, #4]
 8017cf0:	9300      	str	r3, [sp, #0]
 8017cf2:	462b      	mov	r3, r5
 8017cf4:	4622      	mov	r2, r4
 8017cf6:	f000 faad 	bl	8018254 <lv_draw_sw_mask_line_points_init>
 8017cfa:	e05c      	b.n	8017db6 <draw_line_skew+0x38e>
                                             LV_DRAW_SW_MASK_LINE_SIDE_RIGHT);
        }
        else {
            lv_draw_sw_mask_line_points_init(&mask_left_param, p1.x, p1.y + w_half1, p2.x, p2.y + w_half1,
 8017cfc:	f8d7 114c 	ldr.w	r1, [r7, #332]	@ 0x14c
 8017d00:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8017d04:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8017d08:	18d4      	adds	r4, r2, r3
 8017d0a:	f8d7 5144 	ldr.w	r5, [r7, #324]	@ 0x144
 8017d0e:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8017d12:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8017d16:	4413      	add	r3, r2
 8017d18:	f107 00fc 	add.w	r0, r7, #252	@ 0xfc
 8017d1c:	2200      	movs	r2, #0
 8017d1e:	9201      	str	r2, [sp, #4]
 8017d20:	9300      	str	r3, [sp, #0]
 8017d22:	462b      	mov	r3, r5
 8017d24:	4622      	mov	r2, r4
 8017d26:	f000 fa95 	bl	8018254 <lv_draw_sw_mask_line_points_init>
                                             LV_DRAW_SW_MASK_LINE_SIDE_LEFT);
            lv_draw_sw_mask_line_points_init(&mask_right_param, p1.x, p1.y - w_half0, p2.x, p2.y - w_half0,
 8017d2a:	f8d7 114c 	ldr.w	r1, [r7, #332]	@ 0x14c
 8017d2e:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8017d32:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8017d36:	1ad4      	subs	r4, r2, r3
 8017d38:	f8d7 5144 	ldr.w	r5, [r7, #324]	@ 0x144
 8017d3c:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8017d40:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8017d44:	1ad3      	subs	r3, r2, r3
 8017d46:	f107 00c4 	add.w	r0, r7, #196	@ 0xc4
 8017d4a:	2201      	movs	r2, #1
 8017d4c:	9201      	str	r2, [sp, #4]
 8017d4e:	9300      	str	r3, [sp, #0]
 8017d50:	462b      	mov	r3, r5
 8017d52:	4622      	mov	r2, r4
 8017d54:	f000 fa7e 	bl	8018254 <lv_draw_sw_mask_line_points_init>
 8017d58:	e02d      	b.n	8017db6 <draw_line_skew+0x38e>
                                             LV_DRAW_SW_MASK_LINE_SIDE_RIGHT);
        }
    }
    else {
        lv_draw_sw_mask_line_points_init(&mask_left_param, p1.x + w_half1, p1.y, p2.x + w_half1, p2.y,
 8017d5a:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8017d5e:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8017d62:	18d1      	adds	r1, r2, r3
 8017d64:	f8d7 4150 	ldr.w	r4, [r7, #336]	@ 0x150
 8017d68:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8017d6c:	f8d7 316c 	ldr.w	r3, [r7, #364]	@ 0x16c
 8017d70:	441a      	add	r2, r3
 8017d72:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8017d76:	f107 00fc 	add.w	r0, r7, #252	@ 0xfc
 8017d7a:	2500      	movs	r5, #0
 8017d7c:	9501      	str	r5, [sp, #4]
 8017d7e:	9300      	str	r3, [sp, #0]
 8017d80:	4613      	mov	r3, r2
 8017d82:	4622      	mov	r2, r4
 8017d84:	f000 fa66 	bl	8018254 <lv_draw_sw_mask_line_points_init>
                                         LV_DRAW_SW_MASK_LINE_SIDE_LEFT);
        lv_draw_sw_mask_line_points_init(&mask_right_param, p1.x - w_half0, p1.y, p2.x - w_half0, p2.y,
 8017d88:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8017d8c:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8017d90:	1ad1      	subs	r1, r2, r3
 8017d92:	f8d7 4150 	ldr.w	r4, [r7, #336]	@ 0x150
 8017d96:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8017d9a:	f8d7 3170 	ldr.w	r3, [r7, #368]	@ 0x170
 8017d9e:	1ad2      	subs	r2, r2, r3
 8017da0:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 8017da4:	f107 00c4 	add.w	r0, r7, #196	@ 0xc4
 8017da8:	2501      	movs	r5, #1
 8017daa:	9501      	str	r5, [sp, #4]
 8017dac:	9300      	str	r3, [sp, #0]
 8017dae:	4613      	mov	r3, r2
 8017db0:	4622      	mov	r2, r4
 8017db2:	f000 fa4f 	bl	8018254 <lv_draw_sw_mask_line_points_init>

    }

    /*Use the normal vector for the endings*/

    if(!dsc->raw_end) {
 8017db6:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017dba:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 8017dbe:	681b      	ldr	r3, [r3, #0]
 8017dc0:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8017dc4:	f003 0310 	and.w	r3, r3, #16
 8017dc8:	b2db      	uxtb	r3, r3
 8017dca:	2b00      	cmp	r3, #0
 8017dcc:	d13b      	bne.n	8017e46 <draw_line_skew+0x41e>
        lv_draw_sw_mask_line_points_init(&mask_top_param, p1.x, p1.y, p1.x - ydiff, p1.y + xdiff,
 8017dce:	f8d7 114c 	ldr.w	r1, [r7, #332]	@ 0x14c
 8017dd2:	f8d7 4150 	ldr.w	r4, [r7, #336]	@ 0x150
 8017dd6:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 8017dda:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8017dde:	1ad5      	subs	r5, r2, r3
 8017de0:	f8d7 2150 	ldr.w	r2, [r7, #336]	@ 0x150
 8017de4:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8017de8:	4413      	add	r3, r2
 8017dea:	f107 008c 	add.w	r0, r7, #140	@ 0x8c
 8017dee:	2203      	movs	r2, #3
 8017df0:	9201      	str	r2, [sp, #4]
 8017df2:	9300      	str	r3, [sp, #0]
 8017df4:	462b      	mov	r3, r5
 8017df6:	4622      	mov	r2, r4
 8017df8:	f000 fa2c 	bl	8018254 <lv_draw_sw_mask_line_points_init>
                                         LV_DRAW_SW_MASK_LINE_SIDE_BOTTOM);
        lv_draw_sw_mask_line_points_init(&mask_bottom_param, p2.x, p2.y, p2.x - ydiff, p2.y + xdiff,
 8017dfc:	f8d7 1144 	ldr.w	r1, [r7, #324]	@ 0x144
 8017e00:	f8d7 4148 	ldr.w	r4, [r7, #328]	@ 0x148
 8017e04:	f8d7 2144 	ldr.w	r2, [r7, #324]	@ 0x144
 8017e08:	f8d7 317c 	ldr.w	r3, [r7, #380]	@ 0x17c
 8017e0c:	1ad5      	subs	r5, r2, r3
 8017e0e:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 8017e12:	f8d7 3180 	ldr.w	r3, [r7, #384]	@ 0x180
 8017e16:	4413      	add	r3, r2
 8017e18:	f107 0054 	add.w	r0, r7, #84	@ 0x54
 8017e1c:	2202      	movs	r2, #2
 8017e1e:	9201      	str	r2, [sp, #4]
 8017e20:	9300      	str	r3, [sp, #0]
 8017e22:	462b      	mov	r3, r5
 8017e24:	4622      	mov	r2, r4
 8017e26:	f000 fa15 	bl	8018254 <lv_draw_sw_mask_line_points_init>
                                         LV_DRAW_SW_MASK_LINE_SIDE_TOP);
        masks[2] = &mask_top_param;
 8017e2a:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017e2e:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 8017e32:	f107 028c 	add.w	r2, r7, #140	@ 0x8c
 8017e36:	609a      	str	r2, [r3, #8]
        masks[3] = &mask_bottom_param;
 8017e38:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017e3c:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 8017e40:	f107 0254 	add.w	r2, r7, #84	@ 0x54
 8017e44:	60da      	str	r2, [r3, #12]
    }

    /*The real draw area is around the line.
     *It's easy to calculate with steep lines, but the area can be very wide with very flat lines.
     *So deal with it only with steep lines.*/
    int32_t draw_area_w = lv_area_get_width(&blend_area);
 8017e46:	f507 739a 	add.w	r3, r7, #308	@ 0x134
 8017e4a:	4618      	mov	r0, r3
 8017e4c:	f7ff face 	bl	80173ec <lv_area_get_width>
 8017e50:	f8c7 0164 	str.w	r0, [r7, #356]	@ 0x164

    /*Draw the background line by line*/
    int32_t h;
    uint32_t hor_res = (uint32_t)lv_display_get_horizontal_resolution(_lv_refr_get_disp_refreshing());
 8017e54:	f7f3 f92a 	bl	800b0ac <_lv_refr_get_disp_refreshing>
 8017e58:	4603      	mov	r3, r0
 8017e5a:	4618      	mov	r0, r3
 8017e5c:	f7f3 f964 	bl	800b128 <lv_display_get_horizontal_resolution>
 8017e60:	4603      	mov	r3, r0
 8017e62:	f8c7 3160 	str.w	r3, [r7, #352]	@ 0x160
    size_t mask_buf_size = LV_MIN(lv_area_get_size(&blend_area), hor_res);
 8017e66:	f507 739a 	add.w	r3, r7, #308	@ 0x134
 8017e6a:	4618      	mov	r0, r3
 8017e6c:	f009 fd09 	bl	8021882 <lv_area_get_size>
 8017e70:	4602      	mov	r2, r0
 8017e72:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8017e76:	4293      	cmp	r3, r2
 8017e78:	d908      	bls.n	8017e8c <draw_line_skew+0x464>
 8017e7a:	f507 739a 	add.w	r3, r7, #308	@ 0x134
 8017e7e:	4618      	mov	r0, r3
 8017e80:	f009 fcff 	bl	8021882 <lv_area_get_size>
 8017e84:	4603      	mov	r3, r0
 8017e86:	e003      	b.n	8017e90 <draw_line_skew+0x468>
 8017e88:	08027bf4 	.word	0x08027bf4
 8017e8c:	f8d7 3160 	ldr.w	r3, [r7, #352]	@ 0x160
 8017e90:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    lv_opa_t * mask_buf = lv_malloc(mask_buf_size);
 8017e94:	f8d7 015c 	ldr.w	r0, [r7, #348]	@ 0x15c
 8017e98:	f00d ff96 	bl	8025dc8 <lv_malloc>
 8017e9c:	f8c7 0158 	str.w	r0, [r7, #344]	@ 0x158

    int32_t y2 = blend_area.y2;
 8017ea0:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8017ea4:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
    blend_area.y2 = blend_area.y1;
 8017ea8:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8017eac:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140

    uint32_t mask_p = 0;
 8017eb0:	2300      	movs	r3, #0
 8017eb2:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
    lv_memset(mask_buf, 0xff, mask_buf_size);
 8017eb6:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8017eba:	21ff      	movs	r1, #255	@ 0xff
 8017ebc:	f8d7 0158 	ldr.w	r0, [r7, #344]	@ 0x158
 8017ec0:	f00c ffaf 	bl	8024e22 <lv_memset>

    lv_draw_sw_blend_dsc_t blend_dsc;
    lv_memzero(&blend_dsc, sizeof(blend_dsc));
 8017ec4:	f107 0314 	add.w	r3, r7, #20
 8017ec8:	212c      	movs	r1, #44	@ 0x2c
 8017eca:	4618      	mov	r0, r3
 8017ecc:	f7ff fab7 	bl	801743e <lv_memzero>
    blend_dsc.blend_area = &blend_area;
 8017ed0:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017ed4:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 8017ed8:	f507 729a 	add.w	r2, r7, #308	@ 0x134
 8017edc:	601a      	str	r2, [r3, #0]
    blend_dsc.color = dsc->color;
 8017ede:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017ee2:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 8017ee6:	f507 72c8 	add.w	r2, r7, #400	@ 0x190
 8017eea:	f5a2 72c4 	sub.w	r2, r2, #392	@ 0x188
 8017eee:	6812      	ldr	r2, [r2, #0]
 8017ef0:	3315      	adds	r3, #21
 8017ef2:	322c      	adds	r2, #44	@ 0x2c
 8017ef4:	8811      	ldrh	r1, [r2, #0]
 8017ef6:	7892      	ldrb	r2, [r2, #2]
 8017ef8:	8019      	strh	r1, [r3, #0]
 8017efa:	709a      	strb	r2, [r3, #2]
    blend_dsc.opa = dsc->opa;
 8017efc:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017f00:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 8017f04:	681b      	ldr	r3, [r3, #0]
 8017f06:	f893 203c 	ldrb.w	r2, [r3, #60]	@ 0x3c
 8017f0a:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017f0e:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 8017f12:	751a      	strb	r2, [r3, #20]
    blend_dsc.mask_buf = mask_buf;
 8017f14:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017f18:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 8017f1c:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 8017f20:	619a      	str	r2, [r3, #24]
    blend_dsc.mask_area = &blend_area;
 8017f22:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017f26:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 8017f2a:	f507 729a 	add.w	r2, r7, #308	@ 0x134
 8017f2e:	621a      	str	r2, [r3, #32]

    /*Fill the first row with 'color'*/
    for(h = blend_area.y1; h <= y2; h++) {
 8017f30:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8017f34:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
 8017f38:	e066      	b.n	8018008 <draw_line_skew+0x5e0>
        blend_dsc.mask_res = lv_draw_sw_mask_apply(masks, &mask_buf[mask_p], blend_area.x1, h, draw_area_w);
 8017f3a:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 8017f3e:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8017f42:	18d1      	adds	r1, r2, r3
 8017f44:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 8017f48:	f107 0040 	add.w	r0, r7, #64	@ 0x40
 8017f4c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8017f50:	9300      	str	r3, [sp, #0]
 8017f52:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8017f56:	f000 f909 	bl	801816c <lv_draw_sw_mask_apply>
 8017f5a:	4603      	mov	r3, r0
 8017f5c:	461a      	mov	r2, r3
 8017f5e:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017f62:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 8017f66:	771a      	strb	r2, [r3, #28]
        if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_TRANSP) {
 8017f68:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017f6c:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 8017f70:	7f1b      	ldrb	r3, [r3, #28]
 8017f72:	2b00      	cmp	r3, #0
 8017f74:	d10a      	bne.n	8017f8c <draw_line_skew+0x564>
            lv_memzero(&mask_buf[mask_p], draw_area_w);
 8017f76:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 8017f7a:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8017f7e:	4413      	add	r3, r2
 8017f80:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8017f84:	4611      	mov	r1, r2
 8017f86:	4618      	mov	r0, r3
 8017f88:	f7ff fa59 	bl	801743e <lv_memzero>
        }

        mask_p += draw_area_w;
 8017f8c:	f8d7 3164 	ldr.w	r3, [r7, #356]	@ 0x164
 8017f90:	f8d7 2184 	ldr.w	r2, [r7, #388]	@ 0x184
 8017f94:	4413      	add	r3, r2
 8017f96:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
        if((uint32_t) mask_p + draw_area_w < mask_buf_size) {
 8017f9a:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 8017f9e:	f8d7 3184 	ldr.w	r3, [r7, #388]	@ 0x184
 8017fa2:	4413      	add	r3, r2
 8017fa4:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8017fa8:	429a      	cmp	r2, r3
 8017faa:	d905      	bls.n	8017fb8 <draw_line_skew+0x590>
            blend_area.y2 ++;
 8017fac:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8017fb0:	3301      	adds	r3, #1
 8017fb2:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
 8017fb6:	e022      	b.n	8017ffe <draw_line_skew+0x5d6>
        }
        else {
            blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 8017fb8:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017fbc:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 8017fc0:	2202      	movs	r2, #2
 8017fc2:	771a      	strb	r2, [r3, #28]
            lv_draw_sw_blend(draw_unit, &blend_dsc);
 8017fc4:	f107 0214 	add.w	r2, r7, #20
 8017fc8:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 8017fcc:	f5a3 73c2 	sub.w	r3, r3, #388	@ 0x184
 8017fd0:	4611      	mov	r1, r2
 8017fd2:	6818      	ldr	r0, [r3, #0]
 8017fd4:	f7f6 fc9e 	bl	800e914 <lv_draw_sw_blend>

            blend_area.y1 = blend_area.y2 + 1;
 8017fd8:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8017fdc:	3301      	adds	r3, #1
 8017fde:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
            blend_area.y2 = blend_area.y1;
 8017fe2:	f8d7 3138 	ldr.w	r3, [r7, #312]	@ 0x138
 8017fe6:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
            mask_p = 0;
 8017fea:	2300      	movs	r3, #0
 8017fec:	f8c7 3184 	str.w	r3, [r7, #388]	@ 0x184
            lv_memset(mask_buf, 0xff, mask_buf_size);
 8017ff0:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 8017ff4:	21ff      	movs	r1, #255	@ 0xff
 8017ff6:	f8d7 0158 	ldr.w	r0, [r7, #344]	@ 0x158
 8017ffa:	f00c ff12 	bl	8024e22 <lv_memset>
    for(h = blend_area.y1; h <= y2; h++) {
 8017ffe:	f8d7 3188 	ldr.w	r3, [r7, #392]	@ 0x188
 8018002:	3301      	adds	r3, #1
 8018004:	f8c7 3188 	str.w	r3, [r7, #392]	@ 0x188
 8018008:	f8d7 2188 	ldr.w	r2, [r7, #392]	@ 0x188
 801800c:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8018010:	429a      	cmp	r2, r3
 8018012:	dd92      	ble.n	8017f3a <draw_line_skew+0x512>
        }
    }

    /*Flush the last part*/
    if(blend_area.y1 != blend_area.y2) {
 8018014:	f8d7 2138 	ldr.w	r2, [r7, #312]	@ 0x138
 8018018:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801801c:	429a      	cmp	r2, r3
 801801e:	d014      	beq.n	801804a <draw_line_skew+0x622>
        blend_area.y2--;
 8018020:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 8018024:	3b01      	subs	r3, #1
 8018026:	f8c7 3140 	str.w	r3, [r7, #320]	@ 0x140
        blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 801802a:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 801802e:	f5a3 73be 	sub.w	r3, r3, #380	@ 0x17c
 8018032:	2202      	movs	r2, #2
 8018034:	771a      	strb	r2, [r3, #28]
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 8018036:	f107 0214 	add.w	r2, r7, #20
 801803a:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 801803e:	f5a3 73c2 	sub.w	r3, r3, #388	@ 0x184
 8018042:	4611      	mov	r1, r2
 8018044:	6818      	ldr	r0, [r3, #0]
 8018046:	f7f6 fc65 	bl	800e914 <lv_draw_sw_blend>
    }

    lv_free(mask_buf);
 801804a:	f8d7 0158 	ldr.w	r0, [r7, #344]	@ 0x158
 801804e:	f00d fef3 	bl	8025e38 <lv_free>

    lv_draw_sw_mask_free_param(&mask_left_param);
 8018052:	f107 03fc 	add.w	r3, r7, #252	@ 0xfc
 8018056:	4618      	mov	r0, r3
 8018058:	f000 f8ca 	bl	80181f0 <lv_draw_sw_mask_free_param>
    lv_draw_sw_mask_free_param(&mask_right_param);
 801805c:	f107 03c4 	add.w	r3, r7, #196	@ 0xc4
 8018060:	4618      	mov	r0, r3
 8018062:	f000 f8c5 	bl	80181f0 <lv_draw_sw_mask_free_param>
    if(!dsc->raw_end) {
 8018066:	f507 73c8 	add.w	r3, r7, #400	@ 0x190
 801806a:	f5a3 73c4 	sub.w	r3, r3, #392	@ 0x188
 801806e:	681b      	ldr	r3, [r3, #0]
 8018070:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8018074:	f003 0310 	and.w	r3, r3, #16
 8018078:	b2db      	uxtb	r3, r3
 801807a:	2b00      	cmp	r3, #0
 801807c:	d10b      	bne.n	8018096 <draw_line_skew+0x66e>
        lv_draw_sw_mask_free_param(&mask_top_param);
 801807e:	f107 038c 	add.w	r3, r7, #140	@ 0x8c
 8018082:	4618      	mov	r0, r3
 8018084:	f000 f8b4 	bl	80181f0 <lv_draw_sw_mask_free_param>
        lv_draw_sw_mask_free_param(&mask_bottom_param);
 8018088:	f107 0354 	add.w	r3, r7, #84	@ 0x54
 801808c:	4618      	mov	r0, r3
 801808e:	f000 f8af 	bl	80181f0 <lv_draw_sw_mask_free_param>
 8018092:	e000      	b.n	8018096 <draw_line_skew+0x66e>
    if(is_common == false) return;
 8018094:	bf00      	nop
#else
    LV_UNUSED(draw_unit);
    LV_UNUSED(dsc);
    LV_LOG_WARN("Can't draw skewed line with LV_DRAW_SW_COMPLEX == 0");
#endif /*LV_DRAW_SW_COMPLEX*/
}
 8018096:	f507 77c8 	add.w	r7, r7, #400	@ 0x190
 801809a:	46bd      	mov	sp, r7
 801809c:	bdb0      	pop	{r4, r5, r7, pc}
 801809e:	bf00      	nop

080180a0 <lv_area_copy>:
{
 80180a0:	b480      	push	{r7}
 80180a2:	b083      	sub	sp, #12
 80180a4:	af00      	add	r7, sp, #0
 80180a6:	6078      	str	r0, [r7, #4]
 80180a8:	6039      	str	r1, [r7, #0]
    dest->x1 = src->x1;
 80180aa:	683b      	ldr	r3, [r7, #0]
 80180ac:	681a      	ldr	r2, [r3, #0]
 80180ae:	687b      	ldr	r3, [r7, #4]
 80180b0:	601a      	str	r2, [r3, #0]
    dest->y1 = src->y1;
 80180b2:	683b      	ldr	r3, [r7, #0]
 80180b4:	685a      	ldr	r2, [r3, #4]
 80180b6:	687b      	ldr	r3, [r7, #4]
 80180b8:	605a      	str	r2, [r3, #4]
    dest->x2 = src->x2;
 80180ba:	683b      	ldr	r3, [r7, #0]
 80180bc:	689a      	ldr	r2, [r3, #8]
 80180be:	687b      	ldr	r3, [r7, #4]
 80180c0:	609a      	str	r2, [r3, #8]
    dest->y2 = src->y2;
 80180c2:	683b      	ldr	r3, [r7, #0]
 80180c4:	68da      	ldr	r2, [r3, #12]
 80180c6:	687b      	ldr	r3, [r7, #4]
 80180c8:	60da      	str	r2, [r3, #12]
}
 80180ca:	bf00      	nop
 80180cc:	370c      	adds	r7, #12
 80180ce:	46bd      	mov	sp, r7
 80180d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80180d4:	4770      	bx	lr

080180d6 <lv_area_get_width>:
{
 80180d6:	b480      	push	{r7}
 80180d8:	b083      	sub	sp, #12
 80180da:	af00      	add	r7, sp, #0
 80180dc:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 80180de:	687b      	ldr	r3, [r7, #4]
 80180e0:	689a      	ldr	r2, [r3, #8]
 80180e2:	687b      	ldr	r3, [r7, #4]
 80180e4:	681b      	ldr	r3, [r3, #0]
 80180e6:	1ad3      	subs	r3, r2, r3
 80180e8:	3301      	adds	r3, #1
}
 80180ea:	4618      	mov	r0, r3
 80180ec:	370c      	adds	r7, #12
 80180ee:	46bd      	mov	sp, r7
 80180f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80180f4:	4770      	bx	lr

080180f6 <lv_area_get_height>:
{
 80180f6:	b480      	push	{r7}
 80180f8:	b083      	sub	sp, #12
 80180fa:	af00      	add	r7, sp, #0
 80180fc:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 80180fe:	687b      	ldr	r3, [r7, #4]
 8018100:	68da      	ldr	r2, [r3, #12]
 8018102:	687b      	ldr	r3, [r7, #4]
 8018104:	685b      	ldr	r3, [r3, #4]
 8018106:	1ad3      	subs	r3, r2, r3
 8018108:	3301      	adds	r3, #1
}
 801810a:	4618      	mov	r0, r3
 801810c:	370c      	adds	r7, #12
 801810e:	46bd      	mov	sp, r7
 8018110:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018114:	4770      	bx	lr

08018116 <lv_point_set>:

    return point;
}

static inline void lv_point_set(lv_point_t * p, int32_t x, int32_t y)
{
 8018116:	b480      	push	{r7}
 8018118:	b085      	sub	sp, #20
 801811a:	af00      	add	r7, sp, #0
 801811c:	60f8      	str	r0, [r7, #12]
 801811e:	60b9      	str	r1, [r7, #8]
 8018120:	607a      	str	r2, [r7, #4]
    p->x = x;
 8018122:	68fb      	ldr	r3, [r7, #12]
 8018124:	68ba      	ldr	r2, [r7, #8]
 8018126:	601a      	str	r2, [r3, #0]
    p->y = y;
 8018128:	68fb      	ldr	r3, [r7, #12]
 801812a:	687a      	ldr	r2, [r7, #4]
 801812c:	605a      	str	r2, [r3, #4]
}
 801812e:	bf00      	nop
 8018130:	3714      	adds	r7, #20
 8018132:	46bd      	mov	sp, r7
 8018134:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018138:	4770      	bx	lr

0801813a <lv_memzero>:
{
 801813a:	b580      	push	{r7, lr}
 801813c:	b082      	sub	sp, #8
 801813e:	af00      	add	r7, sp, #0
 8018140:	6078      	str	r0, [r7, #4]
 8018142:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 8018144:	683a      	ldr	r2, [r7, #0]
 8018146:	2100      	movs	r1, #0
 8018148:	6878      	ldr	r0, [r7, #4]
 801814a:	f00c fe6a 	bl	8024e22 <lv_memset>
}
 801814e:	bf00      	nop
 8018150:	3708      	adds	r7, #8
 8018152:	46bd      	mov	sp, r7
 8018154:	bd80      	pop	{r7, pc}
	...

08018158 <lv_draw_sw_mask_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_sw_mask_init(void)
{
 8018158:	b580      	push	{r7, lr}
 801815a:	af00      	add	r7, sp, #0
    lv_mutex_init(&circle_cache_mutex);
 801815c:	4802      	ldr	r0, [pc, #8]	@ (8018168 <lv_draw_sw_mask_init+0x10>)
 801815e:	f00c fb63 	bl	8024828 <lv_mutex_init>
}
 8018162:	bf00      	nop
 8018164:	bd80      	pop	{r7, pc}
 8018166:	bf00      	nop
 8018168:	2000019c 	.word	0x2000019c

0801816c <lv_draw_sw_mask_apply>:
}

lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_sw_mask_apply(void * masks[], lv_opa_t * mask_buf, int32_t abs_x,
                                                                  int32_t abs_y,
                                                                  int32_t len)
{
 801816c:	b590      	push	{r4, r7, lr}
 801816e:	b08b      	sub	sp, #44	@ 0x2c
 8018170:	af02      	add	r7, sp, #8
 8018172:	60f8      	str	r0, [r7, #12]
 8018174:	60b9      	str	r1, [r7, #8]
 8018176:	607a      	str	r2, [r7, #4]
 8018178:	603b      	str	r3, [r7, #0]
    bool changed = false;
 801817a:	2300      	movs	r3, #0
 801817c:	77fb      	strb	r3, [r7, #31]
    _lv_draw_sw_mask_common_dsc_t * dsc;

    uint32_t i;
    for(i = 0; masks[i]; i++) {
 801817e:	2300      	movs	r3, #0
 8018180:	61bb      	str	r3, [r7, #24]
 8018182:	e023      	b.n	80181cc <lv_draw_sw_mask_apply+0x60>
        dsc = masks[i];
 8018184:	69bb      	ldr	r3, [r7, #24]
 8018186:	009b      	lsls	r3, r3, #2
 8018188:	68fa      	ldr	r2, [r7, #12]
 801818a:	4413      	add	r3, r2
 801818c:	681b      	ldr	r3, [r3, #0]
 801818e:	617b      	str	r3, [r7, #20]
        lv_draw_sw_mask_res_t res = LV_DRAW_SW_MASK_RES_FULL_COVER;
 8018190:	2301      	movs	r3, #1
 8018192:	74fb      	strb	r3, [r7, #19]
        res = dsc->cb(mask_buf, abs_x, abs_y, len, masks[i]);
 8018194:	697b      	ldr	r3, [r7, #20]
 8018196:	681c      	ldr	r4, [r3, #0]
 8018198:	69bb      	ldr	r3, [r7, #24]
 801819a:	009b      	lsls	r3, r3, #2
 801819c:	68fa      	ldr	r2, [r7, #12]
 801819e:	4413      	add	r3, r2
 80181a0:	681b      	ldr	r3, [r3, #0]
 80181a2:	9300      	str	r3, [sp, #0]
 80181a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80181a6:	683a      	ldr	r2, [r7, #0]
 80181a8:	6879      	ldr	r1, [r7, #4]
 80181aa:	68b8      	ldr	r0, [r7, #8]
 80181ac:	47a0      	blx	r4
 80181ae:	4603      	mov	r3, r0
 80181b0:	74fb      	strb	r3, [r7, #19]
        if(res == LV_DRAW_SW_MASK_RES_TRANSP) return LV_DRAW_SW_MASK_RES_TRANSP;
 80181b2:	7cfb      	ldrb	r3, [r7, #19]
 80181b4:	2b00      	cmp	r3, #0
 80181b6:	d101      	bne.n	80181bc <lv_draw_sw_mask_apply+0x50>
 80181b8:	2300      	movs	r3, #0
 80181ba:	e014      	b.n	80181e6 <lv_draw_sw_mask_apply+0x7a>
        else if(res == LV_DRAW_SW_MASK_RES_CHANGED) changed = true;
 80181bc:	7cfb      	ldrb	r3, [r7, #19]
 80181be:	2b02      	cmp	r3, #2
 80181c0:	d101      	bne.n	80181c6 <lv_draw_sw_mask_apply+0x5a>
 80181c2:	2301      	movs	r3, #1
 80181c4:	77fb      	strb	r3, [r7, #31]
    for(i = 0; masks[i]; i++) {
 80181c6:	69bb      	ldr	r3, [r7, #24]
 80181c8:	3301      	adds	r3, #1
 80181ca:	61bb      	str	r3, [r7, #24]
 80181cc:	69bb      	ldr	r3, [r7, #24]
 80181ce:	009b      	lsls	r3, r3, #2
 80181d0:	68fa      	ldr	r2, [r7, #12]
 80181d2:	4413      	add	r3, r2
 80181d4:	681b      	ldr	r3, [r3, #0]
 80181d6:	2b00      	cmp	r3, #0
 80181d8:	d1d4      	bne.n	8018184 <lv_draw_sw_mask_apply+0x18>
    }

    return changed ? LV_DRAW_SW_MASK_RES_CHANGED : LV_DRAW_SW_MASK_RES_FULL_COVER;
 80181da:	7ffb      	ldrb	r3, [r7, #31]
 80181dc:	2b00      	cmp	r3, #0
 80181de:	d001      	beq.n	80181e4 <lv_draw_sw_mask_apply+0x78>
 80181e0:	2302      	movs	r3, #2
 80181e2:	e000      	b.n	80181e6 <lv_draw_sw_mask_apply+0x7a>
 80181e4:	2301      	movs	r3, #1
}
 80181e6:	4618      	mov	r0, r3
 80181e8:	3724      	adds	r7, #36	@ 0x24
 80181ea:	46bd      	mov	sp, r7
 80181ec:	bd90      	pop	{r4, r7, pc}
	...

080181f0 <lv_draw_sw_mask_free_param>:

void lv_draw_sw_mask_free_param(void * p)
{
 80181f0:	b580      	push	{r7, lr}
 80181f2:	b084      	sub	sp, #16
 80181f4:	af00      	add	r7, sp, #0
 80181f6:	6078      	str	r0, [r7, #4]
    lv_mutex_lock(&circle_cache_mutex);
 80181f8:	4815      	ldr	r0, [pc, #84]	@ (8018250 <lv_draw_sw_mask_free_param+0x60>)
 80181fa:	f00c fb20 	bl	802483e <lv_mutex_lock>
    _lv_draw_sw_mask_common_dsc_t * pdsc = p;
 80181fe:	687b      	ldr	r3, [r7, #4]
 8018200:	60fb      	str	r3, [r7, #12]
    if(pdsc->type == LV_DRAW_SW_MASK_TYPE_RADIUS) {
 8018202:	68fb      	ldr	r3, [r7, #12]
 8018204:	791b      	ldrb	r3, [r3, #4]
 8018206:	2b02      	cmp	r3, #2
 8018208:	d11b      	bne.n	8018242 <lv_draw_sw_mask_free_param+0x52>
        lv_draw_sw_mask_radius_param_t * radius_p = (lv_draw_sw_mask_radius_param_t *) p;
 801820a:	687b      	ldr	r3, [r7, #4]
 801820c:	60bb      	str	r3, [r7, #8]
        if(radius_p->circle) {
 801820e:	68bb      	ldr	r3, [r7, #8]
 8018210:	6a1b      	ldr	r3, [r3, #32]
 8018212:	2b00      	cmp	r3, #0
 8018214:	d015      	beq.n	8018242 <lv_draw_sw_mask_free_param+0x52>
            if(radius_p->circle->life < 0) {
 8018216:	68bb      	ldr	r3, [r7, #8]
 8018218:	6a1b      	ldr	r3, [r3, #32]
 801821a:	691b      	ldr	r3, [r3, #16]
 801821c:	2b00      	cmp	r3, #0
 801821e:	da0b      	bge.n	8018238 <lv_draw_sw_mask_free_param+0x48>
                lv_free(radius_p->circle->cir_opa);
 8018220:	68bb      	ldr	r3, [r7, #8]
 8018222:	6a1b      	ldr	r3, [r3, #32]
 8018224:	685b      	ldr	r3, [r3, #4]
 8018226:	4618      	mov	r0, r3
 8018228:	f00d fe06 	bl	8025e38 <lv_free>
                lv_free(radius_p->circle);
 801822c:	68bb      	ldr	r3, [r7, #8]
 801822e:	6a1b      	ldr	r3, [r3, #32]
 8018230:	4618      	mov	r0, r3
 8018232:	f00d fe01 	bl	8025e38 <lv_free>
 8018236:	e004      	b.n	8018242 <lv_draw_sw_mask_free_param+0x52>
            }
            else {
                radius_p->circle->used_cnt--;
 8018238:	68bb      	ldr	r3, [r7, #8]
 801823a:	6a1b      	ldr	r3, [r3, #32]
 801823c:	695a      	ldr	r2, [r3, #20]
 801823e:	3a01      	subs	r2, #1
 8018240:	615a      	str	r2, [r3, #20]
            }
        }
    }

    lv_mutex_unlock(&circle_cache_mutex);
 8018242:	4803      	ldr	r0, [pc, #12]	@ (8018250 <lv_draw_sw_mask_free_param+0x60>)
 8018244:	f00c fb06 	bl	8024854 <lv_mutex_unlock>
}
 8018248:	bf00      	nop
 801824a:	3710      	adds	r7, #16
 801824c:	46bd      	mov	sp, r7
 801824e:	bd80      	pop	{r7, pc}
 8018250:	2000019c 	.word	0x2000019c

08018254 <lv_draw_sw_mask_line_points_init>:
}

void lv_draw_sw_mask_line_points_init(lv_draw_sw_mask_line_param_t * param, int32_t p1x, int32_t p1y,
                                      int32_t p2x,
                                      int32_t p2y, lv_draw_sw_mask_line_side_t side)
{
 8018254:	b580      	push	{r7, lr}
 8018256:	b08a      	sub	sp, #40	@ 0x28
 8018258:	af00      	add	r7, sp, #0
 801825a:	60f8      	str	r0, [r7, #12]
 801825c:	60b9      	str	r1, [r7, #8]
 801825e:	607a      	str	r2, [r7, #4]
 8018260:	603b      	str	r3, [r7, #0]
    lv_memzero(param, sizeof(lv_draw_sw_mask_line_param_t));
 8018262:	2138      	movs	r1, #56	@ 0x38
 8018264:	68f8      	ldr	r0, [r7, #12]
 8018266:	f7ff ff68 	bl	801813a <lv_memzero>

    if(p1y == p2y && side == LV_DRAW_SW_MASK_LINE_SIDE_BOTTOM) {
 801826a:	687a      	ldr	r2, [r7, #4]
 801826c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801826e:	429a      	cmp	r2, r3
 8018270:	d109      	bne.n	8018286 <lv_draw_sw_mask_line_points_init+0x32>
 8018272:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 8018276:	2b03      	cmp	r3, #3
 8018278:	d105      	bne.n	8018286 <lv_draw_sw_mask_line_points_init+0x32>
        p1y--;
 801827a:	687b      	ldr	r3, [r7, #4]
 801827c:	3b01      	subs	r3, #1
 801827e:	607b      	str	r3, [r7, #4]
        p2y--;
 8018280:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018282:	3b01      	subs	r3, #1
 8018284:	633b      	str	r3, [r7, #48]	@ 0x30
    }

    if(p1y > p2y) {
 8018286:	687a      	ldr	r2, [r7, #4]
 8018288:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801828a:	429a      	cmp	r2, r3
 801828c:	dd0b      	ble.n	80182a6 <lv_draw_sw_mask_line_points_init+0x52>
        int32_t t;
        t = p2x;
 801828e:	683b      	ldr	r3, [r7, #0]
 8018290:	627b      	str	r3, [r7, #36]	@ 0x24
        p2x = p1x;
 8018292:	68bb      	ldr	r3, [r7, #8]
 8018294:	603b      	str	r3, [r7, #0]
        p1x = t;
 8018296:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018298:	60bb      	str	r3, [r7, #8]

        t = p2y;
 801829a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801829c:	627b      	str	r3, [r7, #36]	@ 0x24
        p2y = p1y;
 801829e:	687b      	ldr	r3, [r7, #4]
 80182a0:	633b      	str	r3, [r7, #48]	@ 0x30
        p1y = t;
 80182a2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80182a4:	607b      	str	r3, [r7, #4]
    }

    lv_point_set(&param->cfg.p1, p1x, p1y);
 80182a6:	68fb      	ldr	r3, [r7, #12]
 80182a8:	3308      	adds	r3, #8
 80182aa:	687a      	ldr	r2, [r7, #4]
 80182ac:	68b9      	ldr	r1, [r7, #8]
 80182ae:	4618      	mov	r0, r3
 80182b0:	f7ff ff31 	bl	8018116 <lv_point_set>
    lv_point_set(&param->cfg.p2, p2x, p2y);
 80182b4:	68fb      	ldr	r3, [r7, #12]
 80182b6:	3310      	adds	r3, #16
 80182b8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80182ba:	6839      	ldr	r1, [r7, #0]
 80182bc:	4618      	mov	r0, r3
 80182be:	f7ff ff2a 	bl	8018116 <lv_point_set>
    param->cfg.side = side;
 80182c2:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 80182c6:	f003 0303 	and.w	r3, r3, #3
 80182ca:	b2d9      	uxtb	r1, r3
 80182cc:	68fa      	ldr	r2, [r7, #12]
 80182ce:	7e13      	ldrb	r3, [r2, #24]
 80182d0:	f361 0301 	bfi	r3, r1, #0, #2
 80182d4:	7613      	strb	r3, [r2, #24]

    lv_point_set(&param->origo, p1x, p1y);
 80182d6:	68fb      	ldr	r3, [r7, #12]
 80182d8:	331c      	adds	r3, #28
 80182da:	687a      	ldr	r2, [r7, #4]
 80182dc:	68b9      	ldr	r1, [r7, #8]
 80182de:	4618      	mov	r0, r3
 80182e0:	f7ff ff19 	bl	8018116 <lv_point_set>
    param->flat = (LV_ABS(p2x - p1x) > LV_ABS(p2y - p1y)) ? 1 : 0;
 80182e4:	683a      	ldr	r2, [r7, #0]
 80182e6:	68bb      	ldr	r3, [r7, #8]
 80182e8:	1ad3      	subs	r3, r2, r3
 80182ea:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 80182ee:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 80182f2:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 80182f4:	687b      	ldr	r3, [r7, #4]
 80182f6:	1acb      	subs	r3, r1, r3
 80182f8:	2b00      	cmp	r3, #0
 80182fa:	bfb8      	it	lt
 80182fc:	425b      	neglt	r3, r3
 80182fe:	429a      	cmp	r2, r3
 8018300:	bfcc      	ite	gt
 8018302:	2301      	movgt	r3, #1
 8018304:	2300      	movle	r3, #0
 8018306:	b2d9      	uxtb	r1, r3
 8018308:	68fa      	ldr	r2, [r7, #12]
 801830a:	f892 3034 	ldrb.w	r3, [r2, #52]	@ 0x34
 801830e:	f361 0300 	bfi	r3, r1, #0, #1
 8018312:	f882 3034 	strb.w	r3, [r2, #52]	@ 0x34
    param->yx_steep = 0;
 8018316:	68fb      	ldr	r3, [r7, #12]
 8018318:	2200      	movs	r2, #0
 801831a:	629a      	str	r2, [r3, #40]	@ 0x28
    param->xy_steep = 0;
 801831c:	68fb      	ldr	r3, [r7, #12]
 801831e:	2200      	movs	r2, #0
 8018320:	625a      	str	r2, [r3, #36]	@ 0x24
    param->dsc.cb = (lv_draw_sw_mask_xcb_t)lv_draw_mask_line;
 8018322:	68fb      	ldr	r3, [r7, #12]
 8018324:	4a61      	ldr	r2, [pc, #388]	@ (80184ac <lv_draw_sw_mask_line_points_init+0x258>)
 8018326:	601a      	str	r2, [r3, #0]
    param->dsc.type = LV_DRAW_SW_MASK_TYPE_LINE;
 8018328:	68fb      	ldr	r3, [r7, #12]
 801832a:	2200      	movs	r2, #0
 801832c:	711a      	strb	r2, [r3, #4]

    int32_t dx = p2x - p1x;
 801832e:	683a      	ldr	r2, [r7, #0]
 8018330:	68bb      	ldr	r3, [r7, #8]
 8018332:	1ad3      	subs	r3, r2, r3
 8018334:	623b      	str	r3, [r7, #32]
    int32_t dy = p2y - p1y;
 8018336:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018338:	687b      	ldr	r3, [r7, #4]
 801833a:	1ad3      	subs	r3, r2, r3
 801833c:	61fb      	str	r3, [r7, #28]

    if(param->flat) {
 801833e:	68fb      	ldr	r3, [r7, #12]
 8018340:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018344:	f003 0301 	and.w	r3, r3, #1
 8018348:	b2db      	uxtb	r3, r3
 801834a:	2b00      	cmp	r3, #0
 801834c:	d024      	beq.n	8018398 <lv_draw_sw_mask_line_points_init+0x144>
        /*Normalize the steep. Delta x should be relative to delta x = 1024*/
        int32_t m;

        if(dx) {
 801834e:	6a3b      	ldr	r3, [r7, #32]
 8018350:	2b00      	cmp	r3, #0
 8018352:	d00c      	beq.n	801836e <lv_draw_sw_mask_line_points_init+0x11a>
            m = (1L << 20) / dx;  /*m is multiplier to normalize y (upscaled by 1024)*/
 8018354:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 8018358:	6a3b      	ldr	r3, [r7, #32]
 801835a:	fb92 f3f3 	sdiv	r3, r2, r3
 801835e:	617b      	str	r3, [r7, #20]
            param->yx_steep = (m * dy) >> 10;
 8018360:	697b      	ldr	r3, [r7, #20]
 8018362:	69fa      	ldr	r2, [r7, #28]
 8018364:	fb02 f303 	mul.w	r3, r2, r3
 8018368:	129a      	asrs	r2, r3, #10
 801836a:	68fb      	ldr	r3, [r7, #12]
 801836c:	629a      	str	r2, [r3, #40]	@ 0x28
        }

        if(dy) {
 801836e:	69fb      	ldr	r3, [r7, #28]
 8018370:	2b00      	cmp	r3, #0
 8018372:	d00c      	beq.n	801838e <lv_draw_sw_mask_line_points_init+0x13a>
            m = (1L << 20) / dy;  /*m is multiplier to normalize x (upscaled by 1024)*/
 8018374:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 8018378:	69fb      	ldr	r3, [r7, #28]
 801837a:	fb92 f3f3 	sdiv	r3, r2, r3
 801837e:	617b      	str	r3, [r7, #20]
            param->xy_steep = (m * dx) >> 10;
 8018380:	697b      	ldr	r3, [r7, #20]
 8018382:	6a3a      	ldr	r2, [r7, #32]
 8018384:	fb02 f303 	mul.w	r3, r2, r3
 8018388:	129a      	asrs	r2, r3, #10
 801838a:	68fb      	ldr	r3, [r7, #12]
 801838c:	625a      	str	r2, [r3, #36]	@ 0x24
        }
        param->steep = param->yx_steep;
 801838e:	68fb      	ldr	r3, [r7, #12]
 8018390:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8018392:	68fb      	ldr	r3, [r7, #12]
 8018394:	62da      	str	r2, [r3, #44]	@ 0x2c
 8018396:	e023      	b.n	80183e0 <lv_draw_sw_mask_line_points_init+0x18c>
    }
    else {
        /*Normalize the steep. Delta y should be relative to delta x = 1024*/
        int32_t m;

        if(dy) {
 8018398:	69fb      	ldr	r3, [r7, #28]
 801839a:	2b00      	cmp	r3, #0
 801839c:	d00c      	beq.n	80183b8 <lv_draw_sw_mask_line_points_init+0x164>
            m = (1L << 20) / dy;  /*m is multiplier to normalize x (upscaled by 1024)*/
 801839e:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 80183a2:	69fb      	ldr	r3, [r7, #28]
 80183a4:	fb92 f3f3 	sdiv	r3, r2, r3
 80183a8:	61bb      	str	r3, [r7, #24]
            param->xy_steep = (m * dx) >> 10;
 80183aa:	69bb      	ldr	r3, [r7, #24]
 80183ac:	6a3a      	ldr	r2, [r7, #32]
 80183ae:	fb02 f303 	mul.w	r3, r2, r3
 80183b2:	129a      	asrs	r2, r3, #10
 80183b4:	68fb      	ldr	r3, [r7, #12]
 80183b6:	625a      	str	r2, [r3, #36]	@ 0x24
        }

        if(dx) {
 80183b8:	6a3b      	ldr	r3, [r7, #32]
 80183ba:	2b00      	cmp	r3, #0
 80183bc:	d00c      	beq.n	80183d8 <lv_draw_sw_mask_line_points_init+0x184>
            m = (1L << 20) / dx;  /*m is multiplier to normalize x (upscaled by 1024)*/
 80183be:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 80183c2:	6a3b      	ldr	r3, [r7, #32]
 80183c4:	fb92 f3f3 	sdiv	r3, r2, r3
 80183c8:	61bb      	str	r3, [r7, #24]
            param->yx_steep = (m * dy) >> 10;
 80183ca:	69bb      	ldr	r3, [r7, #24]
 80183cc:	69fa      	ldr	r2, [r7, #28]
 80183ce:	fb02 f303 	mul.w	r3, r2, r3
 80183d2:	129a      	asrs	r2, r3, #10
 80183d4:	68fb      	ldr	r3, [r7, #12]
 80183d6:	629a      	str	r2, [r3, #40]	@ 0x28
        }
        param->steep = param->xy_steep;
 80183d8:	68fb      	ldr	r3, [r7, #12]
 80183da:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80183dc:	68fb      	ldr	r3, [r7, #12]
 80183de:	62da      	str	r2, [r3, #44]	@ 0x2c
    }

    if(param->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_LEFT) param->inv = 0;
 80183e0:	68fb      	ldr	r3, [r7, #12]
 80183e2:	7e1b      	ldrb	r3, [r3, #24]
 80183e4:	f003 0303 	and.w	r3, r3, #3
 80183e8:	b2db      	uxtb	r3, r3
 80183ea:	2b00      	cmp	r3, #0
 80183ec:	d107      	bne.n	80183fe <lv_draw_sw_mask_line_points_init+0x1aa>
 80183ee:	68fa      	ldr	r2, [r7, #12]
 80183f0:	f892 3034 	ldrb.w	r3, [r2, #52]	@ 0x34
 80183f4:	f36f 0341 	bfc	r3, #1, #1
 80183f8:	f882 3034 	strb.w	r3, [r2, #52]	@ 0x34
 80183fc:	e043      	b.n	8018486 <lv_draw_sw_mask_line_points_init+0x232>
    else if(param->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_RIGHT) param->inv = 1;
 80183fe:	68fb      	ldr	r3, [r7, #12]
 8018400:	7e1b      	ldrb	r3, [r3, #24]
 8018402:	f003 0303 	and.w	r3, r3, #3
 8018406:	b2db      	uxtb	r3, r3
 8018408:	2b01      	cmp	r3, #1
 801840a:	d107      	bne.n	801841c <lv_draw_sw_mask_line_points_init+0x1c8>
 801840c:	68fa      	ldr	r2, [r7, #12]
 801840e:	f892 3034 	ldrb.w	r3, [r2, #52]	@ 0x34
 8018412:	f043 0302 	orr.w	r3, r3, #2
 8018416:	f882 3034 	strb.w	r3, [r2, #52]	@ 0x34
 801841a:	e034      	b.n	8018486 <lv_draw_sw_mask_line_points_init+0x232>
    else if(param->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_TOP) {
 801841c:	68fb      	ldr	r3, [r7, #12]
 801841e:	7e1b      	ldrb	r3, [r3, #24]
 8018420:	f003 0303 	and.w	r3, r3, #3
 8018424:	b2db      	uxtb	r3, r3
 8018426:	2b02      	cmp	r3, #2
 8018428:	d113      	bne.n	8018452 <lv_draw_sw_mask_line_points_init+0x1fe>
        if(param->steep > 0) param->inv = 1;
 801842a:	68fb      	ldr	r3, [r7, #12]
 801842c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801842e:	2b00      	cmp	r3, #0
 8018430:	dd07      	ble.n	8018442 <lv_draw_sw_mask_line_points_init+0x1ee>
 8018432:	68fa      	ldr	r2, [r7, #12]
 8018434:	f892 3034 	ldrb.w	r3, [r2, #52]	@ 0x34
 8018438:	f043 0302 	orr.w	r3, r3, #2
 801843c:	f882 3034 	strb.w	r3, [r2, #52]	@ 0x34
 8018440:	e021      	b.n	8018486 <lv_draw_sw_mask_line_points_init+0x232>
        else param->inv = 0;
 8018442:	68fa      	ldr	r2, [r7, #12]
 8018444:	f892 3034 	ldrb.w	r3, [r2, #52]	@ 0x34
 8018448:	f36f 0341 	bfc	r3, #1, #1
 801844c:	f882 3034 	strb.w	r3, [r2, #52]	@ 0x34
 8018450:	e019      	b.n	8018486 <lv_draw_sw_mask_line_points_init+0x232>
    }
    else if(param->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_BOTTOM) {
 8018452:	68fb      	ldr	r3, [r7, #12]
 8018454:	7e1b      	ldrb	r3, [r3, #24]
 8018456:	f003 0303 	and.w	r3, r3, #3
 801845a:	b2db      	uxtb	r3, r3
 801845c:	2b03      	cmp	r3, #3
 801845e:	d112      	bne.n	8018486 <lv_draw_sw_mask_line_points_init+0x232>
        if(param->steep > 0) param->inv = 0;
 8018460:	68fb      	ldr	r3, [r7, #12]
 8018462:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8018464:	2b00      	cmp	r3, #0
 8018466:	dd07      	ble.n	8018478 <lv_draw_sw_mask_line_points_init+0x224>
 8018468:	68fa      	ldr	r2, [r7, #12]
 801846a:	f892 3034 	ldrb.w	r3, [r2, #52]	@ 0x34
 801846e:	f36f 0341 	bfc	r3, #1, #1
 8018472:	f882 3034 	strb.w	r3, [r2, #52]	@ 0x34
 8018476:	e006      	b.n	8018486 <lv_draw_sw_mask_line_points_init+0x232>
        else param->inv = 1;
 8018478:	68fa      	ldr	r2, [r7, #12]
 801847a:	f892 3034 	ldrb.w	r3, [r2, #52]	@ 0x34
 801847e:	f043 0302 	orr.w	r3, r3, #2
 8018482:	f882 3034 	strb.w	r3, [r2, #52]	@ 0x34
    }

    param->spx = param->steep >> 2;
 8018486:	68fb      	ldr	r3, [r7, #12]
 8018488:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801848a:	109a      	asrs	r2, r3, #2
 801848c:	68fb      	ldr	r3, [r7, #12]
 801848e:	631a      	str	r2, [r3, #48]	@ 0x30
    if(param->steep < 0) param->spx = -param->spx;
 8018490:	68fb      	ldr	r3, [r7, #12]
 8018492:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8018494:	2b00      	cmp	r3, #0
 8018496:	da04      	bge.n	80184a2 <lv_draw_sw_mask_line_points_init+0x24e>
 8018498:	68fb      	ldr	r3, [r7, #12]
 801849a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801849c:	425a      	negs	r2, r3
 801849e:	68fb      	ldr	r3, [r7, #12]
 80184a0:	631a      	str	r2, [r3, #48]	@ 0x30
}
 80184a2:	bf00      	nop
 80184a4:	3728      	adds	r7, #40	@ 0x28
 80184a6:	46bd      	mov	sp, r7
 80184a8:	bd80      	pop	{r7, pc}
 80184aa:	bf00      	nop
 80184ac:	0801888d 	.word	0x0801888d

080184b0 <lv_draw_sw_mask_line_angle_init>:

void lv_draw_sw_mask_line_angle_init(lv_draw_sw_mask_line_param_t * param, int32_t p1x, int32_t py, int16_t angle,
                                     lv_draw_sw_mask_line_side_t side)
{
 80184b0:	b580      	push	{r7, lr}
 80184b2:	b088      	sub	sp, #32
 80184b4:	af02      	add	r7, sp, #8
 80184b6:	60f8      	str	r0, [r7, #12]
 80184b8:	60b9      	str	r1, [r7, #8]
 80184ba:	607a      	str	r2, [r7, #4]
 80184bc:	807b      	strh	r3, [r7, #2]
    /*Find an optimal degree.
     *lv_mask_line_points_init will swap the points to keep the smaller y in p1
     *Theoretically a line with `angle` or `angle+180` is the same only the points are swapped
     *Find the degree which keeps the origo in place*/
    if(angle > 180) angle -= 180; /*> 180 will swap the origo*/
 80184be:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80184c2:	2bb4      	cmp	r3, #180	@ 0xb4
 80184c4:	dd03      	ble.n	80184ce <lv_draw_sw_mask_line_angle_init+0x1e>
 80184c6:	887b      	ldrh	r3, [r7, #2]
 80184c8:	3bb4      	subs	r3, #180	@ 0xb4
 80184ca:	b29b      	uxth	r3, r3
 80184cc:	807b      	strh	r3, [r7, #2]

    int32_t p2x;
    int32_t p2y;

    p2x = (lv_trigo_sin(angle + 90) >> 5) + p1x;
 80184ce:	887b      	ldrh	r3, [r7, #2]
 80184d0:	335a      	adds	r3, #90	@ 0x5a
 80184d2:	b29b      	uxth	r3, r3
 80184d4:	b21b      	sxth	r3, r3
 80184d6:	4618      	mov	r0, r3
 80184d8:	f00a ff04 	bl	80232e4 <lv_trigo_sin>
 80184dc:	4603      	mov	r3, r0
 80184de:	115b      	asrs	r3, r3, #5
 80184e0:	68ba      	ldr	r2, [r7, #8]
 80184e2:	4413      	add	r3, r2
 80184e4:	617b      	str	r3, [r7, #20]
    p2y = (lv_trigo_sin(angle) >> 5) + py;
 80184e6:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80184ea:	4618      	mov	r0, r3
 80184ec:	f00a fefa 	bl	80232e4 <lv_trigo_sin>
 80184f0:	4603      	mov	r3, r0
 80184f2:	115b      	asrs	r3, r3, #5
 80184f4:	687a      	ldr	r2, [r7, #4]
 80184f6:	4413      	add	r3, r2
 80184f8:	613b      	str	r3, [r7, #16]

    lv_draw_sw_mask_line_points_init(param, p1x, py, p2x, p2y, side);
 80184fa:	f897 3020 	ldrb.w	r3, [r7, #32]
 80184fe:	9301      	str	r3, [sp, #4]
 8018500:	693b      	ldr	r3, [r7, #16]
 8018502:	9300      	str	r3, [sp, #0]
 8018504:	697b      	ldr	r3, [r7, #20]
 8018506:	687a      	ldr	r2, [r7, #4]
 8018508:	68b9      	ldr	r1, [r7, #8]
 801850a:	68f8      	ldr	r0, [r7, #12]
 801850c:	f7ff fea2 	bl	8018254 <lv_draw_sw_mask_line_points_init>
}
 8018510:	bf00      	nop
 8018512:	3718      	adds	r7, #24
 8018514:	46bd      	mov	sp, r7
 8018516:	bd80      	pop	{r7, pc}

08018518 <lv_draw_sw_mask_angle_init>:

void lv_draw_sw_mask_angle_init(lv_draw_sw_mask_angle_param_t * param, int32_t vertex_x, int32_t vertex_y,
                                int32_t start_angle, int32_t end_angle)
{
 8018518:	b580      	push	{r7, lr}
 801851a:	b088      	sub	sp, #32
 801851c:	af02      	add	r7, sp, #8
 801851e:	60f8      	str	r0, [r7, #12]
 8018520:	60b9      	str	r1, [r7, #8]
 8018522:	607a      	str	r2, [r7, #4]
 8018524:	603b      	str	r3, [r7, #0]
    lv_draw_sw_mask_line_side_t start_side;
    lv_draw_sw_mask_line_side_t end_side;

    /*Constrain the input angles*/
    if(start_angle < 0)
 8018526:	683b      	ldr	r3, [r7, #0]
 8018528:	2b00      	cmp	r3, #0
 801852a:	da02      	bge.n	8018532 <lv_draw_sw_mask_angle_init+0x1a>
        start_angle = 0;
 801852c:	2300      	movs	r3, #0
 801852e:	603b      	str	r3, [r7, #0]
 8018530:	e006      	b.n	8018540 <lv_draw_sw_mask_angle_init+0x28>
    else if(start_angle > 359)
 8018532:	683b      	ldr	r3, [r7, #0]
 8018534:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 8018538:	db02      	blt.n	8018540 <lv_draw_sw_mask_angle_init+0x28>
        start_angle = 359;
 801853a:	f240 1367 	movw	r3, #359	@ 0x167
 801853e:	603b      	str	r3, [r7, #0]

    if(end_angle < 0)
 8018540:	6a3b      	ldr	r3, [r7, #32]
 8018542:	2b00      	cmp	r3, #0
 8018544:	da02      	bge.n	801854c <lv_draw_sw_mask_angle_init+0x34>
        end_angle = 0;
 8018546:	2300      	movs	r3, #0
 8018548:	623b      	str	r3, [r7, #32]
 801854a:	e006      	b.n	801855a <lv_draw_sw_mask_angle_init+0x42>
    else if(end_angle > 359)
 801854c:	6a3b      	ldr	r3, [r7, #32]
 801854e:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 8018552:	db02      	blt.n	801855a <lv_draw_sw_mask_angle_init+0x42>
        end_angle = 359;
 8018554:	f240 1367 	movw	r3, #359	@ 0x167
 8018558:	623b      	str	r3, [r7, #32]

    if(end_angle < start_angle) {
 801855a:	6a3a      	ldr	r2, [r7, #32]
 801855c:	683b      	ldr	r3, [r7, #0]
 801855e:	429a      	cmp	r2, r3
 8018560:	da0c      	bge.n	801857c <lv_draw_sw_mask_angle_init+0x64>
        param->delta_deg = 360 - start_angle + end_angle;
 8018562:	6a3b      	ldr	r3, [r7, #32]
 8018564:	b29a      	uxth	r2, r3
 8018566:	683b      	ldr	r3, [r7, #0]
 8018568:	b29b      	uxth	r3, r3
 801856a:	1ad3      	subs	r3, r2, r3
 801856c:	b29b      	uxth	r3, r3
 801856e:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 8018572:	b29a      	uxth	r2, r3
 8018574:	68fb      	ldr	r3, [r7, #12]
 8018576:	f8a3 2088 	strh.w	r2, [r3, #136]	@ 0x88
 801857a:	e009      	b.n	8018590 <lv_draw_sw_mask_angle_init+0x78>
    }
    else {
        param->delta_deg = LV_ABS(end_angle - start_angle);
 801857c:	6a3a      	ldr	r2, [r7, #32]
 801857e:	683b      	ldr	r3, [r7, #0]
 8018580:	1ad3      	subs	r3, r2, r3
 8018582:	2b00      	cmp	r3, #0
 8018584:	bfb8      	it	lt
 8018586:	425b      	neglt	r3, r3
 8018588:	b29a      	uxth	r2, r3
 801858a:	68fb      	ldr	r3, [r7, #12]
 801858c:	f8a3 2088 	strh.w	r2, [r3, #136]	@ 0x88
    }

    param->cfg.start_angle = start_angle;
 8018590:	68fb      	ldr	r3, [r7, #12]
 8018592:	683a      	ldr	r2, [r7, #0]
 8018594:	611a      	str	r2, [r3, #16]
    param->cfg.end_angle = end_angle;
 8018596:	68fb      	ldr	r3, [r7, #12]
 8018598:	6a3a      	ldr	r2, [r7, #32]
 801859a:	615a      	str	r2, [r3, #20]
    lv_point_set(&param->cfg.vertex_p, vertex_x, vertex_y);
 801859c:	68fb      	ldr	r3, [r7, #12]
 801859e:	3308      	adds	r3, #8
 80185a0:	687a      	ldr	r2, [r7, #4]
 80185a2:	68b9      	ldr	r1, [r7, #8]
 80185a4:	4618      	mov	r0, r3
 80185a6:	f7ff fdb6 	bl	8018116 <lv_point_set>
    param->dsc.cb = (lv_draw_sw_mask_xcb_t)lv_draw_mask_angle;
 80185aa:	68fb      	ldr	r3, [r7, #12]
 80185ac:	4a29      	ldr	r2, [pc, #164]	@ (8018654 <lv_draw_sw_mask_angle_init+0x13c>)
 80185ae:	601a      	str	r2, [r3, #0]
    param->dsc.type = LV_DRAW_SW_MASK_TYPE_ANGLE;
 80185b0:	68fb      	ldr	r3, [r7, #12]
 80185b2:	2201      	movs	r2, #1
 80185b4:	711a      	strb	r2, [r3, #4]

    LV_ASSERT_MSG(start_angle >= 0 && start_angle <= 360, "Unexpected start angle");
 80185b6:	683b      	ldr	r3, [r7, #0]
 80185b8:	2b00      	cmp	r3, #0
 80185ba:	db04      	blt.n	80185c6 <lv_draw_sw_mask_angle_init+0xae>
 80185bc:	683b      	ldr	r3, [r7, #0]
 80185be:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 80185c2:	dc00      	bgt.n	80185c6 <lv_draw_sw_mask_angle_init+0xae>
 80185c4:	e000      	b.n	80185c8 <lv_draw_sw_mask_angle_init+0xb0>
 80185c6:	e7fe      	b.n	80185c6 <lv_draw_sw_mask_angle_init+0xae>

    if(start_angle >= 0 && start_angle < 180) {
 80185c8:	683b      	ldr	r3, [r7, #0]
 80185ca:	2b00      	cmp	r3, #0
 80185cc:	db05      	blt.n	80185da <lv_draw_sw_mask_angle_init+0xc2>
 80185ce:	683b      	ldr	r3, [r7, #0]
 80185d0:	2bb3      	cmp	r3, #179	@ 0xb3
 80185d2:	dc02      	bgt.n	80185da <lv_draw_sw_mask_angle_init+0xc2>
        start_side = LV_DRAW_SW_MASK_LINE_SIDE_LEFT;
 80185d4:	2300      	movs	r3, #0
 80185d6:	75fb      	strb	r3, [r7, #23]
 80185d8:	e001      	b.n	80185de <lv_draw_sw_mask_angle_init+0xc6>
    }
    else
        start_side = LV_DRAW_SW_MASK_LINE_SIDE_RIGHT; /*silence compiler*/
 80185da:	2301      	movs	r3, #1
 80185dc:	75fb      	strb	r3, [r7, #23]

    LV_ASSERT_MSG(end_angle >= 0 && start_angle <= 360, "Unexpected end angle");
 80185de:	6a3b      	ldr	r3, [r7, #32]
 80185e0:	2b00      	cmp	r3, #0
 80185e2:	db04      	blt.n	80185ee <lv_draw_sw_mask_angle_init+0xd6>
 80185e4:	683b      	ldr	r3, [r7, #0]
 80185e6:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 80185ea:	dc00      	bgt.n	80185ee <lv_draw_sw_mask_angle_init+0xd6>
 80185ec:	e000      	b.n	80185f0 <lv_draw_sw_mask_angle_init+0xd8>
 80185ee:	e7fe      	b.n	80185ee <lv_draw_sw_mask_angle_init+0xd6>

    if(end_angle >= 0 && end_angle < 180) {
 80185f0:	6a3b      	ldr	r3, [r7, #32]
 80185f2:	2b00      	cmp	r3, #0
 80185f4:	db05      	blt.n	8018602 <lv_draw_sw_mask_angle_init+0xea>
 80185f6:	6a3b      	ldr	r3, [r7, #32]
 80185f8:	2bb3      	cmp	r3, #179	@ 0xb3
 80185fa:	dc02      	bgt.n	8018602 <lv_draw_sw_mask_angle_init+0xea>
        end_side = LV_DRAW_SW_MASK_LINE_SIDE_RIGHT;
 80185fc:	2301      	movs	r3, #1
 80185fe:	75bb      	strb	r3, [r7, #22]
 8018600:	e00b      	b.n	801861a <lv_draw_sw_mask_angle_init+0x102>
    }
    else if(end_angle >= 180 && end_angle < 360) {
 8018602:	6a3b      	ldr	r3, [r7, #32]
 8018604:	2bb3      	cmp	r3, #179	@ 0xb3
 8018606:	dd06      	ble.n	8018616 <lv_draw_sw_mask_angle_init+0xfe>
 8018608:	6a3b      	ldr	r3, [r7, #32]
 801860a:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 801860e:	da02      	bge.n	8018616 <lv_draw_sw_mask_angle_init+0xfe>
        end_side = LV_DRAW_SW_MASK_LINE_SIDE_LEFT;
 8018610:	2300      	movs	r3, #0
 8018612:	75bb      	strb	r3, [r7, #22]
 8018614:	e001      	b.n	801861a <lv_draw_sw_mask_angle_init+0x102>
    }
    else
        end_side = LV_DRAW_SW_MASK_LINE_SIDE_RIGHT; /*silence compiler*/
 8018616:	2301      	movs	r3, #1
 8018618:	75bb      	strb	r3, [r7, #22]

    lv_draw_sw_mask_line_angle_init(&param->start_line, vertex_x, vertex_y, start_angle, start_side);
 801861a:	68fb      	ldr	r3, [r7, #12]
 801861c:	f103 0018 	add.w	r0, r3, #24
 8018620:	683b      	ldr	r3, [r7, #0]
 8018622:	b21a      	sxth	r2, r3
 8018624:	7dfb      	ldrb	r3, [r7, #23]
 8018626:	9300      	str	r3, [sp, #0]
 8018628:	4613      	mov	r3, r2
 801862a:	687a      	ldr	r2, [r7, #4]
 801862c:	68b9      	ldr	r1, [r7, #8]
 801862e:	f7ff ff3f 	bl	80184b0 <lv_draw_sw_mask_line_angle_init>
    lv_draw_sw_mask_line_angle_init(&param->end_line, vertex_x, vertex_y, end_angle, end_side);
 8018632:	68fb      	ldr	r3, [r7, #12]
 8018634:	f103 0050 	add.w	r0, r3, #80	@ 0x50
 8018638:	6a3b      	ldr	r3, [r7, #32]
 801863a:	b21a      	sxth	r2, r3
 801863c:	7dbb      	ldrb	r3, [r7, #22]
 801863e:	9300      	str	r3, [sp, #0]
 8018640:	4613      	mov	r3, r2
 8018642:	687a      	ldr	r2, [r7, #4]
 8018644:	68b9      	ldr	r1, [r7, #8]
 8018646:	f7ff ff33 	bl	80184b0 <lv_draw_sw_mask_line_angle_init>
}
 801864a:	bf00      	nop
 801864c:	3718      	adds	r7, #24
 801864e:	46bd      	mov	sp, r7
 8018650:	bd80      	pop	{r7, pc}
 8018652:	bf00      	nop
 8018654:	08019155 	.word	0x08019155

08018658 <lv_draw_sw_mask_radius_init>:

void lv_draw_sw_mask_radius_init(lv_draw_sw_mask_radius_param_t * param, const lv_area_t * rect, int32_t radius,
                                 bool inv)
{
 8018658:	b580      	push	{r7, lr}
 801865a:	b08a      	sub	sp, #40	@ 0x28
 801865c:	af00      	add	r7, sp, #0
 801865e:	60f8      	str	r0, [r7, #12]
 8018660:	60b9      	str	r1, [r7, #8]
 8018662:	607a      	str	r2, [r7, #4]
 8018664:	70fb      	strb	r3, [r7, #3]
    int32_t w = lv_area_get_width(rect);
 8018666:	68b8      	ldr	r0, [r7, #8]
 8018668:	f7ff fd35 	bl	80180d6 <lv_area_get_width>
 801866c:	61f8      	str	r0, [r7, #28]
    int32_t h = lv_area_get_height(rect);
 801866e:	68b8      	ldr	r0, [r7, #8]
 8018670:	f7ff fd41 	bl	80180f6 <lv_area_get_height>
 8018674:	61b8      	str	r0, [r7, #24]
    int32_t short_side = LV_MIN(w, h);
 8018676:	69ba      	ldr	r2, [r7, #24]
 8018678:	69fb      	ldr	r3, [r7, #28]
 801867a:	4293      	cmp	r3, r2
 801867c:	bfa8      	it	ge
 801867e:	4613      	movge	r3, r2
 8018680:	617b      	str	r3, [r7, #20]
    if(radius > short_side >> 1) radius = short_side >> 1;
 8018682:	697b      	ldr	r3, [r7, #20]
 8018684:	105b      	asrs	r3, r3, #1
 8018686:	687a      	ldr	r2, [r7, #4]
 8018688:	429a      	cmp	r2, r3
 801868a:	dd02      	ble.n	8018692 <lv_draw_sw_mask_radius_init+0x3a>
 801868c:	697b      	ldr	r3, [r7, #20]
 801868e:	105b      	asrs	r3, r3, #1
 8018690:	607b      	str	r3, [r7, #4]
    if(radius < 0) radius = 0;
 8018692:	687b      	ldr	r3, [r7, #4]
 8018694:	2b00      	cmp	r3, #0
 8018696:	da01      	bge.n	801869c <lv_draw_sw_mask_radius_init+0x44>
 8018698:	2300      	movs	r3, #0
 801869a:	607b      	str	r3, [r7, #4]

    lv_area_copy(&param->cfg.rect, rect);
 801869c:	68fb      	ldr	r3, [r7, #12]
 801869e:	3308      	adds	r3, #8
 80186a0:	68b9      	ldr	r1, [r7, #8]
 80186a2:	4618      	mov	r0, r3
 80186a4:	f7ff fcfc 	bl	80180a0 <lv_area_copy>
    param->cfg.radius = radius;
 80186a8:	68fb      	ldr	r3, [r7, #12]
 80186aa:	687a      	ldr	r2, [r7, #4]
 80186ac:	619a      	str	r2, [r3, #24]
    param->cfg.outer = inv ? 1 : 0;
 80186ae:	78f9      	ldrb	r1, [r7, #3]
 80186b0:	68fa      	ldr	r2, [r7, #12]
 80186b2:	7f13      	ldrb	r3, [r2, #28]
 80186b4:	f361 0300 	bfi	r3, r1, #0, #1
 80186b8:	7713      	strb	r3, [r2, #28]
    param->dsc.cb = (lv_draw_sw_mask_xcb_t)lv_draw_mask_radius;
 80186ba:	68fb      	ldr	r3, [r7, #12]
 80186bc:	4a70      	ldr	r2, [pc, #448]	@ (8018880 <lv_draw_sw_mask_radius_init+0x228>)
 80186be:	601a      	str	r2, [r3, #0]
    param->dsc.type = LV_DRAW_SW_MASK_TYPE_RADIUS;
 80186c0:	68fb      	ldr	r3, [r7, #12]
 80186c2:	2202      	movs	r2, #2
 80186c4:	711a      	strb	r2, [r3, #4]

    if(radius == 0) {
 80186c6:	687b      	ldr	r3, [r7, #4]
 80186c8:	2b00      	cmp	r3, #0
 80186ca:	d103      	bne.n	80186d4 <lv_draw_sw_mask_radius_init+0x7c>
        param->circle = NULL;
 80186cc:	68fb      	ldr	r3, [r7, #12]
 80186ce:	2200      	movs	r2, #0
 80186d0:	621a      	str	r2, [r3, #32]
        return;
 80186d2:	e0d2      	b.n	801887a <lv_draw_sw_mask_radius_init+0x222>
    }

    lv_mutex_lock(&circle_cache_mutex);
 80186d4:	486b      	ldr	r0, [pc, #428]	@ (8018884 <lv_draw_sw_mask_radius_init+0x22c>)
 80186d6:	f00c f8b2 	bl	802483e <lv_mutex_lock>

    uint32_t i;

    /*Try to reuse a circle cache entry*/
    for(i = 0; i < LV_DRAW_SW_CIRCLE_CACHE_SIZE; i++) {
 80186da:	2300      	movs	r3, #0
 80186dc:	627b      	str	r3, [r7, #36]	@ 0x24
 80186de:	e055      	b.n	801878c <lv_draw_sw_mask_radius_init+0x134>
        if(_circle_cache[i].radius == radius) {
 80186e0:	4969      	ldr	r1, [pc, #420]	@ (8018888 <lv_draw_sw_mask_radius_init+0x230>)
 80186e2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80186e4:	4613      	mov	r3, r2
 80186e6:	00db      	lsls	r3, r3, #3
 80186e8:	1a9b      	subs	r3, r3, r2
 80186ea:	009b      	lsls	r3, r3, #2
 80186ec:	440b      	add	r3, r1
 80186ee:	f503 7390 	add.w	r3, r3, #288	@ 0x120
 80186f2:	681b      	ldr	r3, [r3, #0]
 80186f4:	687a      	ldr	r2, [r7, #4]
 80186f6:	429a      	cmp	r2, r3
 80186f8:	d145      	bne.n	8018786 <lv_draw_sw_mask_radius_init+0x12e>
            _circle_cache[i].used_cnt++;
 80186fa:	4963      	ldr	r1, [pc, #396]	@ (8018888 <lv_draw_sw_mask_radius_init+0x230>)
 80186fc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80186fe:	4613      	mov	r3, r2
 8018700:	00db      	lsls	r3, r3, #3
 8018702:	1a9b      	subs	r3, r3, r2
 8018704:	009b      	lsls	r3, r3, #2
 8018706:	440b      	add	r3, r1
 8018708:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 801870c:	681b      	ldr	r3, [r3, #0]
 801870e:	1c59      	adds	r1, r3, #1
 8018710:	485d      	ldr	r0, [pc, #372]	@ (8018888 <lv_draw_sw_mask_radius_init+0x230>)
 8018712:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018714:	4613      	mov	r3, r2
 8018716:	00db      	lsls	r3, r3, #3
 8018718:	1a9b      	subs	r3, r3, r2
 801871a:	009b      	lsls	r3, r3, #2
 801871c:	4403      	add	r3, r0
 801871e:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 8018722:	6019      	str	r1, [r3, #0]
            CIRCLE_CACHE_AGING(_circle_cache[i].life, radius);
 8018724:	4958      	ldr	r1, [pc, #352]	@ (8018888 <lv_draw_sw_mask_radius_init+0x230>)
 8018726:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018728:	4613      	mov	r3, r2
 801872a:	00db      	lsls	r3, r3, #3
 801872c:	1a9b      	subs	r3, r3, r2
 801872e:	009b      	lsls	r3, r3, #2
 8018730:	440b      	add	r3, r1
 8018732:	f503 738c 	add.w	r3, r3, #280	@ 0x118
 8018736:	681a      	ldr	r2, [r3, #0]
 8018738:	687b      	ldr	r3, [r7, #4]
 801873a:	2b0f      	cmp	r3, #15
 801873c:	dd02      	ble.n	8018744 <lv_draw_sw_mask_radius_init+0xec>
 801873e:	687b      	ldr	r3, [r7, #4]
 8018740:	111b      	asrs	r3, r3, #4
 8018742:	e000      	b.n	8018746 <lv_draw_sw_mask_radius_init+0xee>
 8018744:	2301      	movs	r3, #1
 8018746:	4413      	add	r3, r2
 8018748:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 801874c:	bfa8      	it	ge
 801874e:	f44f 737a 	movge.w	r3, #1000	@ 0x3e8
 8018752:	4619      	mov	r1, r3
 8018754:	484c      	ldr	r0, [pc, #304]	@ (8018888 <lv_draw_sw_mask_radius_init+0x230>)
 8018756:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018758:	4613      	mov	r3, r2
 801875a:	00db      	lsls	r3, r3, #3
 801875c:	1a9b      	subs	r3, r3, r2
 801875e:	009b      	lsls	r3, r3, #2
 8018760:	4403      	add	r3, r0
 8018762:	f503 738c 	add.w	r3, r3, #280	@ 0x118
 8018766:	6019      	str	r1, [r3, #0]
            param->circle = &(_circle_cache[i]);
 8018768:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801876a:	4613      	mov	r3, r2
 801876c:	00db      	lsls	r3, r3, #3
 801876e:	1a9b      	subs	r3, r3, r2
 8018770:	009b      	lsls	r3, r3, #2
 8018772:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 8018776:	4a44      	ldr	r2, [pc, #272]	@ (8018888 <lv_draw_sw_mask_radius_init+0x230>)
 8018778:	441a      	add	r2, r3
 801877a:	68fb      	ldr	r3, [r7, #12]
 801877c:	621a      	str	r2, [r3, #32]
            lv_mutex_unlock(&circle_cache_mutex);
 801877e:	4841      	ldr	r0, [pc, #260]	@ (8018884 <lv_draw_sw_mask_radius_init+0x22c>)
 8018780:	f00c f868 	bl	8024854 <lv_mutex_unlock>
            return;
 8018784:	e079      	b.n	801887a <lv_draw_sw_mask_radius_init+0x222>
    for(i = 0; i < LV_DRAW_SW_CIRCLE_CACHE_SIZE; i++) {
 8018786:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018788:	3301      	adds	r3, #1
 801878a:	627b      	str	r3, [r7, #36]	@ 0x24
 801878c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801878e:	2b03      	cmp	r3, #3
 8018790:	d9a6      	bls.n	80186e0 <lv_draw_sw_mask_radius_init+0x88>
        }
    }

    /*If not cached use the free entry with lowest life*/
    _lv_draw_sw_mask_radius_circle_dsc_t * entry = NULL;
 8018792:	2300      	movs	r3, #0
 8018794:	623b      	str	r3, [r7, #32]
    for(i = 0; i < LV_DRAW_SW_CIRCLE_CACHE_SIZE; i++) {
 8018796:	2300      	movs	r3, #0
 8018798:	627b      	str	r3, [r7, #36]	@ 0x24
 801879a:	e034      	b.n	8018806 <lv_draw_sw_mask_radius_init+0x1ae>
        if(_circle_cache[i].used_cnt == 0) {
 801879c:	493a      	ldr	r1, [pc, #232]	@ (8018888 <lv_draw_sw_mask_radius_init+0x230>)
 801879e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80187a0:	4613      	mov	r3, r2
 80187a2:	00db      	lsls	r3, r3, #3
 80187a4:	1a9b      	subs	r3, r3, r2
 80187a6:	009b      	lsls	r3, r3, #2
 80187a8:	440b      	add	r3, r1
 80187aa:	f503 738e 	add.w	r3, r3, #284	@ 0x11c
 80187ae:	681b      	ldr	r3, [r3, #0]
 80187b0:	2b00      	cmp	r3, #0
 80187b2:	d125      	bne.n	8018800 <lv_draw_sw_mask_radius_init+0x1a8>
            if(!entry) entry = &(_circle_cache[i]);
 80187b4:	6a3b      	ldr	r3, [r7, #32]
 80187b6:	2b00      	cmp	r3, #0
 80187b8:	d10a      	bne.n	80187d0 <lv_draw_sw_mask_radius_init+0x178>
 80187ba:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80187bc:	4613      	mov	r3, r2
 80187be:	00db      	lsls	r3, r3, #3
 80187c0:	1a9b      	subs	r3, r3, r2
 80187c2:	009b      	lsls	r3, r3, #2
 80187c4:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 80187c8:	4a2f      	ldr	r2, [pc, #188]	@ (8018888 <lv_draw_sw_mask_radius_init+0x230>)
 80187ca:	4413      	add	r3, r2
 80187cc:	623b      	str	r3, [r7, #32]
 80187ce:	e017      	b.n	8018800 <lv_draw_sw_mask_radius_init+0x1a8>
            else if(_circle_cache[i].life < entry->life) entry = &(_circle_cache[i]);
 80187d0:	492d      	ldr	r1, [pc, #180]	@ (8018888 <lv_draw_sw_mask_radius_init+0x230>)
 80187d2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80187d4:	4613      	mov	r3, r2
 80187d6:	00db      	lsls	r3, r3, #3
 80187d8:	1a9b      	subs	r3, r3, r2
 80187da:	009b      	lsls	r3, r3, #2
 80187dc:	440b      	add	r3, r1
 80187de:	f503 738c 	add.w	r3, r3, #280	@ 0x118
 80187e2:	681a      	ldr	r2, [r3, #0]
 80187e4:	6a3b      	ldr	r3, [r7, #32]
 80187e6:	691b      	ldr	r3, [r3, #16]
 80187e8:	429a      	cmp	r2, r3
 80187ea:	da09      	bge.n	8018800 <lv_draw_sw_mask_radius_init+0x1a8>
 80187ec:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80187ee:	4613      	mov	r3, r2
 80187f0:	00db      	lsls	r3, r3, #3
 80187f2:	1a9b      	subs	r3, r3, r2
 80187f4:	009b      	lsls	r3, r3, #2
 80187f6:	f503 7384 	add.w	r3, r3, #264	@ 0x108
 80187fa:	4a23      	ldr	r2, [pc, #140]	@ (8018888 <lv_draw_sw_mask_radius_init+0x230>)
 80187fc:	4413      	add	r3, r2
 80187fe:	623b      	str	r3, [r7, #32]
    for(i = 0; i < LV_DRAW_SW_CIRCLE_CACHE_SIZE; i++) {
 8018800:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018802:	3301      	adds	r3, #1
 8018804:	627b      	str	r3, [r7, #36]	@ 0x24
 8018806:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018808:	2b03      	cmp	r3, #3
 801880a:	d9c7      	bls.n	801879c <lv_draw_sw_mask_radius_init+0x144>
        }
    }

    /*There is no unused entry. Allocate one temporarily*/
    if(!entry) {
 801880c:	6a3b      	ldr	r3, [r7, #32]
 801880e:	2b00      	cmp	r3, #0
 8018810:	d10d      	bne.n	801882e <lv_draw_sw_mask_radius_init+0x1d6>
        entry = lv_malloc_zeroed(sizeof(_lv_draw_sw_mask_radius_circle_dsc_t));
 8018812:	201c      	movs	r0, #28
 8018814:	f00d faf2 	bl	8025dfc <lv_malloc_zeroed>
 8018818:	6238      	str	r0, [r7, #32]
        LV_ASSERT_MALLOC(entry);
 801881a:	6a3b      	ldr	r3, [r7, #32]
 801881c:	2b00      	cmp	r3, #0
 801881e:	d101      	bne.n	8018824 <lv_draw_sw_mask_radius_init+0x1cc>
 8018820:	bf00      	nop
 8018822:	e7fd      	b.n	8018820 <lv_draw_sw_mask_radius_init+0x1c8>
        entry->life = -1;
 8018824:	6a3b      	ldr	r3, [r7, #32]
 8018826:	f04f 32ff 	mov.w	r2, #4294967295
 801882a:	611a      	str	r2, [r3, #16]
 801882c:	e019      	b.n	8018862 <lv_draw_sw_mask_radius_init+0x20a>
    }
    else {
        entry->used_cnt++;
 801882e:	6a3b      	ldr	r3, [r7, #32]
 8018830:	695b      	ldr	r3, [r3, #20]
 8018832:	1c5a      	adds	r2, r3, #1
 8018834:	6a3b      	ldr	r3, [r7, #32]
 8018836:	615a      	str	r2, [r3, #20]
        entry->life = 0;
 8018838:	6a3b      	ldr	r3, [r7, #32]
 801883a:	2200      	movs	r2, #0
 801883c:	611a      	str	r2, [r3, #16]
        CIRCLE_CACHE_AGING(entry->life, radius);
 801883e:	6a3b      	ldr	r3, [r7, #32]
 8018840:	691a      	ldr	r2, [r3, #16]
 8018842:	687b      	ldr	r3, [r7, #4]
 8018844:	2b0f      	cmp	r3, #15
 8018846:	dd02      	ble.n	801884e <lv_draw_sw_mask_radius_init+0x1f6>
 8018848:	687b      	ldr	r3, [r7, #4]
 801884a:	111b      	asrs	r3, r3, #4
 801884c:	e000      	b.n	8018850 <lv_draw_sw_mask_radius_init+0x1f8>
 801884e:	2301      	movs	r3, #1
 8018850:	4413      	add	r3, r2
 8018852:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8018856:	bfa8      	it	ge
 8018858:	f44f 737a 	movge.w	r3, #1000	@ 0x3e8
 801885c:	461a      	mov	r2, r3
 801885e:	6a3b      	ldr	r3, [r7, #32]
 8018860:	611a      	str	r2, [r3, #16]
    }

    param->circle = entry;
 8018862:	68fb      	ldr	r3, [r7, #12]
 8018864:	6a3a      	ldr	r2, [r7, #32]
 8018866:	621a      	str	r2, [r3, #32]

    circ_calc_aa4(param->circle, radius);
 8018868:	68fb      	ldr	r3, [r7, #12]
 801886a:	6a1b      	ldr	r3, [r3, #32]
 801886c:	6879      	ldr	r1, [r7, #4]
 801886e:	4618      	mov	r0, r3
 8018870:	f001 f95b 	bl	8019b2a <circ_calc_aa4>
    lv_mutex_unlock(&circle_cache_mutex);
 8018874:	4803      	ldr	r0, [pc, #12]	@ (8018884 <lv_draw_sw_mask_radius_init+0x22c>)
 8018876:	f00b ffed 	bl	8024854 <lv_mutex_unlock>

}
 801887a:	3728      	adds	r7, #40	@ 0x28
 801887c:	46bd      	mov	sp, r7
 801887e:	bd80      	pop	{r7, pc}
 8018880:	08019675 	.word	0x08019675
 8018884:	2000019c 	.word	0x2000019c
 8018888:	2000009c 	.word	0x2000009c

0801888c <lv_draw_mask_line>:
 **********************/

static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_mask_line(lv_opa_t * mask_buf, int32_t abs_x,
                                                                     int32_t abs_y, int32_t len,
                                                                     lv_draw_sw_mask_line_param_t * p)
{
 801888c:	b580      	push	{r7, lr}
 801888e:	b08a      	sub	sp, #40	@ 0x28
 8018890:	af02      	add	r7, sp, #8
 8018892:	60f8      	str	r0, [r7, #12]
 8018894:	60b9      	str	r1, [r7, #8]
 8018896:	607a      	str	r2, [r7, #4]
 8018898:	603b      	str	r3, [r7, #0]
    /*Make to points relative to the vertex*/
    abs_y -= p->origo.y;
 801889a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801889c:	6a1b      	ldr	r3, [r3, #32]
 801889e:	687a      	ldr	r2, [r7, #4]
 80188a0:	1ad3      	subs	r3, r2, r3
 80188a2:	607b      	str	r3, [r7, #4]
    abs_x -= p->origo.x;
 80188a4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80188a6:	69db      	ldr	r3, [r3, #28]
 80188a8:	68ba      	ldr	r2, [r7, #8]
 80188aa:	1ad3      	subs	r3, r2, r3
 80188ac:	60bb      	str	r3, [r7, #8]

    /*Handle special cases*/
    if(p->steep == 0) {
 80188ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80188b0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80188b2:	2b00      	cmp	r3, #0
 80188b4:	f040 8099 	bne.w	80189ea <lv_draw_mask_line+0x15e>
        /*Horizontal*/
        if(p->flat) {
 80188b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80188ba:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 80188be:	f003 0301 	and.w	r3, r3, #1
 80188c2:	b2db      	uxtb	r3, r3
 80188c4:	2b00      	cmp	r3, #0
 80188c6:	d029      	beq.n	801891c <lv_draw_mask_line+0x90>
            /*Non sense: Can't be on the right/left of a horizontal line*/
            if(p->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_LEFT ||
 80188c8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80188ca:	7e1b      	ldrb	r3, [r3, #24]
 80188cc:	f003 0303 	and.w	r3, r3, #3
 80188d0:	b2db      	uxtb	r3, r3
 80188d2:	2b00      	cmp	r3, #0
 80188d4:	d006      	beq.n	80188e4 <lv_draw_mask_line+0x58>
               p->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_RIGHT) return LV_DRAW_SW_MASK_RES_FULL_COVER;
 80188d6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80188d8:	7e1b      	ldrb	r3, [r3, #24]
 80188da:	f003 0303 	and.w	r3, r3, #3
 80188de:	b2db      	uxtb	r3, r3
            if(p->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_LEFT ||
 80188e0:	2b01      	cmp	r3, #1
 80188e2:	d101      	bne.n	80188e8 <lv_draw_mask_line+0x5c>
               p->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_RIGHT) return LV_DRAW_SW_MASK_RES_FULL_COVER;
 80188e4:	2301      	movs	r3, #1
 80188e6:	e09e      	b.n	8018a26 <lv_draw_mask_line+0x19a>
            else if(p->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_TOP && abs_y < 0) return LV_DRAW_SW_MASK_RES_FULL_COVER;
 80188e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80188ea:	7e1b      	ldrb	r3, [r3, #24]
 80188ec:	f003 0303 	and.w	r3, r3, #3
 80188f0:	b2db      	uxtb	r3, r3
 80188f2:	2b02      	cmp	r3, #2
 80188f4:	d104      	bne.n	8018900 <lv_draw_mask_line+0x74>
 80188f6:	687b      	ldr	r3, [r7, #4]
 80188f8:	2b00      	cmp	r3, #0
 80188fa:	da01      	bge.n	8018900 <lv_draw_mask_line+0x74>
 80188fc:	2301      	movs	r3, #1
 80188fe:	e092      	b.n	8018a26 <lv_draw_mask_line+0x19a>
            else if(p->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_BOTTOM && abs_y > 0) return LV_DRAW_SW_MASK_RES_FULL_COVER;
 8018900:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018902:	7e1b      	ldrb	r3, [r3, #24]
 8018904:	f003 0303 	and.w	r3, r3, #3
 8018908:	b2db      	uxtb	r3, r3
 801890a:	2b03      	cmp	r3, #3
 801890c:	d104      	bne.n	8018918 <lv_draw_mask_line+0x8c>
 801890e:	687b      	ldr	r3, [r7, #4]
 8018910:	2b00      	cmp	r3, #0
 8018912:	dd01      	ble.n	8018918 <lv_draw_mask_line+0x8c>
 8018914:	2301      	movs	r3, #1
 8018916:	e086      	b.n	8018a26 <lv_draw_mask_line+0x19a>
            else {
                return LV_DRAW_SW_MASK_RES_TRANSP;
 8018918:	2300      	movs	r3, #0
 801891a:	e084      	b.n	8018a26 <lv_draw_mask_line+0x19a>
            }
        }
        /*Vertical*/
        else {
            /*Non sense: Can't be on the top/bottom of a vertical line*/
            if(p->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_TOP ||
 801891c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801891e:	7e1b      	ldrb	r3, [r3, #24]
 8018920:	f003 0303 	and.w	r3, r3, #3
 8018924:	b2db      	uxtb	r3, r3
 8018926:	2b02      	cmp	r3, #2
 8018928:	d006      	beq.n	8018938 <lv_draw_mask_line+0xac>
               p->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_BOTTOM) return LV_DRAW_SW_MASK_RES_FULL_COVER;
 801892a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801892c:	7e1b      	ldrb	r3, [r3, #24]
 801892e:	f003 0303 	and.w	r3, r3, #3
 8018932:	b2db      	uxtb	r3, r3
            if(p->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_TOP ||
 8018934:	2b03      	cmp	r3, #3
 8018936:	d101      	bne.n	801893c <lv_draw_mask_line+0xb0>
               p->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_BOTTOM) return LV_DRAW_SW_MASK_RES_FULL_COVER;
 8018938:	2301      	movs	r3, #1
 801893a:	e074      	b.n	8018a26 <lv_draw_mask_line+0x19a>
            else if(p->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_RIGHT && abs_x > 0) return LV_DRAW_SW_MASK_RES_FULL_COVER;
 801893c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801893e:	7e1b      	ldrb	r3, [r3, #24]
 8018940:	f003 0303 	and.w	r3, r3, #3
 8018944:	b2db      	uxtb	r3, r3
 8018946:	2b01      	cmp	r3, #1
 8018948:	d104      	bne.n	8018954 <lv_draw_mask_line+0xc8>
 801894a:	68bb      	ldr	r3, [r7, #8]
 801894c:	2b00      	cmp	r3, #0
 801894e:	dd01      	ble.n	8018954 <lv_draw_mask_line+0xc8>
 8018950:	2301      	movs	r3, #1
 8018952:	e068      	b.n	8018a26 <lv_draw_mask_line+0x19a>
            else if(p->cfg.side == LV_DRAW_SW_MASK_LINE_SIDE_LEFT) {
 8018954:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018956:	7e1b      	ldrb	r3, [r3, #24]
 8018958:	f003 0303 	and.w	r3, r3, #3
 801895c:	b2db      	uxtb	r3, r3
 801895e:	2b00      	cmp	r3, #0
 8018960:	d120      	bne.n	80189a4 <lv_draw_mask_line+0x118>
                if(abs_x + len < 0) return LV_DRAW_SW_MASK_RES_FULL_COVER;
 8018962:	68ba      	ldr	r2, [r7, #8]
 8018964:	683b      	ldr	r3, [r7, #0]
 8018966:	4413      	add	r3, r2
 8018968:	2b00      	cmp	r3, #0
 801896a:	da01      	bge.n	8018970 <lv_draw_mask_line+0xe4>
 801896c:	2301      	movs	r3, #1
 801896e:	e05a      	b.n	8018a26 <lv_draw_mask_line+0x19a>
                else {
                    int32_t k = - abs_x;
 8018970:	68bb      	ldr	r3, [r7, #8]
 8018972:	425b      	negs	r3, r3
 8018974:	617b      	str	r3, [r7, #20]
                    if(k < 0) return LV_DRAW_SW_MASK_RES_TRANSP;
 8018976:	697b      	ldr	r3, [r7, #20]
 8018978:	2b00      	cmp	r3, #0
 801897a:	da01      	bge.n	8018980 <lv_draw_mask_line+0xf4>
 801897c:	2300      	movs	r3, #0
 801897e:	e052      	b.n	8018a26 <lv_draw_mask_line+0x19a>
                    if(k >= 0 && k < len) lv_memzero(&mask_buf[k], len - k);
 8018980:	697b      	ldr	r3, [r7, #20]
 8018982:	2b00      	cmp	r3, #0
 8018984:	db0c      	blt.n	80189a0 <lv_draw_mask_line+0x114>
 8018986:	697a      	ldr	r2, [r7, #20]
 8018988:	683b      	ldr	r3, [r7, #0]
 801898a:	429a      	cmp	r2, r3
 801898c:	da08      	bge.n	80189a0 <lv_draw_mask_line+0x114>
 801898e:	697b      	ldr	r3, [r7, #20]
 8018990:	68fa      	ldr	r2, [r7, #12]
 8018992:	18d0      	adds	r0, r2, r3
 8018994:	683a      	ldr	r2, [r7, #0]
 8018996:	697b      	ldr	r3, [r7, #20]
 8018998:	1ad3      	subs	r3, r2, r3
 801899a:	4619      	mov	r1, r3
 801899c:	f7ff fbcd 	bl	801813a <lv_memzero>
                    return  LV_DRAW_SW_MASK_RES_CHANGED;
 80189a0:	2302      	movs	r3, #2
 80189a2:	e040      	b.n	8018a26 <lv_draw_mask_line+0x19a>
                }
            }
            else {
                if(abs_x + len < 0) return LV_DRAW_SW_MASK_RES_TRANSP;
 80189a4:	68ba      	ldr	r2, [r7, #8]
 80189a6:	683b      	ldr	r3, [r7, #0]
 80189a8:	4413      	add	r3, r2
 80189aa:	2b00      	cmp	r3, #0
 80189ac:	da01      	bge.n	80189b2 <lv_draw_mask_line+0x126>
 80189ae:	2300      	movs	r3, #0
 80189b0:	e039      	b.n	8018a26 <lv_draw_mask_line+0x19a>
                else {
                    int32_t k = - abs_x;
 80189b2:	68bb      	ldr	r3, [r7, #8]
 80189b4:	425b      	negs	r3, r3
 80189b6:	61fb      	str	r3, [r7, #28]
                    if(k < 0) k = 0;
 80189b8:	69fb      	ldr	r3, [r7, #28]
 80189ba:	2b00      	cmp	r3, #0
 80189bc:	da01      	bge.n	80189c2 <lv_draw_mask_line+0x136>
 80189be:	2300      	movs	r3, #0
 80189c0:	61fb      	str	r3, [r7, #28]
                    if(k >= len) return LV_DRAW_SW_MASK_RES_TRANSP;
 80189c2:	69fa      	ldr	r2, [r7, #28]
 80189c4:	683b      	ldr	r3, [r7, #0]
 80189c6:	429a      	cmp	r2, r3
 80189c8:	db01      	blt.n	80189ce <lv_draw_mask_line+0x142>
 80189ca:	2300      	movs	r3, #0
 80189cc:	e02b      	b.n	8018a26 <lv_draw_mask_line+0x19a>
                    else if(k >= 0 && k < len) lv_memzero(&mask_buf[0], k);
 80189ce:	69fb      	ldr	r3, [r7, #28]
 80189d0:	2b00      	cmp	r3, #0
 80189d2:	db08      	blt.n	80189e6 <lv_draw_mask_line+0x15a>
 80189d4:	69fa      	ldr	r2, [r7, #28]
 80189d6:	683b      	ldr	r3, [r7, #0]
 80189d8:	429a      	cmp	r2, r3
 80189da:	da04      	bge.n	80189e6 <lv_draw_mask_line+0x15a>
 80189dc:	69fb      	ldr	r3, [r7, #28]
 80189de:	4619      	mov	r1, r3
 80189e0:	68f8      	ldr	r0, [r7, #12]
 80189e2:	f7ff fbaa 	bl	801813a <lv_memzero>
                    return  LV_DRAW_SW_MASK_RES_CHANGED;
 80189e6:	2302      	movs	r3, #2
 80189e8:	e01d      	b.n	8018a26 <lv_draw_mask_line+0x19a>
            }
        }
    }

    lv_draw_sw_mask_res_t res;
    if(p->flat) {
 80189ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80189ec:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 80189f0:	f003 0301 	and.w	r3, r3, #1
 80189f4:	b2db      	uxtb	r3, r3
 80189f6:	2b00      	cmp	r3, #0
 80189f8:	d00a      	beq.n	8018a10 <lv_draw_mask_line+0x184>
        res = line_mask_flat(mask_buf, abs_x, abs_y, len, p);
 80189fa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80189fc:	9300      	str	r3, [sp, #0]
 80189fe:	683b      	ldr	r3, [r7, #0]
 8018a00:	687a      	ldr	r2, [r7, #4]
 8018a02:	68b9      	ldr	r1, [r7, #8]
 8018a04:	68f8      	ldr	r0, [r7, #12]
 8018a06:	f000 f812 	bl	8018a2e <line_mask_flat>
 8018a0a:	4603      	mov	r3, r0
 8018a0c:	76fb      	strb	r3, [r7, #27]
 8018a0e:	e009      	b.n	8018a24 <lv_draw_mask_line+0x198>
    }
    else {
        res = line_mask_steep(mask_buf, abs_x, abs_y, len, p);
 8018a10:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018a12:	9300      	str	r3, [sp, #0]
 8018a14:	683b      	ldr	r3, [r7, #0]
 8018a16:	687a      	ldr	r2, [r7, #4]
 8018a18:	68b9      	ldr	r1, [r7, #8]
 8018a1a:	68f8      	ldr	r0, [r7, #12]
 8018a1c:	f000 f979 	bl	8018d12 <line_mask_steep>
 8018a20:	4603      	mov	r3, r0
 8018a22:	76fb      	strb	r3, [r7, #27]
    }

    return res;
 8018a24:	7efb      	ldrb	r3, [r7, #27]
}
 8018a26:	4618      	mov	r0, r3
 8018a28:	3720      	adds	r7, #32
 8018a2a:	46bd      	mov	sp, r7
 8018a2c:	bd80      	pop	{r7, pc}

08018a2e <line_mask_flat>:

static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM line_mask_flat(lv_opa_t * mask_buf, int32_t abs_x,
                                                                  int32_t abs_y,
                                                                  int32_t len,
                                                                  lv_draw_sw_mask_line_param_t * p)
{
 8018a2e:	b590      	push	{r4, r7, lr}
 8018a30:	b08d      	sub	sp, #52	@ 0x34
 8018a32:	af00      	add	r7, sp, #0
 8018a34:	60f8      	str	r0, [r7, #12]
 8018a36:	60b9      	str	r1, [r7, #8]
 8018a38:	607a      	str	r2, [r7, #4]
 8018a3a:	603b      	str	r3, [r7, #0]

    int32_t y_at_x;
    y_at_x = (int32_t)((int32_t)p->yx_steep * abs_x) >> 10;
 8018a3c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018a3e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018a40:	68ba      	ldr	r2, [r7, #8]
 8018a42:	fb02 f303 	mul.w	r3, r2, r3
 8018a46:	129b      	asrs	r3, r3, #10
 8018a48:	61fb      	str	r3, [r7, #28]

    if(p->yx_steep > 0) {
 8018a4a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018a4c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018a4e:	2b00      	cmp	r3, #0
 8018a50:	dd0f      	ble.n	8018a72 <line_mask_flat+0x44>
        if(y_at_x > abs_y) {
 8018a52:	69fa      	ldr	r2, [r7, #28]
 8018a54:	687b      	ldr	r3, [r7, #4]
 8018a56:	429a      	cmp	r2, r3
 8018a58:	dd1b      	ble.n	8018a92 <line_mask_flat+0x64>
            if(p->inv) {
 8018a5a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018a5c:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018a60:	f003 0302 	and.w	r3, r3, #2
 8018a64:	b2db      	uxtb	r3, r3
 8018a66:	2b00      	cmp	r3, #0
 8018a68:	d001      	beq.n	8018a6e <line_mask_flat+0x40>
                return LV_DRAW_SW_MASK_RES_FULL_COVER;
 8018a6a:	2301      	movs	r3, #1
 8018a6c:	e14d      	b.n	8018d0a <line_mask_flat+0x2dc>
            }
            else {
                return LV_DRAW_SW_MASK_RES_TRANSP;
 8018a6e:	2300      	movs	r3, #0
 8018a70:	e14b      	b.n	8018d0a <line_mask_flat+0x2dc>
            }
        }
    }
    else {
        if(y_at_x < abs_y) {
 8018a72:	69fa      	ldr	r2, [r7, #28]
 8018a74:	687b      	ldr	r3, [r7, #4]
 8018a76:	429a      	cmp	r2, r3
 8018a78:	da0b      	bge.n	8018a92 <line_mask_flat+0x64>
            if(p->inv) {
 8018a7a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018a7c:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018a80:	f003 0302 	and.w	r3, r3, #2
 8018a84:	b2db      	uxtb	r3, r3
 8018a86:	2b00      	cmp	r3, #0
 8018a88:	d001      	beq.n	8018a8e <line_mask_flat+0x60>
                return LV_DRAW_SW_MASK_RES_FULL_COVER;
 8018a8a:	2301      	movs	r3, #1
 8018a8c:	e13d      	b.n	8018d0a <line_mask_flat+0x2dc>
            }
            else {
                return LV_DRAW_SW_MASK_RES_TRANSP;
 8018a8e:	2300      	movs	r3, #0
 8018a90:	e13b      	b.n	8018d0a <line_mask_flat+0x2dc>
        }
    }

    /*At the end of the mask if the limit line is smaller than the mask's y.
     *Then the mask is in the "good" area*/
    y_at_x = (int32_t)((int32_t)p->yx_steep * (abs_x + len)) >> 10;
 8018a92:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018a94:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018a96:	68b9      	ldr	r1, [r7, #8]
 8018a98:	683a      	ldr	r2, [r7, #0]
 8018a9a:	440a      	add	r2, r1
 8018a9c:	fb02 f303 	mul.w	r3, r2, r3
 8018aa0:	129b      	asrs	r3, r3, #10
 8018aa2:	61fb      	str	r3, [r7, #28]
    if(p->yx_steep > 0) {
 8018aa4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018aa6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018aa8:	2b00      	cmp	r3, #0
 8018aaa:	dd0f      	ble.n	8018acc <line_mask_flat+0x9e>
        if(y_at_x < abs_y) {
 8018aac:	69fa      	ldr	r2, [r7, #28]
 8018aae:	687b      	ldr	r3, [r7, #4]
 8018ab0:	429a      	cmp	r2, r3
 8018ab2:	da1b      	bge.n	8018aec <line_mask_flat+0xbe>
            if(p->inv) {
 8018ab4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018ab6:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018aba:	f003 0302 	and.w	r3, r3, #2
 8018abe:	b2db      	uxtb	r3, r3
 8018ac0:	2b00      	cmp	r3, #0
 8018ac2:	d001      	beq.n	8018ac8 <line_mask_flat+0x9a>
                return LV_DRAW_SW_MASK_RES_TRANSP;
 8018ac4:	2300      	movs	r3, #0
 8018ac6:	e120      	b.n	8018d0a <line_mask_flat+0x2dc>
            }
            else {
                return LV_DRAW_SW_MASK_RES_FULL_COVER;
 8018ac8:	2301      	movs	r3, #1
 8018aca:	e11e      	b.n	8018d0a <line_mask_flat+0x2dc>
            }
        }
    }
    else {
        if(y_at_x > abs_y) {
 8018acc:	69fa      	ldr	r2, [r7, #28]
 8018ace:	687b      	ldr	r3, [r7, #4]
 8018ad0:	429a      	cmp	r2, r3
 8018ad2:	dd0b      	ble.n	8018aec <line_mask_flat+0xbe>
            if(p->inv) {
 8018ad4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018ad6:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018ada:	f003 0302 	and.w	r3, r3, #2
 8018ade:	b2db      	uxtb	r3, r3
 8018ae0:	2b00      	cmp	r3, #0
 8018ae2:	d001      	beq.n	8018ae8 <line_mask_flat+0xba>
                return LV_DRAW_SW_MASK_RES_TRANSP;
 8018ae4:	2300      	movs	r3, #0
 8018ae6:	e110      	b.n	8018d0a <line_mask_flat+0x2dc>
            }
            else {
                return LV_DRAW_SW_MASK_RES_FULL_COVER;
 8018ae8:	2301      	movs	r3, #1
 8018aea:	e10e      	b.n	8018d0a <line_mask_flat+0x2dc>
            }
        }
    }

    int32_t xe;
    if(p->yx_steep > 0) xe = ((abs_y * 256) * p->xy_steep) >> 10;
 8018aec:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018aee:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018af0:	2b00      	cmp	r3, #0
 8018af2:	dd08      	ble.n	8018b06 <line_mask_flat+0xd8>
 8018af4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018af6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018af8:	687a      	ldr	r2, [r7, #4]
 8018afa:	fb02 f303 	mul.w	r3, r2, r3
 8018afe:	021b      	lsls	r3, r3, #8
 8018b00:	129b      	asrs	r3, r3, #10
 8018b02:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8018b04:	e008      	b.n	8018b18 <line_mask_flat+0xea>
    else xe = (((abs_y + 1) * 256) * p->xy_steep) >> 10;
 8018b06:	687b      	ldr	r3, [r7, #4]
 8018b08:	3301      	adds	r3, #1
 8018b0a:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8018b0c:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8018b0e:	fb02 f303 	mul.w	r3, r2, r3
 8018b12:	021b      	lsls	r3, r3, #8
 8018b14:	129b      	asrs	r3, r3, #10
 8018b16:	62fb      	str	r3, [r7, #44]	@ 0x2c

    int32_t xei = xe >> 8;
 8018b18:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b1a:	121b      	asrs	r3, r3, #8
 8018b1c:	61bb      	str	r3, [r7, #24]
    int32_t xef = xe & 0xFF;
 8018b1e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018b20:	b2db      	uxtb	r3, r3
 8018b22:	617b      	str	r3, [r7, #20]

    int32_t px_h;
    if(xef == 0) px_h = 255;
 8018b24:	697b      	ldr	r3, [r7, #20]
 8018b26:	2b00      	cmp	r3, #0
 8018b28:	d102      	bne.n	8018b30 <line_mask_flat+0x102>
 8018b2a:	23ff      	movs	r3, #255	@ 0xff
 8018b2c:	62bb      	str	r3, [r7, #40]	@ 0x28
 8018b2e:	e00a      	b.n	8018b46 <line_mask_flat+0x118>
    else px_h = 255 - (((255 - xef) * p->spx) >> 8);
 8018b30:	697b      	ldr	r3, [r7, #20]
 8018b32:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 8018b36:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8018b38:	6b12      	ldr	r2, [r2, #48]	@ 0x30
 8018b3a:	fb02 f303 	mul.w	r3, r2, r3
 8018b3e:	121b      	asrs	r3, r3, #8
 8018b40:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 8018b44:	62bb      	str	r3, [r7, #40]	@ 0x28
    int32_t k = xei - abs_x;
 8018b46:	69ba      	ldr	r2, [r7, #24]
 8018b48:	68bb      	ldr	r3, [r7, #8]
 8018b4a:	1ad3      	subs	r3, r2, r3
 8018b4c:	627b      	str	r3, [r7, #36]	@ 0x24
    lv_opa_t m;

    if(xef) {
 8018b4e:	697b      	ldr	r3, [r7, #20]
 8018b50:	2b00      	cmp	r3, #0
 8018b52:	d069      	beq.n	8018c28 <line_mask_flat+0x1fa>
        if(k >= 0 && k < len) {
 8018b54:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b56:	2b00      	cmp	r3, #0
 8018b58:	db2b      	blt.n	8018bb2 <line_mask_flat+0x184>
 8018b5a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018b5c:	683b      	ldr	r3, [r7, #0]
 8018b5e:	429a      	cmp	r2, r3
 8018b60:	da27      	bge.n	8018bb2 <line_mask_flat+0x184>
            m = 255 - (((255 - xef) * (255 - px_h)) >> 9);
 8018b62:	697b      	ldr	r3, [r7, #20]
 8018b64:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 8018b68:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018b6a:	f1c2 02ff 	rsb	r2, r2, #255	@ 0xff
 8018b6e:	fb02 f303 	mul.w	r3, r2, r3
 8018b72:	125b      	asrs	r3, r3, #9
 8018b74:	b2db      	uxtb	r3, r3
 8018b76:	43db      	mvns	r3, r3
 8018b78:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
            if(p->inv) m = 255 - m;
 8018b7c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018b7e:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018b82:	f003 0302 	and.w	r3, r3, #2
 8018b86:	b2db      	uxtb	r3, r3
 8018b88:	2b00      	cmp	r3, #0
 8018b8a:	d004      	beq.n	8018b96 <line_mask_flat+0x168>
 8018b8c:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8018b90:	43db      	mvns	r3, r3
 8018b92:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
            mask_buf[k] = mask_mix(mask_buf[k], m);
 8018b96:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018b98:	68fa      	ldr	r2, [r7, #12]
 8018b9a:	4413      	add	r3, r2
 8018b9c:	7818      	ldrb	r0, [r3, #0]
 8018b9e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018ba0:	68fa      	ldr	r2, [r7, #12]
 8018ba2:	18d4      	adds	r4, r2, r3
 8018ba4:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8018ba8:	4619      	mov	r1, r3
 8018baa:	f001 fab2 	bl	801a112 <mask_mix>
 8018bae:	4603      	mov	r3, r0
 8018bb0:	7023      	strb	r3, [r4, #0]
        }
        k++;
 8018bb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018bb4:	3301      	adds	r3, #1
 8018bb6:	627b      	str	r3, [r7, #36]	@ 0x24
    }

    while(px_h > p->spx) {
 8018bb8:	e036      	b.n	8018c28 <line_mask_flat+0x1fa>
        if(k >= 0 && k < len) {
 8018bba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018bbc:	2b00      	cmp	r3, #0
 8018bbe:	db27      	blt.n	8018c10 <line_mask_flat+0x1e2>
 8018bc0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018bc2:	683b      	ldr	r3, [r7, #0]
 8018bc4:	429a      	cmp	r2, r3
 8018bc6:	da23      	bge.n	8018c10 <line_mask_flat+0x1e2>
            m = px_h - (p->spx >> 1);
 8018bc8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018bca:	b2da      	uxtb	r2, r3
 8018bcc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018bce:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8018bd0:	105b      	asrs	r3, r3, #1
 8018bd2:	b2db      	uxtb	r3, r3
 8018bd4:	1ad3      	subs	r3, r2, r3
 8018bd6:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
            if(p->inv) m = 255 - m;
 8018bda:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018bdc:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018be0:	f003 0302 	and.w	r3, r3, #2
 8018be4:	b2db      	uxtb	r3, r3
 8018be6:	2b00      	cmp	r3, #0
 8018be8:	d004      	beq.n	8018bf4 <line_mask_flat+0x1c6>
 8018bea:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8018bee:	43db      	mvns	r3, r3
 8018bf0:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
            mask_buf[k] = mask_mix(mask_buf[k], m);
 8018bf4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018bf6:	68fa      	ldr	r2, [r7, #12]
 8018bf8:	4413      	add	r3, r2
 8018bfa:	7818      	ldrb	r0, [r3, #0]
 8018bfc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018bfe:	68fa      	ldr	r2, [r7, #12]
 8018c00:	18d4      	adds	r4, r2, r3
 8018c02:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8018c06:	4619      	mov	r1, r3
 8018c08:	f001 fa83 	bl	801a112 <mask_mix>
 8018c0c:	4603      	mov	r3, r0
 8018c0e:	7023      	strb	r3, [r4, #0]
        }
        px_h -= p->spx;
 8018c10:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018c12:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8018c14:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018c16:	1ad3      	subs	r3, r2, r3
 8018c18:	62bb      	str	r3, [r7, #40]	@ 0x28
        k++;
 8018c1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c1c:	3301      	adds	r3, #1
 8018c1e:	627b      	str	r3, [r7, #36]	@ 0x24
        if(k >= len) break;
 8018c20:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018c22:	683b      	ldr	r3, [r7, #0]
 8018c24:	429a      	cmp	r2, r3
 8018c26:	da05      	bge.n	8018c34 <line_mask_flat+0x206>
    while(px_h > p->spx) {
 8018c28:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018c2a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8018c2c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018c2e:	429a      	cmp	r2, r3
 8018c30:	dcc3      	bgt.n	8018bba <line_mask_flat+0x18c>
 8018c32:	e000      	b.n	8018c36 <line_mask_flat+0x208>
        if(k >= len) break;
 8018c34:	bf00      	nop
    }

    if(k < len && k >= 0) {
 8018c36:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018c38:	683b      	ldr	r3, [r7, #0]
 8018c3a:	429a      	cmp	r2, r3
 8018c3c:	da34      	bge.n	8018ca8 <line_mask_flat+0x27a>
 8018c3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c40:	2b00      	cmp	r3, #0
 8018c42:	db31      	blt.n	8018ca8 <line_mask_flat+0x27a>
        int32_t x_inters = (px_h * p->xy_steep) >> 10;
 8018c44:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018c46:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018c48:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018c4a:	fb02 f303 	mul.w	r3, r2, r3
 8018c4e:	129b      	asrs	r3, r3, #10
 8018c50:	613b      	str	r3, [r7, #16]
        m = (x_inters * px_h) >> 9;
 8018c52:	693b      	ldr	r3, [r7, #16]
 8018c54:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018c56:	fb02 f303 	mul.w	r3, r2, r3
 8018c5a:	125b      	asrs	r3, r3, #9
 8018c5c:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
        if(p->yx_steep < 0) m = 255 - m;
 8018c60:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018c62:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018c64:	2b00      	cmp	r3, #0
 8018c66:	da04      	bge.n	8018c72 <line_mask_flat+0x244>
 8018c68:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8018c6c:	43db      	mvns	r3, r3
 8018c6e:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
        if(p->inv) m = 255 - m;
 8018c72:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018c74:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018c78:	f003 0302 	and.w	r3, r3, #2
 8018c7c:	b2db      	uxtb	r3, r3
 8018c7e:	2b00      	cmp	r3, #0
 8018c80:	d004      	beq.n	8018c8c <line_mask_flat+0x25e>
 8018c82:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8018c86:	43db      	mvns	r3, r3
 8018c88:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
        mask_buf[k] = mask_mix(mask_buf[k], m);
 8018c8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c8e:	68fa      	ldr	r2, [r7, #12]
 8018c90:	4413      	add	r3, r2
 8018c92:	7818      	ldrb	r0, [r3, #0]
 8018c94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018c96:	68fa      	ldr	r2, [r7, #12]
 8018c98:	18d4      	adds	r4, r2, r3
 8018c9a:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8018c9e:	4619      	mov	r1, r3
 8018ca0:	f001 fa37 	bl	801a112 <mask_mix>
 8018ca4:	4603      	mov	r3, r0
 8018ca6:	7023      	strb	r3, [r4, #0]
    }

    if(p->inv) {
 8018ca8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018caa:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018cae:	f003 0302 	and.w	r3, r3, #2
 8018cb2:	b2db      	uxtb	r3, r3
 8018cb4:	2b00      	cmp	r3, #0
 8018cb6:	d012      	beq.n	8018cde <line_mask_flat+0x2b0>
        k = xei - abs_x;
 8018cb8:	69ba      	ldr	r2, [r7, #24]
 8018cba:	68bb      	ldr	r3, [r7, #8]
 8018cbc:	1ad3      	subs	r3, r2, r3
 8018cbe:	627b      	str	r3, [r7, #36]	@ 0x24
        if(k > len) {
 8018cc0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018cc2:	683b      	ldr	r3, [r7, #0]
 8018cc4:	429a      	cmp	r2, r3
 8018cc6:	dd01      	ble.n	8018ccc <line_mask_flat+0x29e>
            return LV_DRAW_SW_MASK_RES_TRANSP;
 8018cc8:	2300      	movs	r3, #0
 8018cca:	e01e      	b.n	8018d0a <line_mask_flat+0x2dc>
        }
        if(k >= 0) {
 8018ccc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018cce:	2b00      	cmp	r3, #0
 8018cd0:	db1a      	blt.n	8018d08 <line_mask_flat+0x2da>
            lv_memzero(&mask_buf[0], k);
 8018cd2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018cd4:	4619      	mov	r1, r3
 8018cd6:	68f8      	ldr	r0, [r7, #12]
 8018cd8:	f7ff fa2f 	bl	801813a <lv_memzero>
 8018cdc:	e014      	b.n	8018d08 <line_mask_flat+0x2da>
        }
    }
    else {
        k++;
 8018cde:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018ce0:	3301      	adds	r3, #1
 8018ce2:	627b      	str	r3, [r7, #36]	@ 0x24
        if(k < 0) {
 8018ce4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018ce6:	2b00      	cmp	r3, #0
 8018ce8:	da01      	bge.n	8018cee <line_mask_flat+0x2c0>
            return LV_DRAW_SW_MASK_RES_TRANSP;
 8018cea:	2300      	movs	r3, #0
 8018cec:	e00d      	b.n	8018d0a <line_mask_flat+0x2dc>
        }
        if(k <= len) {
 8018cee:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8018cf0:	683b      	ldr	r3, [r7, #0]
 8018cf2:	429a      	cmp	r2, r3
 8018cf4:	dc08      	bgt.n	8018d08 <line_mask_flat+0x2da>
            lv_memzero(&mask_buf[k], len - k);
 8018cf6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018cf8:	68fa      	ldr	r2, [r7, #12]
 8018cfa:	18d0      	adds	r0, r2, r3
 8018cfc:	683a      	ldr	r2, [r7, #0]
 8018cfe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018d00:	1ad3      	subs	r3, r2, r3
 8018d02:	4619      	mov	r1, r3
 8018d04:	f7ff fa19 	bl	801813a <lv_memzero>
        }
    }

    return LV_DRAW_SW_MASK_RES_CHANGED;
 8018d08:	2302      	movs	r3, #2
}
 8018d0a:	4618      	mov	r0, r3
 8018d0c:	3734      	adds	r7, #52	@ 0x34
 8018d0e:	46bd      	mov	sp, r7
 8018d10:	bd90      	pop	{r4, r7, pc}

08018d12 <line_mask_steep>:

static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM line_mask_steep(lv_opa_t * mask_buf, int32_t abs_x,
                                                                   int32_t abs_y,
                                                                   int32_t len,
                                                                   lv_draw_sw_mask_line_param_t * p)
{
 8018d12:	b590      	push	{r4, r7, lr}
 8018d14:	b091      	sub	sp, #68	@ 0x44
 8018d16:	af00      	add	r7, sp, #0
 8018d18:	60f8      	str	r0, [r7, #12]
 8018d1a:	60b9      	str	r1, [r7, #8]
 8018d1c:	607a      	str	r2, [r7, #4]
 8018d1e:	603b      	str	r3, [r7, #0]
    int32_t k;
    int32_t x_at_y;
    /*At the beginning of the mask if the limit line is greater than the mask's y.
     *Then the mask is in the "wrong" area*/
    x_at_y = (int32_t)((int32_t)p->xy_steep * abs_y) >> 10;
 8018d20:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018d22:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018d24:	687a      	ldr	r2, [r7, #4]
 8018d26:	fb02 f303 	mul.w	r3, r2, r3
 8018d2a:	129b      	asrs	r3, r3, #10
 8018d2c:	63bb      	str	r3, [r7, #56]	@ 0x38
    if(p->xy_steep > 0) x_at_y++;
 8018d2e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018d30:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018d32:	2b00      	cmp	r3, #0
 8018d34:	dd02      	ble.n	8018d3c <line_mask_steep+0x2a>
 8018d36:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018d38:	3301      	adds	r3, #1
 8018d3a:	63bb      	str	r3, [r7, #56]	@ 0x38
    if(x_at_y < abs_x) {
 8018d3c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8018d3e:	68bb      	ldr	r3, [r7, #8]
 8018d40:	429a      	cmp	r2, r3
 8018d42:	da0b      	bge.n	8018d5c <line_mask_steep+0x4a>
        if(p->inv) {
 8018d44:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018d46:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018d4a:	f003 0302 	and.w	r3, r3, #2
 8018d4e:	b2db      	uxtb	r3, r3
 8018d50:	2b00      	cmp	r3, #0
 8018d52:	d001      	beq.n	8018d58 <line_mask_steep+0x46>
            return LV_DRAW_SW_MASK_RES_FULL_COVER;
 8018d54:	2301      	movs	r3, #1
 8018d56:	e1f9      	b.n	801914c <line_mask_steep+0x43a>
        }
        else {
            return LV_DRAW_SW_MASK_RES_TRANSP;
 8018d58:	2300      	movs	r3, #0
 8018d5a:	e1f7      	b.n	801914c <line_mask_steep+0x43a>
        }
    }

    /*At the end of the mask if the limit line is smaller than the mask's y.
     *Then the mask is in the "good" area*/
    x_at_y = (int32_t)((int32_t)p->xy_steep * (abs_y)) >> 10;
 8018d5c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018d5e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018d60:	687a      	ldr	r2, [r7, #4]
 8018d62:	fb02 f303 	mul.w	r3, r2, r3
 8018d66:	129b      	asrs	r3, r3, #10
 8018d68:	63bb      	str	r3, [r7, #56]	@ 0x38
    if(x_at_y > abs_x + len) {
 8018d6a:	68ba      	ldr	r2, [r7, #8]
 8018d6c:	683b      	ldr	r3, [r7, #0]
 8018d6e:	4413      	add	r3, r2
 8018d70:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8018d72:	429a      	cmp	r2, r3
 8018d74:	dd0b      	ble.n	8018d8e <line_mask_steep+0x7c>
        if(p->inv) {
 8018d76:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018d78:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018d7c:	f003 0302 	and.w	r3, r3, #2
 8018d80:	b2db      	uxtb	r3, r3
 8018d82:	2b00      	cmp	r3, #0
 8018d84:	d001      	beq.n	8018d8a <line_mask_steep+0x78>
            return LV_DRAW_SW_MASK_RES_TRANSP;
 8018d86:	2300      	movs	r3, #0
 8018d88:	e1e0      	b.n	801914c <line_mask_steep+0x43a>
        }
        else {
            return LV_DRAW_SW_MASK_RES_FULL_COVER;
 8018d8a:	2301      	movs	r3, #1
 8018d8c:	e1de      	b.n	801914c <line_mask_steep+0x43a>
        }
    }

    /*X start*/
    int32_t xs = ((abs_y * 256) * p->xy_steep) >> 10;
 8018d8e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018d90:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018d92:	687a      	ldr	r2, [r7, #4]
 8018d94:	fb02 f303 	mul.w	r3, r2, r3
 8018d98:	021b      	lsls	r3, r3, #8
 8018d9a:	129b      	asrs	r3, r3, #10
 8018d9c:	62bb      	str	r3, [r7, #40]	@ 0x28
    int32_t xsi = xs >> 8;
 8018d9e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018da0:	121b      	asrs	r3, r3, #8
 8018da2:	637b      	str	r3, [r7, #52]	@ 0x34
    int32_t xsf = xs & 0xFF;
 8018da4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018da6:	b2db      	uxtb	r3, r3
 8018da8:	633b      	str	r3, [r7, #48]	@ 0x30

    /*X end*/
    int32_t xe = (((abs_y + 1) * 256) * p->xy_steep) >> 10;
 8018daa:	687b      	ldr	r3, [r7, #4]
 8018dac:	3301      	adds	r3, #1
 8018dae:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8018db0:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8018db2:	fb02 f303 	mul.w	r3, r2, r3
 8018db6:	021b      	lsls	r3, r3, #8
 8018db8:	129b      	asrs	r3, r3, #10
 8018dba:	627b      	str	r3, [r7, #36]	@ 0x24
    int32_t xei = xe >> 8;
 8018dbc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018dbe:	121b      	asrs	r3, r3, #8
 8018dc0:	623b      	str	r3, [r7, #32]
    int32_t xef = xe & 0xFF;
 8018dc2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018dc4:	b2db      	uxtb	r3, r3
 8018dc6:	61fb      	str	r3, [r7, #28]

    lv_opa_t m;

    k = xsi - abs_x;
 8018dc8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8018dca:	68bb      	ldr	r3, [r7, #8]
 8018dcc:	1ad3      	subs	r3, r2, r3
 8018dce:	63fb      	str	r3, [r7, #60]	@ 0x3c
    if(xsi != xei && (p->xy_steep < 0 && xsf == 0)) {
 8018dd0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8018dd2:	6a3b      	ldr	r3, [r7, #32]
 8018dd4:	429a      	cmp	r2, r3
 8018dd6:	d00d      	beq.n	8018df4 <line_mask_steep+0xe2>
 8018dd8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018dda:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018ddc:	2b00      	cmp	r3, #0
 8018dde:	da09      	bge.n	8018df4 <line_mask_steep+0xe2>
 8018de0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018de2:	2b00      	cmp	r3, #0
 8018de4:	d106      	bne.n	8018df4 <line_mask_steep+0xe2>
        xsf = 0xFF;
 8018de6:	23ff      	movs	r3, #255	@ 0xff
 8018de8:	633b      	str	r3, [r7, #48]	@ 0x30
        xsi = xei;
 8018dea:	6a3b      	ldr	r3, [r7, #32]
 8018dec:	637b      	str	r3, [r7, #52]	@ 0x34
        k--;
 8018dee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018df0:	3b01      	subs	r3, #1
 8018df2:	63fb      	str	r3, [r7, #60]	@ 0x3c
    }

    if(xsi == xei) {
 8018df4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8018df6:	6a3b      	ldr	r3, [r7, #32]
 8018df8:	429a      	cmp	r2, r3
 8018dfa:	d15f      	bne.n	8018ebc <line_mask_steep+0x1aa>
        if(k >= 0 && k < len) {
 8018dfc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018dfe:	2b00      	cmp	r3, #0
 8018e00:	db24      	blt.n	8018e4c <line_mask_steep+0x13a>
 8018e02:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8018e04:	683b      	ldr	r3, [r7, #0]
 8018e06:	429a      	cmp	r2, r3
 8018e08:	da20      	bge.n	8018e4c <line_mask_steep+0x13a>
            m = (xsf + xef) >> 1;
 8018e0a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018e0c:	69fb      	ldr	r3, [r7, #28]
 8018e0e:	4413      	add	r3, r2
 8018e10:	105b      	asrs	r3, r3, #1
 8018e12:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
            if(p->inv) m = 255 - m;
 8018e16:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018e18:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018e1c:	f003 0302 	and.w	r3, r3, #2
 8018e20:	b2db      	uxtb	r3, r3
 8018e22:	2b00      	cmp	r3, #0
 8018e24:	d004      	beq.n	8018e30 <line_mask_steep+0x11e>
 8018e26:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8018e2a:	43db      	mvns	r3, r3
 8018e2c:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
            mask_buf[k] = mask_mix(mask_buf[k], m);
 8018e30:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018e32:	68fa      	ldr	r2, [r7, #12]
 8018e34:	4413      	add	r3, r2
 8018e36:	7818      	ldrb	r0, [r3, #0]
 8018e38:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018e3a:	68fa      	ldr	r2, [r7, #12]
 8018e3c:	18d4      	adds	r4, r2, r3
 8018e3e:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8018e42:	4619      	mov	r1, r3
 8018e44:	f001 f965 	bl	801a112 <mask_mix>
 8018e48:	4603      	mov	r3, r0
 8018e4a:	7023      	strb	r3, [r4, #0]
        }
        k++;
 8018e4c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018e4e:	3301      	adds	r3, #1
 8018e50:	63fb      	str	r3, [r7, #60]	@ 0x3c

        if(p->inv) {
 8018e52:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018e54:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018e58:	f003 0302 	and.w	r3, r3, #2
 8018e5c:	b2db      	uxtb	r3, r3
 8018e5e:	2b00      	cmp	r3, #0
 8018e60:	d013      	beq.n	8018e8a <line_mask_steep+0x178>
            k = xsi - abs_x;
 8018e62:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8018e64:	68bb      	ldr	r3, [r7, #8]
 8018e66:	1ad3      	subs	r3, r2, r3
 8018e68:	63fb      	str	r3, [r7, #60]	@ 0x3c
            if(k >= len) {
 8018e6a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8018e6c:	683b      	ldr	r3, [r7, #0]
 8018e6e:	429a      	cmp	r2, r3
 8018e70:	db01      	blt.n	8018e76 <line_mask_steep+0x164>
                return LV_DRAW_SW_MASK_RES_TRANSP;
 8018e72:	2300      	movs	r3, #0
 8018e74:	e16a      	b.n	801914c <line_mask_steep+0x43a>
            }
            if(k >= 0) lv_memzero(&mask_buf[0], k);
 8018e76:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018e78:	2b00      	cmp	r3, #0
 8018e7a:	f2c0 8166 	blt.w	801914a <line_mask_steep+0x438>
 8018e7e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018e80:	4619      	mov	r1, r3
 8018e82:	68f8      	ldr	r0, [r7, #12]
 8018e84:	f7ff f959 	bl	801813a <lv_memzero>
 8018e88:	e15f      	b.n	801914a <line_mask_steep+0x438>

        }
        else {
            if(k > len) k = len;
 8018e8a:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8018e8c:	683b      	ldr	r3, [r7, #0]
 8018e8e:	429a      	cmp	r2, r3
 8018e90:	dd01      	ble.n	8018e96 <line_mask_steep+0x184>
 8018e92:	683b      	ldr	r3, [r7, #0]
 8018e94:	63fb      	str	r3, [r7, #60]	@ 0x3c
            if(k == 0) return LV_DRAW_SW_MASK_RES_TRANSP;
 8018e96:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018e98:	2b00      	cmp	r3, #0
 8018e9a:	d101      	bne.n	8018ea0 <line_mask_steep+0x18e>
 8018e9c:	2300      	movs	r3, #0
 8018e9e:	e155      	b.n	801914c <line_mask_steep+0x43a>
            else if(k > 0) lv_memzero(&mask_buf[k],  len - k);
 8018ea0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018ea2:	2b00      	cmp	r3, #0
 8018ea4:	f340 8151 	ble.w	801914a <line_mask_steep+0x438>
 8018ea8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018eaa:	68fa      	ldr	r2, [r7, #12]
 8018eac:	18d0      	adds	r0, r2, r3
 8018eae:	683a      	ldr	r2, [r7, #0]
 8018eb0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018eb2:	1ad3      	subs	r3, r2, r3
 8018eb4:	4619      	mov	r1, r3
 8018eb6:	f7ff f940 	bl	801813a <lv_memzero>
 8018eba:	e146      	b.n	801914a <line_mask_steep+0x438>
        }

    }
    else {
        int32_t y_inters;
        if(p->xy_steep < 0) {
 8018ebc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018ebe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018ec0:	2b00      	cmp	r3, #0
 8018ec2:	f280 80a0 	bge.w	8019006 <line_mask_steep+0x2f4>
            y_inters = (xsf * (-p->yx_steep)) >> 10;
 8018ec6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018ec8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8018eca:	425b      	negs	r3, r3
 8018ecc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018ece:	fb02 f303 	mul.w	r3, r2, r3
 8018ed2:	129b      	asrs	r3, r3, #10
 8018ed4:	61bb      	str	r3, [r7, #24]
            if(k >= 0 && k < len) {
 8018ed6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018ed8:	2b00      	cmp	r3, #0
 8018eda:	db25      	blt.n	8018f28 <line_mask_steep+0x216>
 8018edc:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8018ede:	683b      	ldr	r3, [r7, #0]
 8018ee0:	429a      	cmp	r2, r3
 8018ee2:	da21      	bge.n	8018f28 <line_mask_steep+0x216>
                m = (y_inters * xsf) >> 9;
 8018ee4:	69bb      	ldr	r3, [r7, #24]
 8018ee6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018ee8:	fb02 f303 	mul.w	r3, r2, r3
 8018eec:	125b      	asrs	r3, r3, #9
 8018eee:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
                if(p->inv) m = 255 - m;
 8018ef2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018ef4:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018ef8:	f003 0302 	and.w	r3, r3, #2
 8018efc:	b2db      	uxtb	r3, r3
 8018efe:	2b00      	cmp	r3, #0
 8018f00:	d004      	beq.n	8018f0c <line_mask_steep+0x1fa>
 8018f02:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8018f06:	43db      	mvns	r3, r3
 8018f08:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
                mask_buf[k] = mask_mix(mask_buf[k], m);
 8018f0c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018f0e:	68fa      	ldr	r2, [r7, #12]
 8018f10:	4413      	add	r3, r2
 8018f12:	7818      	ldrb	r0, [r3, #0]
 8018f14:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018f16:	68fa      	ldr	r2, [r7, #12]
 8018f18:	18d4      	adds	r4, r2, r3
 8018f1a:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8018f1e:	4619      	mov	r1, r3
 8018f20:	f001 f8f7 	bl	801a112 <mask_mix>
 8018f24:	4603      	mov	r3, r0
 8018f26:	7023      	strb	r3, [r4, #0]
            }
            k--;
 8018f28:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018f2a:	3b01      	subs	r3, #1
 8018f2c:	63fb      	str	r3, [r7, #60]	@ 0x3c

            int32_t x_inters = ((255 - y_inters) * (-p->xy_steep)) >> 10;
 8018f2e:	69bb      	ldr	r3, [r7, #24]
 8018f30:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 8018f34:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8018f36:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8018f38:	4252      	negs	r2, r2
 8018f3a:	fb02 f303 	mul.w	r3, r2, r3
 8018f3e:	129b      	asrs	r3, r3, #10
 8018f40:	613b      	str	r3, [r7, #16]

            if(k >= 0 && k < len) {
 8018f42:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018f44:	2b00      	cmp	r3, #0
 8018f46:	db29      	blt.n	8018f9c <line_mask_steep+0x28a>
 8018f48:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8018f4a:	683b      	ldr	r3, [r7, #0]
 8018f4c:	429a      	cmp	r2, r3
 8018f4e:	da25      	bge.n	8018f9c <line_mask_steep+0x28a>
                m = 255 - (((255 - y_inters) * x_inters) >> 9);
 8018f50:	69bb      	ldr	r3, [r7, #24]
 8018f52:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 8018f56:	693a      	ldr	r2, [r7, #16]
 8018f58:	fb02 f303 	mul.w	r3, r2, r3
 8018f5c:	125b      	asrs	r3, r3, #9
 8018f5e:	b2db      	uxtb	r3, r3
 8018f60:	43db      	mvns	r3, r3
 8018f62:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
                if(p->inv) m = 255 - m;
 8018f66:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018f68:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018f6c:	f003 0302 	and.w	r3, r3, #2
 8018f70:	b2db      	uxtb	r3, r3
 8018f72:	2b00      	cmp	r3, #0
 8018f74:	d004      	beq.n	8018f80 <line_mask_steep+0x26e>
 8018f76:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8018f7a:	43db      	mvns	r3, r3
 8018f7c:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
                mask_buf[k] = mask_mix(mask_buf[k], m);
 8018f80:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018f82:	68fa      	ldr	r2, [r7, #12]
 8018f84:	4413      	add	r3, r2
 8018f86:	7818      	ldrb	r0, [r3, #0]
 8018f88:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018f8a:	68fa      	ldr	r2, [r7, #12]
 8018f8c:	18d4      	adds	r4, r2, r3
 8018f8e:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8018f92:	4619      	mov	r1, r3
 8018f94:	f001 f8bd 	bl	801a112 <mask_mix>
 8018f98:	4603      	mov	r3, r0
 8018f9a:	7023      	strb	r3, [r4, #0]
            }

            k += 2;
 8018f9c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018f9e:	3302      	adds	r3, #2
 8018fa0:	63fb      	str	r3, [r7, #60]	@ 0x3c

            if(p->inv) {
 8018fa2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8018fa4:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8018fa8:	f003 0302 	and.w	r3, r3, #2
 8018fac:	b2db      	uxtb	r3, r3
 8018fae:	2b00      	cmp	r3, #0
 8018fb0:	d015      	beq.n	8018fde <line_mask_steep+0x2cc>
                k = xsi - abs_x - 1;
 8018fb2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8018fb4:	68bb      	ldr	r3, [r7, #8]
 8018fb6:	1ad3      	subs	r3, r2, r3
 8018fb8:	3b01      	subs	r3, #1
 8018fba:	63fb      	str	r3, [r7, #60]	@ 0x3c

                if(k > len) k = len;
 8018fbc:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8018fbe:	683b      	ldr	r3, [r7, #0]
 8018fc0:	429a      	cmp	r2, r3
 8018fc2:	dd02      	ble.n	8018fca <line_mask_steep+0x2b8>
 8018fc4:	683b      	ldr	r3, [r7, #0]
 8018fc6:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8018fc8:	e0bf      	b.n	801914a <line_mask_steep+0x438>
                else if(k > 0) lv_memzero(&mask_buf[0],  k);
 8018fca:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018fcc:	2b00      	cmp	r3, #0
 8018fce:	f340 80bc 	ble.w	801914a <line_mask_steep+0x438>
 8018fd2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018fd4:	4619      	mov	r1, r3
 8018fd6:	68f8      	ldr	r0, [r7, #12]
 8018fd8:	f7ff f8af 	bl	801813a <lv_memzero>
 8018fdc:	e0b5      	b.n	801914a <line_mask_steep+0x438>

            }
            else {
                if(k > len) return LV_DRAW_SW_MASK_RES_FULL_COVER;
 8018fde:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8018fe0:	683b      	ldr	r3, [r7, #0]
 8018fe2:	429a      	cmp	r2, r3
 8018fe4:	dd01      	ble.n	8018fea <line_mask_steep+0x2d8>
 8018fe6:	2301      	movs	r3, #1
 8018fe8:	e0b0      	b.n	801914c <line_mask_steep+0x43a>
                if(k >= 0) lv_memzero(&mask_buf[k],  len - k);
 8018fea:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018fec:	2b00      	cmp	r3, #0
 8018fee:	f2c0 80ac 	blt.w	801914a <line_mask_steep+0x438>
 8018ff2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018ff4:	68fa      	ldr	r2, [r7, #12]
 8018ff6:	18d0      	adds	r0, r2, r3
 8018ff8:	683a      	ldr	r2, [r7, #0]
 8018ffa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8018ffc:	1ad3      	subs	r3, r2, r3
 8018ffe:	4619      	mov	r1, r3
 8019000:	f7ff f89b 	bl	801813a <lv_memzero>
 8019004:	e0a1      	b.n	801914a <line_mask_steep+0x438>
            }

        }
        else {
            y_inters = ((255 - xsf) * p->yx_steep) >> 10;
 8019006:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019008:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 801900c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801900e:	6a92      	ldr	r2, [r2, #40]	@ 0x28
 8019010:	fb02 f303 	mul.w	r3, r2, r3
 8019014:	129b      	asrs	r3, r3, #10
 8019016:	61bb      	str	r3, [r7, #24]
            if(k >= 0 && k < len) {
 8019018:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801901a:	2b00      	cmp	r3, #0
 801901c:	db29      	blt.n	8019072 <line_mask_steep+0x360>
 801901e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8019020:	683b      	ldr	r3, [r7, #0]
 8019022:	429a      	cmp	r2, r3
 8019024:	da25      	bge.n	8019072 <line_mask_steep+0x360>
                m = 255 - ((y_inters * (255 - xsf)) >> 9);
 8019026:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019028:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 801902c:	69ba      	ldr	r2, [r7, #24]
 801902e:	fb02 f303 	mul.w	r3, r2, r3
 8019032:	125b      	asrs	r3, r3, #9
 8019034:	b2db      	uxtb	r3, r3
 8019036:	43db      	mvns	r3, r3
 8019038:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
                if(p->inv) m = 255 - m;
 801903c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801903e:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8019042:	f003 0302 	and.w	r3, r3, #2
 8019046:	b2db      	uxtb	r3, r3
 8019048:	2b00      	cmp	r3, #0
 801904a:	d004      	beq.n	8019056 <line_mask_steep+0x344>
 801904c:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8019050:	43db      	mvns	r3, r3
 8019052:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
                mask_buf[k] = mask_mix(mask_buf[k], m);
 8019056:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8019058:	68fa      	ldr	r2, [r7, #12]
 801905a:	4413      	add	r3, r2
 801905c:	7818      	ldrb	r0, [r3, #0]
 801905e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8019060:	68fa      	ldr	r2, [r7, #12]
 8019062:	18d4      	adds	r4, r2, r3
 8019064:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8019068:	4619      	mov	r1, r3
 801906a:	f001 f852 	bl	801a112 <mask_mix>
 801906e:	4603      	mov	r3, r0
 8019070:	7023      	strb	r3, [r4, #0]
            }

            k++;
 8019072:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8019074:	3301      	adds	r3, #1
 8019076:	63fb      	str	r3, [r7, #60]	@ 0x3c

            int32_t x_inters = ((255 - y_inters) * p->xy_steep) >> 10;
 8019078:	69bb      	ldr	r3, [r7, #24]
 801907a:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 801907e:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8019080:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 8019082:	fb02 f303 	mul.w	r3, r2, r3
 8019086:	129b      	asrs	r3, r3, #10
 8019088:	617b      	str	r3, [r7, #20]
            if(k >= 0 && k < len) {
 801908a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801908c:	2b00      	cmp	r3, #0
 801908e:	db27      	blt.n	80190e0 <line_mask_steep+0x3ce>
 8019090:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8019092:	683b      	ldr	r3, [r7, #0]
 8019094:	429a      	cmp	r2, r3
 8019096:	da23      	bge.n	80190e0 <line_mask_steep+0x3ce>
                m = ((255 - y_inters) * x_inters) >> 9;
 8019098:	69bb      	ldr	r3, [r7, #24]
 801909a:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 801909e:	697a      	ldr	r2, [r7, #20]
 80190a0:	fb02 f303 	mul.w	r3, r2, r3
 80190a4:	125b      	asrs	r3, r3, #9
 80190a6:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
                if(p->inv) m = 255 - m;
 80190aa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80190ac:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 80190b0:	f003 0302 	and.w	r3, r3, #2
 80190b4:	b2db      	uxtb	r3, r3
 80190b6:	2b00      	cmp	r3, #0
 80190b8:	d004      	beq.n	80190c4 <line_mask_steep+0x3b2>
 80190ba:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 80190be:	43db      	mvns	r3, r3
 80190c0:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
                mask_buf[k] = mask_mix(mask_buf[k], m);
 80190c4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80190c6:	68fa      	ldr	r2, [r7, #12]
 80190c8:	4413      	add	r3, r2
 80190ca:	7818      	ldrb	r0, [r3, #0]
 80190cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80190ce:	68fa      	ldr	r2, [r7, #12]
 80190d0:	18d4      	adds	r4, r2, r3
 80190d2:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 80190d6:	4619      	mov	r1, r3
 80190d8:	f001 f81b 	bl	801a112 <mask_mix>
 80190dc:	4603      	mov	r3, r0
 80190de:	7023      	strb	r3, [r4, #0]
            }
            k++;
 80190e0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80190e2:	3301      	adds	r3, #1
 80190e4:	63fb      	str	r3, [r7, #60]	@ 0x3c

            if(p->inv) {
 80190e6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80190e8:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 80190ec:	f003 0302 	and.w	r3, r3, #2
 80190f0:	b2db      	uxtb	r3, r3
 80190f2:	2b00      	cmp	r3, #0
 80190f4:	d012      	beq.n	801911c <line_mask_steep+0x40a>
                k = xsi - abs_x;
 80190f6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80190f8:	68bb      	ldr	r3, [r7, #8]
 80190fa:	1ad3      	subs	r3, r2, r3
 80190fc:	63fb      	str	r3, [r7, #60]	@ 0x3c
                if(k > len)  return LV_DRAW_SW_MASK_RES_TRANSP;
 80190fe:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8019100:	683b      	ldr	r3, [r7, #0]
 8019102:	429a      	cmp	r2, r3
 8019104:	dd01      	ble.n	801910a <line_mask_steep+0x3f8>
 8019106:	2300      	movs	r3, #0
 8019108:	e020      	b.n	801914c <line_mask_steep+0x43a>
                if(k >= 0) lv_memzero(&mask_buf[0],  k);
 801910a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801910c:	2b00      	cmp	r3, #0
 801910e:	db1c      	blt.n	801914a <line_mask_steep+0x438>
 8019110:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8019112:	4619      	mov	r1, r3
 8019114:	68f8      	ldr	r0, [r7, #12]
 8019116:	f7ff f810 	bl	801813a <lv_memzero>
 801911a:	e016      	b.n	801914a <line_mask_steep+0x438>

            }
            else {
                if(k > len) k = len;
 801911c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801911e:	683b      	ldr	r3, [r7, #0]
 8019120:	429a      	cmp	r2, r3
 8019122:	dd01      	ble.n	8019128 <line_mask_steep+0x416>
 8019124:	683b      	ldr	r3, [r7, #0]
 8019126:	63fb      	str	r3, [r7, #60]	@ 0x3c
                if(k == 0) return LV_DRAW_SW_MASK_RES_TRANSP;
 8019128:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801912a:	2b00      	cmp	r3, #0
 801912c:	d101      	bne.n	8019132 <line_mask_steep+0x420>
 801912e:	2300      	movs	r3, #0
 8019130:	e00c      	b.n	801914c <line_mask_steep+0x43a>
                else if(k > 0) lv_memzero(&mask_buf[k],  len - k);
 8019132:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8019134:	2b00      	cmp	r3, #0
 8019136:	dd08      	ble.n	801914a <line_mask_steep+0x438>
 8019138:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801913a:	68fa      	ldr	r2, [r7, #12]
 801913c:	18d0      	adds	r0, r2, r3
 801913e:	683a      	ldr	r2, [r7, #0]
 8019140:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8019142:	1ad3      	subs	r3, r2, r3
 8019144:	4619      	mov	r1, r3
 8019146:	f7fe fff8 	bl	801813a <lv_memzero>
            }
        }
    }

    return LV_DRAW_SW_MASK_RES_CHANGED;
 801914a:	2302      	movs	r3, #2
}
 801914c:	4618      	mov	r0, r3
 801914e:	3744      	adds	r7, #68	@ 0x44
 8019150:	46bd      	mov	sp, r7
 8019152:	bd90      	pop	{r4, r7, pc}

08019154 <lv_draw_mask_angle>:

static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_mask_angle(lv_opa_t * mask_buf, int32_t abs_x,
                                                                      int32_t abs_y, int32_t len,
                                                                      lv_draw_sw_mask_angle_param_t * p)
{
 8019154:	b580      	push	{r7, lr}
 8019156:	b096      	sub	sp, #88	@ 0x58
 8019158:	af02      	add	r7, sp, #8
 801915a:	60f8      	str	r0, [r7, #12]
 801915c:	60b9      	str	r1, [r7, #8]
 801915e:	607a      	str	r2, [r7, #4]
 8019160:	603b      	str	r3, [r7, #0]
    int32_t rel_y = abs_y - p->cfg.vertex_p.y;
 8019162:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019164:	68db      	ldr	r3, [r3, #12]
 8019166:	687a      	ldr	r2, [r7, #4]
 8019168:	1ad3      	subs	r3, r2, r3
 801916a:	633b      	str	r3, [r7, #48]	@ 0x30
    int32_t rel_x = abs_x - p->cfg.vertex_p.x;
 801916c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801916e:	689b      	ldr	r3, [r3, #8]
 8019170:	68ba      	ldr	r2, [r7, #8]
 8019172:	1ad3      	subs	r3, r2, r3
 8019174:	62fb      	str	r3, [r7, #44]	@ 0x2c

    if(p->cfg.start_angle < 180 && p->cfg.end_angle < 180 &&
 8019176:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019178:	691b      	ldr	r3, [r3, #16]
 801917a:	2bb3      	cmp	r3, #179	@ 0xb3
 801917c:	f300 80e9 	bgt.w	8019352 <lv_draw_mask_angle+0x1fe>
 8019180:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019182:	695b      	ldr	r3, [r3, #20]
 8019184:	2bb3      	cmp	r3, #179	@ 0xb3
 8019186:	f300 80e4 	bgt.w	8019352 <lv_draw_mask_angle+0x1fe>
       p->cfg.start_angle != 0  && p->cfg.end_angle != 0 &&
 801918a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801918c:	691b      	ldr	r3, [r3, #16]
    if(p->cfg.start_angle < 180 && p->cfg.end_angle < 180 &&
 801918e:	2b00      	cmp	r3, #0
 8019190:	f000 80df 	beq.w	8019352 <lv_draw_mask_angle+0x1fe>
       p->cfg.start_angle != 0  && p->cfg.end_angle != 0 &&
 8019194:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019196:	695b      	ldr	r3, [r3, #20]
 8019198:	2b00      	cmp	r3, #0
 801919a:	f000 80da 	beq.w	8019352 <lv_draw_mask_angle+0x1fe>
       p->cfg.start_angle > p->cfg.end_angle) {
 801919e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80191a0:	691a      	ldr	r2, [r3, #16]
 80191a2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80191a4:	695b      	ldr	r3, [r3, #20]
       p->cfg.start_angle != 0  && p->cfg.end_angle != 0 &&
 80191a6:	429a      	cmp	r2, r3
 80191a8:	f340 80d3 	ble.w	8019352 <lv_draw_mask_angle+0x1fe>

        if(abs_y < p->cfg.vertex_p.y) {
 80191ac:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80191ae:	68db      	ldr	r3, [r3, #12]
 80191b0:	687a      	ldr	r2, [r7, #4]
 80191b2:	429a      	cmp	r2, r3
 80191b4:	da01      	bge.n	80191ba <lv_draw_mask_angle+0x66>
            return LV_DRAW_SW_MASK_RES_FULL_COVER;
 80191b6:	2301      	movs	r3, #1
 80191b8:	e258      	b.n	801966c <lv_draw_mask_angle+0x518>
        }

        /*Start angle mask can work only from the end of end angle mask*/
        int32_t end_angle_first = (rel_y * p->end_line.xy_steep) >> 10;
 80191ba:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80191bc:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80191be:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80191c0:	fb02 f303 	mul.w	r3, r2, r3
 80191c4:	129b      	asrs	r3, r3, #10
 80191c6:	62bb      	str	r3, [r7, #40]	@ 0x28
        int32_t start_angle_last = ((rel_y + 1) * p->start_line.xy_steep) >> 10;
 80191c8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80191ca:	3301      	adds	r3, #1
 80191cc:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80191ce:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 80191d0:	fb02 f303 	mul.w	r3, r2, r3
 80191d4:	129b      	asrs	r3, r3, #10
 80191d6:	64fb      	str	r3, [r7, #76]	@ 0x4c

        /*Do not let the line end cross the vertex else it will affect the opposite part*/
        if(p->cfg.start_angle > 270 && p->cfg.start_angle <= 359 && start_angle_last < 0) start_angle_last = 0;
 80191d8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80191da:	691b      	ldr	r3, [r3, #16]
 80191dc:	f5b3 7f87 	cmp.w	r3, #270	@ 0x10e
 80191e0:	dd0a      	ble.n	80191f8 <lv_draw_mask_angle+0xa4>
 80191e2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80191e4:	691b      	ldr	r3, [r3, #16]
 80191e6:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 80191ea:	da05      	bge.n	80191f8 <lv_draw_mask_angle+0xa4>
 80191ec:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80191ee:	2b00      	cmp	r3, #0
 80191f0:	da02      	bge.n	80191f8 <lv_draw_mask_angle+0xa4>
 80191f2:	2300      	movs	r3, #0
 80191f4:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80191f6:	e01b      	b.n	8019230 <lv_draw_mask_angle+0xdc>
        else if(p->cfg.start_angle > 0 && p->cfg.start_angle <= 90 && start_angle_last < 0) start_angle_last = 0;
 80191f8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80191fa:	691b      	ldr	r3, [r3, #16]
 80191fc:	2b00      	cmp	r3, #0
 80191fe:	dd09      	ble.n	8019214 <lv_draw_mask_angle+0xc0>
 8019200:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019202:	691b      	ldr	r3, [r3, #16]
 8019204:	2b5a      	cmp	r3, #90	@ 0x5a
 8019206:	dc05      	bgt.n	8019214 <lv_draw_mask_angle+0xc0>
 8019208:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801920a:	2b00      	cmp	r3, #0
 801920c:	da02      	bge.n	8019214 <lv_draw_mask_angle+0xc0>
 801920e:	2300      	movs	r3, #0
 8019210:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8019212:	e00d      	b.n	8019230 <lv_draw_mask_angle+0xdc>
        else if(p->cfg.start_angle > 90 && p->cfg.start_angle < 270 && start_angle_last > 0) start_angle_last = 0;
 8019214:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019216:	691b      	ldr	r3, [r3, #16]
 8019218:	2b5a      	cmp	r3, #90	@ 0x5a
 801921a:	dd09      	ble.n	8019230 <lv_draw_mask_angle+0xdc>
 801921c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801921e:	691b      	ldr	r3, [r3, #16]
 8019220:	f5b3 7f87 	cmp.w	r3, #270	@ 0x10e
 8019224:	da04      	bge.n	8019230 <lv_draw_mask_angle+0xdc>
 8019226:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8019228:	2b00      	cmp	r3, #0
 801922a:	dd01      	ble.n	8019230 <lv_draw_mask_angle+0xdc>
 801922c:	2300      	movs	r3, #0
 801922e:	64fb      	str	r3, [r7, #76]	@ 0x4c

        if(p->cfg.end_angle > 270 && p->cfg.end_angle <= 359 && start_angle_last < 0) start_angle_last = 0;
 8019230:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019232:	695b      	ldr	r3, [r3, #20]
 8019234:	f5b3 7f87 	cmp.w	r3, #270	@ 0x10e
 8019238:	dd0a      	ble.n	8019250 <lv_draw_mask_angle+0xfc>
 801923a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801923c:	695b      	ldr	r3, [r3, #20]
 801923e:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 8019242:	da05      	bge.n	8019250 <lv_draw_mask_angle+0xfc>
 8019244:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8019246:	2b00      	cmp	r3, #0
 8019248:	da02      	bge.n	8019250 <lv_draw_mask_angle+0xfc>
 801924a:	2300      	movs	r3, #0
 801924c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801924e:	e01b      	b.n	8019288 <lv_draw_mask_angle+0x134>
        else if(p->cfg.end_angle > 0 &&   p->cfg.end_angle <= 90 && start_angle_last < 0) start_angle_last = 0;
 8019250:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019252:	695b      	ldr	r3, [r3, #20]
 8019254:	2b00      	cmp	r3, #0
 8019256:	dd09      	ble.n	801926c <lv_draw_mask_angle+0x118>
 8019258:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801925a:	695b      	ldr	r3, [r3, #20]
 801925c:	2b5a      	cmp	r3, #90	@ 0x5a
 801925e:	dc05      	bgt.n	801926c <lv_draw_mask_angle+0x118>
 8019260:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8019262:	2b00      	cmp	r3, #0
 8019264:	da02      	bge.n	801926c <lv_draw_mask_angle+0x118>
 8019266:	2300      	movs	r3, #0
 8019268:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801926a:	e00d      	b.n	8019288 <lv_draw_mask_angle+0x134>
        else if(p->cfg.end_angle > 90 &&  p->cfg.end_angle < 270 && start_angle_last > 0) start_angle_last = 0;
 801926c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801926e:	695b      	ldr	r3, [r3, #20]
 8019270:	2b5a      	cmp	r3, #90	@ 0x5a
 8019272:	dd09      	ble.n	8019288 <lv_draw_mask_angle+0x134>
 8019274:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019276:	695b      	ldr	r3, [r3, #20]
 8019278:	f5b3 7f87 	cmp.w	r3, #270	@ 0x10e
 801927c:	da04      	bge.n	8019288 <lv_draw_mask_angle+0x134>
 801927e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8019280:	2b00      	cmp	r3, #0
 8019282:	dd01      	ble.n	8019288 <lv_draw_mask_angle+0x134>
 8019284:	2300      	movs	r3, #0
 8019286:	64fb      	str	r3, [r7, #76]	@ 0x4c

        int32_t dist = (end_angle_first - start_angle_last) >> 1;
 8019288:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801928a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801928c:	1ad3      	subs	r3, r2, r3
 801928e:	105b      	asrs	r3, r3, #1
 8019290:	627b      	str	r3, [r7, #36]	@ 0x24

        lv_draw_sw_mask_res_t res1 = LV_DRAW_SW_MASK_RES_FULL_COVER;
 8019292:	2301      	movs	r3, #1
 8019294:	f887 304b 	strb.w	r3, [r7, #75]	@ 0x4b
        lv_draw_sw_mask_res_t res2 = LV_DRAW_SW_MASK_RES_FULL_COVER;
 8019298:	2301      	movs	r3, #1
 801929a:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23

        int32_t tmp = start_angle_last + dist - rel_x;
 801929e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80192a0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80192a2:	441a      	add	r2, r3
 80192a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80192a6:	1ad3      	subs	r3, r2, r3
 80192a8:	647b      	str	r3, [r7, #68]	@ 0x44
        if(tmp > len) tmp = len;
 80192aa:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80192ac:	683b      	ldr	r3, [r7, #0]
 80192ae:	429a      	cmp	r2, r3
 80192b0:	dd01      	ble.n	80192b6 <lv_draw_mask_angle+0x162>
 80192b2:	683b      	ldr	r3, [r7, #0]
 80192b4:	647b      	str	r3, [r7, #68]	@ 0x44
        if(tmp > 0) {
 80192b6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80192b8:	2b00      	cmp	r3, #0
 80192ba:	dd14      	ble.n	80192e6 <lv_draw_mask_angle+0x192>
            res1 = lv_draw_mask_line(&mask_buf[0], abs_x, abs_y, tmp, &p->start_line);
 80192bc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80192be:	3318      	adds	r3, #24
 80192c0:	9300      	str	r3, [sp, #0]
 80192c2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80192c4:	687a      	ldr	r2, [r7, #4]
 80192c6:	68b9      	ldr	r1, [r7, #8]
 80192c8:	68f8      	ldr	r0, [r7, #12]
 80192ca:	f7ff fadf 	bl	801888c <lv_draw_mask_line>
 80192ce:	4603      	mov	r3, r0
 80192d0:	f887 304b 	strb.w	r3, [r7, #75]	@ 0x4b
            if(res1 == LV_DRAW_SW_MASK_RES_TRANSP) {
 80192d4:	f897 304b 	ldrb.w	r3, [r7, #75]	@ 0x4b
 80192d8:	2b00      	cmp	r3, #0
 80192da:	d104      	bne.n	80192e6 <lv_draw_mask_angle+0x192>
                lv_memzero(&mask_buf[0], tmp);
 80192dc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80192de:	4619      	mov	r1, r3
 80192e0:	68f8      	ldr	r0, [r7, #12]
 80192e2:	f7fe ff2a 	bl	801813a <lv_memzero>
            }
        }

        if(tmp > len) tmp = len;
 80192e6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80192e8:	683b      	ldr	r3, [r7, #0]
 80192ea:	429a      	cmp	r2, r3
 80192ec:	dd01      	ble.n	80192f2 <lv_draw_mask_angle+0x19e>
 80192ee:	683b      	ldr	r3, [r7, #0]
 80192f0:	647b      	str	r3, [r7, #68]	@ 0x44
        if(tmp < 0) tmp = 0;
 80192f2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80192f4:	2b00      	cmp	r3, #0
 80192f6:	da01      	bge.n	80192fc <lv_draw_mask_angle+0x1a8>
 80192f8:	2300      	movs	r3, #0
 80192fa:	647b      	str	r3, [r7, #68]	@ 0x44
        res2 = lv_draw_mask_line(&mask_buf[tmp], abs_x + tmp, abs_y, len - tmp, &p->end_line);
 80192fc:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 80192fe:	68fa      	ldr	r2, [r7, #12]
 8019300:	18d0      	adds	r0, r2, r3
 8019302:	68ba      	ldr	r2, [r7, #8]
 8019304:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8019306:	18d1      	adds	r1, r2, r3
 8019308:	683a      	ldr	r2, [r7, #0]
 801930a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801930c:	1ad2      	subs	r2, r2, r3
 801930e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019310:	3350      	adds	r3, #80	@ 0x50
 8019312:	9300      	str	r3, [sp, #0]
 8019314:	4613      	mov	r3, r2
 8019316:	687a      	ldr	r2, [r7, #4]
 8019318:	f7ff fab8 	bl	801888c <lv_draw_mask_line>
 801931c:	4603      	mov	r3, r0
 801931e:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
        if(res2 == LV_DRAW_SW_MASK_RES_TRANSP) {
 8019322:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8019326:	2b00      	cmp	r3, #0
 8019328:	d108      	bne.n	801933c <lv_draw_mask_angle+0x1e8>
            lv_memzero(&mask_buf[tmp], len - tmp);
 801932a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801932c:	68fa      	ldr	r2, [r7, #12]
 801932e:	18d0      	adds	r0, r2, r3
 8019330:	683a      	ldr	r2, [r7, #0]
 8019332:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8019334:	1ad3      	subs	r3, r2, r3
 8019336:	4619      	mov	r1, r3
 8019338:	f7fe feff 	bl	801813a <lv_memzero>
        }
        if(res1 == res2) return res1;
 801933c:	f897 204b 	ldrb.w	r2, [r7, #75]	@ 0x4b
 8019340:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8019344:	429a      	cmp	r2, r3
 8019346:	d102      	bne.n	801934e <lv_draw_mask_angle+0x1fa>
 8019348:	f897 304b 	ldrb.w	r3, [r7, #75]	@ 0x4b
 801934c:	e18e      	b.n	801966c <lv_draw_mask_angle+0x518>
        else return LV_DRAW_SW_MASK_RES_CHANGED;
 801934e:	2302      	movs	r3, #2
 8019350:	e18c      	b.n	801966c <lv_draw_mask_angle+0x518>
    }
    else if(p->cfg.start_angle > 180 && p->cfg.end_angle > 180 && p->cfg.start_angle > p->cfg.end_angle) {
 8019352:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019354:	691b      	ldr	r3, [r3, #16]
 8019356:	2bb4      	cmp	r3, #180	@ 0xb4
 8019358:	f340 80db 	ble.w	8019512 <lv_draw_mask_angle+0x3be>
 801935c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801935e:	695b      	ldr	r3, [r3, #20]
 8019360:	2bb4      	cmp	r3, #180	@ 0xb4
 8019362:	f340 80d6 	ble.w	8019512 <lv_draw_mask_angle+0x3be>
 8019366:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019368:	691a      	ldr	r2, [r3, #16]
 801936a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801936c:	695b      	ldr	r3, [r3, #20]
 801936e:	429a      	cmp	r2, r3
 8019370:	f340 80cf 	ble.w	8019512 <lv_draw_mask_angle+0x3be>

        if(abs_y > p->cfg.vertex_p.y) {
 8019374:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019376:	68db      	ldr	r3, [r3, #12]
 8019378:	687a      	ldr	r2, [r7, #4]
 801937a:	429a      	cmp	r2, r3
 801937c:	dd01      	ble.n	8019382 <lv_draw_mask_angle+0x22e>
            return LV_DRAW_SW_MASK_RES_FULL_COVER;
 801937e:	2301      	movs	r3, #1
 8019380:	e174      	b.n	801966c <lv_draw_mask_angle+0x518>
        }

        /*Start angle mask can work only from the end of end angle mask*/
        int32_t end_angle_first = (rel_y * p->end_line.xy_steep) >> 10;
 8019382:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019384:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8019386:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8019388:	fb02 f303 	mul.w	r3, r2, r3
 801938c:	129b      	asrs	r3, r3, #10
 801938e:	61fb      	str	r3, [r7, #28]
        int32_t start_angle_last = ((rel_y + 1) * p->start_line.xy_steep) >> 10;
 8019390:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019392:	3301      	adds	r3, #1
 8019394:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8019396:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 8019398:	fb02 f303 	mul.w	r3, r2, r3
 801939c:	129b      	asrs	r3, r3, #10
 801939e:	643b      	str	r3, [r7, #64]	@ 0x40

        /*Do not let the line end cross the vertex else it will affect the opposite part*/
        if(p->cfg.start_angle > 270 && p->cfg.start_angle <= 359 && start_angle_last < 0) start_angle_last = 0;
 80193a0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80193a2:	691b      	ldr	r3, [r3, #16]
 80193a4:	f5b3 7f87 	cmp.w	r3, #270	@ 0x10e
 80193a8:	dd0a      	ble.n	80193c0 <lv_draw_mask_angle+0x26c>
 80193aa:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80193ac:	691b      	ldr	r3, [r3, #16]
 80193ae:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 80193b2:	da05      	bge.n	80193c0 <lv_draw_mask_angle+0x26c>
 80193b4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80193b6:	2b00      	cmp	r3, #0
 80193b8:	da02      	bge.n	80193c0 <lv_draw_mask_angle+0x26c>
 80193ba:	2300      	movs	r3, #0
 80193bc:	643b      	str	r3, [r7, #64]	@ 0x40
 80193be:	e01b      	b.n	80193f8 <lv_draw_mask_angle+0x2a4>
        else if(p->cfg.start_angle > 0 && p->cfg.start_angle <= 90 && start_angle_last < 0) start_angle_last = 0;
 80193c0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80193c2:	691b      	ldr	r3, [r3, #16]
 80193c4:	2b00      	cmp	r3, #0
 80193c6:	dd09      	ble.n	80193dc <lv_draw_mask_angle+0x288>
 80193c8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80193ca:	691b      	ldr	r3, [r3, #16]
 80193cc:	2b5a      	cmp	r3, #90	@ 0x5a
 80193ce:	dc05      	bgt.n	80193dc <lv_draw_mask_angle+0x288>
 80193d0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80193d2:	2b00      	cmp	r3, #0
 80193d4:	da02      	bge.n	80193dc <lv_draw_mask_angle+0x288>
 80193d6:	2300      	movs	r3, #0
 80193d8:	643b      	str	r3, [r7, #64]	@ 0x40
 80193da:	e00d      	b.n	80193f8 <lv_draw_mask_angle+0x2a4>
        else if(p->cfg.start_angle > 90 && p->cfg.start_angle < 270 && start_angle_last > 0) start_angle_last = 0;
 80193dc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80193de:	691b      	ldr	r3, [r3, #16]
 80193e0:	2b5a      	cmp	r3, #90	@ 0x5a
 80193e2:	dd09      	ble.n	80193f8 <lv_draw_mask_angle+0x2a4>
 80193e4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80193e6:	691b      	ldr	r3, [r3, #16]
 80193e8:	f5b3 7f87 	cmp.w	r3, #270	@ 0x10e
 80193ec:	da04      	bge.n	80193f8 <lv_draw_mask_angle+0x2a4>
 80193ee:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80193f0:	2b00      	cmp	r3, #0
 80193f2:	dd01      	ble.n	80193f8 <lv_draw_mask_angle+0x2a4>
 80193f4:	2300      	movs	r3, #0
 80193f6:	643b      	str	r3, [r7, #64]	@ 0x40

        if(p->cfg.end_angle > 270 && p->cfg.end_angle <= 359 && start_angle_last < 0) start_angle_last = 0;
 80193f8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80193fa:	695b      	ldr	r3, [r3, #20]
 80193fc:	f5b3 7f87 	cmp.w	r3, #270	@ 0x10e
 8019400:	dd0a      	ble.n	8019418 <lv_draw_mask_angle+0x2c4>
 8019402:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019404:	695b      	ldr	r3, [r3, #20]
 8019406:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 801940a:	da05      	bge.n	8019418 <lv_draw_mask_angle+0x2c4>
 801940c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801940e:	2b00      	cmp	r3, #0
 8019410:	da02      	bge.n	8019418 <lv_draw_mask_angle+0x2c4>
 8019412:	2300      	movs	r3, #0
 8019414:	643b      	str	r3, [r7, #64]	@ 0x40
 8019416:	e01b      	b.n	8019450 <lv_draw_mask_angle+0x2fc>
        else if(p->cfg.end_angle > 0 &&   p->cfg.end_angle <= 90 && start_angle_last < 0) start_angle_last = 0;
 8019418:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801941a:	695b      	ldr	r3, [r3, #20]
 801941c:	2b00      	cmp	r3, #0
 801941e:	dd09      	ble.n	8019434 <lv_draw_mask_angle+0x2e0>
 8019420:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019422:	695b      	ldr	r3, [r3, #20]
 8019424:	2b5a      	cmp	r3, #90	@ 0x5a
 8019426:	dc05      	bgt.n	8019434 <lv_draw_mask_angle+0x2e0>
 8019428:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801942a:	2b00      	cmp	r3, #0
 801942c:	da02      	bge.n	8019434 <lv_draw_mask_angle+0x2e0>
 801942e:	2300      	movs	r3, #0
 8019430:	643b      	str	r3, [r7, #64]	@ 0x40
 8019432:	e00d      	b.n	8019450 <lv_draw_mask_angle+0x2fc>
        else if(p->cfg.end_angle > 90 &&  p->cfg.end_angle < 270 && start_angle_last > 0) start_angle_last = 0;
 8019434:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019436:	695b      	ldr	r3, [r3, #20]
 8019438:	2b5a      	cmp	r3, #90	@ 0x5a
 801943a:	dd09      	ble.n	8019450 <lv_draw_mask_angle+0x2fc>
 801943c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801943e:	695b      	ldr	r3, [r3, #20]
 8019440:	f5b3 7f87 	cmp.w	r3, #270	@ 0x10e
 8019444:	da04      	bge.n	8019450 <lv_draw_mask_angle+0x2fc>
 8019446:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8019448:	2b00      	cmp	r3, #0
 801944a:	dd01      	ble.n	8019450 <lv_draw_mask_angle+0x2fc>
 801944c:	2300      	movs	r3, #0
 801944e:	643b      	str	r3, [r7, #64]	@ 0x40

        int32_t dist = (end_angle_first - start_angle_last) >> 1;
 8019450:	69fa      	ldr	r2, [r7, #28]
 8019452:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8019454:	1ad3      	subs	r3, r2, r3
 8019456:	105b      	asrs	r3, r3, #1
 8019458:	61bb      	str	r3, [r7, #24]

        lv_draw_sw_mask_res_t res1 = LV_DRAW_SW_MASK_RES_FULL_COVER;
 801945a:	2301      	movs	r3, #1
 801945c:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
        lv_draw_sw_mask_res_t res2 = LV_DRAW_SW_MASK_RES_FULL_COVER;
 8019460:	2301      	movs	r3, #1
 8019462:	75fb      	strb	r3, [r7, #23]

        int32_t tmp = start_angle_last + dist - rel_x;
 8019464:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8019466:	69bb      	ldr	r3, [r7, #24]
 8019468:	441a      	add	r2, r3
 801946a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801946c:	1ad3      	subs	r3, r2, r3
 801946e:	63bb      	str	r3, [r7, #56]	@ 0x38
        if(tmp > len) tmp = len;
 8019470:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8019472:	683b      	ldr	r3, [r7, #0]
 8019474:	429a      	cmp	r2, r3
 8019476:	dd01      	ble.n	801947c <lv_draw_mask_angle+0x328>
 8019478:	683b      	ldr	r3, [r7, #0]
 801947a:	63bb      	str	r3, [r7, #56]	@ 0x38
        if(tmp > 0) {
 801947c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801947e:	2b00      	cmp	r3, #0
 8019480:	dd14      	ble.n	80194ac <lv_draw_mask_angle+0x358>
            res1 = lv_draw_mask_line(&mask_buf[0], abs_x, abs_y, tmp, (lv_draw_sw_mask_line_param_t *)&p->end_line);
 8019482:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019484:	3350      	adds	r3, #80	@ 0x50
 8019486:	9300      	str	r3, [sp, #0]
 8019488:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801948a:	687a      	ldr	r2, [r7, #4]
 801948c:	68b9      	ldr	r1, [r7, #8]
 801948e:	68f8      	ldr	r0, [r7, #12]
 8019490:	f7ff f9fc 	bl	801888c <lv_draw_mask_line>
 8019494:	4603      	mov	r3, r0
 8019496:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
            if(res1 == LV_DRAW_SW_MASK_RES_TRANSP) {
 801949a:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 801949e:	2b00      	cmp	r3, #0
 80194a0:	d104      	bne.n	80194ac <lv_draw_mask_angle+0x358>
                lv_memzero(&mask_buf[0], tmp);
 80194a2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80194a4:	4619      	mov	r1, r3
 80194a6:	68f8      	ldr	r0, [r7, #12]
 80194a8:	f7fe fe47 	bl	801813a <lv_memzero>
            }
        }

        if(tmp > len) tmp = len;
 80194ac:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80194ae:	683b      	ldr	r3, [r7, #0]
 80194b0:	429a      	cmp	r2, r3
 80194b2:	dd01      	ble.n	80194b8 <lv_draw_mask_angle+0x364>
 80194b4:	683b      	ldr	r3, [r7, #0]
 80194b6:	63bb      	str	r3, [r7, #56]	@ 0x38
        if(tmp < 0) tmp = 0;
 80194b8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80194ba:	2b00      	cmp	r3, #0
 80194bc:	da01      	bge.n	80194c2 <lv_draw_mask_angle+0x36e>
 80194be:	2300      	movs	r3, #0
 80194c0:	63bb      	str	r3, [r7, #56]	@ 0x38
        res2 = lv_draw_mask_line(&mask_buf[tmp], abs_x + tmp, abs_y, len - tmp, (lv_draw_sw_mask_line_param_t *)&p->start_line);
 80194c2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80194c4:	68fa      	ldr	r2, [r7, #12]
 80194c6:	18d0      	adds	r0, r2, r3
 80194c8:	68ba      	ldr	r2, [r7, #8]
 80194ca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80194cc:	18d1      	adds	r1, r2, r3
 80194ce:	683a      	ldr	r2, [r7, #0]
 80194d0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80194d2:	1ad2      	subs	r2, r2, r3
 80194d4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80194d6:	3318      	adds	r3, #24
 80194d8:	9300      	str	r3, [sp, #0]
 80194da:	4613      	mov	r3, r2
 80194dc:	687a      	ldr	r2, [r7, #4]
 80194de:	f7ff f9d5 	bl	801888c <lv_draw_mask_line>
 80194e2:	4603      	mov	r3, r0
 80194e4:	75fb      	strb	r3, [r7, #23]
        if(res2 == LV_DRAW_SW_MASK_RES_TRANSP) {
 80194e6:	7dfb      	ldrb	r3, [r7, #23]
 80194e8:	2b00      	cmp	r3, #0
 80194ea:	d108      	bne.n	80194fe <lv_draw_mask_angle+0x3aa>
            lv_memzero(&mask_buf[tmp], len - tmp);
 80194ec:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80194ee:	68fa      	ldr	r2, [r7, #12]
 80194f0:	18d0      	adds	r0, r2, r3
 80194f2:	683a      	ldr	r2, [r7, #0]
 80194f4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80194f6:	1ad3      	subs	r3, r2, r3
 80194f8:	4619      	mov	r1, r3
 80194fa:	f7fe fe1e 	bl	801813a <lv_memzero>
        }
        if(res1 == res2) return res1;
 80194fe:	f897 203f 	ldrb.w	r2, [r7, #63]	@ 0x3f
 8019502:	7dfb      	ldrb	r3, [r7, #23]
 8019504:	429a      	cmp	r2, r3
 8019506:	d102      	bne.n	801950e <lv_draw_mask_angle+0x3ba>
 8019508:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 801950c:	e0ae      	b.n	801966c <lv_draw_mask_angle+0x518>
        else return LV_DRAW_SW_MASK_RES_CHANGED;
 801950e:	2302      	movs	r3, #2
 8019510:	e0ac      	b.n	801966c <lv_draw_mask_angle+0x518>
    }
    else  {

        lv_draw_sw_mask_res_t res1 = LV_DRAW_SW_MASK_RES_FULL_COVER;
 8019512:	2301      	movs	r3, #1
 8019514:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
        lv_draw_sw_mask_res_t res2 = LV_DRAW_SW_MASK_RES_FULL_COVER;
 8019518:	2301      	movs	r3, #1
 801951a:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36

        if(p->cfg.start_angle == 180) {
 801951e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019520:	691b      	ldr	r3, [r3, #16]
 8019522:	2bb4      	cmp	r3, #180	@ 0xb4
 8019524:	d10c      	bne.n	8019540 <lv_draw_mask_angle+0x3ec>
            if(abs_y < p->cfg.vertex_p.y) res1 = LV_DRAW_SW_MASK_RES_FULL_COVER;
 8019526:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019528:	68db      	ldr	r3, [r3, #12]
 801952a:	687a      	ldr	r2, [r7, #4]
 801952c:	429a      	cmp	r2, r3
 801952e:	da03      	bge.n	8019538 <lv_draw_mask_angle+0x3e4>
 8019530:	2301      	movs	r3, #1
 8019532:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
 8019536:	e036      	b.n	80195a6 <lv_draw_mask_angle+0x452>
            else res1 = LV_DRAW_SW_MASK_RES_UNKNOWN;
 8019538:	2303      	movs	r3, #3
 801953a:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
 801953e:	e032      	b.n	80195a6 <lv_draw_mask_angle+0x452>
        }
        else if(p->cfg.start_angle == 0) {
 8019540:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019542:	691b      	ldr	r3, [r3, #16]
 8019544:	2b00      	cmp	r3, #0
 8019546:	d10c      	bne.n	8019562 <lv_draw_mask_angle+0x40e>
            if(abs_y < p->cfg.vertex_p.y) res1 = LV_DRAW_SW_MASK_RES_UNKNOWN;
 8019548:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801954a:	68db      	ldr	r3, [r3, #12]
 801954c:	687a      	ldr	r2, [r7, #4]
 801954e:	429a      	cmp	r2, r3
 8019550:	da03      	bge.n	801955a <lv_draw_mask_angle+0x406>
 8019552:	2303      	movs	r3, #3
 8019554:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
 8019558:	e025      	b.n	80195a6 <lv_draw_mask_angle+0x452>
            else res1 = LV_DRAW_SW_MASK_RES_FULL_COVER;
 801955a:	2301      	movs	r3, #1
 801955c:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
 8019560:	e021      	b.n	80195a6 <lv_draw_mask_angle+0x452>
        }
        else if((p->cfg.start_angle < 180 && abs_y < p->cfg.vertex_p.y) ||
 8019562:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019564:	691b      	ldr	r3, [r3, #16]
 8019566:	2bb3      	cmp	r3, #179	@ 0xb3
 8019568:	dc04      	bgt.n	8019574 <lv_draw_mask_angle+0x420>
 801956a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801956c:	68db      	ldr	r3, [r3, #12]
 801956e:	687a      	ldr	r2, [r7, #4]
 8019570:	429a      	cmp	r2, r3
 8019572:	db08      	blt.n	8019586 <lv_draw_mask_angle+0x432>
                (p->cfg.start_angle > 180 && abs_y >= p->cfg.vertex_p.y)) {
 8019574:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019576:	691b      	ldr	r3, [r3, #16]
        else if((p->cfg.start_angle < 180 && abs_y < p->cfg.vertex_p.y) ||
 8019578:	2bb4      	cmp	r3, #180	@ 0xb4
 801957a:	dd08      	ble.n	801958e <lv_draw_mask_angle+0x43a>
                (p->cfg.start_angle > 180 && abs_y >= p->cfg.vertex_p.y)) {
 801957c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801957e:	68db      	ldr	r3, [r3, #12]
 8019580:	687a      	ldr	r2, [r7, #4]
 8019582:	429a      	cmp	r2, r3
 8019584:	db03      	blt.n	801958e <lv_draw_mask_angle+0x43a>
            res1 = LV_DRAW_SW_MASK_RES_UNKNOWN;
 8019586:	2303      	movs	r3, #3
 8019588:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
 801958c:	e00b      	b.n	80195a6 <lv_draw_mask_angle+0x452>
        }
        else  {
            res1 = lv_draw_mask_line(mask_buf, abs_x, abs_y, len, &p->start_line);
 801958e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019590:	3318      	adds	r3, #24
 8019592:	9300      	str	r3, [sp, #0]
 8019594:	683b      	ldr	r3, [r7, #0]
 8019596:	687a      	ldr	r2, [r7, #4]
 8019598:	68b9      	ldr	r1, [r7, #8]
 801959a:	68f8      	ldr	r0, [r7, #12]
 801959c:	f7ff f976 	bl	801888c <lv_draw_mask_line>
 80195a0:	4603      	mov	r3, r0
 80195a2:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
        }

        if(p->cfg.end_angle == 180) {
 80195a6:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80195a8:	695b      	ldr	r3, [r3, #20]
 80195aa:	2bb4      	cmp	r3, #180	@ 0xb4
 80195ac:	d10c      	bne.n	80195c8 <lv_draw_mask_angle+0x474>
            if(abs_y < p->cfg.vertex_p.y) res2 = LV_DRAW_SW_MASK_RES_UNKNOWN;
 80195ae:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80195b0:	68db      	ldr	r3, [r3, #12]
 80195b2:	687a      	ldr	r2, [r7, #4]
 80195b4:	429a      	cmp	r2, r3
 80195b6:	da03      	bge.n	80195c0 <lv_draw_mask_angle+0x46c>
 80195b8:	2303      	movs	r3, #3
 80195ba:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
 80195be:	e036      	b.n	801962e <lv_draw_mask_angle+0x4da>
            else res2 = LV_DRAW_SW_MASK_RES_FULL_COVER;
 80195c0:	2301      	movs	r3, #1
 80195c2:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
 80195c6:	e032      	b.n	801962e <lv_draw_mask_angle+0x4da>
        }
        else if(p->cfg.end_angle == 0) {
 80195c8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80195ca:	695b      	ldr	r3, [r3, #20]
 80195cc:	2b00      	cmp	r3, #0
 80195ce:	d10c      	bne.n	80195ea <lv_draw_mask_angle+0x496>
            if(abs_y < p->cfg.vertex_p.y) res2 = LV_DRAW_SW_MASK_RES_FULL_COVER;
 80195d0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80195d2:	68db      	ldr	r3, [r3, #12]
 80195d4:	687a      	ldr	r2, [r7, #4]
 80195d6:	429a      	cmp	r2, r3
 80195d8:	da03      	bge.n	80195e2 <lv_draw_mask_angle+0x48e>
 80195da:	2301      	movs	r3, #1
 80195dc:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
 80195e0:	e025      	b.n	801962e <lv_draw_mask_angle+0x4da>
            else res2 = LV_DRAW_SW_MASK_RES_UNKNOWN;
 80195e2:	2303      	movs	r3, #3
 80195e4:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
 80195e8:	e021      	b.n	801962e <lv_draw_mask_angle+0x4da>
        }
        else if((p->cfg.end_angle < 180 && abs_y < p->cfg.vertex_p.y) ||
 80195ea:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80195ec:	695b      	ldr	r3, [r3, #20]
 80195ee:	2bb3      	cmp	r3, #179	@ 0xb3
 80195f0:	dc04      	bgt.n	80195fc <lv_draw_mask_angle+0x4a8>
 80195f2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80195f4:	68db      	ldr	r3, [r3, #12]
 80195f6:	687a      	ldr	r2, [r7, #4]
 80195f8:	429a      	cmp	r2, r3
 80195fa:	db08      	blt.n	801960e <lv_draw_mask_angle+0x4ba>
                (p->cfg.end_angle > 180 && abs_y >= p->cfg.vertex_p.y)) {
 80195fc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80195fe:	695b      	ldr	r3, [r3, #20]
        else if((p->cfg.end_angle < 180 && abs_y < p->cfg.vertex_p.y) ||
 8019600:	2bb4      	cmp	r3, #180	@ 0xb4
 8019602:	dd08      	ble.n	8019616 <lv_draw_mask_angle+0x4c2>
                (p->cfg.end_angle > 180 && abs_y >= p->cfg.vertex_p.y)) {
 8019604:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019606:	68db      	ldr	r3, [r3, #12]
 8019608:	687a      	ldr	r2, [r7, #4]
 801960a:	429a      	cmp	r2, r3
 801960c:	db03      	blt.n	8019616 <lv_draw_mask_angle+0x4c2>
            res2 = LV_DRAW_SW_MASK_RES_UNKNOWN;
 801960e:	2303      	movs	r3, #3
 8019610:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
 8019614:	e00b      	b.n	801962e <lv_draw_mask_angle+0x4da>
        }
        else {
            res2 = lv_draw_mask_line(mask_buf, abs_x, abs_y, len, &p->end_line);
 8019616:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019618:	3350      	adds	r3, #80	@ 0x50
 801961a:	9300      	str	r3, [sp, #0]
 801961c:	683b      	ldr	r3, [r7, #0]
 801961e:	687a      	ldr	r2, [r7, #4]
 8019620:	68b9      	ldr	r1, [r7, #8]
 8019622:	68f8      	ldr	r0, [r7, #12]
 8019624:	f7ff f932 	bl	801888c <lv_draw_mask_line>
 8019628:	4603      	mov	r3, r0
 801962a:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
        }

        if(res1 == LV_DRAW_SW_MASK_RES_TRANSP || res2 == LV_DRAW_SW_MASK_RES_TRANSP) return LV_DRAW_SW_MASK_RES_TRANSP;
 801962e:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 8019632:	2b00      	cmp	r3, #0
 8019634:	d003      	beq.n	801963e <lv_draw_mask_angle+0x4ea>
 8019636:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
 801963a:	2b00      	cmp	r3, #0
 801963c:	d101      	bne.n	8019642 <lv_draw_mask_angle+0x4ee>
 801963e:	2300      	movs	r3, #0
 8019640:	e014      	b.n	801966c <lv_draw_mask_angle+0x518>
        else if(res1 == LV_DRAW_SW_MASK_RES_UNKNOWN && res2 == LV_DRAW_SW_MASK_RES_UNKNOWN) return LV_DRAW_SW_MASK_RES_TRANSP;
 8019642:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 8019646:	2b03      	cmp	r3, #3
 8019648:	d105      	bne.n	8019656 <lv_draw_mask_angle+0x502>
 801964a:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
 801964e:	2b03      	cmp	r3, #3
 8019650:	d101      	bne.n	8019656 <lv_draw_mask_angle+0x502>
 8019652:	2300      	movs	r3, #0
 8019654:	e00a      	b.n	801966c <lv_draw_mask_angle+0x518>
        else if(res1 == LV_DRAW_SW_MASK_RES_FULL_COVER &&
 8019656:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 801965a:	2b01      	cmp	r3, #1
 801965c:	d105      	bne.n	801966a <lv_draw_mask_angle+0x516>
 801965e:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
 8019662:	2b01      	cmp	r3, #1
 8019664:	d101      	bne.n	801966a <lv_draw_mask_angle+0x516>
                res2 == LV_DRAW_SW_MASK_RES_FULL_COVER) return LV_DRAW_SW_MASK_RES_FULL_COVER;
 8019666:	2301      	movs	r3, #1
 8019668:	e000      	b.n	801966c <lv_draw_mask_angle+0x518>
        else return LV_DRAW_SW_MASK_RES_CHANGED;
 801966a:	2302      	movs	r3, #2
    }
}
 801966c:	4618      	mov	r0, r3
 801966e:	3750      	adds	r7, #80	@ 0x50
 8019670:	46bd      	mov	sp, r7
 8019672:	bd80      	pop	{r7, pc}

08019674 <lv_draw_mask_radius>:

static lv_draw_sw_mask_res_t LV_ATTRIBUTE_FAST_MEM lv_draw_mask_radius(lv_opa_t * mask_buf, int32_t abs_x,
                                                                       int32_t abs_y, int32_t len,
                                                                       lv_draw_sw_mask_radius_param_t * p)
{
 8019674:	b590      	push	{r4, r7, lr}
 8019676:	b09d      	sub	sp, #116	@ 0x74
 8019678:	af00      	add	r7, sp, #0
 801967a:	60f8      	str	r0, [r7, #12]
 801967c:	60b9      	str	r1, [r7, #8]
 801967e:	607a      	str	r2, [r7, #4]
 8019680:	603b      	str	r3, [r7, #0]
    bool outer = p->cfg.outer;
 8019682:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8019686:	7f1b      	ldrb	r3, [r3, #28]
 8019688:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801968c:	b2db      	uxtb	r3, r3
 801968e:	2b00      	cmp	r3, #0
 8019690:	bf14      	ite	ne
 8019692:	2301      	movne	r3, #1
 8019694:	2300      	moveq	r3, #0
 8019696:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
    int32_t radius = p->cfg.radius;
 801969a:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801969e:	699b      	ldr	r3, [r3, #24]
 80196a0:	65bb      	str	r3, [r7, #88]	@ 0x58
    lv_area_t rect;
    lv_area_copy(&rect, &p->cfg.rect);
 80196a2:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 80196a6:	f103 0208 	add.w	r2, r3, #8
 80196aa:	f107 031c 	add.w	r3, r7, #28
 80196ae:	4611      	mov	r1, r2
 80196b0:	4618      	mov	r0, r3
 80196b2:	f7fe fcf5 	bl	80180a0 <lv_area_copy>

    if(outer == false) {
 80196b6:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 80196ba:	f083 0301 	eor.w	r3, r3, #1
 80196be:	b2db      	uxtb	r3, r3
 80196c0:	2b00      	cmp	r3, #0
 80196c2:	d009      	beq.n	80196d8 <lv_draw_mask_radius+0x64>
        if((abs_y < rect.y1 || abs_y > rect.y2)) {
 80196c4:	6a3b      	ldr	r3, [r7, #32]
 80196c6:	687a      	ldr	r2, [r7, #4]
 80196c8:	429a      	cmp	r2, r3
 80196ca:	db03      	blt.n	80196d4 <lv_draw_mask_radius+0x60>
 80196cc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80196ce:	687a      	ldr	r2, [r7, #4]
 80196d0:	429a      	cmp	r2, r3
 80196d2:	dd0b      	ble.n	80196ec <lv_draw_mask_radius+0x78>
            return LV_DRAW_SW_MASK_RES_TRANSP;
 80196d4:	2300      	movs	r3, #0
 80196d6:	e1cb      	b.n	8019a70 <lv_draw_mask_radius+0x3fc>
        }
    }
    else {
        if(abs_y < rect.y1 || abs_y > rect.y2) {
 80196d8:	6a3b      	ldr	r3, [r7, #32]
 80196da:	687a      	ldr	r2, [r7, #4]
 80196dc:	429a      	cmp	r2, r3
 80196de:	db03      	blt.n	80196e8 <lv_draw_mask_radius+0x74>
 80196e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80196e2:	687a      	ldr	r2, [r7, #4]
 80196e4:	429a      	cmp	r2, r3
 80196e6:	dd01      	ble.n	80196ec <lv_draw_mask_radius+0x78>
            return LV_DRAW_SW_MASK_RES_FULL_COVER;
 80196e8:	2301      	movs	r3, #1
 80196ea:	e1c1      	b.n	8019a70 <lv_draw_mask_radius+0x3fc>
        }
    }

    if((abs_x >= rect.x1 + radius && abs_x + len <= rect.x2 - radius) ||
 80196ec:	69fa      	ldr	r2, [r7, #28]
 80196ee:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 80196f0:	4413      	add	r3, r2
 80196f2:	68ba      	ldr	r2, [r7, #8]
 80196f4:	429a      	cmp	r2, r3
 80196f6:	db07      	blt.n	8019708 <lv_draw_mask_radius+0x94>
 80196f8:	68ba      	ldr	r2, [r7, #8]
 80196fa:	683b      	ldr	r3, [r7, #0]
 80196fc:	441a      	add	r2, r3
 80196fe:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8019700:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019702:	1acb      	subs	r3, r1, r3
 8019704:	429a      	cmp	r2, r3
 8019706:	dd0b      	ble.n	8019720 <lv_draw_mask_radius+0xac>
       (abs_y >= rect.y1 + radius && abs_y <= rect.y2 - radius)) {
 8019708:	6a3a      	ldr	r2, [r7, #32]
 801970a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801970c:	4413      	add	r3, r2
    if((abs_x >= rect.x1 + radius && abs_x + len <= rect.x2 - radius) ||
 801970e:	687a      	ldr	r2, [r7, #4]
 8019710:	429a      	cmp	r2, r3
 8019712:	db6b      	blt.n	80197ec <lv_draw_mask_radius+0x178>
       (abs_y >= rect.y1 + radius && abs_y <= rect.y2 - radius)) {
 8019714:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8019716:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019718:	1ad3      	subs	r3, r2, r3
 801971a:	687a      	ldr	r2, [r7, #4]
 801971c:	429a      	cmp	r2, r3
 801971e:	dc65      	bgt.n	80197ec <lv_draw_mask_radius+0x178>
        if(outer == false) {
 8019720:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 8019724:	f083 0301 	eor.w	r3, r3, #1
 8019728:	b2db      	uxtb	r3, r3
 801972a:	2b00      	cmp	r3, #0
 801972c:	d033      	beq.n	8019796 <lv_draw_mask_radius+0x122>
            /*Remove the edges*/
            int32_t last = rect.x1 - abs_x;
 801972e:	69fa      	ldr	r2, [r7, #28]
 8019730:	68bb      	ldr	r3, [r7, #8]
 8019732:	1ad3      	subs	r3, r2, r3
 8019734:	633b      	str	r3, [r7, #48]	@ 0x30
            if(last > len) return LV_DRAW_SW_MASK_RES_TRANSP;
 8019736:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8019738:	683b      	ldr	r3, [r7, #0]
 801973a:	429a      	cmp	r2, r3
 801973c:	dd01      	ble.n	8019742 <lv_draw_mask_radius+0xce>
 801973e:	2300      	movs	r3, #0
 8019740:	e196      	b.n	8019a70 <lv_draw_mask_radius+0x3fc>
            if(last >= 0) {
 8019742:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019744:	2b00      	cmp	r3, #0
 8019746:	db04      	blt.n	8019752 <lv_draw_mask_radius+0xde>
                lv_memzero(&mask_buf[0], last);
 8019748:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801974a:	4619      	mov	r1, r3
 801974c:	68f8      	ldr	r0, [r7, #12]
 801974e:	f7fe fcf4 	bl	801813a <lv_memzero>
            }

            int32_t first = rect.x2 - abs_x + 1;
 8019752:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8019754:	68bb      	ldr	r3, [r7, #8]
 8019756:	1ad3      	subs	r3, r2, r3
 8019758:	3301      	adds	r3, #1
 801975a:	62fb      	str	r3, [r7, #44]	@ 0x2c
            if(first <= 0) return LV_DRAW_SW_MASK_RES_TRANSP;
 801975c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801975e:	2b00      	cmp	r3, #0
 8019760:	dc01      	bgt.n	8019766 <lv_draw_mask_radius+0xf2>
 8019762:	2300      	movs	r3, #0
 8019764:	e184      	b.n	8019a70 <lv_draw_mask_radius+0x3fc>
            else if(first < len) {
 8019766:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8019768:	683b      	ldr	r3, [r7, #0]
 801976a:	429a      	cmp	r2, r3
 801976c:	da08      	bge.n	8019780 <lv_draw_mask_radius+0x10c>
                lv_memzero(&mask_buf[first], len - first);
 801976e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019770:	68fa      	ldr	r2, [r7, #12]
 8019772:	18d0      	adds	r0, r2, r3
 8019774:	683a      	ldr	r2, [r7, #0]
 8019776:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8019778:	1ad3      	subs	r3, r2, r3
 801977a:	4619      	mov	r1, r3
 801977c:	f7fe fcdd 	bl	801813a <lv_memzero>
            }
            if(last == 0 && first == len) return LV_DRAW_SW_MASK_RES_FULL_COVER;
 8019780:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019782:	2b00      	cmp	r3, #0
 8019784:	d105      	bne.n	8019792 <lv_draw_mask_radius+0x11e>
 8019786:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8019788:	683b      	ldr	r3, [r7, #0]
 801978a:	429a      	cmp	r2, r3
 801978c:	d101      	bne.n	8019792 <lv_draw_mask_radius+0x11e>
 801978e:	2301      	movs	r3, #1
 8019790:	e16e      	b.n	8019a70 <lv_draw_mask_radius+0x3fc>
            else return LV_DRAW_SW_MASK_RES_CHANGED;
 8019792:	2302      	movs	r3, #2
 8019794:	e16c      	b.n	8019a70 <lv_draw_mask_radius+0x3fc>
        }
        else {
            int32_t first = rect.x1 - abs_x;
 8019796:	69fa      	ldr	r2, [r7, #28]
 8019798:	68bb      	ldr	r3, [r7, #8]
 801979a:	1ad3      	subs	r3, r2, r3
 801979c:	66fb      	str	r3, [r7, #108]	@ 0x6c
            if(first < 0) first = 0;
 801979e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80197a0:	2b00      	cmp	r3, #0
 80197a2:	da01      	bge.n	80197a8 <lv_draw_mask_radius+0x134>
 80197a4:	2300      	movs	r3, #0
 80197a6:	66fb      	str	r3, [r7, #108]	@ 0x6c
            if(first <= len) {
 80197a8:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80197aa:	683b      	ldr	r3, [r7, #0]
 80197ac:	429a      	cmp	r2, r3
 80197ae:	dc1b      	bgt.n	80197e8 <lv_draw_mask_radius+0x174>
                int32_t last = rect.x2 - abs_x - first + 1;
 80197b0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80197b2:	68bb      	ldr	r3, [r7, #8]
 80197b4:	1ad2      	subs	r2, r2, r3
 80197b6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80197b8:	1ad3      	subs	r3, r2, r3
 80197ba:	3301      	adds	r3, #1
 80197bc:	66bb      	str	r3, [r7, #104]	@ 0x68
                if(first + last > len) last = len - first;
 80197be:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80197c0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80197c2:	4413      	add	r3, r2
 80197c4:	683a      	ldr	r2, [r7, #0]
 80197c6:	429a      	cmp	r2, r3
 80197c8:	da03      	bge.n	80197d2 <lv_draw_mask_radius+0x15e>
 80197ca:	683a      	ldr	r2, [r7, #0]
 80197cc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80197ce:	1ad3      	subs	r3, r2, r3
 80197d0:	66bb      	str	r3, [r7, #104]	@ 0x68
                if(last >= 0) {
 80197d2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80197d4:	2b00      	cmp	r3, #0
 80197d6:	db07      	blt.n	80197e8 <lv_draw_mask_radius+0x174>
                    lv_memzero(&mask_buf[first], last);
 80197d8:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80197da:	68fa      	ldr	r2, [r7, #12]
 80197dc:	4413      	add	r3, r2
 80197de:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 80197e0:	4611      	mov	r1, r2
 80197e2:	4618      	mov	r0, r3
 80197e4:	f7fe fca9 	bl	801813a <lv_memzero>
                }
            }
        }
        return LV_DRAW_SW_MASK_RES_CHANGED;
 80197e8:	2302      	movs	r3, #2
 80197ea:	e141      	b.n	8019a70 <lv_draw_mask_radius+0x3fc>
    }

    int32_t k = rect.x1 - abs_x; /*First relevant coordinate on the of the mask*/
 80197ec:	69fa      	ldr	r2, [r7, #28]
 80197ee:	68bb      	ldr	r3, [r7, #8]
 80197f0:	1ad3      	subs	r3, r2, r3
 80197f2:	657b      	str	r3, [r7, #84]	@ 0x54
    int32_t w = lv_area_get_width(&rect);
 80197f4:	f107 031c 	add.w	r3, r7, #28
 80197f8:	4618      	mov	r0, r3
 80197fa:	f7fe fc6c 	bl	80180d6 <lv_area_get_width>
 80197fe:	6538      	str	r0, [r7, #80]	@ 0x50
    int32_t h = lv_area_get_height(&rect);
 8019800:	f107 031c 	add.w	r3, r7, #28
 8019804:	4618      	mov	r0, r3
 8019806:	f7fe fc76 	bl	80180f6 <lv_area_get_height>
 801980a:	64f8      	str	r0, [r7, #76]	@ 0x4c
    abs_x -= rect.x1;
 801980c:	69fb      	ldr	r3, [r7, #28]
 801980e:	68ba      	ldr	r2, [r7, #8]
 8019810:	1ad3      	subs	r3, r2, r3
 8019812:	60bb      	str	r3, [r7, #8]
    abs_y -= rect.y1;
 8019814:	6a3b      	ldr	r3, [r7, #32]
 8019816:	687a      	ldr	r2, [r7, #4]
 8019818:	1ad3      	subs	r3, r2, r3
 801981a:	607b      	str	r3, [r7, #4]

    int32_t aa_len;
    int32_t x_start;
    int32_t cir_y;
    if(abs_y < radius) {
 801981c:	687a      	ldr	r2, [r7, #4]
 801981e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019820:	429a      	cmp	r2, r3
 8019822:	da05      	bge.n	8019830 <lv_draw_mask_radius+0x1bc>
        cir_y = radius - abs_y - 1;
 8019824:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8019826:	687b      	ldr	r3, [r7, #4]
 8019828:	1ad3      	subs	r3, r2, r3
 801982a:	3b01      	subs	r3, #1
 801982c:	667b      	str	r3, [r7, #100]	@ 0x64
 801982e:	e005      	b.n	801983c <lv_draw_mask_radius+0x1c8>
    }
    else {
        cir_y = abs_y - (h - radius);
 8019830:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8019832:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019834:	1ad3      	subs	r3, r2, r3
 8019836:	687a      	ldr	r2, [r7, #4]
 8019838:	1ad3      	subs	r3, r2, r3
 801983a:	667b      	str	r3, [r7, #100]	@ 0x64
    }
    lv_opa_t * aa_opa = get_next_line(p->circle, cir_y, &aa_len, &x_start);
 801983c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8019840:	6a18      	ldr	r0, [r3, #32]
 8019842:	f107 0314 	add.w	r3, r7, #20
 8019846:	f107 0218 	add.w	r2, r7, #24
 801984a:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 801984c:	f000 fc31 	bl	801a0b2 <get_next_line>
 8019850:	64b8      	str	r0, [r7, #72]	@ 0x48
    int32_t cir_x_right = k + w - radius + x_start;
 8019852:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8019854:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8019856:	441a      	add	r2, r3
 8019858:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801985a:	1ad2      	subs	r2, r2, r3
 801985c:	697b      	ldr	r3, [r7, #20]
 801985e:	4413      	add	r3, r2
 8019860:	647b      	str	r3, [r7, #68]	@ 0x44
    int32_t cir_x_left = k + radius - x_start - 1;
 8019862:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8019864:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019866:	441a      	add	r2, r3
 8019868:	697b      	ldr	r3, [r7, #20]
 801986a:	1ad3      	subs	r3, r2, r3
 801986c:	3b01      	subs	r3, #1
 801986e:	643b      	str	r3, [r7, #64]	@ 0x40
    int32_t i;

    if(outer == false) {
 8019870:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
 8019874:	f083 0301 	eor.w	r3, r3, #1
 8019878:	b2db      	uxtb	r3, r3
 801987a:	2b00      	cmp	r3, #0
 801987c:	d074      	beq.n	8019968 <lv_draw_mask_radius+0x2f4>
        for(i = 0; i < aa_len; i++) {
 801987e:	2300      	movs	r3, #0
 8019880:	663b      	str	r3, [r7, #96]	@ 0x60
 8019882:	e049      	b.n	8019918 <lv_draw_mask_radius+0x2a4>
            lv_opa_t opa = aa_opa[aa_len - i - 1];
 8019884:	69ba      	ldr	r2, [r7, #24]
 8019886:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8019888:	1ad3      	subs	r3, r2, r3
 801988a:	3b01      	subs	r3, #1
 801988c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801988e:	4413      	add	r3, r2
 8019890:	781b      	ldrb	r3, [r3, #0]
 8019892:	f887 3036 	strb.w	r3, [r7, #54]	@ 0x36
            if(cir_x_right + i >= 0 && cir_x_right + i < len) {
 8019896:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019898:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801989a:	4413      	add	r3, r2
 801989c:	2b00      	cmp	r3, #0
 801989e:	db19      	blt.n	80198d4 <lv_draw_mask_radius+0x260>
 80198a0:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80198a2:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80198a4:	4413      	add	r3, r2
 80198a6:	683a      	ldr	r2, [r7, #0]
 80198a8:	429a      	cmp	r2, r3
 80198aa:	dd13      	ble.n	80198d4 <lv_draw_mask_radius+0x260>
                mask_buf[cir_x_right + i] = mask_mix(opa, mask_buf[cir_x_right + i]);
 80198ac:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80198ae:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80198b0:	4413      	add	r3, r2
 80198b2:	461a      	mov	r2, r3
 80198b4:	68fb      	ldr	r3, [r7, #12]
 80198b6:	4413      	add	r3, r2
 80198b8:	7819      	ldrb	r1, [r3, #0]
 80198ba:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80198bc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80198be:	4413      	add	r3, r2
 80198c0:	461a      	mov	r2, r3
 80198c2:	68fb      	ldr	r3, [r7, #12]
 80198c4:	189c      	adds	r4, r3, r2
 80198c6:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
 80198ca:	4618      	mov	r0, r3
 80198cc:	f000 fc21 	bl	801a112 <mask_mix>
 80198d0:	4603      	mov	r3, r0
 80198d2:	7023      	strb	r3, [r4, #0]
            }
            if(cir_x_left - i >= 0 && cir_x_left - i < len) {
 80198d4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80198d6:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80198d8:	1ad3      	subs	r3, r2, r3
 80198da:	2b00      	cmp	r3, #0
 80198dc:	db19      	blt.n	8019912 <lv_draw_mask_radius+0x29e>
 80198de:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80198e0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80198e2:	1ad3      	subs	r3, r2, r3
 80198e4:	683a      	ldr	r2, [r7, #0]
 80198e6:	429a      	cmp	r2, r3
 80198e8:	dd13      	ble.n	8019912 <lv_draw_mask_radius+0x29e>
                mask_buf[cir_x_left - i] = mask_mix(opa, mask_buf[cir_x_left - i]);
 80198ea:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80198ec:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80198ee:	1ad3      	subs	r3, r2, r3
 80198f0:	461a      	mov	r2, r3
 80198f2:	68fb      	ldr	r3, [r7, #12]
 80198f4:	4413      	add	r3, r2
 80198f6:	7819      	ldrb	r1, [r3, #0]
 80198f8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80198fa:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80198fc:	1ad3      	subs	r3, r2, r3
 80198fe:	461a      	mov	r2, r3
 8019900:	68fb      	ldr	r3, [r7, #12]
 8019902:	189c      	adds	r4, r3, r2
 8019904:	f897 3036 	ldrb.w	r3, [r7, #54]	@ 0x36
 8019908:	4618      	mov	r0, r3
 801990a:	f000 fc02 	bl	801a112 <mask_mix>
 801990e:	4603      	mov	r3, r0
 8019910:	7023      	strb	r3, [r4, #0]
        for(i = 0; i < aa_len; i++) {
 8019912:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8019914:	3301      	adds	r3, #1
 8019916:	663b      	str	r3, [r7, #96]	@ 0x60
 8019918:	69bb      	ldr	r3, [r7, #24]
 801991a:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 801991c:	429a      	cmp	r2, r3
 801991e:	dbb1      	blt.n	8019884 <lv_draw_mask_radius+0x210>
            }
        }

        /*Clean the right side*/
        cir_x_right = LV_CLAMP(0, cir_x_right + i, len);
 8019920:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019922:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8019924:	441a      	add	r2, r3
 8019926:	683b      	ldr	r3, [r7, #0]
 8019928:	4293      	cmp	r3, r2
 801992a:	bfa8      	it	ge
 801992c:	4613      	movge	r3, r2
 801992e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8019932:	647b      	str	r3, [r7, #68]	@ 0x44
        lv_memzero(&mask_buf[cir_x_right], len - cir_x_right);
 8019934:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8019936:	68fa      	ldr	r2, [r7, #12]
 8019938:	18d0      	adds	r0, r2, r3
 801993a:	683a      	ldr	r2, [r7, #0]
 801993c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801993e:	1ad3      	subs	r3, r2, r3
 8019940:	4619      	mov	r1, r3
 8019942:	f7fe fbfa 	bl	801813a <lv_memzero>

        /*Clean the left side*/
        cir_x_left = LV_CLAMP(0, cir_x_left - aa_len + 1, len);
 8019946:	69bb      	ldr	r3, [r7, #24]
 8019948:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801994a:	1ad3      	subs	r3, r2, r3
 801994c:	1c5a      	adds	r2, r3, #1
 801994e:	683b      	ldr	r3, [r7, #0]
 8019950:	4293      	cmp	r3, r2
 8019952:	bfa8      	it	ge
 8019954:	4613      	movge	r3, r2
 8019956:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 801995a:	643b      	str	r3, [r7, #64]	@ 0x40
        lv_memzero(&mask_buf[0], cir_x_left);
 801995c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801995e:	4619      	mov	r1, r3
 8019960:	68f8      	ldr	r0, [r7, #12]
 8019962:	f7fe fbea 	bl	801813a <lv_memzero>
 8019966:	e082      	b.n	8019a6e <lv_draw_mask_radius+0x3fa>
    }
    else {
        for(i = 0; i < aa_len; i++) {
 8019968:	2300      	movs	r3, #0
 801996a:	663b      	str	r3, [r7, #96]	@ 0x60
 801996c:	e04b      	b.n	8019a06 <lv_draw_mask_radius+0x392>
            lv_opa_t opa = 255 - (aa_opa[aa_len - 1 - i]);
 801996e:	69bb      	ldr	r3, [r7, #24]
 8019970:	1e5a      	subs	r2, r3, #1
 8019972:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8019974:	1ad3      	subs	r3, r2, r3
 8019976:	461a      	mov	r2, r3
 8019978:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801997a:	4413      	add	r3, r2
 801997c:	781b      	ldrb	r3, [r3, #0]
 801997e:	43db      	mvns	r3, r3
 8019980:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
            if(cir_x_right + i >= 0 && cir_x_right + i < len) {
 8019984:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019986:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8019988:	4413      	add	r3, r2
 801998a:	2b00      	cmp	r3, #0
 801998c:	db19      	blt.n	80199c2 <lv_draw_mask_radius+0x34e>
 801998e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019990:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8019992:	4413      	add	r3, r2
 8019994:	683a      	ldr	r2, [r7, #0]
 8019996:	429a      	cmp	r2, r3
 8019998:	dd13      	ble.n	80199c2 <lv_draw_mask_radius+0x34e>
                mask_buf[cir_x_right + i] = mask_mix(opa, mask_buf[cir_x_right + i]);
 801999a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801999c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801999e:	4413      	add	r3, r2
 80199a0:	461a      	mov	r2, r3
 80199a2:	68fb      	ldr	r3, [r7, #12]
 80199a4:	4413      	add	r3, r2
 80199a6:	7819      	ldrb	r1, [r3, #0]
 80199a8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 80199aa:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80199ac:	4413      	add	r3, r2
 80199ae:	461a      	mov	r2, r3
 80199b0:	68fb      	ldr	r3, [r7, #12]
 80199b2:	189c      	adds	r4, r3, r2
 80199b4:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 80199b8:	4618      	mov	r0, r3
 80199ba:	f000 fbaa 	bl	801a112 <mask_mix>
 80199be:	4603      	mov	r3, r0
 80199c0:	7023      	strb	r3, [r4, #0]
            }
            if(cir_x_left - i >= 0 && cir_x_left - i < len) {
 80199c2:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80199c4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80199c6:	1ad3      	subs	r3, r2, r3
 80199c8:	2b00      	cmp	r3, #0
 80199ca:	db19      	blt.n	8019a00 <lv_draw_mask_radius+0x38c>
 80199cc:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80199ce:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80199d0:	1ad3      	subs	r3, r2, r3
 80199d2:	683a      	ldr	r2, [r7, #0]
 80199d4:	429a      	cmp	r2, r3
 80199d6:	dd13      	ble.n	8019a00 <lv_draw_mask_radius+0x38c>
                mask_buf[cir_x_left - i] = mask_mix(opa, mask_buf[cir_x_left - i]);
 80199d8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80199da:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80199dc:	1ad3      	subs	r3, r2, r3
 80199de:	461a      	mov	r2, r3
 80199e0:	68fb      	ldr	r3, [r7, #12]
 80199e2:	4413      	add	r3, r2
 80199e4:	7819      	ldrb	r1, [r3, #0]
 80199e6:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80199e8:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80199ea:	1ad3      	subs	r3, r2, r3
 80199ec:	461a      	mov	r2, r3
 80199ee:	68fb      	ldr	r3, [r7, #12]
 80199f0:	189c      	adds	r4, r3, r2
 80199f2:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 80199f6:	4618      	mov	r0, r3
 80199f8:	f000 fb8b 	bl	801a112 <mask_mix>
 80199fc:	4603      	mov	r3, r0
 80199fe:	7023      	strb	r3, [r4, #0]
        for(i = 0; i < aa_len; i++) {
 8019a00:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8019a02:	3301      	adds	r3, #1
 8019a04:	663b      	str	r3, [r7, #96]	@ 0x60
 8019a06:	69bb      	ldr	r3, [r7, #24]
 8019a08:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8019a0a:	429a      	cmp	r2, r3
 8019a0c:	dbaf      	blt.n	801996e <lv_draw_mask_radius+0x2fa>
            }
        }

        int32_t clr_start = LV_CLAMP(0, cir_x_left + 1, len);
 8019a0e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8019a10:	1c5a      	adds	r2, r3, #1
 8019a12:	683b      	ldr	r3, [r7, #0]
 8019a14:	4293      	cmp	r3, r2
 8019a16:	bfa8      	it	ge
 8019a18:	4613      	movge	r3, r2
 8019a1a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8019a1e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        int32_t clr_len = LV_CLAMP(0, cir_x_right - clr_start, len - clr_start);
 8019a20:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019a22:	683b      	ldr	r3, [r7, #0]
 8019a24:	429a      	cmp	r2, r3
 8019a26:	da05      	bge.n	8019a34 <lv_draw_mask_radius+0x3c0>
 8019a28:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019a2a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8019a2c:	1ad3      	subs	r3, r2, r3
 8019a2e:	0fdb      	lsrs	r3, r3, #31
 8019a30:	b2db      	uxtb	r3, r3
 8019a32:	e004      	b.n	8019a3e <lv_draw_mask_radius+0x3ca>
 8019a34:	683a      	ldr	r2, [r7, #0]
 8019a36:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8019a38:	1ad3      	subs	r3, r2, r3
 8019a3a:	0fdb      	lsrs	r3, r3, #31
 8019a3c:	b2db      	uxtb	r3, r3
 8019a3e:	2b00      	cmp	r3, #0
 8019a40:	d001      	beq.n	8019a46 <lv_draw_mask_radius+0x3d2>
 8019a42:	2300      	movs	r3, #0
 8019a44:	e00a      	b.n	8019a5c <lv_draw_mask_radius+0x3e8>
 8019a46:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019a48:	683b      	ldr	r3, [r7, #0]
 8019a4a:	429a      	cmp	r2, r3
 8019a4c:	da03      	bge.n	8019a56 <lv_draw_mask_radius+0x3e2>
 8019a4e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019a50:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8019a52:	1ad3      	subs	r3, r2, r3
 8019a54:	e002      	b.n	8019a5c <lv_draw_mask_radius+0x3e8>
 8019a56:	683a      	ldr	r2, [r7, #0]
 8019a58:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8019a5a:	1ad3      	subs	r3, r2, r3
 8019a5c:	63bb      	str	r3, [r7, #56]	@ 0x38
        lv_memzero(&mask_buf[clr_start], clr_len);
 8019a5e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8019a60:	68fa      	ldr	r2, [r7, #12]
 8019a62:	4413      	add	r3, r2
 8019a64:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8019a66:	4611      	mov	r1, r2
 8019a68:	4618      	mov	r0, r3
 8019a6a:	f7fe fb66 	bl	801813a <lv_memzero>
    }

    return LV_DRAW_SW_MASK_RES_CHANGED;
 8019a6e:	2302      	movs	r3, #2
}
 8019a70:	4618      	mov	r0, r3
 8019a72:	3774      	adds	r7, #116	@ 0x74
 8019a74:	46bd      	mov	sp, r7
 8019a76:	bd90      	pop	{r4, r7, pc}

08019a78 <circ_init>:
 * @param c pointer to a point. The coordinates will be calculated here
 * @param tmp point to a variable. It will store temporary data
 * @param radius radius of the circle
 */
static void circ_init(lv_point_t * c, int32_t * tmp, int32_t radius)
{
 8019a78:	b480      	push	{r7}
 8019a7a:	b085      	sub	sp, #20
 8019a7c:	af00      	add	r7, sp, #0
 8019a7e:	60f8      	str	r0, [r7, #12]
 8019a80:	60b9      	str	r1, [r7, #8]
 8019a82:	607a      	str	r2, [r7, #4]
    c->x = radius;
 8019a84:	68fb      	ldr	r3, [r7, #12]
 8019a86:	687a      	ldr	r2, [r7, #4]
 8019a88:	601a      	str	r2, [r3, #0]
    c->y = 0;
 8019a8a:	68fb      	ldr	r3, [r7, #12]
 8019a8c:	2200      	movs	r2, #0
 8019a8e:	605a      	str	r2, [r3, #4]
    *tmp = 1 - radius;
 8019a90:	687b      	ldr	r3, [r7, #4]
 8019a92:	f1c3 0201 	rsb	r2, r3, #1
 8019a96:	68bb      	ldr	r3, [r7, #8]
 8019a98:	601a      	str	r2, [r3, #0]
}
 8019a9a:	bf00      	nop
 8019a9c:	3714      	adds	r7, #20
 8019a9e:	46bd      	mov	sp, r7
 8019aa0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019aa4:	4770      	bx	lr

08019aa6 <circ_cont>:
 * Test the circle drawing is ready or not
 * @param c same as in circ_init
 * @return true if the circle is not ready yet
 */
static bool circ_cont(lv_point_t * c)
{
 8019aa6:	b480      	push	{r7}
 8019aa8:	b083      	sub	sp, #12
 8019aaa:	af00      	add	r7, sp, #0
 8019aac:	6078      	str	r0, [r7, #4]
    return c->y <= c->x;
 8019aae:	687b      	ldr	r3, [r7, #4]
 8019ab0:	685a      	ldr	r2, [r3, #4]
 8019ab2:	687b      	ldr	r3, [r7, #4]
 8019ab4:	681b      	ldr	r3, [r3, #0]
 8019ab6:	429a      	cmp	r2, r3
 8019ab8:	bfd4      	ite	le
 8019aba:	2301      	movle	r3, #1
 8019abc:	2300      	movgt	r3, #0
 8019abe:	b2db      	uxtb	r3, r3
}
 8019ac0:	4618      	mov	r0, r3
 8019ac2:	370c      	adds	r7, #12
 8019ac4:	46bd      	mov	sp, r7
 8019ac6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019aca:	4770      	bx	lr

08019acc <circ_next>:
 * Get the next point from the circle
 * @param c same as in circ_init. The next point stored here.
 * @param tmp same as in circ_init.
 */
static void circ_next(lv_point_t * c, int32_t * tmp)
{
 8019acc:	b480      	push	{r7}
 8019ace:	b083      	sub	sp, #12
 8019ad0:	af00      	add	r7, sp, #0
 8019ad2:	6078      	str	r0, [r7, #4]
 8019ad4:	6039      	str	r1, [r7, #0]

    if(*tmp <= 0) {
 8019ad6:	683b      	ldr	r3, [r7, #0]
 8019ad8:	681b      	ldr	r3, [r3, #0]
 8019ada:	2b00      	cmp	r3, #0
 8019adc:	dc09      	bgt.n	8019af2 <circ_next+0x26>
        (*tmp) += 2 * c->y + 3; /*Change in decision criterion for y -> y+1*/
 8019ade:	683b      	ldr	r3, [r7, #0]
 8019ae0:	681a      	ldr	r2, [r3, #0]
 8019ae2:	687b      	ldr	r3, [r7, #4]
 8019ae4:	685b      	ldr	r3, [r3, #4]
 8019ae6:	005b      	lsls	r3, r3, #1
 8019ae8:	3303      	adds	r3, #3
 8019aea:	441a      	add	r2, r3
 8019aec:	683b      	ldr	r3, [r7, #0]
 8019aee:	601a      	str	r2, [r3, #0]
 8019af0:	e010      	b.n	8019b14 <circ_next+0x48>
    }
    else {
        (*tmp) += 2 * (c->y - c->x) + 5; /*Change for y -> y+1, x -> x-1*/
 8019af2:	683b      	ldr	r3, [r7, #0]
 8019af4:	681a      	ldr	r2, [r3, #0]
 8019af6:	687b      	ldr	r3, [r7, #4]
 8019af8:	6859      	ldr	r1, [r3, #4]
 8019afa:	687b      	ldr	r3, [r7, #4]
 8019afc:	681b      	ldr	r3, [r3, #0]
 8019afe:	1acb      	subs	r3, r1, r3
 8019b00:	005b      	lsls	r3, r3, #1
 8019b02:	3305      	adds	r3, #5
 8019b04:	441a      	add	r2, r3
 8019b06:	683b      	ldr	r3, [r7, #0]
 8019b08:	601a      	str	r2, [r3, #0]
        c->x--;
 8019b0a:	687b      	ldr	r3, [r7, #4]
 8019b0c:	681b      	ldr	r3, [r3, #0]
 8019b0e:	1e5a      	subs	r2, r3, #1
 8019b10:	687b      	ldr	r3, [r7, #4]
 8019b12:	601a      	str	r2, [r3, #0]
    }
    c->y++;
 8019b14:	687b      	ldr	r3, [r7, #4]
 8019b16:	685b      	ldr	r3, [r3, #4]
 8019b18:	1c5a      	adds	r2, r3, #1
 8019b1a:	687b      	ldr	r3, [r7, #4]
 8019b1c:	605a      	str	r2, [r3, #4]
}
 8019b1e:	bf00      	nop
 8019b20:	370c      	adds	r7, #12
 8019b22:	46bd      	mov	sp, r7
 8019b24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019b28:	4770      	bx	lr

08019b2a <circ_calc_aa4>:

static void circ_calc_aa4(_lv_draw_sw_mask_radius_circle_dsc_t * c, int32_t radius)
{
 8019b2a:	b580      	push	{r7, lr}
 8019b2c:	b098      	sub	sp, #96	@ 0x60
 8019b2e:	af00      	add	r7, sp, #0
 8019b30:	6078      	str	r0, [r7, #4]
 8019b32:	6039      	str	r1, [r7, #0]
    if(radius == 0) return;
 8019b34:	683b      	ldr	r3, [r7, #0]
 8019b36:	2b00      	cmp	r3, #0
 8019b38:	f000 82b7 	beq.w	801a0aa <circ_calc_aa4+0x580>
    c->radius = radius;
 8019b3c:	687b      	ldr	r3, [r7, #4]
 8019b3e:	683a      	ldr	r2, [r7, #0]
 8019b40:	619a      	str	r2, [r3, #24]

    /*Allocate buffers*/
    if(c->buf) lv_free(c->buf);
 8019b42:	687b      	ldr	r3, [r7, #4]
 8019b44:	681b      	ldr	r3, [r3, #0]
 8019b46:	2b00      	cmp	r3, #0
 8019b48:	d004      	beq.n	8019b54 <circ_calc_aa4+0x2a>
 8019b4a:	687b      	ldr	r3, [r7, #4]
 8019b4c:	681b      	ldr	r3, [r3, #0]
 8019b4e:	4618      	mov	r0, r3
 8019b50:	f00c f972 	bl	8025e38 <lv_free>

    c->buf = lv_malloc(radius * 6 + 6);  /*Use uint16_t for opa_start_on_y and x_start_on_y*/
 8019b54:	683b      	ldr	r3, [r7, #0]
 8019b56:	1c5a      	adds	r2, r3, #1
 8019b58:	4613      	mov	r3, r2
 8019b5a:	005b      	lsls	r3, r3, #1
 8019b5c:	4413      	add	r3, r2
 8019b5e:	005b      	lsls	r3, r3, #1
 8019b60:	4618      	mov	r0, r3
 8019b62:	f00c f931 	bl	8025dc8 <lv_malloc>
 8019b66:	4602      	mov	r2, r0
 8019b68:	687b      	ldr	r3, [r7, #4]
 8019b6a:	601a      	str	r2, [r3, #0]
    LV_ASSERT_MALLOC(c->buf);
 8019b6c:	687b      	ldr	r3, [r7, #4]
 8019b6e:	681b      	ldr	r3, [r3, #0]
 8019b70:	2b00      	cmp	r3, #0
 8019b72:	d101      	bne.n	8019b78 <circ_calc_aa4+0x4e>
 8019b74:	bf00      	nop
 8019b76:	e7fd      	b.n	8019b74 <circ_calc_aa4+0x4a>
    c->cir_opa = c->buf;
 8019b78:	687b      	ldr	r3, [r7, #4]
 8019b7a:	681a      	ldr	r2, [r3, #0]
 8019b7c:	687b      	ldr	r3, [r7, #4]
 8019b7e:	605a      	str	r2, [r3, #4]
    c->opa_start_on_y = (uint16_t *)(c->buf + 2 * radius + 2);
 8019b80:	687b      	ldr	r3, [r7, #4]
 8019b82:	681a      	ldr	r2, [r3, #0]
 8019b84:	683b      	ldr	r3, [r7, #0]
 8019b86:	005b      	lsls	r3, r3, #1
 8019b88:	3302      	adds	r3, #2
 8019b8a:	441a      	add	r2, r3
 8019b8c:	687b      	ldr	r3, [r7, #4]
 8019b8e:	60da      	str	r2, [r3, #12]
    c->x_start_on_y = (uint16_t *)(c->buf + 4 * radius + 4);
 8019b90:	687b      	ldr	r3, [r7, #4]
 8019b92:	681a      	ldr	r2, [r3, #0]
 8019b94:	683b      	ldr	r3, [r7, #0]
 8019b96:	009b      	lsls	r3, r3, #2
 8019b98:	3304      	adds	r3, #4
 8019b9a:	441a      	add	r2, r3
 8019b9c:	687b      	ldr	r3, [r7, #4]
 8019b9e:	609a      	str	r2, [r3, #8]

    /*Special case, handle manually*/
    if(radius == 1) {
 8019ba0:	683b      	ldr	r3, [r7, #0]
 8019ba2:	2b01      	cmp	r3, #1
 8019ba4:	d111      	bne.n	8019bca <circ_calc_aa4+0xa0>
        c->cir_opa[0] = 180;
 8019ba6:	687b      	ldr	r3, [r7, #4]
 8019ba8:	685b      	ldr	r3, [r3, #4]
 8019baa:	22b4      	movs	r2, #180	@ 0xb4
 8019bac:	701a      	strb	r2, [r3, #0]
        c->opa_start_on_y[0] = 0;
 8019bae:	687b      	ldr	r3, [r7, #4]
 8019bb0:	68db      	ldr	r3, [r3, #12]
 8019bb2:	2200      	movs	r2, #0
 8019bb4:	801a      	strh	r2, [r3, #0]
        c->opa_start_on_y[1] = 1;
 8019bb6:	687b      	ldr	r3, [r7, #4]
 8019bb8:	68db      	ldr	r3, [r3, #12]
 8019bba:	3302      	adds	r3, #2
 8019bbc:	2201      	movs	r2, #1
 8019bbe:	801a      	strh	r2, [r3, #0]
        c->x_start_on_y[0] = 0;
 8019bc0:	687b      	ldr	r3, [r7, #4]
 8019bc2:	689b      	ldr	r3, [r3, #8]
 8019bc4:	2200      	movs	r2, #0
 8019bc6:	801a      	strh	r2, [r3, #0]
        return;
 8019bc8:	e270      	b.n	801a0ac <circ_calc_aa4+0x582>
    }

    const size_t cir_xy_size = (radius + 1) * 2 * 2 * sizeof(int32_t);
 8019bca:	683b      	ldr	r3, [r7, #0]
 8019bcc:	3301      	adds	r3, #1
 8019bce:	011b      	lsls	r3, r3, #4
 8019bd0:	64bb      	str	r3, [r7, #72]	@ 0x48
    int32_t * cir_x = lv_malloc_zeroed(cir_xy_size);
 8019bd2:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8019bd4:	f00c f912 	bl	8025dfc <lv_malloc_zeroed>
 8019bd8:	6478      	str	r0, [r7, #68]	@ 0x44
    int32_t * cir_y = &cir_x[(radius + 1) * 2];
 8019bda:	683b      	ldr	r3, [r7, #0]
 8019bdc:	3301      	adds	r3, #1
 8019bde:	00db      	lsls	r3, r3, #3
 8019be0:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019be2:	4413      	add	r3, r2
 8019be4:	643b      	str	r3, [r7, #64]	@ 0x40

    uint32_t y_8th_cnt = 0;
 8019be6:	2300      	movs	r3, #0
 8019be8:	65fb      	str	r3, [r7, #92]	@ 0x5c
    lv_point_t cp;
    int32_t tmp;
    circ_init(&cp, &tmp, radius * 4);    /*Upscale by 4*/
 8019bea:	683b      	ldr	r3, [r7, #0]
 8019bec:	009a      	lsls	r2, r3, #2
 8019bee:	f107 012c 	add.w	r1, r7, #44	@ 0x2c
 8019bf2:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8019bf6:	4618      	mov	r0, r3
 8019bf8:	f7ff ff3e 	bl	8019a78 <circ_init>
    int32_t i;

    uint32_t x_int[4];
    uint32_t x_fract[4];
    int32_t cir_size = 0;
 8019bfc:	2300      	movs	r3, #0
 8019bfe:	657b      	str	r3, [r7, #84]	@ 0x54
    x_int[0] = cp.x >> 2;
 8019c00:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019c02:	109b      	asrs	r3, r3, #2
 8019c04:	61fb      	str	r3, [r7, #28]
    x_fract[0] = 0;
 8019c06:	2300      	movs	r3, #0
 8019c08:	60fb      	str	r3, [r7, #12]

    /*Calculate an 1/8 circle*/
    while(circ_cont(&cp)) {
 8019c0a:	e167      	b.n	8019edc <circ_calc_aa4+0x3b2>
        /*Calculate 4 point of the circle */
        for(i = 0; i < 4; i++) {
 8019c0c:	2300      	movs	r3, #0
 8019c0e:	65bb      	str	r3, [r7, #88]	@ 0x58
 8019c10:	e027      	b.n	8019c62 <circ_calc_aa4+0x138>
            circ_next(&cp, &tmp);
 8019c12:	f107 022c 	add.w	r2, r7, #44	@ 0x2c
 8019c16:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8019c1a:	4611      	mov	r1, r2
 8019c1c:	4618      	mov	r0, r3
 8019c1e:	f7ff ff55 	bl	8019acc <circ_next>
            if(circ_cont(&cp) == false) break;
 8019c22:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8019c26:	4618      	mov	r0, r3
 8019c28:	f7ff ff3d 	bl	8019aa6 <circ_cont>
 8019c2c:	4603      	mov	r3, r0
 8019c2e:	f083 0301 	eor.w	r3, r3, #1
 8019c32:	b2db      	uxtb	r3, r3
 8019c34:	2b00      	cmp	r3, #0
 8019c36:	d118      	bne.n	8019c6a <circ_calc_aa4+0x140>
            x_int[i] = cp.x >> 2;
 8019c38:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019c3a:	109b      	asrs	r3, r3, #2
 8019c3c:	461a      	mov	r2, r3
 8019c3e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019c40:	009b      	lsls	r3, r3, #2
 8019c42:	3360      	adds	r3, #96	@ 0x60
 8019c44:	443b      	add	r3, r7
 8019c46:	f843 2c44 	str.w	r2, [r3, #-68]
            x_fract[i] = cp.x & 0x3;
 8019c4a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8019c4c:	f003 0203 	and.w	r2, r3, #3
 8019c50:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019c52:	009b      	lsls	r3, r3, #2
 8019c54:	3360      	adds	r3, #96	@ 0x60
 8019c56:	443b      	add	r3, r7
 8019c58:	f843 2c54 	str.w	r2, [r3, #-84]
        for(i = 0; i < 4; i++) {
 8019c5c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019c5e:	3301      	adds	r3, #1
 8019c60:	65bb      	str	r3, [r7, #88]	@ 0x58
 8019c62:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019c64:	2b03      	cmp	r3, #3
 8019c66:	ddd4      	ble.n	8019c12 <circ_calc_aa4+0xe8>
 8019c68:	e000      	b.n	8019c6c <circ_calc_aa4+0x142>
            if(circ_cont(&cp) == false) break;
 8019c6a:	bf00      	nop
        }
        if(i != 4) break;
 8019c6c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019c6e:	2b04      	cmp	r3, #4
 8019c70:	f040 813e 	bne.w	8019ef0 <circ_calc_aa4+0x3c6>

        /*All lines on the same x when downscaled*/
        if(x_int[0] == x_int[3]) {
 8019c74:	69fa      	ldr	r2, [r7, #28]
 8019c76:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8019c78:	429a      	cmp	r2, r3
 8019c7a:	d12f      	bne.n	8019cdc <circ_calc_aa4+0x1b2>
            cir_x[cir_size] = x_int[0];
 8019c7c:	69f9      	ldr	r1, [r7, #28]
 8019c7e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019c80:	009b      	lsls	r3, r3, #2
 8019c82:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019c84:	4413      	add	r3, r2
 8019c86:	460a      	mov	r2, r1
 8019c88:	601a      	str	r2, [r3, #0]
            cir_y[cir_size] = y_8th_cnt;
 8019c8a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019c8c:	009b      	lsls	r3, r3, #2
 8019c8e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8019c90:	4413      	add	r3, r2
 8019c92:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8019c94:	601a      	str	r2, [r3, #0]
            c->cir_opa[cir_size] = x_fract[0] + x_fract[1] + x_fract[2] + x_fract[3];
 8019c96:	68fb      	ldr	r3, [r7, #12]
 8019c98:	b2da      	uxtb	r2, r3
 8019c9a:	693b      	ldr	r3, [r7, #16]
 8019c9c:	b2db      	uxtb	r3, r3
 8019c9e:	4413      	add	r3, r2
 8019ca0:	b2da      	uxtb	r2, r3
 8019ca2:	697b      	ldr	r3, [r7, #20]
 8019ca4:	b2db      	uxtb	r3, r3
 8019ca6:	4413      	add	r3, r2
 8019ca8:	b2d9      	uxtb	r1, r3
 8019caa:	69bb      	ldr	r3, [r7, #24]
 8019cac:	b2da      	uxtb	r2, r3
 8019cae:	687b      	ldr	r3, [r7, #4]
 8019cb0:	6858      	ldr	r0, [r3, #4]
 8019cb2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019cb4:	4403      	add	r3, r0
 8019cb6:	440a      	add	r2, r1
 8019cb8:	b2d2      	uxtb	r2, r2
 8019cba:	701a      	strb	r2, [r3, #0]
            c->cir_opa[cir_size] *= 16;
 8019cbc:	687b      	ldr	r3, [r7, #4]
 8019cbe:	685a      	ldr	r2, [r3, #4]
 8019cc0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019cc2:	4413      	add	r3, r2
 8019cc4:	781a      	ldrb	r2, [r3, #0]
 8019cc6:	687b      	ldr	r3, [r7, #4]
 8019cc8:	6859      	ldr	r1, [r3, #4]
 8019cca:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019ccc:	440b      	add	r3, r1
 8019cce:	0112      	lsls	r2, r2, #4
 8019cd0:	b2d2      	uxtb	r2, r2
 8019cd2:	701a      	strb	r2, [r3, #0]
            cir_size++;
 8019cd4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019cd6:	3301      	adds	r3, #1
 8019cd8:	657b      	str	r3, [r7, #84]	@ 0x54
 8019cda:	e0fc      	b.n	8019ed6 <circ_calc_aa4+0x3ac>
        }
        /*Second line on new x when downscaled*/
        else if(x_int[0] != x_int[1]) {
 8019cdc:	69fa      	ldr	r2, [r7, #28]
 8019cde:	6a3b      	ldr	r3, [r7, #32]
 8019ce0:	429a      	cmp	r2, r3
 8019ce2:	d051      	beq.n	8019d88 <circ_calc_aa4+0x25e>
            cir_x[cir_size] = x_int[0];
 8019ce4:	69f9      	ldr	r1, [r7, #28]
 8019ce6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019ce8:	009b      	lsls	r3, r3, #2
 8019cea:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019cec:	4413      	add	r3, r2
 8019cee:	460a      	mov	r2, r1
 8019cf0:	601a      	str	r2, [r3, #0]
            cir_y[cir_size] = y_8th_cnt;
 8019cf2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019cf4:	009b      	lsls	r3, r3, #2
 8019cf6:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8019cf8:	4413      	add	r3, r2
 8019cfa:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8019cfc:	601a      	str	r2, [r3, #0]
            c->cir_opa[cir_size] = x_fract[0];
 8019cfe:	68f9      	ldr	r1, [r7, #12]
 8019d00:	687b      	ldr	r3, [r7, #4]
 8019d02:	685a      	ldr	r2, [r3, #4]
 8019d04:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019d06:	4413      	add	r3, r2
 8019d08:	b2ca      	uxtb	r2, r1
 8019d0a:	701a      	strb	r2, [r3, #0]
            c->cir_opa[cir_size] *= 16;
 8019d0c:	687b      	ldr	r3, [r7, #4]
 8019d0e:	685a      	ldr	r2, [r3, #4]
 8019d10:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019d12:	4413      	add	r3, r2
 8019d14:	781a      	ldrb	r2, [r3, #0]
 8019d16:	687b      	ldr	r3, [r7, #4]
 8019d18:	6859      	ldr	r1, [r3, #4]
 8019d1a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019d1c:	440b      	add	r3, r1
 8019d1e:	0112      	lsls	r2, r2, #4
 8019d20:	b2d2      	uxtb	r2, r2
 8019d22:	701a      	strb	r2, [r3, #0]
            cir_size++;
 8019d24:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019d26:	3301      	adds	r3, #1
 8019d28:	657b      	str	r3, [r7, #84]	@ 0x54

            cir_x[cir_size] = x_int[0] - 1;
 8019d2a:	69fb      	ldr	r3, [r7, #28]
 8019d2c:	1e59      	subs	r1, r3, #1
 8019d2e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019d30:	009b      	lsls	r3, r3, #2
 8019d32:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019d34:	4413      	add	r3, r2
 8019d36:	460a      	mov	r2, r1
 8019d38:	601a      	str	r2, [r3, #0]
            cir_y[cir_size] = y_8th_cnt;
 8019d3a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019d3c:	009b      	lsls	r3, r3, #2
 8019d3e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8019d40:	4413      	add	r3, r2
 8019d42:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8019d44:	601a      	str	r2, [r3, #0]
            c->cir_opa[cir_size] = 1 * 4 + x_fract[1] + x_fract[2] + x_fract[3];;
 8019d46:	693b      	ldr	r3, [r7, #16]
 8019d48:	b2da      	uxtb	r2, r3
 8019d4a:	697b      	ldr	r3, [r7, #20]
 8019d4c:	b2db      	uxtb	r3, r3
 8019d4e:	4413      	add	r3, r2
 8019d50:	b2da      	uxtb	r2, r3
 8019d52:	69bb      	ldr	r3, [r7, #24]
 8019d54:	b2db      	uxtb	r3, r3
 8019d56:	4413      	add	r3, r2
 8019d58:	b2da      	uxtb	r2, r3
 8019d5a:	687b      	ldr	r3, [r7, #4]
 8019d5c:	6859      	ldr	r1, [r3, #4]
 8019d5e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019d60:	440b      	add	r3, r1
 8019d62:	3204      	adds	r2, #4
 8019d64:	b2d2      	uxtb	r2, r2
 8019d66:	701a      	strb	r2, [r3, #0]
            c->cir_opa[cir_size] *= 16;
 8019d68:	687b      	ldr	r3, [r7, #4]
 8019d6a:	685a      	ldr	r2, [r3, #4]
 8019d6c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019d6e:	4413      	add	r3, r2
 8019d70:	781a      	ldrb	r2, [r3, #0]
 8019d72:	687b      	ldr	r3, [r7, #4]
 8019d74:	6859      	ldr	r1, [r3, #4]
 8019d76:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019d78:	440b      	add	r3, r1
 8019d7a:	0112      	lsls	r2, r2, #4
 8019d7c:	b2d2      	uxtb	r2, r2
 8019d7e:	701a      	strb	r2, [r3, #0]
            cir_size++;
 8019d80:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019d82:	3301      	adds	r3, #1
 8019d84:	657b      	str	r3, [r7, #84]	@ 0x54
 8019d86:	e0a6      	b.n	8019ed6 <circ_calc_aa4+0x3ac>
        }
        /*Third line on new x when downscaled*/
        else if(x_int[0] != x_int[2]) {
 8019d88:	69fa      	ldr	r2, [r7, #28]
 8019d8a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8019d8c:	429a      	cmp	r2, r3
 8019d8e:	d051      	beq.n	8019e34 <circ_calc_aa4+0x30a>
            cir_x[cir_size] = x_int[0];
 8019d90:	69f9      	ldr	r1, [r7, #28]
 8019d92:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019d94:	009b      	lsls	r3, r3, #2
 8019d96:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019d98:	4413      	add	r3, r2
 8019d9a:	460a      	mov	r2, r1
 8019d9c:	601a      	str	r2, [r3, #0]
            cir_y[cir_size] = y_8th_cnt;
 8019d9e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019da0:	009b      	lsls	r3, r3, #2
 8019da2:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8019da4:	4413      	add	r3, r2
 8019da6:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8019da8:	601a      	str	r2, [r3, #0]
            c->cir_opa[cir_size] = x_fract[0] + x_fract[1];
 8019daa:	68fb      	ldr	r3, [r7, #12]
 8019dac:	b2d9      	uxtb	r1, r3
 8019dae:	693b      	ldr	r3, [r7, #16]
 8019db0:	b2da      	uxtb	r2, r3
 8019db2:	687b      	ldr	r3, [r7, #4]
 8019db4:	6858      	ldr	r0, [r3, #4]
 8019db6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019db8:	4403      	add	r3, r0
 8019dba:	440a      	add	r2, r1
 8019dbc:	b2d2      	uxtb	r2, r2
 8019dbe:	701a      	strb	r2, [r3, #0]
            c->cir_opa[cir_size] *= 16;
 8019dc0:	687b      	ldr	r3, [r7, #4]
 8019dc2:	685a      	ldr	r2, [r3, #4]
 8019dc4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019dc6:	4413      	add	r3, r2
 8019dc8:	781a      	ldrb	r2, [r3, #0]
 8019dca:	687b      	ldr	r3, [r7, #4]
 8019dcc:	6859      	ldr	r1, [r3, #4]
 8019dce:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019dd0:	440b      	add	r3, r1
 8019dd2:	0112      	lsls	r2, r2, #4
 8019dd4:	b2d2      	uxtb	r2, r2
 8019dd6:	701a      	strb	r2, [r3, #0]
            cir_size++;
 8019dd8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019dda:	3301      	adds	r3, #1
 8019ddc:	657b      	str	r3, [r7, #84]	@ 0x54

            cir_x[cir_size] = x_int[0] - 1;
 8019dde:	69fb      	ldr	r3, [r7, #28]
 8019de0:	1e59      	subs	r1, r3, #1
 8019de2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019de4:	009b      	lsls	r3, r3, #2
 8019de6:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019de8:	4413      	add	r3, r2
 8019dea:	460a      	mov	r2, r1
 8019dec:	601a      	str	r2, [r3, #0]
            cir_y[cir_size] = y_8th_cnt;
 8019dee:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019df0:	009b      	lsls	r3, r3, #2
 8019df2:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8019df4:	4413      	add	r3, r2
 8019df6:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8019df8:	601a      	str	r2, [r3, #0]
            c->cir_opa[cir_size] = 2 * 4 + x_fract[2] + x_fract[3];;
 8019dfa:	697b      	ldr	r3, [r7, #20]
 8019dfc:	b2da      	uxtb	r2, r3
 8019dfe:	69bb      	ldr	r3, [r7, #24]
 8019e00:	b2db      	uxtb	r3, r3
 8019e02:	4413      	add	r3, r2
 8019e04:	b2da      	uxtb	r2, r3
 8019e06:	687b      	ldr	r3, [r7, #4]
 8019e08:	6859      	ldr	r1, [r3, #4]
 8019e0a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019e0c:	440b      	add	r3, r1
 8019e0e:	3208      	adds	r2, #8
 8019e10:	b2d2      	uxtb	r2, r2
 8019e12:	701a      	strb	r2, [r3, #0]
            c->cir_opa[cir_size] *= 16;
 8019e14:	687b      	ldr	r3, [r7, #4]
 8019e16:	685a      	ldr	r2, [r3, #4]
 8019e18:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019e1a:	4413      	add	r3, r2
 8019e1c:	781a      	ldrb	r2, [r3, #0]
 8019e1e:	687b      	ldr	r3, [r7, #4]
 8019e20:	6859      	ldr	r1, [r3, #4]
 8019e22:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019e24:	440b      	add	r3, r1
 8019e26:	0112      	lsls	r2, r2, #4
 8019e28:	b2d2      	uxtb	r2, r2
 8019e2a:	701a      	strb	r2, [r3, #0]
            cir_size++;
 8019e2c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019e2e:	3301      	adds	r3, #1
 8019e30:	657b      	str	r3, [r7, #84]	@ 0x54
 8019e32:	e050      	b.n	8019ed6 <circ_calc_aa4+0x3ac>
        }
        /*Forth line on new x when downscaled*/
        else {
            cir_x[cir_size] = x_int[0];
 8019e34:	69f9      	ldr	r1, [r7, #28]
 8019e36:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019e38:	009b      	lsls	r3, r3, #2
 8019e3a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019e3c:	4413      	add	r3, r2
 8019e3e:	460a      	mov	r2, r1
 8019e40:	601a      	str	r2, [r3, #0]
            cir_y[cir_size] = y_8th_cnt;
 8019e42:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019e44:	009b      	lsls	r3, r3, #2
 8019e46:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8019e48:	4413      	add	r3, r2
 8019e4a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8019e4c:	601a      	str	r2, [r3, #0]
            c->cir_opa[cir_size] = x_fract[0] + x_fract[1] + x_fract[2];
 8019e4e:	68fb      	ldr	r3, [r7, #12]
 8019e50:	b2da      	uxtb	r2, r3
 8019e52:	693b      	ldr	r3, [r7, #16]
 8019e54:	b2db      	uxtb	r3, r3
 8019e56:	4413      	add	r3, r2
 8019e58:	b2d9      	uxtb	r1, r3
 8019e5a:	697b      	ldr	r3, [r7, #20]
 8019e5c:	b2da      	uxtb	r2, r3
 8019e5e:	687b      	ldr	r3, [r7, #4]
 8019e60:	6858      	ldr	r0, [r3, #4]
 8019e62:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019e64:	4403      	add	r3, r0
 8019e66:	440a      	add	r2, r1
 8019e68:	b2d2      	uxtb	r2, r2
 8019e6a:	701a      	strb	r2, [r3, #0]
            c->cir_opa[cir_size] *= 16;
 8019e6c:	687b      	ldr	r3, [r7, #4]
 8019e6e:	685a      	ldr	r2, [r3, #4]
 8019e70:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019e72:	4413      	add	r3, r2
 8019e74:	781a      	ldrb	r2, [r3, #0]
 8019e76:	687b      	ldr	r3, [r7, #4]
 8019e78:	6859      	ldr	r1, [r3, #4]
 8019e7a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019e7c:	440b      	add	r3, r1
 8019e7e:	0112      	lsls	r2, r2, #4
 8019e80:	b2d2      	uxtb	r2, r2
 8019e82:	701a      	strb	r2, [r3, #0]
            cir_size++;
 8019e84:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019e86:	3301      	adds	r3, #1
 8019e88:	657b      	str	r3, [r7, #84]	@ 0x54

            cir_x[cir_size] = x_int[0] - 1;
 8019e8a:	69fb      	ldr	r3, [r7, #28]
 8019e8c:	1e59      	subs	r1, r3, #1
 8019e8e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019e90:	009b      	lsls	r3, r3, #2
 8019e92:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019e94:	4413      	add	r3, r2
 8019e96:	460a      	mov	r2, r1
 8019e98:	601a      	str	r2, [r3, #0]
            cir_y[cir_size] = y_8th_cnt;
 8019e9a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019e9c:	009b      	lsls	r3, r3, #2
 8019e9e:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8019ea0:	4413      	add	r3, r2
 8019ea2:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8019ea4:	601a      	str	r2, [r3, #0]
            c->cir_opa[cir_size] = 3 * 4 + x_fract[3];;
 8019ea6:	69bb      	ldr	r3, [r7, #24]
 8019ea8:	b2da      	uxtb	r2, r3
 8019eaa:	687b      	ldr	r3, [r7, #4]
 8019eac:	6859      	ldr	r1, [r3, #4]
 8019eae:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019eb0:	440b      	add	r3, r1
 8019eb2:	320c      	adds	r2, #12
 8019eb4:	b2d2      	uxtb	r2, r2
 8019eb6:	701a      	strb	r2, [r3, #0]
            c->cir_opa[cir_size] *= 16;
 8019eb8:	687b      	ldr	r3, [r7, #4]
 8019eba:	685a      	ldr	r2, [r3, #4]
 8019ebc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019ebe:	4413      	add	r3, r2
 8019ec0:	781a      	ldrb	r2, [r3, #0]
 8019ec2:	687b      	ldr	r3, [r7, #4]
 8019ec4:	6859      	ldr	r1, [r3, #4]
 8019ec6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019ec8:	440b      	add	r3, r1
 8019eca:	0112      	lsls	r2, r2, #4
 8019ecc:	b2d2      	uxtb	r2, r2
 8019ece:	701a      	strb	r2, [r3, #0]
            cir_size++;
 8019ed0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019ed2:	3301      	adds	r3, #1
 8019ed4:	657b      	str	r3, [r7, #84]	@ 0x54
        }

        y_8th_cnt++;
 8019ed6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8019ed8:	3301      	adds	r3, #1
 8019eda:	65fb      	str	r3, [r7, #92]	@ 0x5c
    while(circ_cont(&cp)) {
 8019edc:	f107 0330 	add.w	r3, r7, #48	@ 0x30
 8019ee0:	4618      	mov	r0, r3
 8019ee2:	f7ff fde0 	bl	8019aa6 <circ_cont>
 8019ee6:	4603      	mov	r3, r0
 8019ee8:	2b00      	cmp	r3, #0
 8019eea:	f47f ae8f 	bne.w	8019c0c <circ_calc_aa4+0xe2>
 8019eee:	e000      	b.n	8019ef2 <circ_calc_aa4+0x3c8>
        if(i != 4) break;
 8019ef0:	bf00      	nop
    }

    /*The point on the 1/8 circle is special, calculate it manually*/
    int32_t mid = radius * 723;
 8019ef2:	683b      	ldr	r3, [r7, #0]
 8019ef4:	f240 22d3 	movw	r2, #723	@ 0x2d3
 8019ef8:	fb02 f303 	mul.w	r3, r2, r3
 8019efc:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int32_t mid_int = mid >> 10;
 8019efe:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8019f00:	129b      	asrs	r3, r3, #10
 8019f02:	63bb      	str	r3, [r7, #56]	@ 0x38
    if(cir_x[cir_size - 1] != mid_int || cir_y[cir_size - 1] != mid_int) {
 8019f04:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019f06:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8019f0a:	3b01      	subs	r3, #1
 8019f0c:	009b      	lsls	r3, r3, #2
 8019f0e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019f10:	4413      	add	r3, r2
 8019f12:	681b      	ldr	r3, [r3, #0]
 8019f14:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8019f16:	429a      	cmp	r2, r3
 8019f18:	d10a      	bne.n	8019f30 <circ_calc_aa4+0x406>
 8019f1a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019f1c:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8019f20:	3b01      	subs	r3, #1
 8019f22:	009b      	lsls	r3, r3, #2
 8019f24:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8019f26:	4413      	add	r3, r2
 8019f28:	681b      	ldr	r3, [r3, #0]
 8019f2a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8019f2c:	429a      	cmp	r2, r3
 8019f2e:	d043      	beq.n	8019fb8 <circ_calc_aa4+0x48e>
        int32_t tmp_val = mid - (mid_int << 10);
 8019f30:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8019f32:	029b      	lsls	r3, r3, #10
 8019f34:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8019f36:	1ad3      	subs	r3, r2, r3
 8019f38:	653b      	str	r3, [r7, #80]	@ 0x50
        if(tmp_val <= 512) {
 8019f3a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8019f3c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8019f40:	dc08      	bgt.n	8019f54 <circ_calc_aa4+0x42a>
            tmp_val = tmp_val * tmp_val * 2;
 8019f42:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8019f44:	fb03 f303 	mul.w	r3, r3, r3
 8019f48:	005b      	lsls	r3, r3, #1
 8019f4a:	653b      	str	r3, [r7, #80]	@ 0x50
            tmp_val = tmp_val >> (10 + 6);
 8019f4c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8019f4e:	141b      	asrs	r3, r3, #16
 8019f50:	653b      	str	r3, [r7, #80]	@ 0x50
 8019f52:	e00f      	b.n	8019f74 <circ_calc_aa4+0x44a>
        }
        else {
            tmp_val = 1024 - tmp_val;
 8019f54:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8019f56:	f5c3 6380 	rsb	r3, r3, #1024	@ 0x400
 8019f5a:	653b      	str	r3, [r7, #80]	@ 0x50
            tmp_val = tmp_val * tmp_val * 2;
 8019f5c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8019f5e:	fb03 f303 	mul.w	r3, r3, r3
 8019f62:	005b      	lsls	r3, r3, #1
 8019f64:	653b      	str	r3, [r7, #80]	@ 0x50
            tmp_val = tmp_val >> (10 + 6);
 8019f66:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8019f68:	141b      	asrs	r3, r3, #16
 8019f6a:	653b      	str	r3, [r7, #80]	@ 0x50
            tmp_val = 15 - tmp_val;
 8019f6c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8019f6e:	f1c3 030f 	rsb	r3, r3, #15
 8019f72:	653b      	str	r3, [r7, #80]	@ 0x50
        }

        cir_x[cir_size] = mid_int;
 8019f74:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019f76:	009b      	lsls	r3, r3, #2
 8019f78:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019f7a:	4413      	add	r3, r2
 8019f7c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8019f7e:	601a      	str	r2, [r3, #0]
        cir_y[cir_size] = mid_int;
 8019f80:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019f82:	009b      	lsls	r3, r3, #2
 8019f84:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8019f86:	4413      	add	r3, r2
 8019f88:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8019f8a:	601a      	str	r2, [r3, #0]
        c->cir_opa[cir_size] = tmp_val;
 8019f8c:	687b      	ldr	r3, [r7, #4]
 8019f8e:	685a      	ldr	r2, [r3, #4]
 8019f90:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019f92:	4413      	add	r3, r2
 8019f94:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8019f96:	b2d2      	uxtb	r2, r2
 8019f98:	701a      	strb	r2, [r3, #0]
        c->cir_opa[cir_size] *= 16;
 8019f9a:	687b      	ldr	r3, [r7, #4]
 8019f9c:	685a      	ldr	r2, [r3, #4]
 8019f9e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019fa0:	4413      	add	r3, r2
 8019fa2:	781a      	ldrb	r2, [r3, #0]
 8019fa4:	687b      	ldr	r3, [r7, #4]
 8019fa6:	6859      	ldr	r1, [r3, #4]
 8019fa8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019faa:	440b      	add	r3, r1
 8019fac:	0112      	lsls	r2, r2, #4
 8019fae:	b2d2      	uxtb	r2, r2
 8019fb0:	701a      	strb	r2, [r3, #0]
        cir_size++;
 8019fb2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019fb4:	3301      	adds	r3, #1
 8019fb6:	657b      	str	r3, [r7, #84]	@ 0x54
    }

    /*Build the second octet by mirroring the first*/
    for(i = cir_size - 2; i >= 0; i--, cir_size++) {
 8019fb8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019fba:	3b02      	subs	r3, #2
 8019fbc:	65bb      	str	r3, [r7, #88]	@ 0x58
 8019fbe:	e023      	b.n	801a008 <circ_calc_aa4+0x4de>
        cir_x[cir_size] = cir_y[i];
 8019fc0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019fc2:	009b      	lsls	r3, r3, #2
 8019fc4:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8019fc6:	441a      	add	r2, r3
 8019fc8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019fca:	009b      	lsls	r3, r3, #2
 8019fcc:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 8019fce:	440b      	add	r3, r1
 8019fd0:	6812      	ldr	r2, [r2, #0]
 8019fd2:	601a      	str	r2, [r3, #0]
        cir_y[cir_size] = cir_x[i];
 8019fd4:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019fd6:	009b      	lsls	r3, r3, #2
 8019fd8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8019fda:	441a      	add	r2, r3
 8019fdc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019fde:	009b      	lsls	r3, r3, #2
 8019fe0:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 8019fe2:	440b      	add	r3, r1
 8019fe4:	6812      	ldr	r2, [r2, #0]
 8019fe6:	601a      	str	r2, [r3, #0]
        c->cir_opa[cir_size] = c->cir_opa[i];
 8019fe8:	687b      	ldr	r3, [r7, #4]
 8019fea:	685a      	ldr	r2, [r3, #4]
 8019fec:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019fee:	441a      	add	r2, r3
 8019ff0:	687b      	ldr	r3, [r7, #4]
 8019ff2:	6859      	ldr	r1, [r3, #4]
 8019ff4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 8019ff6:	440b      	add	r3, r1
 8019ff8:	7812      	ldrb	r2, [r2, #0]
 8019ffa:	701a      	strb	r2, [r3, #0]
    for(i = cir_size - 2; i >= 0; i--, cir_size++) {
 8019ffc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8019ffe:	3b01      	subs	r3, #1
 801a000:	65bb      	str	r3, [r7, #88]	@ 0x58
 801a002:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801a004:	3301      	adds	r3, #1
 801a006:	657b      	str	r3, [r7, #84]	@ 0x54
 801a008:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801a00a:	2b00      	cmp	r3, #0
 801a00c:	dad8      	bge.n	8019fc0 <circ_calc_aa4+0x496>
    }

    int32_t y = 0;
 801a00e:	2300      	movs	r3, #0
 801a010:	64fb      	str	r3, [r7, #76]	@ 0x4c
    i = 0;
 801a012:	2300      	movs	r3, #0
 801a014:	65bb      	str	r3, [r7, #88]	@ 0x58
    c->opa_start_on_y[0] = 0;
 801a016:	687b      	ldr	r3, [r7, #4]
 801a018:	68db      	ldr	r3, [r3, #12]
 801a01a:	2200      	movs	r2, #0
 801a01c:	801a      	strh	r2, [r3, #0]
    while(i < cir_size) {
 801a01e:	e03c      	b.n	801a09a <circ_calc_aa4+0x570>
        c->opa_start_on_y[y] = i;
 801a020:	687b      	ldr	r3, [r7, #4]
 801a022:	68da      	ldr	r2, [r3, #12]
 801a024:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801a026:	005b      	lsls	r3, r3, #1
 801a028:	4413      	add	r3, r2
 801a02a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801a02c:	b292      	uxth	r2, r2
 801a02e:	801a      	strh	r2, [r3, #0]
        c->x_start_on_y[y] = cir_x[i];
 801a030:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801a032:	009b      	lsls	r3, r3, #2
 801a034:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801a036:	4413      	add	r3, r2
 801a038:	6819      	ldr	r1, [r3, #0]
 801a03a:	687b      	ldr	r3, [r7, #4]
 801a03c:	689a      	ldr	r2, [r3, #8]
 801a03e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801a040:	005b      	lsls	r3, r3, #1
 801a042:	4413      	add	r3, r2
 801a044:	b28a      	uxth	r2, r1
 801a046:	801a      	strh	r2, [r3, #0]
        for(; cir_y[i] == y && i < (int32_t)cir_size; i++) {
 801a048:	e018      	b.n	801a07c <circ_calc_aa4+0x552>
            c->x_start_on_y[y] = LV_MIN(c->x_start_on_y[y], cir_x[i]);
 801a04a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801a04c:	009b      	lsls	r3, r3, #2
 801a04e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801a050:	4413      	add	r3, r2
 801a052:	681b      	ldr	r3, [r3, #0]
 801a054:	687a      	ldr	r2, [r7, #4]
 801a056:	6891      	ldr	r1, [r2, #8]
 801a058:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801a05a:	0052      	lsls	r2, r2, #1
 801a05c:	440a      	add	r2, r1
 801a05e:	8812      	ldrh	r2, [r2, #0]
 801a060:	4293      	cmp	r3, r2
 801a062:	bfa8      	it	ge
 801a064:	4613      	movge	r3, r2
 801a066:	4619      	mov	r1, r3
 801a068:	687b      	ldr	r3, [r7, #4]
 801a06a:	689a      	ldr	r2, [r3, #8]
 801a06c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801a06e:	005b      	lsls	r3, r3, #1
 801a070:	4413      	add	r3, r2
 801a072:	b28a      	uxth	r2, r1
 801a074:	801a      	strh	r2, [r3, #0]
        for(; cir_y[i] == y && i < (int32_t)cir_size; i++) {
 801a076:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801a078:	3301      	adds	r3, #1
 801a07a:	65bb      	str	r3, [r7, #88]	@ 0x58
 801a07c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801a07e:	009b      	lsls	r3, r3, #2
 801a080:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801a082:	4413      	add	r3, r2
 801a084:	681b      	ldr	r3, [r3, #0]
 801a086:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801a088:	429a      	cmp	r2, r3
 801a08a:	d103      	bne.n	801a094 <circ_calc_aa4+0x56a>
 801a08c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801a08e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801a090:	429a      	cmp	r2, r3
 801a092:	dbda      	blt.n	801a04a <circ_calc_aa4+0x520>
        }
        y++;
 801a094:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801a096:	3301      	adds	r3, #1
 801a098:	64fb      	str	r3, [r7, #76]	@ 0x4c
    while(i < cir_size) {
 801a09a:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801a09c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801a09e:	429a      	cmp	r2, r3
 801a0a0:	dbbe      	blt.n	801a020 <circ_calc_aa4+0x4f6>
    }

    lv_free(cir_x);
 801a0a2:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 801a0a4:	f00b fec8 	bl	8025e38 <lv_free>
 801a0a8:	e000      	b.n	801a0ac <circ_calc_aa4+0x582>
    if(radius == 0) return;
 801a0aa:	bf00      	nop
}
 801a0ac:	3760      	adds	r7, #96	@ 0x60
 801a0ae:	46bd      	mov	sp, r7
 801a0b0:	bd80      	pop	{r7, pc}

0801a0b2 <get_next_line>:

static lv_opa_t * get_next_line(_lv_draw_sw_mask_radius_circle_dsc_t * c, int32_t y, int32_t * len,
                                int32_t * x_start)
{
 801a0b2:	b480      	push	{r7}
 801a0b4:	b085      	sub	sp, #20
 801a0b6:	af00      	add	r7, sp, #0
 801a0b8:	60f8      	str	r0, [r7, #12]
 801a0ba:	60b9      	str	r1, [r7, #8]
 801a0bc:	607a      	str	r2, [r7, #4]
 801a0be:	603b      	str	r3, [r7, #0]
    *len = c->opa_start_on_y[y + 1] - c->opa_start_on_y[y];
 801a0c0:	68fb      	ldr	r3, [r7, #12]
 801a0c2:	68da      	ldr	r2, [r3, #12]
 801a0c4:	68bb      	ldr	r3, [r7, #8]
 801a0c6:	3301      	adds	r3, #1
 801a0c8:	005b      	lsls	r3, r3, #1
 801a0ca:	4413      	add	r3, r2
 801a0cc:	881b      	ldrh	r3, [r3, #0]
 801a0ce:	4619      	mov	r1, r3
 801a0d0:	68fb      	ldr	r3, [r7, #12]
 801a0d2:	68da      	ldr	r2, [r3, #12]
 801a0d4:	68bb      	ldr	r3, [r7, #8]
 801a0d6:	005b      	lsls	r3, r3, #1
 801a0d8:	4413      	add	r3, r2
 801a0da:	881b      	ldrh	r3, [r3, #0]
 801a0dc:	1aca      	subs	r2, r1, r3
 801a0de:	687b      	ldr	r3, [r7, #4]
 801a0e0:	601a      	str	r2, [r3, #0]
    *x_start = c->x_start_on_y[y];
 801a0e2:	68fb      	ldr	r3, [r7, #12]
 801a0e4:	689a      	ldr	r2, [r3, #8]
 801a0e6:	68bb      	ldr	r3, [r7, #8]
 801a0e8:	005b      	lsls	r3, r3, #1
 801a0ea:	4413      	add	r3, r2
 801a0ec:	881b      	ldrh	r3, [r3, #0]
 801a0ee:	461a      	mov	r2, r3
 801a0f0:	683b      	ldr	r3, [r7, #0]
 801a0f2:	601a      	str	r2, [r3, #0]
    return &c->cir_opa[c->opa_start_on_y[y]];
 801a0f4:	68fb      	ldr	r3, [r7, #12]
 801a0f6:	685b      	ldr	r3, [r3, #4]
 801a0f8:	68fa      	ldr	r2, [r7, #12]
 801a0fa:	68d1      	ldr	r1, [r2, #12]
 801a0fc:	68ba      	ldr	r2, [r7, #8]
 801a0fe:	0052      	lsls	r2, r2, #1
 801a100:	440a      	add	r2, r1
 801a102:	8812      	ldrh	r2, [r2, #0]
 801a104:	4413      	add	r3, r2
}
 801a106:	4618      	mov	r0, r3
 801a108:	3714      	adds	r7, #20
 801a10a:	46bd      	mov	sp, r7
 801a10c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a110:	4770      	bx	lr

0801a112 <mask_mix>:

static inline lv_opa_t LV_ATTRIBUTE_FAST_MEM mask_mix(lv_opa_t mask_act, lv_opa_t mask_new)
{
 801a112:	b480      	push	{r7}
 801a114:	b083      	sub	sp, #12
 801a116:	af00      	add	r7, sp, #0
 801a118:	4603      	mov	r3, r0
 801a11a:	460a      	mov	r2, r1
 801a11c:	71fb      	strb	r3, [r7, #7]
 801a11e:	4613      	mov	r3, r2
 801a120:	71bb      	strb	r3, [r7, #6]
    if(mask_new >= LV_OPA_MAX) return mask_act;
 801a122:	79bb      	ldrb	r3, [r7, #6]
 801a124:	2bfc      	cmp	r3, #252	@ 0xfc
 801a126:	d901      	bls.n	801a12c <mask_mix+0x1a>
 801a128:	79fb      	ldrb	r3, [r7, #7]
 801a12a:	e010      	b.n	801a14e <mask_mix+0x3c>
    if(mask_new <= LV_OPA_MIN) return 0;
 801a12c:	79bb      	ldrb	r3, [r7, #6]
 801a12e:	2b02      	cmp	r3, #2
 801a130:	d801      	bhi.n	801a136 <mask_mix+0x24>
 801a132:	2300      	movs	r3, #0
 801a134:	e00b      	b.n	801a14e <mask_mix+0x3c>

    return LV_UDIV255(mask_act * mask_new);
 801a136:	79fb      	ldrb	r3, [r7, #7]
 801a138:	79ba      	ldrb	r2, [r7, #6]
 801a13a:	fb02 f303 	mul.w	r3, r2, r3
 801a13e:	461a      	mov	r2, r3
 801a140:	4613      	mov	r3, r2
 801a142:	021b      	lsls	r3, r3, #8
 801a144:	4413      	add	r3, r2
 801a146:	01db      	lsls	r3, r3, #7
 801a148:	4413      	add	r3, r2
 801a14a:	0ddb      	lsrs	r3, r3, #23
 801a14c:	b2db      	uxtb	r3, r3
}
 801a14e:	4618      	mov	r0, r3
 801a150:	370c      	adds	r7, #12
 801a152:	46bd      	mov	sp, r7
 801a154:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a158:	4770      	bx	lr

0801a15a <lv_area_get_width>:
{
 801a15a:	b480      	push	{r7}
 801a15c:	b083      	sub	sp, #12
 801a15e:	af00      	add	r7, sp, #0
 801a160:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 801a162:	687b      	ldr	r3, [r7, #4]
 801a164:	689a      	ldr	r2, [r3, #8]
 801a166:	687b      	ldr	r3, [r7, #4]
 801a168:	681b      	ldr	r3, [r3, #0]
 801a16a:	1ad3      	subs	r3, r2, r3
 801a16c:	3301      	adds	r3, #1
}
 801a16e:	4618      	mov	r0, r3
 801a170:	370c      	adds	r7, #12
 801a172:	46bd      	mov	sp, r7
 801a174:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a178:	4770      	bx	lr

0801a17a <lv_memzero>:
{
 801a17a:	b580      	push	{r7, lr}
 801a17c:	b082      	sub	sp, #8
 801a17e:	af00      	add	r7, sp, #0
 801a180:	6078      	str	r0, [r7, #4]
 801a182:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 801a184:	683a      	ldr	r2, [r7, #0]
 801a186:	2100      	movs	r1, #0
 801a188:	6878      	ldr	r0, [r7, #4]
 801a18a:	f00a fe4a 	bl	8024e22 <lv_memset>
}
 801a18e:	bf00      	nop
 801a190:	3708      	adds	r7, #8
 801a192:	46bd      	mov	sp, r7
 801a194:	bd80      	pop	{r7, pc}

0801a196 <lv_draw_sw_mask_rect>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_sw_mask_rect(lv_draw_unit_t * draw_unit, const lv_draw_mask_rect_dsc_t * dsc, const lv_area_t * coords)
{
 801a196:	b590      	push	{r4, r7, lr}
 801a198:	b0a3      	sub	sp, #140	@ 0x8c
 801a19a:	af02      	add	r7, sp, #8
 801a19c:	60f8      	str	r0, [r7, #12]
 801a19e:	60b9      	str	r1, [r7, #8]
 801a1a0:	607a      	str	r2, [r7, #4]
    LV_UNUSED(coords);

    lv_area_t draw_area;
    if(!_lv_area_intersect(&draw_area, &dsc->area, draw_unit->clip_area)) {
 801a1a2:	68bb      	ldr	r3, [r7, #8]
 801a1a4:	f103 011c 	add.w	r1, r3, #28
 801a1a8:	68fb      	ldr	r3, [r7, #12]
 801a1aa:	689a      	ldr	r2, [r3, #8]
 801a1ac:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
 801a1b0:	4618      	mov	r0, r3
 801a1b2:	f007 fbc9 	bl	8021948 <_lv_area_intersect>
 801a1b6:	4603      	mov	r3, r0
 801a1b8:	f083 0301 	eor.w	r3, r3, #1
 801a1bc:	b2db      	uxtb	r3, r3
 801a1be:	2b00      	cmp	r3, #0
 801a1c0:	f040 8113 	bne.w	801a3ea <lv_draw_sw_mask_rect+0x254>
        return;
    }

    lv_layer_t * target_layer = draw_unit->target_layer;
 801a1c4:	68fb      	ldr	r3, [r7, #12]
 801a1c6:	685b      	ldr	r3, [r3, #4]
 801a1c8:	677b      	str	r3, [r7, #116]	@ 0x74
    lv_area_t * buf_area = &target_layer->buf_area;
 801a1ca:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801a1cc:	3304      	adds	r3, #4
 801a1ce:	673b      	str	r3, [r7, #112]	@ 0x70
    lv_area_t clear_area;

    void * draw_buf = target_layer->draw_buf;
 801a1d0:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801a1d2:	681b      	ldr	r3, [r3, #0]
 801a1d4:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /*Clear the top part*/
    lv_area_set(&clear_area, draw_unit->clip_area->x1, draw_unit->clip_area->y1, draw_unit->clip_area->x2,
 801a1d6:	68fb      	ldr	r3, [r7, #12]
 801a1d8:	689b      	ldr	r3, [r3, #8]
 801a1da:	6819      	ldr	r1, [r3, #0]
 801a1dc:	68fb      	ldr	r3, [r7, #12]
 801a1de:	689b      	ldr	r3, [r3, #8]
 801a1e0:	685a      	ldr	r2, [r3, #4]
 801a1e2:	68fb      	ldr	r3, [r7, #12]
 801a1e4:	689b      	ldr	r3, [r3, #8]
 801a1e6:	689c      	ldr	r4, [r3, #8]
                dsc->area.y1 - 1);
 801a1e8:	68bb      	ldr	r3, [r7, #8]
 801a1ea:	6a1b      	ldr	r3, [r3, #32]
    lv_area_set(&clear_area, draw_unit->clip_area->x1, draw_unit->clip_area->y1, draw_unit->clip_area->x2,
 801a1ec:	3b01      	subs	r3, #1
 801a1ee:	f107 003c 	add.w	r0, r7, #60	@ 0x3c
 801a1f2:	9300      	str	r3, [sp, #0]
 801a1f4:	4623      	mov	r3, r4
 801a1f6:	f007 fb07 	bl	8021808 <lv_area_set>
    lv_area_move(&clear_area, -buf_area->x1, -buf_area->y1);
 801a1fa:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801a1fc:	681b      	ldr	r3, [r3, #0]
 801a1fe:	4259      	negs	r1, r3
 801a200:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801a202:	685b      	ldr	r3, [r3, #4]
 801a204:	425a      	negs	r2, r3
 801a206:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801a20a:	4618      	mov	r0, r3
 801a20c:	f007 fb78 	bl	8021900 <lv_area_move>
    lv_draw_buf_clear(draw_buf, &clear_area);
 801a210:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801a214:	4619      	mov	r1, r3
 801a216:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801a218:	f7f1 fd0c 	bl	800bc34 <lv_draw_buf_clear>

    /*Clear the bottom part*/
    lv_area_set(&clear_area, draw_unit->clip_area->x1, dsc->area.y2 + 1, draw_unit->clip_area->x2,
 801a21c:	68fb      	ldr	r3, [r7, #12]
 801a21e:	689b      	ldr	r3, [r3, #8]
 801a220:	6819      	ldr	r1, [r3, #0]
 801a222:	68bb      	ldr	r3, [r7, #8]
 801a224:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801a226:	1c5a      	adds	r2, r3, #1
 801a228:	68fb      	ldr	r3, [r7, #12]
 801a22a:	689b      	ldr	r3, [r3, #8]
 801a22c:	689c      	ldr	r4, [r3, #8]
                draw_unit->clip_area->y2);
 801a22e:	68fb      	ldr	r3, [r7, #12]
 801a230:	689b      	ldr	r3, [r3, #8]
 801a232:	68db      	ldr	r3, [r3, #12]
    lv_area_set(&clear_area, draw_unit->clip_area->x1, dsc->area.y2 + 1, draw_unit->clip_area->x2,
 801a234:	f107 003c 	add.w	r0, r7, #60	@ 0x3c
 801a238:	9300      	str	r3, [sp, #0]
 801a23a:	4623      	mov	r3, r4
 801a23c:	f007 fae4 	bl	8021808 <lv_area_set>
    lv_area_move(&clear_area, -buf_area->x1, -buf_area->y1);
 801a240:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801a242:	681b      	ldr	r3, [r3, #0]
 801a244:	4259      	negs	r1, r3
 801a246:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801a248:	685b      	ldr	r3, [r3, #4]
 801a24a:	425a      	negs	r2, r3
 801a24c:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801a250:	4618      	mov	r0, r3
 801a252:	f007 fb55 	bl	8021900 <lv_area_move>
    lv_draw_buf_clear(draw_buf, &clear_area);
 801a256:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801a25a:	4619      	mov	r1, r3
 801a25c:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801a25e:	f7f1 fce9 	bl	800bc34 <lv_draw_buf_clear>

    /*Clear the left part*/
    lv_area_set(&clear_area, draw_unit->clip_area->x1, dsc->area.y1, dsc->area.x1 - 1, dsc->area.y2);
 801a262:	68fb      	ldr	r3, [r7, #12]
 801a264:	689b      	ldr	r3, [r3, #8]
 801a266:	6819      	ldr	r1, [r3, #0]
 801a268:	68bb      	ldr	r3, [r7, #8]
 801a26a:	6a1a      	ldr	r2, [r3, #32]
 801a26c:	68bb      	ldr	r3, [r7, #8]
 801a26e:	69db      	ldr	r3, [r3, #28]
 801a270:	1e5c      	subs	r4, r3, #1
 801a272:	68bb      	ldr	r3, [r7, #8]
 801a274:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801a276:	f107 003c 	add.w	r0, r7, #60	@ 0x3c
 801a27a:	9300      	str	r3, [sp, #0]
 801a27c:	4623      	mov	r3, r4
 801a27e:	f007 fac3 	bl	8021808 <lv_area_set>
    lv_area_move(&clear_area, -buf_area->x1, -buf_area->y1);
 801a282:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801a284:	681b      	ldr	r3, [r3, #0]
 801a286:	4259      	negs	r1, r3
 801a288:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801a28a:	685b      	ldr	r3, [r3, #4]
 801a28c:	425a      	negs	r2, r3
 801a28e:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801a292:	4618      	mov	r0, r3
 801a294:	f007 fb34 	bl	8021900 <lv_area_move>
    lv_draw_buf_clear(draw_buf, &clear_area);
 801a298:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801a29c:	4619      	mov	r1, r3
 801a29e:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801a2a0:	f7f1 fcc8 	bl	800bc34 <lv_draw_buf_clear>

    /*Clear the right part*/
    lv_area_set(&clear_area, dsc->area.x2 + 1, dsc->area.y1, draw_unit->clip_area->x2, dsc->area.y2);
 801a2a4:	68bb      	ldr	r3, [r7, #8]
 801a2a6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a2a8:	1c59      	adds	r1, r3, #1
 801a2aa:	68bb      	ldr	r3, [r7, #8]
 801a2ac:	6a1a      	ldr	r2, [r3, #32]
 801a2ae:	68fb      	ldr	r3, [r7, #12]
 801a2b0:	689b      	ldr	r3, [r3, #8]
 801a2b2:	689c      	ldr	r4, [r3, #8]
 801a2b4:	68bb      	ldr	r3, [r7, #8]
 801a2b6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801a2b8:	f107 003c 	add.w	r0, r7, #60	@ 0x3c
 801a2bc:	9300      	str	r3, [sp, #0]
 801a2be:	4623      	mov	r3, r4
 801a2c0:	f007 faa2 	bl	8021808 <lv_area_set>
    lv_area_move(&clear_area, -buf_area->x1, -buf_area->y1);
 801a2c4:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801a2c6:	681b      	ldr	r3, [r3, #0]
 801a2c8:	4259      	negs	r1, r3
 801a2ca:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801a2cc:	685b      	ldr	r3, [r3, #4]
 801a2ce:	425a      	negs	r2, r3
 801a2d0:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801a2d4:	4618      	mov	r0, r3
 801a2d6:	f007 fb13 	bl	8021900 <lv_area_move>
    lv_draw_buf_clear(draw_buf, &clear_area);
 801a2da:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801a2de:	4619      	mov	r1, r3
 801a2e0:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 801a2e2:	f7f1 fca7 	bl	800bc34 <lv_draw_buf_clear>

    lv_draw_sw_mask_radius_param_t param;
    lv_draw_sw_mask_radius_init(&param, &dsc->area, dsc->radius, false);
 801a2e6:	68bb      	ldr	r3, [r7, #8]
 801a2e8:	f103 011c 	add.w	r1, r3, #28
 801a2ec:	68bb      	ldr	r3, [r7, #8]
 801a2ee:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 801a2f0:	f107 0018 	add.w	r0, r7, #24
 801a2f4:	2300      	movs	r3, #0
 801a2f6:	f7fe f9af 	bl	8018658 <lv_draw_sw_mask_radius_init>

    void * masks[2] = {0};
 801a2fa:	f107 0310 	add.w	r3, r7, #16
 801a2fe:	2200      	movs	r2, #0
 801a300:	601a      	str	r2, [r3, #0]
 801a302:	605a      	str	r2, [r3, #4]
    masks[0] = &param;
 801a304:	f107 0318 	add.w	r3, r7, #24
 801a308:	613b      	str	r3, [r7, #16]

    uint32_t area_w = lv_area_get_width(&draw_area);
 801a30a:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
 801a30e:	4618      	mov	r0, r3
 801a310:	f7ff ff23 	bl	801a15a <lv_area_get_width>
 801a314:	4603      	mov	r3, r0
 801a316:	66bb      	str	r3, [r7, #104]	@ 0x68
    lv_opa_t * mask_buf = lv_malloc(area_w);
 801a318:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 801a31a:	f00b fd55 	bl	8025dc8 <lv_malloc>
 801a31e:	6678      	str	r0, [r7, #100]	@ 0x64

    int32_t y;
    for(y = draw_area.y1; y <= draw_area.y2; y++) {
 801a320:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801a322:	67fb      	str	r3, [r7, #124]	@ 0x7c
 801a324:	e054      	b.n	801a3d0 <lv_draw_sw_mask_rect+0x23a>
        lv_memset(mask_buf, 0xff, area_w);
 801a326:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 801a328:	21ff      	movs	r1, #255	@ 0xff
 801a32a:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801a32c:	f00a fd79 	bl	8024e22 <lv_memset>
        lv_draw_sw_mask_res_t res = lv_draw_sw_mask_apply(masks, mask_buf, draw_area.x1, y, area_w);
 801a330:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801a332:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801a334:	f107 0010 	add.w	r0, r7, #16
 801a338:	9300      	str	r3, [sp, #0]
 801a33a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801a33c:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 801a33e:	f7fd ff15 	bl	801816c <lv_draw_sw_mask_apply>
 801a342:	4603      	mov	r3, r0
 801a344:	f887 3063 	strb.w	r3, [r7, #99]	@ 0x63
        if(res == LV_DRAW_SW_MASK_RES_FULL_COVER) continue;
 801a348:	f897 3063 	ldrb.w	r3, [r7, #99]	@ 0x63
 801a34c:	2b01      	cmp	r3, #1
 801a34e:	d03b      	beq.n	801a3c8 <lv_draw_sw_mask_rect+0x232>

        lv_color32_t * c32_buf = lv_draw_layer_go_to_xy(target_layer, draw_area.x1 - buf_area->x1,
 801a350:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801a352:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801a354:	681b      	ldr	r3, [r3, #0]
 801a356:	1ad1      	subs	r1, r2, r3
                                                        y - buf_area->y1);
 801a358:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801a35a:	685b      	ldr	r3, [r3, #4]
        lv_color32_t * c32_buf = lv_draw_layer_go_to_xy(target_layer, draw_area.x1 - buf_area->x1,
 801a35c:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801a35e:	1ad3      	subs	r3, r2, r3
 801a360:	461a      	mov	r2, r3
 801a362:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 801a364:	f7f1 fb1c 	bl	800b9a0 <lv_draw_layer_go_to_xy>
 801a368:	65f8      	str	r0, [r7, #92]	@ 0x5c

        if(res == LV_DRAW_SW_MASK_RES_TRANSP) {
 801a36a:	f897 3063 	ldrb.w	r3, [r7, #99]	@ 0x63
 801a36e:	2b00      	cmp	r3, #0
 801a370:	d106      	bne.n	801a380 <lv_draw_sw_mask_rect+0x1ea>
            lv_memzero(c32_buf, area_w * sizeof(lv_color32_t));
 801a372:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801a374:	009b      	lsls	r3, r3, #2
 801a376:	4619      	mov	r1, r3
 801a378:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801a37a:	f7ff fefe 	bl	801a17a <lv_memzero>
 801a37e:	e024      	b.n	801a3ca <lv_draw_sw_mask_rect+0x234>
        }
        else {
            uint32_t i;
            for(i = 0; i < area_w; i++) {
 801a380:	2300      	movs	r3, #0
 801a382:	67bb      	str	r3, [r7, #120]	@ 0x78
 801a384:	e01b      	b.n	801a3be <lv_draw_sw_mask_rect+0x228>
                if(mask_buf[i] != LV_OPA_COVER) {
 801a386:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 801a388:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801a38a:	4413      	add	r3, r2
 801a38c:	781b      	ldrb	r3, [r3, #0]
 801a38e:	2bff      	cmp	r3, #255	@ 0xff
 801a390:	d012      	beq.n	801a3b8 <lv_draw_sw_mask_rect+0x222>
                    c32_buf[i].alpha = LV_OPA_MIX2(c32_buf[i].alpha, mask_buf[i]);
 801a392:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801a394:	009b      	lsls	r3, r3, #2
 801a396:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801a398:	4413      	add	r3, r2
 801a39a:	78db      	ldrb	r3, [r3, #3]
 801a39c:	4619      	mov	r1, r3
 801a39e:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 801a3a0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801a3a2:	4413      	add	r3, r2
 801a3a4:	781b      	ldrb	r3, [r3, #0]
 801a3a6:	fb01 f303 	mul.w	r3, r1, r3
 801a3aa:	1219      	asrs	r1, r3, #8
 801a3ac:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801a3ae:	009b      	lsls	r3, r3, #2
 801a3b0:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801a3b2:	4413      	add	r3, r2
 801a3b4:	b2ca      	uxtb	r2, r1
 801a3b6:	70da      	strb	r2, [r3, #3]
            for(i = 0; i < area_w; i++) {
 801a3b8:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801a3ba:	3301      	adds	r3, #1
 801a3bc:	67bb      	str	r3, [r7, #120]	@ 0x78
 801a3be:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 801a3c0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801a3c2:	429a      	cmp	r2, r3
 801a3c4:	d3df      	bcc.n	801a386 <lv_draw_sw_mask_rect+0x1f0>
 801a3c6:	e000      	b.n	801a3ca <lv_draw_sw_mask_rect+0x234>
        if(res == LV_DRAW_SW_MASK_RES_FULL_COVER) continue;
 801a3c8:	bf00      	nop
    for(y = draw_area.y1; y <= draw_area.y2; y++) {
 801a3ca:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801a3cc:	3301      	adds	r3, #1
 801a3ce:	67fb      	str	r3, [r7, #124]	@ 0x7c
 801a3d0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801a3d2:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801a3d4:	429a      	cmp	r2, r3
 801a3d6:	dda6      	ble.n	801a326 <lv_draw_sw_mask_rect+0x190>
                }
            }
        }
    }

    lv_free(mask_buf);
 801a3d8:	6e78      	ldr	r0, [r7, #100]	@ 0x64
 801a3da:	f00b fd2d 	bl	8025e38 <lv_free>
    lv_draw_sw_mask_free_param(&param);
 801a3de:	f107 0318 	add.w	r3, r7, #24
 801a3e2:	4618      	mov	r0, r3
 801a3e4:	f7fd ff04 	bl	80181f0 <lv_draw_sw_mask_free_param>
 801a3e8:	e000      	b.n	801a3ec <lv_draw_sw_mask_rect+0x256>
        return;
 801a3ea:	bf00      	nop
}
 801a3ec:	3784      	adds	r7, #132	@ 0x84
 801a3ee:	46bd      	mov	sp, r7
 801a3f0:	bd90      	pop	{r4, r7, pc}

0801a3f2 <lv_area_get_width>:
{
 801a3f2:	b480      	push	{r7}
 801a3f4:	b083      	sub	sp, #12
 801a3f6:	af00      	add	r7, sp, #0
 801a3f8:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 801a3fa:	687b      	ldr	r3, [r7, #4]
 801a3fc:	689a      	ldr	r2, [r3, #8]
 801a3fe:	687b      	ldr	r3, [r7, #4]
 801a400:	681b      	ldr	r3, [r3, #0]
 801a402:	1ad3      	subs	r3, r2, r3
 801a404:	3301      	adds	r3, #1
}
 801a406:	4618      	mov	r0, r3
 801a408:	370c      	adds	r7, #12
 801a40a:	46bd      	mov	sp, r7
 801a40c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a410:	4770      	bx	lr

0801a412 <lv_area_get_height>:
{
 801a412:	b480      	push	{r7}
 801a414:	b083      	sub	sp, #12
 801a416:	af00      	add	r7, sp, #0
 801a418:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 801a41a:	687b      	ldr	r3, [r7, #4]
 801a41c:	68da      	ldr	r2, [r3, #12]
 801a41e:	687b      	ldr	r3, [r7, #4]
 801a420:	685b      	ldr	r3, [r3, #4]
 801a422:	1ad3      	subs	r3, r2, r3
 801a424:	3301      	adds	r3, #1
}
 801a426:	4618      	mov	r0, r3
 801a428:	370c      	adds	r7, #12
 801a42a:	46bd      	mov	sp, r7
 801a42c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a430:	4770      	bx	lr

0801a432 <lv_color_format_get_size>:
{
 801a432:	b580      	push	{r7, lr}
 801a434:	b082      	sub	sp, #8
 801a436:	af00      	add	r7, sp, #0
 801a438:	4603      	mov	r3, r0
 801a43a:	71fb      	strb	r3, [r7, #7]
    return (lv_color_format_get_bpp(cf) + 7) >> 3;
 801a43c:	79fb      	ldrb	r3, [r7, #7]
 801a43e:	4618      	mov	r0, r3
 801a440:	f008 f862 	bl	8022508 <lv_color_format_get_bpp>
 801a444:	4603      	mov	r3, r0
 801a446:	3307      	adds	r3, #7
 801a448:	10db      	asrs	r3, r3, #3
 801a44a:	b2db      	uxtb	r3, r3
}
 801a44c:	4618      	mov	r0, r3
 801a44e:	3708      	adds	r7, #8
 801a450:	46bd      	mov	sp, r7
 801a452:	bd80      	pop	{r7, pc}

0801a454 <lv_color32_eq>:
 * @param c1    the first color
 * @param c2    the second color
 * @return      true: equal
 */
static inline bool lv_color32_eq(lv_color32_t c1, lv_color32_t c2)
{
 801a454:	b480      	push	{r7}
 801a456:	b083      	sub	sp, #12
 801a458:	af00      	add	r7, sp, #0
 801a45a:	6078      	str	r0, [r7, #4]
 801a45c:	6039      	str	r1, [r7, #0]
    return *((uint32_t *)&c1) == *((uint32_t *)&c2);
 801a45e:	1d3b      	adds	r3, r7, #4
 801a460:	681a      	ldr	r2, [r3, #0]
 801a462:	463b      	mov	r3, r7
 801a464:	681b      	ldr	r3, [r3, #0]
 801a466:	429a      	cmp	r2, r3
 801a468:	bf0c      	ite	eq
 801a46a:	2301      	moveq	r3, #1
 801a46c:	2300      	movne	r3, #0
 801a46e:	b2db      	uxtb	r3, r3
}
 801a470:	4618      	mov	r0, r3
 801a472:	370c      	adds	r7, #12
 801a474:	46bd      	mov	sp, r7
 801a476:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a47a:	4770      	bx	lr

0801a47c <lv_color_16_16_mix>:
 * @return          mix == 0: c2
 *                  mix == 255: c1
 *                  mix == 128: 0.5 x c1 + 0.5 x c2
 */
static inline uint16_t LV_ATTRIBUTE_FAST_MEM lv_color_16_16_mix(uint16_t c1, uint16_t c2, uint8_t mix)
{
 801a47c:	b480      	push	{r7}
 801a47e:	b087      	sub	sp, #28
 801a480:	af00      	add	r7, sp, #0
 801a482:	4603      	mov	r3, r0
 801a484:	80fb      	strh	r3, [r7, #6]
 801a486:	460b      	mov	r3, r1
 801a488:	80bb      	strh	r3, [r7, #4]
 801a48a:	4613      	mov	r3, r2
 801a48c:	70fb      	strb	r3, [r7, #3]
    if(mix == 255) return c1;
 801a48e:	78fb      	ldrb	r3, [r7, #3]
 801a490:	2bff      	cmp	r3, #255	@ 0xff
 801a492:	d101      	bne.n	801a498 <lv_color_16_16_mix+0x1c>
 801a494:	88fb      	ldrh	r3, [r7, #6]
 801a496:	e02a      	b.n	801a4ee <lv_color_16_16_mix+0x72>
    if(mix == 0) return c2;
 801a498:	78fb      	ldrb	r3, [r7, #3]
 801a49a:	2b00      	cmp	r3, #0
 801a49c:	d101      	bne.n	801a4a2 <lv_color_16_16_mix+0x26>
 801a49e:	88bb      	ldrh	r3, [r7, #4]
 801a4a0:	e025      	b.n	801a4ee <lv_color_16_16_mix+0x72>

    uint16_t ret;

    /* Source: https://stackoverflow.com/a/50012418/1999969*/
    mix = (uint32_t)((uint32_t)mix + 4) >> 3;
 801a4a2:	78fb      	ldrb	r3, [r7, #3]
 801a4a4:	3304      	adds	r3, #4
 801a4a6:	08db      	lsrs	r3, r3, #3
 801a4a8:	70fb      	strb	r3, [r7, #3]

    /*0x7E0F81F = 0b00000111111000001111100000011111*/
    uint32_t bg = (uint32_t)(c2 | ((uint32_t)c2 << 16)) & 0x7E0F81F;
 801a4aa:	88ba      	ldrh	r2, [r7, #4]
 801a4ac:	4613      	mov	r3, r2
 801a4ae:	041b      	lsls	r3, r3, #16
 801a4b0:	441a      	add	r2, r3
 801a4b2:	4b12      	ldr	r3, [pc, #72]	@ (801a4fc <lv_color_16_16_mix+0x80>)
 801a4b4:	4013      	ands	r3, r2
 801a4b6:	617b      	str	r3, [r7, #20]
    uint32_t fg = (uint32_t)(c1 | ((uint32_t)c1 << 16)) & 0x7E0F81F;
 801a4b8:	88fa      	ldrh	r2, [r7, #6]
 801a4ba:	4613      	mov	r3, r2
 801a4bc:	041b      	lsls	r3, r3, #16
 801a4be:	441a      	add	r2, r3
 801a4c0:	4b0e      	ldr	r3, [pc, #56]	@ (801a4fc <lv_color_16_16_mix+0x80>)
 801a4c2:	4013      	ands	r3, r2
 801a4c4:	613b      	str	r3, [r7, #16]
    uint32_t result = ((((fg - bg) * mix) >> 5) + bg) & 0x7E0F81F;
 801a4c6:	693a      	ldr	r2, [r7, #16]
 801a4c8:	697b      	ldr	r3, [r7, #20]
 801a4ca:	1ad3      	subs	r3, r2, r3
 801a4cc:	78fa      	ldrb	r2, [r7, #3]
 801a4ce:	fb02 f303 	mul.w	r3, r2, r3
 801a4d2:	095a      	lsrs	r2, r3, #5
 801a4d4:	697b      	ldr	r3, [r7, #20]
 801a4d6:	441a      	add	r2, r3
 801a4d8:	4b08      	ldr	r3, [pc, #32]	@ (801a4fc <lv_color_16_16_mix+0x80>)
 801a4da:	4013      	ands	r3, r2
 801a4dc:	60fb      	str	r3, [r7, #12]
    ret = (uint16_t)(result >> 16) | result;
 801a4de:	68fb      	ldr	r3, [r7, #12]
 801a4e0:	0c1b      	lsrs	r3, r3, #16
 801a4e2:	b29a      	uxth	r2, r3
 801a4e4:	68fb      	ldr	r3, [r7, #12]
 801a4e6:	b29b      	uxth	r3, r3
 801a4e8:	4313      	orrs	r3, r2
 801a4ea:	817b      	strh	r3, [r7, #10]

    return ret;
 801a4ec:	897b      	ldrh	r3, [r7, #10]
}
 801a4ee:	4618      	mov	r0, r3
 801a4f0:	371c      	adds	r7, #28
 801a4f2:	46bd      	mov	sp, r7
 801a4f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a4f8:	4770      	bx	lr
 801a4fa:	bf00      	nop
 801a4fc:	07e0f81f 	.word	0x07e0f81f

0801a500 <lv_color_mix32>:
 * @return
 * @note Use bg.alpha in the return value
 * @note Use fg.alpha as mix ratio
 */
static inline lv_color32_t lv_color_mix32(lv_color32_t fg, lv_color32_t bg)
{
 801a500:	b480      	push	{r7}
 801a502:	b085      	sub	sp, #20
 801a504:	af00      	add	r7, sp, #0
 801a506:	6078      	str	r0, [r7, #4]
 801a508:	6039      	str	r1, [r7, #0]
    if(fg.alpha >= LV_OPA_MAX) {
 801a50a:	79fb      	ldrb	r3, [r7, #7]
 801a50c:	2bfc      	cmp	r3, #252	@ 0xfc
 801a50e:	d904      	bls.n	801a51a <lv_color_mix32+0x1a>
        fg.alpha = bg.alpha;
 801a510:	78fb      	ldrb	r3, [r7, #3]
 801a512:	71fb      	strb	r3, [r7, #7]
        return fg;
 801a514:	687b      	ldr	r3, [r7, #4]
 801a516:	60fb      	str	r3, [r7, #12]
 801a518:	e031      	b.n	801a57e <lv_color_mix32+0x7e>
    }
    if(fg.alpha <= LV_OPA_MIN) {
 801a51a:	79fb      	ldrb	r3, [r7, #7]
 801a51c:	2b02      	cmp	r3, #2
 801a51e:	d802      	bhi.n	801a526 <lv_color_mix32+0x26>
        return bg;
 801a520:	683b      	ldr	r3, [r7, #0]
 801a522:	60fb      	str	r3, [r7, #12]
 801a524:	e02b      	b.n	801a57e <lv_color_mix32+0x7e>
    }
    bg.red = (uint32_t)((uint32_t)fg.red * fg.alpha + (uint32_t)bg.red * (255 - fg.alpha)) >> 8;
 801a526:	79bb      	ldrb	r3, [r7, #6]
 801a528:	79fa      	ldrb	r2, [r7, #7]
 801a52a:	fb03 f202 	mul.w	r2, r3, r2
 801a52e:	78bb      	ldrb	r3, [r7, #2]
 801a530:	79f9      	ldrb	r1, [r7, #7]
 801a532:	f1c1 01ff 	rsb	r1, r1, #255	@ 0xff
 801a536:	fb01 f303 	mul.w	r3, r1, r3
 801a53a:	4413      	add	r3, r2
 801a53c:	0a1b      	lsrs	r3, r3, #8
 801a53e:	b2db      	uxtb	r3, r3
 801a540:	70bb      	strb	r3, [r7, #2]
    bg.green = (uint32_t)((uint32_t)fg.green * fg.alpha + (uint32_t)bg.green * (255 - fg.alpha)) >> 8;
 801a542:	797b      	ldrb	r3, [r7, #5]
 801a544:	79fa      	ldrb	r2, [r7, #7]
 801a546:	fb03 f202 	mul.w	r2, r3, r2
 801a54a:	787b      	ldrb	r3, [r7, #1]
 801a54c:	79f9      	ldrb	r1, [r7, #7]
 801a54e:	f1c1 01ff 	rsb	r1, r1, #255	@ 0xff
 801a552:	fb01 f303 	mul.w	r3, r1, r3
 801a556:	4413      	add	r3, r2
 801a558:	0a1b      	lsrs	r3, r3, #8
 801a55a:	b2db      	uxtb	r3, r3
 801a55c:	707b      	strb	r3, [r7, #1]
    bg.blue = (uint32_t)((uint32_t)fg.blue * fg.alpha + (uint32_t)bg.blue * (255 - fg.alpha)) >> 8;
 801a55e:	793b      	ldrb	r3, [r7, #4]
 801a560:	79fa      	ldrb	r2, [r7, #7]
 801a562:	fb03 f202 	mul.w	r2, r3, r2
 801a566:	783b      	ldrb	r3, [r7, #0]
 801a568:	79f9      	ldrb	r1, [r7, #7]
 801a56a:	f1c1 01ff 	rsb	r1, r1, #255	@ 0xff
 801a56e:	fb01 f303 	mul.w	r3, r1, r3
 801a572:	4413      	add	r3, r2
 801a574:	0a1b      	lsrs	r3, r3, #8
 801a576:	b2db      	uxtb	r3, r3
 801a578:	703b      	strb	r3, [r7, #0]
    return bg;
 801a57a:	683b      	ldr	r3, [r7, #0]
 801a57c:	60fb      	str	r3, [r7, #12]
}
 801a57e:	2300      	movs	r3, #0
 801a580:	7b3a      	ldrb	r2, [r7, #12]
 801a582:	f362 0307 	bfi	r3, r2, #0, #8
 801a586:	7b7a      	ldrb	r2, [r7, #13]
 801a588:	f362 230f 	bfi	r3, r2, #8, #8
 801a58c:	7bba      	ldrb	r2, [r7, #14]
 801a58e:	f362 4317 	bfi	r3, r2, #16, #8
 801a592:	7bfa      	ldrb	r2, [r7, #15]
 801a594:	f362 631f 	bfi	r3, r2, #24, #8
 801a598:	4618      	mov	r0, r3
 801a59a:	3714      	adds	r7, #20
 801a59c:	46bd      	mov	sp, r7
 801a59e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a5a2:	4770      	bx	lr

0801a5a4 <lv_draw_sw_transform>:
 **********************/

void lv_draw_sw_transform(lv_draw_unit_t * draw_unit, const lv_area_t * dest_area, const void * src_buf,
                          int32_t src_w, int32_t src_h, int32_t src_stride,
                          const lv_draw_image_dsc_t * draw_dsc, const lv_draw_image_sup_t * sup, lv_color_format_t src_cf, void * dest_buf)
{
 801a5a4:	b590      	push	{r4, r7, lr}
 801a5a6:	b0c3      	sub	sp, #268	@ 0x10c
 801a5a8:	af0a      	add	r7, sp, #40	@ 0x28
 801a5aa:	60f8      	str	r0, [r7, #12]
 801a5ac:	60b9      	str	r1, [r7, #8]
 801a5ae:	607a      	str	r2, [r7, #4]
 801a5b0:	603b      	str	r3, [r7, #0]
    LV_UNUSED(draw_unit);
    LV_UNUSED(sup);

    point_transform_dsc_t tr_dsc;
    tr_dsc.angle = -draw_dsc->rotation;
 801a5b2:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801a5b6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801a5b8:	425b      	negs	r3, r3
 801a5ba:	667b      	str	r3, [r7, #100]	@ 0x64
    tr_dsc.scale_x = (256 * 256) / draw_dsc->scale_x;
 801a5bc:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801a5c0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801a5c2:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 801a5c6:	fb92 f3f3 	sdiv	r3, r2, r3
 801a5ca:	65fb      	str	r3, [r7, #92]	@ 0x5c
    tr_dsc.scale_y = (256 * 256) / draw_dsc->scale_y;
 801a5cc:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801a5d0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801a5d2:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 801a5d6:	fb92 f3f3 	sdiv	r3, r2, r3
 801a5da:	663b      	str	r3, [r7, #96]	@ 0x60
    tr_dsc.pivot = draw_dsc->pivot;
 801a5dc:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801a5e0:	f107 0370 	add.w	r3, r7, #112	@ 0x70
 801a5e4:	3240      	adds	r2, #64	@ 0x40
 801a5e6:	e892 0003 	ldmia.w	r2, {r0, r1}
 801a5ea:	e883 0003 	stmia.w	r3, {r0, r1}

    int32_t angle_low = tr_dsc.angle / 10;
 801a5ee:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801a5f0:	4ad0      	ldr	r2, [pc, #832]	@ (801a934 <lv_draw_sw_transform+0x390>)
 801a5f2:	fb82 1203 	smull	r1, r2, r2, r3
 801a5f6:	1092      	asrs	r2, r2, #2
 801a5f8:	17db      	asrs	r3, r3, #31
 801a5fa:	1ad3      	subs	r3, r2, r3
 801a5fc:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    int32_t angle_high = angle_low + 1;
 801a600:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 801a604:	3301      	adds	r3, #1
 801a606:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
    int32_t angle_rem = tr_dsc.angle  - (angle_low * 10);
 801a60a:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 801a60c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 801a610:	f06f 0109 	mvn.w	r1, #9
 801a614:	fb01 f303 	mul.w	r3, r1, r3
 801a618:	4413      	add	r3, r2
 801a61a:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0

    int32_t s1 = lv_trigo_sin(angle_low);
 801a61e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 801a622:	b21b      	sxth	r3, r3
 801a624:	4618      	mov	r0, r3
 801a626:	f008 fe5d 	bl	80232e4 <lv_trigo_sin>
 801a62a:	f8c7 00ac 	str.w	r0, [r7, #172]	@ 0xac
    int32_t s2 = lv_trigo_sin(angle_high);
 801a62e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 801a632:	b21b      	sxth	r3, r3
 801a634:	4618      	mov	r0, r3
 801a636:	f008 fe55 	bl	80232e4 <lv_trigo_sin>
 801a63a:	f8c7 00a8 	str.w	r0, [r7, #168]	@ 0xa8

    int32_t c1 = lv_trigo_sin(angle_low + 90);
 801a63e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 801a642:	b29b      	uxth	r3, r3
 801a644:	335a      	adds	r3, #90	@ 0x5a
 801a646:	b29b      	uxth	r3, r3
 801a648:	b21b      	sxth	r3, r3
 801a64a:	4618      	mov	r0, r3
 801a64c:	f008 fe4a 	bl	80232e4 <lv_trigo_sin>
 801a650:	f8c7 00a4 	str.w	r0, [r7, #164]	@ 0xa4
    int32_t c2 = lv_trigo_sin(angle_high + 90);
 801a654:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 801a658:	b29b      	uxth	r3, r3
 801a65a:	335a      	adds	r3, #90	@ 0x5a
 801a65c:	b29b      	uxth	r3, r3
 801a65e:	b21b      	sxth	r3, r3
 801a660:	4618      	mov	r0, r3
 801a662:	f008 fe3f 	bl	80232e4 <lv_trigo_sin>
 801a666:	f8c7 00a0 	str.w	r0, [r7, #160]	@ 0xa0

    tr_dsc.sinma = (s1 * (10 - angle_rem) + s2 * angle_rem) / 10;
 801a66a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801a66e:	f1c3 030a 	rsb	r3, r3, #10
 801a672:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 801a676:	fb03 f202 	mul.w	r2, r3, r2
 801a67a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 801a67e:	f8d7 10b0 	ldr.w	r1, [r7, #176]	@ 0xb0
 801a682:	fb01 f303 	mul.w	r3, r1, r3
 801a686:	4413      	add	r3, r2
 801a688:	4aaa      	ldr	r2, [pc, #680]	@ (801a934 <lv_draw_sw_transform+0x390>)
 801a68a:	fb82 1203 	smull	r1, r2, r2, r3
 801a68e:	1092      	asrs	r2, r2, #2
 801a690:	17db      	asrs	r3, r3, #31
 801a692:	1ad3      	subs	r3, r2, r3
 801a694:	657b      	str	r3, [r7, #84]	@ 0x54
    tr_dsc.cosma = (c1 * (10 - angle_rem) + c2 * angle_rem) / 10;
 801a696:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801a69a:	f1c3 030a 	rsb	r3, r3, #10
 801a69e:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 801a6a2:	fb03 f202 	mul.w	r2, r3, r2
 801a6a6:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801a6aa:	f8d7 10b0 	ldr.w	r1, [r7, #176]	@ 0xb0
 801a6ae:	fb01 f303 	mul.w	r3, r1, r3
 801a6b2:	4413      	add	r3, r2
 801a6b4:	4a9f      	ldr	r2, [pc, #636]	@ (801a934 <lv_draw_sw_transform+0x390>)
 801a6b6:	fb82 1203 	smull	r1, r2, r2, r3
 801a6ba:	1092      	asrs	r2, r2, #2
 801a6bc:	17db      	asrs	r3, r3, #31
 801a6be:	1ad3      	subs	r3, r2, r3
 801a6c0:	65bb      	str	r3, [r7, #88]	@ 0x58
    tr_dsc.sinma = tr_dsc.sinma >> (LV_TRIGO_SHIFT - 10);
 801a6c2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801a6c4:	115b      	asrs	r3, r3, #5
 801a6c6:	657b      	str	r3, [r7, #84]	@ 0x54
    tr_dsc.cosma = tr_dsc.cosma >> (LV_TRIGO_SHIFT - 10);
 801a6c8:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801a6ca:	115b      	asrs	r3, r3, #5
 801a6cc:	65bb      	str	r3, [r7, #88]	@ 0x58
    tr_dsc.pivot_x_256 = tr_dsc.pivot.x * 256;
 801a6ce:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801a6d0:	021b      	lsls	r3, r3, #8
 801a6d2:	66bb      	str	r3, [r7, #104]	@ 0x68
    tr_dsc.pivot_y_256 = tr_dsc.pivot.y * 256;
 801a6d4:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801a6d6:	021b      	lsls	r3, r3, #8
 801a6d8:	66fb      	str	r3, [r7, #108]	@ 0x6c

    int32_t dest_w = lv_area_get_width(dest_area);
 801a6da:	68b8      	ldr	r0, [r7, #8]
 801a6dc:	f7ff fe89 	bl	801a3f2 <lv_area_get_width>
 801a6e0:	f8c7 009c 	str.w	r0, [r7, #156]	@ 0x9c
    int32_t dest_h = lv_area_get_height(dest_area);
 801a6e4:	68b8      	ldr	r0, [r7, #8]
 801a6e6:	f7ff fe94 	bl	801a412 <lv_area_get_height>
 801a6ea:	f8c7 0098 	str.w	r0, [r7, #152]	@ 0x98

    int32_t dest_stride_a8 = dest_w;
 801a6ee:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801a6f2:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    int32_t dest_stride;
    if(src_cf == LV_COLOR_FORMAT_RGB888) {
 801a6f6:	f897 3100 	ldrb.w	r3, [r7, #256]	@ 0x100
 801a6fa:	2b0f      	cmp	r3, #15
 801a6fc:	d10b      	bne.n	801a716 <lv_draw_sw_transform+0x172>
        dest_stride = dest_w * lv_color_format_get_size(LV_COLOR_FORMAT_ARGB8888);
 801a6fe:	2010      	movs	r0, #16
 801a700:	f7ff fe97 	bl	801a432 <lv_color_format_get_size>
 801a704:	4603      	mov	r3, r0
 801a706:	461a      	mov	r2, r3
 801a708:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801a70c:	fb02 f303 	mul.w	r3, r2, r3
 801a710:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 801a714:	e016      	b.n	801a744 <lv_draw_sw_transform+0x1a0>
    }
    else if(src_cf == LV_COLOR_FORMAT_RGB565A8) {
 801a716:	f897 3100 	ldrb.w	r3, [r7, #256]	@ 0x100
 801a71a:	2b14      	cmp	r3, #20
 801a71c:	d105      	bne.n	801a72a <lv_draw_sw_transform+0x186>
        dest_stride = dest_w * 2;
 801a71e:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801a722:	005b      	lsls	r3, r3, #1
 801a724:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 801a728:	e00c      	b.n	801a744 <lv_draw_sw_transform+0x1a0>
    }
    else {
        dest_stride = dest_w * lv_color_format_get_size(src_cf);
 801a72a:	f897 3100 	ldrb.w	r3, [r7, #256]	@ 0x100
 801a72e:	4618      	mov	r0, r3
 801a730:	f7ff fe7f 	bl	801a432 <lv_color_format_get_size>
 801a734:	4603      	mov	r3, r0
 801a736:	461a      	mov	r2, r3
 801a738:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801a73c:	fb02 f303 	mul.w	r3, r2, r3
 801a740:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    }

    uint8_t * alpha_buf;
    if(src_cf == LV_COLOR_FORMAT_RGB565 || src_cf == LV_COLOR_FORMAT_RGB565A8) {
 801a744:	f897 3100 	ldrb.w	r3, [r7, #256]	@ 0x100
 801a748:	2b12      	cmp	r3, #18
 801a74a:	d003      	beq.n	801a754 <lv_draw_sw_transform+0x1b0>
 801a74c:	f897 3100 	ldrb.w	r3, [r7, #256]	@ 0x100
 801a750:	2b14      	cmp	r3, #20
 801a752:	d110      	bne.n	801a776 <lv_draw_sw_transform+0x1d2>
        alpha_buf = dest_buf;
 801a754:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801a758:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
        alpha_buf += dest_stride * dest_h;
 801a75c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801a760:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 801a764:	fb02 f303 	mul.w	r3, r2, r3
 801a768:	461a      	mov	r2, r3
 801a76a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801a76e:	4413      	add	r3, r2
 801a770:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 801a774:	e002      	b.n	801a77c <lv_draw_sw_transform+0x1d8>
    }
    else {
        alpha_buf = NULL;
 801a776:	2300      	movs	r3, #0
 801a778:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    }

    bool aa = draw_dsc->antialias;
 801a77c:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801a780:	f893 304d 	ldrb.w	r3, [r3, #77]	@ 0x4d
 801a784:	f3c3 1300 	ubfx	r3, r3, #4, #1
 801a788:	b2db      	uxtb	r3, r3
 801a78a:	2b00      	cmp	r3, #0
 801a78c:	bf14      	ite	ne
 801a78e:	2301      	movne	r3, #1
 801a790:	2300      	moveq	r3, #0
 801a792:	f887 3093 	strb.w	r3, [r7, #147]	@ 0x93
    bool is_rotated = draw_dsc->rotation;
 801a796:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801a79a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801a79c:	2b00      	cmp	r3, #0
 801a79e:	bf14      	ite	ne
 801a7a0:	2301      	movne	r3, #1
 801a7a2:	2300      	moveq	r3, #0
 801a7a4:	f887 3092 	strb.w	r3, [r7, #146]	@ 0x92

    int32_t xs_ups = 0, ys_ups = 0, ys_ups_start = 0, ys_step_256_original = 0;
 801a7a8:	2300      	movs	r3, #0
 801a7aa:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 801a7ae:	2300      	movs	r3, #0
 801a7b0:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 801a7b4:	2300      	movs	r3, #0
 801a7b6:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 801a7ba:	2300      	movs	r3, #0
 801a7bc:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
    int32_t xs_step_256 = 0, ys_step_256 = 0;
 801a7c0:	2300      	movs	r3, #0
 801a7c2:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 801a7c6:	2300      	movs	r3, #0
 801a7c8:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
     *However this way the last pixel will be on the 99.67 coordinate.
     *As it's larger than 99.5 LVGL will start to mix the next coordinate
     *which is out of the image, so will make the pixel more transparent.
     *To avoid it in case of scale only limit the coordinates to the 0..297 range,
     *that is to 0..(src_w-1)*zoom */
    if(is_rotated == false) {
 801a7cc:	f897 3092 	ldrb.w	r3, [r7, #146]	@ 0x92
 801a7d0:	f083 0301 	eor.w	r3, r3, #1
 801a7d4:	b2db      	uxtb	r3, r3
 801a7d6:	2b00      	cmp	r3, #0
 801a7d8:	f000 8091 	beq.w	801a8fe <lv_draw_sw_transform+0x35a>
        int32_t xs1_ups, ys1_ups, xs2_ups, ys2_ups;

        int32_t x_max = (((src_w - 1 - draw_dsc->pivot.x) * draw_dsc->scale_x) >> 8) + draw_dsc->pivot.x;
 801a7dc:	683b      	ldr	r3, [r7, #0]
 801a7de:	1e5a      	subs	r2, r3, #1
 801a7e0:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801a7e4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801a7e6:	1ad3      	subs	r3, r2, r3
 801a7e8:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801a7ec:	6b12      	ldr	r2, [r2, #48]	@ 0x30
 801a7ee:	fb02 f303 	mul.w	r3, r2, r3
 801a7f2:	121a      	asrs	r2, r3, #8
 801a7f4:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801a7f8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801a7fa:	4413      	add	r3, r2
 801a7fc:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
        int32_t y_max = (((src_h - 1 - draw_dsc->pivot.y) * draw_dsc->scale_y) >> 8) + draw_dsc->pivot.y;
 801a800:	f8d7 30f0 	ldr.w	r3, [r7, #240]	@ 0xf0
 801a804:	1e5a      	subs	r2, r3, #1
 801a806:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801a80a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801a80c:	1ad3      	subs	r3, r2, r3
 801a80e:	f8d7 20f8 	ldr.w	r2, [r7, #248]	@ 0xf8
 801a812:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 801a814:	fb02 f303 	mul.w	r3, r2, r3
 801a818:	121a      	asrs	r2, r3, #8
 801a81a:	f8d7 30f8 	ldr.w	r3, [r7, #248]	@ 0xf8
 801a81e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801a820:	4413      	add	r3, r2
 801a822:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88

        lv_area_t dest_area_limited;
        dest_area_limited.x1 = dest_area->x1 > x_max ? x_max : dest_area->x1;
 801a826:	68bb      	ldr	r3, [r7, #8]
 801a828:	681a      	ldr	r2, [r3, #0]
 801a82a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801a82e:	4293      	cmp	r3, r2
 801a830:	bfa8      	it	ge
 801a832:	4613      	movge	r3, r2
 801a834:	627b      	str	r3, [r7, #36]	@ 0x24
        dest_area_limited.x2 = dest_area->x2 > x_max ? x_max : dest_area->x2;
 801a836:	68bb      	ldr	r3, [r7, #8]
 801a838:	689a      	ldr	r2, [r3, #8]
 801a83a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801a83e:	4293      	cmp	r3, r2
 801a840:	bfa8      	it	ge
 801a842:	4613      	movge	r3, r2
 801a844:	62fb      	str	r3, [r7, #44]	@ 0x2c
        dest_area_limited.y1 = dest_area->y1 > y_max ? y_max : dest_area->y1;
 801a846:	68bb      	ldr	r3, [r7, #8]
 801a848:	685a      	ldr	r2, [r3, #4]
 801a84a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801a84e:	4293      	cmp	r3, r2
 801a850:	bfa8      	it	ge
 801a852:	4613      	movge	r3, r2
 801a854:	62bb      	str	r3, [r7, #40]	@ 0x28
        dest_area_limited.y2 = dest_area->y2 > y_max ? y_max : dest_area->y2;
 801a856:	68bb      	ldr	r3, [r7, #8]
 801a858:	68da      	ldr	r2, [r3, #12]
 801a85a:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 801a85e:	4293      	cmp	r3, r2
 801a860:	bfa8      	it	ge
 801a862:	4613      	movge	r3, r2
 801a864:	633b      	str	r3, [r7, #48]	@ 0x30

        transform_point_upscaled(&tr_dsc, dest_area_limited.x1, dest_area_limited.y1, &xs1_ups, &ys1_ups);
 801a866:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801a868:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801a86a:	f107 0440 	add.w	r4, r7, #64	@ 0x40
 801a86e:	f107 0044 	add.w	r0, r7, #68	@ 0x44
 801a872:	f107 033c 	add.w	r3, r7, #60	@ 0x3c
 801a876:	9300      	str	r3, [sp, #0]
 801a878:	4623      	mov	r3, r4
 801a87a:	f000 ffb5 	bl	801b7e8 <transform_point_upscaled>
        transform_point_upscaled(&tr_dsc, dest_area_limited.x2, dest_area_limited.y2, &xs2_ups, &ys2_ups);
 801a87e:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 801a880:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801a882:	f107 0438 	add.w	r4, r7, #56	@ 0x38
 801a886:	f107 0044 	add.w	r0, r7, #68	@ 0x44
 801a88a:	f107 0334 	add.w	r3, r7, #52	@ 0x34
 801a88e:	9300      	str	r3, [sp, #0]
 801a890:	4623      	mov	r3, r4
 801a892:	f000 ffa9 	bl	801b7e8 <transform_point_upscaled>

        int32_t xs_diff = xs2_ups - xs1_ups;
 801a896:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801a898:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801a89a:	1ad3      	subs	r3, r2, r3
 801a89c:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
        int32_t ys_diff = ys2_ups - ys1_ups;
 801a8a0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801a8a2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801a8a4:	1ad3      	subs	r3, r2, r3
 801a8a6:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        xs_step_256 = 0;
 801a8aa:	2300      	movs	r3, #0
 801a8ac:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
        ys_step_256_original = 0;
 801a8b0:	2300      	movs	r3, #0
 801a8b2:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
        if(dest_w > 1) {
 801a8b6:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801a8ba:	2b01      	cmp	r3, #1
 801a8bc:	dd09      	ble.n	801a8d2 <lv_draw_sw_transform+0x32e>
            xs_step_256 = (256 * xs_diff) / (dest_w - 1);
 801a8be:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801a8c2:	021a      	lsls	r2, r3, #8
 801a8c4:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801a8c8:	3b01      	subs	r3, #1
 801a8ca:	fb92 f3f3 	sdiv	r3, r2, r3
 801a8ce:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
        }
        if(dest_h > 1) {
 801a8d2:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801a8d6:	2b01      	cmp	r3, #1
 801a8d8:	dd09      	ble.n	801a8ee <lv_draw_sw_transform+0x34a>
            ys_step_256_original = (256 * ys_diff) / (dest_h - 1);
 801a8da:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801a8de:	021a      	lsls	r2, r3, #8
 801a8e0:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801a8e4:	3b01      	subs	r3, #1
 801a8e6:	fb92 f3f3 	sdiv	r3, r2, r3
 801a8ea:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
        }

        xs_ups = xs1_ups + 0x80;
 801a8ee:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801a8f0:	3380      	adds	r3, #128	@ 0x80
 801a8f2:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
        ys_ups_start = ys1_ups + 0x80;
 801a8f6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801a8f8:	3380      	adds	r3, #128	@ 0x80
 801a8fa:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
    }

    int32_t y;
    for(y = 0; y < dest_h; y++) {
 801a8fe:	2300      	movs	r3, #0
 801a900:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 801a904:	e158      	b.n	801abb8 <lv_draw_sw_transform+0x614>
        if(is_rotated == false) {
 801a906:	f897 3092 	ldrb.w	r3, [r7, #146]	@ 0x92
 801a90a:	f083 0301 	eor.w	r3, r3, #1
 801a90e:	b2db      	uxtb	r3, r3
 801a910:	2b00      	cmp	r3, #0
 801a912:	d011      	beq.n	801a938 <lv_draw_sw_transform+0x394>
            ys_ups = ys_ups_start + ((ys_step_256_original * y) >> 8);
 801a914:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 801a918:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 801a91c:	fb02 f303 	mul.w	r3, r2, r3
 801a920:	121b      	asrs	r3, r3, #8
 801a922:	f8d7 20cc 	ldr.w	r2, [r7, #204]	@ 0xcc
 801a926:	4413      	add	r3, r2
 801a928:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
            ys_step_256 = 0;
 801a92c:	2300      	movs	r3, #0
 801a92e:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 801a932:	e04f      	b.n	801a9d4 <lv_draw_sw_transform+0x430>
 801a934:	66666667 	.word	0x66666667
        }
        else {
            int32_t xs1_ups, ys1_ups, xs2_ups, ys2_ups;
            transform_point_upscaled(&tr_dsc, dest_area->x1, dest_area->y1 + y, &xs1_ups, &ys1_ups);
 801a938:	68bb      	ldr	r3, [r7, #8]
 801a93a:	6819      	ldr	r1, [r3, #0]
 801a93c:	68bb      	ldr	r3, [r7, #8]
 801a93e:	685a      	ldr	r2, [r3, #4]
 801a940:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801a944:	441a      	add	r2, r3
 801a946:	f107 0420 	add.w	r4, r7, #32
 801a94a:	f107 0044 	add.w	r0, r7, #68	@ 0x44
 801a94e:	f107 031c 	add.w	r3, r7, #28
 801a952:	9300      	str	r3, [sp, #0]
 801a954:	4623      	mov	r3, r4
 801a956:	f000 ff47 	bl	801b7e8 <transform_point_upscaled>
            transform_point_upscaled(&tr_dsc, dest_area->x2, dest_area->y1 + y, &xs2_ups, &ys2_ups);
 801a95a:	68bb      	ldr	r3, [r7, #8]
 801a95c:	6899      	ldr	r1, [r3, #8]
 801a95e:	68bb      	ldr	r3, [r7, #8]
 801a960:	685a      	ldr	r2, [r3, #4]
 801a962:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801a966:	441a      	add	r2, r3
 801a968:	f107 0418 	add.w	r4, r7, #24
 801a96c:	f107 0044 	add.w	r0, r7, #68	@ 0x44
 801a970:	f107 0314 	add.w	r3, r7, #20
 801a974:	9300      	str	r3, [sp, #0]
 801a976:	4623      	mov	r3, r4
 801a978:	f000 ff36 	bl	801b7e8 <transform_point_upscaled>

            int32_t xs_diff = xs2_ups - xs1_ups;
 801a97c:	69ba      	ldr	r2, [r7, #24]
 801a97e:	6a3b      	ldr	r3, [r7, #32]
 801a980:	1ad3      	subs	r3, r2, r3
 801a982:	67fb      	str	r3, [r7, #124]	@ 0x7c
            int32_t ys_diff = ys2_ups - ys1_ups;
 801a984:	697a      	ldr	r2, [r7, #20]
 801a986:	69fb      	ldr	r3, [r7, #28]
 801a988:	1ad3      	subs	r3, r2, r3
 801a98a:	67bb      	str	r3, [r7, #120]	@ 0x78
            xs_step_256 = 0;
 801a98c:	2300      	movs	r3, #0
 801a98e:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
            ys_step_256 = 0;
 801a992:	2300      	movs	r3, #0
 801a994:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
            if(dest_w > 1) {
 801a998:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801a99c:	2b01      	cmp	r3, #1
 801a99e:	dd11      	ble.n	801a9c4 <lv_draw_sw_transform+0x420>
                xs_step_256 = (256 * xs_diff) / (dest_w - 1);
 801a9a0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801a9a2:	021a      	lsls	r2, r3, #8
 801a9a4:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801a9a8:	3b01      	subs	r3, #1
 801a9aa:	fb92 f3f3 	sdiv	r3, r2, r3
 801a9ae:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
                ys_step_256 = (256 * ys_diff) / (dest_w - 1);
 801a9b2:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801a9b4:	021a      	lsls	r2, r3, #8
 801a9b6:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801a9ba:	3b01      	subs	r3, #1
 801a9bc:	fb92 f3f3 	sdiv	r3, r2, r3
 801a9c0:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
            }

            xs_ups = xs1_ups + 0x80;
 801a9c4:	6a3b      	ldr	r3, [r7, #32]
 801a9c6:	3380      	adds	r3, #128	@ 0x80
 801a9c8:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
            ys_ups = ys1_ups + 0x80;
 801a9cc:	69fb      	ldr	r3, [r7, #28]
 801a9ce:	3380      	adds	r3, #128	@ 0x80
 801a9d0:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
        }

        switch(src_cf) {
 801a9d4:	f897 3100 	ldrb.w	r3, [r7, #256]	@ 0x100
 801a9d8:	3b0e      	subs	r3, #14
 801a9da:	2b06      	cmp	r3, #6
 801a9dc:	f200 80d4 	bhi.w	801ab88 <lv_draw_sw_transform+0x5e4>
 801a9e0:	a201      	add	r2, pc, #4	@ (adr r2, 801a9e8 <lv_draw_sw_transform+0x444>)
 801a9e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a9e6:	bf00      	nop
 801a9e8:	0801aa85 	.word	0x0801aa85
 801a9ec:	0801aa45 	.word	0x0801aa45
 801a9f0:	0801aac1 	.word	0x0801aac1
 801a9f4:	0801aa05 	.word	0x0801aa05
 801a9f8:	0801aafd 	.word	0x0801aafd
 801a9fc:	0801ab89 	.word	0x0801ab89
 801aa00:	0801ab43 	.word	0x0801ab43
            case LV_COLOR_FORMAT_XRGB8888:
                transform_rgb888(src_buf, src_w, src_h, src_stride, xs_ups, ys_ups, xs_step_256, ys_step_256, dest_w, dest_buf, aa,
 801aa04:	2304      	movs	r3, #4
 801aa06:	9307      	str	r3, [sp, #28]
 801aa08:	f897 3093 	ldrb.w	r3, [r7, #147]	@ 0x93
 801aa0c:	9306      	str	r3, [sp, #24]
 801aa0e:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801aa12:	9305      	str	r3, [sp, #20]
 801aa14:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801aa18:	9304      	str	r3, [sp, #16]
 801aa1a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801aa1e:	9303      	str	r3, [sp, #12]
 801aa20:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801aa24:	9302      	str	r3, [sp, #8]
 801aa26:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801aa2a:	9301      	str	r3, [sp, #4]
 801aa2c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801aa30:	9300      	str	r3, [sp, #0]
 801aa32:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801aa36:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 801aa3a:	6839      	ldr	r1, [r7, #0]
 801aa3c:	6878      	ldr	r0, [r7, #4]
 801aa3e:	f000 f8c7 	bl	801abd0 <transform_rgb888>
                                 4);
                break;
 801aa42:	e0a2      	b.n	801ab8a <lv_draw_sw_transform+0x5e6>
            case LV_COLOR_FORMAT_RGB888:
                transform_rgb888(src_buf, src_w, src_h, src_stride, xs_ups, ys_ups, xs_step_256, ys_step_256, dest_w, dest_buf, aa,
 801aa44:	2303      	movs	r3, #3
 801aa46:	9307      	str	r3, [sp, #28]
 801aa48:	f897 3093 	ldrb.w	r3, [r7, #147]	@ 0x93
 801aa4c:	9306      	str	r3, [sp, #24]
 801aa4e:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801aa52:	9305      	str	r3, [sp, #20]
 801aa54:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801aa58:	9304      	str	r3, [sp, #16]
 801aa5a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801aa5e:	9303      	str	r3, [sp, #12]
 801aa60:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801aa64:	9302      	str	r3, [sp, #8]
 801aa66:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801aa6a:	9301      	str	r3, [sp, #4]
 801aa6c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801aa70:	9300      	str	r3, [sp, #0]
 801aa72:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801aa76:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 801aa7a:	6839      	ldr	r1, [r7, #0]
 801aa7c:	6878      	ldr	r0, [r7, #4]
 801aa7e:	f000 f8a7 	bl	801abd0 <transform_rgb888>
                                 3);
                break;
 801aa82:	e082      	b.n	801ab8a <lv_draw_sw_transform+0x5e6>
            case LV_COLOR_FORMAT_A8:
                transform_a8(src_buf, src_w, src_h, src_stride, xs_ups, ys_ups, xs_step_256, ys_step_256, dest_w, dest_buf, aa);
 801aa84:	f897 3093 	ldrb.w	r3, [r7, #147]	@ 0x93
 801aa88:	9306      	str	r3, [sp, #24]
 801aa8a:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801aa8e:	9305      	str	r3, [sp, #20]
 801aa90:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801aa94:	9304      	str	r3, [sp, #16]
 801aa96:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801aa9a:	9303      	str	r3, [sp, #12]
 801aa9c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801aaa0:	9302      	str	r3, [sp, #8]
 801aaa2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801aaa6:	9301      	str	r3, [sp, #4]
 801aaa8:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801aaac:	9300      	str	r3, [sp, #0]
 801aaae:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801aab2:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 801aab6:	6839      	ldr	r1, [r7, #0]
 801aab8:	6878      	ldr	r0, [r7, #4]
 801aaba:	f000 fd6d 	bl	801b598 <transform_a8>
                break;
 801aabe:	e064      	b.n	801ab8a <lv_draw_sw_transform+0x5e6>
            case LV_COLOR_FORMAT_ARGB8888:
                transform_argb8888(src_buf, src_w, src_h, src_stride, xs_ups, ys_ups, xs_step_256, ys_step_256, dest_w, dest_buf,
 801aac0:	f897 3093 	ldrb.w	r3, [r7, #147]	@ 0x93
 801aac4:	9306      	str	r3, [sp, #24]
 801aac6:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801aaca:	9305      	str	r3, [sp, #20]
 801aacc:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801aad0:	9304      	str	r3, [sp, #16]
 801aad2:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801aad6:	9303      	str	r3, [sp, #12]
 801aad8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801aadc:	9302      	str	r3, [sp, #8]
 801aade:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801aae2:	9301      	str	r3, [sp, #4]
 801aae4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801aae8:	9300      	str	r3, [sp, #0]
 801aaea:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801aaee:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 801aaf2:	6839      	ldr	r1, [r7, #0]
 801aaf4:	6878      	ldr	r0, [r7, #4]
 801aaf6:	f000 f9e1 	bl	801aebc <transform_argb8888>
                                   aa);
                break;
 801aafa:	e046      	b.n	801ab8a <lv_draw_sw_transform+0x5e6>
            case LV_COLOR_FORMAT_RGB565:
                transform_rgb565a8(src_buf, src_w, src_h, src_stride, xs_ups, ys_ups, xs_step_256, ys_step_256, dest_w, dest_buf,
 801aafc:	f897 3093 	ldrb.w	r3, [r7, #147]	@ 0x93
 801ab00:	9308      	str	r3, [sp, #32]
 801ab02:	2300      	movs	r3, #0
 801ab04:	9307      	str	r3, [sp, #28]
 801ab06:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801ab0a:	9306      	str	r3, [sp, #24]
 801ab0c:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801ab10:	9305      	str	r3, [sp, #20]
 801ab12:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ab16:	9304      	str	r3, [sp, #16]
 801ab18:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801ab1c:	9303      	str	r3, [sp, #12]
 801ab1e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801ab22:	9302      	str	r3, [sp, #8]
 801ab24:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801ab28:	9301      	str	r3, [sp, #4]
 801ab2a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801ab2e:	9300      	str	r3, [sp, #0]
 801ab30:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801ab34:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 801ab38:	6839      	ldr	r1, [r7, #0]
 801ab3a:	6878      	ldr	r0, [r7, #4]
 801ab3c:	f000 fb6a 	bl	801b214 <transform_rgb565a8>
                                   alpha_buf, false, aa);
                break;
 801ab40:	e023      	b.n	801ab8a <lv_draw_sw_transform+0x5e6>
            case LV_COLOR_FORMAT_RGB565A8:
                transform_rgb565a8(src_buf, src_w, src_h, src_stride, xs_ups, ys_ups, xs_step_256, ys_step_256, dest_w,
 801ab42:	f897 3093 	ldrb.w	r3, [r7, #147]	@ 0x93
 801ab46:	9308      	str	r3, [sp, #32]
 801ab48:	2301      	movs	r3, #1
 801ab4a:	9307      	str	r3, [sp, #28]
 801ab4c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801ab50:	9306      	str	r3, [sp, #24]
 801ab52:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 801ab56:	9305      	str	r3, [sp, #20]
 801ab58:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 801ab5c:	9304      	str	r3, [sp, #16]
 801ab5e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 801ab62:	9303      	str	r3, [sp, #12]
 801ab64:	f8d7 30c4 	ldr.w	r3, [r7, #196]	@ 0xc4
 801ab68:	9302      	str	r3, [sp, #8]
 801ab6a:	f8d7 30d0 	ldr.w	r3, [r7, #208]	@ 0xd0
 801ab6e:	9301      	str	r3, [sp, #4]
 801ab70:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 801ab74:	9300      	str	r3, [sp, #0]
 801ab76:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 801ab7a:	f8d7 20f0 	ldr.w	r2, [r7, #240]	@ 0xf0
 801ab7e:	6839      	ldr	r1, [r7, #0]
 801ab80:	6878      	ldr	r0, [r7, #4]
 801ab82:	f000 fb47 	bl	801b214 <transform_rgb565a8>
                                   (uint16_t *)dest_buf,
                                   alpha_buf, true, aa);
                break;
 801ab86:	e000      	b.n	801ab8a <lv_draw_sw_transform+0x5e6>
            default:
                break;
 801ab88:	bf00      	nop
        }

        dest_buf = (uint8_t *)dest_buf + dest_stride;
 801ab8a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801ab8e:	f8d7 2104 	ldr.w	r2, [r7, #260]	@ 0x104
 801ab92:	4413      	add	r3, r2
 801ab94:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
        if(alpha_buf) alpha_buf += dest_stride_a8;
 801ab98:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801ab9c:	2b00      	cmp	r3, #0
 801ab9e:	d006      	beq.n	801abae <lv_draw_sw_transform+0x60a>
 801aba0:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 801aba4:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 801aba8:	4413      	add	r3, r2
 801abaa:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    for(y = 0; y < dest_h; y++) {
 801abae:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 801abb2:	3301      	adds	r3, #1
 801abb4:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 801abb8:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 801abbc:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 801abc0:	429a      	cmp	r2, r3
 801abc2:	f6ff aea0 	blt.w	801a906 <lv_draw_sw_transform+0x362>
    }
}
 801abc6:	bf00      	nop
 801abc8:	bf00      	nop
 801abca:	37e4      	adds	r7, #228	@ 0xe4
 801abcc:	46bd      	mov	sp, r7
 801abce:	bd90      	pop	{r4, r7, pc}

0801abd0 <transform_rgb888>:
 **********************/

static void transform_rgb888(const uint8_t * src, int32_t src_w, int32_t src_h, int32_t src_stride,
                             int32_t xs_ups, int32_t ys_ups, int32_t xs_step, int32_t ys_step,
                             int32_t x_end, uint8_t * dest_buf, bool aa, uint32_t px_size)
{
 801abd0:	b590      	push	{r4, r7, lr}
 801abd2:	b095      	sub	sp, #84	@ 0x54
 801abd4:	af00      	add	r7, sp, #0
 801abd6:	60f8      	str	r0, [r7, #12]
 801abd8:	60b9      	str	r1, [r7, #8]
 801abda:	607a      	str	r2, [r7, #4]
 801abdc:	603b      	str	r3, [r7, #0]
    int32_t xs_ups_start = xs_ups;
 801abde:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801abe0:	63bb      	str	r3, [r7, #56]	@ 0x38
    int32_t ys_ups_start = ys_ups;
 801abe2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801abe4:	637b      	str	r3, [r7, #52]	@ 0x34
    lv_color32_t * dest_c32 = (lv_color32_t *) dest_buf;
 801abe6:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801abe8:	633b      	str	r3, [r7, #48]	@ 0x30

    int32_t x;
    for(x = 0; x < x_end; x++) {
 801abea:	2300      	movs	r3, #0
 801abec:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801abee:	e15b      	b.n	801aea8 <transform_rgb888+0x2d8>
        xs_ups = xs_ups_start + ((xs_step * x) >> 8);
 801abf0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801abf2:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801abf4:	fb02 f303 	mul.w	r3, r2, r3
 801abf8:	121b      	asrs	r3, r3, #8
 801abfa:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801abfc:	4413      	add	r3, r2
 801abfe:	663b      	str	r3, [r7, #96]	@ 0x60
        ys_ups = ys_ups_start + ((ys_step * x) >> 8);
 801ac00:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801ac02:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801ac04:	fb02 f303 	mul.w	r3, r2, r3
 801ac08:	121b      	asrs	r3, r3, #8
 801ac0a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801ac0c:	4413      	add	r3, r2
 801ac0e:	667b      	str	r3, [r7, #100]	@ 0x64

        int32_t xs_int = xs_ups >> 8;
 801ac10:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801ac12:	121b      	asrs	r3, r3, #8
 801ac14:	62fb      	str	r3, [r7, #44]	@ 0x2c
        int32_t ys_int = ys_ups >> 8;
 801ac16:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801ac18:	121b      	asrs	r3, r3, #8
 801ac1a:	62bb      	str	r3, [r7, #40]	@ 0x28

        /*Fully out of the image*/
        if(xs_int < 0 || xs_int >= src_w || ys_int < 0 || ys_int >= src_h) {
 801ac1c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ac1e:	2b00      	cmp	r3, #0
 801ac20:	db0a      	blt.n	801ac38 <transform_rgb888+0x68>
 801ac22:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801ac24:	68bb      	ldr	r3, [r7, #8]
 801ac26:	429a      	cmp	r2, r3
 801ac28:	da06      	bge.n	801ac38 <transform_rgb888+0x68>
 801ac2a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ac2c:	2b00      	cmp	r3, #0
 801ac2e:	db03      	blt.n	801ac38 <transform_rgb888+0x68>
 801ac30:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801ac32:	687b      	ldr	r3, [r7, #4]
 801ac34:	429a      	cmp	r2, r3
 801ac36:	db06      	blt.n	801ac46 <transform_rgb888+0x76>
            dest_c32[x].alpha = 0x00;
 801ac38:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ac3a:	009b      	lsls	r3, r3, #2
 801ac3c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801ac3e:	4413      	add	r3, r2
 801ac40:	2200      	movs	r2, #0
 801ac42:	70da      	strb	r2, [r3, #3]
            continue;
 801ac44:	e12d      	b.n	801aea2 <transform_rgb888+0x2d2>
        }

        /*Get the direction the hor and ver neighbor
         *`fract` will be in range of 0x00..0xFF and `next` (+/-1) indicates the direction*/
        int32_t xs_fract = xs_ups & 0xFF;
 801ac46:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801ac48:	b2db      	uxtb	r3, r3
 801ac4a:	64bb      	str	r3, [r7, #72]	@ 0x48
        int32_t ys_fract = ys_ups & 0xFF;
 801ac4c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801ac4e:	b2db      	uxtb	r3, r3
 801ac50:	647b      	str	r3, [r7, #68]	@ 0x44

        int32_t x_next;
        int32_t y_next;
        if(xs_fract < 0x80) {
 801ac52:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801ac54:	2b7f      	cmp	r3, #127	@ 0x7f
 801ac56:	dc07      	bgt.n	801ac68 <transform_rgb888+0x98>
            x_next = -1;
 801ac58:	f04f 33ff 	mov.w	r3, #4294967295
 801ac5c:	643b      	str	r3, [r7, #64]	@ 0x40
            xs_fract = 0x7F - xs_fract;
 801ac5e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801ac60:	f1c3 037f 	rsb	r3, r3, #127	@ 0x7f
 801ac64:	64bb      	str	r3, [r7, #72]	@ 0x48
 801ac66:	e004      	b.n	801ac72 <transform_rgb888+0xa2>
        }
        else {
            x_next = 1;
 801ac68:	2301      	movs	r3, #1
 801ac6a:	643b      	str	r3, [r7, #64]	@ 0x40
            xs_fract = xs_fract - 0x80;
 801ac6c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801ac6e:	3b80      	subs	r3, #128	@ 0x80
 801ac70:	64bb      	str	r3, [r7, #72]	@ 0x48
        }
        if(ys_fract < 0x80) {
 801ac72:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ac74:	2b7f      	cmp	r3, #127	@ 0x7f
 801ac76:	dc07      	bgt.n	801ac88 <transform_rgb888+0xb8>
            y_next = -1;
 801ac78:	f04f 33ff 	mov.w	r3, #4294967295
 801ac7c:	63fb      	str	r3, [r7, #60]	@ 0x3c
            ys_fract = 0x7F - ys_fract;
 801ac7e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ac80:	f1c3 037f 	rsb	r3, r3, #127	@ 0x7f
 801ac84:	647b      	str	r3, [r7, #68]	@ 0x44
 801ac86:	e004      	b.n	801ac92 <transform_rgb888+0xc2>
        }
        else {
            y_next = 1;
 801ac88:	2301      	movs	r3, #1
 801ac8a:	63fb      	str	r3, [r7, #60]	@ 0x3c
            ys_fract = ys_fract - 0x80;
 801ac8c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ac8e:	3b80      	subs	r3, #128	@ 0x80
 801ac90:	647b      	str	r3, [r7, #68]	@ 0x44
        }

        const uint8_t * src_u8 = &src[ys_int * src_stride + xs_int * px_size];
 801ac92:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ac94:	683a      	ldr	r2, [r7, #0]
 801ac96:	fb02 f303 	mul.w	r3, r2, r3
 801ac9a:	4619      	mov	r1, r3
 801ac9c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ac9e:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801aca0:	fb02 f303 	mul.w	r3, r2, r3
 801aca4:	440b      	add	r3, r1
 801aca6:	68fa      	ldr	r2, [r7, #12]
 801aca8:	4413      	add	r3, r2
 801acaa:	627b      	str	r3, [r7, #36]	@ 0x24

        dest_c32[x].red = src_u8[2];
 801acac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801acae:	1c9a      	adds	r2, r3, #2
 801acb0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801acb2:	009b      	lsls	r3, r3, #2
 801acb4:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 801acb6:	440b      	add	r3, r1
 801acb8:	7812      	ldrb	r2, [r2, #0]
 801acba:	709a      	strb	r2, [r3, #2]
        dest_c32[x].green = src_u8[1];
 801acbc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801acbe:	1c5a      	adds	r2, r3, #1
 801acc0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801acc2:	009b      	lsls	r3, r3, #2
 801acc4:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 801acc6:	440b      	add	r3, r1
 801acc8:	7812      	ldrb	r2, [r2, #0]
 801acca:	705a      	strb	r2, [r3, #1]
        dest_c32[x].blue = src_u8[0];
 801accc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801acce:	009b      	lsls	r3, r3, #2
 801acd0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801acd2:	4413      	add	r3, r2
 801acd4:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801acd6:	7812      	ldrb	r2, [r2, #0]
 801acd8:	701a      	strb	r2, [r3, #0]
        dest_c32[x].alpha = 0xff;
 801acda:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801acdc:	009b      	lsls	r3, r3, #2
 801acde:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801ace0:	4413      	add	r3, r2
 801ace2:	22ff      	movs	r2, #255	@ 0xff
 801ace4:	70da      	strb	r2, [r3, #3]

        if(aa &&
 801ace6:	f897 3078 	ldrb.w	r3, [r7, #120]	@ 0x78
 801acea:	2b00      	cmp	r3, #0
 801acec:	f000 809e 	beq.w	801ae2c <transform_rgb888+0x25c>
           xs_int + x_next >= 0 &&
 801acf0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801acf2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801acf4:	4413      	add	r3, r2
        if(aa &&
 801acf6:	2b00      	cmp	r3, #0
 801acf8:	f2c0 8098 	blt.w	801ae2c <transform_rgb888+0x25c>
           xs_int + x_next <= src_w - 1 &&
 801acfc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801acfe:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801ad00:	4413      	add	r3, r2
           xs_int + x_next >= 0 &&
 801ad02:	68ba      	ldr	r2, [r7, #8]
 801ad04:	429a      	cmp	r2, r3
 801ad06:	f340 8091 	ble.w	801ae2c <transform_rgb888+0x25c>
           ys_int + y_next >= 0 &&
 801ad0a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801ad0c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ad0e:	4413      	add	r3, r2
           xs_int + x_next <= src_w - 1 &&
 801ad10:	2b00      	cmp	r3, #0
 801ad12:	f2c0 808b 	blt.w	801ae2c <transform_rgb888+0x25c>
           ys_int + y_next <= src_h - 1) {
 801ad16:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801ad18:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ad1a:	4413      	add	r3, r2
           ys_int + y_next >= 0 &&
 801ad1c:	687a      	ldr	r2, [r7, #4]
 801ad1e:	429a      	cmp	r2, r3
 801ad20:	f340 8084 	ble.w	801ae2c <transform_rgb888+0x25c>
            const uint8_t * px_hor_u8 = src_u8 + (int32_t)(x_next * px_size);
 801ad24:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801ad26:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801ad28:	fb02 f303 	mul.w	r3, r2, r3
 801ad2c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801ad2e:	4413      	add	r3, r2
 801ad30:	623b      	str	r3, [r7, #32]
            lv_color32_t px_hor;
            px_hor.red = px_hor_u8[2];
 801ad32:	6a3b      	ldr	r3, [r7, #32]
 801ad34:	3302      	adds	r3, #2
 801ad36:	781b      	ldrb	r3, [r3, #0]
 801ad38:	75bb      	strb	r3, [r7, #22]
            px_hor.green = px_hor_u8[1];
 801ad3a:	6a3b      	ldr	r3, [r7, #32]
 801ad3c:	3301      	adds	r3, #1
 801ad3e:	781b      	ldrb	r3, [r3, #0]
 801ad40:	757b      	strb	r3, [r7, #21]
            px_hor.blue = px_hor_u8[0];
 801ad42:	6a3b      	ldr	r3, [r7, #32]
 801ad44:	781b      	ldrb	r3, [r3, #0]
 801ad46:	753b      	strb	r3, [r7, #20]
            px_hor.alpha = 0xff;
 801ad48:	23ff      	movs	r3, #255	@ 0xff
 801ad4a:	75fb      	strb	r3, [r7, #23]

            const uint8_t * px_ver_u8 = src_u8 + (int32_t)(y_next * src_stride);
 801ad4c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ad4e:	683a      	ldr	r2, [r7, #0]
 801ad50:	fb02 f303 	mul.w	r3, r2, r3
 801ad54:	461a      	mov	r2, r3
 801ad56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ad58:	4413      	add	r3, r2
 801ad5a:	61fb      	str	r3, [r7, #28]
            lv_color32_t px_ver;
            px_ver.red = px_ver_u8[2];
 801ad5c:	69fb      	ldr	r3, [r7, #28]
 801ad5e:	3302      	adds	r3, #2
 801ad60:	781b      	ldrb	r3, [r3, #0]
 801ad62:	74bb      	strb	r3, [r7, #18]
            px_ver.green = px_ver_u8[1];
 801ad64:	69fb      	ldr	r3, [r7, #28]
 801ad66:	3301      	adds	r3, #1
 801ad68:	781b      	ldrb	r3, [r3, #0]
 801ad6a:	747b      	strb	r3, [r7, #17]
            px_ver.blue = px_ver_u8[0];
 801ad6c:	69fb      	ldr	r3, [r7, #28]
 801ad6e:	781b      	ldrb	r3, [r3, #0]
 801ad70:	743b      	strb	r3, [r7, #16]
            px_ver.alpha = 0xff;
 801ad72:	23ff      	movs	r3, #255	@ 0xff
 801ad74:	74fb      	strb	r3, [r7, #19]

            if(!lv_color32_eq(dest_c32[x], px_ver)) {
 801ad76:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ad78:	009b      	lsls	r3, r3, #2
 801ad7a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801ad7c:	4413      	add	r3, r2
 801ad7e:	681a      	ldr	r2, [r3, #0]
 801ad80:	4613      	mov	r3, r2
 801ad82:	6939      	ldr	r1, [r7, #16]
 801ad84:	4618      	mov	r0, r3
 801ad86:	f7ff fb65 	bl	801a454 <lv_color32_eq>
 801ad8a:	4603      	mov	r3, r0
 801ad8c:	f083 0301 	eor.w	r3, r3, #1
 801ad90:	b2db      	uxtb	r3, r3
 801ad92:	2b00      	cmp	r3, #0
 801ad94:	d01c      	beq.n	801add0 <transform_rgb888+0x200>
                px_ver.alpha = ys_fract;
 801ad96:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ad98:	b2db      	uxtb	r3, r3
 801ad9a:	74fb      	strb	r3, [r7, #19]
                dest_c32[x] = lv_color_mix32(px_ver, dest_c32[x]);
 801ad9c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ad9e:	009b      	lsls	r3, r3, #2
 801ada0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801ada2:	4413      	add	r3, r2
 801ada4:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801ada6:	0092      	lsls	r2, r2, #2
 801ada8:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 801adaa:	188c      	adds	r4, r1, r2
 801adac:	681a      	ldr	r2, [r3, #0]
 801adae:	4613      	mov	r3, r2
 801adb0:	4619      	mov	r1, r3
 801adb2:	6938      	ldr	r0, [r7, #16]
 801adb4:	f7ff fba4 	bl	801a500 <lv_color_mix32>
 801adb8:	4603      	mov	r3, r0
 801adba:	461a      	mov	r2, r3
 801adbc:	7022      	strb	r2, [r4, #0]
 801adbe:	f3c3 2207 	ubfx	r2, r3, #8, #8
 801adc2:	7062      	strb	r2, [r4, #1]
 801adc4:	f3c3 4207 	ubfx	r2, r3, #16, #8
 801adc8:	70a2      	strb	r2, [r4, #2]
 801adca:	f3c3 6307 	ubfx	r3, r3, #24, #8
 801adce:	70e3      	strb	r3, [r4, #3]
            }

            if(!lv_color32_eq(dest_c32[x], px_hor)) {
 801add0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801add2:	009b      	lsls	r3, r3, #2
 801add4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801add6:	4413      	add	r3, r2
 801add8:	681a      	ldr	r2, [r3, #0]
 801adda:	4613      	mov	r3, r2
 801addc:	6979      	ldr	r1, [r7, #20]
 801adde:	4618      	mov	r0, r3
 801ade0:	f7ff fb38 	bl	801a454 <lv_color32_eq>
 801ade4:	4603      	mov	r3, r0
 801ade6:	f083 0301 	eor.w	r3, r3, #1
 801adea:	b2db      	uxtb	r3, r3
 801adec:	2b00      	cmp	r3, #0
 801adee:	d057      	beq.n	801aea0 <transform_rgb888+0x2d0>
                px_hor.alpha = xs_fract;
 801adf0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801adf2:	b2db      	uxtb	r3, r3
 801adf4:	75fb      	strb	r3, [r7, #23]
                dest_c32[x] = lv_color_mix32(px_hor, dest_c32[x]);
 801adf6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801adf8:	009b      	lsls	r3, r3, #2
 801adfa:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801adfc:	4413      	add	r3, r2
 801adfe:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801ae00:	0092      	lsls	r2, r2, #2
 801ae02:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 801ae04:	188c      	adds	r4, r1, r2
 801ae06:	681a      	ldr	r2, [r3, #0]
 801ae08:	4613      	mov	r3, r2
 801ae0a:	4619      	mov	r1, r3
 801ae0c:	6978      	ldr	r0, [r7, #20]
 801ae0e:	f7ff fb77 	bl	801a500 <lv_color_mix32>
 801ae12:	4603      	mov	r3, r0
 801ae14:	461a      	mov	r2, r3
 801ae16:	7022      	strb	r2, [r4, #0]
 801ae18:	f3c3 2207 	ubfx	r2, r3, #8, #8
 801ae1c:	7062      	strb	r2, [r4, #1]
 801ae1e:	f3c3 4207 	ubfx	r2, r3, #16, #8
 801ae22:	70a2      	strb	r2, [r4, #2]
 801ae24:	f3c3 6307 	ubfx	r3, r3, #24, #8
 801ae28:	70e3      	strb	r3, [r4, #3]
           ys_int + y_next <= src_h - 1) {
 801ae2a:	e039      	b.n	801aea0 <transform_rgb888+0x2d0>
            }
        }
        /*Partially out of the image*/
        else {
            lv_opa_t a = 0xff;
 801ae2c:	23ff      	movs	r3, #255	@ 0xff
 801ae2e:	76fb      	strb	r3, [r7, #27]

            if((xs_int == 0 && x_next < 0) || (xs_int == src_w - 1 && x_next > 0))  {
 801ae30:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ae32:	2b00      	cmp	r3, #0
 801ae34:	d102      	bne.n	801ae3c <transform_rgb888+0x26c>
 801ae36:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801ae38:	2b00      	cmp	r3, #0
 801ae3a:	db07      	blt.n	801ae4c <transform_rgb888+0x27c>
 801ae3c:	68bb      	ldr	r3, [r7, #8]
 801ae3e:	3b01      	subs	r3, #1
 801ae40:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801ae42:	429a      	cmp	r2, r3
 801ae44:	d110      	bne.n	801ae68 <transform_rgb888+0x298>
 801ae46:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801ae48:	2b00      	cmp	r3, #0
 801ae4a:	dd0d      	ble.n	801ae68 <transform_rgb888+0x298>
                dest_c32[x].alpha = (a * (0xFF - xs_fract)) >> 8;
 801ae4c:	7efb      	ldrb	r3, [r7, #27]
 801ae4e:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801ae50:	f1c2 02ff 	rsb	r2, r2, #255	@ 0xff
 801ae54:	fb02 f303 	mul.w	r3, r2, r3
 801ae58:	1219      	asrs	r1, r3, #8
 801ae5a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ae5c:	009b      	lsls	r3, r3, #2
 801ae5e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801ae60:	4413      	add	r3, r2
 801ae62:	b2ca      	uxtb	r2, r1
 801ae64:	70da      	strb	r2, [r3, #3]
 801ae66:	e01c      	b.n	801aea2 <transform_rgb888+0x2d2>
            }
            else if((ys_int == 0 && y_next < 0) || (ys_int == src_h - 1 && y_next > 0))  {
 801ae68:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ae6a:	2b00      	cmp	r3, #0
 801ae6c:	d102      	bne.n	801ae74 <transform_rgb888+0x2a4>
 801ae6e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ae70:	2b00      	cmp	r3, #0
 801ae72:	db07      	blt.n	801ae84 <transform_rgb888+0x2b4>
 801ae74:	687b      	ldr	r3, [r7, #4]
 801ae76:	3b01      	subs	r3, #1
 801ae78:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801ae7a:	429a      	cmp	r2, r3
 801ae7c:	d111      	bne.n	801aea2 <transform_rgb888+0x2d2>
 801ae7e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ae80:	2b00      	cmp	r3, #0
 801ae82:	dd0e      	ble.n	801aea2 <transform_rgb888+0x2d2>
                dest_c32[x].alpha = (a * (0xFF - ys_fract)) >> 8;
 801ae84:	7efb      	ldrb	r3, [r7, #27]
 801ae86:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801ae88:	f1c2 02ff 	rsb	r2, r2, #255	@ 0xff
 801ae8c:	fb02 f303 	mul.w	r3, r2, r3
 801ae90:	1219      	asrs	r1, r3, #8
 801ae92:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ae94:	009b      	lsls	r3, r3, #2
 801ae96:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801ae98:	4413      	add	r3, r2
 801ae9a:	b2ca      	uxtb	r2, r1
 801ae9c:	70da      	strb	r2, [r3, #3]
 801ae9e:	e000      	b.n	801aea2 <transform_rgb888+0x2d2>
           ys_int + y_next <= src_h - 1) {
 801aea0:	bf00      	nop
    for(x = 0; x < x_end; x++) {
 801aea2:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801aea4:	3301      	adds	r3, #1
 801aea6:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801aea8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801aeaa:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801aeac:	429a      	cmp	r2, r3
 801aeae:	f6ff ae9f 	blt.w	801abf0 <transform_rgb888+0x20>
            }
        }
    }
}
 801aeb2:	bf00      	nop
 801aeb4:	bf00      	nop
 801aeb6:	3754      	adds	r7, #84	@ 0x54
 801aeb8:	46bd      	mov	sp, r7
 801aeba:	bd90      	pop	{r4, r7, pc}

0801aebc <transform_argb8888>:

static void transform_argb8888(const uint8_t * src, int32_t src_w, int32_t src_h, int32_t src_stride,
                               int32_t xs_ups, int32_t ys_ups, int32_t xs_step, int32_t ys_step,
                               int32_t x_end, uint8_t * dest_buf, bool aa)
{
 801aebc:	b590      	push	{r4, r7, lr}
 801aebe:	b093      	sub	sp, #76	@ 0x4c
 801aec0:	af00      	add	r7, sp, #0
 801aec2:	60f8      	str	r0, [r7, #12]
 801aec4:	60b9      	str	r1, [r7, #8]
 801aec6:	607a      	str	r2, [r7, #4]
 801aec8:	603b      	str	r3, [r7, #0]
    //    lv_memzero(dest_buf, x_end * 4);
    int32_t xs_ups_start = xs_ups;
 801aeca:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801aecc:	633b      	str	r3, [r7, #48]	@ 0x30
    int32_t ys_ups_start = ys_ups;
 801aece:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801aed0:	62fb      	str	r3, [r7, #44]	@ 0x2c
    lv_color32_t * dest_c32 = (lv_color32_t *) dest_buf;
 801aed2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801aed4:	62bb      	str	r3, [r7, #40]	@ 0x28

    int32_t x;
    for(x = 0; x < x_end; x++) {
 801aed6:	2300      	movs	r3, #0
 801aed8:	647b      	str	r3, [r7, #68]	@ 0x44
 801aeda:	e191      	b.n	801b200 <transform_argb8888+0x344>
        xs_ups = xs_ups_start + ((xs_step * x) >> 8);
 801aedc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801aede:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801aee0:	fb02 f303 	mul.w	r3, r2, r3
 801aee4:	121b      	asrs	r3, r3, #8
 801aee6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801aee8:	4413      	add	r3, r2
 801aeea:	65bb      	str	r3, [r7, #88]	@ 0x58
        ys_ups = ys_ups_start + ((ys_step * x) >> 8);
 801aeec:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801aeee:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801aef0:	fb02 f303 	mul.w	r3, r2, r3
 801aef4:	121b      	asrs	r3, r3, #8
 801aef6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801aef8:	4413      	add	r3, r2
 801aefa:	65fb      	str	r3, [r7, #92]	@ 0x5c

        int32_t xs_int = xs_ups >> 8;
 801aefc:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801aefe:	121b      	asrs	r3, r3, #8
 801af00:	627b      	str	r3, [r7, #36]	@ 0x24
        int32_t ys_int = ys_ups >> 8;
 801af02:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801af04:	121b      	asrs	r3, r3, #8
 801af06:	623b      	str	r3, [r7, #32]

        /*Fully out of the image*/
        if(xs_int < 0 || xs_int >= src_w || ys_int < 0 || ys_int >= src_h) {
 801af08:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801af0a:	2b00      	cmp	r3, #0
 801af0c:	db0a      	blt.n	801af24 <transform_argb8888+0x68>
 801af0e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801af10:	68bb      	ldr	r3, [r7, #8]
 801af12:	429a      	cmp	r2, r3
 801af14:	da06      	bge.n	801af24 <transform_argb8888+0x68>
 801af16:	6a3b      	ldr	r3, [r7, #32]
 801af18:	2b00      	cmp	r3, #0
 801af1a:	db03      	blt.n	801af24 <transform_argb8888+0x68>
 801af1c:	6a3a      	ldr	r2, [r7, #32]
 801af1e:	687b      	ldr	r3, [r7, #4]
 801af20:	429a      	cmp	r2, r3
 801af22:	db06      	blt.n	801af32 <transform_argb8888+0x76>
            ((uint32_t *)dest_buf)[x] = 0x00000000;
 801af24:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801af26:	009b      	lsls	r3, r3, #2
 801af28:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801af2a:	4413      	add	r3, r2
 801af2c:	2200      	movs	r2, #0
 801af2e:	601a      	str	r2, [r3, #0]
            continue;
 801af30:	e163      	b.n	801b1fa <transform_argb8888+0x33e>
        }

        /*Get the direction the hor and ver neighbor
         *`fract` will be in range of 0x00..0xFF and `next` (+/-1) indicates the direction*/
        int32_t xs_fract = xs_ups & 0xFF;
 801af32:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801af34:	b2db      	uxtb	r3, r3
 801af36:	643b      	str	r3, [r7, #64]	@ 0x40
        int32_t ys_fract = ys_ups & 0xFF;
 801af38:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801af3a:	b2db      	uxtb	r3, r3
 801af3c:	63fb      	str	r3, [r7, #60]	@ 0x3c

        int32_t x_next;
        int32_t y_next;
        if(xs_fract < 0x80) {
 801af3e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801af40:	2b7f      	cmp	r3, #127	@ 0x7f
 801af42:	dc07      	bgt.n	801af54 <transform_argb8888+0x98>
            x_next = -1;
 801af44:	f04f 33ff 	mov.w	r3, #4294967295
 801af48:	63bb      	str	r3, [r7, #56]	@ 0x38
            xs_fract = 0x7F - xs_fract;
 801af4a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801af4c:	f1c3 037f 	rsb	r3, r3, #127	@ 0x7f
 801af50:	643b      	str	r3, [r7, #64]	@ 0x40
 801af52:	e004      	b.n	801af5e <transform_argb8888+0xa2>
        }
        else {
            x_next = 1;
 801af54:	2301      	movs	r3, #1
 801af56:	63bb      	str	r3, [r7, #56]	@ 0x38
            xs_fract = xs_fract - 0x80;
 801af58:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801af5a:	3b80      	subs	r3, #128	@ 0x80
 801af5c:	643b      	str	r3, [r7, #64]	@ 0x40
        }
        if(ys_fract < 0x80) {
 801af5e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801af60:	2b7f      	cmp	r3, #127	@ 0x7f
 801af62:	dc07      	bgt.n	801af74 <transform_argb8888+0xb8>
            y_next = -1;
 801af64:	f04f 33ff 	mov.w	r3, #4294967295
 801af68:	637b      	str	r3, [r7, #52]	@ 0x34
            ys_fract = 0x7F - ys_fract;
 801af6a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801af6c:	f1c3 037f 	rsb	r3, r3, #127	@ 0x7f
 801af70:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801af72:	e004      	b.n	801af7e <transform_argb8888+0xc2>
        }
        else {
            y_next = 1;
 801af74:	2301      	movs	r3, #1
 801af76:	637b      	str	r3, [r7, #52]	@ 0x34
            ys_fract = ys_fract - 0x80;
 801af78:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801af7a:	3b80      	subs	r3, #128	@ 0x80
 801af7c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        const lv_color32_t * src_c32 = (const lv_color32_t *)(src + ys_int * src_stride + xs_int * 4);
 801af7e:	6a3b      	ldr	r3, [r7, #32]
 801af80:	683a      	ldr	r2, [r7, #0]
 801af82:	fb02 f303 	mul.w	r3, r2, r3
 801af86:	461a      	mov	r2, r3
 801af88:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801af8a:	009b      	lsls	r3, r3, #2
 801af8c:	4413      	add	r3, r2
 801af8e:	68fa      	ldr	r2, [r7, #12]
 801af90:	4413      	add	r3, r2
 801af92:	61fb      	str	r3, [r7, #28]

        dest_c32[x] = src_c32[0];
 801af94:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801af96:	009b      	lsls	r3, r3, #2
 801af98:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801af9a:	441a      	add	r2, r3
 801af9c:	69fb      	ldr	r3, [r7, #28]
 801af9e:	681b      	ldr	r3, [r3, #0]
 801afa0:	6013      	str	r3, [r2, #0]

        if(aa &&
 801afa2:	f897 3070 	ldrb.w	r3, [r7, #112]	@ 0x70
 801afa6:	2b00      	cmp	r3, #0
 801afa8:	f000 80e4 	beq.w	801b174 <transform_argb8888+0x2b8>
           xs_int + x_next >= 0 &&
 801afac:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801afae:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801afb0:	4413      	add	r3, r2
        if(aa &&
 801afb2:	2b00      	cmp	r3, #0
 801afb4:	f2c0 80de 	blt.w	801b174 <transform_argb8888+0x2b8>
           xs_int + x_next <= src_w - 1 &&
 801afb8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801afba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801afbc:	4413      	add	r3, r2
           xs_int + x_next >= 0 &&
 801afbe:	68ba      	ldr	r2, [r7, #8]
 801afc0:	429a      	cmp	r2, r3
 801afc2:	f340 80d7 	ble.w	801b174 <transform_argb8888+0x2b8>
           ys_int + y_next >= 0 &&
 801afc6:	6a3a      	ldr	r2, [r7, #32]
 801afc8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801afca:	4413      	add	r3, r2
           xs_int + x_next <= src_w - 1 &&
 801afcc:	2b00      	cmp	r3, #0
 801afce:	f2c0 80d1 	blt.w	801b174 <transform_argb8888+0x2b8>
           ys_int + y_next <= src_h - 1) {
 801afd2:	6a3a      	ldr	r2, [r7, #32]
 801afd4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801afd6:	4413      	add	r3, r2
           ys_int + y_next >= 0 &&
 801afd8:	687a      	ldr	r2, [r7, #4]
 801afda:	429a      	cmp	r2, r3
 801afdc:	f340 80ca 	ble.w	801b174 <transform_argb8888+0x2b8>

            lv_color32_t px_hor = src_c32[x_next];
 801afe0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801afe2:	009b      	lsls	r3, r3, #2
 801afe4:	69fa      	ldr	r2, [r7, #28]
 801afe6:	441a      	add	r2, r3
 801afe8:	f107 0318 	add.w	r3, r7, #24
 801afec:	6810      	ldr	r0, [r2, #0]
 801afee:	6018      	str	r0, [r3, #0]
            lv_color32_t px_ver = *(const lv_color32_t *)((uint8_t *)src_c32 + y_next * src_stride);
 801aff0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801aff2:	683a      	ldr	r2, [r7, #0]
 801aff4:	fb02 f303 	mul.w	r3, r2, r3
 801aff8:	461a      	mov	r2, r3
 801affa:	69fb      	ldr	r3, [r7, #28]
 801affc:	441a      	add	r2, r3
 801affe:	f107 0314 	add.w	r3, r7, #20
 801b002:	6810      	ldr	r0, [r2, #0]
 801b004:	6018      	str	r0, [r3, #0]

            if(px_ver.alpha == 0) {
 801b006:	7dfb      	ldrb	r3, [r7, #23]
 801b008:	2b00      	cmp	r3, #0
 801b00a:	d112      	bne.n	801b032 <transform_argb8888+0x176>
                dest_c32[x].alpha = (dest_c32[x].alpha * (0xFF - ys_fract)) >> 8;
 801b00c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b00e:	009b      	lsls	r3, r3, #2
 801b010:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b012:	4413      	add	r3, r2
 801b014:	78db      	ldrb	r3, [r3, #3]
 801b016:	461a      	mov	r2, r3
 801b018:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b01a:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 801b01e:	fb02 f303 	mul.w	r3, r2, r3
 801b022:	1219      	asrs	r1, r3, #8
 801b024:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b026:	009b      	lsls	r3, r3, #2
 801b028:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b02a:	4413      	add	r3, r2
 801b02c:	b2ca      	uxtb	r2, r1
 801b02e:	70da      	strb	r2, [r3, #3]
 801b030:	e044      	b.n	801b0bc <transform_argb8888+0x200>
            }
            else if(!lv_color32_eq(dest_c32[x], px_ver)) {
 801b032:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b034:	009b      	lsls	r3, r3, #2
 801b036:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b038:	4413      	add	r3, r2
 801b03a:	681a      	ldr	r2, [r3, #0]
 801b03c:	4613      	mov	r3, r2
 801b03e:	6979      	ldr	r1, [r7, #20]
 801b040:	4618      	mov	r0, r3
 801b042:	f7ff fa07 	bl	801a454 <lv_color32_eq>
 801b046:	4603      	mov	r3, r0
 801b048:	f083 0301 	eor.w	r3, r3, #1
 801b04c:	b2db      	uxtb	r3, r3
 801b04e:	2b00      	cmp	r3, #0
 801b050:	d034      	beq.n	801b0bc <transform_argb8888+0x200>
                dest_c32[x].alpha = ((px_ver.alpha * ys_fract) + (dest_c32[x].alpha * (0xFF - ys_fract))) >> 8;
 801b052:	7dfb      	ldrb	r3, [r7, #23]
 801b054:	461a      	mov	r2, r3
 801b056:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b058:	fb03 f202 	mul.w	r2, r3, r2
 801b05c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b05e:	009b      	lsls	r3, r3, #2
 801b060:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801b062:	440b      	add	r3, r1
 801b064:	78db      	ldrb	r3, [r3, #3]
 801b066:	4619      	mov	r1, r3
 801b068:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b06a:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 801b06e:	fb01 f303 	mul.w	r3, r1, r3
 801b072:	4413      	add	r3, r2
 801b074:	1219      	asrs	r1, r3, #8
 801b076:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b078:	009b      	lsls	r3, r3, #2
 801b07a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b07c:	4413      	add	r3, r2
 801b07e:	b2ca      	uxtb	r2, r1
 801b080:	70da      	strb	r2, [r3, #3]
                px_ver.alpha = ys_fract;
 801b082:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b084:	b2db      	uxtb	r3, r3
 801b086:	75fb      	strb	r3, [r7, #23]
                dest_c32[x] = lv_color_mix32(px_ver, dest_c32[x]);
 801b088:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b08a:	009b      	lsls	r3, r3, #2
 801b08c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b08e:	4413      	add	r3, r2
 801b090:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801b092:	0092      	lsls	r2, r2, #2
 801b094:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801b096:	188c      	adds	r4, r1, r2
 801b098:	681a      	ldr	r2, [r3, #0]
 801b09a:	4613      	mov	r3, r2
 801b09c:	4619      	mov	r1, r3
 801b09e:	6978      	ldr	r0, [r7, #20]
 801b0a0:	f7ff fa2e 	bl	801a500 <lv_color_mix32>
 801b0a4:	4603      	mov	r3, r0
 801b0a6:	461a      	mov	r2, r3
 801b0a8:	7022      	strb	r2, [r4, #0]
 801b0aa:	f3c3 2207 	ubfx	r2, r3, #8, #8
 801b0ae:	7062      	strb	r2, [r4, #1]
 801b0b0:	f3c3 4207 	ubfx	r2, r3, #16, #8
 801b0b4:	70a2      	strb	r2, [r4, #2]
 801b0b6:	f3c3 6307 	ubfx	r3, r3, #24, #8
 801b0ba:	70e3      	strb	r3, [r4, #3]
            }

            if(px_hor.alpha == 0) {
 801b0bc:	7efb      	ldrb	r3, [r7, #27]
 801b0be:	2b00      	cmp	r3, #0
 801b0c0:	d112      	bne.n	801b0e8 <transform_argb8888+0x22c>
                dest_c32[x].alpha = (dest_c32[x].alpha * (0xFF - xs_fract)) >> 8;
 801b0c2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b0c4:	009b      	lsls	r3, r3, #2
 801b0c6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b0c8:	4413      	add	r3, r2
 801b0ca:	78db      	ldrb	r3, [r3, #3]
 801b0cc:	461a      	mov	r2, r3
 801b0ce:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b0d0:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 801b0d4:	fb02 f303 	mul.w	r3, r2, r3
 801b0d8:	1219      	asrs	r1, r3, #8
 801b0da:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b0dc:	009b      	lsls	r3, r3, #2
 801b0de:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b0e0:	4413      	add	r3, r2
 801b0e2:	b2ca      	uxtb	r2, r1
 801b0e4:	70da      	strb	r2, [r3, #3]
           ys_int + y_next <= src_h - 1) {
 801b0e6:	e087      	b.n	801b1f8 <transform_argb8888+0x33c>
            }
            else if(!lv_color32_eq(dest_c32[x], px_hor)) {
 801b0e8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b0ea:	009b      	lsls	r3, r3, #2
 801b0ec:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b0ee:	4413      	add	r3, r2
 801b0f0:	681a      	ldr	r2, [r3, #0]
 801b0f2:	4613      	mov	r3, r2
 801b0f4:	69b9      	ldr	r1, [r7, #24]
 801b0f6:	4618      	mov	r0, r3
 801b0f8:	f7ff f9ac 	bl	801a454 <lv_color32_eq>
 801b0fc:	4603      	mov	r3, r0
 801b0fe:	f083 0301 	eor.w	r3, r3, #1
 801b102:	b2db      	uxtb	r3, r3
 801b104:	2b00      	cmp	r3, #0
 801b106:	d077      	beq.n	801b1f8 <transform_argb8888+0x33c>
                dest_c32[x].alpha = ((px_hor.alpha * xs_fract) + (dest_c32[x].alpha * (0xFF - xs_fract))) >> 8;
 801b108:	7efb      	ldrb	r3, [r7, #27]
 801b10a:	461a      	mov	r2, r3
 801b10c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b10e:	fb03 f202 	mul.w	r2, r3, r2
 801b112:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b114:	009b      	lsls	r3, r3, #2
 801b116:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801b118:	440b      	add	r3, r1
 801b11a:	78db      	ldrb	r3, [r3, #3]
 801b11c:	4619      	mov	r1, r3
 801b11e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b120:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 801b124:	fb01 f303 	mul.w	r3, r1, r3
 801b128:	4413      	add	r3, r2
 801b12a:	1219      	asrs	r1, r3, #8
 801b12c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b12e:	009b      	lsls	r3, r3, #2
 801b130:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b132:	4413      	add	r3, r2
 801b134:	b2ca      	uxtb	r2, r1
 801b136:	70da      	strb	r2, [r3, #3]
                px_hor.alpha = xs_fract;
 801b138:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b13a:	b2db      	uxtb	r3, r3
 801b13c:	76fb      	strb	r3, [r7, #27]
                dest_c32[x] = lv_color_mix32(px_hor, dest_c32[x]);
 801b13e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b140:	009b      	lsls	r3, r3, #2
 801b142:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b144:	4413      	add	r3, r2
 801b146:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801b148:	0092      	lsls	r2, r2, #2
 801b14a:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801b14c:	188c      	adds	r4, r1, r2
 801b14e:	681a      	ldr	r2, [r3, #0]
 801b150:	4613      	mov	r3, r2
 801b152:	4619      	mov	r1, r3
 801b154:	69b8      	ldr	r0, [r7, #24]
 801b156:	f7ff f9d3 	bl	801a500 <lv_color_mix32>
 801b15a:	4603      	mov	r3, r0
 801b15c:	461a      	mov	r2, r3
 801b15e:	7022      	strb	r2, [r4, #0]
 801b160:	f3c3 2207 	ubfx	r2, r3, #8, #8
 801b164:	7062      	strb	r2, [r4, #1]
 801b166:	f3c3 4207 	ubfx	r2, r3, #16, #8
 801b16a:	70a2      	strb	r2, [r4, #2]
 801b16c:	f3c3 6307 	ubfx	r3, r3, #24, #8
 801b170:	70e3      	strb	r3, [r4, #3]
           ys_int + y_next <= src_h - 1) {
 801b172:	e041      	b.n	801b1f8 <transform_argb8888+0x33c>
            }
        }
        /*Partially out of the image*/
        else {
            if((xs_int == 0 && x_next < 0) || (xs_int == src_w - 1 && x_next > 0))  {
 801b174:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801b176:	2b00      	cmp	r3, #0
 801b178:	d102      	bne.n	801b180 <transform_argb8888+0x2c4>
 801b17a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b17c:	2b00      	cmp	r3, #0
 801b17e:	db07      	blt.n	801b190 <transform_argb8888+0x2d4>
 801b180:	68bb      	ldr	r3, [r7, #8]
 801b182:	3b01      	subs	r3, #1
 801b184:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801b186:	429a      	cmp	r2, r3
 801b188:	d115      	bne.n	801b1b6 <transform_argb8888+0x2fa>
 801b18a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b18c:	2b00      	cmp	r3, #0
 801b18e:	dd12      	ble.n	801b1b6 <transform_argb8888+0x2fa>
                dest_c32[x].alpha = (dest_c32[x].alpha * (0x7F - xs_fract)) >> 7;
 801b190:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b192:	009b      	lsls	r3, r3, #2
 801b194:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b196:	4413      	add	r3, r2
 801b198:	78db      	ldrb	r3, [r3, #3]
 801b19a:	461a      	mov	r2, r3
 801b19c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801b19e:	f1c3 037f 	rsb	r3, r3, #127	@ 0x7f
 801b1a2:	fb02 f303 	mul.w	r3, r2, r3
 801b1a6:	11d9      	asrs	r1, r3, #7
 801b1a8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b1aa:	009b      	lsls	r3, r3, #2
 801b1ac:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b1ae:	4413      	add	r3, r2
 801b1b0:	b2ca      	uxtb	r2, r1
 801b1b2:	70da      	strb	r2, [r3, #3]
 801b1b4:	e021      	b.n	801b1fa <transform_argb8888+0x33e>
            }
            else if((ys_int == 0 && y_next < 0) || (ys_int == src_h - 1 && y_next > 0))  {
 801b1b6:	6a3b      	ldr	r3, [r7, #32]
 801b1b8:	2b00      	cmp	r3, #0
 801b1ba:	d102      	bne.n	801b1c2 <transform_argb8888+0x306>
 801b1bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b1be:	2b00      	cmp	r3, #0
 801b1c0:	db07      	blt.n	801b1d2 <transform_argb8888+0x316>
 801b1c2:	687b      	ldr	r3, [r7, #4]
 801b1c4:	3b01      	subs	r3, #1
 801b1c6:	6a3a      	ldr	r2, [r7, #32]
 801b1c8:	429a      	cmp	r2, r3
 801b1ca:	d116      	bne.n	801b1fa <transform_argb8888+0x33e>
 801b1cc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b1ce:	2b00      	cmp	r3, #0
 801b1d0:	dd13      	ble.n	801b1fa <transform_argb8888+0x33e>
                dest_c32[x].alpha = (dest_c32[x].alpha * (0x7F - ys_fract)) >> 7;
 801b1d2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b1d4:	009b      	lsls	r3, r3, #2
 801b1d6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b1d8:	4413      	add	r3, r2
 801b1da:	78db      	ldrb	r3, [r3, #3]
 801b1dc:	461a      	mov	r2, r3
 801b1de:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b1e0:	f1c3 037f 	rsb	r3, r3, #127	@ 0x7f
 801b1e4:	fb02 f303 	mul.w	r3, r2, r3
 801b1e8:	11d9      	asrs	r1, r3, #7
 801b1ea:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b1ec:	009b      	lsls	r3, r3, #2
 801b1ee:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b1f0:	4413      	add	r3, r2
 801b1f2:	b2ca      	uxtb	r2, r1
 801b1f4:	70da      	strb	r2, [r3, #3]
 801b1f6:	e000      	b.n	801b1fa <transform_argb8888+0x33e>
           ys_int + y_next <= src_h - 1) {
 801b1f8:	bf00      	nop
    for(x = 0; x < x_end; x++) {
 801b1fa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b1fc:	3301      	adds	r3, #1
 801b1fe:	647b      	str	r3, [r7, #68]	@ 0x44
 801b200:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801b202:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801b204:	429a      	cmp	r2, r3
 801b206:	f6ff ae69 	blt.w	801aedc <transform_argb8888+0x20>
            }
        }
    }
}
 801b20a:	bf00      	nop
 801b20c:	bf00      	nop
 801b20e:	374c      	adds	r7, #76	@ 0x4c
 801b210:	46bd      	mov	sp, r7
 801b212:	bd90      	pop	{r4, r7, pc}

0801b214 <transform_rgb565a8>:

static void transform_rgb565a8(const uint8_t * src, int32_t src_w, int32_t src_h, int32_t src_stride,
                               int32_t xs_ups, int32_t ys_ups, int32_t xs_step, int32_t ys_step,
                               int32_t x_end, uint16_t * cbuf, uint8_t * abuf, bool src_has_a8, bool aa)
{
 801b214:	b590      	push	{r4, r7, lr}
 801b216:	b097      	sub	sp, #92	@ 0x5c
 801b218:	af00      	add	r7, sp, #0
 801b21a:	60f8      	str	r0, [r7, #12]
 801b21c:	60b9      	str	r1, [r7, #8]
 801b21e:	607a      	str	r2, [r7, #4]
 801b220:	603b      	str	r3, [r7, #0]
    int32_t xs_ups_start = xs_ups;
 801b222:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801b224:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int32_t ys_ups_start = ys_ups;
 801b226:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801b228:	63bb      	str	r3, [r7, #56]	@ 0x38

    const lv_opa_t * src_alpha = src + src_stride * src_h;
 801b22a:	683b      	ldr	r3, [r7, #0]
 801b22c:	687a      	ldr	r2, [r7, #4]
 801b22e:	fb02 f303 	mul.w	r3, r2, r3
 801b232:	461a      	mov	r2, r3
 801b234:	68fb      	ldr	r3, [r7, #12]
 801b236:	4413      	add	r3, r2
 801b238:	637b      	str	r3, [r7, #52]	@ 0x34

    /*Must be signed type, because we would use negative array index calculated from stride*/
    int32_t alpha_stride = src_stride / 2; /*alpha map stride is always half of RGB map stride*/
 801b23a:	683b      	ldr	r3, [r7, #0]
 801b23c:	0fda      	lsrs	r2, r3, #31
 801b23e:	4413      	add	r3, r2
 801b240:	105b      	asrs	r3, r3, #1
 801b242:	633b      	str	r3, [r7, #48]	@ 0x30

    int32_t x;
    for(x = 0; x < x_end; x++) {
 801b244:	2300      	movs	r3, #0
 801b246:	657b      	str	r3, [r7, #84]	@ 0x54
 801b248:	e19c      	b.n	801b584 <transform_rgb565a8+0x370>
        xs_ups = xs_ups_start + ((xs_step * x) >> 8);
 801b24a:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801b24c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801b24e:	fb02 f303 	mul.w	r3, r2, r3
 801b252:	121b      	asrs	r3, r3, #8
 801b254:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801b256:	4413      	add	r3, r2
 801b258:	66bb      	str	r3, [r7, #104]	@ 0x68
        ys_ups = ys_ups_start + ((ys_step * x) >> 8);
 801b25a:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801b25c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801b25e:	fb02 f303 	mul.w	r3, r2, r3
 801b262:	121b      	asrs	r3, r3, #8
 801b264:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801b266:	4413      	add	r3, r2
 801b268:	66fb      	str	r3, [r7, #108]	@ 0x6c

        int32_t xs_int = xs_ups >> 8;
 801b26a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801b26c:	121b      	asrs	r3, r3, #8
 801b26e:	62fb      	str	r3, [r7, #44]	@ 0x2c
        int32_t ys_int = ys_ups >> 8;
 801b270:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801b272:	121b      	asrs	r3, r3, #8
 801b274:	62bb      	str	r3, [r7, #40]	@ 0x28

        /*Fully out of the image*/
        if(xs_int < 0 || xs_int >= src_w || ys_int < 0 || ys_int >= src_h) {
 801b276:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b278:	2b00      	cmp	r3, #0
 801b27a:	db0a      	blt.n	801b292 <transform_rgb565a8+0x7e>
 801b27c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801b27e:	68bb      	ldr	r3, [r7, #8]
 801b280:	429a      	cmp	r2, r3
 801b282:	da06      	bge.n	801b292 <transform_rgb565a8+0x7e>
 801b284:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801b286:	2b00      	cmp	r3, #0
 801b288:	db03      	blt.n	801b292 <transform_rgb565a8+0x7e>
 801b28a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b28c:	687b      	ldr	r3, [r7, #4]
 801b28e:	429a      	cmp	r2, r3
 801b290:	db06      	blt.n	801b2a0 <transform_rgb565a8+0x8c>
            abuf[x] = 0x00;
 801b292:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b294:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801b298:	4413      	add	r3, r2
 801b29a:	2200      	movs	r2, #0
 801b29c:	701a      	strb	r2, [r3, #0]
            continue;
 801b29e:	e16e      	b.n	801b57e <transform_rgb565a8+0x36a>
        }

        /*Get the direction the hor and ver neighbor
         *`fract` will be in range of 0x00..0xFF and `next` (+/-1) indicates the direction*/
        int32_t xs_fract = xs_ups & 0xFF;
 801b2a0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801b2a2:	b2db      	uxtb	r3, r3
 801b2a4:	653b      	str	r3, [r7, #80]	@ 0x50
        int32_t ys_fract = ys_ups & 0xFF;
 801b2a6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801b2a8:	b2db      	uxtb	r3, r3
 801b2aa:	64fb      	str	r3, [r7, #76]	@ 0x4c

        int32_t x_next;
        int32_t y_next;
        if(xs_fract < 0x80) {
 801b2ac:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801b2ae:	2b7f      	cmp	r3, #127	@ 0x7f
 801b2b0:	dc08      	bgt.n	801b2c4 <transform_rgb565a8+0xb0>
            x_next = -1;
 801b2b2:	f04f 33ff 	mov.w	r3, #4294967295
 801b2b6:	64bb      	str	r3, [r7, #72]	@ 0x48
            xs_fract = (0x7F - xs_fract) * 2;
 801b2b8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801b2ba:	f1c3 037f 	rsb	r3, r3, #127	@ 0x7f
 801b2be:	005b      	lsls	r3, r3, #1
 801b2c0:	653b      	str	r3, [r7, #80]	@ 0x50
 801b2c2:	e005      	b.n	801b2d0 <transform_rgb565a8+0xbc>
        }
        else {
            x_next = 1;
 801b2c4:	2301      	movs	r3, #1
 801b2c6:	64bb      	str	r3, [r7, #72]	@ 0x48
            xs_fract = (xs_fract - 0x80) * 2;
 801b2c8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801b2ca:	3b80      	subs	r3, #128	@ 0x80
 801b2cc:	005b      	lsls	r3, r3, #1
 801b2ce:	653b      	str	r3, [r7, #80]	@ 0x50
        }
        if(ys_fract < 0x80) {
 801b2d0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b2d2:	2b7f      	cmp	r3, #127	@ 0x7f
 801b2d4:	dc08      	bgt.n	801b2e8 <transform_rgb565a8+0xd4>
            y_next = -1;
 801b2d6:	f04f 33ff 	mov.w	r3, #4294967295
 801b2da:	647b      	str	r3, [r7, #68]	@ 0x44
            ys_fract = (0x7F - ys_fract) * 2;
 801b2dc:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b2de:	f1c3 037f 	rsb	r3, r3, #127	@ 0x7f
 801b2e2:	005b      	lsls	r3, r3, #1
 801b2e4:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801b2e6:	e005      	b.n	801b2f4 <transform_rgb565a8+0xe0>
        }
        else {
            y_next = 1;
 801b2e8:	2301      	movs	r3, #1
 801b2ea:	647b      	str	r3, [r7, #68]	@ 0x44
            ys_fract = (ys_fract - 0x80) * 2;
 801b2ec:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b2ee:	3b80      	subs	r3, #128	@ 0x80
 801b2f0:	005b      	lsls	r3, r3, #1
 801b2f2:	64fb      	str	r3, [r7, #76]	@ 0x4c
        }

        const uint16_t * src_tmp_u16 = (const uint16_t *)(src + (ys_int * src_stride) + xs_int * 2);
 801b2f4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801b2f6:	683a      	ldr	r2, [r7, #0]
 801b2f8:	fb02 f303 	mul.w	r3, r2, r3
 801b2fc:	461a      	mov	r2, r3
 801b2fe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b300:	005b      	lsls	r3, r3, #1
 801b302:	4413      	add	r3, r2
 801b304:	68fa      	ldr	r2, [r7, #12]
 801b306:	4413      	add	r3, r2
 801b308:	627b      	str	r3, [r7, #36]	@ 0x24
        cbuf[x] = src_tmp_u16[0];
 801b30a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b30c:	005b      	lsls	r3, r3, #1
 801b30e:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801b310:	4413      	add	r3, r2
 801b312:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801b314:	8812      	ldrh	r2, [r2, #0]
 801b316:	801a      	strh	r2, [r3, #0]

        if(aa &&
 801b318:	f897 3088 	ldrb.w	r3, [r7, #136]	@ 0x88
 801b31c:	2b00      	cmp	r3, #0
 801b31e:	f000 80db 	beq.w	801b4d8 <transform_rgb565a8+0x2c4>
           xs_int + x_next >= 0 &&
 801b322:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801b324:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b326:	4413      	add	r3, r2
        if(aa &&
 801b328:	2b00      	cmp	r3, #0
 801b32a:	f2c0 80d5 	blt.w	801b4d8 <transform_rgb565a8+0x2c4>
           xs_int + x_next <= src_w - 1 &&
 801b32e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801b330:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b332:	4413      	add	r3, r2
           xs_int + x_next >= 0 &&
 801b334:	68ba      	ldr	r2, [r7, #8]
 801b336:	429a      	cmp	r2, r3
 801b338:	f340 80ce 	ble.w	801b4d8 <transform_rgb565a8+0x2c4>
           ys_int + y_next >= 0 &&
 801b33c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b33e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b340:	4413      	add	r3, r2
           xs_int + x_next <= src_w - 1 &&
 801b342:	2b00      	cmp	r3, #0
 801b344:	f2c0 80c8 	blt.w	801b4d8 <transform_rgb565a8+0x2c4>
           ys_int + y_next <= src_h - 1) {
 801b348:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b34a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b34c:	4413      	add	r3, r2
           ys_int + y_next >= 0 &&
 801b34e:	687a      	ldr	r2, [r7, #4]
 801b350:	429a      	cmp	r2, r3
 801b352:	f340 80c1 	ble.w	801b4d8 <transform_rgb565a8+0x2c4>

            uint16_t px_hor = src_tmp_u16[x_next];
 801b356:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b358:	005b      	lsls	r3, r3, #1
 801b35a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801b35c:	4413      	add	r3, r2
 801b35e:	881b      	ldrh	r3, [r3, #0]
 801b360:	847b      	strh	r3, [r7, #34]	@ 0x22
            uint16_t px_ver = *(const uint16_t *)((uint8_t *)src_tmp_u16 + (y_next * src_stride));
 801b362:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b364:	683a      	ldr	r2, [r7, #0]
 801b366:	fb02 f303 	mul.w	r3, r2, r3
 801b36a:	461a      	mov	r2, r3
 801b36c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801b36e:	4413      	add	r3, r2
 801b370:	881b      	ldrh	r3, [r3, #0]
 801b372:	843b      	strh	r3, [r7, #32]

            if(src_has_a8) {
 801b374:	f897 3084 	ldrb.w	r3, [r7, #132]	@ 0x84
 801b378:	2b00      	cmp	r3, #0
 801b37a:	d070      	beq.n	801b45e <transform_rgb565a8+0x24a>
                const lv_opa_t * src_alpha_tmp = src_alpha;
 801b37c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b37e:	61fb      	str	r3, [r7, #28]
                src_alpha_tmp += (ys_int * alpha_stride) + xs_int;
 801b380:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801b382:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801b384:	fb03 f202 	mul.w	r2, r3, r2
 801b388:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b38a:	4413      	add	r3, r2
 801b38c:	461a      	mov	r2, r3
 801b38e:	69fb      	ldr	r3, [r7, #28]
 801b390:	4413      	add	r3, r2
 801b392:	61fb      	str	r3, [r7, #28]
                abuf[x] = src_alpha_tmp[0];
 801b394:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b396:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801b39a:	4413      	add	r3, r2
 801b39c:	69fa      	ldr	r2, [r7, #28]
 801b39e:	7812      	ldrb	r2, [r2, #0]
 801b3a0:	701a      	strb	r2, [r3, #0]

                lv_opa_t a_hor = src_alpha_tmp[x_next];
 801b3a2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b3a4:	69fa      	ldr	r2, [r7, #28]
 801b3a6:	4413      	add	r3, r2
 801b3a8:	781b      	ldrb	r3, [r3, #0]
 801b3aa:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
                lv_opa_t a_ver = src_alpha_tmp[y_next * alpha_stride];
 801b3ae:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b3b0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801b3b2:	fb02 f303 	mul.w	r3, r2, r3
 801b3b6:	461a      	mov	r2, r3
 801b3b8:	69fb      	ldr	r3, [r7, #28]
 801b3ba:	4413      	add	r3, r2
 801b3bc:	781b      	ldrb	r3, [r3, #0]
 801b3be:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42

                if(a_ver != abuf[x]) a_ver = ((a_ver * ys_fract) + (abuf[x] * (0x100 - ys_fract))) >> 8;
 801b3c2:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b3c4:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801b3c8:	4413      	add	r3, r2
 801b3ca:	781b      	ldrb	r3, [r3, #0]
 801b3cc:	f897 2042 	ldrb.w	r2, [r7, #66]	@ 0x42
 801b3d0:	429a      	cmp	r2, r3
 801b3d2:	d013      	beq.n	801b3fc <transform_rgb565a8+0x1e8>
 801b3d4:	f897 3042 	ldrb.w	r3, [r7, #66]	@ 0x42
 801b3d8:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801b3da:	fb03 f202 	mul.w	r2, r3, r2
 801b3de:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b3e0:	f8d7 1080 	ldr.w	r1, [r7, #128]	@ 0x80
 801b3e4:	440b      	add	r3, r1
 801b3e6:	781b      	ldrb	r3, [r3, #0]
 801b3e8:	4619      	mov	r1, r3
 801b3ea:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b3ec:	f5c3 7380 	rsb	r3, r3, #256	@ 0x100
 801b3f0:	fb01 f303 	mul.w	r3, r1, r3
 801b3f4:	4413      	add	r3, r2
 801b3f6:	121b      	asrs	r3, r3, #8
 801b3f8:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
                if(a_hor != abuf[x]) a_hor = ((a_hor * xs_fract) + (abuf[x] * (0x100 - xs_fract))) >> 8;
 801b3fc:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b3fe:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801b402:	4413      	add	r3, r2
 801b404:	781b      	ldrb	r3, [r3, #0]
 801b406:	f897 2043 	ldrb.w	r2, [r7, #67]	@ 0x43
 801b40a:	429a      	cmp	r2, r3
 801b40c:	d013      	beq.n	801b436 <transform_rgb565a8+0x222>
 801b40e:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 801b412:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801b414:	fb03 f202 	mul.w	r2, r3, r2
 801b418:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b41a:	f8d7 1080 	ldr.w	r1, [r7, #128]	@ 0x80
 801b41e:	440b      	add	r3, r1
 801b420:	781b      	ldrb	r3, [r3, #0]
 801b422:	4619      	mov	r1, r3
 801b424:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801b426:	f5c3 7380 	rsb	r3, r3, #256	@ 0x100
 801b42a:	fb01 f303 	mul.w	r3, r1, r3
 801b42e:	4413      	add	r3, r2
 801b430:	121b      	asrs	r3, r3, #8
 801b432:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
                abuf[x] = (a_ver + a_hor) >> 1;
 801b436:	f897 2042 	ldrb.w	r2, [r7, #66]	@ 0x42
 801b43a:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 801b43e:	4413      	add	r3, r2
 801b440:	1059      	asrs	r1, r3, #1
 801b442:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b444:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801b448:	4413      	add	r3, r2
 801b44a:	b2ca      	uxtb	r2, r1
 801b44c:	701a      	strb	r2, [r3, #0]

                if(abuf[x] == 0x00) continue;
 801b44e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b450:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801b454:	4413      	add	r3, r2
 801b456:	781b      	ldrb	r3, [r3, #0]
 801b458:	2b00      	cmp	r3, #0
 801b45a:	d106      	bne.n	801b46a <transform_rgb565a8+0x256>
 801b45c:	e08f      	b.n	801b57e <transform_rgb565a8+0x36a>
            }
            else {
                abuf[x] = 0xff;
 801b45e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b460:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801b464:	4413      	add	r3, r2
 801b466:	22ff      	movs	r2, #255	@ 0xff
 801b468:	701a      	strb	r2, [r3, #0]
            }

            if(cbuf[x] != px_ver || cbuf[x] != px_hor) {
 801b46a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b46c:	005b      	lsls	r3, r3, #1
 801b46e:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801b470:	4413      	add	r3, r2
 801b472:	881b      	ldrh	r3, [r3, #0]
 801b474:	8c3a      	ldrh	r2, [r7, #32]
 801b476:	429a      	cmp	r2, r3
 801b478:	d107      	bne.n	801b48a <transform_rgb565a8+0x276>
 801b47a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b47c:	005b      	lsls	r3, r3, #1
 801b47e:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801b480:	4413      	add	r3, r2
 801b482:	881b      	ldrh	r3, [r3, #0]
 801b484:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
 801b486:	429a      	cmp	r2, r3
 801b488:	d078      	beq.n	801b57c <transform_rgb565a8+0x368>
                uint16_t v = lv_color_16_16_mix(px_ver, cbuf[x], ys_fract);
 801b48a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b48c:	005b      	lsls	r3, r3, #1
 801b48e:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801b490:	4413      	add	r3, r2
 801b492:	8819      	ldrh	r1, [r3, #0]
 801b494:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b496:	b2da      	uxtb	r2, r3
 801b498:	8c3b      	ldrh	r3, [r7, #32]
 801b49a:	4618      	mov	r0, r3
 801b49c:	f7fe ffee 	bl	801a47c <lv_color_16_16_mix>
 801b4a0:	4603      	mov	r3, r0
 801b4a2:	837b      	strh	r3, [r7, #26]
                uint16_t h = lv_color_16_16_mix(px_hor, cbuf[x], xs_fract);
 801b4a4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b4a6:	005b      	lsls	r3, r3, #1
 801b4a8:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801b4aa:	4413      	add	r3, r2
 801b4ac:	8819      	ldrh	r1, [r3, #0]
 801b4ae:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801b4b0:	b2da      	uxtb	r2, r3
 801b4b2:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 801b4b4:	4618      	mov	r0, r3
 801b4b6:	f7fe ffe1 	bl	801a47c <lv_color_16_16_mix>
 801b4ba:	4603      	mov	r3, r0
 801b4bc:	833b      	strh	r3, [r7, #24]
                cbuf[x] = lv_color_16_16_mix(h, v, LV_OPA_50);
 801b4be:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b4c0:	005b      	lsls	r3, r3, #1
 801b4c2:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801b4c4:	18d4      	adds	r4, r2, r3
 801b4c6:	8b79      	ldrh	r1, [r7, #26]
 801b4c8:	8b3b      	ldrh	r3, [r7, #24]
 801b4ca:	227f      	movs	r2, #127	@ 0x7f
 801b4cc:	4618      	mov	r0, r3
 801b4ce:	f7fe ffd5 	bl	801a47c <lv_color_16_16_mix>
 801b4d2:	4603      	mov	r3, r0
 801b4d4:	8023      	strh	r3, [r4, #0]
           ys_int + y_next <= src_h - 1) {
 801b4d6:	e051      	b.n	801b57c <transform_rgb565a8+0x368>
            }
        }
        /*Partially out of the image*/
        else {
            lv_opa_t a;
            if(src_has_a8) {
 801b4d8:	f897 3084 	ldrb.w	r3, [r7, #132]	@ 0x84
 801b4dc:	2b00      	cmp	r3, #0
 801b4de:	d010      	beq.n	801b502 <transform_rgb565a8+0x2ee>
                const lv_opa_t * src_alpha_tmp = src_alpha;
 801b4e0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b4e2:	617b      	str	r3, [r7, #20]
                src_alpha_tmp += (ys_int * alpha_stride) + xs_int;
 801b4e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801b4e6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801b4e8:	fb03 f202 	mul.w	r2, r3, r2
 801b4ec:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b4ee:	4413      	add	r3, r2
 801b4f0:	461a      	mov	r2, r3
 801b4f2:	697b      	ldr	r3, [r7, #20]
 801b4f4:	4413      	add	r3, r2
 801b4f6:	617b      	str	r3, [r7, #20]
                a = src_alpha_tmp[0];
 801b4f8:	697b      	ldr	r3, [r7, #20]
 801b4fa:	781b      	ldrb	r3, [r3, #0]
 801b4fc:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41
 801b500:	e002      	b.n	801b508 <transform_rgb565a8+0x2f4>
            }
            else {
                a = 0xff;
 801b502:	23ff      	movs	r3, #255	@ 0xff
 801b504:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41
            }

            if((xs_int == 0 && x_next < 0) || (xs_int == src_w - 1 && x_next > 0))  {
 801b508:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b50a:	2b00      	cmp	r3, #0
 801b50c:	d102      	bne.n	801b514 <transform_rgb565a8+0x300>
 801b50e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b510:	2b00      	cmp	r3, #0
 801b512:	db07      	blt.n	801b524 <transform_rgb565a8+0x310>
 801b514:	68bb      	ldr	r3, [r7, #8]
 801b516:	3b01      	subs	r3, #1
 801b518:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801b51a:	429a      	cmp	r2, r3
 801b51c:	d111      	bne.n	801b542 <transform_rgb565a8+0x32e>
 801b51e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b520:	2b00      	cmp	r3, #0
 801b522:	dd0e      	ble.n	801b542 <transform_rgb565a8+0x32e>
                abuf[x] = (a * (0xFF - xs_fract)) >> 8;
 801b524:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 801b528:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801b52a:	f1c2 02ff 	rsb	r2, r2, #255	@ 0xff
 801b52e:	fb02 f303 	mul.w	r3, r2, r3
 801b532:	1219      	asrs	r1, r3, #8
 801b534:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b536:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801b53a:	4413      	add	r3, r2
 801b53c:	b2ca      	uxtb	r2, r1
 801b53e:	701a      	strb	r2, [r3, #0]
 801b540:	e01d      	b.n	801b57e <transform_rgb565a8+0x36a>
            }
            else if((ys_int == 0 && y_next < 0) || (ys_int == src_h - 1 && y_next > 0))  {
 801b542:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801b544:	2b00      	cmp	r3, #0
 801b546:	d102      	bne.n	801b54e <transform_rgb565a8+0x33a>
 801b548:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b54a:	2b00      	cmp	r3, #0
 801b54c:	db07      	blt.n	801b55e <transform_rgb565a8+0x34a>
 801b54e:	687b      	ldr	r3, [r7, #4]
 801b550:	3b01      	subs	r3, #1
 801b552:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801b554:	429a      	cmp	r2, r3
 801b556:	d112      	bne.n	801b57e <transform_rgb565a8+0x36a>
 801b558:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801b55a:	2b00      	cmp	r3, #0
 801b55c:	dd0f      	ble.n	801b57e <transform_rgb565a8+0x36a>
                abuf[x] = (a * (0xFF - ys_fract)) >> 8;
 801b55e:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 801b562:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801b564:	f1c2 02ff 	rsb	r2, r2, #255	@ 0xff
 801b568:	fb02 f303 	mul.w	r3, r2, r3
 801b56c:	1219      	asrs	r1, r3, #8
 801b56e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b570:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801b574:	4413      	add	r3, r2
 801b576:	b2ca      	uxtb	r2, r1
 801b578:	701a      	strb	r2, [r3, #0]
 801b57a:	e000      	b.n	801b57e <transform_rgb565a8+0x36a>
           ys_int + y_next <= src_h - 1) {
 801b57c:	bf00      	nop
    for(x = 0; x < x_end; x++) {
 801b57e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b580:	3301      	adds	r3, #1
 801b582:	657b      	str	r3, [r7, #84]	@ 0x54
 801b584:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801b586:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801b588:	429a      	cmp	r2, r3
 801b58a:	f6ff ae5e 	blt.w	801b24a <transform_rgb565a8+0x36>
            }
        }
    }
}
 801b58e:	bf00      	nop
 801b590:	bf00      	nop
 801b592:	375c      	adds	r7, #92	@ 0x5c
 801b594:	46bd      	mov	sp, r7
 801b596:	bd90      	pop	{r4, r7, pc}

0801b598 <transform_a8>:

static void transform_a8(const uint8_t * src, int32_t src_w, int32_t src_h, int32_t src_stride,
                         int32_t xs_ups, int32_t ys_ups, int32_t xs_step, int32_t ys_step,
                         int32_t x_end, uint8_t * abuf, bool aa)
{
 801b598:	b480      	push	{r7}
 801b59a:	b091      	sub	sp, #68	@ 0x44
 801b59c:	af00      	add	r7, sp, #0
 801b59e:	60f8      	str	r0, [r7, #12]
 801b5a0:	60b9      	str	r1, [r7, #8]
 801b5a2:	607a      	str	r2, [r7, #4]
 801b5a4:	603b      	str	r3, [r7, #0]
    int32_t xs_ups_start = xs_ups;
 801b5a6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b5a8:	627b      	str	r3, [r7, #36]	@ 0x24
    int32_t ys_ups_start = ys_ups;
 801b5aa:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b5ac:	623b      	str	r3, [r7, #32]

    int32_t x;
    for(x = 0; x < x_end; x++) {
 801b5ae:	2300      	movs	r3, #0
 801b5b0:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801b5b2:	e10d      	b.n	801b7d0 <transform_a8+0x238>
        xs_ups = xs_ups_start + ((xs_step * x) >> 8);
 801b5b4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801b5b6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801b5b8:	fb02 f303 	mul.w	r3, r2, r3
 801b5bc:	121b      	asrs	r3, r3, #8
 801b5be:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801b5c0:	4413      	add	r3, r2
 801b5c2:	64bb      	str	r3, [r7, #72]	@ 0x48
        ys_ups = ys_ups_start + ((ys_step * x) >> 8);
 801b5c4:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801b5c6:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801b5c8:	fb02 f303 	mul.w	r3, r2, r3
 801b5cc:	121b      	asrs	r3, r3, #8
 801b5ce:	6a3a      	ldr	r2, [r7, #32]
 801b5d0:	4413      	add	r3, r2
 801b5d2:	64fb      	str	r3, [r7, #76]	@ 0x4c

        int32_t xs_int = xs_ups >> 8;
 801b5d4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b5d6:	121b      	asrs	r3, r3, #8
 801b5d8:	61fb      	str	r3, [r7, #28]
        int32_t ys_int = ys_ups >> 8;
 801b5da:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b5dc:	121b      	asrs	r3, r3, #8
 801b5de:	61bb      	str	r3, [r7, #24]

        /*Fully out of the image*/
        if(xs_int < 0 || xs_int >= src_w || ys_int < 0 || ys_int >= src_h) {
 801b5e0:	69fb      	ldr	r3, [r7, #28]
 801b5e2:	2b00      	cmp	r3, #0
 801b5e4:	db0a      	blt.n	801b5fc <transform_a8+0x64>
 801b5e6:	69fa      	ldr	r2, [r7, #28]
 801b5e8:	68bb      	ldr	r3, [r7, #8]
 801b5ea:	429a      	cmp	r2, r3
 801b5ec:	da06      	bge.n	801b5fc <transform_a8+0x64>
 801b5ee:	69bb      	ldr	r3, [r7, #24]
 801b5f0:	2b00      	cmp	r3, #0
 801b5f2:	db03      	blt.n	801b5fc <transform_a8+0x64>
 801b5f4:	69ba      	ldr	r2, [r7, #24]
 801b5f6:	687b      	ldr	r3, [r7, #4]
 801b5f8:	429a      	cmp	r2, r3
 801b5fa:	db05      	blt.n	801b608 <transform_a8+0x70>
            abuf[x] = 0x00;
 801b5fc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b5fe:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801b600:	4413      	add	r3, r2
 801b602:	2200      	movs	r2, #0
 801b604:	701a      	strb	r2, [r3, #0]
            continue;
 801b606:	e0e0      	b.n	801b7ca <transform_a8+0x232>
        }

        /*Get the direction the hor and ver neighbor
         *`fract` will be in range of 0x00..0xFF and `next` (+/-1) indicates the direction*/
        int32_t xs_fract = xs_ups & 0xFF;
 801b608:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801b60a:	b2db      	uxtb	r3, r3
 801b60c:	63bb      	str	r3, [r7, #56]	@ 0x38
        int32_t ys_fract = ys_ups & 0xFF;
 801b60e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801b610:	b2db      	uxtb	r3, r3
 801b612:	637b      	str	r3, [r7, #52]	@ 0x34

        int32_t x_next;
        int32_t y_next;
        if(xs_fract < 0x80) {
 801b614:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b616:	2b7f      	cmp	r3, #127	@ 0x7f
 801b618:	dc08      	bgt.n	801b62c <transform_a8+0x94>
            x_next = -1;
 801b61a:	f04f 33ff 	mov.w	r3, #4294967295
 801b61e:	633b      	str	r3, [r7, #48]	@ 0x30
            xs_fract = (0x7F - xs_fract) * 2;
 801b620:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b622:	f1c3 037f 	rsb	r3, r3, #127	@ 0x7f
 801b626:	005b      	lsls	r3, r3, #1
 801b628:	63bb      	str	r3, [r7, #56]	@ 0x38
 801b62a:	e005      	b.n	801b638 <transform_a8+0xa0>
        }
        else {
            x_next = 1;
 801b62c:	2301      	movs	r3, #1
 801b62e:	633b      	str	r3, [r7, #48]	@ 0x30
            xs_fract = (xs_fract - 0x80) * 2;
 801b630:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b632:	3b80      	subs	r3, #128	@ 0x80
 801b634:	005b      	lsls	r3, r3, #1
 801b636:	63bb      	str	r3, [r7, #56]	@ 0x38
        }
        if(ys_fract < 0x80) {
 801b638:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b63a:	2b7f      	cmp	r3, #127	@ 0x7f
 801b63c:	dc08      	bgt.n	801b650 <transform_a8+0xb8>
            y_next = -1;
 801b63e:	f04f 33ff 	mov.w	r3, #4294967295
 801b642:	62fb      	str	r3, [r7, #44]	@ 0x2c
            ys_fract = (0x7F - ys_fract) * 2;
 801b644:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b646:	f1c3 037f 	rsb	r3, r3, #127	@ 0x7f
 801b64a:	005b      	lsls	r3, r3, #1
 801b64c:	637b      	str	r3, [r7, #52]	@ 0x34
 801b64e:	e005      	b.n	801b65c <transform_a8+0xc4>
        }
        else {
            y_next = 1;
 801b650:	2301      	movs	r3, #1
 801b652:	62fb      	str	r3, [r7, #44]	@ 0x2c
            ys_fract = (ys_fract - 0x80) * 2;
 801b654:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b656:	3b80      	subs	r3, #128	@ 0x80
 801b658:	005b      	lsls	r3, r3, #1
 801b65a:	637b      	str	r3, [r7, #52]	@ 0x34
        }

        const uint8_t * src_tmp = src;
 801b65c:	68fb      	ldr	r3, [r7, #12]
 801b65e:	617b      	str	r3, [r7, #20]
        src_tmp += ys_int * src_stride + xs_int;
 801b660:	69bb      	ldr	r3, [r7, #24]
 801b662:	683a      	ldr	r2, [r7, #0]
 801b664:	fb03 f202 	mul.w	r2, r3, r2
 801b668:	69fb      	ldr	r3, [r7, #28]
 801b66a:	4413      	add	r3, r2
 801b66c:	461a      	mov	r2, r3
 801b66e:	697b      	ldr	r3, [r7, #20]
 801b670:	4413      	add	r3, r2
 801b672:	617b      	str	r3, [r7, #20]
        abuf[x] = src_tmp[0];
 801b674:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b676:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801b678:	4413      	add	r3, r2
 801b67a:	697a      	ldr	r2, [r7, #20]
 801b67c:	7812      	ldrb	r2, [r2, #0]
 801b67e:	701a      	strb	r2, [r3, #0]

        if(aa &&
 801b680:	f897 3060 	ldrb.w	r3, [r7, #96]	@ 0x60
 801b684:	2b00      	cmp	r3, #0
 801b686:	d067      	beq.n	801b758 <transform_a8+0x1c0>
           xs_int + x_next >= 0 &&
 801b688:	69fa      	ldr	r2, [r7, #28]
 801b68a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801b68c:	4413      	add	r3, r2
        if(aa &&
 801b68e:	2b00      	cmp	r3, #0
 801b690:	db62      	blt.n	801b758 <transform_a8+0x1c0>
           xs_int + x_next <= src_w - 1 &&
 801b692:	69fa      	ldr	r2, [r7, #28]
 801b694:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801b696:	4413      	add	r3, r2
           xs_int + x_next >= 0 &&
 801b698:	68ba      	ldr	r2, [r7, #8]
 801b69a:	429a      	cmp	r2, r3
 801b69c:	dd5c      	ble.n	801b758 <transform_a8+0x1c0>
           ys_int + y_next >= 0 &&
 801b69e:	69ba      	ldr	r2, [r7, #24]
 801b6a0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b6a2:	4413      	add	r3, r2
           xs_int + x_next <= src_w - 1 &&
 801b6a4:	2b00      	cmp	r3, #0
 801b6a6:	db57      	blt.n	801b758 <transform_a8+0x1c0>
           ys_int + y_next <= src_h - 1) {
 801b6a8:	69ba      	ldr	r2, [r7, #24]
 801b6aa:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b6ac:	4413      	add	r3, r2
           ys_int + y_next >= 0 &&
 801b6ae:	687a      	ldr	r2, [r7, #4]
 801b6b0:	429a      	cmp	r2, r3
 801b6b2:	dd51      	ble.n	801b758 <transform_a8+0x1c0>

            lv_opa_t a_ver = src_tmp[x_next];
 801b6b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801b6b6:	697a      	ldr	r2, [r7, #20]
 801b6b8:	4413      	add	r3, r2
 801b6ba:	781b      	ldrb	r3, [r3, #0]
 801b6bc:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
            lv_opa_t a_hor = src_tmp[y_next * src_stride];
 801b6c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b6c2:	683a      	ldr	r2, [r7, #0]
 801b6c4:	fb02 f303 	mul.w	r3, r2, r3
 801b6c8:	461a      	mov	r2, r3
 801b6ca:	697b      	ldr	r3, [r7, #20]
 801b6cc:	4413      	add	r3, r2
 801b6ce:	781b      	ldrb	r3, [r3, #0]
 801b6d0:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a

            if(a_ver != abuf[x]) a_ver = ((a_ver * ys_fract) + (abuf[x] * (0x100 - ys_fract))) >> 8;
 801b6d4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b6d6:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801b6d8:	4413      	add	r3, r2
 801b6da:	781b      	ldrb	r3, [r3, #0]
 801b6dc:	f897 202b 	ldrb.w	r2, [r7, #43]	@ 0x2b
 801b6e0:	429a      	cmp	r2, r3
 801b6e2:	d012      	beq.n	801b70a <transform_a8+0x172>
 801b6e4:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 801b6e8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801b6ea:	fb03 f202 	mul.w	r2, r3, r2
 801b6ee:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b6f0:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b6f2:	440b      	add	r3, r1
 801b6f4:	781b      	ldrb	r3, [r3, #0]
 801b6f6:	4619      	mov	r1, r3
 801b6f8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b6fa:	f5c3 7380 	rsb	r3, r3, #256	@ 0x100
 801b6fe:	fb01 f303 	mul.w	r3, r1, r3
 801b702:	4413      	add	r3, r2
 801b704:	121b      	asrs	r3, r3, #8
 801b706:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
            if(a_hor != abuf[x]) a_hor = ((a_hor * xs_fract) + (abuf[x] * (0x100 - xs_fract))) >> 8;
 801b70a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b70c:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801b70e:	4413      	add	r3, r2
 801b710:	781b      	ldrb	r3, [r3, #0]
 801b712:	f897 202a 	ldrb.w	r2, [r7, #42]	@ 0x2a
 801b716:	429a      	cmp	r2, r3
 801b718:	d012      	beq.n	801b740 <transform_a8+0x1a8>
 801b71a:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 801b71e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801b720:	fb03 f202 	mul.w	r2, r3, r2
 801b724:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b726:	6df9      	ldr	r1, [r7, #92]	@ 0x5c
 801b728:	440b      	add	r3, r1
 801b72a:	781b      	ldrb	r3, [r3, #0]
 801b72c:	4619      	mov	r1, r3
 801b72e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b730:	f5c3 7380 	rsb	r3, r3, #256	@ 0x100
 801b734:	fb01 f303 	mul.w	r3, r1, r3
 801b738:	4413      	add	r3, r2
 801b73a:	121b      	asrs	r3, r3, #8
 801b73c:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
            abuf[x] = (a_ver + a_hor) >> 1;
 801b740:	f897 202b 	ldrb.w	r2, [r7, #43]	@ 0x2b
 801b744:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 801b748:	4413      	add	r3, r2
 801b74a:	1059      	asrs	r1, r3, #1
 801b74c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b74e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801b750:	4413      	add	r3, r2
 801b752:	b2ca      	uxtb	r2, r1
 801b754:	701a      	strb	r2, [r3, #0]
           ys_int + y_next <= src_h - 1) {
 801b756:	e038      	b.n	801b7ca <transform_a8+0x232>
        }
        else {
            /*Partially out of the image*/
            if((xs_int == 0 && x_next < 0) || (xs_int == src_w - 1 && x_next > 0))  {
 801b758:	69fb      	ldr	r3, [r7, #28]
 801b75a:	2b00      	cmp	r3, #0
 801b75c:	d102      	bne.n	801b764 <transform_a8+0x1cc>
 801b75e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801b760:	2b00      	cmp	r3, #0
 801b762:	db07      	blt.n	801b774 <transform_a8+0x1dc>
 801b764:	68bb      	ldr	r3, [r7, #8]
 801b766:	3b01      	subs	r3, #1
 801b768:	69fa      	ldr	r2, [r7, #28]
 801b76a:	429a      	cmp	r2, r3
 801b76c:	d111      	bne.n	801b792 <transform_a8+0x1fa>
 801b76e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801b770:	2b00      	cmp	r3, #0
 801b772:	dd0e      	ble.n	801b792 <transform_a8+0x1fa>
                abuf[x] = (src_tmp[0] * (0xFF - xs_fract)) >> 8;
 801b774:	697b      	ldr	r3, [r7, #20]
 801b776:	781b      	ldrb	r3, [r3, #0]
 801b778:	461a      	mov	r2, r3
 801b77a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801b77c:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 801b780:	fb02 f303 	mul.w	r3, r2, r3
 801b784:	1219      	asrs	r1, r3, #8
 801b786:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b788:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801b78a:	4413      	add	r3, r2
 801b78c:	b2ca      	uxtb	r2, r1
 801b78e:	701a      	strb	r2, [r3, #0]
 801b790:	e01b      	b.n	801b7ca <transform_a8+0x232>
            }
            else if((ys_int == 0 && y_next < 0) || (ys_int == src_h - 1 && y_next > 0))  {
 801b792:	69bb      	ldr	r3, [r7, #24]
 801b794:	2b00      	cmp	r3, #0
 801b796:	d102      	bne.n	801b79e <transform_a8+0x206>
 801b798:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b79a:	2b00      	cmp	r3, #0
 801b79c:	db07      	blt.n	801b7ae <transform_a8+0x216>
 801b79e:	687b      	ldr	r3, [r7, #4]
 801b7a0:	3b01      	subs	r3, #1
 801b7a2:	69ba      	ldr	r2, [r7, #24]
 801b7a4:	429a      	cmp	r2, r3
 801b7a6:	d110      	bne.n	801b7ca <transform_a8+0x232>
 801b7a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801b7aa:	2b00      	cmp	r3, #0
 801b7ac:	dd0d      	ble.n	801b7ca <transform_a8+0x232>
                abuf[x] = (src_tmp[0] * (0xFF - ys_fract)) >> 8;
 801b7ae:	697b      	ldr	r3, [r7, #20]
 801b7b0:	781b      	ldrb	r3, [r3, #0]
 801b7b2:	461a      	mov	r2, r3
 801b7b4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801b7b6:	f1c3 03ff 	rsb	r3, r3, #255	@ 0xff
 801b7ba:	fb02 f303 	mul.w	r3, r2, r3
 801b7be:	1219      	asrs	r1, r3, #8
 801b7c0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b7c2:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801b7c4:	4413      	add	r3, r2
 801b7c6:	b2ca      	uxtb	r2, r1
 801b7c8:	701a      	strb	r2, [r3, #0]
    for(x = 0; x < x_end; x++) {
 801b7ca:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801b7cc:	3301      	adds	r3, #1
 801b7ce:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801b7d0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 801b7d2:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801b7d4:	429a      	cmp	r2, r3
 801b7d6:	f6ff aeed 	blt.w	801b5b4 <transform_a8+0x1c>
            }
        }
    }
}
 801b7da:	bf00      	nop
 801b7dc:	bf00      	nop
 801b7de:	3744      	adds	r7, #68	@ 0x44
 801b7e0:	46bd      	mov	sp, r7
 801b7e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b7e6:	4770      	bx	lr

0801b7e8 <transform_point_upscaled>:

static void transform_point_upscaled(point_transform_dsc_t * t, int32_t xin, int32_t yin, int32_t * xout,
                                     int32_t * yout)
{
 801b7e8:	b480      	push	{r7}
 801b7ea:	b085      	sub	sp, #20
 801b7ec:	af00      	add	r7, sp, #0
 801b7ee:	60f8      	str	r0, [r7, #12]
 801b7f0:	60b9      	str	r1, [r7, #8]
 801b7f2:	607a      	str	r2, [r7, #4]
 801b7f4:	603b      	str	r3, [r7, #0]
    if(t->angle == 0 && t->scale_x == LV_SCALE_NONE && t->scale_y == LV_SCALE_NONE) {
 801b7f6:	68fb      	ldr	r3, [r7, #12]
 801b7f8:	6a1b      	ldr	r3, [r3, #32]
 801b7fa:	2b00      	cmp	r3, #0
 801b7fc:	d112      	bne.n	801b824 <transform_point_upscaled+0x3c>
 801b7fe:	68fb      	ldr	r3, [r7, #12]
 801b800:	699b      	ldr	r3, [r3, #24]
 801b802:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 801b806:	d10d      	bne.n	801b824 <transform_point_upscaled+0x3c>
 801b808:	68fb      	ldr	r3, [r7, #12]
 801b80a:	69db      	ldr	r3, [r3, #28]
 801b80c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 801b810:	d108      	bne.n	801b824 <transform_point_upscaled+0x3c>
        *xout = xin * 256;
 801b812:	68bb      	ldr	r3, [r7, #8]
 801b814:	021a      	lsls	r2, r3, #8
 801b816:	683b      	ldr	r3, [r7, #0]
 801b818:	601a      	str	r2, [r3, #0]
        *yout = yin * 256;
 801b81a:	687b      	ldr	r3, [r7, #4]
 801b81c:	021a      	lsls	r2, r3, #8
 801b81e:	69bb      	ldr	r3, [r7, #24]
 801b820:	601a      	str	r2, [r3, #0]
        return;
 801b822:	e079      	b.n	801b918 <transform_point_upscaled+0x130>
    }

    xin -= t->pivot.x;
 801b824:	68fb      	ldr	r3, [r7, #12]
 801b826:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801b828:	68ba      	ldr	r2, [r7, #8]
 801b82a:	1ad3      	subs	r3, r2, r3
 801b82c:	60bb      	str	r3, [r7, #8]
    yin -= t->pivot.y;
 801b82e:	68fb      	ldr	r3, [r7, #12]
 801b830:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801b832:	687a      	ldr	r2, [r7, #4]
 801b834:	1ad3      	subs	r3, r2, r3
 801b836:	607b      	str	r3, [r7, #4]

    if(t->angle == 0) {
 801b838:	68fb      	ldr	r3, [r7, #12]
 801b83a:	6a1b      	ldr	r3, [r3, #32]
 801b83c:	2b00      	cmp	r3, #0
 801b83e:	d114      	bne.n	801b86a <transform_point_upscaled+0x82>
        *xout = ((int32_t)(xin * t->scale_x)) + (t->pivot_x_256);
 801b840:	68fb      	ldr	r3, [r7, #12]
 801b842:	699b      	ldr	r3, [r3, #24]
 801b844:	68ba      	ldr	r2, [r7, #8]
 801b846:	fb03 f202 	mul.w	r2, r3, r2
 801b84a:	68fb      	ldr	r3, [r7, #12]
 801b84c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801b84e:	441a      	add	r2, r3
 801b850:	683b      	ldr	r3, [r7, #0]
 801b852:	601a      	str	r2, [r3, #0]
        *yout = ((int32_t)(yin * t->scale_y)) + (t->pivot_y_256);
 801b854:	68fb      	ldr	r3, [r7, #12]
 801b856:	69db      	ldr	r3, [r3, #28]
 801b858:	687a      	ldr	r2, [r7, #4]
 801b85a:	fb03 f202 	mul.w	r2, r3, r2
 801b85e:	68fb      	ldr	r3, [r7, #12]
 801b860:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801b862:	441a      	add	r2, r3
 801b864:	69bb      	ldr	r3, [r7, #24]
 801b866:	601a      	str	r2, [r3, #0]
 801b868:	e056      	b.n	801b918 <transform_point_upscaled+0x130>
    }
    else if(t->scale_x == LV_SCALE_NONE && t->scale_y == LV_SCALE_NONE) {
 801b86a:	68fb      	ldr	r3, [r7, #12]
 801b86c:	699b      	ldr	r3, [r3, #24]
 801b86e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 801b872:	d127      	bne.n	801b8c4 <transform_point_upscaled+0xdc>
 801b874:	68fb      	ldr	r3, [r7, #12]
 801b876:	69db      	ldr	r3, [r3, #28]
 801b878:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 801b87c:	d122      	bne.n	801b8c4 <transform_point_upscaled+0xdc>
        *xout = ((t->cosma * xin - t->sinma * yin) >> 2) + (t->pivot_x_256);
 801b87e:	68fb      	ldr	r3, [r7, #12]
 801b880:	695b      	ldr	r3, [r3, #20]
 801b882:	68ba      	ldr	r2, [r7, #8]
 801b884:	fb03 f202 	mul.w	r2, r3, r2
 801b888:	68fb      	ldr	r3, [r7, #12]
 801b88a:	691b      	ldr	r3, [r3, #16]
 801b88c:	6879      	ldr	r1, [r7, #4]
 801b88e:	fb01 f303 	mul.w	r3, r1, r3
 801b892:	1ad3      	subs	r3, r2, r3
 801b894:	109a      	asrs	r2, r3, #2
 801b896:	68fb      	ldr	r3, [r7, #12]
 801b898:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801b89a:	441a      	add	r2, r3
 801b89c:	683b      	ldr	r3, [r7, #0]
 801b89e:	601a      	str	r2, [r3, #0]
        *yout = ((t->sinma * xin + t->cosma * yin) >> 2) + (t->pivot_y_256);
 801b8a0:	68fb      	ldr	r3, [r7, #12]
 801b8a2:	691b      	ldr	r3, [r3, #16]
 801b8a4:	68ba      	ldr	r2, [r7, #8]
 801b8a6:	fb03 f202 	mul.w	r2, r3, r2
 801b8aa:	68fb      	ldr	r3, [r7, #12]
 801b8ac:	695b      	ldr	r3, [r3, #20]
 801b8ae:	6879      	ldr	r1, [r7, #4]
 801b8b0:	fb01 f303 	mul.w	r3, r1, r3
 801b8b4:	4413      	add	r3, r2
 801b8b6:	109a      	asrs	r2, r3, #2
 801b8b8:	68fb      	ldr	r3, [r7, #12]
 801b8ba:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801b8bc:	441a      	add	r2, r3
 801b8be:	69bb      	ldr	r3, [r7, #24]
 801b8c0:	601a      	str	r2, [r3, #0]
 801b8c2:	e029      	b.n	801b918 <transform_point_upscaled+0x130>
    }
    else {
        *xout = (((t->cosma * xin - t->sinma * yin) * t->scale_x) >> 10) + (t->pivot_x_256);
 801b8c4:	68fb      	ldr	r3, [r7, #12]
 801b8c6:	695b      	ldr	r3, [r3, #20]
 801b8c8:	68ba      	ldr	r2, [r7, #8]
 801b8ca:	fb03 f202 	mul.w	r2, r3, r2
 801b8ce:	68fb      	ldr	r3, [r7, #12]
 801b8d0:	691b      	ldr	r3, [r3, #16]
 801b8d2:	6879      	ldr	r1, [r7, #4]
 801b8d4:	fb01 f303 	mul.w	r3, r1, r3
 801b8d8:	1ad3      	subs	r3, r2, r3
 801b8da:	68fa      	ldr	r2, [r7, #12]
 801b8dc:	6992      	ldr	r2, [r2, #24]
 801b8de:	fb02 f303 	mul.w	r3, r2, r3
 801b8e2:	129a      	asrs	r2, r3, #10
 801b8e4:	68fb      	ldr	r3, [r7, #12]
 801b8e6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801b8e8:	441a      	add	r2, r3
 801b8ea:	683b      	ldr	r3, [r7, #0]
 801b8ec:	601a      	str	r2, [r3, #0]
        *yout = (((t->sinma * xin + t->cosma * yin) * t->scale_y) >> 10) + (t->pivot_y_256);
 801b8ee:	68fb      	ldr	r3, [r7, #12]
 801b8f0:	691b      	ldr	r3, [r3, #16]
 801b8f2:	68ba      	ldr	r2, [r7, #8]
 801b8f4:	fb03 f202 	mul.w	r2, r3, r2
 801b8f8:	68fb      	ldr	r3, [r7, #12]
 801b8fa:	695b      	ldr	r3, [r3, #20]
 801b8fc:	6879      	ldr	r1, [r7, #4]
 801b8fe:	fb01 f303 	mul.w	r3, r1, r3
 801b902:	4413      	add	r3, r2
 801b904:	68fa      	ldr	r2, [r7, #12]
 801b906:	69d2      	ldr	r2, [r2, #28]
 801b908:	fb02 f303 	mul.w	r3, r2, r3
 801b90c:	129a      	asrs	r2, r3, #10
 801b90e:	68fb      	ldr	r3, [r7, #12]
 801b910:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801b912:	441a      	add	r2, r3
 801b914:	69bb      	ldr	r3, [r7, #24]
 801b916:	601a      	str	r2, [r3, #0]
    }
}
 801b918:	3714      	adds	r7, #20
 801b91a:	46bd      	mov	sp, r7
 801b91c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b920:	4770      	bx	lr

0801b922 <lv_area_get_width>:
{
 801b922:	b480      	push	{r7}
 801b924:	b083      	sub	sp, #12
 801b926:	af00      	add	r7, sp, #0
 801b928:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 801b92a:	687b      	ldr	r3, [r7, #4]
 801b92c:	689a      	ldr	r2, [r3, #8]
 801b92e:	687b      	ldr	r3, [r7, #4]
 801b930:	681b      	ldr	r3, [r3, #0]
 801b932:	1ad3      	subs	r3, r2, r3
 801b934:	3301      	adds	r3, #1
}
 801b936:	4618      	mov	r0, r3
 801b938:	370c      	adds	r7, #12
 801b93a:	46bd      	mov	sp, r7
 801b93c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b940:	4770      	bx	lr

0801b942 <lv_area_get_height>:
{
 801b942:	b480      	push	{r7}
 801b944:	b083      	sub	sp, #12
 801b946:	af00      	add	r7, sp, #0
 801b948:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 801b94a:	687b      	ldr	r3, [r7, #4]
 801b94c:	68da      	ldr	r2, [r3, #12]
 801b94e:	687b      	ldr	r3, [r7, #4]
 801b950:	685b      	ldr	r3, [r3, #4]
 801b952:	1ad3      	subs	r3, r2, r3
 801b954:	3301      	adds	r3, #1
}
 801b956:	4618      	mov	r0, r3
 801b958:	370c      	adds	r7, #12
 801b95a:	46bd      	mov	sp, r7
 801b95c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b960:	4770      	bx	lr

0801b962 <lv_point_from_precise>:
{
 801b962:	b480      	push	{r7}
 801b964:	b085      	sub	sp, #20
 801b966:	af00      	add	r7, sp, #0
 801b968:	6078      	str	r0, [r7, #4]
 801b96a:	6039      	str	r1, [r7, #0]
        (int32_t)p->x, (int32_t)p->y
 801b96c:	683b      	ldr	r3, [r7, #0]
 801b96e:	681b      	ldr	r3, [r3, #0]
    lv_point_t point = {
 801b970:	60bb      	str	r3, [r7, #8]
        (int32_t)p->x, (int32_t)p->y
 801b972:	683b      	ldr	r3, [r7, #0]
 801b974:	685b      	ldr	r3, [r3, #4]
    lv_point_t point = {
 801b976:	60fb      	str	r3, [r7, #12]
    return point;
 801b978:	687b      	ldr	r3, [r7, #4]
 801b97a:	461a      	mov	r2, r3
 801b97c:	f107 0308 	add.w	r3, r7, #8
 801b980:	e893 0003 	ldmia.w	r3, {r0, r1}
 801b984:	e882 0003 	stmia.w	r2, {r0, r1}
}
 801b988:	6878      	ldr	r0, [r7, #4]
 801b98a:	3714      	adds	r7, #20
 801b98c:	46bd      	mov	sp, r7
 801b98e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b992:	4770      	bx	lr

0801b994 <lv_point_swap>:
    p->x = x;
    p->y = y;
}

static inline void lv_point_swap(lv_point_t * p1, lv_point_t * p2)
{
 801b994:	b480      	push	{r7}
 801b996:	b085      	sub	sp, #20
 801b998:	af00      	add	r7, sp, #0
 801b99a:	6078      	str	r0, [r7, #4]
 801b99c:	6039      	str	r1, [r7, #0]
    lv_point_t tmp = *p1;
 801b99e:	687a      	ldr	r2, [r7, #4]
 801b9a0:	f107 0308 	add.w	r3, r7, #8
 801b9a4:	e892 0003 	ldmia.w	r2, {r0, r1}
 801b9a8:	e883 0003 	stmia.w	r3, {r0, r1}
    *p1 = *p2;
 801b9ac:	687b      	ldr	r3, [r7, #4]
 801b9ae:	683a      	ldr	r2, [r7, #0]
 801b9b0:	e892 0003 	ldmia.w	r2, {r0, r1}
 801b9b4:	e883 0003 	stmia.w	r3, {r0, r1}
    *p2 = tmp;
 801b9b8:	683b      	ldr	r3, [r7, #0]
 801b9ba:	461a      	mov	r2, r3
 801b9bc:	f107 0308 	add.w	r3, r7, #8
 801b9c0:	e893 0003 	ldmia.w	r3, {r0, r1}
 801b9c4:	e882 0003 	stmia.w	r2, {r0, r1}
}
 801b9c8:	bf00      	nop
 801b9ca:	3714      	adds	r7, #20
 801b9cc:	46bd      	mov	sp, r7
 801b9ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b9d2:	4770      	bx	lr

0801b9d4 <lv_draw_sw_triangle>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_sw_triangle(lv_draw_unit_t * draw_unit, const lv_draw_triangle_dsc_t * dsc)
{
 801b9d4:	b5b0      	push	{r4, r5, r7, lr}
 801b9d6:	b0da      	sub	sp, #360	@ 0x168
 801b9d8:	af02      	add	r7, sp, #8
 801b9da:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801b9de:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 801b9e2:	6018      	str	r0, [r3, #0]
 801b9e4:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801b9e8:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801b9ec:	6019      	str	r1, [r3, #0]
#if LV_DRAW_SW_COMPLEX
    lv_area_t tri_area;
    tri_area.x1 = (int32_t)LV_MIN3(dsc->p[0].x, dsc->p[1].x, dsc->p[2].x);
 801b9ee:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801b9f2:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801b9f6:	681b      	ldr	r3, [r3, #0]
 801b9f8:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 801b9fa:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801b9fe:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801ba02:	681b      	ldr	r3, [r3, #0]
 801ba04:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 801ba06:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801ba0a:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801ba0e:	681b      	ldr	r3, [r3, #0]
 801ba10:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801ba12:	428b      	cmp	r3, r1
 801ba14:	bfa8      	it	ge
 801ba16:	460b      	movge	r3, r1
 801ba18:	4293      	cmp	r3, r2
 801ba1a:	bfa8      	it	ge
 801ba1c:	4613      	movge	r3, r2
 801ba1e:	f8c7 3130 	str.w	r3, [r7, #304]	@ 0x130
    tri_area.y1 = (int32_t)LV_MIN3(dsc->p[0].y, dsc->p[1].y, dsc->p[2].y);
 801ba22:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801ba26:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801ba2a:	681b      	ldr	r3, [r3, #0]
 801ba2c:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 801ba2e:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801ba32:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801ba36:	681b      	ldr	r3, [r3, #0]
 801ba38:	6b99      	ldr	r1, [r3, #56]	@ 0x38
 801ba3a:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801ba3e:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801ba42:	681b      	ldr	r3, [r3, #0]
 801ba44:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801ba46:	428b      	cmp	r3, r1
 801ba48:	bfa8      	it	ge
 801ba4a:	460b      	movge	r3, r1
 801ba4c:	4293      	cmp	r3, r2
 801ba4e:	bfa8      	it	ge
 801ba50:	4613      	movge	r3, r2
 801ba52:	f8c7 3134 	str.w	r3, [r7, #308]	@ 0x134
    tri_area.x2 = (int32_t)LV_MAX3(dsc->p[0].x, dsc->p[1].x, dsc->p[2].x);
 801ba56:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801ba5a:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801ba5e:	681b      	ldr	r3, [r3, #0]
 801ba60:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 801ba62:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801ba66:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801ba6a:	681b      	ldr	r3, [r3, #0]
 801ba6c:	6b59      	ldr	r1, [r3, #52]	@ 0x34
 801ba6e:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801ba72:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801ba76:	681b      	ldr	r3, [r3, #0]
 801ba78:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801ba7a:	428b      	cmp	r3, r1
 801ba7c:	bfb8      	it	lt
 801ba7e:	460b      	movlt	r3, r1
 801ba80:	4293      	cmp	r3, r2
 801ba82:	bfb8      	it	lt
 801ba84:	4613      	movlt	r3, r2
 801ba86:	f8c7 3138 	str.w	r3, [r7, #312]	@ 0x138
    tri_area.y2 = (int32_t)LV_MAX3(dsc->p[0].y, dsc->p[1].y, dsc->p[2].y);
 801ba8a:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801ba8e:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801ba92:	681b      	ldr	r3, [r3, #0]
 801ba94:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 801ba96:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801ba9a:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801ba9e:	681b      	ldr	r3, [r3, #0]
 801baa0:	6b99      	ldr	r1, [r3, #56]	@ 0x38
 801baa2:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801baa6:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801baaa:	681b      	ldr	r3, [r3, #0]
 801baac:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801baae:	428b      	cmp	r3, r1
 801bab0:	bfb8      	it	lt
 801bab2:	460b      	movlt	r3, r1
 801bab4:	4293      	cmp	r3, r2
 801bab6:	bfb8      	it	lt
 801bab8:	4613      	movlt	r3, r2
 801baba:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c

    bool is_common;
    lv_area_t draw_area;
    is_common = _lv_area_intersect(&draw_area, &tri_area, draw_unit->clip_area);
 801babe:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bac2:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 801bac6:	681b      	ldr	r3, [r3, #0]
 801bac8:	689a      	ldr	r2, [r3, #8]
 801baca:	f507 7198 	add.w	r1, r7, #304	@ 0x130
 801bace:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bad2:	4618      	mov	r0, r3
 801bad4:	f005 ff38 	bl	8021948 <_lv_area_intersect>
 801bad8:	4603      	mov	r3, r0
 801bada:	f887 3153 	strb.w	r3, [r7, #339]	@ 0x153
    if(!is_common) return;
 801bade:	f897 3153 	ldrb.w	r3, [r7, #339]	@ 0x153
 801bae2:	f083 0301 	eor.w	r3, r3, #1
 801bae6:	b2db      	uxtb	r3, r3
 801bae8:	2b00      	cmp	r3, #0
 801baea:	f040 83bd 	bne.w	801c268 <lv_draw_sw_triangle+0x894>

    lv_point_t p[3];
    /*If there is a vertical side use it as p[0] and p[1]*/
    if(dsc->p[0].x == dsc->p[1].x) {
 801baee:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801baf2:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801baf6:	681b      	ldr	r3, [r3, #0]
 801baf8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 801bafa:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bafe:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bb02:	681b      	ldr	r3, [r3, #0]
 801bb04:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801bb06:	429a      	cmp	r2, r3
 801bb08:	d142      	bne.n	801bb90 <lv_draw_sw_triangle+0x1bc>
        p[0] = lv_point_from_precise(&dsc->p[0]);
 801bb0a:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bb0e:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bb12:	681b      	ldr	r3, [r3, #0]
 801bb14:	f103 022c 	add.w	r2, r3, #44	@ 0x2c
 801bb18:	463b      	mov	r3, r7
 801bb1a:	4611      	mov	r1, r2
 801bb1c:	4618      	mov	r0, r3
 801bb1e:	f7ff ff20 	bl	801b962 <lv_point_from_precise>
 801bb22:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bb26:	f5a3 72b0 	sub.w	r2, r3, #352	@ 0x160
 801bb2a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 801bb2e:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bb32:	e883 0003 	stmia.w	r3, {r0, r1}
        p[1] = lv_point_from_precise(&dsc->p[1]);
 801bb36:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bb3a:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bb3e:	681b      	ldr	r3, [r3, #0]
 801bb40:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 801bb44:	463b      	mov	r3, r7
 801bb46:	4611      	mov	r1, r2
 801bb48:	4618      	mov	r0, r3
 801bb4a:	f7ff ff0a 	bl	801b962 <lv_point_from_precise>
 801bb4e:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bb52:	f5a3 72b0 	sub.w	r2, r3, #352	@ 0x160
 801bb56:	f507 7388 	add.w	r3, r7, #272	@ 0x110
 801bb5a:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bb5e:	e883 0003 	stmia.w	r3, {r0, r1}
        p[2] = lv_point_from_precise(&dsc->p[2]);
 801bb62:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bb66:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bb6a:	681b      	ldr	r3, [r3, #0]
 801bb6c:	f103 023c 	add.w	r2, r3, #60	@ 0x3c
 801bb70:	463b      	mov	r3, r7
 801bb72:	4611      	mov	r1, r2
 801bb74:	4618      	mov	r0, r3
 801bb76:	f7ff fef4 	bl	801b962 <lv_point_from_precise>
 801bb7a:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bb7e:	f5a3 72b0 	sub.w	r2, r3, #352	@ 0x160
 801bb82:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801bb86:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bb8a:	e883 0003 	stmia.w	r3, {r0, r1}
 801bb8e:	e114      	b.n	801bdba <lv_draw_sw_triangle+0x3e6>
    }
    else if(dsc->p[0].x == dsc->p[2].x) {
 801bb90:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bb94:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bb98:	681b      	ldr	r3, [r3, #0]
 801bb9a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 801bb9c:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bba0:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bba4:	681b      	ldr	r3, [r3, #0]
 801bba6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801bba8:	429a      	cmp	r2, r3
 801bbaa:	d142      	bne.n	801bc32 <lv_draw_sw_triangle+0x25e>
        p[0] = lv_point_from_precise(&dsc->p[0]);
 801bbac:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bbb0:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bbb4:	681b      	ldr	r3, [r3, #0]
 801bbb6:	f103 022c 	add.w	r2, r3, #44	@ 0x2c
 801bbba:	463b      	mov	r3, r7
 801bbbc:	4611      	mov	r1, r2
 801bbbe:	4618      	mov	r0, r3
 801bbc0:	f7ff fecf 	bl	801b962 <lv_point_from_precise>
 801bbc4:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bbc8:	f5a3 72b0 	sub.w	r2, r3, #352	@ 0x160
 801bbcc:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 801bbd0:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bbd4:	e883 0003 	stmia.w	r3, {r0, r1}
        p[1] = lv_point_from_precise(&dsc->p[2]);
 801bbd8:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bbdc:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bbe0:	681b      	ldr	r3, [r3, #0]
 801bbe2:	f103 023c 	add.w	r2, r3, #60	@ 0x3c
 801bbe6:	463b      	mov	r3, r7
 801bbe8:	4611      	mov	r1, r2
 801bbea:	4618      	mov	r0, r3
 801bbec:	f7ff feb9 	bl	801b962 <lv_point_from_precise>
 801bbf0:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bbf4:	f5a3 72b0 	sub.w	r2, r3, #352	@ 0x160
 801bbf8:	f507 7388 	add.w	r3, r7, #272	@ 0x110
 801bbfc:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bc00:	e883 0003 	stmia.w	r3, {r0, r1}
        p[2] = lv_point_from_precise(&dsc->p[1]);
 801bc04:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bc08:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bc0c:	681b      	ldr	r3, [r3, #0]
 801bc0e:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 801bc12:	463b      	mov	r3, r7
 801bc14:	4611      	mov	r1, r2
 801bc16:	4618      	mov	r0, r3
 801bc18:	f7ff fea3 	bl	801b962 <lv_point_from_precise>
 801bc1c:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bc20:	f5a3 72b0 	sub.w	r2, r3, #352	@ 0x160
 801bc24:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801bc28:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bc2c:	e883 0003 	stmia.w	r3, {r0, r1}
 801bc30:	e0c3      	b.n	801bdba <lv_draw_sw_triangle+0x3e6>
    }
    else if(dsc->p[1].x == dsc->p[2].x) {
 801bc32:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bc36:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bc3a:	681b      	ldr	r3, [r3, #0]
 801bc3c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 801bc3e:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bc42:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bc46:	681b      	ldr	r3, [r3, #0]
 801bc48:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801bc4a:	429a      	cmp	r2, r3
 801bc4c:	d142      	bne.n	801bcd4 <lv_draw_sw_triangle+0x300>
        p[0] = lv_point_from_precise(&dsc->p[1]);
 801bc4e:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bc52:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bc56:	681b      	ldr	r3, [r3, #0]
 801bc58:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 801bc5c:	463b      	mov	r3, r7
 801bc5e:	4611      	mov	r1, r2
 801bc60:	4618      	mov	r0, r3
 801bc62:	f7ff fe7e 	bl	801b962 <lv_point_from_precise>
 801bc66:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bc6a:	f5a3 72b0 	sub.w	r2, r3, #352	@ 0x160
 801bc6e:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 801bc72:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bc76:	e883 0003 	stmia.w	r3, {r0, r1}
        p[1] = lv_point_from_precise(&dsc->p[2]);
 801bc7a:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bc7e:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bc82:	681b      	ldr	r3, [r3, #0]
 801bc84:	f103 023c 	add.w	r2, r3, #60	@ 0x3c
 801bc88:	463b      	mov	r3, r7
 801bc8a:	4611      	mov	r1, r2
 801bc8c:	4618      	mov	r0, r3
 801bc8e:	f7ff fe68 	bl	801b962 <lv_point_from_precise>
 801bc92:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bc96:	f5a3 72b0 	sub.w	r2, r3, #352	@ 0x160
 801bc9a:	f507 7388 	add.w	r3, r7, #272	@ 0x110
 801bc9e:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bca2:	e883 0003 	stmia.w	r3, {r0, r1}
        p[2] = lv_point_from_precise(&dsc->p[0]);
 801bca6:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bcaa:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bcae:	681b      	ldr	r3, [r3, #0]
 801bcb0:	f103 022c 	add.w	r2, r3, #44	@ 0x2c
 801bcb4:	463b      	mov	r3, r7
 801bcb6:	4611      	mov	r1, r2
 801bcb8:	4618      	mov	r0, r3
 801bcba:	f7ff fe52 	bl	801b962 <lv_point_from_precise>
 801bcbe:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bcc2:	f5a3 72b0 	sub.w	r2, r3, #352	@ 0x160
 801bcc6:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801bcca:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bcce:	e883 0003 	stmia.w	r3, {r0, r1}
 801bcd2:	e072      	b.n	801bdba <lv_draw_sw_triangle+0x3e6>
    }
    else {
        p[0] = lv_point_from_precise(&dsc->p[0]);
 801bcd4:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bcd8:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bcdc:	681b      	ldr	r3, [r3, #0]
 801bcde:	f103 022c 	add.w	r2, r3, #44	@ 0x2c
 801bce2:	463b      	mov	r3, r7
 801bce4:	4611      	mov	r1, r2
 801bce6:	4618      	mov	r0, r3
 801bce8:	f7ff fe3b 	bl	801b962 <lv_point_from_precise>
 801bcec:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bcf0:	f5a3 72b0 	sub.w	r2, r3, #352	@ 0x160
 801bcf4:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 801bcf8:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bcfc:	e883 0003 	stmia.w	r3, {r0, r1}
        p[1] = lv_point_from_precise(&dsc->p[1]);
 801bd00:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bd04:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bd08:	681b      	ldr	r3, [r3, #0]
 801bd0a:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 801bd0e:	463b      	mov	r3, r7
 801bd10:	4611      	mov	r1, r2
 801bd12:	4618      	mov	r0, r3
 801bd14:	f7ff fe25 	bl	801b962 <lv_point_from_precise>
 801bd18:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bd1c:	f5a3 72b0 	sub.w	r2, r3, #352	@ 0x160
 801bd20:	f507 7388 	add.w	r3, r7, #272	@ 0x110
 801bd24:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bd28:	e883 0003 	stmia.w	r3, {r0, r1}
        p[2] = lv_point_from_precise(&dsc->p[2]);
 801bd2c:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bd30:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bd34:	681b      	ldr	r3, [r3, #0]
 801bd36:	f103 023c 	add.w	r2, r3, #60	@ 0x3c
 801bd3a:	463b      	mov	r3, r7
 801bd3c:	4611      	mov	r1, r2
 801bd3e:	4618      	mov	r0, r3
 801bd40:	f7ff fe0f 	bl	801b962 <lv_point_from_precise>
 801bd44:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bd48:	f5a3 72b0 	sub.w	r2, r3, #352	@ 0x160
 801bd4c:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 801bd50:	e892 0003 	ldmia.w	r2, {r0, r1}
 801bd54:	e883 0003 	stmia.w	r3, {r0, r1}

        /*Set the smallest y as p[0]*/
        if(p[0].y > p[1].y) lv_point_swap(&p[0], &p[1]);
 801bd58:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 801bd5c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 801bd60:	429a      	cmp	r2, r3
 801bd62:	dd09      	ble.n	801bd78 <lv_draw_sw_triangle+0x3a4>
 801bd64:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 801bd68:	f103 0208 	add.w	r2, r3, #8
 801bd6c:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 801bd70:	4611      	mov	r1, r2
 801bd72:	4618      	mov	r0, r3
 801bd74:	f7ff fe0e 	bl	801b994 <lv_point_swap>
        if(p[0].y > p[2].y) lv_point_swap(&p[0], &p[2]);
 801bd78:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 801bd7c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801bd80:	429a      	cmp	r2, r3
 801bd82:	dd09      	ble.n	801bd98 <lv_draw_sw_triangle+0x3c4>
 801bd84:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 801bd88:	f103 0210 	add.w	r2, r3, #16
 801bd8c:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 801bd90:	4611      	mov	r1, r2
 801bd92:	4618      	mov	r0, r3
 801bd94:	f7ff fdfe 	bl	801b994 <lv_point_swap>

        /*Set the greatest y as p[1]*/
        if(p[1].y < p[2].y) lv_point_swap(&p[1], &p[2]);
 801bd98:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801bd9c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801bda0:	429a      	cmp	r2, r3
 801bda2:	da0a      	bge.n	801bdba <lv_draw_sw_triangle+0x3e6>
 801bda4:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 801bda8:	f103 0210 	add.w	r2, r3, #16
 801bdac:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 801bdb0:	3308      	adds	r3, #8
 801bdb2:	4611      	mov	r1, r2
 801bdb4:	4618      	mov	r0, r3
 801bdb6:	f7ff fded 	bl	801b994 <lv_point_swap>
    }

    /*Be sure p[0] is on the top*/
    if(p[0].y > p[1].y) lv_point_swap(&p[0], &p[1]);
 801bdba:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 801bdbe:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 801bdc2:	429a      	cmp	r2, r3
 801bdc4:	dd09      	ble.n	801bdda <lv_draw_sw_triangle+0x406>
 801bdc6:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 801bdca:	f103 0208 	add.w	r2, r3, #8
 801bdce:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 801bdd2:	4611      	mov	r1, r2
 801bdd4:	4618      	mov	r0, r3
 801bdd6:	f7ff fddd 	bl	801b994 <lv_point_swap>

    /*If right == true p[2] is on the right side of the p[0] p[1] line*/
    bool right = ((p[1].x - p[0].x) * (p[2].y - p[0].y) - (p[1].y - p[0].y) * (p[2].x - p[0].x)) < 0;
 801bdda:	f8d7 2110 	ldr.w	r2, [r7, #272]	@ 0x110
 801bdde:	f8d7 3108 	ldr.w	r3, [r7, #264]	@ 0x108
 801bde2:	1ad3      	subs	r3, r2, r3
 801bde4:	f8d7 111c 	ldr.w	r1, [r7, #284]	@ 0x11c
 801bde8:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 801bdec:	1a8a      	subs	r2, r1, r2
 801bdee:	fb03 f202 	mul.w	r2, r3, r2
 801bdf2:	f8d7 1114 	ldr.w	r1, [r7, #276]	@ 0x114
 801bdf6:	f8d7 310c 	ldr.w	r3, [r7, #268]	@ 0x10c
 801bdfa:	1acb      	subs	r3, r1, r3
 801bdfc:	f8d7 0118 	ldr.w	r0, [r7, #280]	@ 0x118
 801be00:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801be04:	1a41      	subs	r1, r0, r1
 801be06:	fb01 f303 	mul.w	r3, r1, r3
 801be0a:	1ad3      	subs	r3, r2, r3
 801be0c:	0fdb      	lsrs	r3, r3, #31
 801be0e:	f887 3152 	strb.w	r3, [r7, #338]	@ 0x152

    void * masks[4] = {0};
 801be12:	f107 03f8 	add.w	r3, r7, #248	@ 0xf8
 801be16:	2200      	movs	r2, #0
 801be18:	601a      	str	r2, [r3, #0]
 801be1a:	605a      	str	r2, [r3, #4]
 801be1c:	609a      	str	r2, [r3, #8]
 801be1e:	60da      	str	r2, [r3, #12]
    lv_draw_sw_mask_line_param_t mask_left;
    lv_draw_sw_mask_line_param_t mask_right;
    lv_draw_sw_mask_line_param_t mask_bottom;

    lv_draw_sw_mask_line_points_init(&mask_left, p[0].x, p[0].y,
 801be20:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801be24:	f8d7 210c 	ldr.w	r2, [r7, #268]	@ 0x10c
 801be28:	f8d7 4110 	ldr.w	r4, [r7, #272]	@ 0x110
 801be2c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 801be30:	f897 0152 	ldrb.w	r0, [r7, #338]	@ 0x152
 801be34:	4605      	mov	r5, r0
 801be36:	f107 00c0 	add.w	r0, r7, #192	@ 0xc0
 801be3a:	9501      	str	r5, [sp, #4]
 801be3c:	9300      	str	r3, [sp, #0]
 801be3e:	4623      	mov	r3, r4
 801be40:	f7fc fa08 	bl	8018254 <lv_draw_sw_mask_line_points_init>
                                     p[1].x, p[1].y,
                                     right ? LV_DRAW_SW_MASK_LINE_SIDE_RIGHT : LV_DRAW_SW_MASK_LINE_SIDE_LEFT);

    lv_draw_sw_mask_line_points_init(&mask_right, p[0].x, p[0].y,
 801be44:	f8d7 1108 	ldr.w	r1, [r7, #264]	@ 0x108
 801be48:	f8d7 410c 	ldr.w	r4, [r7, #268]	@ 0x10c
 801be4c:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 801be50:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
                                     p[2].x, p[2].y,
                                     right ? LV_DRAW_SW_MASK_LINE_SIDE_LEFT : LV_DRAW_SW_MASK_LINE_SIDE_RIGHT);
 801be54:	f897 2152 	ldrb.w	r2, [r7, #338]	@ 0x152
 801be58:	f082 0201 	eor.w	r2, r2, #1
 801be5c:	b2d2      	uxtb	r2, r2
    lv_draw_sw_mask_line_points_init(&mask_right, p[0].x, p[0].y,
 801be5e:	f107 0088 	add.w	r0, r7, #136	@ 0x88
 801be62:	9201      	str	r2, [sp, #4]
 801be64:	9300      	str	r3, [sp, #0]
 801be66:	462b      	mov	r3, r5
 801be68:	4622      	mov	r2, r4
 801be6a:	f7fc f9f3 	bl	8018254 <lv_draw_sw_mask_line_points_init>

    if(p[1].y == p[2].y) {
 801be6e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801be72:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801be76:	429a      	cmp	r2, r3
 801be78:	d110      	bne.n	801be9c <lv_draw_sw_triangle+0x4c8>
        lv_draw_sw_mask_line_points_init(&mask_bottom, p[1].x, p[1].y,
 801be7a:	f8d7 1110 	ldr.w	r1, [r7, #272]	@ 0x110
 801be7e:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 801be82:	f8d7 4118 	ldr.w	r4, [r7, #280]	@ 0x118
 801be86:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 801be8a:	f107 0050 	add.w	r0, r7, #80	@ 0x50
 801be8e:	2502      	movs	r5, #2
 801be90:	9501      	str	r5, [sp, #4]
 801be92:	9300      	str	r3, [sp, #0]
 801be94:	4623      	mov	r3, r4
 801be96:	f7fc f9dd 	bl	8018254 <lv_draw_sw_mask_line_points_init>
 801be9a:	e014      	b.n	801bec6 <lv_draw_sw_triangle+0x4f2>
                                         p[2].x, p[2].y, LV_DRAW_SW_MASK_LINE_SIDE_TOP);
    }
    else {
        lv_draw_sw_mask_line_points_init(&mask_bottom, p[1].x, p[1].y,
 801be9c:	f8d7 1110 	ldr.w	r1, [r7, #272]	@ 0x110
 801bea0:	f8d7 4114 	ldr.w	r4, [r7, #276]	@ 0x114
 801bea4:	f8d7 5118 	ldr.w	r5, [r7, #280]	@ 0x118
 801bea8:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
                                         p[2].x, p[2].y,
                                         right ? LV_DRAW_SW_MASK_LINE_SIDE_LEFT  : LV_DRAW_SW_MASK_LINE_SIDE_RIGHT);
 801beac:	f897 2152 	ldrb.w	r2, [r7, #338]	@ 0x152
 801beb0:	f082 0201 	eor.w	r2, r2, #1
 801beb4:	b2d2      	uxtb	r2, r2
        lv_draw_sw_mask_line_points_init(&mask_bottom, p[1].x, p[1].y,
 801beb6:	f107 0050 	add.w	r0, r7, #80	@ 0x50
 801beba:	9201      	str	r2, [sp, #4]
 801bebc:	9300      	str	r3, [sp, #0]
 801bebe:	462b      	mov	r3, r5
 801bec0:	4622      	mov	r2, r4
 801bec2:	f7fc f9c7 	bl	8018254 <lv_draw_sw_mask_line_points_init>
    }

    masks[0] = &mask_left;
 801bec6:	f107 03c0 	add.w	r3, r7, #192	@ 0xc0
 801beca:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
    masks[1] = &mask_right;
 801bece:	f107 0388 	add.w	r3, r7, #136	@ 0x88
 801bed2:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
    masks[2] = &mask_bottom;
 801bed6:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 801beda:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
    int32_t area_w = lv_area_get_width(&draw_area);
 801bede:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bee2:	4618      	mov	r0, r3
 801bee4:	f7ff fd1d 	bl	801b922 <lv_area_get_width>
 801bee8:	f8c7 014c 	str.w	r0, [r7, #332]	@ 0x14c
    lv_opa_t * mask_buf = lv_malloc(area_w);
 801beec:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801bef0:	4618      	mov	r0, r3
 801bef2:	f009 ff69 	bl	8025dc8 <lv_malloc>
 801bef6:	f8c7 0148 	str.w	r0, [r7, #328]	@ 0x148

    lv_area_t blend_area = draw_area;
 801befa:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801befe:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801bf02:	461c      	mov	r4, r3
 801bf04:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 801bf08:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801bf0a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    blend_area.y2 = blend_area.y1;
 801bf0e:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bf12:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801bf16:	685a      	ldr	r2, [r3, #4]
 801bf18:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bf1c:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801bf20:	60da      	str	r2, [r3, #12]
    lv_draw_sw_blend_dsc_t blend_dsc;
    blend_dsc.color = dsc->bg_color;
 801bf22:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bf26:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801bf2a:	f507 72b0 	add.w	r2, r7, #352	@ 0x160
 801bf2e:	f5a2 72ac 	sub.w	r2, r2, #344	@ 0x158
 801bf32:	6812      	ldr	r2, [r2, #0]
 801bf34:	3315      	adds	r3, #21
 801bf36:	321d      	adds	r2, #29
 801bf38:	8811      	ldrh	r1, [r2, #0]
 801bf3a:	7892      	ldrb	r2, [r2, #2]
 801bf3c:	8019      	strh	r1, [r3, #0]
 801bf3e:	709a      	strb	r2, [r3, #2]
    blend_dsc.opa = dsc->bg_opa;
 801bf40:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bf44:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bf48:	681b      	ldr	r3, [r3, #0]
 801bf4a:	7f1a      	ldrb	r2, [r3, #28]
 801bf4c:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bf50:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801bf54:	751a      	strb	r2, [r3, #20]
    blend_dsc.mask_buf = mask_buf;
 801bf56:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bf5a:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801bf5e:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801bf62:	619a      	str	r2, [r3, #24]
    blend_dsc.blend_area = &blend_area;
 801bf64:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bf68:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801bf6c:	f107 0240 	add.w	r2, r7, #64	@ 0x40
 801bf70:	601a      	str	r2, [r3, #0]
    blend_dsc.mask_area = &blend_area;
 801bf72:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bf76:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801bf7a:	f107 0240 	add.w	r2, r7, #64	@ 0x40
 801bf7e:	621a      	str	r2, [r3, #32]
    blend_dsc.blend_mode = LV_BLEND_MODE_NORMAL;
 801bf80:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bf84:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801bf88:	2200      	movs	r2, #0
 801bf8a:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
    blend_dsc.src_buf = NULL;
 801bf8e:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bf92:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801bf96:	2200      	movs	r2, #0
 801bf98:	605a      	str	r2, [r3, #4]

    lv_grad_dir_t grad_dir = dsc->bg_grad.dir;
 801bf9a:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bf9e:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bfa2:	681b      	ldr	r3, [r3, #0]
 801bfa4:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 801bfa8:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801bfac:	b2db      	uxtb	r3, r3
 801bfae:	f887 3147 	strb.w	r3, [r7, #327]	@ 0x147

    lv_grad_t * grad = lv_gradient_get(&dsc->bg_grad, lv_area_get_width(&tri_area), lv_area_get_height(&tri_area));
 801bfb2:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801bfb6:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801bfba:	681b      	ldr	r3, [r3, #0]
 801bfbc:	f103 0420 	add.w	r4, r3, #32
 801bfc0:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801bfc4:	4618      	mov	r0, r3
 801bfc6:	f7ff fcac 	bl	801b922 <lv_area_get_width>
 801bfca:	4605      	mov	r5, r0
 801bfcc:	f507 7398 	add.w	r3, r7, #304	@ 0x130
 801bfd0:	4618      	mov	r0, r3
 801bfd2:	f7ff fcb6 	bl	801b942 <lv_area_get_height>
 801bfd6:	4603      	mov	r3, r0
 801bfd8:	461a      	mov	r2, r3
 801bfda:	4629      	mov	r1, r5
 801bfdc:	4620      	mov	r0, r4
 801bfde:	f7fa f906 	bl	80161ee <lv_gradient_get>
 801bfe2:	f8c7 0140 	str.w	r0, [r7, #320]	@ 0x140
    lv_opa_t * grad_opa_map = NULL;
 801bfe6:	2300      	movs	r3, #0
 801bfe8:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
    if(grad && grad_dir == LV_GRAD_DIR_HOR) {
 801bfec:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801bff0:	2b00      	cmp	r3, #0
 801bff2:	d02e      	beq.n	801c052 <lv_draw_sw_triangle+0x67e>
 801bff4:	f897 3147 	ldrb.w	r3, [r7, #327]	@ 0x147
 801bff8:	2b02      	cmp	r3, #2
 801bffa:	d12a      	bne.n	801c052 <lv_draw_sw_triangle+0x67e>
        blend_dsc.src_area = &blend_area;
 801bffc:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c000:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c004:	f107 0240 	add.w	r2, r7, #64	@ 0x40
 801c008:	611a      	str	r2, [r3, #16]
        blend_dsc.src_buf = grad->color_map + draw_area.x1 - tri_area.x1;
 801c00a:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801c00e:	6819      	ldr	r1, [r3, #0]
 801c010:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801c014:	461a      	mov	r2, r3
 801c016:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801c01a:	1ad2      	subs	r2, r2, r3
 801c01c:	4613      	mov	r3, r2
 801c01e:	005b      	lsls	r3, r3, #1
 801c020:	4413      	add	r3, r2
 801c022:	18ca      	adds	r2, r1, r3
 801c024:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c028:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c02c:	605a      	str	r2, [r3, #4]
        grad_opa_map = grad->opa_map + draw_area.x1 - tri_area.x1;
 801c02e:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801c032:	685a      	ldr	r2, [r3, #4]
 801c034:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 801c038:	4619      	mov	r1, r3
 801c03a:	f8d7 3130 	ldr.w	r3, [r7, #304]	@ 0x130
 801c03e:	1acb      	subs	r3, r1, r3
 801c040:	4413      	add	r3, r2
 801c042:	f8c7 315c 	str.w	r3, [r7, #348]	@ 0x15c
        blend_dsc.src_color_format = LV_COLOR_FORMAT_RGB888;
 801c046:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c04a:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c04e:	220f      	movs	r2, #15
 801c050:	731a      	strb	r2, [r3, #12]
    }

    int32_t y;
    for(y = draw_area.y1; y <= draw_area.y2; y++) {
 801c052:	f8d7 3124 	ldr.w	r3, [r7, #292]	@ 0x124
 801c056:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
 801c05a:	e0e2      	b.n	801c222 <lv_draw_sw_triangle+0x84e>
        blend_area.y1 = y;
 801c05c:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c060:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801c064:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801c068:	605a      	str	r2, [r3, #4]
        blend_area.y2 = y;
 801c06a:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c06e:	f5a3 7390 	sub.w	r3, r3, #288	@ 0x120
 801c072:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801c076:	60da      	str	r2, [r3, #12]
        lv_memset(mask_buf, 0xff, area_w);
 801c078:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801c07c:	461a      	mov	r2, r3
 801c07e:	21ff      	movs	r1, #255	@ 0xff
 801c080:	f8d7 0148 	ldr.w	r0, [r7, #328]	@ 0x148
 801c084:	f008 fecd 	bl	8024e22 <lv_memset>
        blend_dsc.mask_res = lv_draw_sw_mask_apply(masks, mask_buf, draw_area.x1, y, area_w);
 801c088:	f8d7 2120 	ldr.w	r2, [r7, #288]	@ 0x120
 801c08c:	f107 00f8 	add.w	r0, r7, #248	@ 0xf8
 801c090:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801c094:	9300      	str	r3, [sp, #0]
 801c096:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801c09a:	f8d7 1148 	ldr.w	r1, [r7, #328]	@ 0x148
 801c09e:	f7fc f865 	bl	801816c <lv_draw_sw_mask_apply>
 801c0a2:	4603      	mov	r3, r0
 801c0a4:	461a      	mov	r2, r3
 801c0a6:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c0aa:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c0ae:	771a      	strb	r2, [r3, #28]
        if(grad_dir == LV_GRAD_DIR_VER) {
 801c0b0:	f897 3147 	ldrb.w	r3, [r7, #327]	@ 0x147
 801c0b4:	2b01      	cmp	r3, #1
 801c0b6:	d142      	bne.n	801c13e <lv_draw_sw_triangle+0x76a>
            blend_dsc.color = grad->color_map[y - tri_area.y1];
 801c0b8:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801c0bc:	681a      	ldr	r2, [r3, #0]
 801c0be:	f8d7 3134 	ldr.w	r3, [r7, #308]	@ 0x134
 801c0c2:	f8d7 1158 	ldr.w	r1, [r7, #344]	@ 0x158
 801c0c6:	1acb      	subs	r3, r1, r3
 801c0c8:	4619      	mov	r1, r3
 801c0ca:	460b      	mov	r3, r1
 801c0cc:	005b      	lsls	r3, r3, #1
 801c0ce:	440b      	add	r3, r1
 801c0d0:	441a      	add	r2, r3
 801c0d2:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c0d6:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c0da:	3315      	adds	r3, #21
 801c0dc:	8811      	ldrh	r1, [r2, #0]
 801c0de:	7892      	ldrb	r2, [r2, #2]
 801c0e0:	8019      	strh	r1, [r3, #0]
 801c0e2:	709a      	strb	r2, [r3, #2]
            blend_dsc.opa = grad->opa_map[y - tri_area.y1];
 801c0e4:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801c0e8:	685b      	ldr	r3, [r3, #4]
 801c0ea:	f8d7 2134 	ldr.w	r2, [r7, #308]	@ 0x134
 801c0ee:	f8d7 1158 	ldr.w	r1, [r7, #344]	@ 0x158
 801c0f2:	1a8a      	subs	r2, r1, r2
 801c0f4:	4413      	add	r3, r2
 801c0f6:	781a      	ldrb	r2, [r3, #0]
 801c0f8:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c0fc:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c100:	751a      	strb	r2, [r3, #20]
            if(dsc->bg_opa < LV_OPA_MAX) blend_dsc.opa = LV_OPA_MIX2(blend_dsc.opa, dsc->bg_opa);
 801c102:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c106:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801c10a:	681b      	ldr	r3, [r3, #0]
 801c10c:	7f1b      	ldrb	r3, [r3, #28]
 801c10e:	2bfc      	cmp	r3, #252	@ 0xfc
 801c110:	d876      	bhi.n	801c200 <lv_draw_sw_triangle+0x82c>
 801c112:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c116:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c11a:	7d1b      	ldrb	r3, [r3, #20]
 801c11c:	461a      	mov	r2, r3
 801c11e:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c122:	f5a3 73ac 	sub.w	r3, r3, #344	@ 0x158
 801c126:	681b      	ldr	r3, [r3, #0]
 801c128:	7f1b      	ldrb	r3, [r3, #28]
 801c12a:	fb02 f303 	mul.w	r3, r2, r3
 801c12e:	121b      	asrs	r3, r3, #8
 801c130:	b2da      	uxtb	r2, r3
 801c132:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c136:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c13a:	751a      	strb	r2, [r3, #20]
 801c13c:	e060      	b.n	801c200 <lv_draw_sw_triangle+0x82c>
        }
        else if(grad_dir == LV_GRAD_DIR_HOR) {
 801c13e:	f897 3147 	ldrb.w	r3, [r7, #327]	@ 0x147
 801c142:	2b02      	cmp	r3, #2
 801c144:	d15c      	bne.n	801c200 <lv_draw_sw_triangle+0x82c>
            if(grad_opa_map) {
 801c146:	f8d7 315c 	ldr.w	r3, [r7, #348]	@ 0x15c
 801c14a:	2b00      	cmp	r3, #0
 801c14c:	d058      	beq.n	801c200 <lv_draw_sw_triangle+0x82c>
                int32_t i;
                if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_CHANGED) {
 801c14e:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c152:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c156:	7f1b      	ldrb	r3, [r3, #28]
 801c158:	2b02      	cmp	r3, #2
 801c15a:	d135      	bne.n	801c1c8 <lv_draw_sw_triangle+0x7f4>
                    blend_dsc.mask_buf = mask_buf;
 801c15c:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c160:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c164:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801c168:	619a      	str	r2, [r3, #24]
                    for(i = 0; i < area_w; i++) {
 801c16a:	2300      	movs	r3, #0
 801c16c:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
 801c170:	e023      	b.n	801c1ba <lv_draw_sw_triangle+0x7e6>
                        if(grad_opa_map[i] < LV_OPA_MAX) mask_buf[i] = LV_OPA_MIX2(mask_buf[i], grad_opa_map[i]);
 801c172:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801c176:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801c17a:	4413      	add	r3, r2
 801c17c:	781b      	ldrb	r3, [r3, #0]
 801c17e:	2bfc      	cmp	r3, #252	@ 0xfc
 801c180:	d816      	bhi.n	801c1b0 <lv_draw_sw_triangle+0x7dc>
 801c182:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801c186:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801c18a:	4413      	add	r3, r2
 801c18c:	781b      	ldrb	r3, [r3, #0]
 801c18e:	4619      	mov	r1, r3
 801c190:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801c194:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801c198:	4413      	add	r3, r2
 801c19a:	781b      	ldrb	r3, [r3, #0]
 801c19c:	fb01 f303 	mul.w	r3, r1, r3
 801c1a0:	1219      	asrs	r1, r3, #8
 801c1a2:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801c1a6:	f8d7 2148 	ldr.w	r2, [r7, #328]	@ 0x148
 801c1aa:	4413      	add	r3, r2
 801c1ac:	b2ca      	uxtb	r2, r1
 801c1ae:	701a      	strb	r2, [r3, #0]
                    for(i = 0; i < area_w; i++) {
 801c1b0:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 801c1b4:	3301      	adds	r3, #1
 801c1b6:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
 801c1ba:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 801c1be:	f8d7 314c 	ldr.w	r3, [r7, #332]	@ 0x14c
 801c1c2:	429a      	cmp	r2, r3
 801c1c4:	dbd5      	blt.n	801c172 <lv_draw_sw_triangle+0x79e>
 801c1c6:	e01b      	b.n	801c200 <lv_draw_sw_triangle+0x82c>
                    }
                }
                else if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_FULL_COVER) {
 801c1c8:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c1cc:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c1d0:	7f1b      	ldrb	r3, [r3, #28]
 801c1d2:	2b01      	cmp	r3, #1
 801c1d4:	d10d      	bne.n	801c1f2 <lv_draw_sw_triangle+0x81e>
                    blend_dsc.mask_buf = grad_opa_map;
 801c1d6:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c1da:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c1de:	f8d7 215c 	ldr.w	r2, [r7, #348]	@ 0x15c
 801c1e2:	619a      	str	r2, [r3, #24]
                    blend_dsc.mask_res = LV_DRAW_SW_MASK_RES_CHANGED;
 801c1e4:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c1e8:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c1ec:	2202      	movs	r2, #2
 801c1ee:	771a      	strb	r2, [r3, #28]
 801c1f0:	e006      	b.n	801c200 <lv_draw_sw_triangle+0x82c>
                }
                else if(blend_dsc.mask_res == LV_DRAW_SW_MASK_RES_TRANSP) {
 801c1f2:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c1f6:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 801c1fa:	7f1b      	ldrb	r3, [r3, #28]
 801c1fc:	2b00      	cmp	r3, #0
 801c1fe:	d00a      	beq.n	801c216 <lv_draw_sw_triangle+0x842>
                    continue;
                }
            }
        }
        lv_draw_sw_blend(draw_unit, &blend_dsc);
 801c200:	f107 0214 	add.w	r2, r7, #20
 801c204:	f507 73b0 	add.w	r3, r7, #352	@ 0x160
 801c208:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 801c20c:	4611      	mov	r1, r2
 801c20e:	6818      	ldr	r0, [r3, #0]
 801c210:	f7f2 fb80 	bl	800e914 <lv_draw_sw_blend>
 801c214:	e000      	b.n	801c218 <lv_draw_sw_triangle+0x844>
                    continue;
 801c216:	bf00      	nop
    for(y = draw_area.y1; y <= draw_area.y2; y++) {
 801c218:	f8d7 3158 	ldr.w	r3, [r7, #344]	@ 0x158
 801c21c:	3301      	adds	r3, #1
 801c21e:	f8c7 3158 	str.w	r3, [r7, #344]	@ 0x158
 801c222:	f8d7 312c 	ldr.w	r3, [r7, #300]	@ 0x12c
 801c226:	f8d7 2158 	ldr.w	r2, [r7, #344]	@ 0x158
 801c22a:	429a      	cmp	r2, r3
 801c22c:	f77f af16 	ble.w	801c05c <lv_draw_sw_triangle+0x688>
    }

    lv_free(mask_buf);
 801c230:	f8d7 0148 	ldr.w	r0, [r7, #328]	@ 0x148
 801c234:	f009 fe00 	bl	8025e38 <lv_free>
    lv_draw_sw_mask_free_param(&mask_bottom);
 801c238:	f107 0350 	add.w	r3, r7, #80	@ 0x50
 801c23c:	4618      	mov	r0, r3
 801c23e:	f7fb ffd7 	bl	80181f0 <lv_draw_sw_mask_free_param>
    lv_draw_sw_mask_free_param(&mask_left);
 801c242:	f107 03c0 	add.w	r3, r7, #192	@ 0xc0
 801c246:	4618      	mov	r0, r3
 801c248:	f7fb ffd2 	bl	80181f0 <lv_draw_sw_mask_free_param>
    lv_draw_sw_mask_free_param(&mask_right);
 801c24c:	f107 0388 	add.w	r3, r7, #136	@ 0x88
 801c250:	4618      	mov	r0, r3
 801c252:	f7fb ffcd 	bl	80181f0 <lv_draw_sw_mask_free_param>

    if(grad) {
 801c256:	f8d7 3140 	ldr.w	r3, [r7, #320]	@ 0x140
 801c25a:	2b00      	cmp	r3, #0
 801c25c:	d005      	beq.n	801c26a <lv_draw_sw_triangle+0x896>
        lv_gradient_cleanup(grad);
 801c25e:	f8d7 0140 	ldr.w	r0, [r7, #320]	@ 0x140
 801c262:	f7fa f947 	bl	80164f4 <lv_gradient_cleanup>
 801c266:	e000      	b.n	801c26a <lv_draw_sw_triangle+0x896>
    if(!is_common) return;
 801c268:	bf00      	nop
#else
    LV_UNUSED(draw_unit);
    LV_UNUSED(dsc);
    LV_LOG_WARN("Can't draw triangles with LV_DRAW_SW_COMPLEX == 0");
#endif /*LV_DRAW_SW_COMPLEX*/
}
 801c26a:	f507 77b0 	add.w	r7, r7, #352	@ 0x160
 801c26e:	46bd      	mov	sp, r7
 801c270:	bdb0      	pop	{r4, r5, r7, pc}

0801c272 <_lv_text_is_marker>:
 *
 * @param letter a letter
 * @return true if so
 */
static inline bool _lv_text_is_marker(uint32_t letter)
{
 801c272:	b480      	push	{r7}
 801c274:	b083      	sub	sp, #12
 801c276:	af00      	add	r7, sp, #0
 801c278:	6078      	str	r0, [r7, #4]
    if(letter < 0x20) return true;
 801c27a:	687b      	ldr	r3, [r7, #4]
 801c27c:	2b1f      	cmp	r3, #31
 801c27e:	d801      	bhi.n	801c284 <_lv_text_is_marker+0x12>
 801c280:	2301      	movs	r3, #1
 801c282:	e052      	b.n	801c32a <_lv_text_is_marker+0xb8>

    /*U+061C ARABIC LETTER MARK, see https://www.compart.com/en/unicode/block/U+0600*/
    if(letter == 0x061C) return true;
 801c284:	687b      	ldr	r3, [r7, #4]
 801c286:	f240 621c 	movw	r2, #1564	@ 0x61c
 801c28a:	4293      	cmp	r3, r2
 801c28c:	d101      	bne.n	801c292 <_lv_text_is_marker+0x20>
 801c28e:	2301      	movs	r3, #1
 801c290:	e04b      	b.n	801c32a <_lv_text_is_marker+0xb8>

    /*U+115F HANGUL CHOSEONG FILLER, See https://www.compart.com/en/unicode/block/U+1100*/
    if(letter == 0x115F) return true;
 801c292:	687b      	ldr	r3, [r7, #4]
 801c294:	f241 125f 	movw	r2, #4447	@ 0x115f
 801c298:	4293      	cmp	r3, r2
 801c29a:	d101      	bne.n	801c2a0 <_lv_text_is_marker+0x2e>
 801c29c:	2301      	movs	r3, #1
 801c29e:	e044      	b.n	801c32a <_lv_text_is_marker+0xb8>
    /*U+1160 HANGUL JUNGSEONG FILLER*/
    if(letter == 0x1160) return true;
 801c2a0:	687b      	ldr	r3, [r7, #4]
 801c2a2:	f5b3 5f8b 	cmp.w	r3, #4448	@ 0x1160
 801c2a6:	d101      	bne.n	801c2ac <_lv_text_is_marker+0x3a>
 801c2a8:	2301      	movs	r3, #1
 801c2aa:	e03e      	b.n	801c32a <_lv_text_is_marker+0xb8>

    /*See https://www.compart.com/en/unicode/block/U+1800*/
    if(letter >= 0x180B && letter <= 0x180E) return true;
 801c2ac:	687b      	ldr	r3, [r7, #4]
 801c2ae:	f641 020a 	movw	r2, #6154	@ 0x180a
 801c2b2:	4293      	cmp	r3, r2
 801c2b4:	d906      	bls.n	801c2c4 <_lv_text_is_marker+0x52>
 801c2b6:	687b      	ldr	r3, [r7, #4]
 801c2b8:	f641 020e 	movw	r2, #6158	@ 0x180e
 801c2bc:	4293      	cmp	r3, r2
 801c2be:	d801      	bhi.n	801c2c4 <_lv_text_is_marker+0x52>
 801c2c0:	2301      	movs	r3, #1
 801c2c2:	e032      	b.n	801c32a <_lv_text_is_marker+0xb8>

    /*See https://www.compart.com/en/unicode/block/U+2000*/
    if(letter >= 0x200B && letter <= 0x200F) return true;
 801c2c4:	687b      	ldr	r3, [r7, #4]
 801c2c6:	f242 020a 	movw	r2, #8202	@ 0x200a
 801c2ca:	4293      	cmp	r3, r2
 801c2cc:	d906      	bls.n	801c2dc <_lv_text_is_marker+0x6a>
 801c2ce:	687b      	ldr	r3, [r7, #4]
 801c2d0:	f242 020f 	movw	r2, #8207	@ 0x200f
 801c2d4:	4293      	cmp	r3, r2
 801c2d6:	d801      	bhi.n	801c2dc <_lv_text_is_marker+0x6a>
 801c2d8:	2301      	movs	r3, #1
 801c2da:	e026      	b.n	801c32a <_lv_text_is_marker+0xb8>
    if(letter >= 0x2028 && letter <= 0x202F) return true;
 801c2dc:	687b      	ldr	r3, [r7, #4]
 801c2de:	f242 0227 	movw	r2, #8231	@ 0x2027
 801c2e2:	4293      	cmp	r3, r2
 801c2e4:	d906      	bls.n	801c2f4 <_lv_text_is_marker+0x82>
 801c2e6:	687b      	ldr	r3, [r7, #4]
 801c2e8:	f242 022f 	movw	r2, #8239	@ 0x202f
 801c2ec:	4293      	cmp	r3, r2
 801c2ee:	d801      	bhi.n	801c2f4 <_lv_text_is_marker+0x82>
 801c2f0:	2301      	movs	r3, #1
 801c2f2:	e01a      	b.n	801c32a <_lv_text_is_marker+0xb8>
    if(letter >= 0x205F && letter <= 0x206F) return true;
 801c2f4:	687b      	ldr	r3, [r7, #4]
 801c2f6:	f242 025e 	movw	r2, #8286	@ 0x205e
 801c2fa:	4293      	cmp	r3, r2
 801c2fc:	d906      	bls.n	801c30c <_lv_text_is_marker+0x9a>
 801c2fe:	687b      	ldr	r3, [r7, #4]
 801c300:	f242 026f 	movw	r2, #8303	@ 0x206f
 801c304:	4293      	cmp	r3, r2
 801c306:	d801      	bhi.n	801c30c <_lv_text_is_marker+0x9a>
 801c308:	2301      	movs	r3, #1
 801c30a:	e00e      	b.n	801c32a <_lv_text_is_marker+0xb8>

    /*U+FEFF ZERO WIDTH NO-BREAK SPACE, see https://www.compart.com/en/unicode/block/U+FE70*/
    if(letter == 0xFEFF) return true;
 801c30c:	687b      	ldr	r3, [r7, #4]
 801c30e:	f64f 62ff 	movw	r2, #65279	@ 0xfeff
 801c312:	4293      	cmp	r3, r2
 801c314:	d101      	bne.n	801c31a <_lv_text_is_marker+0xa8>
 801c316:	2301      	movs	r3, #1
 801c318:	e007      	b.n	801c32a <_lv_text_is_marker+0xb8>

    if(letter == 0xF8FF) return true; /*LV_SYMBOL_DUMMY*/
 801c31a:	687b      	ldr	r3, [r7, #4]
 801c31c:	f64f 02ff 	movw	r2, #63743	@ 0xf8ff
 801c320:	4293      	cmp	r3, r2
 801c322:	d101      	bne.n	801c328 <_lv_text_is_marker+0xb6>
 801c324:	2301      	movs	r3, #1
 801c326:	e000      	b.n	801c32a <_lv_text_is_marker+0xb8>

    return false;
 801c328:	2300      	movs	r3, #0
}
 801c32a:	4618      	mov	r0, r3
 801c32c:	370c      	adds	r7, #12
 801c32e:	46bd      	mov	sp, r7
 801c330:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c334:	4770      	bx	lr

0801c336 <lv_font_get_glyph_bitmap>:
 *   GLOBAL FUNCTIONS
 **********************/

const void * lv_font_get_glyph_bitmap(lv_font_glyph_dsc_t * g_dsc, uint32_t letter,
                                      lv_draw_buf_t * draw_buf)
{
 801c336:	b580      	push	{r7, lr}
 801c338:	b086      	sub	sp, #24
 801c33a:	af00      	add	r7, sp, #0
 801c33c:	60f8      	str	r0, [r7, #12]
 801c33e:	60b9      	str	r1, [r7, #8]
 801c340:	607a      	str	r2, [r7, #4]
    const lv_font_t * font_p = g_dsc->resolved_font;
 801c342:	68fb      	ldr	r3, [r7, #12]
 801c344:	681b      	ldr	r3, [r3, #0]
 801c346:	617b      	str	r3, [r7, #20]
    LV_ASSERT_NULL(font_p);
 801c348:	697b      	ldr	r3, [r7, #20]
 801c34a:	2b00      	cmp	r3, #0
 801c34c:	d101      	bne.n	801c352 <lv_font_get_glyph_bitmap+0x1c>
 801c34e:	bf00      	nop
 801c350:	e7fd      	b.n	801c34e <lv_font_get_glyph_bitmap+0x18>
    return font_p->get_glyph_bitmap(g_dsc, letter, draw_buf);
 801c352:	697b      	ldr	r3, [r7, #20]
 801c354:	685b      	ldr	r3, [r3, #4]
 801c356:	687a      	ldr	r2, [r7, #4]
 801c358:	68b9      	ldr	r1, [r7, #8]
 801c35a:	68f8      	ldr	r0, [r7, #12]
 801c35c:	4798      	blx	r3
 801c35e:	4603      	mov	r3, r0
}
 801c360:	4618      	mov	r0, r3
 801c362:	3718      	adds	r7, #24
 801c364:	46bd      	mov	sp, r7
 801c366:	bd80      	pop	{r7, pc}

0801c368 <lv_font_get_glyph_dsc>:

bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter,
                           uint32_t letter_next)
{
 801c368:	b590      	push	{r4, r7, lr}
 801c36a:	b089      	sub	sp, #36	@ 0x24
 801c36c:	af00      	add	r7, sp, #0
 801c36e:	60f8      	str	r0, [r7, #12]
 801c370:	60b9      	str	r1, [r7, #8]
 801c372:	607a      	str	r2, [r7, #4]
 801c374:	603b      	str	r3, [r7, #0]

    LV_ASSERT_NULL(font_p);
 801c376:	68fb      	ldr	r3, [r7, #12]
 801c378:	2b00      	cmp	r3, #0
 801c37a:	d101      	bne.n	801c380 <lv_font_get_glyph_dsc+0x18>
 801c37c:	bf00      	nop
 801c37e:	e7fd      	b.n	801c37c <lv_font_get_glyph_dsc+0x14>
    LV_ASSERT_NULL(dsc_out);
 801c380:	68bb      	ldr	r3, [r7, #8]
 801c382:	2b00      	cmp	r3, #0
 801c384:	d101      	bne.n	801c38a <lv_font_get_glyph_dsc+0x22>
 801c386:	bf00      	nop
 801c388:	e7fd      	b.n	801c386 <lv_font_get_glyph_dsc+0x1e>

#if LV_USE_FONT_PLACEHOLDER
    const lv_font_t * placeholder_font = NULL;
 801c38a:	2300      	movs	r3, #0
 801c38c:	61fb      	str	r3, [r7, #28]
#endif

    const lv_font_t * f = font_p;
 801c38e:	68fb      	ldr	r3, [r7, #12]
 801c390:	61bb      	str	r3, [r7, #24]

    dsc_out->resolved_font = NULL;
 801c392:	68bb      	ldr	r3, [r7, #8]
 801c394:	2200      	movs	r2, #0
 801c396:	601a      	str	r2, [r3, #0]

    while(f) {
 801c398:	e028      	b.n	801c3ec <lv_font_get_glyph_dsc+0x84>
        bool found = f->get_glyph_dsc(f, dsc_out, letter, f->kerning == LV_FONT_KERNING_NONE ? 0 : letter_next);
 801c39a:	69bb      	ldr	r3, [r7, #24]
 801c39c:	681c      	ldr	r4, [r3, #0]
 801c39e:	69bb      	ldr	r3, [r7, #24]
 801c3a0:	7d1b      	ldrb	r3, [r3, #20]
 801c3a2:	f003 0304 	and.w	r3, r3, #4
 801c3a6:	b2db      	uxtb	r3, r3
 801c3a8:	2b00      	cmp	r3, #0
 801c3aa:	d101      	bne.n	801c3b0 <lv_font_get_glyph_dsc+0x48>
 801c3ac:	683b      	ldr	r3, [r7, #0]
 801c3ae:	e000      	b.n	801c3b2 <lv_font_get_glyph_dsc+0x4a>
 801c3b0:	2300      	movs	r3, #0
 801c3b2:	687a      	ldr	r2, [r7, #4]
 801c3b4:	68b9      	ldr	r1, [r7, #8]
 801c3b6:	69b8      	ldr	r0, [r7, #24]
 801c3b8:	47a0      	blx	r4
 801c3ba:	4603      	mov	r3, r0
 801c3bc:	75fb      	strb	r3, [r7, #23]
        if(found) {
 801c3be:	7dfb      	ldrb	r3, [r7, #23]
 801c3c0:	2b00      	cmp	r3, #0
 801c3c2:	d010      	beq.n	801c3e6 <lv_font_get_glyph_dsc+0x7e>
            if(!dsc_out->is_placeholder) {
 801c3c4:	68bb      	ldr	r3, [r7, #8]
 801c3c6:	7bdb      	ldrb	r3, [r3, #15]
 801c3c8:	f003 0301 	and.w	r3, r3, #1
 801c3cc:	b2db      	uxtb	r3, r3
 801c3ce:	2b00      	cmp	r3, #0
 801c3d0:	d104      	bne.n	801c3dc <lv_font_get_glyph_dsc+0x74>
                dsc_out->resolved_font = f;
 801c3d2:	68bb      	ldr	r3, [r7, #8]
 801c3d4:	69ba      	ldr	r2, [r7, #24]
 801c3d6:	601a      	str	r2, [r3, #0]
                return true;
 801c3d8:	2301      	movs	r3, #1
 801c3da:	e047      	b.n	801c46c <lv_font_get_glyph_dsc+0x104>
            }
#if LV_USE_FONT_PLACEHOLDER
            else if(placeholder_font == NULL) {
 801c3dc:	69fb      	ldr	r3, [r7, #28]
 801c3de:	2b00      	cmp	r3, #0
 801c3e0:	d101      	bne.n	801c3e6 <lv_font_get_glyph_dsc+0x7e>
                placeholder_font = f;
 801c3e2:	69bb      	ldr	r3, [r7, #24]
 801c3e4:	61fb      	str	r3, [r7, #28]
            }
#endif
        }
        f = f->fallback;
 801c3e6:	69bb      	ldr	r3, [r7, #24]
 801c3e8:	69db      	ldr	r3, [r3, #28]
 801c3ea:	61bb      	str	r3, [r7, #24]
    while(f) {
 801c3ec:	69bb      	ldr	r3, [r7, #24]
 801c3ee:	2b00      	cmp	r3, #0
 801c3f0:	d1d3      	bne.n	801c39a <lv_font_get_glyph_dsc+0x32>
    }

#if LV_USE_FONT_PLACEHOLDER
    if(placeholder_font != NULL) {
 801c3f2:	69fb      	ldr	r3, [r7, #28]
 801c3f4:	2b00      	cmp	r3, #0
 801c3f6:	d014      	beq.n	801c422 <lv_font_get_glyph_dsc+0xba>
        placeholder_font->get_glyph_dsc(placeholder_font, dsc_out, letter,
 801c3f8:	69fb      	ldr	r3, [r7, #28]
 801c3fa:	681c      	ldr	r4, [r3, #0]
                                        placeholder_font->kerning == LV_FONT_KERNING_NONE ? 0 : letter_next);
 801c3fc:	69fb      	ldr	r3, [r7, #28]
 801c3fe:	7d1b      	ldrb	r3, [r3, #20]
 801c400:	f003 0304 	and.w	r3, r3, #4
 801c404:	b2db      	uxtb	r3, r3
        placeholder_font->get_glyph_dsc(placeholder_font, dsc_out, letter,
 801c406:	2b00      	cmp	r3, #0
 801c408:	d101      	bne.n	801c40e <lv_font_get_glyph_dsc+0xa6>
 801c40a:	683b      	ldr	r3, [r7, #0]
 801c40c:	e000      	b.n	801c410 <lv_font_get_glyph_dsc+0xa8>
 801c40e:	2300      	movs	r3, #0
 801c410:	687a      	ldr	r2, [r7, #4]
 801c412:	68b9      	ldr	r1, [r7, #8]
 801c414:	69f8      	ldr	r0, [r7, #28]
 801c416:	47a0      	blx	r4
        dsc_out->resolved_font = placeholder_font;
 801c418:	68bb      	ldr	r3, [r7, #8]
 801c41a:	69fa      	ldr	r2, [r7, #28]
 801c41c:	601a      	str	r2, [r3, #0]
        return true;
 801c41e:	2301      	movs	r3, #1
 801c420:	e024      	b.n	801c46c <lv_font_get_glyph_dsc+0x104>
    }
#endif

#if LV_USE_FONT_PLACEHOLDER
    dsc_out->box_w = font_p->line_height / 2;
 801c422:	68fb      	ldr	r3, [r7, #12]
 801c424:	68db      	ldr	r3, [r3, #12]
 801c426:	0fda      	lsrs	r2, r3, #31
 801c428:	4413      	add	r3, r2
 801c42a:	105b      	asrs	r3, r3, #1
 801c42c:	b29a      	uxth	r2, r3
 801c42e:	68bb      	ldr	r3, [r7, #8]
 801c430:	80da      	strh	r2, [r3, #6]
    dsc_out->adv_w = dsc_out->box_w + 2;
 801c432:	68bb      	ldr	r3, [r7, #8]
 801c434:	88db      	ldrh	r3, [r3, #6]
 801c436:	3302      	adds	r3, #2
 801c438:	b29a      	uxth	r2, r3
 801c43a:	68bb      	ldr	r3, [r7, #8]
 801c43c:	809a      	strh	r2, [r3, #4]
#else
    dsc_out->box_w = 0;
    dsc_out->adv_w = 0;
#endif

    dsc_out->resolved_font = NULL;
 801c43e:	68bb      	ldr	r3, [r7, #8]
 801c440:	2200      	movs	r2, #0
 801c442:	601a      	str	r2, [r3, #0]
    dsc_out->box_h = font_p->line_height;
 801c444:	68fb      	ldr	r3, [r7, #12]
 801c446:	68db      	ldr	r3, [r3, #12]
 801c448:	b29a      	uxth	r2, r3
 801c44a:	68bb      	ldr	r3, [r7, #8]
 801c44c:	811a      	strh	r2, [r3, #8]
    dsc_out->ofs_x = 0;
 801c44e:	68bb      	ldr	r3, [r7, #8]
 801c450:	2200      	movs	r2, #0
 801c452:	815a      	strh	r2, [r3, #10]
    dsc_out->ofs_y = 0;
 801c454:	68bb      	ldr	r3, [r7, #8]
 801c456:	2200      	movs	r2, #0
 801c458:	819a      	strh	r2, [r3, #12]
    dsc_out->format = LV_FONT_GLYPH_FORMAT_A1;
 801c45a:	68bb      	ldr	r3, [r7, #8]
 801c45c:	2201      	movs	r2, #1
 801c45e:	739a      	strb	r2, [r3, #14]
    dsc_out->is_placeholder = true;
 801c460:	68ba      	ldr	r2, [r7, #8]
 801c462:	7bd3      	ldrb	r3, [r2, #15]
 801c464:	f043 0301 	orr.w	r3, r3, #1
 801c468:	73d3      	strb	r3, [r2, #15]

    return false;
 801c46a:	2300      	movs	r3, #0
}
 801c46c:	4618      	mov	r0, r3
 801c46e:	3724      	adds	r7, #36	@ 0x24
 801c470:	46bd      	mov	sp, r7
 801c472:	bd90      	pop	{r4, r7, pc}

0801c474 <lv_font_get_glyph_width>:

uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)
{
 801c474:	b580      	push	{r7, lr}
 801c476:	b08a      	sub	sp, #40	@ 0x28
 801c478:	af00      	add	r7, sp, #0
 801c47a:	60f8      	str	r0, [r7, #12]
 801c47c:	60b9      	str	r1, [r7, #8]
 801c47e:	607a      	str	r2, [r7, #4]
    LV_ASSERT_NULL(font);
 801c480:	68fb      	ldr	r3, [r7, #12]
 801c482:	2b00      	cmp	r3, #0
 801c484:	d101      	bne.n	801c48a <lv_font_get_glyph_width+0x16>
 801c486:	bf00      	nop
 801c488:	e7fd      	b.n	801c486 <lv_font_get_glyph_width+0x12>
    lv_font_glyph_dsc_t g;

    /*Return zero if letter is marker*/
    if(_lv_text_is_marker(letter)) return 0;
 801c48a:	68b8      	ldr	r0, [r7, #8]
 801c48c:	f7ff fef1 	bl	801c272 <_lv_text_is_marker>
 801c490:	4603      	mov	r3, r0
 801c492:	2b00      	cmp	r3, #0
 801c494:	d001      	beq.n	801c49a <lv_font_get_glyph_width+0x26>
 801c496:	2300      	movs	r3, #0
 801c498:	e007      	b.n	801c4aa <lv_font_get_glyph_width+0x36>

    lv_font_get_glyph_dsc(font, &g, letter, letter_next);
 801c49a:	f107 0110 	add.w	r1, r7, #16
 801c49e:	687b      	ldr	r3, [r7, #4]
 801c4a0:	68ba      	ldr	r2, [r7, #8]
 801c4a2:	68f8      	ldr	r0, [r7, #12]
 801c4a4:	f7ff ff60 	bl	801c368 <lv_font_get_glyph_dsc>
    return g.adv_w;
 801c4a8:	8abb      	ldrh	r3, [r7, #20]
}
 801c4aa:	4618      	mov	r0, r3
 801c4ac:	3728      	adds	r7, #40	@ 0x28
 801c4ae:	46bd      	mov	sp, r7
 801c4b0:	bd80      	pop	{r7, pc}
	...

0801c4b4 <lv_font_get_bitmap_fmt_txt>:
 *   GLOBAL FUNCTIONS
 **********************/

const void * lv_font_get_bitmap_fmt_txt(lv_font_glyph_dsc_t * g_dsc, uint32_t unicode_letter,
                                        lv_draw_buf_t * draw_buf)
{
 801c4b4:	b580      	push	{r7, lr}
 801c4b6:	b090      	sub	sp, #64	@ 0x40
 801c4b8:	af00      	add	r7, sp, #0
 801c4ba:	60f8      	str	r0, [r7, #12]
 801c4bc:	60b9      	str	r1, [r7, #8]
 801c4be:	607a      	str	r2, [r7, #4]
    const lv_font_t * font = g_dsc->resolved_font;
 801c4c0:	68fb      	ldr	r3, [r7, #12]
 801c4c2:	681b      	ldr	r3, [r3, #0]
 801c4c4:	62bb      	str	r3, [r7, #40]	@ 0x28
    uint8_t * bitmap_out = draw_buf->data;
 801c4c6:	687b      	ldr	r3, [r7, #4]
 801c4c8:	691b      	ldr	r3, [r3, #16]
 801c4ca:	627b      	str	r3, [r7, #36]	@ 0x24

    if(unicode_letter == '\t') unicode_letter = ' ';
 801c4cc:	68bb      	ldr	r3, [r7, #8]
 801c4ce:	2b09      	cmp	r3, #9
 801c4d0:	d101      	bne.n	801c4d6 <lv_font_get_bitmap_fmt_txt+0x22>
 801c4d2:	2320      	movs	r3, #32
 801c4d4:	60bb      	str	r3, [r7, #8]

    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;
 801c4d6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c4d8:	699b      	ldr	r3, [r3, #24]
 801c4da:	623b      	str	r3, [r7, #32]
    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
 801c4dc:	68b9      	ldr	r1, [r7, #8]
 801c4de:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801c4e0:	f000 fa44 	bl	801c96c <get_glyph_dsc_id>
 801c4e4:	61f8      	str	r0, [r7, #28]
    if(!gid) return NULL;
 801c4e6:	69fb      	ldr	r3, [r7, #28]
 801c4e8:	2b00      	cmp	r3, #0
 801c4ea:	d101      	bne.n	801c4f0 <lv_font_get_bitmap_fmt_txt+0x3c>
 801c4ec:	2300      	movs	r3, #0
 801c4ee:	e1a2      	b.n	801c836 <lv_font_get_bitmap_fmt_txt+0x382>

    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
 801c4f0:	6a3b      	ldr	r3, [r7, #32]
 801c4f2:	685a      	ldr	r2, [r3, #4]
 801c4f4:	69fb      	ldr	r3, [r7, #28]
 801c4f6:	00db      	lsls	r3, r3, #3
 801c4f8:	4413      	add	r3, r2
 801c4fa:	61bb      	str	r3, [r7, #24]

    int32_t gsize = (int32_t) gdsc->box_w * gdsc->box_h;
 801c4fc:	69bb      	ldr	r3, [r7, #24]
 801c4fe:	791b      	ldrb	r3, [r3, #4]
 801c500:	461a      	mov	r2, r3
 801c502:	69bb      	ldr	r3, [r7, #24]
 801c504:	795b      	ldrb	r3, [r3, #5]
 801c506:	fb02 f303 	mul.w	r3, r2, r3
 801c50a:	617b      	str	r3, [r7, #20]
    if(gsize == 0) return NULL;
 801c50c:	697b      	ldr	r3, [r7, #20]
 801c50e:	2b00      	cmp	r3, #0
 801c510:	d101      	bne.n	801c516 <lv_font_get_bitmap_fmt_txt+0x62>
 801c512:	2300      	movs	r3, #0
 801c514:	e18f      	b.n	801c836 <lv_font_get_bitmap_fmt_txt+0x382>

    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
 801c516:	6a3b      	ldr	r3, [r7, #32]
 801c518:	7cdb      	ldrb	r3, [r3, #19]
 801c51a:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 801c51e:	b2db      	uxtb	r3, r3
 801c520:	2b00      	cmp	r3, #0
 801c522:	f040 8187 	bne.w	801c834 <lv_font_get_bitmap_fmt_txt+0x380>
        const uint8_t * bitmap_in = &fdsc->glyph_bitmap[gdsc->bitmap_index];
 801c526:	6a3b      	ldr	r3, [r7, #32]
 801c528:	681b      	ldr	r3, [r3, #0]
 801c52a:	69ba      	ldr	r2, [r7, #24]
 801c52c:	6812      	ldr	r2, [r2, #0]
 801c52e:	f3c2 0213 	ubfx	r2, r2, #0, #20
 801c532:	4413      	add	r3, r2
 801c534:	63fb      	str	r3, [r7, #60]	@ 0x3c
        uint8_t * bitmap_out_tmp = bitmap_out;
 801c536:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801c538:	63bb      	str	r3, [r7, #56]	@ 0x38
        int32_t i = 0;
 801c53a:	2300      	movs	r3, #0
 801c53c:	637b      	str	r3, [r7, #52]	@ 0x34
        int32_t x, y;
        uint32_t stride = lv_draw_buf_width_to_stride(gdsc->box_w, LV_COLOR_FORMAT_A8);
 801c53e:	69bb      	ldr	r3, [r7, #24]
 801c540:	791b      	ldrb	r3, [r3, #4]
 801c542:	210e      	movs	r1, #14
 801c544:	4618      	mov	r0, r3
 801c546:	f7ef fb3d 	bl	800bbc4 <lv_draw_buf_width_to_stride>
 801c54a:	6138      	str	r0, [r7, #16]

        if(fdsc->bpp == 1) {
 801c54c:	6a3b      	ldr	r3, [r7, #32]
 801c54e:	7cdb      	ldrb	r3, [r3, #19]
 801c550:	f003 031e 	and.w	r3, r3, #30
 801c554:	b2db      	uxtb	r3, r3
 801c556:	2b02      	cmp	r3, #2
 801c558:	f040 80b7 	bne.w	801c6ca <lv_font_get_bitmap_fmt_txt+0x216>
            for(y = 0; y < gdsc->box_h; y ++) {
 801c55c:	2300      	movs	r3, #0
 801c55e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c560:	e0ab      	b.n	801c6ba <lv_font_get_bitmap_fmt_txt+0x206>
                for(x = 0; x < gdsc->box_w; x++, i++) {
 801c562:	2300      	movs	r3, #0
 801c564:	633b      	str	r3, [r7, #48]	@ 0x30
 801c566:	e09a      	b.n	801c69e <lv_font_get_bitmap_fmt_txt+0x1ea>
                    i = i & 0x7;
 801c568:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c56a:	f003 0307 	and.w	r3, r3, #7
 801c56e:	637b      	str	r3, [r7, #52]	@ 0x34
                    if(i == 0) bitmap_out_tmp[x] = (*bitmap_in) & 0x80 ? 0xff : 0x00;
 801c570:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c572:	2b00      	cmp	r3, #0
 801c574:	d10d      	bne.n	801c592 <lv_font_get_bitmap_fmt_txt+0xde>
 801c576:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c578:	781b      	ldrb	r3, [r3, #0]
 801c57a:	b25b      	sxtb	r3, r3
 801c57c:	2b00      	cmp	r3, #0
 801c57e:	da01      	bge.n	801c584 <lv_font_get_bitmap_fmt_txt+0xd0>
 801c580:	21ff      	movs	r1, #255	@ 0xff
 801c582:	e000      	b.n	801c586 <lv_font_get_bitmap_fmt_txt+0xd2>
 801c584:	2100      	movs	r1, #0
 801c586:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c588:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c58a:	4413      	add	r3, r2
 801c58c:	460a      	mov	r2, r1
 801c58e:	701a      	strb	r2, [r3, #0]
 801c590:	e07f      	b.n	801c692 <lv_font_get_bitmap_fmt_txt+0x1de>
                    else if(i == 1) bitmap_out_tmp[x] = (*bitmap_in) & 0x40 ? 0xff : 0x00;
 801c592:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c594:	2b01      	cmp	r3, #1
 801c596:	d10e      	bne.n	801c5b6 <lv_font_get_bitmap_fmt_txt+0x102>
 801c598:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c59a:	781b      	ldrb	r3, [r3, #0]
 801c59c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801c5a0:	2b00      	cmp	r3, #0
 801c5a2:	d001      	beq.n	801c5a8 <lv_font_get_bitmap_fmt_txt+0xf4>
 801c5a4:	21ff      	movs	r1, #255	@ 0xff
 801c5a6:	e000      	b.n	801c5aa <lv_font_get_bitmap_fmt_txt+0xf6>
 801c5a8:	2100      	movs	r1, #0
 801c5aa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c5ac:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c5ae:	4413      	add	r3, r2
 801c5b0:	460a      	mov	r2, r1
 801c5b2:	701a      	strb	r2, [r3, #0]
 801c5b4:	e06d      	b.n	801c692 <lv_font_get_bitmap_fmt_txt+0x1de>
                    else if(i == 2) bitmap_out_tmp[x] = (*bitmap_in) & 0x20 ? 0xff : 0x00;
 801c5b6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c5b8:	2b02      	cmp	r3, #2
 801c5ba:	d10e      	bne.n	801c5da <lv_font_get_bitmap_fmt_txt+0x126>
 801c5bc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c5be:	781b      	ldrb	r3, [r3, #0]
 801c5c0:	f003 0320 	and.w	r3, r3, #32
 801c5c4:	2b00      	cmp	r3, #0
 801c5c6:	d001      	beq.n	801c5cc <lv_font_get_bitmap_fmt_txt+0x118>
 801c5c8:	21ff      	movs	r1, #255	@ 0xff
 801c5ca:	e000      	b.n	801c5ce <lv_font_get_bitmap_fmt_txt+0x11a>
 801c5cc:	2100      	movs	r1, #0
 801c5ce:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c5d0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c5d2:	4413      	add	r3, r2
 801c5d4:	460a      	mov	r2, r1
 801c5d6:	701a      	strb	r2, [r3, #0]
 801c5d8:	e05b      	b.n	801c692 <lv_font_get_bitmap_fmt_txt+0x1de>
                    else if(i == 3) bitmap_out_tmp[x] = (*bitmap_in) & 0x10 ? 0xff : 0x00;
 801c5da:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c5dc:	2b03      	cmp	r3, #3
 801c5de:	d10e      	bne.n	801c5fe <lv_font_get_bitmap_fmt_txt+0x14a>
 801c5e0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c5e2:	781b      	ldrb	r3, [r3, #0]
 801c5e4:	f003 0310 	and.w	r3, r3, #16
 801c5e8:	2b00      	cmp	r3, #0
 801c5ea:	d001      	beq.n	801c5f0 <lv_font_get_bitmap_fmt_txt+0x13c>
 801c5ec:	21ff      	movs	r1, #255	@ 0xff
 801c5ee:	e000      	b.n	801c5f2 <lv_font_get_bitmap_fmt_txt+0x13e>
 801c5f0:	2100      	movs	r1, #0
 801c5f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c5f4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c5f6:	4413      	add	r3, r2
 801c5f8:	460a      	mov	r2, r1
 801c5fa:	701a      	strb	r2, [r3, #0]
 801c5fc:	e049      	b.n	801c692 <lv_font_get_bitmap_fmt_txt+0x1de>
                    else if(i == 4) bitmap_out_tmp[x] = (*bitmap_in) & 0x08 ? 0xff : 0x00;
 801c5fe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c600:	2b04      	cmp	r3, #4
 801c602:	d10e      	bne.n	801c622 <lv_font_get_bitmap_fmt_txt+0x16e>
 801c604:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c606:	781b      	ldrb	r3, [r3, #0]
 801c608:	f003 0308 	and.w	r3, r3, #8
 801c60c:	2b00      	cmp	r3, #0
 801c60e:	d001      	beq.n	801c614 <lv_font_get_bitmap_fmt_txt+0x160>
 801c610:	21ff      	movs	r1, #255	@ 0xff
 801c612:	e000      	b.n	801c616 <lv_font_get_bitmap_fmt_txt+0x162>
 801c614:	2100      	movs	r1, #0
 801c616:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c618:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c61a:	4413      	add	r3, r2
 801c61c:	460a      	mov	r2, r1
 801c61e:	701a      	strb	r2, [r3, #0]
 801c620:	e037      	b.n	801c692 <lv_font_get_bitmap_fmt_txt+0x1de>
                    else if(i == 5) bitmap_out_tmp[x] = (*bitmap_in) & 0x04 ? 0xff : 0x00;
 801c622:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c624:	2b05      	cmp	r3, #5
 801c626:	d10e      	bne.n	801c646 <lv_font_get_bitmap_fmt_txt+0x192>
 801c628:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c62a:	781b      	ldrb	r3, [r3, #0]
 801c62c:	f003 0304 	and.w	r3, r3, #4
 801c630:	2b00      	cmp	r3, #0
 801c632:	d001      	beq.n	801c638 <lv_font_get_bitmap_fmt_txt+0x184>
 801c634:	21ff      	movs	r1, #255	@ 0xff
 801c636:	e000      	b.n	801c63a <lv_font_get_bitmap_fmt_txt+0x186>
 801c638:	2100      	movs	r1, #0
 801c63a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c63c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c63e:	4413      	add	r3, r2
 801c640:	460a      	mov	r2, r1
 801c642:	701a      	strb	r2, [r3, #0]
 801c644:	e025      	b.n	801c692 <lv_font_get_bitmap_fmt_txt+0x1de>
                    else if(i == 6) bitmap_out_tmp[x] = (*bitmap_in) & 0x02 ? 0xff : 0x00;
 801c646:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c648:	2b06      	cmp	r3, #6
 801c64a:	d10e      	bne.n	801c66a <lv_font_get_bitmap_fmt_txt+0x1b6>
 801c64c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c64e:	781b      	ldrb	r3, [r3, #0]
 801c650:	f003 0302 	and.w	r3, r3, #2
 801c654:	2b00      	cmp	r3, #0
 801c656:	d001      	beq.n	801c65c <lv_font_get_bitmap_fmt_txt+0x1a8>
 801c658:	21ff      	movs	r1, #255	@ 0xff
 801c65a:	e000      	b.n	801c65e <lv_font_get_bitmap_fmt_txt+0x1aa>
 801c65c:	2100      	movs	r1, #0
 801c65e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c660:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c662:	4413      	add	r3, r2
 801c664:	460a      	mov	r2, r1
 801c666:	701a      	strb	r2, [r3, #0]
 801c668:	e013      	b.n	801c692 <lv_font_get_bitmap_fmt_txt+0x1de>
                    else if(i == 7) {
 801c66a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c66c:	2b07      	cmp	r3, #7
 801c66e:	d110      	bne.n	801c692 <lv_font_get_bitmap_fmt_txt+0x1de>
                        bitmap_out_tmp[x] = (*bitmap_in) & 0x01 ? 0xff : 0x00;
 801c670:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c672:	781b      	ldrb	r3, [r3, #0]
 801c674:	f003 0301 	and.w	r3, r3, #1
 801c678:	2b00      	cmp	r3, #0
 801c67a:	d001      	beq.n	801c680 <lv_font_get_bitmap_fmt_txt+0x1cc>
 801c67c:	21ff      	movs	r1, #255	@ 0xff
 801c67e:	e000      	b.n	801c682 <lv_font_get_bitmap_fmt_txt+0x1ce>
 801c680:	2100      	movs	r1, #0
 801c682:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c684:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c686:	4413      	add	r3, r2
 801c688:	460a      	mov	r2, r1
 801c68a:	701a      	strb	r2, [r3, #0]
                        bitmap_in++;
 801c68c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c68e:	3301      	adds	r3, #1
 801c690:	63fb      	str	r3, [r7, #60]	@ 0x3c
                for(x = 0; x < gdsc->box_w; x++, i++) {
 801c692:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c694:	3301      	adds	r3, #1
 801c696:	633b      	str	r3, [r7, #48]	@ 0x30
 801c698:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c69a:	3301      	adds	r3, #1
 801c69c:	637b      	str	r3, [r7, #52]	@ 0x34
 801c69e:	69bb      	ldr	r3, [r7, #24]
 801c6a0:	791b      	ldrb	r3, [r3, #4]
 801c6a2:	461a      	mov	r2, r3
 801c6a4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c6a6:	4293      	cmp	r3, r2
 801c6a8:	f6ff af5e 	blt.w	801c568 <lv_font_get_bitmap_fmt_txt+0xb4>
                    }
                }
                bitmap_out_tmp += stride;
 801c6ac:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c6ae:	693b      	ldr	r3, [r7, #16]
 801c6b0:	4413      	add	r3, r2
 801c6b2:	63bb      	str	r3, [r7, #56]	@ 0x38
            for(y = 0; y < gdsc->box_h; y ++) {
 801c6b4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c6b6:	3301      	adds	r3, #1
 801c6b8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c6ba:	69bb      	ldr	r3, [r7, #24]
 801c6bc:	795b      	ldrb	r3, [r3, #5]
 801c6be:	461a      	mov	r2, r3
 801c6c0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c6c2:	4293      	cmp	r3, r2
 801c6c4:	f6ff af4d 	blt.w	801c562 <lv_font_get_bitmap_fmt_txt+0xae>
 801c6c8:	e0b2      	b.n	801c830 <lv_font_get_bitmap_fmt_txt+0x37c>
            }
        }
        else if(fdsc->bpp == 2) {
 801c6ca:	6a3b      	ldr	r3, [r7, #32]
 801c6cc:	7cdb      	ldrb	r3, [r3, #19]
 801c6ce:	f003 031e 	and.w	r3, r3, #30
 801c6d2:	b2db      	uxtb	r3, r3
 801c6d4:	2b04      	cmp	r3, #4
 801c6d6:	d162      	bne.n	801c79e <lv_font_get_bitmap_fmt_txt+0x2ea>
            for(y = 0; y < gdsc->box_h; y ++) {
 801c6d8:	2300      	movs	r3, #0
 801c6da:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c6dc:	e058      	b.n	801c790 <lv_font_get_bitmap_fmt_txt+0x2dc>
                for(x = 0; x < gdsc->box_w; x++, i++) {
 801c6de:	2300      	movs	r3, #0
 801c6e0:	633b      	str	r3, [r7, #48]	@ 0x30
 801c6e2:	e048      	b.n	801c776 <lv_font_get_bitmap_fmt_txt+0x2c2>
                    i = i & 0x3;
 801c6e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c6e6:	f003 0303 	and.w	r3, r3, #3
 801c6ea:	637b      	str	r3, [r7, #52]	@ 0x34
                    if(i == 0) bitmap_out_tmp[x] = opa2_table[(*bitmap_in) >> 6];
 801c6ec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c6ee:	2b00      	cmp	r3, #0
 801c6f0:	d10b      	bne.n	801c70a <lv_font_get_bitmap_fmt_txt+0x256>
 801c6f2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c6f4:	781b      	ldrb	r3, [r3, #0]
 801c6f6:	099b      	lsrs	r3, r3, #6
 801c6f8:	b2db      	uxtb	r3, r3
 801c6fa:	4619      	mov	r1, r3
 801c6fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c6fe:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c700:	4413      	add	r3, r2
 801c702:	4a4f      	ldr	r2, [pc, #316]	@ (801c840 <lv_font_get_bitmap_fmt_txt+0x38c>)
 801c704:	5c52      	ldrb	r2, [r2, r1]
 801c706:	701a      	strb	r2, [r3, #0]
 801c708:	e02f      	b.n	801c76a <lv_font_get_bitmap_fmt_txt+0x2b6>
                    else if(i == 1) bitmap_out_tmp[x] = opa2_table[((*bitmap_in) >> 4) & 0x3];
 801c70a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c70c:	2b01      	cmp	r3, #1
 801c70e:	d10c      	bne.n	801c72a <lv_font_get_bitmap_fmt_txt+0x276>
 801c710:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c712:	781b      	ldrb	r3, [r3, #0]
 801c714:	091b      	lsrs	r3, r3, #4
 801c716:	b2db      	uxtb	r3, r3
 801c718:	f003 0203 	and.w	r2, r3, #3
 801c71c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c71e:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 801c720:	440b      	add	r3, r1
 801c722:	4947      	ldr	r1, [pc, #284]	@ (801c840 <lv_font_get_bitmap_fmt_txt+0x38c>)
 801c724:	5c8a      	ldrb	r2, [r1, r2]
 801c726:	701a      	strb	r2, [r3, #0]
 801c728:	e01f      	b.n	801c76a <lv_font_get_bitmap_fmt_txt+0x2b6>
                    else if(i == 2) bitmap_out_tmp[x] = opa2_table[((*bitmap_in) >> 2) & 0x3];
 801c72a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c72c:	2b02      	cmp	r3, #2
 801c72e:	d10c      	bne.n	801c74a <lv_font_get_bitmap_fmt_txt+0x296>
 801c730:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c732:	781b      	ldrb	r3, [r3, #0]
 801c734:	089b      	lsrs	r3, r3, #2
 801c736:	b2db      	uxtb	r3, r3
 801c738:	f003 0203 	and.w	r2, r3, #3
 801c73c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c73e:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 801c740:	440b      	add	r3, r1
 801c742:	493f      	ldr	r1, [pc, #252]	@ (801c840 <lv_font_get_bitmap_fmt_txt+0x38c>)
 801c744:	5c8a      	ldrb	r2, [r1, r2]
 801c746:	701a      	strb	r2, [r3, #0]
 801c748:	e00f      	b.n	801c76a <lv_font_get_bitmap_fmt_txt+0x2b6>
                    else if(i == 3) {
 801c74a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c74c:	2b03      	cmp	r3, #3
 801c74e:	d10c      	bne.n	801c76a <lv_font_get_bitmap_fmt_txt+0x2b6>
                        bitmap_out_tmp[x] = opa2_table[((*bitmap_in) >> 0) & 0x3];
 801c750:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c752:	781b      	ldrb	r3, [r3, #0]
 801c754:	f003 0203 	and.w	r2, r3, #3
 801c758:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c75a:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 801c75c:	440b      	add	r3, r1
 801c75e:	4938      	ldr	r1, [pc, #224]	@ (801c840 <lv_font_get_bitmap_fmt_txt+0x38c>)
 801c760:	5c8a      	ldrb	r2, [r1, r2]
 801c762:	701a      	strb	r2, [r3, #0]
                        bitmap_in++;
 801c764:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c766:	3301      	adds	r3, #1
 801c768:	63fb      	str	r3, [r7, #60]	@ 0x3c
                for(x = 0; x < gdsc->box_w; x++, i++) {
 801c76a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c76c:	3301      	adds	r3, #1
 801c76e:	633b      	str	r3, [r7, #48]	@ 0x30
 801c770:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c772:	3301      	adds	r3, #1
 801c774:	637b      	str	r3, [r7, #52]	@ 0x34
 801c776:	69bb      	ldr	r3, [r7, #24]
 801c778:	791b      	ldrb	r3, [r3, #4]
 801c77a:	461a      	mov	r2, r3
 801c77c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c77e:	4293      	cmp	r3, r2
 801c780:	dbb0      	blt.n	801c6e4 <lv_font_get_bitmap_fmt_txt+0x230>
                    }
                }
                bitmap_out_tmp += stride;
 801c782:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c784:	693b      	ldr	r3, [r7, #16]
 801c786:	4413      	add	r3, r2
 801c788:	63bb      	str	r3, [r7, #56]	@ 0x38
            for(y = 0; y < gdsc->box_h; y ++) {
 801c78a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c78c:	3301      	adds	r3, #1
 801c78e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c790:	69bb      	ldr	r3, [r7, #24]
 801c792:	795b      	ldrb	r3, [r3, #5]
 801c794:	461a      	mov	r2, r3
 801c796:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c798:	4293      	cmp	r3, r2
 801c79a:	dba0      	blt.n	801c6de <lv_font_get_bitmap_fmt_txt+0x22a>
 801c79c:	e048      	b.n	801c830 <lv_font_get_bitmap_fmt_txt+0x37c>
            }

        }
        else if(fdsc->bpp == 4) {
 801c79e:	6a3b      	ldr	r3, [r7, #32]
 801c7a0:	7cdb      	ldrb	r3, [r3, #19]
 801c7a2:	f003 031e 	and.w	r3, r3, #30
 801c7a6:	b2db      	uxtb	r3, r3
 801c7a8:	2b08      	cmp	r3, #8
 801c7aa:	d141      	bne.n	801c830 <lv_font_get_bitmap_fmt_txt+0x37c>
            for(y = 0; y < gdsc->box_h; y ++) {
 801c7ac:	2300      	movs	r3, #0
 801c7ae:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c7b0:	e038      	b.n	801c824 <lv_font_get_bitmap_fmt_txt+0x370>
                for(x = 0; x < gdsc->box_w; x++, i++) {
 801c7b2:	2300      	movs	r3, #0
 801c7b4:	633b      	str	r3, [r7, #48]	@ 0x30
 801c7b6:	e028      	b.n	801c80a <lv_font_get_bitmap_fmt_txt+0x356>
                    i = i & 0x1;
 801c7b8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c7ba:	f003 0301 	and.w	r3, r3, #1
 801c7be:	637b      	str	r3, [r7, #52]	@ 0x34
                    if(i == 0) {
 801c7c0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c7c2:	2b00      	cmp	r3, #0
 801c7c4:	d10b      	bne.n	801c7de <lv_font_get_bitmap_fmt_txt+0x32a>
                        bitmap_out_tmp[x] = opa4_table[(*bitmap_in) >> 4];
 801c7c6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c7c8:	781b      	ldrb	r3, [r3, #0]
 801c7ca:	091b      	lsrs	r3, r3, #4
 801c7cc:	b2db      	uxtb	r3, r3
 801c7ce:	4619      	mov	r1, r3
 801c7d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c7d2:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c7d4:	4413      	add	r3, r2
 801c7d6:	4a1b      	ldr	r2, [pc, #108]	@ (801c844 <lv_font_get_bitmap_fmt_txt+0x390>)
 801c7d8:	5c52      	ldrb	r2, [r2, r1]
 801c7da:	701a      	strb	r2, [r3, #0]
 801c7dc:	e00f      	b.n	801c7fe <lv_font_get_bitmap_fmt_txt+0x34a>
                    }
                    else if(i == 1) {
 801c7de:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c7e0:	2b01      	cmp	r3, #1
 801c7e2:	d10c      	bne.n	801c7fe <lv_font_get_bitmap_fmt_txt+0x34a>
                        bitmap_out_tmp[x] = opa4_table[(*bitmap_in) & 0xF];
 801c7e4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c7e6:	781b      	ldrb	r3, [r3, #0]
 801c7e8:	f003 020f 	and.w	r2, r3, #15
 801c7ec:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c7ee:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 801c7f0:	440b      	add	r3, r1
 801c7f2:	4914      	ldr	r1, [pc, #80]	@ (801c844 <lv_font_get_bitmap_fmt_txt+0x390>)
 801c7f4:	5c8a      	ldrb	r2, [r1, r2]
 801c7f6:	701a      	strb	r2, [r3, #0]
                        bitmap_in++;
 801c7f8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801c7fa:	3301      	adds	r3, #1
 801c7fc:	63fb      	str	r3, [r7, #60]	@ 0x3c
                for(x = 0; x < gdsc->box_w; x++, i++) {
 801c7fe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c800:	3301      	adds	r3, #1
 801c802:	633b      	str	r3, [r7, #48]	@ 0x30
 801c804:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801c806:	3301      	adds	r3, #1
 801c808:	637b      	str	r3, [r7, #52]	@ 0x34
 801c80a:	69bb      	ldr	r3, [r7, #24]
 801c80c:	791b      	ldrb	r3, [r3, #4]
 801c80e:	461a      	mov	r2, r3
 801c810:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801c812:	4293      	cmp	r3, r2
 801c814:	dbd0      	blt.n	801c7b8 <lv_font_get_bitmap_fmt_txt+0x304>
                    }
                }
                bitmap_out_tmp += stride;
 801c816:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801c818:	693b      	ldr	r3, [r7, #16]
 801c81a:	4413      	add	r3, r2
 801c81c:	63bb      	str	r3, [r7, #56]	@ 0x38
            for(y = 0; y < gdsc->box_h; y ++) {
 801c81e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c820:	3301      	adds	r3, #1
 801c822:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801c824:	69bb      	ldr	r3, [r7, #24]
 801c826:	795b      	ldrb	r3, [r3, #5]
 801c828:	461a      	mov	r2, r3
 801c82a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c82c:	4293      	cmp	r3, r2
 801c82e:	dbc0      	blt.n	801c7b2 <lv_font_get_bitmap_fmt_txt+0x2fe>
            }
        }
        return draw_buf;
 801c830:	687b      	ldr	r3, [r7, #4]
 801c832:	e000      	b.n	801c836 <lv_font_get_bitmap_fmt_txt+0x382>
        decompress(&fdsc->glyph_bitmap[gdsc->bitmap_index], bitmap_out, gdsc->box_w, gdsc->box_h,
                   (uint8_t)fdsc->bpp, prefilter);
        return draw_buf;
#else /*!LV_USE_FONT_COMPRESSED*/
        LV_LOG_WARN("Compressed fonts is used but LV_USE_FONT_COMPRESSED is not enabled in lv_conf.h");
        return NULL;
 801c834:	2300      	movs	r3, #0
#endif
    }

    /*If not returned earlier then the letter is not found in this font*/
    return NULL;
}
 801c836:	4618      	mov	r0, r3
 801c838:	3740      	adds	r7, #64	@ 0x40
 801c83a:	46bd      	mov	sp, r7
 801c83c:	bd80      	pop	{r7, pc}
 801c83e:	bf00      	nop
 801c840:	08027c28 	.word	0x08027c28
 801c844:	08027c18 	.word	0x08027c18

0801c848 <lv_font_get_glyph_dsc_fmt_txt>:

bool lv_font_get_glyph_dsc_fmt_txt(const lv_font_t * font, lv_font_glyph_dsc_t * dsc_out, uint32_t unicode_letter,
                                   uint32_t unicode_letter_next)
{
 801c848:	b580      	push	{r7, lr}
 801c84a:	b08c      	sub	sp, #48	@ 0x30
 801c84c:	af00      	add	r7, sp, #0
 801c84e:	60f8      	str	r0, [r7, #12]
 801c850:	60b9      	str	r1, [r7, #8]
 801c852:	607a      	str	r2, [r7, #4]
 801c854:	603b      	str	r3, [r7, #0]
    /*It fixes a strange compiler optimization issue: https://github.com/lvgl/lvgl/issues/4370*/
    bool is_tab = unicode_letter == '\t';
 801c856:	687b      	ldr	r3, [r7, #4]
 801c858:	2b09      	cmp	r3, #9
 801c85a:	bf0c      	ite	eq
 801c85c:	2301      	moveq	r3, #1
 801c85e:	2300      	movne	r3, #0
 801c860:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if(is_tab) {
 801c864:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801c868:	2b00      	cmp	r3, #0
 801c86a:	d001      	beq.n	801c870 <lv_font_get_glyph_dsc_fmt_txt+0x28>
        unicode_letter = ' ';
 801c86c:	2320      	movs	r3, #32
 801c86e:	607b      	str	r3, [r7, #4]
    }
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;
 801c870:	68fb      	ldr	r3, [r7, #12]
 801c872:	699b      	ldr	r3, [r3, #24]
 801c874:	623b      	str	r3, [r7, #32]
    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
 801c876:	6879      	ldr	r1, [r7, #4]
 801c878:	68f8      	ldr	r0, [r7, #12]
 801c87a:	f000 f877 	bl	801c96c <get_glyph_dsc_id>
 801c87e:	61f8      	str	r0, [r7, #28]
    if(!gid) return false;
 801c880:	69fb      	ldr	r3, [r7, #28]
 801c882:	2b00      	cmp	r3, #0
 801c884:	d101      	bne.n	801c88a <lv_font_get_glyph_dsc_fmt_txt+0x42>
 801c886:	2300      	movs	r3, #0
 801c888:	e06b      	b.n	801c962 <lv_font_get_glyph_dsc_fmt_txt+0x11a>

    int8_t kvalue = 0;
 801c88a:	2300      	movs	r3, #0
 801c88c:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if(fdsc->kern_dsc) {
 801c890:	6a3b      	ldr	r3, [r7, #32]
 801c892:	68db      	ldr	r3, [r3, #12]
 801c894:	2b00      	cmp	r3, #0
 801c896:	d00f      	beq.n	801c8b8 <lv_font_get_glyph_dsc_fmt_txt+0x70>
        uint32_t gid_next = get_glyph_dsc_id(font, unicode_letter_next);
 801c898:	6839      	ldr	r1, [r7, #0]
 801c89a:	68f8      	ldr	r0, [r7, #12]
 801c89c:	f000 f866 	bl	801c96c <get_glyph_dsc_id>
 801c8a0:	61b8      	str	r0, [r7, #24]
        if(gid_next) {
 801c8a2:	69bb      	ldr	r3, [r7, #24]
 801c8a4:	2b00      	cmp	r3, #0
 801c8a6:	d007      	beq.n	801c8b8 <lv_font_get_glyph_dsc_fmt_txt+0x70>
            kvalue = get_kern_value(font, gid, gid_next);
 801c8a8:	69ba      	ldr	r2, [r7, #24]
 801c8aa:	69f9      	ldr	r1, [r7, #28]
 801c8ac:	68f8      	ldr	r0, [r7, #12]
 801c8ae:	f000 f97d 	bl	801cbac <get_kern_value>
 801c8b2:	4603      	mov	r3, r0
 801c8b4:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        }
    }

    /*Put together a glyph dsc*/
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
 801c8b8:	6a3b      	ldr	r3, [r7, #32]
 801c8ba:	685a      	ldr	r2, [r3, #4]
 801c8bc:	69fb      	ldr	r3, [r7, #28]
 801c8be:	00db      	lsls	r3, r3, #3
 801c8c0:	4413      	add	r3, r2
 801c8c2:	617b      	str	r3, [r7, #20]

    int32_t kv = ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
 801c8c4:	f997 302f 	ldrsb.w	r3, [r7, #47]	@ 0x2f
 801c8c8:	6a3a      	ldr	r2, [r7, #32]
 801c8ca:	8a12      	ldrh	r2, [r2, #16]
 801c8cc:	fb02 f303 	mul.w	r3, r2, r3
 801c8d0:	111b      	asrs	r3, r3, #4
 801c8d2:	613b      	str	r3, [r7, #16]

    uint32_t adv_w = gdsc->adv_w;
 801c8d4:	697b      	ldr	r3, [r7, #20]
 801c8d6:	885b      	ldrh	r3, [r3, #2]
 801c8d8:	f3c3 130b 	ubfx	r3, r3, #4, #12
 801c8dc:	b29b      	uxth	r3, r3
 801c8de:	62bb      	str	r3, [r7, #40]	@ 0x28
    if(is_tab) adv_w *= 2;
 801c8e0:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801c8e4:	2b00      	cmp	r3, #0
 801c8e6:	d002      	beq.n	801c8ee <lv_font_get_glyph_dsc_fmt_txt+0xa6>
 801c8e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c8ea:	005b      	lsls	r3, r3, #1
 801c8ec:	62bb      	str	r3, [r7, #40]	@ 0x28

    adv_w += kv;
 801c8ee:	693b      	ldr	r3, [r7, #16]
 801c8f0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801c8f2:	4413      	add	r3, r2
 801c8f4:	62bb      	str	r3, [r7, #40]	@ 0x28
    adv_w  = (adv_w + (1 << 3)) >> 4;
 801c8f6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c8f8:	3308      	adds	r3, #8
 801c8fa:	091b      	lsrs	r3, r3, #4
 801c8fc:	62bb      	str	r3, [r7, #40]	@ 0x28

    dsc_out->adv_w = adv_w;
 801c8fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c900:	b29a      	uxth	r2, r3
 801c902:	68bb      	ldr	r3, [r7, #8]
 801c904:	809a      	strh	r2, [r3, #4]
    dsc_out->box_h = gdsc->box_h;
 801c906:	697b      	ldr	r3, [r7, #20]
 801c908:	795b      	ldrb	r3, [r3, #5]
 801c90a:	461a      	mov	r2, r3
 801c90c:	68bb      	ldr	r3, [r7, #8]
 801c90e:	811a      	strh	r2, [r3, #8]
    dsc_out->box_w = gdsc->box_w;
 801c910:	697b      	ldr	r3, [r7, #20]
 801c912:	791b      	ldrb	r3, [r3, #4]
 801c914:	461a      	mov	r2, r3
 801c916:	68bb      	ldr	r3, [r7, #8]
 801c918:	80da      	strh	r2, [r3, #6]
    dsc_out->ofs_x = gdsc->ofs_x;
 801c91a:	697b      	ldr	r3, [r7, #20]
 801c91c:	f993 3006 	ldrsb.w	r3, [r3, #6]
 801c920:	461a      	mov	r2, r3
 801c922:	68bb      	ldr	r3, [r7, #8]
 801c924:	815a      	strh	r2, [r3, #10]
    dsc_out->ofs_y = gdsc->ofs_y;
 801c926:	697b      	ldr	r3, [r7, #20]
 801c928:	f993 3007 	ldrsb.w	r3, [r3, #7]
 801c92c:	461a      	mov	r2, r3
 801c92e:	68bb      	ldr	r3, [r7, #8]
 801c930:	819a      	strh	r2, [r3, #12]
    dsc_out->format = (uint8_t)fdsc->bpp;
 801c932:	6a3b      	ldr	r3, [r7, #32]
 801c934:	7cdb      	ldrb	r3, [r3, #19]
 801c936:	f3c3 0343 	ubfx	r3, r3, #1, #4
 801c93a:	b2db      	uxtb	r3, r3
 801c93c:	461a      	mov	r2, r3
 801c93e:	68bb      	ldr	r3, [r7, #8]
 801c940:	739a      	strb	r2, [r3, #14]
    dsc_out->is_placeholder = false;
 801c942:	68ba      	ldr	r2, [r7, #8]
 801c944:	7bd3      	ldrb	r3, [r2, #15]
 801c946:	f36f 0300 	bfc	r3, #0, #1
 801c94a:	73d3      	strb	r3, [r2, #15]

    if(is_tab) dsc_out->box_w = dsc_out->box_w * 2;
 801c94c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801c950:	2b00      	cmp	r3, #0
 801c952:	d005      	beq.n	801c960 <lv_font_get_glyph_dsc_fmt_txt+0x118>
 801c954:	68bb      	ldr	r3, [r7, #8]
 801c956:	88db      	ldrh	r3, [r3, #6]
 801c958:	005b      	lsls	r3, r3, #1
 801c95a:	b29a      	uxth	r2, r3
 801c95c:	68bb      	ldr	r3, [r7, #8]
 801c95e:	80da      	strh	r2, [r3, #6]

    return true;
 801c960:	2301      	movs	r3, #1
}
 801c962:	4618      	mov	r0, r3
 801c964:	3730      	adds	r7, #48	@ 0x30
 801c966:	46bd      	mov	sp, r7
 801c968:	bd80      	pop	{r7, pc}
	...

0801c96c <get_glyph_dsc_id>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
{
 801c96c:	b590      	push	{r4, r7, lr}
 801c96e:	b091      	sub	sp, #68	@ 0x44
 801c970:	af02      	add	r7, sp, #8
 801c972:	6078      	str	r0, [r7, #4]
 801c974:	6039      	str	r1, [r7, #0]
    if(letter == '\0') return 0;
 801c976:	683b      	ldr	r3, [r7, #0]
 801c978:	2b00      	cmp	r3, #0
 801c97a:	d101      	bne.n	801c980 <get_glyph_dsc_id+0x14>
 801c97c:	2300      	movs	r3, #0
 801c97e:	e10e      	b.n	801cb9e <get_glyph_dsc_id+0x232>

    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;
 801c980:	687b      	ldr	r3, [r7, #4]
 801c982:	699b      	ldr	r3, [r3, #24]
 801c984:	62fb      	str	r3, [r7, #44]	@ 0x2c

    uint16_t i;
    for(i = 0; i < fdsc->cmap_num; i++) {
 801c986:	2300      	movs	r3, #0
 801c988:	86fb      	strh	r3, [r7, #54]	@ 0x36
 801c98a:	e0fd      	b.n	801cb88 <get_glyph_dsc_id+0x21c>

        /*Relative code point*/
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
 801c98c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c98e:	6899      	ldr	r1, [r3, #8]
 801c990:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801c992:	4613      	mov	r3, r2
 801c994:	009b      	lsls	r3, r3, #2
 801c996:	4413      	add	r3, r2
 801c998:	009b      	lsls	r3, r3, #2
 801c99a:	440b      	add	r3, r1
 801c99c:	681b      	ldr	r3, [r3, #0]
 801c99e:	683a      	ldr	r2, [r7, #0]
 801c9a0:	1ad3      	subs	r3, r2, r3
 801c9a2:	62bb      	str	r3, [r7, #40]	@ 0x28
        if(rcp >= fdsc->cmaps[i].range_length) continue;
 801c9a4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c9a6:	6899      	ldr	r1, [r3, #8]
 801c9a8:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801c9aa:	4613      	mov	r3, r2
 801c9ac:	009b      	lsls	r3, r3, #2
 801c9ae:	4413      	add	r3, r2
 801c9b0:	009b      	lsls	r3, r3, #2
 801c9b2:	440b      	add	r3, r1
 801c9b4:	889b      	ldrh	r3, [r3, #4]
 801c9b6:	461a      	mov	r2, r3
 801c9b8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c9ba:	4293      	cmp	r3, r2
 801c9bc:	f080 80e0 	bcs.w	801cb80 <get_glyph_dsc_id+0x214>
        uint32_t glyph_id = 0;
 801c9c0:	2300      	movs	r3, #0
 801c9c2:	633b      	str	r3, [r7, #48]	@ 0x30
        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
 801c9c4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c9c6:	6899      	ldr	r1, [r3, #8]
 801c9c8:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801c9ca:	4613      	mov	r3, r2
 801c9cc:	009b      	lsls	r3, r3, #2
 801c9ce:	4413      	add	r3, r2
 801c9d0:	009b      	lsls	r3, r3, #2
 801c9d2:	440b      	add	r3, r1
 801c9d4:	7c9b      	ldrb	r3, [r3, #18]
 801c9d6:	2b02      	cmp	r3, #2
 801c9d8:	d10d      	bne.n	801c9f6 <get_glyph_dsc_id+0x8a>
            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;
 801c9da:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c9dc:	6899      	ldr	r1, [r3, #8]
 801c9de:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801c9e0:	4613      	mov	r3, r2
 801c9e2:	009b      	lsls	r3, r3, #2
 801c9e4:	4413      	add	r3, r2
 801c9e6:	009b      	lsls	r3, r3, #2
 801c9e8:	440b      	add	r3, r1
 801c9ea:	88db      	ldrh	r3, [r3, #6]
 801c9ec:	461a      	mov	r2, r3
 801c9ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801c9f0:	4413      	add	r3, r2
 801c9f2:	633b      	str	r3, [r7, #48]	@ 0x30
 801c9f4:	e0c2      	b.n	801cb7c <get_glyph_dsc_id+0x210>
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
 801c9f6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801c9f8:	6899      	ldr	r1, [r3, #8]
 801c9fa:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801c9fc:	4613      	mov	r3, r2
 801c9fe:	009b      	lsls	r3, r3, #2
 801ca00:	4413      	add	r3, r2
 801ca02:	009b      	lsls	r3, r3, #2
 801ca04:	440b      	add	r3, r1
 801ca06:	7c9b      	ldrb	r3, [r3, #18]
 801ca08:	2b00      	cmp	r3, #0
 801ca0a:	d11a      	bne.n	801ca42 <get_glyph_dsc_id+0xd6>
            const uint8_t * gid_ofs_8 = fdsc->cmaps[i].glyph_id_ofs_list;
 801ca0c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ca0e:	6899      	ldr	r1, [r3, #8]
 801ca10:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801ca12:	4613      	mov	r3, r2
 801ca14:	009b      	lsls	r3, r3, #2
 801ca16:	4413      	add	r3, r2
 801ca18:	009b      	lsls	r3, r3, #2
 801ca1a:	440b      	add	r3, r1
 801ca1c:	68db      	ldr	r3, [r3, #12]
 801ca1e:	613b      	str	r3, [r7, #16]
            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];
 801ca20:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ca22:	6899      	ldr	r1, [r3, #8]
 801ca24:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801ca26:	4613      	mov	r3, r2
 801ca28:	009b      	lsls	r3, r3, #2
 801ca2a:	4413      	add	r3, r2
 801ca2c:	009b      	lsls	r3, r3, #2
 801ca2e:	440b      	add	r3, r1
 801ca30:	88db      	ldrh	r3, [r3, #6]
 801ca32:	4619      	mov	r1, r3
 801ca34:	693a      	ldr	r2, [r7, #16]
 801ca36:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ca38:	4413      	add	r3, r2
 801ca3a:	781b      	ldrb	r3, [r3, #0]
 801ca3c:	440b      	add	r3, r1
 801ca3e:	633b      	str	r3, [r7, #48]	@ 0x30
 801ca40:	e09c      	b.n	801cb7c <get_glyph_dsc_id+0x210>
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
 801ca42:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ca44:	6899      	ldr	r1, [r3, #8]
 801ca46:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801ca48:	4613      	mov	r3, r2
 801ca4a:	009b      	lsls	r3, r3, #2
 801ca4c:	4413      	add	r3, r2
 801ca4e:	009b      	lsls	r3, r3, #2
 801ca50:	440b      	add	r3, r1
 801ca52:	7c9b      	ldrb	r3, [r3, #18]
 801ca54:	2b03      	cmp	r3, #3
 801ca56:	d13c      	bne.n	801cad2 <get_glyph_dsc_id+0x166>
            uint16_t key = rcp;
 801ca58:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ca5a:	b29b      	uxth	r3, r3
 801ca5c:	81fb      	strh	r3, [r7, #14]
            uint16_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
 801ca5e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ca60:	6899      	ldr	r1, [r3, #8]
 801ca62:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801ca64:	4613      	mov	r3, r2
 801ca66:	009b      	lsls	r3, r3, #2
 801ca68:	4413      	add	r3, r2
 801ca6a:	009b      	lsls	r3, r3, #2
 801ca6c:	440b      	add	r3, r1
 801ca6e:	689c      	ldr	r4, [r3, #8]
 801ca70:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ca72:	6899      	ldr	r1, [r3, #8]
 801ca74:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801ca76:	4613      	mov	r3, r2
 801ca78:	009b      	lsls	r3, r3, #2
 801ca7a:	4413      	add	r3, r2
 801ca7c:	009b      	lsls	r3, r3, #2
 801ca7e:	440b      	add	r3, r1
 801ca80:	8a1b      	ldrh	r3, [r3, #16]
 801ca82:	461a      	mov	r2, r3
 801ca84:	f107 000e 	add.w	r0, r7, #14
 801ca88:	4b47      	ldr	r3, [pc, #284]	@ (801cba8 <get_glyph_dsc_id+0x23c>)
 801ca8a:	9300      	str	r3, [sp, #0]
 801ca8c:	2302      	movs	r3, #2
 801ca8e:	4621      	mov	r1, r4
 801ca90:	f007 fe8a 	bl	80247a8 <_lv_utils_bsearch>
 801ca94:	61b8      	str	r0, [r7, #24]
                                             sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);

            if(p) {
 801ca96:	69bb      	ldr	r3, [r7, #24]
 801ca98:	2b00      	cmp	r3, #0
 801ca9a:	d06f      	beq.n	801cb7c <get_glyph_dsc_id+0x210>
                lv_uintptr_t ofs = p - fdsc->cmaps[i].unicode_list;
 801ca9c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ca9e:	6899      	ldr	r1, [r3, #8]
 801caa0:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801caa2:	4613      	mov	r3, r2
 801caa4:	009b      	lsls	r3, r3, #2
 801caa6:	4413      	add	r3, r2
 801caa8:	009b      	lsls	r3, r3, #2
 801caaa:	440b      	add	r3, r1
 801caac:	689b      	ldr	r3, [r3, #8]
 801caae:	69ba      	ldr	r2, [r7, #24]
 801cab0:	1ad3      	subs	r3, r2, r3
 801cab2:	105b      	asrs	r3, r3, #1
 801cab4:	617b      	str	r3, [r7, #20]
                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;
 801cab6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801cab8:	6899      	ldr	r1, [r3, #8]
 801caba:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801cabc:	4613      	mov	r3, r2
 801cabe:	009b      	lsls	r3, r3, #2
 801cac0:	4413      	add	r3, r2
 801cac2:	009b      	lsls	r3, r3, #2
 801cac4:	440b      	add	r3, r1
 801cac6:	88db      	ldrh	r3, [r3, #6]
 801cac8:	461a      	mov	r2, r3
 801caca:	697b      	ldr	r3, [r7, #20]
 801cacc:	4413      	add	r3, r2
 801cace:	633b      	str	r3, [r7, #48]	@ 0x30
 801cad0:	e054      	b.n	801cb7c <get_glyph_dsc_id+0x210>
            }
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
 801cad2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801cad4:	6899      	ldr	r1, [r3, #8]
 801cad6:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801cad8:	4613      	mov	r3, r2
 801cada:	009b      	lsls	r3, r3, #2
 801cadc:	4413      	add	r3, r2
 801cade:	009b      	lsls	r3, r3, #2
 801cae0:	440b      	add	r3, r1
 801cae2:	7c9b      	ldrb	r3, [r3, #18]
 801cae4:	2b01      	cmp	r3, #1
 801cae6:	d149      	bne.n	801cb7c <get_glyph_dsc_id+0x210>
            uint16_t key = rcp;
 801cae8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801caea:	b29b      	uxth	r3, r3
 801caec:	81bb      	strh	r3, [r7, #12]
            uint16_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
 801caee:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801caf0:	6899      	ldr	r1, [r3, #8]
 801caf2:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801caf4:	4613      	mov	r3, r2
 801caf6:	009b      	lsls	r3, r3, #2
 801caf8:	4413      	add	r3, r2
 801cafa:	009b      	lsls	r3, r3, #2
 801cafc:	440b      	add	r3, r1
 801cafe:	689c      	ldr	r4, [r3, #8]
 801cb00:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801cb02:	6899      	ldr	r1, [r3, #8]
 801cb04:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801cb06:	4613      	mov	r3, r2
 801cb08:	009b      	lsls	r3, r3, #2
 801cb0a:	4413      	add	r3, r2
 801cb0c:	009b      	lsls	r3, r3, #2
 801cb0e:	440b      	add	r3, r1
 801cb10:	8a1b      	ldrh	r3, [r3, #16]
 801cb12:	461a      	mov	r2, r3
 801cb14:	f107 000c 	add.w	r0, r7, #12
 801cb18:	4b23      	ldr	r3, [pc, #140]	@ (801cba8 <get_glyph_dsc_id+0x23c>)
 801cb1a:	9300      	str	r3, [sp, #0]
 801cb1c:	2302      	movs	r3, #2
 801cb1e:	4621      	mov	r1, r4
 801cb20:	f007 fe42 	bl	80247a8 <_lv_utils_bsearch>
 801cb24:	6278      	str	r0, [r7, #36]	@ 0x24
                                             sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);

            if(p) {
 801cb26:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801cb28:	2b00      	cmp	r3, #0
 801cb2a:	d027      	beq.n	801cb7c <get_glyph_dsc_id+0x210>
                lv_uintptr_t ofs = p - fdsc->cmaps[i].unicode_list;
 801cb2c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801cb2e:	6899      	ldr	r1, [r3, #8]
 801cb30:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801cb32:	4613      	mov	r3, r2
 801cb34:	009b      	lsls	r3, r3, #2
 801cb36:	4413      	add	r3, r2
 801cb38:	009b      	lsls	r3, r3, #2
 801cb3a:	440b      	add	r3, r1
 801cb3c:	689b      	ldr	r3, [r3, #8]
 801cb3e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801cb40:	1ad3      	subs	r3, r2, r3
 801cb42:	105b      	asrs	r3, r3, #1
 801cb44:	623b      	str	r3, [r7, #32]
                const uint16_t * gid_ofs_16 = fdsc->cmaps[i].glyph_id_ofs_list;
 801cb46:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801cb48:	6899      	ldr	r1, [r3, #8]
 801cb4a:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801cb4c:	4613      	mov	r3, r2
 801cb4e:	009b      	lsls	r3, r3, #2
 801cb50:	4413      	add	r3, r2
 801cb52:	009b      	lsls	r3, r3, #2
 801cb54:	440b      	add	r3, r1
 801cb56:	68db      	ldr	r3, [r3, #12]
 801cb58:	61fb      	str	r3, [r7, #28]
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
 801cb5a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801cb5c:	6899      	ldr	r1, [r3, #8]
 801cb5e:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 801cb60:	4613      	mov	r3, r2
 801cb62:	009b      	lsls	r3, r3, #2
 801cb64:	4413      	add	r3, r2
 801cb66:	009b      	lsls	r3, r3, #2
 801cb68:	440b      	add	r3, r1
 801cb6a:	88db      	ldrh	r3, [r3, #6]
 801cb6c:	4619      	mov	r1, r3
 801cb6e:	6a3b      	ldr	r3, [r7, #32]
 801cb70:	005b      	lsls	r3, r3, #1
 801cb72:	69fa      	ldr	r2, [r7, #28]
 801cb74:	4413      	add	r3, r2
 801cb76:	881b      	ldrh	r3, [r3, #0]
 801cb78:	440b      	add	r3, r1
 801cb7a:	633b      	str	r3, [r7, #48]	@ 0x30
            }
        }

        return glyph_id;
 801cb7c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801cb7e:	e00e      	b.n	801cb9e <get_glyph_dsc_id+0x232>
        if(rcp >= fdsc->cmaps[i].range_length) continue;
 801cb80:	bf00      	nop
    for(i = 0; i < fdsc->cmap_num; i++) {
 801cb82:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 801cb84:	3301      	adds	r3, #1
 801cb86:	86fb      	strh	r3, [r7, #54]	@ 0x36
 801cb88:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801cb8a:	8a5b      	ldrh	r3, [r3, #18]
 801cb8c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 801cb90:	b29b      	uxth	r3, r3
 801cb92:	461a      	mov	r2, r3
 801cb94:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 801cb96:	4293      	cmp	r3, r2
 801cb98:	f4ff aef8 	bcc.w	801c98c <get_glyph_dsc_id+0x20>
    }

    return 0;
 801cb9c:	2300      	movs	r3, #0

}
 801cb9e:	4618      	mov	r0, r3
 801cba0:	373c      	adds	r7, #60	@ 0x3c
 801cba2:	46bd      	mov	sp, r7
 801cba4:	bd90      	pop	{r4, r7, pc}
 801cba6:	bf00      	nop
 801cba8:	0801cd7d 	.word	0x0801cd7d

0801cbac <get_kern_value>:

static int8_t get_kern_value(const lv_font_t * font, uint32_t gid_left, uint32_t gid_right)
{
 801cbac:	b580      	push	{r7, lr}
 801cbae:	b096      	sub	sp, #88	@ 0x58
 801cbb0:	af02      	add	r7, sp, #8
 801cbb2:	60f8      	str	r0, [r7, #12]
 801cbb4:	60b9      	str	r1, [r7, #8]
 801cbb6:	607a      	str	r2, [r7, #4]
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *)font->dsc;
 801cbb8:	68fb      	ldr	r3, [r7, #12]
 801cbba:	699b      	ldr	r3, [r3, #24]
 801cbbc:	64bb      	str	r3, [r7, #72]	@ 0x48

    int8_t value = 0;
 801cbbe:	2300      	movs	r3, #0
 801cbc0:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f

    if(fdsc->kern_classes == 0) {
 801cbc4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801cbc6:	7cdb      	ldrb	r3, [r3, #19]
 801cbc8:	f003 0320 	and.w	r3, r3, #32
 801cbcc:	b2db      	uxtb	r3, r3
 801cbce:	2b00      	cmp	r3, #0
 801cbd0:	d15a      	bne.n	801cc88 <get_kern_value+0xdc>
        /*Kern pairs*/
        const lv_font_fmt_txt_kern_pair_t * kdsc = fdsc->kern_dsc;
 801cbd2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801cbd4:	68db      	ldr	r3, [r3, #12]
 801cbd6:	63fb      	str	r3, [r7, #60]	@ 0x3c
        if(kdsc->glyph_ids_size == 0) {
 801cbd8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801cbda:	7adb      	ldrb	r3, [r3, #11]
 801cbdc:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 801cbe0:	b2db      	uxtb	r3, r3
 801cbe2:	2b00      	cmp	r3, #0
 801cbe4:	d124      	bne.n	801cc30 <get_kern_value+0x84>
            /*Use binary search to find the kern value.
             *The pairs are ordered left_id first, then right_id secondly.*/
            const uint16_t * g_ids = kdsc->glyph_ids;
 801cbe6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801cbe8:	681b      	ldr	r3, [r3, #0]
 801cbea:	62fb      	str	r3, [r7, #44]	@ 0x2c
            kern_pair_ref_t g_id_both = {gid_left, gid_right};
 801cbec:	68bb      	ldr	r3, [r7, #8]
 801cbee:	61fb      	str	r3, [r7, #28]
 801cbf0:	687b      	ldr	r3, [r7, #4]
 801cbf2:	623b      	str	r3, [r7, #32]
            uint16_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
 801cbf4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801cbf6:	689b      	ldr	r3, [r3, #8]
 801cbf8:	f3c3 031d 	ubfx	r3, r3, #0, #30
 801cbfc:	461a      	mov	r2, r3
 801cbfe:	f107 001c 	add.w	r0, r7, #28
 801cc02:	4b39      	ldr	r3, [pc, #228]	@ (801cce8 <get_kern_value+0x13c>)
 801cc04:	9300      	str	r3, [sp, #0]
 801cc06:	2302      	movs	r3, #2
 801cc08:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 801cc0a:	f007 fdcd 	bl	80247a8 <_lv_utils_bsearch>
 801cc0e:	62b8      	str	r0, [r7, #40]	@ 0x28

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
 801cc10:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801cc12:	2b00      	cmp	r3, #0
 801cc14:	d062      	beq.n	801ccdc <get_kern_value+0x130>
                lv_uintptr_t ofs = kid_p - g_ids;
 801cc16:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801cc18:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801cc1a:	1ad3      	subs	r3, r2, r3
 801cc1c:	105b      	asrs	r3, r3, #1
 801cc1e:	627b      	str	r3, [r7, #36]	@ 0x24
                value = kdsc->values[ofs];
 801cc20:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801cc22:	685a      	ldr	r2, [r3, #4]
 801cc24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801cc26:	4413      	add	r3, r2
 801cc28:	781b      	ldrb	r3, [r3, #0]
 801cc2a:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
 801cc2e:	e055      	b.n	801ccdc <get_kern_value+0x130>
            }
        }
        else if(kdsc->glyph_ids_size == 1) {
 801cc30:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801cc32:	7adb      	ldrb	r3, [r3, #11]
 801cc34:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 801cc38:	b2db      	uxtb	r3, r3
 801cc3a:	2b40      	cmp	r3, #64	@ 0x40
 801cc3c:	d14e      	bne.n	801ccdc <get_kern_value+0x130>
            /*Use binary search to find the kern value.
             *The pairs are ordered left_id first, then right_id secondly.*/
            const uint32_t * g_ids = kdsc->glyph_ids;
 801cc3e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801cc40:	681b      	ldr	r3, [r3, #0]
 801cc42:	63bb      	str	r3, [r7, #56]	@ 0x38
            kern_pair_ref_t g_id_both = {gid_left, gid_right};
 801cc44:	68bb      	ldr	r3, [r7, #8]
 801cc46:	617b      	str	r3, [r7, #20]
 801cc48:	687b      	ldr	r3, [r7, #4]
 801cc4a:	61bb      	str	r3, [r7, #24]
            uint32_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
 801cc4c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801cc4e:	689b      	ldr	r3, [r3, #8]
 801cc50:	f3c3 031d 	ubfx	r3, r3, #0, #30
 801cc54:	461a      	mov	r2, r3
 801cc56:	f107 0014 	add.w	r0, r7, #20
 801cc5a:	4b24      	ldr	r3, [pc, #144]	@ (801ccec <get_kern_value+0x140>)
 801cc5c:	9300      	str	r3, [sp, #0]
 801cc5e:	2304      	movs	r3, #4
 801cc60:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 801cc62:	f007 fda1 	bl	80247a8 <_lv_utils_bsearch>
 801cc66:	6378      	str	r0, [r7, #52]	@ 0x34

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
 801cc68:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801cc6a:	2b00      	cmp	r3, #0
 801cc6c:	d036      	beq.n	801ccdc <get_kern_value+0x130>
                lv_uintptr_t ofs = kid_p - g_ids;
 801cc6e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801cc70:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801cc72:	1ad3      	subs	r3, r2, r3
 801cc74:	109b      	asrs	r3, r3, #2
 801cc76:	633b      	str	r3, [r7, #48]	@ 0x30
                value = kdsc->values[ofs];
 801cc78:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801cc7a:	685a      	ldr	r2, [r3, #4]
 801cc7c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801cc7e:	4413      	add	r3, r2
 801cc80:	781b      	ldrb	r3, [r3, #0]
 801cc82:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
 801cc86:	e029      	b.n	801ccdc <get_kern_value+0x130>
            /*Invalid value*/
        }
    }
    else {
        /*Kern classes*/
        const lv_font_fmt_txt_kern_classes_t * kdsc = fdsc->kern_dsc;
 801cc88:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801cc8a:	68db      	ldr	r3, [r3, #12]
 801cc8c:	647b      	str	r3, [r7, #68]	@ 0x44
        uint8_t left_class = kdsc->left_class_mapping[gid_left];
 801cc8e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801cc90:	685a      	ldr	r2, [r3, #4]
 801cc92:	68bb      	ldr	r3, [r7, #8]
 801cc94:	4413      	add	r3, r2
 801cc96:	781b      	ldrb	r3, [r3, #0]
 801cc98:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
        uint8_t right_class = kdsc->right_class_mapping[gid_right];
 801cc9c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801cc9e:	689a      	ldr	r2, [r3, #8]
 801cca0:	687b      	ldr	r3, [r7, #4]
 801cca2:	4413      	add	r3, r2
 801cca4:	781b      	ldrb	r3, [r3, #0]
 801cca6:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42

        /*If class = 0, kerning not exist for that glyph
         *else got the value form `class_pair_values` 2D array*/
        if(left_class > 0 && right_class > 0) {
 801ccaa:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 801ccae:	2b00      	cmp	r3, #0
 801ccb0:	d014      	beq.n	801ccdc <get_kern_value+0x130>
 801ccb2:	f897 3042 	ldrb.w	r3, [r7, #66]	@ 0x42
 801ccb6:	2b00      	cmp	r3, #0
 801ccb8:	d010      	beq.n	801ccdc <get_kern_value+0x130>
            value = kdsc->class_pair_values[(left_class - 1) * kdsc->right_class_cnt + (right_class - 1)];
 801ccba:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ccbc:	681b      	ldr	r3, [r3, #0]
 801ccbe:	f897 2043 	ldrb.w	r2, [r7, #67]	@ 0x43
 801ccc2:	3a01      	subs	r2, #1
 801ccc4:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 801ccc6:	7b49      	ldrb	r1, [r1, #13]
 801ccc8:	fb02 f101 	mul.w	r1, r2, r1
 801cccc:	f897 2042 	ldrb.w	r2, [r7, #66]	@ 0x42
 801ccd0:	3a01      	subs	r2, #1
 801ccd2:	440a      	add	r2, r1
 801ccd4:	4413      	add	r3, r2
 801ccd6:	781b      	ldrb	r3, [r3, #0]
 801ccd8:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
        }

    }
    return value;
 801ccdc:	f997 304f 	ldrsb.w	r3, [r7, #79]	@ 0x4f
}
 801cce0:	4618      	mov	r0, r3
 801cce2:	3750      	adds	r7, #80	@ 0x50
 801cce4:	46bd      	mov	sp, r7
 801cce6:	bd80      	pop	{r7, pc}
 801cce8:	0801ccf1 	.word	0x0801ccf1
 801ccec:	0801cd37 	.word	0x0801cd37

0801ccf0 <kern_pair_8_compare>:

static int32_t kern_pair_8_compare(const void * ref, const void * element)
{
 801ccf0:	b480      	push	{r7}
 801ccf2:	b085      	sub	sp, #20
 801ccf4:	af00      	add	r7, sp, #0
 801ccf6:	6078      	str	r0, [r7, #4]
 801ccf8:	6039      	str	r1, [r7, #0]
    const kern_pair_ref_t * ref8_p = ref;
 801ccfa:	687b      	ldr	r3, [r7, #4]
 801ccfc:	60fb      	str	r3, [r7, #12]
    const uint8_t * element8_p = element;
 801ccfe:	683b      	ldr	r3, [r7, #0]
 801cd00:	60bb      	str	r3, [r7, #8]

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref8_p->gid_left != element8_p[0]) return (int32_t) ref8_p->gid_left - element8_p[0];
 801cd02:	68fb      	ldr	r3, [r7, #12]
 801cd04:	681b      	ldr	r3, [r3, #0]
 801cd06:	68ba      	ldr	r2, [r7, #8]
 801cd08:	7812      	ldrb	r2, [r2, #0]
 801cd0a:	4293      	cmp	r3, r2
 801cd0c:	d006      	beq.n	801cd1c <kern_pair_8_compare+0x2c>
 801cd0e:	68fb      	ldr	r3, [r7, #12]
 801cd10:	681b      	ldr	r3, [r3, #0]
 801cd12:	461a      	mov	r2, r3
 801cd14:	68bb      	ldr	r3, [r7, #8]
 801cd16:	781b      	ldrb	r3, [r3, #0]
 801cd18:	1ad3      	subs	r3, r2, r3
 801cd1a:	e006      	b.n	801cd2a <kern_pair_8_compare+0x3a>
    else return (int32_t) ref8_p->gid_right - element8_p[1];
 801cd1c:	68fb      	ldr	r3, [r7, #12]
 801cd1e:	685b      	ldr	r3, [r3, #4]
 801cd20:	461a      	mov	r2, r3
 801cd22:	68bb      	ldr	r3, [r7, #8]
 801cd24:	3301      	adds	r3, #1
 801cd26:	781b      	ldrb	r3, [r3, #0]
 801cd28:	1ad3      	subs	r3, r2, r3

}
 801cd2a:	4618      	mov	r0, r3
 801cd2c:	3714      	adds	r7, #20
 801cd2e:	46bd      	mov	sp, r7
 801cd30:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cd34:	4770      	bx	lr

0801cd36 <kern_pair_16_compare>:

static int32_t kern_pair_16_compare(const void * ref, const void * element)
{
 801cd36:	b480      	push	{r7}
 801cd38:	b085      	sub	sp, #20
 801cd3a:	af00      	add	r7, sp, #0
 801cd3c:	6078      	str	r0, [r7, #4]
 801cd3e:	6039      	str	r1, [r7, #0]
    const kern_pair_ref_t * ref16_p = ref;
 801cd40:	687b      	ldr	r3, [r7, #4]
 801cd42:	60fb      	str	r3, [r7, #12]
    const uint16_t * element16_p = element;
 801cd44:	683b      	ldr	r3, [r7, #0]
 801cd46:	60bb      	str	r3, [r7, #8]

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref16_p->gid_left != element16_p[0]) return (int32_t) ref16_p->gid_left - element16_p[0];
 801cd48:	68fb      	ldr	r3, [r7, #12]
 801cd4a:	681b      	ldr	r3, [r3, #0]
 801cd4c:	68ba      	ldr	r2, [r7, #8]
 801cd4e:	8812      	ldrh	r2, [r2, #0]
 801cd50:	4293      	cmp	r3, r2
 801cd52:	d006      	beq.n	801cd62 <kern_pair_16_compare+0x2c>
 801cd54:	68fb      	ldr	r3, [r7, #12]
 801cd56:	681b      	ldr	r3, [r3, #0]
 801cd58:	461a      	mov	r2, r3
 801cd5a:	68bb      	ldr	r3, [r7, #8]
 801cd5c:	881b      	ldrh	r3, [r3, #0]
 801cd5e:	1ad3      	subs	r3, r2, r3
 801cd60:	e006      	b.n	801cd70 <kern_pair_16_compare+0x3a>
    else return (int32_t) ref16_p->gid_right - element16_p[1];
 801cd62:	68fb      	ldr	r3, [r7, #12]
 801cd64:	685b      	ldr	r3, [r3, #4]
 801cd66:	461a      	mov	r2, r3
 801cd68:	68bb      	ldr	r3, [r7, #8]
 801cd6a:	3302      	adds	r3, #2
 801cd6c:	881b      	ldrh	r3, [r3, #0]
 801cd6e:	1ad3      	subs	r3, r2, r3
}
 801cd70:	4618      	mov	r0, r3
 801cd72:	3714      	adds	r7, #20
 801cd74:	46bd      	mov	sp, r7
 801cd76:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cd7a:	4770      	bx	lr

0801cd7c <unicode_list_compare>:
 *  @retval = 0   Reference is equal to element.
 *  @retval > 0   Reference is greater than element.
 *
 */
static int32_t unicode_list_compare(const void * ref, const void * element)
{
 801cd7c:	b480      	push	{r7}
 801cd7e:	b083      	sub	sp, #12
 801cd80:	af00      	add	r7, sp, #0
 801cd82:	6078      	str	r0, [r7, #4]
 801cd84:	6039      	str	r1, [r7, #0]
    return ((int32_t)(*(uint16_t *)ref)) - ((int32_t)(*(uint16_t *)element));
 801cd86:	687b      	ldr	r3, [r7, #4]
 801cd88:	881b      	ldrh	r3, [r3, #0]
 801cd8a:	461a      	mov	r2, r3
 801cd8c:	683b      	ldr	r3, [r7, #0]
 801cd8e:	881b      	ldrh	r3, [r3, #0]
 801cd90:	1ad3      	subs	r3, r2, r3
}
 801cd92:	4618      	mov	r0, r3
 801cd94:	370c      	adds	r7, #12
 801cd96:	46bd      	mov	sp, r7
 801cd98:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cd9c:	4770      	bx	lr

0801cd9e <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 801cd9e:	b580      	push	{r7, lr}
 801cda0:	b082      	sub	sp, #8
 801cda2:	af00      	add	r7, sp, #0
 801cda4:	6078      	str	r0, [r7, #4]
 801cda6:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 801cda8:	683a      	ldr	r2, [r7, #0]
 801cdaa:	2100      	movs	r1, #0
 801cdac:	6878      	ldr	r0, [r7, #4]
 801cdae:	f008 f838 	bl	8024e22 <lv_memset>
}
 801cdb2:	bf00      	nop
 801cdb4:	3708      	adds	r7, #8
 801cdb6:	46bd      	mov	sp, r7
 801cdb8:	bd80      	pop	{r7, pc}
	...

0801cdbc <lv_indev_get_next>:
    /*Free the memory of the input device*/
    lv_free(indev);
}

lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
{
 801cdbc:	b580      	push	{r7, lr}
 801cdbe:	b082      	sub	sp, #8
 801cdc0:	af00      	add	r7, sp, #0
 801cdc2:	6078      	str	r0, [r7, #4]
    if(indev == NULL)
 801cdc4:	687b      	ldr	r3, [r7, #4]
 801cdc6:	2b00      	cmp	r3, #0
 801cdc8:	d104      	bne.n	801cdd4 <lv_indev_get_next+0x18>
        return _lv_ll_get_head(indev_ll_head);
 801cdca:	4807      	ldr	r0, [pc, #28]	@ (801cde8 <lv_indev_get_next+0x2c>)
 801cdcc:	f006 f9ff 	bl	80231ce <_lv_ll_get_head>
 801cdd0:	4603      	mov	r3, r0
 801cdd2:	e004      	b.n	801cdde <lv_indev_get_next+0x22>
    else
        return _lv_ll_get_next(indev_ll_head, indev);
 801cdd4:	6879      	ldr	r1, [r7, #4]
 801cdd6:	4804      	ldr	r0, [pc, #16]	@ (801cde8 <lv_indev_get_next+0x2c>)
 801cdd8:	f006 fa1b 	bl	8023212 <_lv_ll_get_next>
 801cddc:	4603      	mov	r3, r0
}
 801cdde:	4618      	mov	r0, r3
 801cde0:	3708      	adds	r7, #8
 801cde2:	46bd      	mov	sp, r7
 801cde4:	bd80      	pop	{r7, pc}
 801cde6:	bf00      	nop
 801cde8:	200000e0 	.word	0x200000e0

0801cdec <lv_indev_active>:
        }
    }
}

lv_indev_t * lv_indev_active(void)
{
 801cdec:	b480      	push	{r7}
 801cdee:	af00      	add	r7, sp, #0
    return indev_act;
 801cdf0:	4b03      	ldr	r3, [pc, #12]	@ (801ce00 <lv_indev_active+0x14>)
 801cdf2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
}
 801cdf4:	4618      	mov	r0, r3
 801cdf6:	46bd      	mov	sp, r7
 801cdf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cdfc:	4770      	bx	lr
 801cdfe:	bf00      	nop
 801ce00:	2000009c 	.word	0x2000009c

0801ce04 <lv_indev_get_type>:

    return indev->read_cb;
}

lv_indev_type_t lv_indev_get_type(const lv_indev_t * indev)
{
 801ce04:	b480      	push	{r7}
 801ce06:	b083      	sub	sp, #12
 801ce08:	af00      	add	r7, sp, #0
 801ce0a:	6078      	str	r0, [r7, #4]
    if(indev == NULL) return LV_INDEV_TYPE_NONE;
 801ce0c:	687b      	ldr	r3, [r7, #4]
 801ce0e:	2b00      	cmp	r3, #0
 801ce10:	d101      	bne.n	801ce16 <lv_indev_get_type+0x12>
 801ce12:	2300      	movs	r3, #0
 801ce14:	e001      	b.n	801ce1a <lv_indev_get_type+0x16>

    return indev->type;
 801ce16:	687b      	ldr	r3, [r7, #4]
 801ce18:	781b      	ldrb	r3, [r3, #0]
}
 801ce1a:	4618      	mov	r0, r3
 801ce1c:	370c      	adds	r7, #12
 801ce1e:	46bd      	mov	sp, r7
 801ce20:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ce24:	4770      	bx	lr

0801ce26 <lv_indev_get_group>:

    return indev->state;
}

lv_group_t * lv_indev_get_group(const lv_indev_t * indev)
{
 801ce26:	b480      	push	{r7}
 801ce28:	b083      	sub	sp, #12
 801ce2a:	af00      	add	r7, sp, #0
 801ce2c:	6078      	str	r0, [r7, #4]
    if(indev == NULL) return NULL;
 801ce2e:	687b      	ldr	r3, [r7, #4]
 801ce30:	2b00      	cmp	r3, #0
 801ce32:	d101      	bne.n	801ce38 <lv_indev_get_group+0x12>
 801ce34:	2300      	movs	r3, #0
 801ce36:	e002      	b.n	801ce3e <lv_indev_get_group+0x18>

    return indev->group;
 801ce38:	687b      	ldr	r3, [r7, #4]
 801ce3a:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
}
 801ce3e:	4618      	mov	r0, r3
 801ce40:	370c      	adds	r7, #12
 801ce42:	46bd      	mov	sp, r7
 801ce44:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ce48:	4770      	bx	lr
	...

0801ce4c <lv_indev_reset>:

    return indev->driver_data;
}

void lv_indev_reset(lv_indev_t * indev, lv_obj_t * obj)
{
 801ce4c:	b580      	push	{r7, lr}
 801ce4e:	b084      	sub	sp, #16
 801ce50:	af00      	add	r7, sp, #0
 801ce52:	6078      	str	r0, [r7, #4]
 801ce54:	6039      	str	r1, [r7, #0]
    if(indev) {
 801ce56:	687b      	ldr	r3, [r7, #4]
 801ce58:	2b00      	cmp	r3, #0
 801ce5a:	d004      	beq.n	801ce66 <lv_indev_reset+0x1a>
        indev_reset_core(indev, obj);
 801ce5c:	6839      	ldr	r1, [r7, #0]
 801ce5e:	6878      	ldr	r0, [r7, #4]
 801ce60:	f000 f894 	bl	801cf8c <indev_reset_core>
            indev_reset_core(i, obj);
            i = lv_indev_get_next(i);
        }
        indev_obj_act = NULL;
    }
}
 801ce64:	e012      	b.n	801ce8c <lv_indev_reset+0x40>
        lv_indev_t * i = lv_indev_get_next(NULL);
 801ce66:	2000      	movs	r0, #0
 801ce68:	f7ff ffa8 	bl	801cdbc <lv_indev_get_next>
 801ce6c:	60f8      	str	r0, [r7, #12]
        while(i) {
 801ce6e:	e007      	b.n	801ce80 <lv_indev_reset+0x34>
            indev_reset_core(i, obj);
 801ce70:	6839      	ldr	r1, [r7, #0]
 801ce72:	68f8      	ldr	r0, [r7, #12]
 801ce74:	f000 f88a 	bl	801cf8c <indev_reset_core>
            i = lv_indev_get_next(i);
 801ce78:	68f8      	ldr	r0, [r7, #12]
 801ce7a:	f7ff ff9f 	bl	801cdbc <lv_indev_get_next>
 801ce7e:	60f8      	str	r0, [r7, #12]
        while(i) {
 801ce80:	68fb      	ldr	r3, [r7, #12]
 801ce82:	2b00      	cmp	r3, #0
 801ce84:	d1f4      	bne.n	801ce70 <lv_indev_reset+0x24>
        indev_obj_act = NULL;
 801ce86:	4b03      	ldr	r3, [pc, #12]	@ (801ce94 <lv_indev_reset+0x48>)
 801ce88:	2200      	movs	r2, #0
 801ce8a:	655a      	str	r2, [r3, #84]	@ 0x54
}
 801ce8c:	bf00      	nop
 801ce8e:	3710      	adds	r7, #16
 801ce90:	46bd      	mov	sp, r7
 801ce92:	bd80      	pop	{r7, pc}
 801ce94:	2000009c 	.word	0x2000009c

0801ce98 <lv_indev_get_scroll_dir>:

    return key;
}

lv_dir_t lv_indev_get_scroll_dir(const lv_indev_t * indev)
{
 801ce98:	b480      	push	{r7}
 801ce9a:	b083      	sub	sp, #12
 801ce9c:	af00      	add	r7, sp, #0
 801ce9e:	6078      	str	r0, [r7, #4]
    if(indev == NULL) return false;
 801cea0:	687b      	ldr	r3, [r7, #4]
 801cea2:	2b00      	cmp	r3, #0
 801cea4:	d101      	bne.n	801ceaa <lv_indev_get_scroll_dir+0x12>
 801cea6:	2300      	movs	r3, #0
 801cea8:	e00f      	b.n	801ceca <lv_indev_get_scroll_dir+0x32>
    if(indev->type != LV_INDEV_TYPE_POINTER && indev->type != LV_INDEV_TYPE_BUTTON) return false;
 801ceaa:	687b      	ldr	r3, [r7, #4]
 801ceac:	781b      	ldrb	r3, [r3, #0]
 801ceae:	2b01      	cmp	r3, #1
 801ceb0:	d005      	beq.n	801cebe <lv_indev_get_scroll_dir+0x26>
 801ceb2:	687b      	ldr	r3, [r7, #4]
 801ceb4:	781b      	ldrb	r3, [r3, #0]
 801ceb6:	2b03      	cmp	r3, #3
 801ceb8:	d001      	beq.n	801cebe <lv_indev_get_scroll_dir+0x26>
 801ceba:	2300      	movs	r3, #0
 801cebc:	e005      	b.n	801ceca <lv_indev_get_scroll_dir+0x32>
    return indev->pointer.scroll_dir;
 801cebe:	687b      	ldr	r3, [r7, #4]
 801cec0:	f893 308c 	ldrb.w	r3, [r3, #140]	@ 0x8c
 801cec4:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801cec8:	b2db      	uxtb	r3, r3
}
 801ceca:	4618      	mov	r0, r3
 801cecc:	370c      	adds	r7, #12
 801cece:	46bd      	mov	sp, r7
 801ced0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ced4:	4770      	bx	lr

0801ced6 <lv_indev_get_scroll_obj>:

lv_obj_t * lv_indev_get_scroll_obj(const lv_indev_t * indev)
{
 801ced6:	b480      	push	{r7}
 801ced8:	b083      	sub	sp, #12
 801ceda:	af00      	add	r7, sp, #0
 801cedc:	6078      	str	r0, [r7, #4]
    if(indev == NULL) return NULL;
 801cede:	687b      	ldr	r3, [r7, #4]
 801cee0:	2b00      	cmp	r3, #0
 801cee2:	d101      	bne.n	801cee8 <lv_indev_get_scroll_obj+0x12>
 801cee4:	2300      	movs	r3, #0
 801cee6:	e00b      	b.n	801cf00 <lv_indev_get_scroll_obj+0x2a>
    if(indev->type != LV_INDEV_TYPE_POINTER && indev->type != LV_INDEV_TYPE_BUTTON) return NULL;
 801cee8:	687b      	ldr	r3, [r7, #4]
 801ceea:	781b      	ldrb	r3, [r3, #0]
 801ceec:	2b01      	cmp	r3, #1
 801ceee:	d005      	beq.n	801cefc <lv_indev_get_scroll_obj+0x26>
 801cef0:	687b      	ldr	r3, [r7, #4]
 801cef2:	781b      	ldrb	r3, [r3, #0]
 801cef4:	2b03      	cmp	r3, #3
 801cef6:	d001      	beq.n	801cefc <lv_indev_get_scroll_obj+0x26>
 801cef8:	2300      	movs	r3, #0
 801cefa:	e001      	b.n	801cf00 <lv_indev_get_scroll_obj+0x2a>
    return indev->pointer.scroll_obj;
 801cefc:	687b      	ldr	r3, [r7, #4]
 801cefe:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
}
 801cf00:	4618      	mov	r0, r3
 801cf02:	370c      	adds	r7, #12
 801cf04:	46bd      	mov	sp, r7
 801cf06:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cf0a:	4770      	bx	lr

0801cf0c <lv_indev_send_event>:

    return removed_count;
}

lv_result_t lv_indev_send_event(lv_indev_t * indev, lv_event_code_t code, void * param)
{
 801cf0c:	b580      	push	{r7, lr}
 801cf0e:	b08c      	sub	sp, #48	@ 0x30
 801cf10:	af00      	add	r7, sp, #0
 801cf12:	60f8      	str	r0, [r7, #12]
 801cf14:	460b      	mov	r3, r1
 801cf16:	607a      	str	r2, [r7, #4]
 801cf18:	817b      	strh	r3, [r7, #10]

    lv_event_t e;
    lv_memzero(&e, sizeof(e));
 801cf1a:	f107 0310 	add.w	r3, r7, #16
 801cf1e:	211c      	movs	r1, #28
 801cf20:	4618      	mov	r0, r3
 801cf22:	f7ff ff3c 	bl	801cd9e <lv_memzero>
    e.code = code;
 801cf26:	897b      	ldrh	r3, [r7, #10]
 801cf28:	833b      	strh	r3, [r7, #24]
    e.current_target = indev;
 801cf2a:	68fb      	ldr	r3, [r7, #12]
 801cf2c:	613b      	str	r3, [r7, #16]
    e.original_target = indev;
 801cf2e:	68fb      	ldr	r3, [r7, #12]
 801cf30:	617b      	str	r3, [r7, #20]
    e.param = param;
 801cf32:	687b      	ldr	r3, [r7, #4]
 801cf34:	623b      	str	r3, [r7, #32]
    lv_result_t res;
    res = lv_event_send(&indev->event_list, &e, true);
 801cf36:	68fb      	ldr	r3, [r7, #12]
 801cf38:	33a4      	adds	r3, #164	@ 0xa4
 801cf3a:	f107 0110 	add.w	r1, r7, #16
 801cf3e:	2201      	movs	r2, #1
 801cf40:	4618      	mov	r0, r3
 801cf42:	f005 fbd9 	bl	80226f8 <lv_event_send>
 801cf46:	4603      	mov	r3, r0
 801cf48:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if(res != LV_RESULT_OK) return res;
 801cf4c:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801cf50:	2b01      	cmp	r3, #1
 801cf52:	d002      	beq.n	801cf5a <lv_indev_send_event+0x4e>
 801cf54:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801cf58:	e013      	b.n	801cf82 <lv_indev_send_event+0x76>

    res = lv_event_send(&indev->event_list, &e, false);
 801cf5a:	68fb      	ldr	r3, [r7, #12]
 801cf5c:	33a4      	adds	r3, #164	@ 0xa4
 801cf5e:	f107 0110 	add.w	r1, r7, #16
 801cf62:	2200      	movs	r2, #0
 801cf64:	4618      	mov	r0, r3
 801cf66:	f005 fbc7 	bl	80226f8 <lv_event_send>
 801cf6a:	4603      	mov	r3, r0
 801cf6c:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if(res != LV_RESULT_OK) return res;
 801cf70:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801cf74:	2b01      	cmp	r3, #1
 801cf76:	d002      	beq.n	801cf7e <lv_indev_send_event+0x72>
 801cf78:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801cf7c:	e001      	b.n	801cf82 <lv_indev_send_event+0x76>

    return res;
 801cf7e:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
 801cf82:	4618      	mov	r0, r3
 801cf84:	3730      	adds	r7, #48	@ 0x30
 801cf86:	46bd      	mov	sp, r7
 801cf88:	bd80      	pop	{r7, pc}
	...

0801cf8c <indev_reset_core>:
 * Reset the indev and send event to active obj and scroll obj
 * @param indev pointer to an input device
 * @param obj pointer to obj
*/
static void indev_reset_core(lv_indev_t * indev, lv_obj_t * obj)
{
 801cf8c:	b580      	push	{r7, lr}
 801cf8e:	b084      	sub	sp, #16
 801cf90:	af00      	add	r7, sp, #0
 801cf92:	6078      	str	r0, [r7, #4]
 801cf94:	6039      	str	r1, [r7, #0]
    lv_obj_t * act_obj = NULL;
 801cf96:	2300      	movs	r3, #0
 801cf98:	60fb      	str	r3, [r7, #12]
    lv_obj_t * scroll_obj = NULL;
 801cf9a:	2300      	movs	r3, #0
 801cf9c:	60bb      	str	r3, [r7, #8]

    indev->reset_query = 1;
 801cf9e:	687a      	ldr	r2, [r7, #4]
 801cfa0:	7a93      	ldrb	r3, [r2, #10]
 801cfa2:	f043 0302 	orr.w	r3, r3, #2
 801cfa6:	7293      	strb	r3, [r2, #10]
    if(indev_act == indev) indev_obj_act = NULL;
 801cfa8:	4b32      	ldr	r3, [pc, #200]	@ (801d074 <indev_reset_core+0xe8>)
 801cfaa:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 801cfac:	687a      	ldr	r2, [r7, #4]
 801cfae:	429a      	cmp	r2, r3
 801cfb0:	d102      	bne.n	801cfb8 <indev_reset_core+0x2c>
 801cfb2:	4b30      	ldr	r3, [pc, #192]	@ (801d074 <indev_reset_core+0xe8>)
 801cfb4:	2200      	movs	r2, #0
 801cfb6:	655a      	str	r2, [r3, #84]	@ 0x54
    if(indev->type == LV_INDEV_TYPE_POINTER || indev->type == LV_INDEV_TYPE_KEYPAD) {
 801cfb8:	687b      	ldr	r3, [r7, #4]
 801cfba:	781b      	ldrb	r3, [r3, #0]
 801cfbc:	2b01      	cmp	r3, #1
 801cfbe:	d003      	beq.n	801cfc8 <indev_reset_core+0x3c>
 801cfc0:	687b      	ldr	r3, [r7, #4]
 801cfc2:	781b      	ldrb	r3, [r3, #0]
 801cfc4:	2b02      	cmp	r3, #2
 801cfc6:	d151      	bne.n	801d06c <indev_reset_core+0xe0>
        if(obj == NULL || indev->pointer.last_pressed == obj) {
 801cfc8:	683b      	ldr	r3, [r7, #0]
 801cfca:	2b00      	cmp	r3, #0
 801cfcc:	d004      	beq.n	801cfd8 <indev_reset_core+0x4c>
 801cfce:	687b      	ldr	r3, [r7, #4]
 801cfd0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801cfd2:	683a      	ldr	r2, [r7, #0]
 801cfd4:	429a      	cmp	r2, r3
 801cfd6:	d102      	bne.n	801cfde <indev_reset_core+0x52>
            indev->pointer.last_pressed = NULL;
 801cfd8:	687b      	ldr	r3, [r7, #4]
 801cfda:	2200      	movs	r2, #0
 801cfdc:	671a      	str	r2, [r3, #112]	@ 0x70
        }
        if(obj == NULL || indev->pointer.act_obj == obj) {
 801cfde:	683b      	ldr	r3, [r7, #0]
 801cfe0:	2b00      	cmp	r3, #0
 801cfe2:	d004      	beq.n	801cfee <indev_reset_core+0x62>
 801cfe4:	687b      	ldr	r3, [r7, #4]
 801cfe6:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 801cfe8:	683a      	ldr	r2, [r7, #0]
 801cfea:	429a      	cmp	r2, r3
 801cfec:	d115      	bne.n	801d01a <indev_reset_core+0x8e>
            if(indev->pointer.act_obj) {
 801cfee:	687b      	ldr	r3, [r7, #4]
 801cff0:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 801cff2:	2b00      	cmp	r3, #0
 801cff4:	d011      	beq.n	801d01a <indev_reset_core+0x8e>
                /* Avoid recursive calls */
                act_obj = indev->pointer.act_obj;
 801cff6:	687b      	ldr	r3, [r7, #4]
 801cff8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 801cffa:	60fb      	str	r3, [r7, #12]
                indev->pointer.act_obj = NULL;
 801cffc:	687b      	ldr	r3, [r7, #4]
 801cffe:	2200      	movs	r2, #0
 801d000:	665a      	str	r2, [r3, #100]	@ 0x64
                lv_obj_send_event(act_obj, LV_EVENT_INDEV_RESET, indev);
 801d002:	687a      	ldr	r2, [r7, #4]
 801d004:	2113      	movs	r1, #19
 801d006:	68f8      	ldr	r0, [r7, #12]
 801d008:	f7e7 ff04 	bl	8004e14 <lv_obj_send_event>
                lv_indev_send_event(indev, LV_EVENT_INDEV_RESET, act_obj);
 801d00c:	68fa      	ldr	r2, [r7, #12]
 801d00e:	2113      	movs	r1, #19
 801d010:	6878      	ldr	r0, [r7, #4]
 801d012:	f7ff ff7b 	bl	801cf0c <lv_indev_send_event>
                act_obj = NULL;
 801d016:	2300      	movs	r3, #0
 801d018:	60fb      	str	r3, [r7, #12]
            }
        }
        if(obj == NULL || indev->pointer.last_obj == obj) {
 801d01a:	683b      	ldr	r3, [r7, #0]
 801d01c:	2b00      	cmp	r3, #0
 801d01e:	d004      	beq.n	801d02a <indev_reset_core+0x9e>
 801d020:	687b      	ldr	r3, [r7, #4]
 801d022:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801d024:	683a      	ldr	r2, [r7, #0]
 801d026:	429a      	cmp	r2, r3
 801d028:	d102      	bne.n	801d030 <indev_reset_core+0xa4>
            indev->pointer.last_obj = NULL;
 801d02a:	687b      	ldr	r3, [r7, #4]
 801d02c:	2200      	movs	r2, #0
 801d02e:	669a      	str	r2, [r3, #104]	@ 0x68
        }
        if(obj == NULL || indev->pointer.scroll_obj == obj) {
 801d030:	683b      	ldr	r3, [r7, #0]
 801d032:	2b00      	cmp	r3, #0
 801d034:	d004      	beq.n	801d040 <indev_reset_core+0xb4>
 801d036:	687b      	ldr	r3, [r7, #4]
 801d038:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801d03a:	683a      	ldr	r2, [r7, #0]
 801d03c:	429a      	cmp	r2, r3
 801d03e:	d115      	bne.n	801d06c <indev_reset_core+0xe0>
            if(indev->pointer.scroll_obj) {
 801d040:	687b      	ldr	r3, [r7, #4]
 801d042:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801d044:	2b00      	cmp	r3, #0
 801d046:	d011      	beq.n	801d06c <indev_reset_core+0xe0>
                /* Avoid recursive calls */
                scroll_obj = indev->pointer.scroll_obj;
 801d048:	687b      	ldr	r3, [r7, #4]
 801d04a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801d04c:	60bb      	str	r3, [r7, #8]
                indev->pointer.scroll_obj = NULL;
 801d04e:	687b      	ldr	r3, [r7, #4]
 801d050:	2200      	movs	r2, #0
 801d052:	66da      	str	r2, [r3, #108]	@ 0x6c
                lv_obj_send_event(scroll_obj, LV_EVENT_INDEV_RESET, indev);
 801d054:	687a      	ldr	r2, [r7, #4]
 801d056:	2113      	movs	r1, #19
 801d058:	68b8      	ldr	r0, [r7, #8]
 801d05a:	f7e7 fedb 	bl	8004e14 <lv_obj_send_event>
                lv_indev_send_event(indev, LV_EVENT_INDEV_RESET, act_obj);
 801d05e:	68fa      	ldr	r2, [r7, #12]
 801d060:	2113      	movs	r1, #19
 801d062:	6878      	ldr	r0, [r7, #4]
 801d064:	f7ff ff52 	bl	801cf0c <lv_indev_send_event>
                scroll_obj = NULL;
 801d068:	2300      	movs	r3, #0
 801d06a:	60bb      	str	r3, [r7, #8]
            }
        }
    }
}
 801d06c:	bf00      	nop
 801d06e:	3710      	adds	r7, #16
 801d070:	46bd      	mov	sp, r7
 801d072:	bd80      	pop	{r7, pc}
 801d074:	2000009c 	.word	0x2000009c

0801d078 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 801d078:	b480      	push	{r7}
 801d07a:	b083      	sub	sp, #12
 801d07c:	af00      	add	r7, sp, #0
 801d07e:	6078      	str	r0, [r7, #4]
 801d080:	6039      	str	r1, [r7, #0]
    dest->x1 = src->x1;
 801d082:	683b      	ldr	r3, [r7, #0]
 801d084:	681a      	ldr	r2, [r3, #0]
 801d086:	687b      	ldr	r3, [r7, #4]
 801d088:	601a      	str	r2, [r3, #0]
    dest->y1 = src->y1;
 801d08a:	683b      	ldr	r3, [r7, #0]
 801d08c:	685a      	ldr	r2, [r3, #4]
 801d08e:	687b      	ldr	r3, [r7, #4]
 801d090:	605a      	str	r2, [r3, #4]
    dest->x2 = src->x2;
 801d092:	683b      	ldr	r3, [r7, #0]
 801d094:	689a      	ldr	r2, [r3, #8]
 801d096:	687b      	ldr	r3, [r7, #4]
 801d098:	609a      	str	r2, [r3, #8]
    dest->y2 = src->y2;
 801d09a:	683b      	ldr	r3, [r7, #0]
 801d09c:	68da      	ldr	r2, [r3, #12]
 801d09e:	687b      	ldr	r3, [r7, #4]
 801d0a0:	60da      	str	r2, [r3, #12]
}
 801d0a2:	bf00      	nop
 801d0a4:	370c      	adds	r7, #12
 801d0a6:	46bd      	mov	sp, r7
 801d0a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d0ac:	4770      	bx	lr

0801d0ae <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline int32_t lv_area_get_width(const lv_area_t * area_p)
{
 801d0ae:	b480      	push	{r7}
 801d0b0:	b083      	sub	sp, #12
 801d0b2:	af00      	add	r7, sp, #0
 801d0b4:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 801d0b6:	687b      	ldr	r3, [r7, #4]
 801d0b8:	689a      	ldr	r2, [r3, #8]
 801d0ba:	687b      	ldr	r3, [r7, #4]
 801d0bc:	681b      	ldr	r3, [r3, #0]
 801d0be:	1ad3      	subs	r3, r2, r3
 801d0c0:	3301      	adds	r3, #1
}
 801d0c2:	4618      	mov	r0, r3
 801d0c4:	370c      	adds	r7, #12
 801d0c6:	46bd      	mov	sp, r7
 801d0c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d0cc:	4770      	bx	lr

0801d0ce <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline int32_t lv_area_get_height(const lv_area_t * area_p)
{
 801d0ce:	b480      	push	{r7}
 801d0d0:	b083      	sub	sp, #12
 801d0d2:	af00      	add	r7, sp, #0
 801d0d4:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 801d0d6:	687b      	ldr	r3, [r7, #4]
 801d0d8:	68da      	ldr	r2, [r3, #12]
 801d0da:	687b      	ldr	r3, [r7, #4]
 801d0dc:	685b      	ldr	r3, [r3, #4]
 801d0de:	1ad3      	subs	r3, r2, r3
 801d0e0:	3301      	adds	r3, #1
}
 801d0e2:	4618      	mov	r0, r3
 801d0e4:	370c      	adds	r7, #12
 801d0e6:	46bd      	mov	sp, r7
 801d0e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d0ec:	4770      	bx	lr

0801d0ee <lv_obj_get_style_width>:
#include "../misc/lv_area.h"
#include "../misc/lv_style.h"
#include "../core/lv_obj_style.h"

static inline int32_t lv_obj_get_style_width(const lv_obj_t * obj, uint32_t part)
{
 801d0ee:	b580      	push	{r7, lr}
 801d0f0:	b084      	sub	sp, #16
 801d0f2:	af00      	add	r7, sp, #0
 801d0f4:	6078      	str	r0, [r7, #4]
 801d0f6:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_WIDTH);
 801d0f8:	2201      	movs	r2, #1
 801d0fa:	6839      	ldr	r1, [r7, #0]
 801d0fc:	6878      	ldr	r0, [r7, #4]
 801d0fe:	f7ec fb13 	bl	8009728 <lv_obj_get_style_prop>
 801d102:	4603      	mov	r3, r0
 801d104:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d106:	68fb      	ldr	r3, [r7, #12]
}
 801d108:	4618      	mov	r0, r3
 801d10a:	3710      	adds	r7, #16
 801d10c:	46bd      	mov	sp, r7
 801d10e:	bd80      	pop	{r7, pc}

0801d110 <lv_obj_get_style_min_width>:

static inline int32_t lv_obj_get_style_min_width(const lv_obj_t * obj, uint32_t part)
{
 801d110:	b580      	push	{r7, lr}
 801d112:	b084      	sub	sp, #16
 801d114:	af00      	add	r7, sp, #0
 801d116:	6078      	str	r0, [r7, #4]
 801d118:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MIN_WIDTH);
 801d11a:	2204      	movs	r2, #4
 801d11c:	6839      	ldr	r1, [r7, #0]
 801d11e:	6878      	ldr	r0, [r7, #4]
 801d120:	f7ec fb02 	bl	8009728 <lv_obj_get_style_prop>
 801d124:	4603      	mov	r3, r0
 801d126:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d128:	68fb      	ldr	r3, [r7, #12]
}
 801d12a:	4618      	mov	r0, r3
 801d12c:	3710      	adds	r7, #16
 801d12e:	46bd      	mov	sp, r7
 801d130:	bd80      	pop	{r7, pc}

0801d132 <lv_obj_get_style_max_width>:

static inline int32_t lv_obj_get_style_max_width(const lv_obj_t * obj, uint32_t part)
{
 801d132:	b580      	push	{r7, lr}
 801d134:	b084      	sub	sp, #16
 801d136:	af00      	add	r7, sp, #0
 801d138:	6078      	str	r0, [r7, #4]
 801d13a:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MAX_WIDTH);
 801d13c:	2205      	movs	r2, #5
 801d13e:	6839      	ldr	r1, [r7, #0]
 801d140:	6878      	ldr	r0, [r7, #4]
 801d142:	f7ec faf1 	bl	8009728 <lv_obj_get_style_prop>
 801d146:	4603      	mov	r3, r0
 801d148:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d14a:	68fb      	ldr	r3, [r7, #12]
}
 801d14c:	4618      	mov	r0, r3
 801d14e:	3710      	adds	r7, #16
 801d150:	46bd      	mov	sp, r7
 801d152:	bd80      	pop	{r7, pc}

0801d154 <lv_obj_get_style_height>:

static inline int32_t lv_obj_get_style_height(const lv_obj_t * obj, uint32_t part)
{
 801d154:	b580      	push	{r7, lr}
 801d156:	b084      	sub	sp, #16
 801d158:	af00      	add	r7, sp, #0
 801d15a:	6078      	str	r0, [r7, #4]
 801d15c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_HEIGHT);
 801d15e:	2202      	movs	r2, #2
 801d160:	6839      	ldr	r1, [r7, #0]
 801d162:	6878      	ldr	r0, [r7, #4]
 801d164:	f7ec fae0 	bl	8009728 <lv_obj_get_style_prop>
 801d168:	4603      	mov	r3, r0
 801d16a:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d16c:	68fb      	ldr	r3, [r7, #12]
}
 801d16e:	4618      	mov	r0, r3
 801d170:	3710      	adds	r7, #16
 801d172:	46bd      	mov	sp, r7
 801d174:	bd80      	pop	{r7, pc}

0801d176 <lv_obj_get_style_min_height>:

static inline int32_t lv_obj_get_style_min_height(const lv_obj_t * obj, uint32_t part)
{
 801d176:	b580      	push	{r7, lr}
 801d178:	b084      	sub	sp, #16
 801d17a:	af00      	add	r7, sp, #0
 801d17c:	6078      	str	r0, [r7, #4]
 801d17e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MIN_HEIGHT);
 801d180:	2206      	movs	r2, #6
 801d182:	6839      	ldr	r1, [r7, #0]
 801d184:	6878      	ldr	r0, [r7, #4]
 801d186:	f7ec facf 	bl	8009728 <lv_obj_get_style_prop>
 801d18a:	4603      	mov	r3, r0
 801d18c:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d18e:	68fb      	ldr	r3, [r7, #12]
}
 801d190:	4618      	mov	r0, r3
 801d192:	3710      	adds	r7, #16
 801d194:	46bd      	mov	sp, r7
 801d196:	bd80      	pop	{r7, pc}

0801d198 <lv_obj_get_style_max_height>:

static inline int32_t lv_obj_get_style_max_height(const lv_obj_t * obj, uint32_t part)
{
 801d198:	b580      	push	{r7, lr}
 801d19a:	b084      	sub	sp, #16
 801d19c:	af00      	add	r7, sp, #0
 801d19e:	6078      	str	r0, [r7, #4]
 801d1a0:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MAX_HEIGHT);
 801d1a2:	2207      	movs	r2, #7
 801d1a4:	6839      	ldr	r1, [r7, #0]
 801d1a6:	6878      	ldr	r0, [r7, #4]
 801d1a8:	f7ec fabe 	bl	8009728 <lv_obj_get_style_prop>
 801d1ac:	4603      	mov	r3, r0
 801d1ae:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d1b0:	68fb      	ldr	r3, [r7, #12]
}
 801d1b2:	4618      	mov	r0, r3
 801d1b4:	3710      	adds	r7, #16
 801d1b6:	46bd      	mov	sp, r7
 801d1b8:	bd80      	pop	{r7, pc}

0801d1ba <lv_obj_get_style_translate_x>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_HEIGHT);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_translate_x(const lv_obj_t * obj, uint32_t part)
{
 801d1ba:	b580      	push	{r7, lr}
 801d1bc:	b084      	sub	sp, #16
 801d1be:	af00      	add	r7, sp, #0
 801d1c0:	6078      	str	r0, [r7, #4]
 801d1c2:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSLATE_X);
 801d1c4:	226a      	movs	r2, #106	@ 0x6a
 801d1c6:	6839      	ldr	r1, [r7, #0]
 801d1c8:	6878      	ldr	r0, [r7, #4]
 801d1ca:	f7ec faad 	bl	8009728 <lv_obj_get_style_prop>
 801d1ce:	4603      	mov	r3, r0
 801d1d0:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d1d2:	68fb      	ldr	r3, [r7, #12]
}
 801d1d4:	4618      	mov	r0, r3
 801d1d6:	3710      	adds	r7, #16
 801d1d8:	46bd      	mov	sp, r7
 801d1da:	bd80      	pop	{r7, pc}

0801d1dc <lv_obj_get_style_translate_y>:

static inline int32_t lv_obj_get_style_translate_y(const lv_obj_t * obj, uint32_t part)
{
 801d1dc:	b580      	push	{r7, lr}
 801d1de:	b084      	sub	sp, #16
 801d1e0:	af00      	add	r7, sp, #0
 801d1e2:	6078      	str	r0, [r7, #4]
 801d1e4:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSLATE_Y);
 801d1e6:	226b      	movs	r2, #107	@ 0x6b
 801d1e8:	6839      	ldr	r1, [r7, #0]
 801d1ea:	6878      	ldr	r0, [r7, #4]
 801d1ec:	f7ec fa9c 	bl	8009728 <lv_obj_get_style_prop>
 801d1f0:	4603      	mov	r3, r0
 801d1f2:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d1f4:	68fb      	ldr	r3, [r7, #12]
}
 801d1f6:	4618      	mov	r0, r3
 801d1f8:	3710      	adds	r7, #16
 801d1fa:	46bd      	mov	sp, r7
 801d1fc:	bd80      	pop	{r7, pc}

0801d1fe <lv_obj_get_style_pad_top>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_SKEW_Y);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_pad_top(const lv_obj_t * obj, uint32_t part)
{
 801d1fe:	b580      	push	{r7, lr}
 801d200:	b084      	sub	sp, #16
 801d202:	af00      	add	r7, sp, #0
 801d204:	6078      	str	r0, [r7, #4]
 801d206:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_TOP);
 801d208:	2210      	movs	r2, #16
 801d20a:	6839      	ldr	r1, [r7, #0]
 801d20c:	6878      	ldr	r0, [r7, #4]
 801d20e:	f7ec fa8b 	bl	8009728 <lv_obj_get_style_prop>
 801d212:	4603      	mov	r3, r0
 801d214:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d216:	68fb      	ldr	r3, [r7, #12]
}
 801d218:	4618      	mov	r0, r3
 801d21a:	3710      	adds	r7, #16
 801d21c:	46bd      	mov	sp, r7
 801d21e:	bd80      	pop	{r7, pc}

0801d220 <lv_obj_get_style_pad_left>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_BOTTOM);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_pad_left(const lv_obj_t * obj, uint32_t part)
{
 801d220:	b580      	push	{r7, lr}
 801d222:	b084      	sub	sp, #16
 801d224:	af00      	add	r7, sp, #0
 801d226:	6078      	str	r0, [r7, #4]
 801d228:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_LEFT);
 801d22a:	2212      	movs	r2, #18
 801d22c:	6839      	ldr	r1, [r7, #0]
 801d22e:	6878      	ldr	r0, [r7, #4]
 801d230:	f7ec fa7a 	bl	8009728 <lv_obj_get_style_prop>
 801d234:	4603      	mov	r3, r0
 801d236:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d238:	68fb      	ldr	r3, [r7, #12]
}
 801d23a:	4618      	mov	r0, r3
 801d23c:	3710      	adds	r7, #16
 801d23e:	46bd      	mov	sp, r7
 801d240:	bd80      	pop	{r7, pc}

0801d242 <lv_obj_get_style_pad_row>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_RIGHT);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_pad_row(const lv_obj_t * obj, uint32_t part)
{
 801d242:	b580      	push	{r7, lr}
 801d244:	b084      	sub	sp, #16
 801d246:	af00      	add	r7, sp, #0
 801d248:	6078      	str	r0, [r7, #4]
 801d24a:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_ROW);
 801d24c:	2214      	movs	r2, #20
 801d24e:	6839      	ldr	r1, [r7, #0]
 801d250:	6878      	ldr	r0, [r7, #4]
 801d252:	f7ec fa69 	bl	8009728 <lv_obj_get_style_prop>
 801d256:	4603      	mov	r3, r0
 801d258:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d25a:	68fb      	ldr	r3, [r7, #12]
}
 801d25c:	4618      	mov	r0, r3
 801d25e:	3710      	adds	r7, #16
 801d260:	46bd      	mov	sp, r7
 801d262:	bd80      	pop	{r7, pc}

0801d264 <lv_obj_get_style_pad_column>:

static inline int32_t lv_obj_get_style_pad_column(const lv_obj_t * obj, uint32_t part)
{
 801d264:	b580      	push	{r7, lr}
 801d266:	b084      	sub	sp, #16
 801d268:	af00      	add	r7, sp, #0
 801d26a:	6078      	str	r0, [r7, #4]
 801d26c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_COLUMN);
 801d26e:	2215      	movs	r2, #21
 801d270:	6839      	ldr	r1, [r7, #0]
 801d272:	6878      	ldr	r0, [r7, #4]
 801d274:	f7ec fa58 	bl	8009728 <lv_obj_get_style_prop>
 801d278:	4603      	mov	r3, r0
 801d27a:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d27c:	68fb      	ldr	r3, [r7, #12]
}
 801d27e:	4618      	mov	r0, r3
 801d280:	3710      	adds	r7, #16
 801d282:	46bd      	mov	sp, r7
 801d284:	bd80      	pop	{r7, pc}

0801d286 <lv_obj_get_style_margin_top>:

static inline int32_t lv_obj_get_style_margin_top(const lv_obj_t * obj, uint32_t part)
{
 801d286:	b580      	push	{r7, lr}
 801d288:	b084      	sub	sp, #16
 801d28a:	af00      	add	r7, sp, #0
 801d28c:	6078      	str	r0, [r7, #4]
 801d28e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_TOP);
 801d290:	2218      	movs	r2, #24
 801d292:	6839      	ldr	r1, [r7, #0]
 801d294:	6878      	ldr	r0, [r7, #4]
 801d296:	f7ec fa47 	bl	8009728 <lv_obj_get_style_prop>
 801d29a:	4603      	mov	r3, r0
 801d29c:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d29e:	68fb      	ldr	r3, [r7, #12]
}
 801d2a0:	4618      	mov	r0, r3
 801d2a2:	3710      	adds	r7, #16
 801d2a4:	46bd      	mov	sp, r7
 801d2a6:	bd80      	pop	{r7, pc}

0801d2a8 <lv_obj_get_style_margin_bottom>:

static inline int32_t lv_obj_get_style_margin_bottom(const lv_obj_t * obj, uint32_t part)
{
 801d2a8:	b580      	push	{r7, lr}
 801d2aa:	b084      	sub	sp, #16
 801d2ac:	af00      	add	r7, sp, #0
 801d2ae:	6078      	str	r0, [r7, #4]
 801d2b0:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_BOTTOM);
 801d2b2:	2219      	movs	r2, #25
 801d2b4:	6839      	ldr	r1, [r7, #0]
 801d2b6:	6878      	ldr	r0, [r7, #4]
 801d2b8:	f7ec fa36 	bl	8009728 <lv_obj_get_style_prop>
 801d2bc:	4603      	mov	r3, r0
 801d2be:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d2c0:	68fb      	ldr	r3, [r7, #12]
}
 801d2c2:	4618      	mov	r0, r3
 801d2c4:	3710      	adds	r7, #16
 801d2c6:	46bd      	mov	sp, r7
 801d2c8:	bd80      	pop	{r7, pc}

0801d2ca <lv_obj_get_style_margin_left>:

static inline int32_t lv_obj_get_style_margin_left(const lv_obj_t * obj, uint32_t part)
{
 801d2ca:	b580      	push	{r7, lr}
 801d2cc:	b084      	sub	sp, #16
 801d2ce:	af00      	add	r7, sp, #0
 801d2d0:	6078      	str	r0, [r7, #4]
 801d2d2:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_LEFT);
 801d2d4:	221a      	movs	r2, #26
 801d2d6:	6839      	ldr	r1, [r7, #0]
 801d2d8:	6878      	ldr	r0, [r7, #4]
 801d2da:	f7ec fa25 	bl	8009728 <lv_obj_get_style_prop>
 801d2de:	4603      	mov	r3, r0
 801d2e0:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d2e2:	68fb      	ldr	r3, [r7, #12]
}
 801d2e4:	4618      	mov	r0, r3
 801d2e6:	3710      	adds	r7, #16
 801d2e8:	46bd      	mov	sp, r7
 801d2ea:	bd80      	pop	{r7, pc}

0801d2ec <lv_obj_get_style_margin_right>:

static inline int32_t lv_obj_get_style_margin_right(const lv_obj_t * obj, uint32_t part)
{
 801d2ec:	b580      	push	{r7, lr}
 801d2ee:	b084      	sub	sp, #16
 801d2f0:	af00      	add	r7, sp, #0
 801d2f2:	6078      	str	r0, [r7, #4]
 801d2f4:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_RIGHT);
 801d2f6:	221b      	movs	r2, #27
 801d2f8:	6839      	ldr	r1, [r7, #0]
 801d2fa:	6878      	ldr	r0, [r7, #4]
 801d2fc:	f7ec fa14 	bl	8009728 <lv_obj_get_style_prop>
 801d300:	4603      	mov	r3, r0
 801d302:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d304:	68fb      	ldr	r3, [r7, #12]
}
 801d306:	4618      	mov	r0, r3
 801d308:	3710      	adds	r7, #16
 801d30a:	46bd      	mov	sp, r7
 801d30c:	bd80      	pop	{r7, pc}

0801d30e <lv_obj_get_style_border_width>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_OPA);
    return (lv_opa_t)v.num;
}

static inline int32_t lv_obj_get_style_border_width(const lv_obj_t * obj, uint32_t part)
{
 801d30e:	b580      	push	{r7, lr}
 801d310:	b084      	sub	sp, #16
 801d312:	af00      	add	r7, sp, #0
 801d314:	6078      	str	r0, [r7, #4]
 801d316:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_WIDTH);
 801d318:	2230      	movs	r2, #48	@ 0x30
 801d31a:	6839      	ldr	r1, [r7, #0]
 801d31c:	6878      	ldr	r0, [r7, #4]
 801d31e:	f7ec fa03 	bl	8009728 <lv_obj_get_style_prop>
 801d322:	4603      	mov	r3, r0
 801d324:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801d326:	68fb      	ldr	r3, [r7, #12]
}
 801d328:	4618      	mov	r0, r3
 801d32a:	3710      	adds	r7, #16
 801d32c:	46bd      	mov	sp, r7
 801d32e:	bd80      	pop	{r7, pc}

0801d330 <lv_obj_get_style_border_side>:

static inline lv_border_side_t lv_obj_get_style_border_side(const lv_obj_t * obj, uint32_t part)
{
 801d330:	b580      	push	{r7, lr}
 801d332:	b084      	sub	sp, #16
 801d334:	af00      	add	r7, sp, #0
 801d336:	6078      	str	r0, [r7, #4]
 801d338:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_SIDE);
 801d33a:	2234      	movs	r2, #52	@ 0x34
 801d33c:	6839      	ldr	r1, [r7, #0]
 801d33e:	6878      	ldr	r0, [r7, #4]
 801d340:	f7ec f9f2 	bl	8009728 <lv_obj_get_style_prop>
 801d344:	4603      	mov	r3, r0
 801d346:	60fb      	str	r3, [r7, #12]
    return (lv_border_side_t)v.num;
 801d348:	68fb      	ldr	r3, [r7, #12]
 801d34a:	b2db      	uxtb	r3, r3
}
 801d34c:	4618      	mov	r0, r3
 801d34e:	3710      	adds	r7, #16
 801d350:	46bd      	mov	sp, r7
 801d352:	bd80      	pop	{r7, pc}

0801d354 <lv_obj_get_style_base_dir>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LAYOUT);
    return (uint16_t)v.num;
}

static inline lv_base_dir_t lv_obj_get_style_base_dir(const lv_obj_t * obj, uint32_t part)
{
 801d354:	b580      	push	{r7, lr}
 801d356:	b084      	sub	sp, #16
 801d358:	af00      	add	r7, sp, #0
 801d35a:	6078      	str	r0, [r7, #4]
 801d35c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BASE_DIR);
 801d35e:	2227      	movs	r2, #39	@ 0x27
 801d360:	6839      	ldr	r1, [r7, #0]
 801d362:	6878      	ldr	r0, [r7, #4]
 801d364:	f7ec f9e0 	bl	8009728 <lv_obj_get_style_prop>
 801d368:	4603      	mov	r3, r0
 801d36a:	60fb      	str	r3, [r7, #12]
    return (lv_base_dir_t)v.num;
 801d36c:	68fb      	ldr	r3, [r7, #12]
 801d36e:	b2db      	uxtb	r3, r3
}
 801d370:	4618      	mov	r0, r3
 801d372:	3710      	adds	r7, #16
 801d374:	46bd      	mov	sp, r7
 801d376:	bd80      	pop	{r7, pc}

0801d378 <lv_obj_get_style_flex_flow>:
}

#if LV_USE_FLEX

static inline lv_flex_flow_t lv_obj_get_style_flex_flow(const lv_obj_t * obj, uint32_t part)
{
 801d378:	b580      	push	{r7, lr}
 801d37a:	b084      	sub	sp, #16
 801d37c:	af00      	add	r7, sp, #0
 801d37e:	6078      	str	r0, [r7, #4]
 801d380:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_FLEX_FLOW);
 801d382:	227d      	movs	r2, #125	@ 0x7d
 801d384:	6839      	ldr	r1, [r7, #0]
 801d386:	6878      	ldr	r0, [r7, #4]
 801d388:	f7ec f9ce 	bl	8009728 <lv_obj_get_style_prop>
 801d38c:	4603      	mov	r3, r0
 801d38e:	60fb      	str	r3, [r7, #12]
    return (lv_flex_flow_t)v.num;
 801d390:	68fb      	ldr	r3, [r7, #12]
 801d392:	b2db      	uxtb	r3, r3
}
 801d394:	4618      	mov	r0, r3
 801d396:	3710      	adds	r7, #16
 801d398:	46bd      	mov	sp, r7
 801d39a:	bd80      	pop	{r7, pc}

0801d39c <lv_obj_get_style_flex_main_place>:

static inline lv_flex_align_t lv_obj_get_style_flex_main_place(const lv_obj_t * obj, uint32_t part)
{
 801d39c:	b580      	push	{r7, lr}
 801d39e:	b084      	sub	sp, #16
 801d3a0:	af00      	add	r7, sp, #0
 801d3a2:	6078      	str	r0, [r7, #4]
 801d3a4:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_FLEX_MAIN_PLACE);
 801d3a6:	227e      	movs	r2, #126	@ 0x7e
 801d3a8:	6839      	ldr	r1, [r7, #0]
 801d3aa:	6878      	ldr	r0, [r7, #4]
 801d3ac:	f7ec f9bc 	bl	8009728 <lv_obj_get_style_prop>
 801d3b0:	4603      	mov	r3, r0
 801d3b2:	60fb      	str	r3, [r7, #12]
    return (lv_flex_align_t)v.num;
 801d3b4:	68fb      	ldr	r3, [r7, #12]
 801d3b6:	b2db      	uxtb	r3, r3
}
 801d3b8:	4618      	mov	r0, r3
 801d3ba:	3710      	adds	r7, #16
 801d3bc:	46bd      	mov	sp, r7
 801d3be:	bd80      	pop	{r7, pc}

0801d3c0 <lv_obj_get_style_flex_cross_place>:

static inline lv_flex_align_t lv_obj_get_style_flex_cross_place(const lv_obj_t * obj, uint32_t part)
{
 801d3c0:	b580      	push	{r7, lr}
 801d3c2:	b084      	sub	sp, #16
 801d3c4:	af00      	add	r7, sp, #0
 801d3c6:	6078      	str	r0, [r7, #4]
 801d3c8:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_FLEX_CROSS_PLACE);
 801d3ca:	227f      	movs	r2, #127	@ 0x7f
 801d3cc:	6839      	ldr	r1, [r7, #0]
 801d3ce:	6878      	ldr	r0, [r7, #4]
 801d3d0:	f7ec f9aa 	bl	8009728 <lv_obj_get_style_prop>
 801d3d4:	4603      	mov	r3, r0
 801d3d6:	60fb      	str	r3, [r7, #12]
    return (lv_flex_align_t)v.num;
 801d3d8:	68fb      	ldr	r3, [r7, #12]
 801d3da:	b2db      	uxtb	r3, r3
}
 801d3dc:	4618      	mov	r0, r3
 801d3de:	3710      	adds	r7, #16
 801d3e0:	46bd      	mov	sp, r7
 801d3e2:	bd80      	pop	{r7, pc}

0801d3e4 <lv_obj_get_style_flex_track_place>:

static inline lv_flex_align_t lv_obj_get_style_flex_track_place(const lv_obj_t * obj, uint32_t part)
{
 801d3e4:	b580      	push	{r7, lr}
 801d3e6:	b084      	sub	sp, #16
 801d3e8:	af00      	add	r7, sp, #0
 801d3ea:	6078      	str	r0, [r7, #4]
 801d3ec:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_FLEX_TRACK_PLACE);
 801d3ee:	2280      	movs	r2, #128	@ 0x80
 801d3f0:	6839      	ldr	r1, [r7, #0]
 801d3f2:	6878      	ldr	r0, [r7, #4]
 801d3f4:	f7ec f998 	bl	8009728 <lv_obj_get_style_prop>
 801d3f8:	4603      	mov	r3, r0
 801d3fa:	60fb      	str	r3, [r7, #12]
    return (lv_flex_align_t)v.num;
 801d3fc:	68fb      	ldr	r3, [r7, #12]
 801d3fe:	b2db      	uxtb	r3, r3
}
 801d400:	4618      	mov	r0, r3
 801d402:	3710      	adds	r7, #16
 801d404:	46bd      	mov	sp, r7
 801d406:	bd80      	pop	{r7, pc}

0801d408 <lv_obj_get_style_flex_grow>:

static inline uint8_t lv_obj_get_style_flex_grow(const lv_obj_t * obj, uint32_t part)
{
 801d408:	b580      	push	{r7, lr}
 801d40a:	b084      	sub	sp, #16
 801d40c:	af00      	add	r7, sp, #0
 801d40e:	6078      	str	r0, [r7, #4]
 801d410:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_FLEX_GROW);
 801d412:	2281      	movs	r2, #129	@ 0x81
 801d414:	6839      	ldr	r1, [r7, #0]
 801d416:	6878      	ldr	r0, [r7, #4]
 801d418:	f7ec f986 	bl	8009728 <lv_obj_get_style_prop>
 801d41c:	4603      	mov	r3, r0
 801d41e:	60fb      	str	r3, [r7, #12]
    return (uint8_t)v.num;
 801d420:	68fb      	ldr	r3, [r7, #12]
 801d422:	b2db      	uxtb	r3, r3
}
 801d424:	4618      	mov	r0, r3
 801d426:	3710      	adds	r7, #16
 801d428:	46bd      	mov	sp, r7
 801d42a:	bd80      	pop	{r7, pc}

0801d42c <lv_obj_get_style_space_left>:
    lv_obj_set_style_transform_scale_x(obj, value, selector);
    lv_obj_set_style_transform_scale_y(obj, value, selector);
}

static inline int32_t lv_obj_get_style_space_left(const lv_obj_t * obj, uint32_t part)
{
 801d42c:	b580      	push	{r7, lr}
 801d42e:	b086      	sub	sp, #24
 801d430:	af00      	add	r7, sp, #0
 801d432:	6078      	str	r0, [r7, #4]
 801d434:	6039      	str	r1, [r7, #0]
    int32_t padding = lv_obj_get_style_pad_left(obj, part);
 801d436:	6839      	ldr	r1, [r7, #0]
 801d438:	6878      	ldr	r0, [r7, #4]
 801d43a:	f7ff fef1 	bl	801d220 <lv_obj_get_style_pad_left>
 801d43e:	6178      	str	r0, [r7, #20]
    int32_t border_width = lv_obj_get_style_border_width(obj, part);
 801d440:	6839      	ldr	r1, [r7, #0]
 801d442:	6878      	ldr	r0, [r7, #4]
 801d444:	f7ff ff63 	bl	801d30e <lv_obj_get_style_border_width>
 801d448:	6138      	str	r0, [r7, #16]
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
 801d44a:	6839      	ldr	r1, [r7, #0]
 801d44c:	6878      	ldr	r0, [r7, #4]
 801d44e:	f7ff ff6f 	bl	801d330 <lv_obj_get_style_border_side>
 801d452:	4603      	mov	r3, r0
 801d454:	73fb      	strb	r3, [r7, #15]
    return (border_side & LV_BORDER_SIDE_LEFT) ? padding + border_width : padding;
 801d456:	7bfb      	ldrb	r3, [r7, #15]
 801d458:	f003 0304 	and.w	r3, r3, #4
 801d45c:	2b00      	cmp	r3, #0
 801d45e:	d003      	beq.n	801d468 <lv_obj_get_style_space_left+0x3c>
 801d460:	697a      	ldr	r2, [r7, #20]
 801d462:	693b      	ldr	r3, [r7, #16]
 801d464:	4413      	add	r3, r2
 801d466:	e000      	b.n	801d46a <lv_obj_get_style_space_left+0x3e>
 801d468:	697b      	ldr	r3, [r7, #20]
}
 801d46a:	4618      	mov	r0, r3
 801d46c:	3718      	adds	r7, #24
 801d46e:	46bd      	mov	sp, r7
 801d470:	bd80      	pop	{r7, pc}

0801d472 <lv_obj_get_style_space_top>:
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
    return (border_side & LV_BORDER_SIDE_RIGHT) ? padding + border_width : padding;
}

static inline int32_t lv_obj_get_style_space_top(const lv_obj_t * obj, uint32_t part)
{
 801d472:	b580      	push	{r7, lr}
 801d474:	b086      	sub	sp, #24
 801d476:	af00      	add	r7, sp, #0
 801d478:	6078      	str	r0, [r7, #4]
 801d47a:	6039      	str	r1, [r7, #0]
    int32_t padding = lv_obj_get_style_pad_top(obj, part);
 801d47c:	6839      	ldr	r1, [r7, #0]
 801d47e:	6878      	ldr	r0, [r7, #4]
 801d480:	f7ff febd 	bl	801d1fe <lv_obj_get_style_pad_top>
 801d484:	6178      	str	r0, [r7, #20]
    int32_t border_width = lv_obj_get_style_border_width(obj, part);
 801d486:	6839      	ldr	r1, [r7, #0]
 801d488:	6878      	ldr	r0, [r7, #4]
 801d48a:	f7ff ff40 	bl	801d30e <lv_obj_get_style_border_width>
 801d48e:	6138      	str	r0, [r7, #16]
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
 801d490:	6839      	ldr	r1, [r7, #0]
 801d492:	6878      	ldr	r0, [r7, #4]
 801d494:	f7ff ff4c 	bl	801d330 <lv_obj_get_style_border_side>
 801d498:	4603      	mov	r3, r0
 801d49a:	73fb      	strb	r3, [r7, #15]
    return (border_side & LV_BORDER_SIDE_TOP) ? padding + border_width : padding;
 801d49c:	7bfb      	ldrb	r3, [r7, #15]
 801d49e:	f003 0302 	and.w	r3, r3, #2
 801d4a2:	2b00      	cmp	r3, #0
 801d4a4:	d003      	beq.n	801d4ae <lv_obj_get_style_space_top+0x3c>
 801d4a6:	697a      	ldr	r2, [r7, #20]
 801d4a8:	693b      	ldr	r3, [r7, #16]
 801d4aa:	4413      	add	r3, r2
 801d4ac:	e000      	b.n	801d4b0 <lv_obj_get_style_space_top+0x3e>
 801d4ae:	697b      	ldr	r3, [r7, #20]
}
 801d4b0:	4618      	mov	r0, r3
 801d4b2:	3718      	adds	r7, #24
 801d4b4:	46bd      	mov	sp, r7
 801d4b6:	bd80      	pop	{r7, pc}

0801d4b8 <lv_flex_init>:
/*=====================
 * Setter functions
 *====================*/

void lv_flex_init(void)
{
 801d4b8:	b480      	push	{r7}
 801d4ba:	af00      	add	r7, sp, #0
    layout_list_def[LV_LAYOUT_FLEX].cb = flex_update;
 801d4bc:	4b07      	ldr	r3, [pc, #28]	@ (801d4dc <lv_flex_init+0x24>)
 801d4be:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801d4c0:	3308      	adds	r3, #8
 801d4c2:	4a07      	ldr	r2, [pc, #28]	@ (801d4e0 <lv_flex_init+0x28>)
 801d4c4:	601a      	str	r2, [r3, #0]
    layout_list_def[LV_LAYOUT_FLEX].user_data = NULL;
 801d4c6:	4b05      	ldr	r3, [pc, #20]	@ (801d4dc <lv_flex_init+0x24>)
 801d4c8:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801d4ca:	3308      	adds	r3, #8
 801d4cc:	2200      	movs	r2, #0
 801d4ce:	605a      	str	r2, [r3, #4]

}
 801d4d0:	bf00      	nop
 801d4d2:	46bd      	mov	sp, r7
 801d4d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d4d8:	4770      	bx	lr
 801d4da:	bf00      	nop
 801d4dc:	2000009c 	.word	0x2000009c
 801d4e0:	0801d4e5 	.word	0x0801d4e5

0801d4e4 <flex_update>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void flex_update(lv_obj_t * cont, void * user_data)
{
 801d4e4:	b590      	push	{r4, r7, lr}
 801d4e6:	b0a9      	sub	sp, #164	@ 0xa4
 801d4e8:	af06      	add	r7, sp, #24
 801d4ea:	6078      	str	r0, [r7, #4]
 801d4ec:	6039      	str	r1, [r7, #0]
    LV_LOG_INFO("update %p container", (void *)cont);
    LV_UNUSED(user_data);

    flex_t f;
    lv_flex_flow_t flow = lv_obj_get_style_flex_flow(cont, LV_PART_MAIN);
 801d4ee:	2100      	movs	r1, #0
 801d4f0:	6878      	ldr	r0, [r7, #4]
 801d4f2:	f7ff ff41 	bl	801d378 <lv_obj_get_style_flex_flow>
 801d4f6:	4603      	mov	r3, r0
 801d4f8:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
    f.row = flow & _LV_FLEX_COLUMN ? 0 : 1;
 801d4fc:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 801d500:	f003 0301 	and.w	r3, r3, #1
 801d504:	2b00      	cmp	r3, #0
 801d506:	bf0c      	ite	eq
 801d508:	2301      	moveq	r3, #1
 801d50a:	2300      	movne	r3, #0
 801d50c:	b2da      	uxtb	r2, r3
 801d50e:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d512:	f362 0300 	bfi	r3, r2, #0, #1
 801d516:	f887 3053 	strb.w	r3, [r7, #83]	@ 0x53
    f.wrap = flow & _LV_FLEX_WRAP ? 1 : 0;
 801d51a:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 801d51e:	109b      	asrs	r3, r3, #2
 801d520:	f003 0301 	and.w	r3, r3, #1
 801d524:	b2da      	uxtb	r2, r3
 801d526:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d52a:	f362 0341 	bfi	r3, r2, #1, #1
 801d52e:	f887 3053 	strb.w	r3, [r7, #83]	@ 0x53
    f.rev = flow & _LV_FLEX_REVERSE ? 1 : 0;
 801d532:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 801d536:	10db      	asrs	r3, r3, #3
 801d538:	f003 0301 	and.w	r3, r3, #1
 801d53c:	b2da      	uxtb	r2, r3
 801d53e:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d542:	f362 0382 	bfi	r3, r2, #2, #1
 801d546:	f887 3053 	strb.w	r3, [r7, #83]	@ 0x53
    f.main_place = lv_obj_get_style_flex_main_place(cont, LV_PART_MAIN);
 801d54a:	2100      	movs	r1, #0
 801d54c:	6878      	ldr	r0, [r7, #4]
 801d54e:	f7ff ff25 	bl	801d39c <lv_obj_get_style_flex_main_place>
 801d552:	4603      	mov	r3, r0
 801d554:	f887 3050 	strb.w	r3, [r7, #80]	@ 0x50
    f.cross_place = lv_obj_get_style_flex_cross_place(cont, LV_PART_MAIN);
 801d558:	2100      	movs	r1, #0
 801d55a:	6878      	ldr	r0, [r7, #4]
 801d55c:	f7ff ff30 	bl	801d3c0 <lv_obj_get_style_flex_cross_place>
 801d560:	4603      	mov	r3, r0
 801d562:	f887 3051 	strb.w	r3, [r7, #81]	@ 0x51
    f.track_place = lv_obj_get_style_flex_track_place(cont, LV_PART_MAIN);
 801d566:	2100      	movs	r1, #0
 801d568:	6878      	ldr	r0, [r7, #4]
 801d56a:	f7ff ff3b 	bl	801d3e4 <lv_obj_get_style_flex_track_place>
 801d56e:	4603      	mov	r3, r0
 801d570:	f887 3052 	strb.w	r3, [r7, #82]	@ 0x52

    bool rtl = lv_obj_get_style_base_dir(cont, LV_PART_MAIN) == LV_BASE_DIR_RTL;
 801d574:	2100      	movs	r1, #0
 801d576:	6878      	ldr	r0, [r7, #4]
 801d578:	f7ff feec 	bl	801d354 <lv_obj_get_style_base_dir>
 801d57c:	4603      	mov	r3, r0
 801d57e:	2b01      	cmp	r3, #1
 801d580:	bf0c      	ite	eq
 801d582:	2301      	moveq	r3, #1
 801d584:	2300      	movne	r3, #0
 801d586:	f887 3076 	strb.w	r3, [r7, #118]	@ 0x76
    int32_t track_gap = !f.row ? lv_obj_get_style_pad_column(cont, LV_PART_MAIN) : lv_obj_get_style_pad_row(cont,
 801d58a:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d58e:	f003 0301 	and.w	r3, r3, #1
 801d592:	b2db      	uxtb	r3, r3
 801d594:	2b00      	cmp	r3, #0
 801d596:	d105      	bne.n	801d5a4 <flex_update+0xc0>
 801d598:	2100      	movs	r1, #0
 801d59a:	6878      	ldr	r0, [r7, #4]
 801d59c:	f7ff fe62 	bl	801d264 <lv_obj_get_style_pad_column>
 801d5a0:	4603      	mov	r3, r0
 801d5a2:	e004      	b.n	801d5ae <flex_update+0xca>
 801d5a4:	2100      	movs	r1, #0
 801d5a6:	6878      	ldr	r0, [r7, #4]
 801d5a8:	f7ff fe4b 	bl	801d242 <lv_obj_get_style_pad_row>
 801d5ac:	4603      	mov	r3, r0
 801d5ae:	673b      	str	r3, [r7, #112]	@ 0x70
                                                                                                            LV_PART_MAIN);
    int32_t item_gap = f.row ? lv_obj_get_style_pad_column(cont, LV_PART_MAIN) : lv_obj_get_style_pad_row(cont,
 801d5b0:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d5b4:	f003 0301 	and.w	r3, r3, #1
 801d5b8:	b2db      	uxtb	r3, r3
 801d5ba:	2b00      	cmp	r3, #0
 801d5bc:	d005      	beq.n	801d5ca <flex_update+0xe6>
 801d5be:	2100      	movs	r1, #0
 801d5c0:	6878      	ldr	r0, [r7, #4]
 801d5c2:	f7ff fe4f 	bl	801d264 <lv_obj_get_style_pad_column>
 801d5c6:	4603      	mov	r3, r0
 801d5c8:	e004      	b.n	801d5d4 <flex_update+0xf0>
 801d5ca:	2100      	movs	r1, #0
 801d5cc:	6878      	ldr	r0, [r7, #4]
 801d5ce:	f7ff fe38 	bl	801d242 <lv_obj_get_style_pad_row>
 801d5d2:	4603      	mov	r3, r0
 801d5d4:	66fb      	str	r3, [r7, #108]	@ 0x6c
                                                                                                          LV_PART_MAIN);
    int32_t max_main_size = (f.row ? lv_obj_get_content_width(cont) : lv_obj_get_content_height(cont));
 801d5d6:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d5da:	f003 0301 	and.w	r3, r3, #1
 801d5de:	b2db      	uxtb	r3, r3
 801d5e0:	2b00      	cmp	r3, #0
 801d5e2:	d004      	beq.n	801d5ee <flex_update+0x10a>
 801d5e4:	6878      	ldr	r0, [r7, #4]
 801d5e6:	f7e8 fbbf 	bl	8005d68 <lv_obj_get_content_width>
 801d5ea:	4603      	mov	r3, r0
 801d5ec:	e003      	b.n	801d5f6 <flex_update+0x112>
 801d5ee:	6878      	ldr	r0, [r7, #4]
 801d5f0:	f7e8 fbd4 	bl	8005d9c <lv_obj_get_content_height>
 801d5f4:	4603      	mov	r3, r0
 801d5f6:	66bb      	str	r3, [r7, #104]	@ 0x68
    int32_t abs_y = cont->coords.y1 + lv_obj_get_style_space_top(cont,
 801d5f8:	687b      	ldr	r3, [r7, #4]
 801d5fa:	699c      	ldr	r4, [r3, #24]
 801d5fc:	2100      	movs	r1, #0
 801d5fe:	6878      	ldr	r0, [r7, #4]
 801d600:	f7ff ff37 	bl	801d472 <lv_obj_get_style_space_top>
 801d604:	4603      	mov	r3, r0
 801d606:	441c      	add	r4, r3
                                                                 LV_PART_MAIN) - lv_obj_get_scroll_y(cont);
 801d608:	6878      	ldr	r0, [r7, #4]
 801d60a:	f7e9 ff2b 	bl	8007464 <lv_obj_get_scroll_y>
 801d60e:	4603      	mov	r3, r0
 801d610:	1ae3      	subs	r3, r4, r3
    int32_t abs_y = cont->coords.y1 + lv_obj_get_style_space_top(cont,
 801d612:	64fb      	str	r3, [r7, #76]	@ 0x4c
    int32_t abs_x = cont->coords.x1 + lv_obj_get_style_space_left(cont,
 801d614:	687b      	ldr	r3, [r7, #4]
 801d616:	695c      	ldr	r4, [r3, #20]
 801d618:	2100      	movs	r1, #0
 801d61a:	6878      	ldr	r0, [r7, #4]
 801d61c:	f7ff ff06 	bl	801d42c <lv_obj_get_style_space_left>
 801d620:	4603      	mov	r3, r0
 801d622:	441c      	add	r4, r3
                                                                  LV_PART_MAIN) - lv_obj_get_scroll_x(cont);
 801d624:	6878      	ldr	r0, [r7, #4]
 801d626:	f7e9 ff09 	bl	800743c <lv_obj_get_scroll_x>
 801d62a:	4603      	mov	r3, r0
 801d62c:	1ae3      	subs	r3, r4, r3
    int32_t abs_x = cont->coords.x1 + lv_obj_get_style_space_left(cont,
 801d62e:	64bb      	str	r3, [r7, #72]	@ 0x48

    lv_flex_align_t track_cross_place = f.track_place;
 801d630:	f897 3052 	ldrb.w	r3, [r7, #82]	@ 0x52
 801d634:	f887 3087 	strb.w	r3, [r7, #135]	@ 0x87
    int32_t * cross_pos = (f.row ? &abs_y : &abs_x);
 801d638:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d63c:	f003 0301 	and.w	r3, r3, #1
 801d640:	b2db      	uxtb	r3, r3
 801d642:	2b00      	cmp	r3, #0
 801d644:	d002      	beq.n	801d64c <flex_update+0x168>
 801d646:	f107 034c 	add.w	r3, r7, #76	@ 0x4c
 801d64a:	e001      	b.n	801d650 <flex_update+0x16c>
 801d64c:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 801d650:	667b      	str	r3, [r7, #100]	@ 0x64

    int32_t w_set = lv_obj_get_style_width(cont, LV_PART_MAIN);
 801d652:	2100      	movs	r1, #0
 801d654:	6878      	ldr	r0, [r7, #4]
 801d656:	f7ff fd4a 	bl	801d0ee <lv_obj_get_style_width>
 801d65a:	6638      	str	r0, [r7, #96]	@ 0x60
    int32_t h_set = lv_obj_get_style_height(cont, LV_PART_MAIN);
 801d65c:	2100      	movs	r1, #0
 801d65e:	6878      	ldr	r0, [r7, #4]
 801d660:	f7ff fd78 	bl	801d154 <lv_obj_get_style_height>
 801d664:	65f8      	str	r0, [r7, #92]	@ 0x5c

    /*Content sized objects should squeeze the gap between the children, therefore any alignment will look like `START`*/
    if((f.row && h_set == LV_SIZE_CONTENT && cont->h_layout == 0) ||
 801d666:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d66a:	f003 0301 	and.w	r3, r3, #1
 801d66e:	b2db      	uxtb	r3, r3
 801d670:	2b00      	cmp	r3, #0
 801d672:	d00b      	beq.n	801d68c <flex_update+0x1a8>
 801d674:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d676:	4aa1      	ldr	r2, [pc, #644]	@ (801d8fc <flex_update+0x418>)
 801d678:	4293      	cmp	r3, r2
 801d67a:	d107      	bne.n	801d68c <flex_update+0x1a8>
 801d67c:	687b      	ldr	r3, [r7, #4]
 801d67e:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 801d682:	f003 0304 	and.w	r3, r3, #4
 801d686:	b2db      	uxtb	r3, r3
 801d688:	2b00      	cmp	r3, #0
 801d68a:	d012      	beq.n	801d6b2 <flex_update+0x1ce>
       (!f.row && w_set == LV_SIZE_CONTENT && cont->w_layout == 0)) {
 801d68c:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d690:	f003 0301 	and.w	r3, r3, #1
 801d694:	b2db      	uxtb	r3, r3
    if((f.row && h_set == LV_SIZE_CONTENT && cont->h_layout == 0) ||
 801d696:	2b00      	cmp	r3, #0
 801d698:	d10e      	bne.n	801d6b8 <flex_update+0x1d4>
       (!f.row && w_set == LV_SIZE_CONTENT && cont->w_layout == 0)) {
 801d69a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d69c:	4a97      	ldr	r2, [pc, #604]	@ (801d8fc <flex_update+0x418>)
 801d69e:	4293      	cmp	r3, r2
 801d6a0:	d10a      	bne.n	801d6b8 <flex_update+0x1d4>
 801d6a2:	687b      	ldr	r3, [r7, #4]
 801d6a4:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 801d6a8:	f003 0308 	and.w	r3, r3, #8
 801d6ac:	b2db      	uxtb	r3, r3
 801d6ae:	2b00      	cmp	r3, #0
 801d6b0:	d102      	bne.n	801d6b8 <flex_update+0x1d4>
        track_cross_place = LV_FLEX_ALIGN_START;
 801d6b2:	2300      	movs	r3, #0
 801d6b4:	f887 3087 	strb.w	r3, [r7, #135]	@ 0x87
    }

    if(rtl && !f.row) {
 801d6b8:	f897 3076 	ldrb.w	r3, [r7, #118]	@ 0x76
 801d6bc:	2b00      	cmp	r3, #0
 801d6be:	d015      	beq.n	801d6ec <flex_update+0x208>
 801d6c0:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d6c4:	f003 0301 	and.w	r3, r3, #1
 801d6c8:	b2db      	uxtb	r3, r3
 801d6ca:	2b00      	cmp	r3, #0
 801d6cc:	d10e      	bne.n	801d6ec <flex_update+0x208>
        if(track_cross_place == LV_FLEX_ALIGN_START) track_cross_place = LV_FLEX_ALIGN_END;
 801d6ce:	f897 3087 	ldrb.w	r3, [r7, #135]	@ 0x87
 801d6d2:	2b00      	cmp	r3, #0
 801d6d4:	d103      	bne.n	801d6de <flex_update+0x1fa>
 801d6d6:	2301      	movs	r3, #1
 801d6d8:	f887 3087 	strb.w	r3, [r7, #135]	@ 0x87
 801d6dc:	e006      	b.n	801d6ec <flex_update+0x208>
        else if(track_cross_place == LV_FLEX_ALIGN_END) track_cross_place = LV_FLEX_ALIGN_START;
 801d6de:	f897 3087 	ldrb.w	r3, [r7, #135]	@ 0x87
 801d6e2:	2b01      	cmp	r3, #1
 801d6e4:	d102      	bne.n	801d6ec <flex_update+0x208>
 801d6e6:	2300      	movs	r3, #0
 801d6e8:	f887 3087 	strb.w	r3, [r7, #135]	@ 0x87
    }

    int32_t total_track_cross_size = 0;
 801d6ec:	2300      	movs	r3, #0
 801d6ee:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    int32_t gap = 0;
 801d6f2:	2300      	movs	r3, #0
 801d6f4:	647b      	str	r3, [r7, #68]	@ 0x44
    uint32_t track_cnt = 0;
 801d6f6:	2300      	movs	r3, #0
 801d6f8:	67fb      	str	r3, [r7, #124]	@ 0x7c
    int32_t track_first_item;
    int32_t next_track_first_item;

    if(track_cross_place != LV_FLEX_ALIGN_START) {
 801d6fa:	f897 3087 	ldrb.w	r3, [r7, #135]	@ 0x87
 801d6fe:	2b00      	cmp	r3, #0
 801d700:	d060      	beq.n	801d7c4 <flex_update+0x2e0>
        track_first_item = f.rev ? cont->spec_attr->child_cnt - 1 : 0;
 801d702:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d706:	f003 0304 	and.w	r3, r3, #4
 801d70a:	b2db      	uxtb	r3, r3
 801d70c:	2b00      	cmp	r3, #0
 801d70e:	d004      	beq.n	801d71a <flex_update+0x236>
 801d710:	687b      	ldr	r3, [r7, #4]
 801d712:	689b      	ldr	r3, [r3, #8]
 801d714:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801d716:	3b01      	subs	r3, #1
 801d718:	e000      	b.n	801d71c <flex_update+0x238>
 801d71a:	2300      	movs	r3, #0
 801d71c:	67bb      	str	r3, [r7, #120]	@ 0x78
        track_t t;
        while(track_first_item < (int32_t)cont->spec_attr->child_cnt && track_first_item >= 0) {
 801d71e:	e01f      	b.n	801d760 <flex_update+0x27c>
            /*Search the first item of the next row*/
            t.grow_dsc_calc = 0;
 801d720:	f897 3040 	ldrb.w	r3, [r7, #64]	@ 0x40
 801d724:	f36f 0300 	bfc	r3, #0, #1
 801d728:	f887 3040 	strb.w	r3, [r7, #64]	@ 0x40
            next_track_first_item = find_track_end(cont, &f, track_first_item, max_main_size, item_gap, &t);
 801d72c:	f107 0150 	add.w	r1, r7, #80	@ 0x50
 801d730:	f107 0328 	add.w	r3, r7, #40	@ 0x28
 801d734:	9301      	str	r3, [sp, #4]
 801d736:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801d738:	9300      	str	r3, [sp, #0]
 801d73a:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801d73c:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 801d73e:	6878      	ldr	r0, [r7, #4]
 801d740:	f000 f8de 	bl	801d900 <find_track_end>
 801d744:	65b8      	str	r0, [r7, #88]	@ 0x58
            total_track_cross_size += t.track_cross_size + track_gap;
 801d746:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801d748:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801d74a:	4413      	add	r3, r2
 801d74c:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801d750:	4413      	add	r3, r2
 801d752:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
            track_cnt++;
 801d756:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801d758:	3301      	adds	r3, #1
 801d75a:	67fb      	str	r3, [r7, #124]	@ 0x7c
            track_first_item = next_track_first_item;
 801d75c:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d75e:	67bb      	str	r3, [r7, #120]	@ 0x78
        while(track_first_item < (int32_t)cont->spec_attr->child_cnt && track_first_item >= 0) {
 801d760:	687b      	ldr	r3, [r7, #4]
 801d762:	689b      	ldr	r3, [r3, #8]
 801d764:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801d766:	461a      	mov	r2, r3
 801d768:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801d76a:	4293      	cmp	r3, r2
 801d76c:	da02      	bge.n	801d774 <flex_update+0x290>
 801d76e:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801d770:	2b00      	cmp	r3, #0
 801d772:	dad5      	bge.n	801d720 <flex_update+0x23c>
        }

        if(track_cnt) total_track_cross_size -= track_gap;   /*No gap after the last track*/
 801d774:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801d776:	2b00      	cmp	r3, #0
 801d778:	d005      	beq.n	801d786 <flex_update+0x2a2>
 801d77a:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801d77e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801d780:	1ad3      	subs	r3, r2, r3
 801d782:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

        /*Place the tracks to get the start position*/
        int32_t max_cross_size = (f.row ? lv_obj_get_content_height(cont) : lv_obj_get_content_width(cont));
 801d786:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d78a:	f003 0301 	and.w	r3, r3, #1
 801d78e:	b2db      	uxtb	r3, r3
 801d790:	2b00      	cmp	r3, #0
 801d792:	d004      	beq.n	801d79e <flex_update+0x2ba>
 801d794:	6878      	ldr	r0, [r7, #4]
 801d796:	f7e8 fb01 	bl	8005d9c <lv_obj_get_content_height>
 801d79a:	4603      	mov	r3, r0
 801d79c:	e003      	b.n	801d7a6 <flex_update+0x2c2>
 801d79e:	6878      	ldr	r0, [r7, #4]
 801d7a0:	f7e8 fae2 	bl	8005d68 <lv_obj_get_content_width>
 801d7a4:	4603      	mov	r3, r0
 801d7a6:	657b      	str	r3, [r7, #84]	@ 0x54
        place_content(track_cross_place, max_cross_size, total_track_cross_size, track_cnt, cross_pos, &gap);
 801d7a8:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801d7aa:	f897 0087 	ldrb.w	r0, [r7, #135]	@ 0x87
 801d7ae:	f107 0344 	add.w	r3, r7, #68	@ 0x44
 801d7b2:	9301      	str	r3, [sp, #4]
 801d7b4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d7b6:	9300      	str	r3, [sp, #0]
 801d7b8:	4613      	mov	r3, r2
 801d7ba:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801d7be:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 801d7c0:	f000 fe12 	bl	801e3e8 <place_content>
    }

    track_first_item = f.rev ? cont->spec_attr->child_cnt - 1 : 0;
 801d7c4:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d7c8:	f003 0304 	and.w	r3, r3, #4
 801d7cc:	b2db      	uxtb	r3, r3
 801d7ce:	2b00      	cmp	r3, #0
 801d7d0:	d004      	beq.n	801d7dc <flex_update+0x2f8>
 801d7d2:	687b      	ldr	r3, [r7, #4]
 801d7d4:	689b      	ldr	r3, [r3, #8]
 801d7d6:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801d7d8:	3b01      	subs	r3, #1
 801d7da:	e000      	b.n	801d7de <flex_update+0x2fa>
 801d7dc:	2300      	movs	r3, #0
 801d7de:	67bb      	str	r3, [r7, #120]	@ 0x78

    if(rtl && !f.row) {
 801d7e0:	f897 3076 	ldrb.w	r3, [r7, #118]	@ 0x76
 801d7e4:	2b00      	cmp	r3, #0
 801d7e6:	d06b      	beq.n	801d8c0 <flex_update+0x3dc>
 801d7e8:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d7ec:	f003 0301 	and.w	r3, r3, #1
 801d7f0:	b2db      	uxtb	r3, r3
 801d7f2:	2b00      	cmp	r3, #0
 801d7f4:	d164      	bne.n	801d8c0 <flex_update+0x3dc>
        *cross_pos += total_track_cross_size;
 801d7f6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d7f8:	681a      	ldr	r2, [r3, #0]
 801d7fa:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 801d7fe:	441a      	add	r2, r3
 801d800:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d802:	601a      	str	r2, [r3, #0]
    }

    while(track_first_item < (int32_t)cont->spec_attr->child_cnt && track_first_item >= 0) {
 801d804:	e05c      	b.n	801d8c0 <flex_update+0x3dc>
        track_t t;
        t.grow_dsc_calc = 1;
 801d806:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 801d80a:	f043 0301 	orr.w	r3, r3, #1
 801d80e:	f887 3024 	strb.w	r3, [r7, #36]	@ 0x24
        /*Search the first item of the next row*/
        next_track_first_item = find_track_end(cont, &f, track_first_item, max_main_size, item_gap, &t);
 801d812:	f107 0150 	add.w	r1, r7, #80	@ 0x50
 801d816:	f107 030c 	add.w	r3, r7, #12
 801d81a:	9301      	str	r3, [sp, #4]
 801d81c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801d81e:	9300      	str	r3, [sp, #0]
 801d820:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801d822:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 801d824:	6878      	ldr	r0, [r7, #4]
 801d826:	f000 f86b 	bl	801d900 <find_track_end>
 801d82a:	65b8      	str	r0, [r7, #88]	@ 0x58

        if(rtl && !f.row) {
 801d82c:	f897 3076 	ldrb.w	r3, [r7, #118]	@ 0x76
 801d830:	2b00      	cmp	r3, #0
 801d832:	d00c      	beq.n	801d84e <flex_update+0x36a>
 801d834:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d838:	f003 0301 	and.w	r3, r3, #1
 801d83c:	b2db      	uxtb	r3, r3
 801d83e:	2b00      	cmp	r3, #0
 801d840:	d105      	bne.n	801d84e <flex_update+0x36a>
            *cross_pos -= t.track_cross_size;
 801d842:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d844:	681a      	ldr	r2, [r3, #0]
 801d846:	68fb      	ldr	r3, [r7, #12]
 801d848:	1ad2      	subs	r2, r2, r3
 801d84a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d84c:	601a      	str	r2, [r3, #0]
        }
        children_repos(cont, &f, track_first_item, next_track_first_item, abs_x, abs_y, max_main_size, item_gap, &t);
 801d84e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801d850:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801d852:	f107 0050 	add.w	r0, r7, #80	@ 0x50
 801d856:	f107 010c 	add.w	r1, r7, #12
 801d85a:	9104      	str	r1, [sp, #16]
 801d85c:	6ef9      	ldr	r1, [r7, #108]	@ 0x6c
 801d85e:	9103      	str	r1, [sp, #12]
 801d860:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 801d862:	9102      	str	r1, [sp, #8]
 801d864:	9201      	str	r2, [sp, #4]
 801d866:	9300      	str	r3, [sp, #0]
 801d868:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d86a:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 801d86c:	4601      	mov	r1, r0
 801d86e:	6878      	ldr	r0, [r7, #4]
 801d870:	f000 f9fc 	bl	801dc6c <children_repos>
        track_first_item = next_track_first_item;
 801d874:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801d876:	67bb      	str	r3, [r7, #120]	@ 0x78
        lv_free(t.grow_dsc);
 801d878:	69fb      	ldr	r3, [r7, #28]
 801d87a:	4618      	mov	r0, r3
 801d87c:	f008 fadc 	bl	8025e38 <lv_free>
        t.grow_dsc = NULL;
 801d880:	2300      	movs	r3, #0
 801d882:	61fb      	str	r3, [r7, #28]
        if(rtl && !f.row) {
 801d884:	f897 3076 	ldrb.w	r3, [r7, #118]	@ 0x76
 801d888:	2b00      	cmp	r3, #0
 801d88a:	d00f      	beq.n	801d8ac <flex_update+0x3c8>
 801d88c:	f897 3053 	ldrb.w	r3, [r7, #83]	@ 0x53
 801d890:	f003 0301 	and.w	r3, r3, #1
 801d894:	b2db      	uxtb	r3, r3
 801d896:	2b00      	cmp	r3, #0
 801d898:	d108      	bne.n	801d8ac <flex_update+0x3c8>
            *cross_pos -= gap + track_gap;
 801d89a:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d89c:	681a      	ldr	r2, [r3, #0]
 801d89e:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 801d8a0:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801d8a2:	440b      	add	r3, r1
 801d8a4:	1ad2      	subs	r2, r2, r3
 801d8a6:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d8a8:	601a      	str	r2, [r3, #0]
 801d8aa:	e009      	b.n	801d8c0 <flex_update+0x3dc>
        }
        else {
            *cross_pos += t.track_cross_size + gap + track_gap;
 801d8ac:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d8ae:	681a      	ldr	r2, [r3, #0]
 801d8b0:	68f9      	ldr	r1, [r7, #12]
 801d8b2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d8b4:	4419      	add	r1, r3
 801d8b6:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801d8b8:	440b      	add	r3, r1
 801d8ba:	441a      	add	r2, r3
 801d8bc:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801d8be:	601a      	str	r2, [r3, #0]
    while(track_first_item < (int32_t)cont->spec_attr->child_cnt && track_first_item >= 0) {
 801d8c0:	687b      	ldr	r3, [r7, #4]
 801d8c2:	689b      	ldr	r3, [r3, #8]
 801d8c4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801d8c6:	461a      	mov	r2, r3
 801d8c8:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801d8ca:	4293      	cmp	r3, r2
 801d8cc:	da02      	bge.n	801d8d4 <flex_update+0x3f0>
 801d8ce:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801d8d0:	2b00      	cmp	r3, #0
 801d8d2:	da98      	bge.n	801d806 <flex_update+0x322>
        }
    }
    LV_ASSERT_MEM_INTEGRITY();

    if(w_set == LV_SIZE_CONTENT || h_set == LV_SIZE_CONTENT) {
 801d8d4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801d8d6:	4a09      	ldr	r2, [pc, #36]	@ (801d8fc <flex_update+0x418>)
 801d8d8:	4293      	cmp	r3, r2
 801d8da:	d003      	beq.n	801d8e4 <flex_update+0x400>
 801d8dc:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801d8de:	4a07      	ldr	r2, [pc, #28]	@ (801d8fc <flex_update+0x418>)
 801d8e0:	4293      	cmp	r3, r2
 801d8e2:	d102      	bne.n	801d8ea <flex_update+0x406>
        lv_obj_refr_size(cont);
 801d8e4:	6878      	ldr	r0, [r7, #4]
 801d8e6:	f7e7 ff97 	bl	8005818 <lv_obj_refr_size>
    }

    lv_obj_send_event(cont, LV_EVENT_LAYOUT_CHANGED, NULL);
 801d8ea:	2200      	movs	r2, #0
 801d8ec:	212d      	movs	r1, #45	@ 0x2d
 801d8ee:	6878      	ldr	r0, [r7, #4]
 801d8f0:	f7e7 fa90 	bl	8004e14 <lv_obj_send_event>

    LV_TRACE_LAYOUT("finished");
}
 801d8f4:	bf00      	nop
 801d8f6:	378c      	adds	r7, #140	@ 0x8c
 801d8f8:	46bd      	mov	sp, r7
 801d8fa:	bd90      	pop	{r4, r7, pc}
 801d8fc:	200007d1 	.word	0x200007d1

0801d900 <find_track_end>:
/**
 * Find the last item of a track
 */
static int32_t find_track_end(lv_obj_t * cont, flex_t * f, int32_t item_start_id, int32_t max_main_size,
                              int32_t item_gap, track_t * t)
{
 801d900:	b580      	push	{r7, lr}
 801d902:	b08e      	sub	sp, #56	@ 0x38
 801d904:	af00      	add	r7, sp, #0
 801d906:	60f8      	str	r0, [r7, #12]
 801d908:	60b9      	str	r1, [r7, #8]
 801d90a:	607a      	str	r2, [r7, #4]
 801d90c:	603b      	str	r3, [r7, #0]
    int32_t w_set = lv_obj_get_style_width(cont, LV_PART_MAIN);
 801d90e:	2100      	movs	r1, #0
 801d910:	68f8      	ldr	r0, [r7, #12]
 801d912:	f7ff fbec 	bl	801d0ee <lv_obj_get_style_width>
 801d916:	6338      	str	r0, [r7, #48]	@ 0x30
    int32_t h_set = lv_obj_get_style_height(cont, LV_PART_MAIN);
 801d918:	2100      	movs	r1, #0
 801d91a:	68f8      	ldr	r0, [r7, #12]
 801d91c:	f7ff fc1a 	bl	801d154 <lv_obj_get_style_height>
 801d920:	62f8      	str	r0, [r7, #44]	@ 0x2c

    /*Can't wrap if the size is auto (i.e. the size depends on the children)*/
    if(f->wrap && ((f->row && w_set == LV_SIZE_CONTENT) || (!f->row && h_set == LV_SIZE_CONTENT))) {
 801d922:	68bb      	ldr	r3, [r7, #8]
 801d924:	78db      	ldrb	r3, [r3, #3]
 801d926:	f003 0302 	and.w	r3, r3, #2
 801d92a:	b2db      	uxtb	r3, r3
 801d92c:	2b00      	cmp	r3, #0
 801d92e:	d01a      	beq.n	801d966 <find_track_end+0x66>
 801d930:	68bb      	ldr	r3, [r7, #8]
 801d932:	78db      	ldrb	r3, [r3, #3]
 801d934:	f003 0301 	and.w	r3, r3, #1
 801d938:	b2db      	uxtb	r3, r3
 801d93a:	2b00      	cmp	r3, #0
 801d93c:	d003      	beq.n	801d946 <find_track_end+0x46>
 801d93e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801d940:	4aa0      	ldr	r2, [pc, #640]	@ (801dbc4 <find_track_end+0x2c4>)
 801d942:	4293      	cmp	r3, r2
 801d944:	d00a      	beq.n	801d95c <find_track_end+0x5c>
 801d946:	68bb      	ldr	r3, [r7, #8]
 801d948:	78db      	ldrb	r3, [r3, #3]
 801d94a:	f003 0301 	and.w	r3, r3, #1
 801d94e:	b2db      	uxtb	r3, r3
 801d950:	2b00      	cmp	r3, #0
 801d952:	d108      	bne.n	801d966 <find_track_end+0x66>
 801d954:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801d956:	4a9b      	ldr	r2, [pc, #620]	@ (801dbc4 <find_track_end+0x2c4>)
 801d958:	4293      	cmp	r3, r2
 801d95a:	d104      	bne.n	801d966 <find_track_end+0x66>
        f->wrap = false;
 801d95c:	68ba      	ldr	r2, [r7, #8]
 801d95e:	78d3      	ldrb	r3, [r2, #3]
 801d960:	f36f 0341 	bfc	r3, #1, #1
 801d964:	70d3      	strb	r3, [r2, #3]
    }
    int32_t(*get_main_size)(const lv_obj_t *) = (f->row ? lv_obj_get_width_with_margin : lv_obj_get_height_with_margin);
 801d966:	68bb      	ldr	r3, [r7, #8]
 801d968:	78db      	ldrb	r3, [r3, #3]
 801d96a:	f003 0301 	and.w	r3, r3, #1
 801d96e:	b2db      	uxtb	r3, r3
 801d970:	2b00      	cmp	r3, #0
 801d972:	d001      	beq.n	801d978 <find_track_end+0x78>
 801d974:	4b94      	ldr	r3, [pc, #592]	@ (801dbc8 <find_track_end+0x2c8>)
 801d976:	e000      	b.n	801d97a <find_track_end+0x7a>
 801d978:	4b94      	ldr	r3, [pc, #592]	@ (801dbcc <find_track_end+0x2cc>)
 801d97a:	62bb      	str	r3, [r7, #40]	@ 0x28
    int32_t(*get_cross_size)(const lv_obj_t *) = (!f->row ? lv_obj_get_width_with_margin :
 801d97c:	68bb      	ldr	r3, [r7, #8]
 801d97e:	78db      	ldrb	r3, [r3, #3]
 801d980:	f003 0301 	and.w	r3, r3, #1
 801d984:	b2db      	uxtb	r3, r3
 801d986:	2b00      	cmp	r3, #0
 801d988:	d101      	bne.n	801d98e <find_track_end+0x8e>
 801d98a:	4b8f      	ldr	r3, [pc, #572]	@ (801dbc8 <find_track_end+0x2c8>)
 801d98c:	e000      	b.n	801d990 <find_track_end+0x90>
 801d98e:	4b8f      	ldr	r3, [pc, #572]	@ (801dbcc <find_track_end+0x2cc>)
 801d990:	627b      	str	r3, [r7, #36]	@ 0x24
                                                  lv_obj_get_height_with_margin);

    t->track_main_size = 0;
 801d992:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d994:	2200      	movs	r2, #0
 801d996:	605a      	str	r2, [r3, #4]
    t->track_fix_main_size = 0;
 801d998:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d99a:	2200      	movs	r2, #0
 801d99c:	609a      	str	r2, [r3, #8]
    t->grow_item_cnt = 0;
 801d99e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d9a0:	2200      	movs	r2, #0
 801d9a2:	615a      	str	r2, [r3, #20]
    t->track_cross_size = 0;
 801d9a4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d9a6:	2200      	movs	r2, #0
 801d9a8:	601a      	str	r2, [r3, #0]
    t->item_cnt = 0;
 801d9aa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d9ac:	2200      	movs	r2, #0
 801d9ae:	60da      	str	r2, [r3, #12]
    t->grow_dsc = NULL;
 801d9b0:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801d9b2:	2200      	movs	r2, #0
 801d9b4:	611a      	str	r2, [r3, #16]

    int32_t item_id = item_start_id;
 801d9b6:	687b      	ldr	r3, [r7, #4]
 801d9b8:	617b      	str	r3, [r7, #20]

    lv_obj_t * item = lv_obj_get_child(cont, item_id);
 801d9ba:	697b      	ldr	r3, [r7, #20]
 801d9bc:	4619      	mov	r1, r3
 801d9be:	68f8      	ldr	r0, [r7, #12]
 801d9c0:	f7ed fa49 	bl	800ae56 <lv_obj_get_child>
 801d9c4:	6378      	str	r0, [r7, #52]	@ 0x34
    while(item) {
 801d9c6:	e0f3      	b.n	801dbb0 <find_track_end+0x2b0>
        if(item_id != item_start_id && lv_obj_has_flag(item, LV_OBJ_FLAG_FLEX_IN_NEW_TRACK)) break;
 801d9c8:	697b      	ldr	r3, [r7, #20]
 801d9ca:	687a      	ldr	r2, [r7, #4]
 801d9cc:	429a      	cmp	r2, r3
 801d9ce:	d008      	beq.n	801d9e2 <find_track_end+0xe2>
 801d9d0:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 801d9d4:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801d9d6:	f7e5 f9ba 	bl	8002d4e <lv_obj_has_flag>
 801d9da:	4603      	mov	r3, r0
 801d9dc:	2b00      	cmp	r3, #0
 801d9de:	f040 80ec 	bne.w	801dbba <find_track_end+0x2ba>

        if(!lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) {
 801d9e2:	497b      	ldr	r1, [pc, #492]	@ (801dbd0 <find_track_end+0x2d0>)
 801d9e4:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801d9e6:	f7e5 f9c7 	bl	8002d78 <lv_obj_has_flag_any>
 801d9ea:	4603      	mov	r3, r0
 801d9ec:	f083 0301 	eor.w	r3, r3, #1
 801d9f0:	b2db      	uxtb	r3, r3
 801d9f2:	2b00      	cmp	r3, #0
 801d9f4:	f000 80c5 	beq.w	801db82 <find_track_end+0x282>
            uint8_t grow_value = lv_obj_get_style_flex_grow(item, LV_PART_MAIN);
 801d9f8:	2100      	movs	r1, #0
 801d9fa:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801d9fc:	f7ff fd04 	bl	801d408 <lv_obj_get_style_flex_grow>
 801da00:	4603      	mov	r3, r0
 801da02:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
            if(grow_value) {
 801da06:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 801da0a:	2b00      	cmp	r3, #0
 801da0c:	f000 8089 	beq.w	801db22 <find_track_end+0x222>
                t->grow_item_cnt++;
 801da10:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801da12:	695b      	ldr	r3, [r3, #20]
 801da14:	1c5a      	adds	r2, r3, #1
 801da16:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801da18:	615a      	str	r2, [r3, #20]
                t->track_fix_main_size += item_gap;
 801da1a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801da1c:	689a      	ldr	r2, [r3, #8]
 801da1e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801da20:	441a      	add	r2, r3
 801da22:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801da24:	609a      	str	r2, [r3, #8]
                if(t->grow_dsc_calc) {
 801da26:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801da28:	7e1b      	ldrb	r3, [r3, #24]
 801da2a:	f003 0301 	and.w	r3, r3, #1
 801da2e:	b2db      	uxtb	r3, r3
 801da30:	2b00      	cmp	r3, #0
 801da32:	f000 8090 	beq.w	801db56 <find_track_end+0x256>
                    grow_dsc_t * new_dsc = lv_realloc(t->grow_dsc, sizeof(grow_dsc_t) * (t->grow_item_cnt));
 801da36:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801da38:	6918      	ldr	r0, [r3, #16]
 801da3a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801da3c:	695a      	ldr	r2, [r3, #20]
 801da3e:	4613      	mov	r3, r2
 801da40:	005b      	lsls	r3, r3, #1
 801da42:	4413      	add	r3, r2
 801da44:	00db      	lsls	r3, r3, #3
 801da46:	4619      	mov	r1, r3
 801da48:	f008 fa0e 	bl	8025e68 <lv_realloc>
 801da4c:	61b8      	str	r0, [r7, #24]
                    LV_ASSERT_MALLOC(new_dsc);
 801da4e:	69bb      	ldr	r3, [r7, #24]
 801da50:	2b00      	cmp	r3, #0
 801da52:	d101      	bne.n	801da58 <find_track_end+0x158>
 801da54:	bf00      	nop
 801da56:	e7fd      	b.n	801da54 <find_track_end+0x154>
                    if(new_dsc == NULL) return item_id;
 801da58:	69bb      	ldr	r3, [r7, #24]
 801da5a:	2b00      	cmp	r3, #0
 801da5c:	d101      	bne.n	801da62 <find_track_end+0x162>
 801da5e:	697b      	ldr	r3, [r7, #20]
 801da60:	e0ff      	b.n	801dc62 <find_track_end+0x362>

                    new_dsc[t->grow_item_cnt - 1].item = item;
 801da62:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801da64:	695a      	ldr	r2, [r3, #20]
 801da66:	4613      	mov	r3, r2
 801da68:	005b      	lsls	r3, r3, #1
 801da6a:	4413      	add	r3, r2
 801da6c:	00db      	lsls	r3, r3, #3
 801da6e:	3b18      	subs	r3, #24
 801da70:	69ba      	ldr	r2, [r7, #24]
 801da72:	4413      	add	r3, r2
 801da74:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801da76:	601a      	str	r2, [r3, #0]
                    new_dsc[t->grow_item_cnt - 1].min_size = f->row ? lv_obj_get_style_min_width(item, LV_PART_MAIN)
 801da78:	68bb      	ldr	r3, [r7, #8]
 801da7a:	78db      	ldrb	r3, [r3, #3]
 801da7c:	f003 0301 	and.w	r3, r3, #1
 801da80:	b2db      	uxtb	r3, r3
                                                             : lv_obj_get_style_min_height(item, LV_PART_MAIN);
 801da82:	2b00      	cmp	r3, #0
 801da84:	d005      	beq.n	801da92 <find_track_end+0x192>
                    new_dsc[t->grow_item_cnt - 1].min_size = f->row ? lv_obj_get_style_min_width(item, LV_PART_MAIN)
 801da86:	2100      	movs	r1, #0
 801da88:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801da8a:	f7ff fb41 	bl	801d110 <lv_obj_get_style_min_width>
 801da8e:	4602      	mov	r2, r0
 801da90:	e004      	b.n	801da9c <find_track_end+0x19c>
                                                             : lv_obj_get_style_min_height(item, LV_PART_MAIN);
 801da92:	2100      	movs	r1, #0
 801da94:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801da96:	f7ff fb6e 	bl	801d176 <lv_obj_get_style_min_height>
 801da9a:	4602      	mov	r2, r0
                    new_dsc[t->grow_item_cnt - 1].min_size = f->row ? lv_obj_get_style_min_width(item, LV_PART_MAIN)
 801da9c:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801da9e:	6959      	ldr	r1, [r3, #20]
 801daa0:	460b      	mov	r3, r1
 801daa2:	005b      	lsls	r3, r3, #1
 801daa4:	440b      	add	r3, r1
 801daa6:	00db      	lsls	r3, r3, #3
 801daa8:	3b18      	subs	r3, #24
 801daaa:	69b9      	ldr	r1, [r7, #24]
 801daac:	440b      	add	r3, r1
 801daae:	605a      	str	r2, [r3, #4]
                    new_dsc[t->grow_item_cnt - 1].max_size = f->row ? lv_obj_get_style_max_width(item, LV_PART_MAIN)
 801dab0:	68bb      	ldr	r3, [r7, #8]
 801dab2:	78db      	ldrb	r3, [r3, #3]
 801dab4:	f003 0301 	and.w	r3, r3, #1
 801dab8:	b2db      	uxtb	r3, r3
                                                             : lv_obj_get_style_max_height(item, LV_PART_MAIN);
 801daba:	2b00      	cmp	r3, #0
 801dabc:	d005      	beq.n	801daca <find_track_end+0x1ca>
                    new_dsc[t->grow_item_cnt - 1].max_size = f->row ? lv_obj_get_style_max_width(item, LV_PART_MAIN)
 801dabe:	2100      	movs	r1, #0
 801dac0:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801dac2:	f7ff fb36 	bl	801d132 <lv_obj_get_style_max_width>
 801dac6:	4602      	mov	r2, r0
 801dac8:	e004      	b.n	801dad4 <find_track_end+0x1d4>
                                                             : lv_obj_get_style_max_height(item, LV_PART_MAIN);
 801daca:	2100      	movs	r1, #0
 801dacc:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801dace:	f7ff fb63 	bl	801d198 <lv_obj_get_style_max_height>
 801dad2:	4602      	mov	r2, r0
                    new_dsc[t->grow_item_cnt - 1].max_size = f->row ? lv_obj_get_style_max_width(item, LV_PART_MAIN)
 801dad4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dad6:	6959      	ldr	r1, [r3, #20]
 801dad8:	460b      	mov	r3, r1
 801dada:	005b      	lsls	r3, r3, #1
 801dadc:	440b      	add	r3, r1
 801dade:	00db      	lsls	r3, r3, #3
 801dae0:	3b18      	subs	r3, #24
 801dae2:	69b9      	ldr	r1, [r7, #24]
 801dae4:	440b      	add	r3, r1
 801dae6:	609a      	str	r2, [r3, #8]
                    new_dsc[t->grow_item_cnt - 1].grow_value = grow_value;
 801dae8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801daea:	695a      	ldr	r2, [r3, #20]
 801daec:	4613      	mov	r3, r2
 801daee:	005b      	lsls	r3, r3, #1
 801daf0:	4413      	add	r3, r2
 801daf2:	00db      	lsls	r3, r3, #3
 801daf4:	3b18      	subs	r3, #24
 801daf6:	69ba      	ldr	r2, [r7, #24]
 801daf8:	4413      	add	r3, r2
 801dafa:	f897 2023 	ldrb.w	r2, [r7, #35]	@ 0x23
 801dafe:	611a      	str	r2, [r3, #16]
                    new_dsc[t->grow_item_cnt - 1].clamped = 0;
 801db00:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801db02:	695a      	ldr	r2, [r3, #20]
 801db04:	4613      	mov	r3, r2
 801db06:	005b      	lsls	r3, r3, #1
 801db08:	4413      	add	r3, r2
 801db0a:	00db      	lsls	r3, r3, #3
 801db0c:	3b18      	subs	r3, #24
 801db0e:	69ba      	ldr	r2, [r7, #24]
 801db10:	441a      	add	r2, r3
 801db12:	7d13      	ldrb	r3, [r2, #20]
 801db14:	f36f 0300 	bfc	r3, #0, #1
 801db18:	7513      	strb	r3, [r2, #20]
                    t->grow_dsc = new_dsc;
 801db1a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801db1c:	69ba      	ldr	r2, [r7, #24]
 801db1e:	611a      	str	r2, [r3, #16]
 801db20:	e019      	b.n	801db56 <find_track_end+0x256>
                }
            }
            else {
                int32_t item_size = get_main_size(item);
 801db22:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801db24:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801db26:	4798      	blx	r3
 801db28:	61f8      	str	r0, [r7, #28]
                if(f->wrap && t->track_fix_main_size + item_size > max_main_size) break;
 801db2a:	68bb      	ldr	r3, [r7, #8]
 801db2c:	78db      	ldrb	r3, [r3, #3]
 801db2e:	f003 0302 	and.w	r3, r3, #2
 801db32:	b2db      	uxtb	r3, r3
 801db34:	2b00      	cmp	r3, #0
 801db36:	d006      	beq.n	801db46 <find_track_end+0x246>
 801db38:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801db3a:	689a      	ldr	r2, [r3, #8]
 801db3c:	69fb      	ldr	r3, [r7, #28]
 801db3e:	4413      	add	r3, r2
 801db40:	683a      	ldr	r2, [r7, #0]
 801db42:	429a      	cmp	r2, r3
 801db44:	db3b      	blt.n	801dbbe <find_track_end+0x2be>
                t->track_fix_main_size += item_size + item_gap;
 801db46:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801db48:	689a      	ldr	r2, [r3, #8]
 801db4a:	69f9      	ldr	r1, [r7, #28]
 801db4c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801db4e:	440b      	add	r3, r1
 801db50:	441a      	add	r2, r3
 801db52:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801db54:	609a      	str	r2, [r3, #8]
            }

            t->track_cross_size = LV_MAX(get_cross_size(item), t->track_cross_size);
 801db56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801db58:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801db5a:	4798      	blx	r3
 801db5c:	4602      	mov	r2, r0
 801db5e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801db60:	681b      	ldr	r3, [r3, #0]
 801db62:	429a      	cmp	r2, r3
 801db64:	dd04      	ble.n	801db70 <find_track_end+0x270>
 801db66:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801db68:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801db6a:	4798      	blx	r3
 801db6c:	4603      	mov	r3, r0
 801db6e:	e001      	b.n	801db74 <find_track_end+0x274>
 801db70:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801db72:	681b      	ldr	r3, [r3, #0]
 801db74:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801db76:	6013      	str	r3, [r2, #0]
            t->item_cnt++;
 801db78:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801db7a:	68db      	ldr	r3, [r3, #12]
 801db7c:	1c5a      	adds	r2, r3, #1
 801db7e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801db80:	60da      	str	r2, [r3, #12]
        }

        item_id += f->rev ? -1 : +1;
 801db82:	68bb      	ldr	r3, [r7, #8]
 801db84:	78db      	ldrb	r3, [r3, #3]
 801db86:	f003 0304 	and.w	r3, r3, #4
 801db8a:	b2db      	uxtb	r3, r3
 801db8c:	2b00      	cmp	r3, #0
 801db8e:	d002      	beq.n	801db96 <find_track_end+0x296>
 801db90:	f04f 32ff 	mov.w	r2, #4294967295
 801db94:	e000      	b.n	801db98 <find_track_end+0x298>
 801db96:	2201      	movs	r2, #1
 801db98:	697b      	ldr	r3, [r7, #20]
 801db9a:	4413      	add	r3, r2
 801db9c:	617b      	str	r3, [r7, #20]
        if(item_id < 0) break;
 801db9e:	697b      	ldr	r3, [r7, #20]
 801dba0:	2b00      	cmp	r3, #0
 801dba2:	db17      	blt.n	801dbd4 <find_track_end+0x2d4>
        item = lv_obj_get_child(cont, item_id);
 801dba4:	697b      	ldr	r3, [r7, #20]
 801dba6:	4619      	mov	r1, r3
 801dba8:	68f8      	ldr	r0, [r7, #12]
 801dbaa:	f7ed f954 	bl	800ae56 <lv_obj_get_child>
 801dbae:	6378      	str	r0, [r7, #52]	@ 0x34
    while(item) {
 801dbb0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dbb2:	2b00      	cmp	r3, #0
 801dbb4:	f47f af08 	bne.w	801d9c8 <find_track_end+0xc8>
 801dbb8:	e00d      	b.n	801dbd6 <find_track_end+0x2d6>
        if(item_id != item_start_id && lv_obj_has_flag(item, LV_OBJ_FLAG_FLEX_IN_NEW_TRACK)) break;
 801dbba:	bf00      	nop
 801dbbc:	e00b      	b.n	801dbd6 <find_track_end+0x2d6>
                if(f->wrap && t->track_fix_main_size + item_size > max_main_size) break;
 801dbbe:	bf00      	nop
 801dbc0:	e009      	b.n	801dbd6 <find_track_end+0x2d6>
 801dbc2:	bf00      	nop
 801dbc4:	200007d1 	.word	0x200007d1
 801dbc8:	0801e551 	.word	0x0801e551
 801dbcc:	0801e581 	.word	0x0801e581
 801dbd0:	00060001 	.word	0x00060001
        if(item_id < 0) break;
 801dbd4:	bf00      	nop
    }

    if(t->track_fix_main_size > 0) t->track_fix_main_size -= item_gap; /*There is no gap after the last item*/
 801dbd6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dbd8:	689b      	ldr	r3, [r3, #8]
 801dbda:	2b00      	cmp	r3, #0
 801dbdc:	dd05      	ble.n	801dbea <find_track_end+0x2ea>
 801dbde:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dbe0:	689a      	ldr	r2, [r3, #8]
 801dbe2:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801dbe4:	1ad2      	subs	r2, r2, r3
 801dbe6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dbe8:	609a      	str	r2, [r3, #8]

    /*If there is at least one "grow item" the track takes the full space*/
    t->track_main_size = t->grow_item_cnt ? max_main_size : t->track_fix_main_size;
 801dbea:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dbec:	695b      	ldr	r3, [r3, #20]
 801dbee:	2b00      	cmp	r3, #0
 801dbf0:	d102      	bne.n	801dbf8 <find_track_end+0x2f8>
 801dbf2:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dbf4:	689b      	ldr	r3, [r3, #8]
 801dbf6:	e000      	b.n	801dbfa <find_track_end+0x2fa>
 801dbf8:	683b      	ldr	r3, [r7, #0]
 801dbfa:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801dbfc:	6053      	str	r3, [r2, #4]

    /*Have at least one item in a row*/
    if(item && item_id == item_start_id) {
 801dbfe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dc00:	2b00      	cmp	r3, #0
 801dc02:	d02d      	beq.n	801dc60 <find_track_end+0x360>
 801dc04:	697b      	ldr	r3, [r7, #20]
 801dc06:	687a      	ldr	r2, [r7, #4]
 801dc08:	429a      	cmp	r2, r3
 801dc0a:	d129      	bne.n	801dc60 <find_track_end+0x360>
        item = cont->spec_attr->children[item_id];
 801dc0c:	68fb      	ldr	r3, [r7, #12]
 801dc0e:	689b      	ldr	r3, [r3, #8]
 801dc10:	681a      	ldr	r2, [r3, #0]
 801dc12:	697b      	ldr	r3, [r7, #20]
 801dc14:	009b      	lsls	r3, r3, #2
 801dc16:	4413      	add	r3, r2
 801dc18:	681b      	ldr	r3, [r3, #0]
 801dc1a:	637b      	str	r3, [r7, #52]	@ 0x34
        get_next_item(cont, f->rev, &item_id);
 801dc1c:	68bb      	ldr	r3, [r7, #8]
 801dc1e:	78db      	ldrb	r3, [r3, #3]
 801dc20:	f3c3 0380 	ubfx	r3, r3, #2, #1
 801dc24:	b2db      	uxtb	r3, r3
 801dc26:	2b00      	cmp	r3, #0
 801dc28:	bf14      	ite	ne
 801dc2a:	2301      	movne	r3, #1
 801dc2c:	2300      	moveq	r3, #0
 801dc2e:	b2db      	uxtb	r3, r3
 801dc30:	f107 0214 	add.w	r2, r7, #20
 801dc34:	4619      	mov	r1, r3
 801dc36:	68f8      	ldr	r0, [r7, #12]
 801dc38:	f000 fc50 	bl	801e4dc <get_next_item>
        if(item) {
 801dc3c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801dc3e:	2b00      	cmp	r3, #0
 801dc40:	d00e      	beq.n	801dc60 <find_track_end+0x360>
            t->track_cross_size = get_cross_size(item);
 801dc42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801dc44:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801dc46:	4798      	blx	r3
 801dc48:	4602      	mov	r2, r0
 801dc4a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc4c:	601a      	str	r2, [r3, #0]
            t->track_main_size = get_main_size(item);
 801dc4e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801dc50:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801dc52:	4798      	blx	r3
 801dc54:	4602      	mov	r2, r0
 801dc56:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc58:	605a      	str	r2, [r3, #4]
            t->item_cnt = 1;
 801dc5a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801dc5c:	2201      	movs	r2, #1
 801dc5e:	60da      	str	r2, [r3, #12]
        }
    }

    return item_id;
 801dc60:	697b      	ldr	r3, [r7, #20]
}
 801dc62:	4618      	mov	r0, r3
 801dc64:	3738      	adds	r7, #56	@ 0x38
 801dc66:	46bd      	mov	sp, r7
 801dc68:	bd80      	pop	{r7, pc}
 801dc6a:	bf00      	nop

0801dc6c <children_repos>:
/**
 * Position the children in the same track
 */
static void children_repos(lv_obj_t * cont, flex_t * f, int32_t item_first_id, int32_t item_last_id, int32_t abs_x,
                           int32_t abs_y, int32_t max_main_size, int32_t item_gap, track_t * t)
{
 801dc6c:	b590      	push	{r4, r7, lr}
 801dc6e:	b0a7      	sub	sp, #156	@ 0x9c
 801dc70:	af02      	add	r7, sp, #8
 801dc72:	60f8      	str	r0, [r7, #12]
 801dc74:	60b9      	str	r1, [r7, #8]
 801dc76:	607a      	str	r2, [r7, #4]
 801dc78:	603b      	str	r3, [r7, #0]
    void (*area_set_main_size)(lv_area_t *, int32_t) = (f->row ? lv_area_set_width : lv_area_set_height);
 801dc7a:	68bb      	ldr	r3, [r7, #8]
 801dc7c:	78db      	ldrb	r3, [r3, #3]
 801dc7e:	f003 0301 	and.w	r3, r3, #1
 801dc82:	b2db      	uxtb	r3, r3
 801dc84:	2b00      	cmp	r3, #0
 801dc86:	d001      	beq.n	801dc8c <children_repos+0x20>
 801dc88:	4b5a      	ldr	r3, [pc, #360]	@ (801ddf4 <children_repos+0x188>)
 801dc8a:	e000      	b.n	801dc8e <children_repos+0x22>
 801dc8c:	4b5a      	ldr	r3, [pc, #360]	@ (801ddf8 <children_repos+0x18c>)
 801dc8e:	66bb      	str	r3, [r7, #104]	@ 0x68
    int32_t (*area_get_main_size)(const lv_area_t *) = (f->row ? lv_area_get_width : lv_area_get_height);
 801dc90:	68bb      	ldr	r3, [r7, #8]
 801dc92:	78db      	ldrb	r3, [r3, #3]
 801dc94:	f003 0301 	and.w	r3, r3, #1
 801dc98:	b2db      	uxtb	r3, r3
 801dc9a:	2b00      	cmp	r3, #0
 801dc9c:	d001      	beq.n	801dca2 <children_repos+0x36>
 801dc9e:	4b57      	ldr	r3, [pc, #348]	@ (801ddfc <children_repos+0x190>)
 801dca0:	e000      	b.n	801dca4 <children_repos+0x38>
 801dca2:	4b57      	ldr	r3, [pc, #348]	@ (801de00 <children_repos+0x194>)
 801dca4:	667b      	str	r3, [r7, #100]	@ 0x64
    int32_t (*area_get_cross_size)(const lv_area_t *) = (!f->row ? lv_area_get_width : lv_area_get_height);
 801dca6:	68bb      	ldr	r3, [r7, #8]
 801dca8:	78db      	ldrb	r3, [r3, #3]
 801dcaa:	f003 0301 	and.w	r3, r3, #1
 801dcae:	b2db      	uxtb	r3, r3
 801dcb0:	2b00      	cmp	r3, #0
 801dcb2:	d101      	bne.n	801dcb8 <children_repos+0x4c>
 801dcb4:	4b51      	ldr	r3, [pc, #324]	@ (801ddfc <children_repos+0x190>)
 801dcb6:	e000      	b.n	801dcba <children_repos+0x4e>
 801dcb8:	4b51      	ldr	r3, [pc, #324]	@ (801de00 <children_repos+0x194>)
 801dcba:	663b      	str	r3, [r7, #96]	@ 0x60

    typedef int32_t (*margin_func_t)(const lv_obj_t *, uint32_t);
    margin_func_t get_margin_main_start = (f->row ? lv_obj_get_style_margin_left : lv_obj_get_style_margin_top);
 801dcbc:	68bb      	ldr	r3, [r7, #8]
 801dcbe:	78db      	ldrb	r3, [r3, #3]
 801dcc0:	f003 0301 	and.w	r3, r3, #1
 801dcc4:	b2db      	uxtb	r3, r3
 801dcc6:	2b00      	cmp	r3, #0
 801dcc8:	d001      	beq.n	801dcce <children_repos+0x62>
 801dcca:	4b4e      	ldr	r3, [pc, #312]	@ (801de04 <children_repos+0x198>)
 801dccc:	e000      	b.n	801dcd0 <children_repos+0x64>
 801dcce:	4b4e      	ldr	r3, [pc, #312]	@ (801de08 <children_repos+0x19c>)
 801dcd0:	65fb      	str	r3, [r7, #92]	@ 0x5c
    margin_func_t get_margin_main_end = (f->row ? lv_obj_get_style_margin_right : lv_obj_get_style_margin_bottom);
 801dcd2:	68bb      	ldr	r3, [r7, #8]
 801dcd4:	78db      	ldrb	r3, [r3, #3]
 801dcd6:	f003 0301 	and.w	r3, r3, #1
 801dcda:	b2db      	uxtb	r3, r3
 801dcdc:	2b00      	cmp	r3, #0
 801dcde:	d001      	beq.n	801dce4 <children_repos+0x78>
 801dce0:	4b4a      	ldr	r3, [pc, #296]	@ (801de0c <children_repos+0x1a0>)
 801dce2:	e000      	b.n	801dce6 <children_repos+0x7a>
 801dce4:	4b4a      	ldr	r3, [pc, #296]	@ (801de10 <children_repos+0x1a4>)
 801dce6:	65bb      	str	r3, [r7, #88]	@ 0x58
    margin_func_t get_margin_cross_start = (!f->row ? lv_obj_get_style_margin_left : lv_obj_get_style_margin_top);
 801dce8:	68bb      	ldr	r3, [r7, #8]
 801dcea:	78db      	ldrb	r3, [r3, #3]
 801dcec:	f003 0301 	and.w	r3, r3, #1
 801dcf0:	b2db      	uxtb	r3, r3
 801dcf2:	2b00      	cmp	r3, #0
 801dcf4:	d101      	bne.n	801dcfa <children_repos+0x8e>
 801dcf6:	4b43      	ldr	r3, [pc, #268]	@ (801de04 <children_repos+0x198>)
 801dcf8:	e000      	b.n	801dcfc <children_repos+0x90>
 801dcfa:	4b43      	ldr	r3, [pc, #268]	@ (801de08 <children_repos+0x19c>)
 801dcfc:	657b      	str	r3, [r7, #84]	@ 0x54
    margin_func_t get_margin_cross_end = (!f->row ? lv_obj_get_style_margin_right : lv_obj_get_style_margin_bottom);
 801dcfe:	68bb      	ldr	r3, [r7, #8]
 801dd00:	78db      	ldrb	r3, [r3, #3]
 801dd02:	f003 0301 	and.w	r3, r3, #1
 801dd06:	b2db      	uxtb	r3, r3
 801dd08:	2b00      	cmp	r3, #0
 801dd0a:	d101      	bne.n	801dd10 <children_repos+0xa4>
 801dd0c:	4b3f      	ldr	r3, [pc, #252]	@ (801de0c <children_repos+0x1a0>)
 801dd0e:	e000      	b.n	801dd12 <children_repos+0xa6>
 801dd10:	4b3f      	ldr	r3, [pc, #252]	@ (801de10 <children_repos+0x1a4>)
 801dd12:	653b      	str	r3, [r7, #80]	@ 0x50

    /*Calculate the size of grow items first*/
    uint32_t i;
    bool grow_reiterate  = true;
 801dd14:	2301      	movs	r3, #1
 801dd16:	f887 308b 	strb.w	r3, [r7, #139]	@ 0x8b
    while(grow_reiterate && t->grow_item_cnt) {
 801dd1a:	e0fe      	b.n	801df1a <children_repos+0x2ae>
        grow_reiterate = false;
 801dd1c:	2300      	movs	r3, #0
 801dd1e:	f887 308b 	strb.w	r3, [r7, #139]	@ 0x8b
        int32_t grow_value_sum = 0;
 801dd22:	2300      	movs	r3, #0
 801dd24:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
        int32_t grow_max_size = t->track_main_size - t->track_fix_main_size;
 801dd28:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801dd2c:	685a      	ldr	r2, [r3, #4]
 801dd2e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801dd32:	689b      	ldr	r3, [r3, #8]
 801dd34:	1ad3      	subs	r3, r2, r3
 801dd36:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        for(i = 0; i < t->grow_item_cnt; i++) {
 801dd3a:	2300      	movs	r3, #0
 801dd3c:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801dd40:	e035      	b.n	801ddae <children_repos+0x142>
            if(t->grow_dsc[i].clamped == 0) {
 801dd42:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801dd46:	6919      	ldr	r1, [r3, #16]
 801dd48:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801dd4c:	4613      	mov	r3, r2
 801dd4e:	005b      	lsls	r3, r3, #1
 801dd50:	4413      	add	r3, r2
 801dd52:	00db      	lsls	r3, r3, #3
 801dd54:	440b      	add	r3, r1
 801dd56:	7d1b      	ldrb	r3, [r3, #20]
 801dd58:	f003 0301 	and.w	r3, r3, #1
 801dd5c:	b2db      	uxtb	r3, r3
 801dd5e:	2b00      	cmp	r3, #0
 801dd60:	d110      	bne.n	801dd84 <children_repos+0x118>
                grow_value_sum += t->grow_dsc[i].grow_value;
 801dd62:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801dd66:	6919      	ldr	r1, [r3, #16]
 801dd68:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801dd6c:	4613      	mov	r3, r2
 801dd6e:	005b      	lsls	r3, r3, #1
 801dd70:	4413      	add	r3, r2
 801dd72:	00db      	lsls	r3, r3, #3
 801dd74:	440b      	add	r3, r1
 801dd76:	691a      	ldr	r2, [r3, #16]
 801dd78:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801dd7c:	4413      	add	r3, r2
 801dd7e:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 801dd82:	e00f      	b.n	801dda4 <children_repos+0x138>
            }
            else {
                grow_max_size -= t->grow_dsc[i].final_size;
 801dd84:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801dd88:	6919      	ldr	r1, [r3, #16]
 801dd8a:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801dd8e:	4613      	mov	r3, r2
 801dd90:	005b      	lsls	r3, r3, #1
 801dd92:	4413      	add	r3, r2
 801dd94:	00db      	lsls	r3, r3, #3
 801dd96:	440b      	add	r3, r1
 801dd98:	68db      	ldr	r3, [r3, #12]
 801dd9a:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801dd9e:	1ad3      	subs	r3, r2, r3
 801dda0:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        for(i = 0; i < t->grow_item_cnt; i++) {
 801dda4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801dda8:	3301      	adds	r3, #1
 801ddaa:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801ddae:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801ddb2:	695b      	ldr	r3, [r3, #20]
 801ddb4:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801ddb8:	429a      	cmp	r2, r3
 801ddba:	d3c2      	bcc.n	801dd42 <children_repos+0xd6>
            }
        }
        int32_t grow_unit;

        for(i = 0; i < t->grow_item_cnt; i++) {
 801ddbc:	2300      	movs	r3, #0
 801ddbe:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801ddc2:	e0a2      	b.n	801df0a <children_repos+0x29e>
            if(t->grow_dsc[i].clamped == 0) {
 801ddc4:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801ddc8:	6919      	ldr	r1, [r3, #16]
 801ddca:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801ddce:	4613      	mov	r3, r2
 801ddd0:	005b      	lsls	r3, r3, #1
 801ddd2:	4413      	add	r3, r2
 801ddd4:	00db      	lsls	r3, r3, #3
 801ddd6:	440b      	add	r3, r1
 801ddd8:	7d1b      	ldrb	r3, [r3, #20]
 801ddda:	f003 0301 	and.w	r3, r3, #1
 801ddde:	b2db      	uxtb	r3, r3
 801dde0:	2b00      	cmp	r3, #0
 801dde2:	f040 808d 	bne.w	801df00 <children_repos+0x294>
                LV_ASSERT(grow_value_sum != 0);
 801dde6:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801ddea:	2b00      	cmp	r3, #0
 801ddec:	d112      	bne.n	801de14 <children_repos+0x1a8>
 801ddee:	bf00      	nop
 801ddf0:	e7fd      	b.n	801ddee <children_repos+0x182>
 801ddf2:	bf00      	nop
 801ddf4:	0802183b 	.word	0x0802183b
 801ddf8:	0802185f 	.word	0x0802185f
 801ddfc:	0801d0af 	.word	0x0801d0af
 801de00:	0801d0cf 	.word	0x0801d0cf
 801de04:	0801d2cb 	.word	0x0801d2cb
 801de08:	0801d287 	.word	0x0801d287
 801de0c:	0801d2ed 	.word	0x0801d2ed
 801de10:	0801d2a9 	.word	0x0801d2a9
                grow_unit = grow_max_size / grow_value_sum;
 801de14:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801de18:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 801de1c:	fb92 f3f3 	sdiv	r3, r2, r3
 801de20:	64fb      	str	r3, [r7, #76]	@ 0x4c
                int32_t size = grow_unit * t->grow_dsc[i].grow_value;
 801de22:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801de26:	6919      	ldr	r1, [r3, #16]
 801de28:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801de2c:	4613      	mov	r3, r2
 801de2e:	005b      	lsls	r3, r3, #1
 801de30:	4413      	add	r3, r2
 801de32:	00db      	lsls	r3, r3, #3
 801de34:	440b      	add	r3, r1
 801de36:	691b      	ldr	r3, [r3, #16]
 801de38:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 801de3a:	fb02 f303 	mul.w	r3, r2, r3
 801de3e:	64bb      	str	r3, [r7, #72]	@ 0x48
                int32_t size_clamp = LV_CLAMP(t->grow_dsc[i].min_size, size, t->grow_dsc[i].max_size);
 801de40:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801de44:	6919      	ldr	r1, [r3, #16]
 801de46:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801de4a:	4613      	mov	r3, r2
 801de4c:	005b      	lsls	r3, r3, #1
 801de4e:	4413      	add	r3, r2
 801de50:	00db      	lsls	r3, r3, #3
 801de52:	440b      	add	r3, r1
 801de54:	689a      	ldr	r2, [r3, #8]
 801de56:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801de58:	429a      	cmp	r2, r3
 801de5a:	bfa8      	it	ge
 801de5c:	461a      	movge	r2, r3
 801de5e:	4611      	mov	r1, r2
 801de60:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801de64:	6918      	ldr	r0, [r3, #16]
 801de66:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801de6a:	4613      	mov	r3, r2
 801de6c:	005b      	lsls	r3, r3, #1
 801de6e:	4413      	add	r3, r2
 801de70:	00db      	lsls	r3, r3, #3
 801de72:	4403      	add	r3, r0
 801de74:	685b      	ldr	r3, [r3, #4]
 801de76:	428b      	cmp	r3, r1
 801de78:	bfb8      	it	lt
 801de7a:	460b      	movlt	r3, r1
 801de7c:	647b      	str	r3, [r7, #68]	@ 0x44

                if(size_clamp != size) {
 801de7e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801de80:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801de82:	429a      	cmp	r2, r3
 801de84:	d010      	beq.n	801dea8 <children_repos+0x23c>
                    t->grow_dsc[i].clamped = 1;
 801de86:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801de8a:	6919      	ldr	r1, [r3, #16]
 801de8c:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801de90:	4613      	mov	r3, r2
 801de92:	005b      	lsls	r3, r3, #1
 801de94:	4413      	add	r3, r2
 801de96:	00db      	lsls	r3, r3, #3
 801de98:	18ca      	adds	r2, r1, r3
 801de9a:	7d13      	ldrb	r3, [r2, #20]
 801de9c:	f043 0301 	orr.w	r3, r3, #1
 801dea0:	7513      	strb	r3, [r2, #20]
                    grow_reiterate = true;
 801dea2:	2301      	movs	r3, #1
 801dea4:	f887 308b 	strb.w	r3, [r7, #139]	@ 0x8b
                }
                t->grow_dsc[i].final_size = size_clamp;
 801dea8:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801deac:	6919      	ldr	r1, [r3, #16]
 801deae:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801deb2:	4613      	mov	r3, r2
 801deb4:	005b      	lsls	r3, r3, #1
 801deb6:	4413      	add	r3, r2
 801deb8:	00db      	lsls	r3, r3, #3
 801deba:	440b      	add	r3, r1
 801debc:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801debe:	60da      	str	r2, [r3, #12]
                grow_value_sum -= t->grow_dsc[i].grow_value;
 801dec0:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 801dec4:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801dec8:	6918      	ldr	r0, [r3, #16]
 801deca:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801dece:	4613      	mov	r3, r2
 801ded0:	005b      	lsls	r3, r3, #1
 801ded2:	4413      	add	r3, r2
 801ded4:	00db      	lsls	r3, r3, #3
 801ded6:	4403      	add	r3, r0
 801ded8:	691b      	ldr	r3, [r3, #16]
 801deda:	1acb      	subs	r3, r1, r3
 801dedc:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
                grow_max_size  -= t->grow_dsc[i].final_size;
 801dee0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801dee4:	6919      	ldr	r1, [r3, #16]
 801dee6:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801deea:	4613      	mov	r3, r2
 801deec:	005b      	lsls	r3, r3, #1
 801deee:	4413      	add	r3, r2
 801def0:	00db      	lsls	r3, r3, #3
 801def2:	440b      	add	r3, r1
 801def4:	68db      	ldr	r3, [r3, #12]
 801def6:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 801defa:	1ad3      	subs	r3, r2, r3
 801defc:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
        for(i = 0; i < t->grow_item_cnt; i++) {
 801df00:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801df04:	3301      	adds	r3, #1
 801df06:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801df0a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801df0e:	695b      	ldr	r3, [r3, #20]
 801df10:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801df14:	429a      	cmp	r2, r3
 801df16:	f4ff af55 	bcc.w	801ddc4 <children_repos+0x158>
    while(grow_reiterate && t->grow_item_cnt) {
 801df1a:	f897 308b 	ldrb.w	r3, [r7, #139]	@ 0x8b
 801df1e:	2b00      	cmp	r3, #0
 801df20:	d005      	beq.n	801df2e <children_repos+0x2c2>
 801df22:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801df26:	695b      	ldr	r3, [r3, #20]
 801df28:	2b00      	cmp	r3, #0
 801df2a:	f47f aef7 	bne.w	801dd1c <children_repos+0xb0>
            }
        }
    }

    bool rtl = lv_obj_get_style_base_dir(cont, LV_PART_MAIN) == LV_BASE_DIR_RTL;
 801df2e:	2100      	movs	r1, #0
 801df30:	68f8      	ldr	r0, [r7, #12]
 801df32:	f7ff fa0f 	bl	801d354 <lv_obj_get_style_base_dir>
 801df36:	4603      	mov	r3, r0
 801df38:	2b01      	cmp	r3, #1
 801df3a:	bf0c      	ite	eq
 801df3c:	2301      	moveq	r3, #1
 801df3e:	2300      	movne	r3, #0
 801df40:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43

    int32_t main_pos = 0;
 801df44:	2300      	movs	r3, #0
 801df46:	62bb      	str	r3, [r7, #40]	@ 0x28

    int32_t place_gap = 0;
 801df48:	2300      	movs	r3, #0
 801df4a:	627b      	str	r3, [r7, #36]	@ 0x24
    place_content(f->main_place, max_main_size, t->track_main_size, t->item_cnt, &main_pos, &place_gap);
 801df4c:	68bb      	ldr	r3, [r7, #8]
 801df4e:	7818      	ldrb	r0, [r3, #0]
 801df50:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801df54:	685a      	ldr	r2, [r3, #4]
 801df56:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801df5a:	68db      	ldr	r3, [r3, #12]
 801df5c:	4619      	mov	r1, r3
 801df5e:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 801df62:	9301      	str	r3, [sp, #4]
 801df64:	f107 0328 	add.w	r3, r7, #40	@ 0x28
 801df68:	9300      	str	r3, [sp, #0]
 801df6a:	460b      	mov	r3, r1
 801df6c:	f8d7 10a8 	ldr.w	r1, [r7, #168]	@ 0xa8
 801df70:	f000 fa3a 	bl	801e3e8 <place_content>
    if(f->row && rtl) main_pos += lv_obj_get_content_width(cont);
 801df74:	68bb      	ldr	r3, [r7, #8]
 801df76:	78db      	ldrb	r3, [r3, #3]
 801df78:	f003 0301 	and.w	r3, r3, #1
 801df7c:	b2db      	uxtb	r3, r3
 801df7e:	2b00      	cmp	r3, #0
 801df80:	d00a      	beq.n	801df98 <children_repos+0x32c>
 801df82:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 801df86:	2b00      	cmp	r3, #0
 801df88:	d006      	beq.n	801df98 <children_repos+0x32c>
 801df8a:	68f8      	ldr	r0, [r7, #12]
 801df8c:	f7e7 feec 	bl	8005d68 <lv_obj_get_content_width>
 801df90:	4602      	mov	r2, r0
 801df92:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801df94:	4413      	add	r3, r2
 801df96:	62bb      	str	r3, [r7, #40]	@ 0x28

    lv_obj_t * item = lv_obj_get_child(cont, item_first_id);
 801df98:	687b      	ldr	r3, [r7, #4]
 801df9a:	4619      	mov	r1, r3
 801df9c:	68f8      	ldr	r0, [r7, #12]
 801df9e:	f7ec ff5a 	bl	800ae56 <lv_obj_get_child>
 801dfa2:	67f8      	str	r0, [r7, #124]	@ 0x7c
    /*Reposition the children*/
    while(item && item_first_id != item_last_id) {
 801dfa4:	e212      	b.n	801e3cc <children_repos+0x760>
        if(lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) {
 801dfa6:	49b0      	ldr	r1, [pc, #704]	@ (801e268 <children_repos+0x5fc>)
 801dfa8:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801dfaa:	f7e4 fee5 	bl	8002d78 <lv_obj_has_flag_any>
 801dfae:	4603      	mov	r3, r0
 801dfb0:	2b00      	cmp	r3, #0
 801dfb2:	d010      	beq.n	801dfd6 <children_repos+0x36a>
            item = get_next_item(cont, f->rev, &item_first_id);
 801dfb4:	68bb      	ldr	r3, [r7, #8]
 801dfb6:	78db      	ldrb	r3, [r3, #3]
 801dfb8:	f3c3 0380 	ubfx	r3, r3, #2, #1
 801dfbc:	b2db      	uxtb	r3, r3
 801dfbe:	2b00      	cmp	r3, #0
 801dfc0:	bf14      	ite	ne
 801dfc2:	2301      	movne	r3, #1
 801dfc4:	2300      	moveq	r3, #0
 801dfc6:	b2db      	uxtb	r3, r3
 801dfc8:	1d3a      	adds	r2, r7, #4
 801dfca:	4619      	mov	r1, r3
 801dfcc:	68f8      	ldr	r0, [r7, #12]
 801dfce:	f000 fa85 	bl	801e4dc <get_next_item>
 801dfd2:	67f8      	str	r0, [r7, #124]	@ 0x7c
            continue;
 801dfd4:	e1fa      	b.n	801e3cc <children_repos+0x760>
        }
        int32_t grow_size = lv_obj_get_style_flex_grow(item, LV_PART_MAIN);
 801dfd6:	2100      	movs	r1, #0
 801dfd8:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801dfda:	f7ff fa15 	bl	801d408 <lv_obj_get_style_flex_grow>
 801dfde:	4603      	mov	r3, r0
 801dfe0:	63fb      	str	r3, [r7, #60]	@ 0x3c
        if(grow_size) {
 801dfe2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801dfe4:	2b00      	cmp	r3, #0
 801dfe6:	f000 8082 	beq.w	801e0ee <children_repos+0x482>
            int32_t s = 0;
 801dfea:	2300      	movs	r3, #0
 801dfec:	67bb      	str	r3, [r7, #120]	@ 0x78
            for(i = 0; i < t->grow_item_cnt; i++) {
 801dfee:	2300      	movs	r3, #0
 801dff0:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801dff4:	e01f      	b.n	801e036 <children_repos+0x3ca>
                if(t->grow_dsc[i].item == item) {
 801dff6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801dffa:	6919      	ldr	r1, [r3, #16]
 801dffc:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801e000:	4613      	mov	r3, r2
 801e002:	005b      	lsls	r3, r3, #1
 801e004:	4413      	add	r3, r2
 801e006:	00db      	lsls	r3, r3, #3
 801e008:	440b      	add	r3, r1
 801e00a:	681b      	ldr	r3, [r3, #0]
 801e00c:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801e00e:	429a      	cmp	r2, r3
 801e010:	d10c      	bne.n	801e02c <children_repos+0x3c0>
                    s = t->grow_dsc[i].final_size;
 801e012:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801e016:	6919      	ldr	r1, [r3, #16]
 801e018:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801e01c:	4613      	mov	r3, r2
 801e01e:	005b      	lsls	r3, r3, #1
 801e020:	4413      	add	r3, r2
 801e022:	00db      	lsls	r3, r3, #3
 801e024:	440b      	add	r3, r1
 801e026:	68db      	ldr	r3, [r3, #12]
 801e028:	67bb      	str	r3, [r7, #120]	@ 0x78
                    break;
 801e02a:	e00b      	b.n	801e044 <children_repos+0x3d8>
            for(i = 0; i < t->grow_item_cnt; i++) {
 801e02c:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 801e030:	3301      	adds	r3, #1
 801e032:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 801e036:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801e03a:	695b      	ldr	r3, [r3, #20]
 801e03c:	f8d7 208c 	ldr.w	r2, [r7, #140]	@ 0x8c
 801e040:	429a      	cmp	r2, r3
 801e042:	d3d8      	bcc.n	801dff6 <children_repos+0x38a>
                }
            }

            if(f->row) {
 801e044:	68bb      	ldr	r3, [r7, #8]
 801e046:	78db      	ldrb	r3, [r3, #3]
 801e048:	f003 0301 	and.w	r3, r3, #1
 801e04c:	b2db      	uxtb	r3, r3
 801e04e:	2b00      	cmp	r3, #0
 801e050:	d00e      	beq.n	801e070 <children_repos+0x404>
                item->w_layout = 1;
 801e052:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801e054:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801e058:	f043 0308 	orr.w	r3, r3, #8
 801e05c:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
                item->h_layout = 0;
 801e060:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801e062:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801e066:	f36f 0382 	bfc	r3, #2, #1
 801e06a:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
 801e06e:	e00d      	b.n	801e08c <children_repos+0x420>
            }
            else {
                item->h_layout = 1;
 801e070:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801e072:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801e076:	f043 0304 	orr.w	r3, r3, #4
 801e07a:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
                item->w_layout = 0;
 801e07e:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801e080:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801e084:	f36f 03c3 	bfc	r3, #3, #1
 801e088:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
            }

            if(s != area_get_main_size(&item->coords)) {
 801e08c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e08e:	f103 0214 	add.w	r2, r3, #20
 801e092:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e094:	4610      	mov	r0, r2
 801e096:	4798      	blx	r3
 801e098:	4602      	mov	r2, r0
 801e09a:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801e09c:	4293      	cmp	r3, r2
 801e09e:	d034      	beq.n	801e10a <children_repos+0x49e>
                lv_obj_invalidate(item);
 801e0a0:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e0a2:	f7e8 facd 	bl	8006640 <lv_obj_invalidate>

                lv_area_t old_coords;
                lv_area_copy(&old_coords, &item->coords);
 801e0a6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e0a8:	f103 0214 	add.w	r2, r3, #20
 801e0ac:	f107 0314 	add.w	r3, r7, #20
 801e0b0:	4611      	mov	r1, r2
 801e0b2:	4618      	mov	r0, r3
 801e0b4:	f7fe ffe0 	bl	801d078 <lv_area_copy>
                area_set_main_size(&item->coords, s);
 801e0b8:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e0ba:	f103 0214 	add.w	r2, r3, #20
 801e0be:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801e0c0:	6fb9      	ldr	r1, [r7, #120]	@ 0x78
 801e0c2:	4610      	mov	r0, r2
 801e0c4:	4798      	blx	r3
                lv_obj_send_event(item, LV_EVENT_SIZE_CHANGED, &old_coords);
 801e0c6:	f107 0314 	add.w	r3, r7, #20
 801e0ca:	461a      	mov	r2, r3
 801e0cc:	212b      	movs	r1, #43	@ 0x2b
 801e0ce:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e0d0:	f7e6 fea0 	bl	8004e14 <lv_obj_send_event>
                lv_obj_send_event(lv_obj_get_parent(item), LV_EVENT_CHILD_CHANGED, item);
 801e0d4:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e0d6:	f7ec fead 	bl	800ae34 <lv_obj_get_parent>
 801e0da:	4603      	mov	r3, r0
 801e0dc:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801e0de:	2124      	movs	r1, #36	@ 0x24
 801e0e0:	4618      	mov	r0, r3
 801e0e2:	f7e6 fe97 	bl	8004e14 <lv_obj_send_event>
                lv_obj_invalidate(item);
 801e0e6:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e0e8:	f7e8 faaa 	bl	8006640 <lv_obj_invalidate>
 801e0ec:	e00d      	b.n	801e10a <children_repos+0x49e>
            }
        }
        else {
            item->w_layout = 0;
 801e0ee:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801e0f0:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801e0f4:	f36f 03c3 	bfc	r3, #3, #1
 801e0f8:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
            item->h_layout = 0;
 801e0fc:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 801e0fe:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801e102:	f36f 0382 	bfc	r3, #2, #1
 801e106:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
        }

        int32_t cross_pos = 0;
 801e10a:	2300      	movs	r3, #0
 801e10c:	677b      	str	r3, [r7, #116]	@ 0x74
        switch(f->cross_place) {
 801e10e:	68bb      	ldr	r3, [r7, #8]
 801e110:	785b      	ldrb	r3, [r3, #1]
 801e112:	2b01      	cmp	r3, #1
 801e114:	d026      	beq.n	801e164 <children_repos+0x4f8>
 801e116:	2b02      	cmp	r3, #2
 801e118:	d139      	bne.n	801e18e <children_repos+0x522>
            case LV_FLEX_ALIGN_CENTER:
                /*Round up the cross size to avoid rounding error when dividing by 2
                 *The issue comes up e,g, with column direction with center cross direction if an element's width changes*/
                cross_pos = (((t->track_cross_size + 1) & (~1)) - area_get_cross_size(&item->coords)) / 2;
 801e11a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801e11e:	681b      	ldr	r3, [r3, #0]
 801e120:	3301      	adds	r3, #1
 801e122:	f023 0401 	bic.w	r4, r3, #1
 801e126:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e128:	f103 0214 	add.w	r2, r3, #20
 801e12c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801e12e:	4610      	mov	r0, r2
 801e130:	4798      	blx	r3
 801e132:	4603      	mov	r3, r0
 801e134:	1ae3      	subs	r3, r4, r3
 801e136:	0fda      	lsrs	r2, r3, #31
 801e138:	4413      	add	r3, r2
 801e13a:	105b      	asrs	r3, r3, #1
 801e13c:	677b      	str	r3, [r7, #116]	@ 0x74
                cross_pos += (get_margin_cross_start(item, LV_PART_MAIN) - get_margin_cross_end(item, LV_PART_MAIN)) / 2;
 801e13e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801e140:	2100      	movs	r1, #0
 801e142:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e144:	4798      	blx	r3
 801e146:	4604      	mov	r4, r0
 801e148:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801e14a:	2100      	movs	r1, #0
 801e14c:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e14e:	4798      	blx	r3
 801e150:	4603      	mov	r3, r0
 801e152:	1ae3      	subs	r3, r4, r3
 801e154:	0fda      	lsrs	r2, r3, #31
 801e156:	4413      	add	r3, r2
 801e158:	105b      	asrs	r3, r3, #1
 801e15a:	461a      	mov	r2, r3
 801e15c:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801e15e:	4413      	add	r3, r2
 801e160:	677b      	str	r3, [r7, #116]	@ 0x74
                break;
 801e162:	e01d      	b.n	801e1a0 <children_repos+0x534>
            case LV_FLEX_ALIGN_END:
                cross_pos = t->track_cross_size - area_get_cross_size(&item->coords);
 801e164:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 801e168:	681c      	ldr	r4, [r3, #0]
 801e16a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e16c:	f103 0214 	add.w	r2, r3, #20
 801e170:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801e172:	4610      	mov	r0, r2
 801e174:	4798      	blx	r3
 801e176:	4603      	mov	r3, r0
 801e178:	1ae3      	subs	r3, r4, r3
 801e17a:	677b      	str	r3, [r7, #116]	@ 0x74
                cross_pos -= get_margin_cross_end(item, LV_PART_MAIN);
 801e17c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801e17e:	2100      	movs	r1, #0
 801e180:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e182:	4798      	blx	r3
 801e184:	4602      	mov	r2, r0
 801e186:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801e188:	1a9b      	subs	r3, r3, r2
 801e18a:	677b      	str	r3, [r7, #116]	@ 0x74
                break;
 801e18c:	e008      	b.n	801e1a0 <children_repos+0x534>
            default:
                cross_pos += get_margin_cross_start(item, LV_PART_MAIN);
 801e18e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801e190:	2100      	movs	r1, #0
 801e192:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e194:	4798      	blx	r3
 801e196:	4602      	mov	r2, r0
 801e198:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801e19a:	4413      	add	r3, r2
 801e19c:	677b      	str	r3, [r7, #116]	@ 0x74
                break;
 801e19e:	bf00      	nop
        }

        if(f->row && rtl) main_pos -= area_get_main_size(&item->coords);
 801e1a0:	68bb      	ldr	r3, [r7, #8]
 801e1a2:	78db      	ldrb	r3, [r3, #3]
 801e1a4:	f003 0301 	and.w	r3, r3, #1
 801e1a8:	b2db      	uxtb	r3, r3
 801e1aa:	2b00      	cmp	r3, #0
 801e1ac:	d00d      	beq.n	801e1ca <children_repos+0x55e>
 801e1ae:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 801e1b2:	2b00      	cmp	r3, #0
 801e1b4:	d009      	beq.n	801e1ca <children_repos+0x55e>
 801e1b6:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e1b8:	f103 0214 	add.w	r2, r3, #20
 801e1bc:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e1be:	4610      	mov	r0, r2
 801e1c0:	4798      	blx	r3
 801e1c2:	4602      	mov	r2, r0
 801e1c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801e1c6:	1a9b      	subs	r3, r3, r2
 801e1c8:	62bb      	str	r3, [r7, #40]	@ 0x28

        /*Handle percentage value of translate*/
        int32_t tr_x = lv_obj_get_style_translate_x(item, LV_PART_MAIN);
 801e1ca:	2100      	movs	r1, #0
 801e1cc:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e1ce:	f7fe fff4 	bl	801d1ba <lv_obj_get_style_translate_x>
 801e1d2:	6738      	str	r0, [r7, #112]	@ 0x70
        int32_t tr_y = lv_obj_get_style_translate_y(item, LV_PART_MAIN);
 801e1d4:	2100      	movs	r1, #0
 801e1d6:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e1d8:	f7ff f800 	bl	801d1dc <lv_obj_get_style_translate_y>
 801e1dc:	66f8      	str	r0, [r7, #108]	@ 0x6c
        int32_t w = lv_obj_get_width(item);
 801e1de:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e1e0:	f7e7 fda6 	bl	8005d30 <lv_obj_get_width>
 801e1e4:	63b8      	str	r0, [r7, #56]	@ 0x38
        int32_t h = lv_obj_get_height(item);
 801e1e6:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e1e8:	f7e7 fdb0 	bl	8005d4c <lv_obj_get_height>
 801e1ec:	6378      	str	r0, [r7, #52]	@ 0x34
        if(LV_COORD_IS_PCT(tr_x)) tr_x = (w * LV_COORD_GET_PCT(tr_x)) / 100;
 801e1ee:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801e1f0:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 801e1f4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 801e1f8:	d11e      	bne.n	801e238 <children_repos+0x5cc>
 801e1fa:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801e1fc:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801e200:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 801e204:	dc18      	bgt.n	801e238 <children_repos+0x5cc>
 801e206:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801e208:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801e20c:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 801e210:	dd05      	ble.n	801e21e <children_repos+0x5b2>
 801e212:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801e214:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801e218:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 801e21c:	e002      	b.n	801e224 <children_repos+0x5b8>
 801e21e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801e220:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801e224:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801e226:	fb02 f303 	mul.w	r3, r2, r3
 801e22a:	4a10      	ldr	r2, [pc, #64]	@ (801e26c <children_repos+0x600>)
 801e22c:	fb82 1203 	smull	r1, r2, r2, r3
 801e230:	1152      	asrs	r2, r2, #5
 801e232:	17db      	asrs	r3, r3, #31
 801e234:	1ad3      	subs	r3, r2, r3
 801e236:	673b      	str	r3, [r7, #112]	@ 0x70
        if(LV_COORD_IS_PCT(tr_y)) tr_y = (h * LV_COORD_GET_PCT(tr_y)) / 100;
 801e238:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801e23a:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 801e23e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 801e242:	d122      	bne.n	801e28a <children_repos+0x61e>
 801e244:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801e246:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801e24a:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 801e24e:	dc1c      	bgt.n	801e28a <children_repos+0x61e>
 801e250:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801e252:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801e256:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 801e25a:	dd09      	ble.n	801e270 <children_repos+0x604>
 801e25c:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801e25e:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801e262:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 801e266:	e006      	b.n	801e276 <children_repos+0x60a>
 801e268:	00060001 	.word	0x00060001
 801e26c:	51eb851f 	.word	0x51eb851f
 801e270:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801e272:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801e276:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801e278:	fb02 f303 	mul.w	r3, r2, r3
 801e27c:	4a59      	ldr	r2, [pc, #356]	@ (801e3e4 <children_repos+0x778>)
 801e27e:	fb82 1203 	smull	r1, r2, r2, r3
 801e282:	1152      	asrs	r2, r2, #5
 801e284:	17db      	asrs	r3, r3, #31
 801e286:	1ad3      	subs	r3, r2, r3
 801e288:	66fb      	str	r3, [r7, #108]	@ 0x6c

        int32_t diff_x = abs_x - item->coords.x1 + tr_x;
 801e28a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e28c:	695b      	ldr	r3, [r3, #20]
 801e28e:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 801e292:	1ad3      	subs	r3, r2, r3
 801e294:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801e296:	4413      	add	r3, r2
 801e298:	633b      	str	r3, [r7, #48]	@ 0x30
        int32_t diff_y = abs_y - item->coords.y1 + tr_y;
 801e29a:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e29c:	699b      	ldr	r3, [r3, #24]
 801e29e:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 801e2a2:	1ad3      	subs	r3, r2, r3
 801e2a4:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801e2a6:	4413      	add	r3, r2
 801e2a8:	62fb      	str	r3, [r7, #44]	@ 0x2c
        diff_x += f->row ? main_pos + get_margin_main_start(item, LV_PART_MAIN) : cross_pos;
 801e2aa:	68bb      	ldr	r3, [r7, #8]
 801e2ac:	78db      	ldrb	r3, [r3, #3]
 801e2ae:	f003 0301 	and.w	r3, r3, #1
 801e2b2:	b2db      	uxtb	r3, r3
 801e2b4:	2b00      	cmp	r3, #0
 801e2b6:	d007      	beq.n	801e2c8 <children_repos+0x65c>
 801e2b8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801e2ba:	2100      	movs	r1, #0
 801e2bc:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e2be:	4798      	blx	r3
 801e2c0:	4602      	mov	r2, r0
 801e2c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801e2c4:	4413      	add	r3, r2
 801e2c6:	e000      	b.n	801e2ca <children_repos+0x65e>
 801e2c8:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801e2ca:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801e2cc:	4413      	add	r3, r2
 801e2ce:	633b      	str	r3, [r7, #48]	@ 0x30
        diff_y += f->row ? cross_pos : main_pos + get_margin_main_start(item, LV_PART_MAIN);
 801e2d0:	68bb      	ldr	r3, [r7, #8]
 801e2d2:	78db      	ldrb	r3, [r3, #3]
 801e2d4:	f003 0301 	and.w	r3, r3, #1
 801e2d8:	b2db      	uxtb	r3, r3
 801e2da:	2b00      	cmp	r3, #0
 801e2dc:	d107      	bne.n	801e2ee <children_repos+0x682>
 801e2de:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801e2e0:	2100      	movs	r1, #0
 801e2e2:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e2e4:	4798      	blx	r3
 801e2e6:	4602      	mov	r2, r0
 801e2e8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801e2ea:	4413      	add	r3, r2
 801e2ec:	e000      	b.n	801e2f0 <children_repos+0x684>
 801e2ee:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 801e2f0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801e2f2:	4413      	add	r3, r2
 801e2f4:	62fb      	str	r3, [r7, #44]	@ 0x2c

        if(diff_x || diff_y) {
 801e2f6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801e2f8:	2b00      	cmp	r3, #0
 801e2fa:	d102      	bne.n	801e302 <children_repos+0x696>
 801e2fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801e2fe:	2b00      	cmp	r3, #0
 801e300:	d023      	beq.n	801e34a <children_repos+0x6de>
            lv_obj_invalidate(item);
 801e302:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e304:	f7e8 f99c 	bl	8006640 <lv_obj_invalidate>
            item->coords.x1 += diff_x;
 801e308:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e30a:	695a      	ldr	r2, [r3, #20]
 801e30c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801e30e:	441a      	add	r2, r3
 801e310:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e312:	615a      	str	r2, [r3, #20]
            item->coords.x2 += diff_x;
 801e314:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e316:	69da      	ldr	r2, [r3, #28]
 801e318:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801e31a:	441a      	add	r2, r3
 801e31c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e31e:	61da      	str	r2, [r3, #28]
            item->coords.y1 += diff_y;
 801e320:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e322:	699a      	ldr	r2, [r3, #24]
 801e324:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801e326:	441a      	add	r2, r3
 801e328:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e32a:	619a      	str	r2, [r3, #24]
            item->coords.y2 += diff_y;
 801e32c:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e32e:	6a1a      	ldr	r2, [r3, #32]
 801e330:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801e332:	441a      	add	r2, r3
 801e334:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e336:	621a      	str	r2, [r3, #32]
            lv_obj_invalidate(item);
 801e338:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e33a:	f7e8 f981 	bl	8006640 <lv_obj_invalidate>
            lv_obj_move_children_by(item, diff_x, diff_y, false);
 801e33e:	2300      	movs	r3, #0
 801e340:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801e342:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 801e344:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e346:	f7e8 f828 	bl	800639a <lv_obj_move_children_by>
        }

        if(!(f->row && rtl)) main_pos += area_get_main_size(&item->coords) + item_gap + place_gap
 801e34a:	68bb      	ldr	r3, [r7, #8]
 801e34c:	78db      	ldrb	r3, [r3, #3]
 801e34e:	f003 0301 	and.w	r3, r3, #1
 801e352:	b2db      	uxtb	r3, r3
 801e354:	2b00      	cmp	r3, #0
 801e356:	d006      	beq.n	801e366 <children_repos+0x6fa>
 801e358:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 801e35c:	f083 0301 	eor.w	r3, r3, #1
 801e360:	b2db      	uxtb	r3, r3
 801e362:	2b00      	cmp	r3, #0
 801e364:	d01b      	beq.n	801e39e <children_repos+0x732>
 801e366:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e368:	f103 0214 	add.w	r2, r3, #20
 801e36c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801e36e:	4610      	mov	r0, r2
 801e370:	4798      	blx	r3
 801e372:	4602      	mov	r2, r0
 801e374:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 801e378:	441a      	add	r2, r3
 801e37a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801e37c:	18d4      	adds	r4, r2, r3
                                             + get_margin_main_start(item, LV_PART_MAIN)
 801e37e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801e380:	2100      	movs	r1, #0
 801e382:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e384:	4798      	blx	r3
 801e386:	4603      	mov	r3, r0
 801e388:	441c      	add	r4, r3
                                             + get_margin_main_end(item, LV_PART_MAIN);
 801e38a:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801e38c:	2100      	movs	r1, #0
 801e38e:	6ff8      	ldr	r0, [r7, #124]	@ 0x7c
 801e390:	4798      	blx	r3
 801e392:	4603      	mov	r3, r0
 801e394:	18e2      	adds	r2, r4, r3
        if(!(f->row && rtl)) main_pos += area_get_main_size(&item->coords) + item_gap + place_gap
 801e396:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801e398:	4413      	add	r3, r2
 801e39a:	62bb      	str	r3, [r7, #40]	@ 0x28
                                             + get_margin_main_end(item, LV_PART_MAIN);
 801e39c:	e006      	b.n	801e3ac <children_repos+0x740>
        else main_pos -= item_gap + place_gap;
 801e39e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801e3a0:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801e3a2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 801e3a6:	440b      	add	r3, r1
 801e3a8:	1ad3      	subs	r3, r2, r3
 801e3aa:	62bb      	str	r3, [r7, #40]	@ 0x28

        item = get_next_item(cont, f->rev, &item_first_id);
 801e3ac:	68bb      	ldr	r3, [r7, #8]
 801e3ae:	78db      	ldrb	r3, [r3, #3]
 801e3b0:	f3c3 0380 	ubfx	r3, r3, #2, #1
 801e3b4:	b2db      	uxtb	r3, r3
 801e3b6:	2b00      	cmp	r3, #0
 801e3b8:	bf14      	ite	ne
 801e3ba:	2301      	movne	r3, #1
 801e3bc:	2300      	moveq	r3, #0
 801e3be:	b2db      	uxtb	r3, r3
 801e3c0:	1d3a      	adds	r2, r7, #4
 801e3c2:	4619      	mov	r1, r3
 801e3c4:	68f8      	ldr	r0, [r7, #12]
 801e3c6:	f000 f889 	bl	801e4dc <get_next_item>
 801e3ca:	67f8      	str	r0, [r7, #124]	@ 0x7c
    while(item && item_first_id != item_last_id) {
 801e3cc:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 801e3ce:	2b00      	cmp	r3, #0
 801e3d0:	d004      	beq.n	801e3dc <children_repos+0x770>
 801e3d2:	687b      	ldr	r3, [r7, #4]
 801e3d4:	683a      	ldr	r2, [r7, #0]
 801e3d6:	429a      	cmp	r2, r3
 801e3d8:	f47f ade5 	bne.w	801dfa6 <children_repos+0x33a>
    }
}
 801e3dc:	bf00      	nop
 801e3de:	3794      	adds	r7, #148	@ 0x94
 801e3e0:	46bd      	mov	sp, r7
 801e3e2:	bd90      	pop	{r4, r7, pc}
 801e3e4:	51eb851f 	.word	0x51eb851f

0801e3e8 <place_content>:
/**
 * Tell a start coordinate and gap for a placement type.
 */
static void place_content(lv_flex_align_t place, int32_t max_size, int32_t content_size, int32_t item_cnt,
                          int32_t * start_pos, int32_t * gap)
{
 801e3e8:	b480      	push	{r7}
 801e3ea:	b085      	sub	sp, #20
 801e3ec:	af00      	add	r7, sp, #0
 801e3ee:	60b9      	str	r1, [r7, #8]
 801e3f0:	607a      	str	r2, [r7, #4]
 801e3f2:	603b      	str	r3, [r7, #0]
 801e3f4:	4603      	mov	r3, r0
 801e3f6:	73fb      	strb	r3, [r7, #15]
    if(item_cnt <= 1) {
 801e3f8:	683b      	ldr	r3, [r7, #0]
 801e3fa:	2b01      	cmp	r3, #1
 801e3fc:	dc07      	bgt.n	801e40e <place_content+0x26>
        switch(place) {
 801e3fe:	7bfb      	ldrb	r3, [r7, #15]
 801e400:	3b03      	subs	r3, #3
 801e402:	2b02      	cmp	r3, #2
 801e404:	d802      	bhi.n	801e40c <place_content+0x24>
            case LV_FLEX_ALIGN_SPACE_BETWEEN:
            case LV_FLEX_ALIGN_SPACE_AROUND:
            case LV_FLEX_ALIGN_SPACE_EVENLY:
                place = LV_FLEX_ALIGN_CENTER;
 801e406:	2302      	movs	r3, #2
 801e408:	73fb      	strb	r3, [r7, #15]
                break;
 801e40a:	e000      	b.n	801e40e <place_content+0x26>
            default:
                break;
 801e40c:	bf00      	nop
        }
    }

    switch(place) {
 801e40e:	7bfb      	ldrb	r3, [r7, #15]
 801e410:	3b01      	subs	r3, #1
 801e412:	2b04      	cmp	r3, #4
 801e414:	d858      	bhi.n	801e4c8 <place_content+0xe0>
 801e416:	a201      	add	r2, pc, #4	@ (adr r2, 801e41c <place_content+0x34>)
 801e418:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e41c:	0801e44f 	.word	0x0801e44f
 801e420:	0801e431 	.word	0x0801e431
 801e424:	0801e4a7 	.word	0x0801e4a7
 801e428:	0801e47b 	.word	0x0801e47b
 801e42c:	0801e467 	.word	0x0801e467
        case LV_FLEX_ALIGN_CENTER:
            *gap = 0;
 801e430:	69fb      	ldr	r3, [r7, #28]
 801e432:	2200      	movs	r2, #0
 801e434:	601a      	str	r2, [r3, #0]
            *start_pos += (max_size - content_size) / 2;
 801e436:	69bb      	ldr	r3, [r7, #24]
 801e438:	681a      	ldr	r2, [r3, #0]
 801e43a:	68b9      	ldr	r1, [r7, #8]
 801e43c:	687b      	ldr	r3, [r7, #4]
 801e43e:	1acb      	subs	r3, r1, r3
 801e440:	0fd9      	lsrs	r1, r3, #31
 801e442:	440b      	add	r3, r1
 801e444:	105b      	asrs	r3, r3, #1
 801e446:	441a      	add	r2, r3
 801e448:	69bb      	ldr	r3, [r7, #24]
 801e44a:	601a      	str	r2, [r3, #0]
            break;
 801e44c:	e040      	b.n	801e4d0 <place_content+0xe8>
        case LV_FLEX_ALIGN_END:
            *gap = 0;
 801e44e:	69fb      	ldr	r3, [r7, #28]
 801e450:	2200      	movs	r2, #0
 801e452:	601a      	str	r2, [r3, #0]
            *start_pos += max_size - content_size;
 801e454:	69bb      	ldr	r3, [r7, #24]
 801e456:	681a      	ldr	r2, [r3, #0]
 801e458:	68b9      	ldr	r1, [r7, #8]
 801e45a:	687b      	ldr	r3, [r7, #4]
 801e45c:	1acb      	subs	r3, r1, r3
 801e45e:	441a      	add	r2, r3
 801e460:	69bb      	ldr	r3, [r7, #24]
 801e462:	601a      	str	r2, [r3, #0]
            break;
 801e464:	e034      	b.n	801e4d0 <place_content+0xe8>
        case LV_FLEX_ALIGN_SPACE_BETWEEN:
            *gap = (int32_t)(max_size - content_size) / (int32_t)(item_cnt - 1);
 801e466:	68ba      	ldr	r2, [r7, #8]
 801e468:	687b      	ldr	r3, [r7, #4]
 801e46a:	1ad2      	subs	r2, r2, r3
 801e46c:	683b      	ldr	r3, [r7, #0]
 801e46e:	3b01      	subs	r3, #1
 801e470:	fb92 f2f3 	sdiv	r2, r2, r3
 801e474:	69fb      	ldr	r3, [r7, #28]
 801e476:	601a      	str	r2, [r3, #0]
            break;
 801e478:	e02a      	b.n	801e4d0 <place_content+0xe8>
        case LV_FLEX_ALIGN_SPACE_AROUND:
            *gap += (int32_t)(max_size - content_size) / (int32_t)(item_cnt);
 801e47a:	69fb      	ldr	r3, [r7, #28]
 801e47c:	681a      	ldr	r2, [r3, #0]
 801e47e:	68b9      	ldr	r1, [r7, #8]
 801e480:	687b      	ldr	r3, [r7, #4]
 801e482:	1ac9      	subs	r1, r1, r3
 801e484:	683b      	ldr	r3, [r7, #0]
 801e486:	fb91 f3f3 	sdiv	r3, r1, r3
 801e48a:	441a      	add	r2, r3
 801e48c:	69fb      	ldr	r3, [r7, #28]
 801e48e:	601a      	str	r2, [r3, #0]
            *start_pos += *gap / 2;
 801e490:	69bb      	ldr	r3, [r7, #24]
 801e492:	681a      	ldr	r2, [r3, #0]
 801e494:	69fb      	ldr	r3, [r7, #28]
 801e496:	681b      	ldr	r3, [r3, #0]
 801e498:	0fd9      	lsrs	r1, r3, #31
 801e49a:	440b      	add	r3, r1
 801e49c:	105b      	asrs	r3, r3, #1
 801e49e:	441a      	add	r2, r3
 801e4a0:	69bb      	ldr	r3, [r7, #24]
 801e4a2:	601a      	str	r2, [r3, #0]
            break;
 801e4a4:	e014      	b.n	801e4d0 <place_content+0xe8>
        case LV_FLEX_ALIGN_SPACE_EVENLY:
            *gap = (int32_t)(max_size - content_size) / (int32_t)(item_cnt + 1);
 801e4a6:	68ba      	ldr	r2, [r7, #8]
 801e4a8:	687b      	ldr	r3, [r7, #4]
 801e4aa:	1ad2      	subs	r2, r2, r3
 801e4ac:	683b      	ldr	r3, [r7, #0]
 801e4ae:	3301      	adds	r3, #1
 801e4b0:	fb92 f2f3 	sdiv	r2, r2, r3
 801e4b4:	69fb      	ldr	r3, [r7, #28]
 801e4b6:	601a      	str	r2, [r3, #0]
            *start_pos += *gap;
 801e4b8:	69bb      	ldr	r3, [r7, #24]
 801e4ba:	681a      	ldr	r2, [r3, #0]
 801e4bc:	69fb      	ldr	r3, [r7, #28]
 801e4be:	681b      	ldr	r3, [r3, #0]
 801e4c0:	441a      	add	r2, r3
 801e4c2:	69bb      	ldr	r3, [r7, #24]
 801e4c4:	601a      	str	r2, [r3, #0]
            break;
 801e4c6:	e003      	b.n	801e4d0 <place_content+0xe8>
        default:
            *gap = 0;
 801e4c8:	69fb      	ldr	r3, [r7, #28]
 801e4ca:	2200      	movs	r2, #0
 801e4cc:	601a      	str	r2, [r3, #0]
    }
}
 801e4ce:	bf00      	nop
 801e4d0:	bf00      	nop
 801e4d2:	3714      	adds	r7, #20
 801e4d4:	46bd      	mov	sp, r7
 801e4d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e4da:	4770      	bx	lr

0801e4dc <get_next_item>:

static lv_obj_t * get_next_item(lv_obj_t * cont, bool rev, int32_t * item_id)
{
 801e4dc:	b480      	push	{r7}
 801e4de:	b085      	sub	sp, #20
 801e4e0:	af00      	add	r7, sp, #0
 801e4e2:	60f8      	str	r0, [r7, #12]
 801e4e4:	460b      	mov	r3, r1
 801e4e6:	607a      	str	r2, [r7, #4]
 801e4e8:	72fb      	strb	r3, [r7, #11]
    if(rev) {
 801e4ea:	7afb      	ldrb	r3, [r7, #11]
 801e4ec:	2b00      	cmp	r3, #0
 801e4ee:	d013      	beq.n	801e518 <get_next_item+0x3c>
        (*item_id)--;
 801e4f0:	687b      	ldr	r3, [r7, #4]
 801e4f2:	681b      	ldr	r3, [r3, #0]
 801e4f4:	1e5a      	subs	r2, r3, #1
 801e4f6:	687b      	ldr	r3, [r7, #4]
 801e4f8:	601a      	str	r2, [r3, #0]
        if(*item_id >= 0) return cont->spec_attr->children[*item_id];
 801e4fa:	687b      	ldr	r3, [r7, #4]
 801e4fc:	681b      	ldr	r3, [r3, #0]
 801e4fe:	2b00      	cmp	r3, #0
 801e500:	db08      	blt.n	801e514 <get_next_item+0x38>
 801e502:	68fb      	ldr	r3, [r7, #12]
 801e504:	689b      	ldr	r3, [r3, #8]
 801e506:	681a      	ldr	r2, [r3, #0]
 801e508:	687b      	ldr	r3, [r7, #4]
 801e50a:	681b      	ldr	r3, [r3, #0]
 801e50c:	009b      	lsls	r3, r3, #2
 801e50e:	4413      	add	r3, r2
 801e510:	681b      	ldr	r3, [r3, #0]
 801e512:	e017      	b.n	801e544 <get_next_item+0x68>
        else return NULL;
 801e514:	2300      	movs	r3, #0
 801e516:	e015      	b.n	801e544 <get_next_item+0x68>
    }
    else {
        (*item_id)++;
 801e518:	687b      	ldr	r3, [r7, #4]
 801e51a:	681b      	ldr	r3, [r3, #0]
 801e51c:	1c5a      	adds	r2, r3, #1
 801e51e:	687b      	ldr	r3, [r7, #4]
 801e520:	601a      	str	r2, [r3, #0]
        if((*item_id) < (int32_t)cont->spec_attr->child_cnt) return cont->spec_attr->children[*item_id];
 801e522:	687b      	ldr	r3, [r7, #4]
 801e524:	681b      	ldr	r3, [r3, #0]
 801e526:	68fa      	ldr	r2, [r7, #12]
 801e528:	6892      	ldr	r2, [r2, #8]
 801e52a:	8d12      	ldrh	r2, [r2, #40]	@ 0x28
 801e52c:	4293      	cmp	r3, r2
 801e52e:	da08      	bge.n	801e542 <get_next_item+0x66>
 801e530:	68fb      	ldr	r3, [r7, #12]
 801e532:	689b      	ldr	r3, [r3, #8]
 801e534:	681a      	ldr	r2, [r3, #0]
 801e536:	687b      	ldr	r3, [r7, #4]
 801e538:	681b      	ldr	r3, [r3, #0]
 801e53a:	009b      	lsls	r3, r3, #2
 801e53c:	4413      	add	r3, r2
 801e53e:	681b      	ldr	r3, [r3, #0]
 801e540:	e000      	b.n	801e544 <get_next_item+0x68>
        else return NULL;
 801e542:	2300      	movs	r3, #0
    }
}
 801e544:	4618      	mov	r0, r3
 801e546:	3714      	adds	r7, #20
 801e548:	46bd      	mov	sp, r7
 801e54a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e54e:	4770      	bx	lr

0801e550 <lv_obj_get_width_with_margin>:

static int32_t lv_obj_get_width_with_margin(const lv_obj_t * obj)
{
 801e550:	b590      	push	{r4, r7, lr}
 801e552:	b083      	sub	sp, #12
 801e554:	af00      	add	r7, sp, #0
 801e556:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_margin_left(obj, LV_PART_MAIN)
 801e558:	2100      	movs	r1, #0
 801e55a:	6878      	ldr	r0, [r7, #4]
 801e55c:	f7fe feb5 	bl	801d2ca <lv_obj_get_style_margin_left>
 801e560:	4604      	mov	r4, r0
           + lv_obj_get_width(obj)
 801e562:	6878      	ldr	r0, [r7, #4]
 801e564:	f7e7 fbe4 	bl	8005d30 <lv_obj_get_width>
 801e568:	4603      	mov	r3, r0
 801e56a:	441c      	add	r4, r3
           + lv_obj_get_style_margin_right(obj, LV_PART_MAIN);
 801e56c:	2100      	movs	r1, #0
 801e56e:	6878      	ldr	r0, [r7, #4]
 801e570:	f7fe febc 	bl	801d2ec <lv_obj_get_style_margin_right>
 801e574:	4603      	mov	r3, r0
 801e576:	4423      	add	r3, r4
}
 801e578:	4618      	mov	r0, r3
 801e57a:	370c      	adds	r7, #12
 801e57c:	46bd      	mov	sp, r7
 801e57e:	bd90      	pop	{r4, r7, pc}

0801e580 <lv_obj_get_height_with_margin>:

static int32_t lv_obj_get_height_with_margin(const lv_obj_t * obj)
{
 801e580:	b590      	push	{r4, r7, lr}
 801e582:	b083      	sub	sp, #12
 801e584:	af00      	add	r7, sp, #0
 801e586:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_margin_top(obj, LV_PART_MAIN)
 801e588:	2100      	movs	r1, #0
 801e58a:	6878      	ldr	r0, [r7, #4]
 801e58c:	f7fe fe7b 	bl	801d286 <lv_obj_get_style_margin_top>
 801e590:	4604      	mov	r4, r0
           + lv_obj_get_height(obj)
 801e592:	6878      	ldr	r0, [r7, #4]
 801e594:	f7e7 fbda 	bl	8005d4c <lv_obj_get_height>
 801e598:	4603      	mov	r3, r0
 801e59a:	441c      	add	r4, r3
           + lv_obj_get_style_margin_bottom(obj, LV_PART_MAIN);
 801e59c:	2100      	movs	r1, #0
 801e59e:	6878      	ldr	r0, [r7, #4]
 801e5a0:	f7fe fe82 	bl	801d2a8 <lv_obj_get_style_margin_bottom>
 801e5a4:	4603      	mov	r3, r0
 801e5a6:	4423      	add	r3, r4
}
 801e5a8:	4618      	mov	r0, r3
 801e5aa:	370c      	adds	r7, #12
 801e5ac:	46bd      	mov	sp, r7
 801e5ae:	bd90      	pop	{r4, r7, pc}

0801e5b0 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 801e5b0:	b480      	push	{r7}
 801e5b2:	b083      	sub	sp, #12
 801e5b4:	af00      	add	r7, sp, #0
 801e5b6:	6078      	str	r0, [r7, #4]
 801e5b8:	6039      	str	r1, [r7, #0]
    dest->x1 = src->x1;
 801e5ba:	683b      	ldr	r3, [r7, #0]
 801e5bc:	681a      	ldr	r2, [r3, #0]
 801e5be:	687b      	ldr	r3, [r7, #4]
 801e5c0:	601a      	str	r2, [r3, #0]
    dest->y1 = src->y1;
 801e5c2:	683b      	ldr	r3, [r7, #0]
 801e5c4:	685a      	ldr	r2, [r3, #4]
 801e5c6:	687b      	ldr	r3, [r7, #4]
 801e5c8:	605a      	str	r2, [r3, #4]
    dest->x2 = src->x2;
 801e5ca:	683b      	ldr	r3, [r7, #0]
 801e5cc:	689a      	ldr	r2, [r3, #8]
 801e5ce:	687b      	ldr	r3, [r7, #4]
 801e5d0:	609a      	str	r2, [r3, #8]
    dest->y2 = src->y2;
 801e5d2:	683b      	ldr	r3, [r7, #0]
 801e5d4:	68da      	ldr	r2, [r3, #12]
 801e5d6:	687b      	ldr	r3, [r7, #4]
 801e5d8:	60da      	str	r2, [r3, #12]
}
 801e5da:	bf00      	nop
 801e5dc:	370c      	adds	r7, #12
 801e5de:	46bd      	mov	sp, r7
 801e5e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e5e4:	4770      	bx	lr

0801e5e6 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline int32_t lv_area_get_width(const lv_area_t * area_p)
{
 801e5e6:	b480      	push	{r7}
 801e5e8:	b083      	sub	sp, #12
 801e5ea:	af00      	add	r7, sp, #0
 801e5ec:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 801e5ee:	687b      	ldr	r3, [r7, #4]
 801e5f0:	689a      	ldr	r2, [r3, #8]
 801e5f2:	687b      	ldr	r3, [r7, #4]
 801e5f4:	681b      	ldr	r3, [r3, #0]
 801e5f6:	1ad3      	subs	r3, r2, r3
 801e5f8:	3301      	adds	r3, #1
}
 801e5fa:	4618      	mov	r0, r3
 801e5fc:	370c      	adds	r7, #12
 801e5fe:	46bd      	mov	sp, r7
 801e600:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e604:	4770      	bx	lr

0801e606 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline int32_t lv_area_get_height(const lv_area_t * area_p)
{
 801e606:	b480      	push	{r7}
 801e608:	b083      	sub	sp, #12
 801e60a:	af00      	add	r7, sp, #0
 801e60c:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 801e60e:	687b      	ldr	r3, [r7, #4]
 801e610:	68da      	ldr	r2, [r3, #12]
 801e612:	687b      	ldr	r3, [r7, #4]
 801e614:	685b      	ldr	r3, [r3, #4]
 801e616:	1ad3      	subs	r3, r2, r3
 801e618:	3301      	adds	r3, #1
}
 801e61a:	4618      	mov	r0, r3
 801e61c:	370c      	adds	r7, #12
 801e61e:	46bd      	mov	sp, r7
 801e620:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e624:	4770      	bx	lr

0801e626 <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 801e626:	b580      	push	{r7, lr}
 801e628:	b082      	sub	sp, #8
 801e62a:	af00      	add	r7, sp, #0
 801e62c:	6078      	str	r0, [r7, #4]
 801e62e:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 801e630:	683a      	ldr	r2, [r7, #0]
 801e632:	2100      	movs	r1, #0
 801e634:	6878      	ldr	r0, [r7, #4]
 801e636:	f006 fbf4 	bl	8024e22 <lv_memset>
}
 801e63a:	bf00      	nop
 801e63c:	3708      	adds	r7, #8
 801e63e:	46bd      	mov	sp, r7
 801e640:	bd80      	pop	{r7, pc}

0801e642 <lv_obj_get_style_width>:
#include "../misc/lv_area.h"
#include "../misc/lv_style.h"
#include "../core/lv_obj_style.h"

static inline int32_t lv_obj_get_style_width(const lv_obj_t * obj, uint32_t part)
{
 801e642:	b580      	push	{r7, lr}
 801e644:	b084      	sub	sp, #16
 801e646:	af00      	add	r7, sp, #0
 801e648:	6078      	str	r0, [r7, #4]
 801e64a:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_WIDTH);
 801e64c:	2201      	movs	r2, #1
 801e64e:	6839      	ldr	r1, [r7, #0]
 801e650:	6878      	ldr	r0, [r7, #4]
 801e652:	f7eb f869 	bl	8009728 <lv_obj_get_style_prop>
 801e656:	4603      	mov	r3, r0
 801e658:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e65a:	68fb      	ldr	r3, [r7, #12]
}
 801e65c:	4618      	mov	r0, r3
 801e65e:	3710      	adds	r7, #16
 801e660:	46bd      	mov	sp, r7
 801e662:	bd80      	pop	{r7, pc}

0801e664 <lv_obj_get_style_height>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MAX_WIDTH);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_height(const lv_obj_t * obj, uint32_t part)
{
 801e664:	b580      	push	{r7, lr}
 801e666:	b084      	sub	sp, #16
 801e668:	af00      	add	r7, sp, #0
 801e66a:	6078      	str	r0, [r7, #4]
 801e66c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_HEIGHT);
 801e66e:	2202      	movs	r2, #2
 801e670:	6839      	ldr	r1, [r7, #0]
 801e672:	6878      	ldr	r0, [r7, #4]
 801e674:	f7eb f858 	bl	8009728 <lv_obj_get_style_prop>
 801e678:	4603      	mov	r3, r0
 801e67a:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e67c:	68fb      	ldr	r3, [r7, #12]
}
 801e67e:	4618      	mov	r0, r3
 801e680:	3710      	adds	r7, #16
 801e682:	46bd      	mov	sp, r7
 801e684:	bd80      	pop	{r7, pc}

0801e686 <lv_obj_get_style_translate_x>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_HEIGHT);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_translate_x(const lv_obj_t * obj, uint32_t part)
{
 801e686:	b580      	push	{r7, lr}
 801e688:	b084      	sub	sp, #16
 801e68a:	af00      	add	r7, sp, #0
 801e68c:	6078      	str	r0, [r7, #4]
 801e68e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSLATE_X);
 801e690:	226a      	movs	r2, #106	@ 0x6a
 801e692:	6839      	ldr	r1, [r7, #0]
 801e694:	6878      	ldr	r0, [r7, #4]
 801e696:	f7eb f847 	bl	8009728 <lv_obj_get_style_prop>
 801e69a:	4603      	mov	r3, r0
 801e69c:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e69e:	68fb      	ldr	r3, [r7, #12]
}
 801e6a0:	4618      	mov	r0, r3
 801e6a2:	3710      	adds	r7, #16
 801e6a4:	46bd      	mov	sp, r7
 801e6a6:	bd80      	pop	{r7, pc}

0801e6a8 <lv_obj_get_style_translate_y>:

static inline int32_t lv_obj_get_style_translate_y(const lv_obj_t * obj, uint32_t part)
{
 801e6a8:	b580      	push	{r7, lr}
 801e6aa:	b084      	sub	sp, #16
 801e6ac:	af00      	add	r7, sp, #0
 801e6ae:	6078      	str	r0, [r7, #4]
 801e6b0:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSLATE_Y);
 801e6b2:	226b      	movs	r2, #107	@ 0x6b
 801e6b4:	6839      	ldr	r1, [r7, #0]
 801e6b6:	6878      	ldr	r0, [r7, #4]
 801e6b8:	f7eb f836 	bl	8009728 <lv_obj_get_style_prop>
 801e6bc:	4603      	mov	r3, r0
 801e6be:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e6c0:	68fb      	ldr	r3, [r7, #12]
}
 801e6c2:	4618      	mov	r0, r3
 801e6c4:	3710      	adds	r7, #16
 801e6c6:	46bd      	mov	sp, r7
 801e6c8:	bd80      	pop	{r7, pc}

0801e6ca <lv_obj_get_style_pad_top>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_SKEW_Y);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_pad_top(const lv_obj_t * obj, uint32_t part)
{
 801e6ca:	b580      	push	{r7, lr}
 801e6cc:	b084      	sub	sp, #16
 801e6ce:	af00      	add	r7, sp, #0
 801e6d0:	6078      	str	r0, [r7, #4]
 801e6d2:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_TOP);
 801e6d4:	2210      	movs	r2, #16
 801e6d6:	6839      	ldr	r1, [r7, #0]
 801e6d8:	6878      	ldr	r0, [r7, #4]
 801e6da:	f7eb f825 	bl	8009728 <lv_obj_get_style_prop>
 801e6de:	4603      	mov	r3, r0
 801e6e0:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e6e2:	68fb      	ldr	r3, [r7, #12]
}
 801e6e4:	4618      	mov	r0, r3
 801e6e6:	3710      	adds	r7, #16
 801e6e8:	46bd      	mov	sp, r7
 801e6ea:	bd80      	pop	{r7, pc}

0801e6ec <lv_obj_get_style_pad_left>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_BOTTOM);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_pad_left(const lv_obj_t * obj, uint32_t part)
{
 801e6ec:	b580      	push	{r7, lr}
 801e6ee:	b084      	sub	sp, #16
 801e6f0:	af00      	add	r7, sp, #0
 801e6f2:	6078      	str	r0, [r7, #4]
 801e6f4:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_LEFT);
 801e6f6:	2212      	movs	r2, #18
 801e6f8:	6839      	ldr	r1, [r7, #0]
 801e6fa:	6878      	ldr	r0, [r7, #4]
 801e6fc:	f7eb f814 	bl	8009728 <lv_obj_get_style_prop>
 801e700:	4603      	mov	r3, r0
 801e702:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e704:	68fb      	ldr	r3, [r7, #12]
}
 801e706:	4618      	mov	r0, r3
 801e708:	3710      	adds	r7, #16
 801e70a:	46bd      	mov	sp, r7
 801e70c:	bd80      	pop	{r7, pc}

0801e70e <lv_obj_get_style_pad_row>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_RIGHT);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_pad_row(const lv_obj_t * obj, uint32_t part)
{
 801e70e:	b580      	push	{r7, lr}
 801e710:	b084      	sub	sp, #16
 801e712:	af00      	add	r7, sp, #0
 801e714:	6078      	str	r0, [r7, #4]
 801e716:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_ROW);
 801e718:	2214      	movs	r2, #20
 801e71a:	6839      	ldr	r1, [r7, #0]
 801e71c:	6878      	ldr	r0, [r7, #4]
 801e71e:	f7eb f803 	bl	8009728 <lv_obj_get_style_prop>
 801e722:	4603      	mov	r3, r0
 801e724:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e726:	68fb      	ldr	r3, [r7, #12]
}
 801e728:	4618      	mov	r0, r3
 801e72a:	3710      	adds	r7, #16
 801e72c:	46bd      	mov	sp, r7
 801e72e:	bd80      	pop	{r7, pc}

0801e730 <lv_obj_get_style_pad_column>:

static inline int32_t lv_obj_get_style_pad_column(const lv_obj_t * obj, uint32_t part)
{
 801e730:	b580      	push	{r7, lr}
 801e732:	b084      	sub	sp, #16
 801e734:	af00      	add	r7, sp, #0
 801e736:	6078      	str	r0, [r7, #4]
 801e738:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_COLUMN);
 801e73a:	2215      	movs	r2, #21
 801e73c:	6839      	ldr	r1, [r7, #0]
 801e73e:	6878      	ldr	r0, [r7, #4]
 801e740:	f7ea fff2 	bl	8009728 <lv_obj_get_style_prop>
 801e744:	4603      	mov	r3, r0
 801e746:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e748:	68fb      	ldr	r3, [r7, #12]
}
 801e74a:	4618      	mov	r0, r3
 801e74c:	3710      	adds	r7, #16
 801e74e:	46bd      	mov	sp, r7
 801e750:	bd80      	pop	{r7, pc}

0801e752 <lv_obj_get_style_margin_top>:

static inline int32_t lv_obj_get_style_margin_top(const lv_obj_t * obj, uint32_t part)
{
 801e752:	b580      	push	{r7, lr}
 801e754:	b084      	sub	sp, #16
 801e756:	af00      	add	r7, sp, #0
 801e758:	6078      	str	r0, [r7, #4]
 801e75a:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_TOP);
 801e75c:	2218      	movs	r2, #24
 801e75e:	6839      	ldr	r1, [r7, #0]
 801e760:	6878      	ldr	r0, [r7, #4]
 801e762:	f7ea ffe1 	bl	8009728 <lv_obj_get_style_prop>
 801e766:	4603      	mov	r3, r0
 801e768:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e76a:	68fb      	ldr	r3, [r7, #12]
}
 801e76c:	4618      	mov	r0, r3
 801e76e:	3710      	adds	r7, #16
 801e770:	46bd      	mov	sp, r7
 801e772:	bd80      	pop	{r7, pc}

0801e774 <lv_obj_get_style_margin_bottom>:

static inline int32_t lv_obj_get_style_margin_bottom(const lv_obj_t * obj, uint32_t part)
{
 801e774:	b580      	push	{r7, lr}
 801e776:	b084      	sub	sp, #16
 801e778:	af00      	add	r7, sp, #0
 801e77a:	6078      	str	r0, [r7, #4]
 801e77c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_BOTTOM);
 801e77e:	2219      	movs	r2, #25
 801e780:	6839      	ldr	r1, [r7, #0]
 801e782:	6878      	ldr	r0, [r7, #4]
 801e784:	f7ea ffd0 	bl	8009728 <lv_obj_get_style_prop>
 801e788:	4603      	mov	r3, r0
 801e78a:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e78c:	68fb      	ldr	r3, [r7, #12]
}
 801e78e:	4618      	mov	r0, r3
 801e790:	3710      	adds	r7, #16
 801e792:	46bd      	mov	sp, r7
 801e794:	bd80      	pop	{r7, pc}

0801e796 <lv_obj_get_style_margin_left>:

static inline int32_t lv_obj_get_style_margin_left(const lv_obj_t * obj, uint32_t part)
{
 801e796:	b580      	push	{r7, lr}
 801e798:	b084      	sub	sp, #16
 801e79a:	af00      	add	r7, sp, #0
 801e79c:	6078      	str	r0, [r7, #4]
 801e79e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_LEFT);
 801e7a0:	221a      	movs	r2, #26
 801e7a2:	6839      	ldr	r1, [r7, #0]
 801e7a4:	6878      	ldr	r0, [r7, #4]
 801e7a6:	f7ea ffbf 	bl	8009728 <lv_obj_get_style_prop>
 801e7aa:	4603      	mov	r3, r0
 801e7ac:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e7ae:	68fb      	ldr	r3, [r7, #12]
}
 801e7b0:	4618      	mov	r0, r3
 801e7b2:	3710      	adds	r7, #16
 801e7b4:	46bd      	mov	sp, r7
 801e7b6:	bd80      	pop	{r7, pc}

0801e7b8 <lv_obj_get_style_margin_right>:

static inline int32_t lv_obj_get_style_margin_right(const lv_obj_t * obj, uint32_t part)
{
 801e7b8:	b580      	push	{r7, lr}
 801e7ba:	b084      	sub	sp, #16
 801e7bc:	af00      	add	r7, sp, #0
 801e7be:	6078      	str	r0, [r7, #4]
 801e7c0:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_RIGHT);
 801e7c2:	221b      	movs	r2, #27
 801e7c4:	6839      	ldr	r1, [r7, #0]
 801e7c6:	6878      	ldr	r0, [r7, #4]
 801e7c8:	f7ea ffae 	bl	8009728 <lv_obj_get_style_prop>
 801e7cc:	4603      	mov	r3, r0
 801e7ce:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e7d0:	68fb      	ldr	r3, [r7, #12]
}
 801e7d2:	4618      	mov	r0, r3
 801e7d4:	3710      	adds	r7, #16
 801e7d6:	46bd      	mov	sp, r7
 801e7d8:	bd80      	pop	{r7, pc}

0801e7da <lv_obj_get_style_border_width>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_OPA);
    return (lv_opa_t)v.num;
}

static inline int32_t lv_obj_get_style_border_width(const lv_obj_t * obj, uint32_t part)
{
 801e7da:	b580      	push	{r7, lr}
 801e7dc:	b084      	sub	sp, #16
 801e7de:	af00      	add	r7, sp, #0
 801e7e0:	6078      	str	r0, [r7, #4]
 801e7e2:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_WIDTH);
 801e7e4:	2230      	movs	r2, #48	@ 0x30
 801e7e6:	6839      	ldr	r1, [r7, #0]
 801e7e8:	6878      	ldr	r0, [r7, #4]
 801e7ea:	f7ea ff9d 	bl	8009728 <lv_obj_get_style_prop>
 801e7ee:	4603      	mov	r3, r0
 801e7f0:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e7f2:	68fb      	ldr	r3, [r7, #12]
}
 801e7f4:	4618      	mov	r0, r3
 801e7f6:	3710      	adds	r7, #16
 801e7f8:	46bd      	mov	sp, r7
 801e7fa:	bd80      	pop	{r7, pc}

0801e7fc <lv_obj_get_style_border_side>:

static inline lv_border_side_t lv_obj_get_style_border_side(const lv_obj_t * obj, uint32_t part)
{
 801e7fc:	b580      	push	{r7, lr}
 801e7fe:	b084      	sub	sp, #16
 801e800:	af00      	add	r7, sp, #0
 801e802:	6078      	str	r0, [r7, #4]
 801e804:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BORDER_SIDE);
 801e806:	2234      	movs	r2, #52	@ 0x34
 801e808:	6839      	ldr	r1, [r7, #0]
 801e80a:	6878      	ldr	r0, [r7, #4]
 801e80c:	f7ea ff8c 	bl	8009728 <lv_obj_get_style_prop>
 801e810:	4603      	mov	r3, r0
 801e812:	60fb      	str	r3, [r7, #12]
    return (lv_border_side_t)v.num;
 801e814:	68fb      	ldr	r3, [r7, #12]
 801e816:	b2db      	uxtb	r3, r3
}
 801e818:	4618      	mov	r0, r3
 801e81a:	3710      	adds	r7, #16
 801e81c:	46bd      	mov	sp, r7
 801e81e:	bd80      	pop	{r7, pc}

0801e820 <lv_obj_get_style_base_dir>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LAYOUT);
    return (uint16_t)v.num;
}

static inline lv_base_dir_t lv_obj_get_style_base_dir(const lv_obj_t * obj, uint32_t part)
{
 801e820:	b580      	push	{r7, lr}
 801e822:	b084      	sub	sp, #16
 801e824:	af00      	add	r7, sp, #0
 801e826:	6078      	str	r0, [r7, #4]
 801e828:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BASE_DIR);
 801e82a:	2227      	movs	r2, #39	@ 0x27
 801e82c:	6839      	ldr	r1, [r7, #0]
 801e82e:	6878      	ldr	r0, [r7, #4]
 801e830:	f7ea ff7a 	bl	8009728 <lv_obj_get_style_prop>
 801e834:	4603      	mov	r3, r0
 801e836:	60fb      	str	r3, [r7, #12]
    return (lv_base_dir_t)v.num;
 801e838:	68fb      	ldr	r3, [r7, #12]
 801e83a:	b2db      	uxtb	r3, r3
}
 801e83c:	4618      	mov	r0, r3
 801e83e:	3710      	adds	r7, #16
 801e840:	46bd      	mov	sp, r7
 801e842:	bd80      	pop	{r7, pc}

0801e844 <lv_obj_get_style_grid_column_dsc_array>:
#endif /*LV_USE_FLEX*/

#if LV_USE_GRID

static inline const int32_t * lv_obj_get_style_grid_column_dsc_array(const lv_obj_t * obj, uint32_t part)
{
 801e844:	b580      	push	{r7, lr}
 801e846:	b084      	sub	sp, #16
 801e848:	af00      	add	r7, sp, #0
 801e84a:	6078      	str	r0, [r7, #4]
 801e84c:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_COLUMN_DSC_ARRAY);
 801e84e:	2285      	movs	r2, #133	@ 0x85
 801e850:	6839      	ldr	r1, [r7, #0]
 801e852:	6878      	ldr	r0, [r7, #4]
 801e854:	f7ea ff68 	bl	8009728 <lv_obj_get_style_prop>
 801e858:	4603      	mov	r3, r0
 801e85a:	60fb      	str	r3, [r7, #12]
    return (const int32_t *)v.ptr;
 801e85c:	68fb      	ldr	r3, [r7, #12]
}
 801e85e:	4618      	mov	r0, r3
 801e860:	3710      	adds	r7, #16
 801e862:	46bd      	mov	sp, r7
 801e864:	bd80      	pop	{r7, pc}

0801e866 <lv_obj_get_style_grid_column_align>:

static inline lv_grid_align_t lv_obj_get_style_grid_column_align(const lv_obj_t * obj, uint32_t part)
{
 801e866:	b580      	push	{r7, lr}
 801e868:	b084      	sub	sp, #16
 801e86a:	af00      	add	r7, sp, #0
 801e86c:	6078      	str	r0, [r7, #4]
 801e86e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_COLUMN_ALIGN);
 801e870:	2282      	movs	r2, #130	@ 0x82
 801e872:	6839      	ldr	r1, [r7, #0]
 801e874:	6878      	ldr	r0, [r7, #4]
 801e876:	f7ea ff57 	bl	8009728 <lv_obj_get_style_prop>
 801e87a:	4603      	mov	r3, r0
 801e87c:	60fb      	str	r3, [r7, #12]
    return (lv_grid_align_t)v.num;
 801e87e:	68fb      	ldr	r3, [r7, #12]
 801e880:	b2db      	uxtb	r3, r3
}
 801e882:	4618      	mov	r0, r3
 801e884:	3710      	adds	r7, #16
 801e886:	46bd      	mov	sp, r7
 801e888:	bd80      	pop	{r7, pc}

0801e88a <lv_obj_get_style_grid_row_dsc_array>:

static inline const int32_t * lv_obj_get_style_grid_row_dsc_array(const lv_obj_t * obj, uint32_t part)
{
 801e88a:	b580      	push	{r7, lr}
 801e88c:	b084      	sub	sp, #16
 801e88e:	af00      	add	r7, sp, #0
 801e890:	6078      	str	r0, [r7, #4]
 801e892:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_ROW_DSC_ARRAY);
 801e894:	2284      	movs	r2, #132	@ 0x84
 801e896:	6839      	ldr	r1, [r7, #0]
 801e898:	6878      	ldr	r0, [r7, #4]
 801e89a:	f7ea ff45 	bl	8009728 <lv_obj_get_style_prop>
 801e89e:	4603      	mov	r3, r0
 801e8a0:	60fb      	str	r3, [r7, #12]
    return (const int32_t *)v.ptr;
 801e8a2:	68fb      	ldr	r3, [r7, #12]
}
 801e8a4:	4618      	mov	r0, r3
 801e8a6:	3710      	adds	r7, #16
 801e8a8:	46bd      	mov	sp, r7
 801e8aa:	bd80      	pop	{r7, pc}

0801e8ac <lv_obj_get_style_grid_row_align>:

static inline lv_grid_align_t lv_obj_get_style_grid_row_align(const lv_obj_t * obj, uint32_t part)
{
 801e8ac:	b580      	push	{r7, lr}
 801e8ae:	b084      	sub	sp, #16
 801e8b0:	af00      	add	r7, sp, #0
 801e8b2:	6078      	str	r0, [r7, #4]
 801e8b4:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_ROW_ALIGN);
 801e8b6:	2283      	movs	r2, #131	@ 0x83
 801e8b8:	6839      	ldr	r1, [r7, #0]
 801e8ba:	6878      	ldr	r0, [r7, #4]
 801e8bc:	f7ea ff34 	bl	8009728 <lv_obj_get_style_prop>
 801e8c0:	4603      	mov	r3, r0
 801e8c2:	60fb      	str	r3, [r7, #12]
    return (lv_grid_align_t)v.num;
 801e8c4:	68fb      	ldr	r3, [r7, #12]
 801e8c6:	b2db      	uxtb	r3, r3
}
 801e8c8:	4618      	mov	r0, r3
 801e8ca:	3710      	adds	r7, #16
 801e8cc:	46bd      	mov	sp, r7
 801e8ce:	bd80      	pop	{r7, pc}

0801e8d0 <lv_obj_get_style_grid_cell_column_pos>:

static inline int32_t lv_obj_get_style_grid_cell_column_pos(const lv_obj_t * obj, uint32_t part)
{
 801e8d0:	b580      	push	{r7, lr}
 801e8d2:	b084      	sub	sp, #16
 801e8d4:	af00      	add	r7, sp, #0
 801e8d6:	6078      	str	r0, [r7, #4]
 801e8d8:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_CELL_COLUMN_POS);
 801e8da:	2286      	movs	r2, #134	@ 0x86
 801e8dc:	6839      	ldr	r1, [r7, #0]
 801e8de:	6878      	ldr	r0, [r7, #4]
 801e8e0:	f7ea ff22 	bl	8009728 <lv_obj_get_style_prop>
 801e8e4:	4603      	mov	r3, r0
 801e8e6:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e8e8:	68fb      	ldr	r3, [r7, #12]
}
 801e8ea:	4618      	mov	r0, r3
 801e8ec:	3710      	adds	r7, #16
 801e8ee:	46bd      	mov	sp, r7
 801e8f0:	bd80      	pop	{r7, pc}

0801e8f2 <lv_obj_get_style_grid_cell_x_align>:

static inline lv_grid_align_t lv_obj_get_style_grid_cell_x_align(const lv_obj_t * obj, uint32_t part)
{
 801e8f2:	b580      	push	{r7, lr}
 801e8f4:	b084      	sub	sp, #16
 801e8f6:	af00      	add	r7, sp, #0
 801e8f8:	6078      	str	r0, [r7, #4]
 801e8fa:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_CELL_X_ALIGN);
 801e8fc:	2288      	movs	r2, #136	@ 0x88
 801e8fe:	6839      	ldr	r1, [r7, #0]
 801e900:	6878      	ldr	r0, [r7, #4]
 801e902:	f7ea ff11 	bl	8009728 <lv_obj_get_style_prop>
 801e906:	4603      	mov	r3, r0
 801e908:	60fb      	str	r3, [r7, #12]
    return (lv_grid_align_t)v.num;
 801e90a:	68fb      	ldr	r3, [r7, #12]
 801e90c:	b2db      	uxtb	r3, r3
}
 801e90e:	4618      	mov	r0, r3
 801e910:	3710      	adds	r7, #16
 801e912:	46bd      	mov	sp, r7
 801e914:	bd80      	pop	{r7, pc}

0801e916 <lv_obj_get_style_grid_cell_column_span>:

static inline int32_t lv_obj_get_style_grid_cell_column_span(const lv_obj_t * obj, uint32_t part)
{
 801e916:	b580      	push	{r7, lr}
 801e918:	b084      	sub	sp, #16
 801e91a:	af00      	add	r7, sp, #0
 801e91c:	6078      	str	r0, [r7, #4]
 801e91e:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_CELL_COLUMN_SPAN);
 801e920:	2287      	movs	r2, #135	@ 0x87
 801e922:	6839      	ldr	r1, [r7, #0]
 801e924:	6878      	ldr	r0, [r7, #4]
 801e926:	f7ea feff 	bl	8009728 <lv_obj_get_style_prop>
 801e92a:	4603      	mov	r3, r0
 801e92c:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e92e:	68fb      	ldr	r3, [r7, #12]
}
 801e930:	4618      	mov	r0, r3
 801e932:	3710      	adds	r7, #16
 801e934:	46bd      	mov	sp, r7
 801e936:	bd80      	pop	{r7, pc}

0801e938 <lv_obj_get_style_grid_cell_row_pos>:

static inline int32_t lv_obj_get_style_grid_cell_row_pos(const lv_obj_t * obj, uint32_t part)
{
 801e938:	b580      	push	{r7, lr}
 801e93a:	b084      	sub	sp, #16
 801e93c:	af00      	add	r7, sp, #0
 801e93e:	6078      	str	r0, [r7, #4]
 801e940:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_CELL_ROW_POS);
 801e942:	2289      	movs	r2, #137	@ 0x89
 801e944:	6839      	ldr	r1, [r7, #0]
 801e946:	6878      	ldr	r0, [r7, #4]
 801e948:	f7ea feee 	bl	8009728 <lv_obj_get_style_prop>
 801e94c:	4603      	mov	r3, r0
 801e94e:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e950:	68fb      	ldr	r3, [r7, #12]
}
 801e952:	4618      	mov	r0, r3
 801e954:	3710      	adds	r7, #16
 801e956:	46bd      	mov	sp, r7
 801e958:	bd80      	pop	{r7, pc}

0801e95a <lv_obj_get_style_grid_cell_y_align>:

static inline lv_grid_align_t lv_obj_get_style_grid_cell_y_align(const lv_obj_t * obj, uint32_t part)
{
 801e95a:	b580      	push	{r7, lr}
 801e95c:	b084      	sub	sp, #16
 801e95e:	af00      	add	r7, sp, #0
 801e960:	6078      	str	r0, [r7, #4]
 801e962:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_CELL_Y_ALIGN);
 801e964:	228b      	movs	r2, #139	@ 0x8b
 801e966:	6839      	ldr	r1, [r7, #0]
 801e968:	6878      	ldr	r0, [r7, #4]
 801e96a:	f7ea fedd 	bl	8009728 <lv_obj_get_style_prop>
 801e96e:	4603      	mov	r3, r0
 801e970:	60fb      	str	r3, [r7, #12]
    return (lv_grid_align_t)v.num;
 801e972:	68fb      	ldr	r3, [r7, #12]
 801e974:	b2db      	uxtb	r3, r3
}
 801e976:	4618      	mov	r0, r3
 801e978:	3710      	adds	r7, #16
 801e97a:	46bd      	mov	sp, r7
 801e97c:	bd80      	pop	{r7, pc}

0801e97e <lv_obj_get_style_grid_cell_row_span>:

static inline int32_t lv_obj_get_style_grid_cell_row_span(const lv_obj_t * obj, uint32_t part)
{
 801e97e:	b580      	push	{r7, lr}
 801e980:	b084      	sub	sp, #16
 801e982:	af00      	add	r7, sp, #0
 801e984:	6078      	str	r0, [r7, #4]
 801e986:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_GRID_CELL_ROW_SPAN);
 801e988:	228a      	movs	r2, #138	@ 0x8a
 801e98a:	6839      	ldr	r1, [r7, #0]
 801e98c:	6878      	ldr	r0, [r7, #4]
 801e98e:	f7ea fecb 	bl	8009728 <lv_obj_get_style_prop>
 801e992:	4603      	mov	r3, r0
 801e994:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 801e996:	68fb      	ldr	r3, [r7, #12]
}
 801e998:	4618      	mov	r0, r3
 801e99a:	3710      	adds	r7, #16
 801e99c:	46bd      	mov	sp, r7
 801e99e:	bd80      	pop	{r7, pc}

0801e9a0 <lv_obj_get_style_space_left>:
    lv_obj_set_style_transform_scale_x(obj, value, selector);
    lv_obj_set_style_transform_scale_y(obj, value, selector);
}

static inline int32_t lv_obj_get_style_space_left(const lv_obj_t * obj, uint32_t part)
{
 801e9a0:	b580      	push	{r7, lr}
 801e9a2:	b086      	sub	sp, #24
 801e9a4:	af00      	add	r7, sp, #0
 801e9a6:	6078      	str	r0, [r7, #4]
 801e9a8:	6039      	str	r1, [r7, #0]
    int32_t padding = lv_obj_get_style_pad_left(obj, part);
 801e9aa:	6839      	ldr	r1, [r7, #0]
 801e9ac:	6878      	ldr	r0, [r7, #4]
 801e9ae:	f7ff fe9d 	bl	801e6ec <lv_obj_get_style_pad_left>
 801e9b2:	6178      	str	r0, [r7, #20]
    int32_t border_width = lv_obj_get_style_border_width(obj, part);
 801e9b4:	6839      	ldr	r1, [r7, #0]
 801e9b6:	6878      	ldr	r0, [r7, #4]
 801e9b8:	f7ff ff0f 	bl	801e7da <lv_obj_get_style_border_width>
 801e9bc:	6138      	str	r0, [r7, #16]
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
 801e9be:	6839      	ldr	r1, [r7, #0]
 801e9c0:	6878      	ldr	r0, [r7, #4]
 801e9c2:	f7ff ff1b 	bl	801e7fc <lv_obj_get_style_border_side>
 801e9c6:	4603      	mov	r3, r0
 801e9c8:	73fb      	strb	r3, [r7, #15]
    return (border_side & LV_BORDER_SIDE_LEFT) ? padding + border_width : padding;
 801e9ca:	7bfb      	ldrb	r3, [r7, #15]
 801e9cc:	f003 0304 	and.w	r3, r3, #4
 801e9d0:	2b00      	cmp	r3, #0
 801e9d2:	d003      	beq.n	801e9dc <lv_obj_get_style_space_left+0x3c>
 801e9d4:	697a      	ldr	r2, [r7, #20]
 801e9d6:	693b      	ldr	r3, [r7, #16]
 801e9d8:	4413      	add	r3, r2
 801e9da:	e000      	b.n	801e9de <lv_obj_get_style_space_left+0x3e>
 801e9dc:	697b      	ldr	r3, [r7, #20]
}
 801e9de:	4618      	mov	r0, r3
 801e9e0:	3718      	adds	r7, #24
 801e9e2:	46bd      	mov	sp, r7
 801e9e4:	bd80      	pop	{r7, pc}

0801e9e6 <lv_obj_get_style_space_top>:
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
    return (border_side & LV_BORDER_SIDE_RIGHT) ? padding + border_width : padding;
}

static inline int32_t lv_obj_get_style_space_top(const lv_obj_t * obj, uint32_t part)
{
 801e9e6:	b580      	push	{r7, lr}
 801e9e8:	b086      	sub	sp, #24
 801e9ea:	af00      	add	r7, sp, #0
 801e9ec:	6078      	str	r0, [r7, #4]
 801e9ee:	6039      	str	r1, [r7, #0]
    int32_t padding = lv_obj_get_style_pad_top(obj, part);
 801e9f0:	6839      	ldr	r1, [r7, #0]
 801e9f2:	6878      	ldr	r0, [r7, #4]
 801e9f4:	f7ff fe69 	bl	801e6ca <lv_obj_get_style_pad_top>
 801e9f8:	6178      	str	r0, [r7, #20]
    int32_t border_width = lv_obj_get_style_border_width(obj, part);
 801e9fa:	6839      	ldr	r1, [r7, #0]
 801e9fc:	6878      	ldr	r0, [r7, #4]
 801e9fe:	f7ff feec 	bl	801e7da <lv_obj_get_style_border_width>
 801ea02:	6138      	str	r0, [r7, #16]
    lv_border_side_t border_side = lv_obj_get_style_border_side(obj, part);
 801ea04:	6839      	ldr	r1, [r7, #0]
 801ea06:	6878      	ldr	r0, [r7, #4]
 801ea08:	f7ff fef8 	bl	801e7fc <lv_obj_get_style_border_side>
 801ea0c:	4603      	mov	r3, r0
 801ea0e:	73fb      	strb	r3, [r7, #15]
    return (border_side & LV_BORDER_SIDE_TOP) ? padding + border_width : padding;
 801ea10:	7bfb      	ldrb	r3, [r7, #15]
 801ea12:	f003 0302 	and.w	r3, r3, #2
 801ea16:	2b00      	cmp	r3, #0
 801ea18:	d003      	beq.n	801ea22 <lv_obj_get_style_space_top+0x3c>
 801ea1a:	697a      	ldr	r2, [r7, #20]
 801ea1c:	693b      	ldr	r3, [r7, #16]
 801ea1e:	4413      	add	r3, r2
 801ea20:	e000      	b.n	801ea24 <lv_obj_get_style_space_top+0x3e>
 801ea22:	697b      	ldr	r3, [r7, #20]
}
 801ea24:	4618      	mov	r0, r3
 801ea26:	3718      	adds	r7, #24
 801ea28:	46bd      	mov	sp, r7
 801ea2a:	bd80      	pop	{r7, pc}

0801ea2c <get_col_dsc>:
                          uint32_t track_num,
                          int32_t * size_array, int32_t * pos_array, bool reverse);
static uint32_t count_tracks(const int32_t * templ);

static inline const int32_t * get_col_dsc(lv_obj_t * obj)
{
 801ea2c:	b580      	push	{r7, lr}
 801ea2e:	b082      	sub	sp, #8
 801ea30:	af00      	add	r7, sp, #0
 801ea32:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_grid_column_dsc_array(obj, 0);
 801ea34:	2100      	movs	r1, #0
 801ea36:	6878      	ldr	r0, [r7, #4]
 801ea38:	f7ff ff04 	bl	801e844 <lv_obj_get_style_grid_column_dsc_array>
 801ea3c:	4603      	mov	r3, r0
}
 801ea3e:	4618      	mov	r0, r3
 801ea40:	3708      	adds	r7, #8
 801ea42:	46bd      	mov	sp, r7
 801ea44:	bd80      	pop	{r7, pc}

0801ea46 <get_row_dsc>:
static inline const int32_t * get_row_dsc(lv_obj_t * obj)
{
 801ea46:	b580      	push	{r7, lr}
 801ea48:	b082      	sub	sp, #8
 801ea4a:	af00      	add	r7, sp, #0
 801ea4c:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_grid_row_dsc_array(obj, 0);
 801ea4e:	2100      	movs	r1, #0
 801ea50:	6878      	ldr	r0, [r7, #4]
 801ea52:	f7ff ff1a 	bl	801e88a <lv_obj_get_style_grid_row_dsc_array>
 801ea56:	4603      	mov	r3, r0
}
 801ea58:	4618      	mov	r0, r3
 801ea5a:	3708      	adds	r7, #8
 801ea5c:	46bd      	mov	sp, r7
 801ea5e:	bd80      	pop	{r7, pc}

0801ea60 <get_col_pos>:
static inline int32_t get_col_pos(lv_obj_t * obj)
{
 801ea60:	b580      	push	{r7, lr}
 801ea62:	b082      	sub	sp, #8
 801ea64:	af00      	add	r7, sp, #0
 801ea66:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_grid_cell_column_pos(obj, 0);
 801ea68:	2100      	movs	r1, #0
 801ea6a:	6878      	ldr	r0, [r7, #4]
 801ea6c:	f7ff ff30 	bl	801e8d0 <lv_obj_get_style_grid_cell_column_pos>
 801ea70:	4603      	mov	r3, r0
}
 801ea72:	4618      	mov	r0, r3
 801ea74:	3708      	adds	r7, #8
 801ea76:	46bd      	mov	sp, r7
 801ea78:	bd80      	pop	{r7, pc}

0801ea7a <get_row_pos>:
static inline int32_t get_row_pos(lv_obj_t * obj)
{
 801ea7a:	b580      	push	{r7, lr}
 801ea7c:	b082      	sub	sp, #8
 801ea7e:	af00      	add	r7, sp, #0
 801ea80:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_grid_cell_row_pos(obj, 0);
 801ea82:	2100      	movs	r1, #0
 801ea84:	6878      	ldr	r0, [r7, #4]
 801ea86:	f7ff ff57 	bl	801e938 <lv_obj_get_style_grid_cell_row_pos>
 801ea8a:	4603      	mov	r3, r0
}
 801ea8c:	4618      	mov	r0, r3
 801ea8e:	3708      	adds	r7, #8
 801ea90:	46bd      	mov	sp, r7
 801ea92:	bd80      	pop	{r7, pc}

0801ea94 <get_col_span>:
static inline int32_t get_col_span(lv_obj_t * obj)
{
 801ea94:	b580      	push	{r7, lr}
 801ea96:	b082      	sub	sp, #8
 801ea98:	af00      	add	r7, sp, #0
 801ea9a:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_grid_cell_column_span(obj, 0);
 801ea9c:	2100      	movs	r1, #0
 801ea9e:	6878      	ldr	r0, [r7, #4]
 801eaa0:	f7ff ff39 	bl	801e916 <lv_obj_get_style_grid_cell_column_span>
 801eaa4:	4603      	mov	r3, r0
}
 801eaa6:	4618      	mov	r0, r3
 801eaa8:	3708      	adds	r7, #8
 801eaaa:	46bd      	mov	sp, r7
 801eaac:	bd80      	pop	{r7, pc}

0801eaae <get_row_span>:
static inline int32_t get_row_span(lv_obj_t * obj)
{
 801eaae:	b580      	push	{r7, lr}
 801eab0:	b082      	sub	sp, #8
 801eab2:	af00      	add	r7, sp, #0
 801eab4:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_grid_cell_row_span(obj, 0);
 801eab6:	2100      	movs	r1, #0
 801eab8:	6878      	ldr	r0, [r7, #4]
 801eaba:	f7ff ff60 	bl	801e97e <lv_obj_get_style_grid_cell_row_span>
 801eabe:	4603      	mov	r3, r0
}
 801eac0:	4618      	mov	r0, r3
 801eac2:	3708      	adds	r7, #8
 801eac4:	46bd      	mov	sp, r7
 801eac6:	bd80      	pop	{r7, pc}

0801eac8 <get_cell_col_align>:
static inline lv_grid_align_t get_cell_col_align(lv_obj_t * obj)
{
 801eac8:	b580      	push	{r7, lr}
 801eaca:	b082      	sub	sp, #8
 801eacc:	af00      	add	r7, sp, #0
 801eace:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_grid_cell_x_align(obj, 0);
 801ead0:	2100      	movs	r1, #0
 801ead2:	6878      	ldr	r0, [r7, #4]
 801ead4:	f7ff ff0d 	bl	801e8f2 <lv_obj_get_style_grid_cell_x_align>
 801ead8:	4603      	mov	r3, r0
}
 801eada:	4618      	mov	r0, r3
 801eadc:	3708      	adds	r7, #8
 801eade:	46bd      	mov	sp, r7
 801eae0:	bd80      	pop	{r7, pc}

0801eae2 <get_cell_row_align>:
static inline lv_grid_align_t get_cell_row_align(lv_obj_t * obj)
{
 801eae2:	b580      	push	{r7, lr}
 801eae4:	b082      	sub	sp, #8
 801eae6:	af00      	add	r7, sp, #0
 801eae8:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_grid_cell_y_align(obj, 0);
 801eaea:	2100      	movs	r1, #0
 801eaec:	6878      	ldr	r0, [r7, #4]
 801eaee:	f7ff ff34 	bl	801e95a <lv_obj_get_style_grid_cell_y_align>
 801eaf2:	4603      	mov	r3, r0
}
 801eaf4:	4618      	mov	r0, r3
 801eaf6:	3708      	adds	r7, #8
 801eaf8:	46bd      	mov	sp, r7
 801eafa:	bd80      	pop	{r7, pc}

0801eafc <get_grid_col_align>:
static inline lv_grid_align_t get_grid_col_align(lv_obj_t * obj)
{
 801eafc:	b580      	push	{r7, lr}
 801eafe:	b082      	sub	sp, #8
 801eb00:	af00      	add	r7, sp, #0
 801eb02:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_grid_column_align(obj, 0);
 801eb04:	2100      	movs	r1, #0
 801eb06:	6878      	ldr	r0, [r7, #4]
 801eb08:	f7ff fead 	bl	801e866 <lv_obj_get_style_grid_column_align>
 801eb0c:	4603      	mov	r3, r0
}
 801eb0e:	4618      	mov	r0, r3
 801eb10:	3708      	adds	r7, #8
 801eb12:	46bd      	mov	sp, r7
 801eb14:	bd80      	pop	{r7, pc}

0801eb16 <get_grid_row_align>:
static inline lv_grid_align_t get_grid_row_align(lv_obj_t * obj)
{
 801eb16:	b580      	push	{r7, lr}
 801eb18:	b082      	sub	sp, #8
 801eb1a:	af00      	add	r7, sp, #0
 801eb1c:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_grid_row_align(obj, 0);
 801eb1e:	2100      	movs	r1, #0
 801eb20:	6878      	ldr	r0, [r7, #4]
 801eb22:	f7ff fec3 	bl	801e8ac <lv_obj_get_style_grid_row_align>
 801eb26:	4603      	mov	r3, r0
}
 801eb28:	4618      	mov	r0, r3
 801eb2a:	3708      	adds	r7, #8
 801eb2c:	46bd      	mov	sp, r7
 801eb2e:	bd80      	pop	{r7, pc}

0801eb30 <get_margin_hor>:
static inline int32_t get_margin_hor(lv_obj_t * obj)
{
 801eb30:	b590      	push	{r4, r7, lr}
 801eb32:	b083      	sub	sp, #12
 801eb34:	af00      	add	r7, sp, #0
 801eb36:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_margin_left(obj, LV_PART_MAIN)
 801eb38:	2100      	movs	r1, #0
 801eb3a:	6878      	ldr	r0, [r7, #4]
 801eb3c:	f7ff fe2b 	bl	801e796 <lv_obj_get_style_margin_left>
 801eb40:	4604      	mov	r4, r0
           + lv_obj_get_style_margin_right(obj, LV_PART_MAIN);
 801eb42:	2100      	movs	r1, #0
 801eb44:	6878      	ldr	r0, [r7, #4]
 801eb46:	f7ff fe37 	bl	801e7b8 <lv_obj_get_style_margin_right>
 801eb4a:	4603      	mov	r3, r0
 801eb4c:	4423      	add	r3, r4
}
 801eb4e:	4618      	mov	r0, r3
 801eb50:	370c      	adds	r7, #12
 801eb52:	46bd      	mov	sp, r7
 801eb54:	bd90      	pop	{r4, r7, pc}

0801eb56 <get_margin_ver>:
static inline int32_t get_margin_ver(lv_obj_t * obj)
{
 801eb56:	b590      	push	{r4, r7, lr}
 801eb58:	b083      	sub	sp, #12
 801eb5a:	af00      	add	r7, sp, #0
 801eb5c:	6078      	str	r0, [r7, #4]
    return lv_obj_get_style_margin_top(obj, LV_PART_MAIN)
 801eb5e:	2100      	movs	r1, #0
 801eb60:	6878      	ldr	r0, [r7, #4]
 801eb62:	f7ff fdf6 	bl	801e752 <lv_obj_get_style_margin_top>
 801eb66:	4604      	mov	r4, r0
           + lv_obj_get_style_margin_bottom(obj, LV_PART_MAIN);
 801eb68:	2100      	movs	r1, #0
 801eb6a:	6878      	ldr	r0, [r7, #4]
 801eb6c:	f7ff fe02 	bl	801e774 <lv_obj_get_style_margin_bottom>
 801eb70:	4603      	mov	r3, r0
 801eb72:	4423      	add	r3, r4
}
 801eb74:	4618      	mov	r0, r3
 801eb76:	370c      	adds	r7, #12
 801eb78:	46bd      	mov	sp, r7
 801eb7a:	bd90      	pop	{r4, r7, pc}

0801eb7c <lv_grid_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_grid_init(void)
{
 801eb7c:	b480      	push	{r7}
 801eb7e:	af00      	add	r7, sp, #0
    layout_list_def[LV_LAYOUT_GRID].cb = grid_update;
 801eb80:	4b07      	ldr	r3, [pc, #28]	@ (801eba0 <lv_grid_init+0x24>)
 801eb82:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801eb84:	3310      	adds	r3, #16
 801eb86:	4a07      	ldr	r2, [pc, #28]	@ (801eba4 <lv_grid_init+0x28>)
 801eb88:	601a      	str	r2, [r3, #0]
    layout_list_def[LV_LAYOUT_GRID].user_data = NULL;
 801eb8a:	4b05      	ldr	r3, [pc, #20]	@ (801eba0 <lv_grid_init+0x24>)
 801eb8c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801eb8e:	3310      	adds	r3, #16
 801eb90:	2200      	movs	r2, #0
 801eb92:	605a      	str	r2, [r3, #4]
}
 801eb94:	bf00      	nop
 801eb96:	46bd      	mov	sp, r7
 801eb98:	f85d 7b04 	ldr.w	r7, [sp], #4
 801eb9c:	4770      	bx	lr
 801eb9e:	bf00      	nop
 801eba0:	2000009c 	.word	0x2000009c
 801eba4:	0801eba9 	.word	0x0801eba9

0801eba8 <grid_update>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void grid_update(lv_obj_t * cont, void * user_data)
{
 801eba8:	b590      	push	{r4, r7, lr}
 801ebaa:	b095      	sub	sp, #84	@ 0x54
 801ebac:	af00      	add	r7, sp, #0
 801ebae:	6078      	str	r0, [r7, #4]
 801ebb0:	6039      	str	r1, [r7, #0]
    //    const int32_t * col_templ = get_col_dsc(cont);
    //    const int32_t * row_templ = get_row_dsc(cont);
    //    if(col_templ == NULL || row_templ == NULL) return;

    _lv_grid_calc_t c;
    calc(cont, &c);
 801ebb2:	f107 0318 	add.w	r3, r7, #24
 801ebb6:	4619      	mov	r1, r3
 801ebb8:	6878      	ldr	r0, [r7, #4]
 801ebba:	f000 f867 	bl	801ec8c <calc>

    item_repos_hint_t hint;
    lv_memzero(&hint, sizeof(hint));
 801ebbe:	f107 0308 	add.w	r3, r7, #8
 801ebc2:	2110      	movs	r1, #16
 801ebc4:	4618      	mov	r0, r3
 801ebc6:	f7ff fd2e 	bl	801e626 <lv_memzero>

    /*Calculate the grids absolute x and y coordinates.
     *It will be used as helper during item repositioning to avoid calculating this value for every children*/
    int32_t pad_left = lv_obj_get_style_space_left(cont, LV_PART_MAIN);
 801ebca:	2100      	movs	r1, #0
 801ebcc:	6878      	ldr	r0, [r7, #4]
 801ebce:	f7ff fee7 	bl	801e9a0 <lv_obj_get_style_space_left>
 801ebd2:	64b8      	str	r0, [r7, #72]	@ 0x48
    int32_t pad_top = lv_obj_get_style_space_top(cont, LV_PART_MAIN);
 801ebd4:	2100      	movs	r1, #0
 801ebd6:	6878      	ldr	r0, [r7, #4]
 801ebd8:	f7ff ff05 	bl	801e9e6 <lv_obj_get_style_space_top>
 801ebdc:	6478      	str	r0, [r7, #68]	@ 0x44
    hint.grid_abs.x = pad_left + cont->coords.x1 - lv_obj_get_scroll_x(cont);
 801ebde:	687b      	ldr	r3, [r7, #4]
 801ebe0:	695a      	ldr	r2, [r3, #20]
 801ebe2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801ebe4:	18d4      	adds	r4, r2, r3
 801ebe6:	6878      	ldr	r0, [r7, #4]
 801ebe8:	f7e8 fc28 	bl	800743c <lv_obj_get_scroll_x>
 801ebec:	4603      	mov	r3, r0
 801ebee:	1ae3      	subs	r3, r4, r3
 801ebf0:	613b      	str	r3, [r7, #16]
    hint.grid_abs.y = pad_top + cont->coords.y1 - lv_obj_get_scroll_y(cont);
 801ebf2:	687b      	ldr	r3, [r7, #4]
 801ebf4:	699a      	ldr	r2, [r3, #24]
 801ebf6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801ebf8:	18d4      	adds	r4, r2, r3
 801ebfa:	6878      	ldr	r0, [r7, #4]
 801ebfc:	f7e8 fc32 	bl	8007464 <lv_obj_get_scroll_y>
 801ec00:	4603      	mov	r3, r0
 801ec02:	1ae3      	subs	r3, r4, r3
 801ec04:	617b      	str	r3, [r7, #20]

    uint32_t i;
    for(i = 0; i < cont->spec_attr->child_cnt; i++) {
 801ec06:	2300      	movs	r3, #0
 801ec08:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801ec0a:	e012      	b.n	801ec32 <grid_update+0x8a>
        lv_obj_t * item = cont->spec_attr->children[i];
 801ec0c:	687b      	ldr	r3, [r7, #4]
 801ec0e:	689b      	ldr	r3, [r3, #8]
 801ec10:	681a      	ldr	r2, [r3, #0]
 801ec12:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ec14:	009b      	lsls	r3, r3, #2
 801ec16:	4413      	add	r3, r2
 801ec18:	681b      	ldr	r3, [r3, #0]
 801ec1a:	63bb      	str	r3, [r7, #56]	@ 0x38
        item_repos(item, &c, &hint);
 801ec1c:	f107 0208 	add.w	r2, r7, #8
 801ec20:	f107 0318 	add.w	r3, r7, #24
 801ec24:	4619      	mov	r1, r3
 801ec26:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801ec28:	f000 fbc6 	bl	801f3b8 <item_repos>
    for(i = 0; i < cont->spec_attr->child_cnt; i++) {
 801ec2c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ec2e:	3301      	adds	r3, #1
 801ec30:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801ec32:	687b      	ldr	r3, [r7, #4]
 801ec34:	689b      	ldr	r3, [r3, #8]
 801ec36:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 801ec38:	461a      	mov	r2, r3
 801ec3a:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ec3c:	4293      	cmp	r3, r2
 801ec3e:	d3e5      	bcc.n	801ec0c <grid_update+0x64>
    }
    calc_free(&c);
 801ec40:	f107 0318 	add.w	r3, r7, #24
 801ec44:	4618      	mov	r0, r3
 801ec46:	f000 f8c3 	bl	801edd0 <calc_free>

    int32_t w_set = lv_obj_get_style_width(cont, LV_PART_MAIN);
 801ec4a:	2100      	movs	r1, #0
 801ec4c:	6878      	ldr	r0, [r7, #4]
 801ec4e:	f7ff fcf8 	bl	801e642 <lv_obj_get_style_width>
 801ec52:	6438      	str	r0, [r7, #64]	@ 0x40
    int32_t h_set = lv_obj_get_style_height(cont, LV_PART_MAIN);
 801ec54:	2100      	movs	r1, #0
 801ec56:	6878      	ldr	r0, [r7, #4]
 801ec58:	f7ff fd04 	bl	801e664 <lv_obj_get_style_height>
 801ec5c:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if(w_set == LV_SIZE_CONTENT || h_set == LV_SIZE_CONTENT) {
 801ec5e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801ec60:	4a09      	ldr	r2, [pc, #36]	@ (801ec88 <grid_update+0xe0>)
 801ec62:	4293      	cmp	r3, r2
 801ec64:	d003      	beq.n	801ec6e <grid_update+0xc6>
 801ec66:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801ec68:	4a07      	ldr	r2, [pc, #28]	@ (801ec88 <grid_update+0xe0>)
 801ec6a:	4293      	cmp	r3, r2
 801ec6c:	d102      	bne.n	801ec74 <grid_update+0xcc>
        lv_obj_refr_size(cont);
 801ec6e:	6878      	ldr	r0, [r7, #4]
 801ec70:	f7e6 fdd2 	bl	8005818 <lv_obj_refr_size>
    }

    lv_obj_send_event(cont, LV_EVENT_LAYOUT_CHANGED, NULL);
 801ec74:	2200      	movs	r2, #0
 801ec76:	212d      	movs	r1, #45	@ 0x2d
 801ec78:	6878      	ldr	r0, [r7, #4]
 801ec7a:	f7e6 f8cb 	bl	8004e14 <lv_obj_send_event>

    LV_TRACE_LAYOUT("finished");
}
 801ec7e:	bf00      	nop
 801ec80:	3754      	adds	r7, #84	@ 0x54
 801ec82:	46bd      	mov	sp, r7
 801ec84:	bd90      	pop	{r4, r7, pc}
 801ec86:	bf00      	nop
 801ec88:	200007d1 	.word	0x200007d1

0801ec8c <calc>:
 * @param cont an object that has a grid
 * @param calc store the calculated cells sizes here
 * @note `_lv_grid_calc_free(calc_out)` needs to be called when `calc_out` is not needed anymore
 */
static void calc(lv_obj_t * cont, _lv_grid_calc_t * calc_out)
{
 801ec8c:	b5b0      	push	{r4, r5, r7, lr}
 801ec8e:	b090      	sub	sp, #64	@ 0x40
 801ec90:	af04      	add	r7, sp, #16
 801ec92:	6078      	str	r0, [r7, #4]
 801ec94:	6039      	str	r1, [r7, #0]
    if(lv_obj_get_child(cont, 0) == NULL) {
 801ec96:	2100      	movs	r1, #0
 801ec98:	6878      	ldr	r0, [r7, #4]
 801ec9a:	f7ec f8dc 	bl	800ae56 <lv_obj_get_child>
 801ec9e:	4603      	mov	r3, r0
 801eca0:	2b00      	cmp	r3, #0
 801eca2:	d104      	bne.n	801ecae <calc+0x22>
        lv_memzero(calc_out, sizeof(_lv_grid_calc_t));
 801eca4:	2120      	movs	r1, #32
 801eca6:	6838      	ldr	r0, [r7, #0]
 801eca8:	f7ff fcbd 	bl	801e626 <lv_memzero>
        return;
 801ecac:	e08b      	b.n	801edc6 <calc+0x13a>
    }

    calc_rows(cont, calc_out);
 801ecae:	6839      	ldr	r1, [r7, #0]
 801ecb0:	6878      	ldr	r0, [r7, #4]
 801ecb2:	f000 fa15 	bl	801f0e0 <calc_rows>
    calc_cols(cont, calc_out);
 801ecb6:	6839      	ldr	r1, [r7, #0]
 801ecb8:	6878      	ldr	r0, [r7, #4]
 801ecba:	f000 f8a5 	bl	801ee08 <calc_cols>

    int32_t col_gap = lv_obj_get_style_pad_column(cont, LV_PART_MAIN);
 801ecbe:	2100      	movs	r1, #0
 801ecc0:	6878      	ldr	r0, [r7, #4]
 801ecc2:	f7ff fd35 	bl	801e730 <lv_obj_get_style_pad_column>
 801ecc6:	62f8      	str	r0, [r7, #44]	@ 0x2c
    int32_t row_gap = lv_obj_get_style_pad_row(cont, LV_PART_MAIN);
 801ecc8:	2100      	movs	r1, #0
 801ecca:	6878      	ldr	r0, [r7, #4]
 801eccc:	f7ff fd1f 	bl	801e70e <lv_obj_get_style_pad_row>
 801ecd0:	62b8      	str	r0, [r7, #40]	@ 0x28

    bool rev = lv_obj_get_style_base_dir(cont, LV_PART_MAIN) == LV_BASE_DIR_RTL;
 801ecd2:	2100      	movs	r1, #0
 801ecd4:	6878      	ldr	r0, [r7, #4]
 801ecd6:	f7ff fda3 	bl	801e820 <lv_obj_get_style_base_dir>
 801ecda:	4603      	mov	r3, r0
 801ecdc:	2b01      	cmp	r3, #1
 801ecde:	bf0c      	ite	eq
 801ece0:	2301      	moveq	r3, #1
 801ece2:	2300      	movne	r3, #0
 801ece4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

    int32_t w_set = lv_obj_get_style_width(cont, LV_PART_MAIN);
 801ece8:	2100      	movs	r1, #0
 801ecea:	6878      	ldr	r0, [r7, #4]
 801ecec:	f7ff fca9 	bl	801e642 <lv_obj_get_style_width>
 801ecf0:	6238      	str	r0, [r7, #32]
    int32_t h_set = lv_obj_get_style_height(cont, LV_PART_MAIN);
 801ecf2:	2100      	movs	r1, #0
 801ecf4:	6878      	ldr	r0, [r7, #4]
 801ecf6:	f7ff fcb5 	bl	801e664 <lv_obj_get_style_height>
 801ecfa:	61f8      	str	r0, [r7, #28]
    bool auto_w = w_set == LV_SIZE_CONTENT && !cont->w_layout;
 801ecfc:	6a3b      	ldr	r3, [r7, #32]
 801ecfe:	4a33      	ldr	r2, [pc, #204]	@ (801edcc <calc+0x140>)
 801ed00:	4293      	cmp	r3, r2
 801ed02:	d109      	bne.n	801ed18 <calc+0x8c>
 801ed04:	687b      	ldr	r3, [r7, #4]
 801ed06:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 801ed0a:	f003 0308 	and.w	r3, r3, #8
 801ed0e:	b2db      	uxtb	r3, r3
 801ed10:	2b00      	cmp	r3, #0
 801ed12:	d101      	bne.n	801ed18 <calc+0x8c>
 801ed14:	2301      	movs	r3, #1
 801ed16:	e000      	b.n	801ed1a <calc+0x8e>
 801ed18:	2300      	movs	r3, #0
 801ed1a:	76fb      	strb	r3, [r7, #27]
 801ed1c:	7efb      	ldrb	r3, [r7, #27]
 801ed1e:	f003 0301 	and.w	r3, r3, #1
 801ed22:	76fb      	strb	r3, [r7, #27]
    int32_t cont_w = lv_obj_get_content_width(cont);
 801ed24:	6878      	ldr	r0, [r7, #4]
 801ed26:	f7e7 f81f 	bl	8005d68 <lv_obj_get_content_width>
 801ed2a:	6178      	str	r0, [r7, #20]
    calc_out->grid_w = grid_align(cont_w, auto_w, get_grid_col_align(cont), col_gap, calc_out->col_num, calc_out->w,
 801ed2c:	6878      	ldr	r0, [r7, #4]
 801ed2e:	f7ff fee5 	bl	801eafc <get_grid_col_align>
 801ed32:	4603      	mov	r3, r0
 801ed34:	461d      	mov	r5, r3
 801ed36:	683b      	ldr	r3, [r7, #0]
 801ed38:	691b      	ldr	r3, [r3, #16]
 801ed3a:	683a      	ldr	r2, [r7, #0]
 801ed3c:	6892      	ldr	r2, [r2, #8]
 801ed3e:	6839      	ldr	r1, [r7, #0]
 801ed40:	6809      	ldr	r1, [r1, #0]
 801ed42:	7efc      	ldrb	r4, [r7, #27]
 801ed44:	f897 0027 	ldrb.w	r0, [r7, #39]	@ 0x27
 801ed48:	9003      	str	r0, [sp, #12]
 801ed4a:	9102      	str	r1, [sp, #8]
 801ed4c:	9201      	str	r2, [sp, #4]
 801ed4e:	9300      	str	r3, [sp, #0]
 801ed50:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ed52:	462a      	mov	r2, r5
 801ed54:	4621      	mov	r1, r4
 801ed56:	6978      	ldr	r0, [r7, #20]
 801ed58:	f000 fda8 	bl	801f8ac <grid_align>
 801ed5c:	4602      	mov	r2, r0
 801ed5e:	683b      	ldr	r3, [r7, #0]
 801ed60:	619a      	str	r2, [r3, #24]
                                  calc_out->x, rev);

    bool auto_h = h_set == LV_SIZE_CONTENT && !cont->h_layout;
 801ed62:	69fb      	ldr	r3, [r7, #28]
 801ed64:	4a19      	ldr	r2, [pc, #100]	@ (801edcc <calc+0x140>)
 801ed66:	4293      	cmp	r3, r2
 801ed68:	d109      	bne.n	801ed7e <calc+0xf2>
 801ed6a:	687b      	ldr	r3, [r7, #4]
 801ed6c:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 801ed70:	f003 0304 	and.w	r3, r3, #4
 801ed74:	b2db      	uxtb	r3, r3
 801ed76:	2b00      	cmp	r3, #0
 801ed78:	d101      	bne.n	801ed7e <calc+0xf2>
 801ed7a:	2301      	movs	r3, #1
 801ed7c:	e000      	b.n	801ed80 <calc+0xf4>
 801ed7e:	2300      	movs	r3, #0
 801ed80:	74fb      	strb	r3, [r7, #19]
 801ed82:	7cfb      	ldrb	r3, [r7, #19]
 801ed84:	f003 0301 	and.w	r3, r3, #1
 801ed88:	74fb      	strb	r3, [r7, #19]
    int32_t cont_h = lv_obj_get_content_height(cont);
 801ed8a:	6878      	ldr	r0, [r7, #4]
 801ed8c:	f7e7 f806 	bl	8005d9c <lv_obj_get_content_height>
 801ed90:	60f8      	str	r0, [r7, #12]
    calc_out->grid_h = grid_align(cont_h, auto_h, get_grid_row_align(cont), row_gap, calc_out->row_num, calc_out->h,
 801ed92:	6878      	ldr	r0, [r7, #4]
 801ed94:	f7ff febf 	bl	801eb16 <get_grid_row_align>
 801ed98:	4603      	mov	r3, r0
 801ed9a:	461d      	mov	r5, r3
 801ed9c:	683b      	ldr	r3, [r7, #0]
 801ed9e:	695b      	ldr	r3, [r3, #20]
 801eda0:	683a      	ldr	r2, [r7, #0]
 801eda2:	68d2      	ldr	r2, [r2, #12]
 801eda4:	6839      	ldr	r1, [r7, #0]
 801eda6:	6849      	ldr	r1, [r1, #4]
 801eda8:	7cf8      	ldrb	r0, [r7, #19]
 801edaa:	2400      	movs	r4, #0
 801edac:	9403      	str	r4, [sp, #12]
 801edae:	9102      	str	r1, [sp, #8]
 801edb0:	9201      	str	r2, [sp, #4]
 801edb2:	9300      	str	r3, [sp, #0]
 801edb4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801edb6:	462a      	mov	r2, r5
 801edb8:	4601      	mov	r1, r0
 801edba:	68f8      	ldr	r0, [r7, #12]
 801edbc:	f000 fd76 	bl	801f8ac <grid_align>
 801edc0:	4602      	mov	r2, r0
 801edc2:	683b      	ldr	r3, [r7, #0]
 801edc4:	61da      	str	r2, [r3, #28]
                                  calc_out->y, false);

    LV_ASSERT_MEM_INTEGRITY();
}
 801edc6:	3730      	adds	r7, #48	@ 0x30
 801edc8:	46bd      	mov	sp, r7
 801edca:	bdb0      	pop	{r4, r5, r7, pc}
 801edcc:	200007d1 	.word	0x200007d1

0801edd0 <calc_free>:
/**
 * Free the a grid calculation's data
 * @param calc pointer to the calculated grid cell coordinates
 */
static void calc_free(_lv_grid_calc_t * calc)
{
 801edd0:	b580      	push	{r7, lr}
 801edd2:	b082      	sub	sp, #8
 801edd4:	af00      	add	r7, sp, #0
 801edd6:	6078      	str	r0, [r7, #4]
    lv_free(calc->x);
 801edd8:	687b      	ldr	r3, [r7, #4]
 801edda:	681b      	ldr	r3, [r3, #0]
 801eddc:	4618      	mov	r0, r3
 801edde:	f007 f82b 	bl	8025e38 <lv_free>
    lv_free(calc->y);
 801ede2:	687b      	ldr	r3, [r7, #4]
 801ede4:	685b      	ldr	r3, [r3, #4]
 801ede6:	4618      	mov	r0, r3
 801ede8:	f007 f826 	bl	8025e38 <lv_free>
    lv_free(calc->w);
 801edec:	687b      	ldr	r3, [r7, #4]
 801edee:	689b      	ldr	r3, [r3, #8]
 801edf0:	4618      	mov	r0, r3
 801edf2:	f007 f821 	bl	8025e38 <lv_free>
    lv_free(calc->h);
 801edf6:	687b      	ldr	r3, [r7, #4]
 801edf8:	68db      	ldr	r3, [r3, #12]
 801edfa:	4618      	mov	r0, r3
 801edfc:	f007 f81c 	bl	8025e38 <lv_free>
}
 801ee00:	bf00      	nop
 801ee02:	3708      	adds	r7, #8
 801ee04:	46bd      	mov	sp, r7
 801ee06:	bd80      	pop	{r7, pc}

0801ee08 <calc_cols>:

static void calc_cols(lv_obj_t * cont, _lv_grid_calc_t * c)
{
 801ee08:	b580      	push	{r7, lr}
 801ee0a:	b098      	sub	sp, #96	@ 0x60
 801ee0c:	af00      	add	r7, sp, #0
 801ee0e:	6078      	str	r0, [r7, #4]
 801ee10:	6039      	str	r1, [r7, #0]

    const int32_t * col_templ;
    col_templ = get_col_dsc(cont);
 801ee12:	6878      	ldr	r0, [r7, #4]
 801ee14:	f7ff fe0a 	bl	801ea2c <get_col_dsc>
 801ee18:	65f8      	str	r0, [r7, #92]	@ 0x5c
    bool subgrid = false;
 801ee1a:	2300      	movs	r3, #0
 801ee1c:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
    if(col_templ == NULL) {
 801ee20:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801ee22:	2b00      	cmp	r3, #0
 801ee24:	d130      	bne.n	801ee88 <calc_cols+0x80>
        lv_obj_t * parent = lv_obj_get_parent(cont);
 801ee26:	6878      	ldr	r0, [r7, #4]
 801ee28:	f7ec f804 	bl	800ae34 <lv_obj_get_parent>
 801ee2c:	6378      	str	r0, [r7, #52]	@ 0x34
        col_templ = get_col_dsc(parent);
 801ee2e:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801ee30:	f7ff fdfc 	bl	801ea2c <get_col_dsc>
 801ee34:	65f8      	str	r0, [r7, #92]	@ 0x5c
        if(col_templ == NULL) {
 801ee36:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801ee38:	2b00      	cmp	r3, #0
 801ee3a:	f000 8147 	beq.w	801f0cc <calc_cols+0x2c4>
            LV_LOG_WARN("No col descriptor found even on the parent");
            return;
        }

        int32_t pos = get_col_pos(cont);
 801ee3e:	6878      	ldr	r0, [r7, #4]
 801ee40:	f7ff fe0e 	bl	801ea60 <get_col_pos>
 801ee44:	6338      	str	r0, [r7, #48]	@ 0x30
        int32_t span = get_col_span(cont);
 801ee46:	6878      	ldr	r0, [r7, #4]
 801ee48:	f7ff fe24 	bl	801ea94 <get_col_span>
 801ee4c:	62f8      	str	r0, [r7, #44]	@ 0x2c

        int32_t * col_templ_sub = lv_malloc(sizeof(int32_t) * (span + 1));
 801ee4e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ee50:	3301      	adds	r3, #1
 801ee52:	009b      	lsls	r3, r3, #2
 801ee54:	4618      	mov	r0, r3
 801ee56:	f006 ffb7 	bl	8025dc8 <lv_malloc>
 801ee5a:	62b8      	str	r0, [r7, #40]	@ 0x28
        lv_memcpy(col_templ_sub, &col_templ[pos], sizeof(int32_t) * span);
 801ee5c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801ee5e:	009b      	lsls	r3, r3, #2
 801ee60:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801ee62:	18d1      	adds	r1, r2, r3
 801ee64:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ee66:	009b      	lsls	r3, r3, #2
 801ee68:	461a      	mov	r2, r3
 801ee6a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801ee6c:	f005 fdbc 	bl	80249e8 <lv_memcpy>
        col_templ_sub[span] = LV_GRID_TEMPLATE_LAST;
 801ee70:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801ee72:	009b      	lsls	r3, r3, #2
 801ee74:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801ee76:	4413      	add	r3, r2
 801ee78:	f06f 4260 	mvn.w	r2, #3758096384	@ 0xe0000000
 801ee7c:	601a      	str	r2, [r3, #0]
        col_templ = col_templ_sub;
 801ee7e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801ee80:	65fb      	str	r3, [r7, #92]	@ 0x5c
        subgrid = true;
 801ee82:	2301      	movs	r3, #1
 801ee84:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
    }

    int32_t cont_w = lv_obj_get_content_width(cont);
 801ee88:	6878      	ldr	r0, [r7, #4]
 801ee8a:	f7e6 ff6d 	bl	8005d68 <lv_obj_get_content_width>
 801ee8e:	6278      	str	r0, [r7, #36]	@ 0x24

    c->col_num = count_tracks(col_templ);
 801ee90:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801ee92:	f000 fdef 	bl	801fa74 <count_tracks>
 801ee96:	4602      	mov	r2, r0
 801ee98:	683b      	ldr	r3, [r7, #0]
 801ee9a:	611a      	str	r2, [r3, #16]
    c->x = lv_malloc(sizeof(int32_t) * c->col_num);
 801ee9c:	683b      	ldr	r3, [r7, #0]
 801ee9e:	691b      	ldr	r3, [r3, #16]
 801eea0:	009b      	lsls	r3, r3, #2
 801eea2:	4618      	mov	r0, r3
 801eea4:	f006 ff90 	bl	8025dc8 <lv_malloc>
 801eea8:	4602      	mov	r2, r0
 801eeaa:	683b      	ldr	r3, [r7, #0]
 801eeac:	601a      	str	r2, [r3, #0]
    c->w = lv_malloc(sizeof(int32_t) * c->col_num);
 801eeae:	683b      	ldr	r3, [r7, #0]
 801eeb0:	691b      	ldr	r3, [r3, #16]
 801eeb2:	009b      	lsls	r3, r3, #2
 801eeb4:	4618      	mov	r0, r3
 801eeb6:	f006 ff87 	bl	8025dc8 <lv_malloc>
 801eeba:	4602      	mov	r2, r0
 801eebc:	683b      	ldr	r3, [r7, #0]
 801eebe:	609a      	str	r2, [r3, #8]

    /*Set sizes for CONTENT cells*/
    uint32_t i;
    for(i = 0; i < c->col_num; i++) {
 801eec0:	2300      	movs	r3, #0
 801eec2:	657b      	str	r3, [r7, #84]	@ 0x54
 801eec4:	e05d      	b.n	801ef82 <calc_cols+0x17a>
        int32_t size = LV_COORD_MIN;
 801eec6:	4b83      	ldr	r3, [pc, #524]	@ (801f0d4 <calc_cols+0x2cc>)
 801eec8:	653b      	str	r3, [r7, #80]	@ 0x50
        if(IS_CONTENT(col_templ[i])) {
 801eeca:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801eecc:	009b      	lsls	r3, r3, #2
 801eece:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801eed0:	4413      	add	r3, r2
 801eed2:	681b      	ldr	r3, [r3, #0]
 801eed4:	4a80      	ldr	r2, [pc, #512]	@ (801f0d8 <calc_cols+0x2d0>)
 801eed6:	4293      	cmp	r3, r2
 801eed8:	d150      	bne.n	801ef7c <calc_cols+0x174>
            /*Check the size of children of this cell*/
            uint32_t ci;
            for(ci = 0; ci < lv_obj_get_child_count(cont); ci++) {
 801eeda:	2300      	movs	r3, #0
 801eedc:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801eede:	e034      	b.n	801ef4a <calc_cols+0x142>
                lv_obj_t * item = lv_obj_get_child(cont, ci);
 801eee0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801eee2:	4619      	mov	r1, r3
 801eee4:	6878      	ldr	r0, [r7, #4]
 801eee6:	f7eb ffb6 	bl	800ae56 <lv_obj_get_child>
 801eeea:	6138      	str	r0, [r7, #16]
                if(lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 801eeec:	497b      	ldr	r1, [pc, #492]	@ (801f0dc <calc_cols+0x2d4>)
 801eeee:	6938      	ldr	r0, [r7, #16]
 801eef0:	f7e3 ff42 	bl	8002d78 <lv_obj_has_flag_any>
 801eef4:	4603      	mov	r3, r0
 801eef6:	2b00      	cmp	r3, #0
 801eef8:	d11f      	bne.n	801ef3a <calc_cols+0x132>
                uint32_t col_span = get_col_span(item);
 801eefa:	6938      	ldr	r0, [r7, #16]
 801eefc:	f7ff fdca 	bl	801ea94 <get_col_span>
 801ef00:	4603      	mov	r3, r0
 801ef02:	60fb      	str	r3, [r7, #12]
                if(col_span != 1) continue;
 801ef04:	68fb      	ldr	r3, [r7, #12]
 801ef06:	2b01      	cmp	r3, #1
 801ef08:	d119      	bne.n	801ef3e <calc_cols+0x136>

                uint32_t col_pos = get_col_pos(item);
 801ef0a:	6938      	ldr	r0, [r7, #16]
 801ef0c:	f7ff fda8 	bl	801ea60 <get_col_pos>
 801ef10:	4603      	mov	r3, r0
 801ef12:	60bb      	str	r3, [r7, #8]
                if(col_pos != i) continue;
 801ef14:	68ba      	ldr	r2, [r7, #8]
 801ef16:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ef18:	429a      	cmp	r2, r3
 801ef1a:	d112      	bne.n	801ef42 <calc_cols+0x13a>

                size = LV_MAX(size, lv_obj_get_width(item));
 801ef1c:	6938      	ldr	r0, [r7, #16]
 801ef1e:	f7e6 ff07 	bl	8005d30 <lv_obj_get_width>
 801ef22:	4602      	mov	r2, r0
 801ef24:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801ef26:	4293      	cmp	r3, r2
 801ef28:	dc04      	bgt.n	801ef34 <calc_cols+0x12c>
 801ef2a:	6938      	ldr	r0, [r7, #16]
 801ef2c:	f7e6 ff00 	bl	8005d30 <lv_obj_get_width>
 801ef30:	4603      	mov	r3, r0
 801ef32:	e000      	b.n	801ef36 <calc_cols+0x12e>
 801ef34:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801ef36:	653b      	str	r3, [r7, #80]	@ 0x50
 801ef38:	e004      	b.n	801ef44 <calc_cols+0x13c>
                if(lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 801ef3a:	bf00      	nop
 801ef3c:	e002      	b.n	801ef44 <calc_cols+0x13c>
                if(col_span != 1) continue;
 801ef3e:	bf00      	nop
 801ef40:	e000      	b.n	801ef44 <calc_cols+0x13c>
                if(col_pos != i) continue;
 801ef42:	bf00      	nop
            for(ci = 0; ci < lv_obj_get_child_count(cont); ci++) {
 801ef44:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ef46:	3301      	adds	r3, #1
 801ef48:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801ef4a:	6878      	ldr	r0, [r7, #4]
 801ef4c:	f7eb ffb8 	bl	800aec0 <lv_obj_get_child_count>
 801ef50:	4602      	mov	r2, r0
 801ef52:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801ef54:	4293      	cmp	r3, r2
 801ef56:	d3c3      	bcc.n	801eee0 <calc_cols+0xd8>
            }
            if(size >= 0) c->w[i] = size;
 801ef58:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801ef5a:	2b00      	cmp	r3, #0
 801ef5c:	db07      	blt.n	801ef6e <calc_cols+0x166>
 801ef5e:	683b      	ldr	r3, [r7, #0]
 801ef60:	689a      	ldr	r2, [r3, #8]
 801ef62:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ef64:	009b      	lsls	r3, r3, #2
 801ef66:	4413      	add	r3, r2
 801ef68:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801ef6a:	601a      	str	r2, [r3, #0]
 801ef6c:	e006      	b.n	801ef7c <calc_cols+0x174>
            else c->w[i] = 0;
 801ef6e:	683b      	ldr	r3, [r7, #0]
 801ef70:	689a      	ldr	r2, [r3, #8]
 801ef72:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ef74:	009b      	lsls	r3, r3, #2
 801ef76:	4413      	add	r3, r2
 801ef78:	2200      	movs	r2, #0
 801ef7a:	601a      	str	r2, [r3, #0]
    for(i = 0; i < c->col_num; i++) {
 801ef7c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ef7e:	3301      	adds	r3, #1
 801ef80:	657b      	str	r3, [r7, #84]	@ 0x54
 801ef82:	683b      	ldr	r3, [r7, #0]
 801ef84:	691b      	ldr	r3, [r3, #16]
 801ef86:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801ef88:	429a      	cmp	r2, r3
 801ef8a:	d39c      	bcc.n	801eec6 <calc_cols+0xbe>
        }
    }

    uint32_t col_fr_cnt = 0;
 801ef8c:	2300      	movs	r3, #0
 801ef8e:	64bb      	str	r3, [r7, #72]	@ 0x48
    int32_t grid_w = 0;
 801ef90:	2300      	movs	r3, #0
 801ef92:	647b      	str	r3, [r7, #68]	@ 0x44

    for(i = 0; i < c->col_num; i++) {
 801ef94:	2300      	movs	r3, #0
 801ef96:	657b      	str	r3, [r7, #84]	@ 0x54
 801ef98:	e02d      	b.n	801eff6 <calc_cols+0x1ee>
        int32_t x = col_templ[i];
 801ef9a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801ef9c:	009b      	lsls	r3, r3, #2
 801ef9e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801efa0:	4413      	add	r3, r2
 801efa2:	681b      	ldr	r3, [r3, #0]
 801efa4:	617b      	str	r3, [r7, #20]
        if(IS_FR(x)) {
 801efa6:	697b      	ldr	r3, [r7, #20]
 801efa8:	4a4b      	ldr	r2, [pc, #300]	@ (801f0d8 <calc_cols+0x2d0>)
 801efaa:	4293      	cmp	r3, r2
 801efac:	dd07      	ble.n	801efbe <calc_cols+0x1b6>
            col_fr_cnt += GET_FR(x);
 801efae:	697a      	ldr	r2, [r7, #20]
 801efb0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801efb2:	4413      	add	r3, r2
 801efb4:	f103 4360 	add.w	r3, r3, #3758096384	@ 0xe0000000
 801efb8:	3365      	adds	r3, #101	@ 0x65
 801efba:	64bb      	str	r3, [r7, #72]	@ 0x48
 801efbc:	e018      	b.n	801eff0 <calc_cols+0x1e8>
        }
        else if(IS_CONTENT(x)) {
 801efbe:	697b      	ldr	r3, [r7, #20]
 801efc0:	4a45      	ldr	r2, [pc, #276]	@ (801f0d8 <calc_cols+0x2d0>)
 801efc2:	4293      	cmp	r3, r2
 801efc4:	d109      	bne.n	801efda <calc_cols+0x1d2>
            grid_w += c->w[i];
 801efc6:	683b      	ldr	r3, [r7, #0]
 801efc8:	689a      	ldr	r2, [r3, #8]
 801efca:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801efcc:	009b      	lsls	r3, r3, #2
 801efce:	4413      	add	r3, r2
 801efd0:	681b      	ldr	r3, [r3, #0]
 801efd2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801efd4:	4413      	add	r3, r2
 801efd6:	647b      	str	r3, [r7, #68]	@ 0x44
 801efd8:	e00a      	b.n	801eff0 <calc_cols+0x1e8>
        }
        else {
            c->w[i] = x;
 801efda:	683b      	ldr	r3, [r7, #0]
 801efdc:	689a      	ldr	r2, [r3, #8]
 801efde:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801efe0:	009b      	lsls	r3, r3, #2
 801efe2:	4413      	add	r3, r2
 801efe4:	697a      	ldr	r2, [r7, #20]
 801efe6:	601a      	str	r2, [r3, #0]
            grid_w += x;
 801efe8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801efea:	697b      	ldr	r3, [r7, #20]
 801efec:	4413      	add	r3, r2
 801efee:	647b      	str	r3, [r7, #68]	@ 0x44
    for(i = 0; i < c->col_num; i++) {
 801eff0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801eff2:	3301      	adds	r3, #1
 801eff4:	657b      	str	r3, [r7, #84]	@ 0x54
 801eff6:	683b      	ldr	r3, [r7, #0]
 801eff8:	691b      	ldr	r3, [r3, #16]
 801effa:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801effc:	429a      	cmp	r2, r3
 801effe:	d3cc      	bcc.n	801ef9a <calc_cols+0x192>
        }
    }

    int32_t col_gap = lv_obj_get_style_pad_column(cont, LV_PART_MAIN);
 801f000:	2100      	movs	r1, #0
 801f002:	6878      	ldr	r0, [r7, #4]
 801f004:	f7ff fb94 	bl	801e730 <lv_obj_get_style_pad_column>
 801f008:	6238      	str	r0, [r7, #32]
    cont_w -= col_gap * (c->col_num - 1);
 801f00a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801f00c:	683b      	ldr	r3, [r7, #0]
 801f00e:	691b      	ldr	r3, [r3, #16]
 801f010:	3b01      	subs	r3, #1
 801f012:	6a39      	ldr	r1, [r7, #32]
 801f014:	fb01 f303 	mul.w	r3, r1, r3
 801f018:	1ad3      	subs	r3, r2, r3
 801f01a:	627b      	str	r3, [r7, #36]	@ 0x24
    int32_t free_w = cont_w - grid_w;
 801f01c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801f01e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801f020:	1ad3      	subs	r3, r2, r3
 801f022:	643b      	str	r3, [r7, #64]	@ 0x40
    if(free_w < 0) free_w = 0;
 801f024:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801f026:	2b00      	cmp	r3, #0
 801f028:	da01      	bge.n	801f02e <calc_cols+0x226>
 801f02a:	2300      	movs	r3, #0
 801f02c:	643b      	str	r3, [r7, #64]	@ 0x40

    int32_t last_fr_i = -1;
 801f02e:	f04f 33ff 	mov.w	r3, #4294967295
 801f032:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int32_t last_fr_x = 0;
 801f034:	2300      	movs	r3, #0
 801f036:	63bb      	str	r3, [r7, #56]	@ 0x38
    for(i = 0; i < c->col_num; i++) {
 801f038:	2300      	movs	r3, #0
 801f03a:	657b      	str	r3, [r7, #84]	@ 0x54
 801f03c:	e024      	b.n	801f088 <calc_cols+0x280>
        int32_t x = col_templ[i];
 801f03e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f040:	009b      	lsls	r3, r3, #2
 801f042:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801f044:	4413      	add	r3, r2
 801f046:	681b      	ldr	r3, [r3, #0]
 801f048:	61fb      	str	r3, [r7, #28]
        if(IS_FR(x)) {
 801f04a:	69fb      	ldr	r3, [r7, #28]
 801f04c:	4a22      	ldr	r2, [pc, #136]	@ (801f0d8 <calc_cols+0x2d0>)
 801f04e:	4293      	cmp	r3, r2
 801f050:	dd17      	ble.n	801f082 <calc_cols+0x27a>
            int32_t f = GET_FR(x);
 801f052:	69fb      	ldr	r3, [r7, #28]
 801f054:	f103 4360 	add.w	r3, r3, #3758096384	@ 0xe0000000
 801f058:	3365      	adds	r3, #101	@ 0x65
 801f05a:	61bb      	str	r3, [r7, #24]
            c->w[i] = (free_w * f) / col_fr_cnt;
 801f05c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801f05e:	69ba      	ldr	r2, [r7, #24]
 801f060:	fb02 f303 	mul.w	r3, r2, r3
 801f064:	461a      	mov	r2, r3
 801f066:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801f068:	fbb2 f1f3 	udiv	r1, r2, r3
 801f06c:	683b      	ldr	r3, [r7, #0]
 801f06e:	689a      	ldr	r2, [r3, #8]
 801f070:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f072:	009b      	lsls	r3, r3, #2
 801f074:	4413      	add	r3, r2
 801f076:	460a      	mov	r2, r1
 801f078:	601a      	str	r2, [r3, #0]
            last_fr_i = i;
 801f07a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f07c:	63fb      	str	r3, [r7, #60]	@ 0x3c
            last_fr_x = f;
 801f07e:	69bb      	ldr	r3, [r7, #24]
 801f080:	63bb      	str	r3, [r7, #56]	@ 0x38
    for(i = 0; i < c->col_num; i++) {
 801f082:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f084:	3301      	adds	r3, #1
 801f086:	657b      	str	r3, [r7, #84]	@ 0x54
 801f088:	683b      	ldr	r3, [r7, #0]
 801f08a:	691b      	ldr	r3, [r3, #16]
 801f08c:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801f08e:	429a      	cmp	r2, r3
 801f090:	d3d5      	bcc.n	801f03e <calc_cols+0x236>
        }
    }

    /*To avoid rounding errors set the last FR track to the remaining size */
    if(last_fr_i >= 0) {
 801f092:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801f094:	2b00      	cmp	r3, #0
 801f096:	db11      	blt.n	801f0bc <calc_cols+0x2b4>
        c->w[last_fr_i] = free_w - ((free_w * (col_fr_cnt - last_fr_x)) / col_fr_cnt);
 801f098:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801f09a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801f09c:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 801f09e:	1acb      	subs	r3, r1, r3
 801f0a0:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 801f0a2:	fb03 f101 	mul.w	r1, r3, r1
 801f0a6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801f0a8:	fbb1 f3f3 	udiv	r3, r1, r3
 801f0ac:	1ad1      	subs	r1, r2, r3
 801f0ae:	683b      	ldr	r3, [r7, #0]
 801f0b0:	689a      	ldr	r2, [r3, #8]
 801f0b2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801f0b4:	009b      	lsls	r3, r3, #2
 801f0b6:	4413      	add	r3, r2
 801f0b8:	460a      	mov	r2, r1
 801f0ba:	601a      	str	r2, [r3, #0]
    }

    if(subgrid) {
 801f0bc:	f897 305b 	ldrb.w	r3, [r7, #91]	@ 0x5b
 801f0c0:	2b00      	cmp	r3, #0
 801f0c2:	d004      	beq.n	801f0ce <calc_cols+0x2c6>
        lv_free((void *)col_templ);
 801f0c4:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801f0c6:	f006 feb7 	bl	8025e38 <lv_free>
 801f0ca:	e000      	b.n	801f0ce <calc_cols+0x2c6>
            return;
 801f0cc:	bf00      	nop
    }
}
 801f0ce:	3760      	adds	r7, #96	@ 0x60
 801f0d0:	46bd      	mov	sp, r7
 801f0d2:	bd80      	pop	{r7, pc}
 801f0d4:	e0000001 	.word	0xe0000001
 801f0d8:	1fffff9a 	.word	0x1fffff9a
 801f0dc:	00060001 	.word	0x00060001

0801f0e0 <calc_rows>:

static void calc_rows(lv_obj_t * cont, _lv_grid_calc_t * c)
{
 801f0e0:	b580      	push	{r7, lr}
 801f0e2:	b098      	sub	sp, #96	@ 0x60
 801f0e4:	af00      	add	r7, sp, #0
 801f0e6:	6078      	str	r0, [r7, #4]
 801f0e8:	6039      	str	r1, [r7, #0]
    const int32_t * row_templ;
    row_templ = get_row_dsc(cont);
 801f0ea:	6878      	ldr	r0, [r7, #4]
 801f0ec:	f7ff fcab 	bl	801ea46 <get_row_dsc>
 801f0f0:	65f8      	str	r0, [r7, #92]	@ 0x5c
    bool subgrid = false;
 801f0f2:	2300      	movs	r3, #0
 801f0f4:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
    if(row_templ == NULL) {
 801f0f8:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801f0fa:	2b00      	cmp	r3, #0
 801f0fc:	d130      	bne.n	801f160 <calc_rows+0x80>
        lv_obj_t * parent = lv_obj_get_parent(cont);
 801f0fe:	6878      	ldr	r0, [r7, #4]
 801f100:	f7eb fe98 	bl	800ae34 <lv_obj_get_parent>
 801f104:	6378      	str	r0, [r7, #52]	@ 0x34
        row_templ = get_row_dsc(parent);
 801f106:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 801f108:	f7ff fc9d 	bl	801ea46 <get_row_dsc>
 801f10c:	65f8      	str	r0, [r7, #92]	@ 0x5c
        if(row_templ == NULL) {
 801f10e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801f110:	2b00      	cmp	r3, #0
 801f112:	f000 8147 	beq.w	801f3a4 <calc_rows+0x2c4>
            LV_LOG_WARN("No row descriptor found even on the parent");
            return;
        }

        int32_t pos = get_row_pos(cont);
 801f116:	6878      	ldr	r0, [r7, #4]
 801f118:	f7ff fcaf 	bl	801ea7a <get_row_pos>
 801f11c:	6338      	str	r0, [r7, #48]	@ 0x30
        int32_t span = get_row_span(cont);
 801f11e:	6878      	ldr	r0, [r7, #4]
 801f120:	f7ff fcc5 	bl	801eaae <get_row_span>
 801f124:	62f8      	str	r0, [r7, #44]	@ 0x2c

        int32_t * row_templ_sub = lv_malloc(sizeof(int32_t) * (span + 1));
 801f126:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f128:	3301      	adds	r3, #1
 801f12a:	009b      	lsls	r3, r3, #2
 801f12c:	4618      	mov	r0, r3
 801f12e:	f006 fe4b 	bl	8025dc8 <lv_malloc>
 801f132:	62b8      	str	r0, [r7, #40]	@ 0x28
        lv_memcpy(row_templ_sub, &row_templ[pos], sizeof(int32_t) * span);
 801f134:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f136:	009b      	lsls	r3, r3, #2
 801f138:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801f13a:	18d1      	adds	r1, r2, r3
 801f13c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f13e:	009b      	lsls	r3, r3, #2
 801f140:	461a      	mov	r2, r3
 801f142:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 801f144:	f005 fc50 	bl	80249e8 <lv_memcpy>
        row_templ_sub[span] = LV_GRID_TEMPLATE_LAST;
 801f148:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801f14a:	009b      	lsls	r3, r3, #2
 801f14c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801f14e:	4413      	add	r3, r2
 801f150:	f06f 4260 	mvn.w	r2, #3758096384	@ 0xe0000000
 801f154:	601a      	str	r2, [r3, #0]
        row_templ = row_templ_sub;
 801f156:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f158:	65fb      	str	r3, [r7, #92]	@ 0x5c
        subgrid = true;
 801f15a:	2301      	movs	r3, #1
 801f15c:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b
    }

    c->row_num = count_tracks(row_templ);
 801f160:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801f162:	f000 fc87 	bl	801fa74 <count_tracks>
 801f166:	4602      	mov	r2, r0
 801f168:	683b      	ldr	r3, [r7, #0]
 801f16a:	615a      	str	r2, [r3, #20]
    c->y = lv_malloc(sizeof(int32_t) * c->row_num);
 801f16c:	683b      	ldr	r3, [r7, #0]
 801f16e:	695b      	ldr	r3, [r3, #20]
 801f170:	009b      	lsls	r3, r3, #2
 801f172:	4618      	mov	r0, r3
 801f174:	f006 fe28 	bl	8025dc8 <lv_malloc>
 801f178:	4602      	mov	r2, r0
 801f17a:	683b      	ldr	r3, [r7, #0]
 801f17c:	605a      	str	r2, [r3, #4]
    c->h = lv_malloc(sizeof(int32_t) * c->row_num);
 801f17e:	683b      	ldr	r3, [r7, #0]
 801f180:	695b      	ldr	r3, [r3, #20]
 801f182:	009b      	lsls	r3, r3, #2
 801f184:	4618      	mov	r0, r3
 801f186:	f006 fe1f 	bl	8025dc8 <lv_malloc>
 801f18a:	4602      	mov	r2, r0
 801f18c:	683b      	ldr	r3, [r7, #0]
 801f18e:	60da      	str	r2, [r3, #12]
    /*Set sizes for CONTENT cells*/
    uint32_t i;
    for(i = 0; i < c->row_num; i++) {
 801f190:	2300      	movs	r3, #0
 801f192:	657b      	str	r3, [r7, #84]	@ 0x54
 801f194:	e05d      	b.n	801f252 <calc_rows+0x172>
        int32_t size = LV_COORD_MIN;
 801f196:	4b85      	ldr	r3, [pc, #532]	@ (801f3ac <calc_rows+0x2cc>)
 801f198:	653b      	str	r3, [r7, #80]	@ 0x50
        if(IS_CONTENT(row_templ[i])) {
 801f19a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f19c:	009b      	lsls	r3, r3, #2
 801f19e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801f1a0:	4413      	add	r3, r2
 801f1a2:	681b      	ldr	r3, [r3, #0]
 801f1a4:	4a82      	ldr	r2, [pc, #520]	@ (801f3b0 <calc_rows+0x2d0>)
 801f1a6:	4293      	cmp	r3, r2
 801f1a8:	d150      	bne.n	801f24c <calc_rows+0x16c>
            /*Check the size of children of this cell*/
            uint32_t ci;
            for(ci = 0; ci < lv_obj_get_child_count(cont); ci++) {
 801f1aa:	2300      	movs	r3, #0
 801f1ac:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801f1ae:	e034      	b.n	801f21a <calc_rows+0x13a>
                lv_obj_t * item = lv_obj_get_child(cont, ci);
 801f1b0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801f1b2:	4619      	mov	r1, r3
 801f1b4:	6878      	ldr	r0, [r7, #4]
 801f1b6:	f7eb fe4e 	bl	800ae56 <lv_obj_get_child>
 801f1ba:	6138      	str	r0, [r7, #16]
                if(lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 801f1bc:	497d      	ldr	r1, [pc, #500]	@ (801f3b4 <calc_rows+0x2d4>)
 801f1be:	6938      	ldr	r0, [r7, #16]
 801f1c0:	f7e3 fdda 	bl	8002d78 <lv_obj_has_flag_any>
 801f1c4:	4603      	mov	r3, r0
 801f1c6:	2b00      	cmp	r3, #0
 801f1c8:	d11f      	bne.n	801f20a <calc_rows+0x12a>
                uint32_t row_span = get_row_span(item);
 801f1ca:	6938      	ldr	r0, [r7, #16]
 801f1cc:	f7ff fc6f 	bl	801eaae <get_row_span>
 801f1d0:	4603      	mov	r3, r0
 801f1d2:	60fb      	str	r3, [r7, #12]
                if(row_span != 1) continue;
 801f1d4:	68fb      	ldr	r3, [r7, #12]
 801f1d6:	2b01      	cmp	r3, #1
 801f1d8:	d119      	bne.n	801f20e <calc_rows+0x12e>

                uint32_t row_pos = get_row_pos(item);
 801f1da:	6938      	ldr	r0, [r7, #16]
 801f1dc:	f7ff fc4d 	bl	801ea7a <get_row_pos>
 801f1e0:	4603      	mov	r3, r0
 801f1e2:	60bb      	str	r3, [r7, #8]
                if(row_pos != i) continue;
 801f1e4:	68ba      	ldr	r2, [r7, #8]
 801f1e6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f1e8:	429a      	cmp	r2, r3
 801f1ea:	d112      	bne.n	801f212 <calc_rows+0x132>

                size = LV_MAX(size, lv_obj_get_height(item));
 801f1ec:	6938      	ldr	r0, [r7, #16]
 801f1ee:	f7e6 fdad 	bl	8005d4c <lv_obj_get_height>
 801f1f2:	4602      	mov	r2, r0
 801f1f4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801f1f6:	4293      	cmp	r3, r2
 801f1f8:	dc04      	bgt.n	801f204 <calc_rows+0x124>
 801f1fa:	6938      	ldr	r0, [r7, #16]
 801f1fc:	f7e6 fda6 	bl	8005d4c <lv_obj_get_height>
 801f200:	4603      	mov	r3, r0
 801f202:	e000      	b.n	801f206 <calc_rows+0x126>
 801f204:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801f206:	653b      	str	r3, [r7, #80]	@ 0x50
 801f208:	e004      	b.n	801f214 <calc_rows+0x134>
                if(lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) continue;
 801f20a:	bf00      	nop
 801f20c:	e002      	b.n	801f214 <calc_rows+0x134>
                if(row_span != 1) continue;
 801f20e:	bf00      	nop
 801f210:	e000      	b.n	801f214 <calc_rows+0x134>
                if(row_pos != i) continue;
 801f212:	bf00      	nop
            for(ci = 0; ci < lv_obj_get_child_count(cont); ci++) {
 801f214:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801f216:	3301      	adds	r3, #1
 801f218:	64fb      	str	r3, [r7, #76]	@ 0x4c
 801f21a:	6878      	ldr	r0, [r7, #4]
 801f21c:	f7eb fe50 	bl	800aec0 <lv_obj_get_child_count>
 801f220:	4602      	mov	r2, r0
 801f222:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801f224:	4293      	cmp	r3, r2
 801f226:	d3c3      	bcc.n	801f1b0 <calc_rows+0xd0>
            }
            if(size >= 0) c->h[i] = size;
 801f228:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801f22a:	2b00      	cmp	r3, #0
 801f22c:	db07      	blt.n	801f23e <calc_rows+0x15e>
 801f22e:	683b      	ldr	r3, [r7, #0]
 801f230:	68da      	ldr	r2, [r3, #12]
 801f232:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f234:	009b      	lsls	r3, r3, #2
 801f236:	4413      	add	r3, r2
 801f238:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 801f23a:	601a      	str	r2, [r3, #0]
 801f23c:	e006      	b.n	801f24c <calc_rows+0x16c>
            else c->h[i] = 0;
 801f23e:	683b      	ldr	r3, [r7, #0]
 801f240:	68da      	ldr	r2, [r3, #12]
 801f242:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f244:	009b      	lsls	r3, r3, #2
 801f246:	4413      	add	r3, r2
 801f248:	2200      	movs	r2, #0
 801f24a:	601a      	str	r2, [r3, #0]
    for(i = 0; i < c->row_num; i++) {
 801f24c:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f24e:	3301      	adds	r3, #1
 801f250:	657b      	str	r3, [r7, #84]	@ 0x54
 801f252:	683b      	ldr	r3, [r7, #0]
 801f254:	695b      	ldr	r3, [r3, #20]
 801f256:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801f258:	429a      	cmp	r2, r3
 801f25a:	d39c      	bcc.n	801f196 <calc_rows+0xb6>
        }
    }

    uint32_t row_fr_cnt = 0;
 801f25c:	2300      	movs	r3, #0
 801f25e:	64bb      	str	r3, [r7, #72]	@ 0x48
    int32_t grid_h = 0;
 801f260:	2300      	movs	r3, #0
 801f262:	647b      	str	r3, [r7, #68]	@ 0x44

    for(i = 0; i < c->row_num; i++) {
 801f264:	2300      	movs	r3, #0
 801f266:	657b      	str	r3, [r7, #84]	@ 0x54
 801f268:	e02d      	b.n	801f2c6 <calc_rows+0x1e6>
        int32_t x = row_templ[i];
 801f26a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f26c:	009b      	lsls	r3, r3, #2
 801f26e:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801f270:	4413      	add	r3, r2
 801f272:	681b      	ldr	r3, [r3, #0]
 801f274:	617b      	str	r3, [r7, #20]
        if(IS_FR(x)) {
 801f276:	697b      	ldr	r3, [r7, #20]
 801f278:	4a4d      	ldr	r2, [pc, #308]	@ (801f3b0 <calc_rows+0x2d0>)
 801f27a:	4293      	cmp	r3, r2
 801f27c:	dd07      	ble.n	801f28e <calc_rows+0x1ae>
            row_fr_cnt += GET_FR(x);
 801f27e:	697a      	ldr	r2, [r7, #20]
 801f280:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801f282:	4413      	add	r3, r2
 801f284:	f103 4360 	add.w	r3, r3, #3758096384	@ 0xe0000000
 801f288:	3365      	adds	r3, #101	@ 0x65
 801f28a:	64bb      	str	r3, [r7, #72]	@ 0x48
 801f28c:	e018      	b.n	801f2c0 <calc_rows+0x1e0>
        }
        else if(IS_CONTENT(x)) {
 801f28e:	697b      	ldr	r3, [r7, #20]
 801f290:	4a47      	ldr	r2, [pc, #284]	@ (801f3b0 <calc_rows+0x2d0>)
 801f292:	4293      	cmp	r3, r2
 801f294:	d109      	bne.n	801f2aa <calc_rows+0x1ca>
            grid_h += c->h[i];
 801f296:	683b      	ldr	r3, [r7, #0]
 801f298:	68da      	ldr	r2, [r3, #12]
 801f29a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f29c:	009b      	lsls	r3, r3, #2
 801f29e:	4413      	add	r3, r2
 801f2a0:	681b      	ldr	r3, [r3, #0]
 801f2a2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801f2a4:	4413      	add	r3, r2
 801f2a6:	647b      	str	r3, [r7, #68]	@ 0x44
 801f2a8:	e00a      	b.n	801f2c0 <calc_rows+0x1e0>
        }
        else {
            c->h[i] = x;
 801f2aa:	683b      	ldr	r3, [r7, #0]
 801f2ac:	68da      	ldr	r2, [r3, #12]
 801f2ae:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f2b0:	009b      	lsls	r3, r3, #2
 801f2b2:	4413      	add	r3, r2
 801f2b4:	697a      	ldr	r2, [r7, #20]
 801f2b6:	601a      	str	r2, [r3, #0]
            grid_h += x;
 801f2b8:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801f2ba:	697b      	ldr	r3, [r7, #20]
 801f2bc:	4413      	add	r3, r2
 801f2be:	647b      	str	r3, [r7, #68]	@ 0x44
    for(i = 0; i < c->row_num; i++) {
 801f2c0:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f2c2:	3301      	adds	r3, #1
 801f2c4:	657b      	str	r3, [r7, #84]	@ 0x54
 801f2c6:	683b      	ldr	r3, [r7, #0]
 801f2c8:	695b      	ldr	r3, [r3, #20]
 801f2ca:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801f2cc:	429a      	cmp	r2, r3
 801f2ce:	d3cc      	bcc.n	801f26a <calc_rows+0x18a>
        }
    }

    int32_t row_gap = lv_obj_get_style_pad_row(cont, LV_PART_MAIN);
 801f2d0:	2100      	movs	r1, #0
 801f2d2:	6878      	ldr	r0, [r7, #4]
 801f2d4:	f7ff fa1b 	bl	801e70e <lv_obj_get_style_pad_row>
 801f2d8:	6278      	str	r0, [r7, #36]	@ 0x24
    int32_t cont_h = lv_obj_get_content_height(cont) - row_gap * (c->row_num - 1);
 801f2da:	6878      	ldr	r0, [r7, #4]
 801f2dc:	f7e6 fd5e 	bl	8005d9c <lv_obj_get_content_height>
 801f2e0:	4603      	mov	r3, r0
 801f2e2:	4619      	mov	r1, r3
 801f2e4:	683b      	ldr	r3, [r7, #0]
 801f2e6:	695b      	ldr	r3, [r3, #20]
 801f2e8:	3b01      	subs	r3, #1
 801f2ea:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801f2ec:	fb02 f303 	mul.w	r3, r2, r3
 801f2f0:	1acb      	subs	r3, r1, r3
 801f2f2:	623b      	str	r3, [r7, #32]
    int32_t free_h = cont_h - grid_h;
 801f2f4:	6a3a      	ldr	r2, [r7, #32]
 801f2f6:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801f2f8:	1ad3      	subs	r3, r2, r3
 801f2fa:	643b      	str	r3, [r7, #64]	@ 0x40
    if(free_h < 0) free_h = 0;
 801f2fc:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801f2fe:	2b00      	cmp	r3, #0
 801f300:	da01      	bge.n	801f306 <calc_rows+0x226>
 801f302:	2300      	movs	r3, #0
 801f304:	643b      	str	r3, [r7, #64]	@ 0x40

    int32_t last_fr_i = -1;
 801f306:	f04f 33ff 	mov.w	r3, #4294967295
 801f30a:	63fb      	str	r3, [r7, #60]	@ 0x3c
    int32_t last_fr_x = 0;
 801f30c:	2300      	movs	r3, #0
 801f30e:	63bb      	str	r3, [r7, #56]	@ 0x38
    for(i = 0; i < c->row_num; i++) {
 801f310:	2300      	movs	r3, #0
 801f312:	657b      	str	r3, [r7, #84]	@ 0x54
 801f314:	e024      	b.n	801f360 <calc_rows+0x280>
        int32_t x = row_templ[i];
 801f316:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f318:	009b      	lsls	r3, r3, #2
 801f31a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 801f31c:	4413      	add	r3, r2
 801f31e:	681b      	ldr	r3, [r3, #0]
 801f320:	61fb      	str	r3, [r7, #28]
        if(IS_FR(x)) {
 801f322:	69fb      	ldr	r3, [r7, #28]
 801f324:	4a22      	ldr	r2, [pc, #136]	@ (801f3b0 <calc_rows+0x2d0>)
 801f326:	4293      	cmp	r3, r2
 801f328:	dd17      	ble.n	801f35a <calc_rows+0x27a>
            int32_t f = GET_FR(x);
 801f32a:	69fb      	ldr	r3, [r7, #28]
 801f32c:	f103 4360 	add.w	r3, r3, #3758096384	@ 0xe0000000
 801f330:	3365      	adds	r3, #101	@ 0x65
 801f332:	61bb      	str	r3, [r7, #24]
            c->h[i] = (free_h * f) / row_fr_cnt;
 801f334:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801f336:	69ba      	ldr	r2, [r7, #24]
 801f338:	fb02 f303 	mul.w	r3, r2, r3
 801f33c:	461a      	mov	r2, r3
 801f33e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801f340:	fbb2 f1f3 	udiv	r1, r2, r3
 801f344:	683b      	ldr	r3, [r7, #0]
 801f346:	68da      	ldr	r2, [r3, #12]
 801f348:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f34a:	009b      	lsls	r3, r3, #2
 801f34c:	4413      	add	r3, r2
 801f34e:	460a      	mov	r2, r1
 801f350:	601a      	str	r2, [r3, #0]
            last_fr_i = i;
 801f352:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f354:	63fb      	str	r3, [r7, #60]	@ 0x3c
            last_fr_x = f;
 801f356:	69bb      	ldr	r3, [r7, #24]
 801f358:	63bb      	str	r3, [r7, #56]	@ 0x38
    for(i = 0; i < c->row_num; i++) {
 801f35a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f35c:	3301      	adds	r3, #1
 801f35e:	657b      	str	r3, [r7, #84]	@ 0x54
 801f360:	683b      	ldr	r3, [r7, #0]
 801f362:	695b      	ldr	r3, [r3, #20]
 801f364:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 801f366:	429a      	cmp	r2, r3
 801f368:	d3d5      	bcc.n	801f316 <calc_rows+0x236>
        }
    }

    /*To avoid rounding errors set the last FR track to the remaining size */
    if(last_fr_i >= 0) {
 801f36a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801f36c:	2b00      	cmp	r3, #0
 801f36e:	db11      	blt.n	801f394 <calc_rows+0x2b4>
        c->h[last_fr_i] = free_h - ((free_h * (row_fr_cnt - last_fr_x)) / row_fr_cnt);
 801f370:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801f372:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801f374:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 801f376:	1acb      	subs	r3, r1, r3
 801f378:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 801f37a:	fb03 f101 	mul.w	r1, r3, r1
 801f37e:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801f380:	fbb1 f3f3 	udiv	r3, r1, r3
 801f384:	1ad1      	subs	r1, r2, r3
 801f386:	683b      	ldr	r3, [r7, #0]
 801f388:	68da      	ldr	r2, [r3, #12]
 801f38a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801f38c:	009b      	lsls	r3, r3, #2
 801f38e:	4413      	add	r3, r2
 801f390:	460a      	mov	r2, r1
 801f392:	601a      	str	r2, [r3, #0]
    }

    if(subgrid) {
 801f394:	f897 305b 	ldrb.w	r3, [r7, #91]	@ 0x5b
 801f398:	2b00      	cmp	r3, #0
 801f39a:	d004      	beq.n	801f3a6 <calc_rows+0x2c6>
        lv_free((void *)row_templ);
 801f39c:	6df8      	ldr	r0, [r7, #92]	@ 0x5c
 801f39e:	f006 fd4b 	bl	8025e38 <lv_free>
 801f3a2:	e000      	b.n	801f3a6 <calc_rows+0x2c6>
            return;
 801f3a4:	bf00      	nop
    }
}
 801f3a6:	3760      	adds	r7, #96	@ 0x60
 801f3a8:	46bd      	mov	sp, r7
 801f3aa:	bd80      	pop	{r7, pc}
 801f3ac:	e0000001 	.word	0xe0000001
 801f3b0:	1fffff9a 	.word	0x1fffff9a
 801f3b4:	00060001 	.word	0x00060001

0801f3b8 <item_repos>:
 * @param calc the calculated grid of `cont`
 * @param child_id_ext helper value if the ID of the child is know (order from the oldest) else -1
 * @param grid_abs helper value, the absolute position of the grid, NULL if unknown
 */
static void item_repos(lv_obj_t * item, _lv_grid_calc_t * c, item_repos_hint_t * hint)
{
 801f3b8:	b5b0      	push	{r4, r5, r7, lr}
 801f3ba:	b09e      	sub	sp, #120	@ 0x78
 801f3bc:	af00      	add	r7, sp, #0
 801f3be:	60f8      	str	r0, [r7, #12]
 801f3c0:	60b9      	str	r1, [r7, #8]
 801f3c2:	607a      	str	r2, [r7, #4]
    if(lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) return;
 801f3c4:	49a7      	ldr	r1, [pc, #668]	@ (801f664 <item_repos+0x2ac>)
 801f3c6:	68f8      	ldr	r0, [r7, #12]
 801f3c8:	f7e3 fcd6 	bl	8002d78 <lv_obj_has_flag_any>
 801f3cc:	4603      	mov	r3, r0
 801f3ce:	2b00      	cmp	r3, #0
 801f3d0:	f040 8263 	bne.w	801f89a <item_repos+0x4e2>
    uint32_t col_span = get_col_span(item);
 801f3d4:	68f8      	ldr	r0, [r7, #12]
 801f3d6:	f7ff fb5d 	bl	801ea94 <get_col_span>
 801f3da:	4603      	mov	r3, r0
 801f3dc:	65bb      	str	r3, [r7, #88]	@ 0x58
    uint32_t row_span = get_row_span(item);
 801f3de:	68f8      	ldr	r0, [r7, #12]
 801f3e0:	f7ff fb65 	bl	801eaae <get_row_span>
 801f3e4:	4603      	mov	r3, r0
 801f3e6:	657b      	str	r3, [r7, #84]	@ 0x54
    if(row_span == 0 || col_span == 0) return;
 801f3e8:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f3ea:	2b00      	cmp	r3, #0
 801f3ec:	f000 8257 	beq.w	801f89e <item_repos+0x4e6>
 801f3f0:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801f3f2:	2b00      	cmp	r3, #0
 801f3f4:	f000 8253 	beq.w	801f89e <item_repos+0x4e6>

    uint32_t col_pos = get_col_pos(item);
 801f3f8:	68f8      	ldr	r0, [r7, #12]
 801f3fa:	f7ff fb31 	bl	801ea60 <get_col_pos>
 801f3fe:	4603      	mov	r3, r0
 801f400:	653b      	str	r3, [r7, #80]	@ 0x50
    uint32_t row_pos = get_row_pos(item);
 801f402:	68f8      	ldr	r0, [r7, #12]
 801f404:	f7ff fb39 	bl	801ea7a <get_row_pos>
 801f408:	4603      	mov	r3, r0
 801f40a:	64fb      	str	r3, [r7, #76]	@ 0x4c
    lv_grid_align_t col_align = get_cell_col_align(item);
 801f40c:	68f8      	ldr	r0, [r7, #12]
 801f40e:	f7ff fb5b 	bl	801eac8 <get_cell_col_align>
 801f412:	4603      	mov	r3, r0
 801f414:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
    lv_grid_align_t row_align = get_cell_row_align(item);
 801f418:	68f8      	ldr	r0, [r7, #12]
 801f41a:	f7ff fb62 	bl	801eae2 <get_cell_row_align>
 801f41e:	4603      	mov	r3, r0
 801f420:	f887 304b 	strb.w	r3, [r7, #75]	@ 0x4b

    int32_t col_x1 = c->x[col_pos];
 801f424:	68bb      	ldr	r3, [r7, #8]
 801f426:	681a      	ldr	r2, [r3, #0]
 801f428:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801f42a:	009b      	lsls	r3, r3, #2
 801f42c:	4413      	add	r3, r2
 801f42e:	681b      	ldr	r3, [r3, #0]
 801f430:	647b      	str	r3, [r7, #68]	@ 0x44
    int32_t col_x2 = c->x[col_pos + col_span - 1] + c->w[col_pos + col_span - 1];
 801f432:	68bb      	ldr	r3, [r7, #8]
 801f434:	681a      	ldr	r2, [r3, #0]
 801f436:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801f438:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801f43a:	440b      	add	r3, r1
 801f43c:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 801f440:	3b01      	subs	r3, #1
 801f442:	009b      	lsls	r3, r3, #2
 801f444:	4413      	add	r3, r2
 801f446:	681a      	ldr	r2, [r3, #0]
 801f448:	68bb      	ldr	r3, [r7, #8]
 801f44a:	6899      	ldr	r1, [r3, #8]
 801f44c:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 801f44e:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 801f450:	4403      	add	r3, r0
 801f452:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 801f456:	3b01      	subs	r3, #1
 801f458:	009b      	lsls	r3, r3, #2
 801f45a:	440b      	add	r3, r1
 801f45c:	681b      	ldr	r3, [r3, #0]
 801f45e:	4413      	add	r3, r2
 801f460:	643b      	str	r3, [r7, #64]	@ 0x40
    int32_t col_w = col_x2 - col_x1;
 801f462:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 801f464:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 801f466:	1ad3      	subs	r3, r2, r3
 801f468:	63fb      	str	r3, [r7, #60]	@ 0x3c

    int32_t row_y1 = c->y[row_pos];
 801f46a:	68bb      	ldr	r3, [r7, #8]
 801f46c:	685a      	ldr	r2, [r3, #4]
 801f46e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801f470:	009b      	lsls	r3, r3, #2
 801f472:	4413      	add	r3, r2
 801f474:	681b      	ldr	r3, [r3, #0]
 801f476:	63bb      	str	r3, [r7, #56]	@ 0x38
    int32_t row_y2 = c->y[row_pos + row_span - 1] + c->h[row_pos + row_span - 1];
 801f478:	68bb      	ldr	r3, [r7, #8]
 801f47a:	685a      	ldr	r2, [r3, #4]
 801f47c:	6cf9      	ldr	r1, [r7, #76]	@ 0x4c
 801f47e:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f480:	440b      	add	r3, r1
 801f482:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 801f486:	3b01      	subs	r3, #1
 801f488:	009b      	lsls	r3, r3, #2
 801f48a:	4413      	add	r3, r2
 801f48c:	681a      	ldr	r2, [r3, #0]
 801f48e:	68bb      	ldr	r3, [r7, #8]
 801f490:	68d9      	ldr	r1, [r3, #12]
 801f492:	6cf8      	ldr	r0, [r7, #76]	@ 0x4c
 801f494:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 801f496:	4403      	add	r3, r0
 801f498:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 801f49c:	3b01      	subs	r3, #1
 801f49e:	009b      	lsls	r3, r3, #2
 801f4a0:	440b      	add	r3, r1
 801f4a2:	681b      	ldr	r3, [r3, #0]
 801f4a4:	4413      	add	r3, r2
 801f4a6:	637b      	str	r3, [r7, #52]	@ 0x34
    int32_t row_h = row_y2 - row_y1;
 801f4a8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 801f4aa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801f4ac:	1ad3      	subs	r3, r2, r3
 801f4ae:	633b      	str	r3, [r7, #48]	@ 0x30

    /*If the item has RTL base dir switch start and end*/
    if(lv_obj_get_style_base_dir(item, LV_PART_MAIN) == LV_BASE_DIR_RTL) {
 801f4b0:	2100      	movs	r1, #0
 801f4b2:	68f8      	ldr	r0, [r7, #12]
 801f4b4:	f7ff f9b4 	bl	801e820 <lv_obj_get_style_base_dir>
 801f4b8:	4603      	mov	r3, r0
 801f4ba:	2b01      	cmp	r3, #1
 801f4bc:	d10e      	bne.n	801f4dc <item_repos+0x124>
        if(col_align == LV_GRID_ALIGN_START) col_align = LV_GRID_ALIGN_END;
 801f4be:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 801f4c2:	2b00      	cmp	r3, #0
 801f4c4:	d103      	bne.n	801f4ce <item_repos+0x116>
 801f4c6:	2302      	movs	r3, #2
 801f4c8:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
 801f4cc:	e006      	b.n	801f4dc <item_repos+0x124>
        else if(col_align == LV_GRID_ALIGN_END) col_align = LV_GRID_ALIGN_START;
 801f4ce:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 801f4d2:	2b02      	cmp	r3, #2
 801f4d4:	d102      	bne.n	801f4dc <item_repos+0x124>
 801f4d6:	2300      	movs	r3, #0
 801f4d8:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
    }

    int32_t x;
    int32_t y;
    int32_t item_w = lv_area_get_width(&item->coords);
 801f4dc:	68fb      	ldr	r3, [r7, #12]
 801f4de:	3314      	adds	r3, #20
 801f4e0:	4618      	mov	r0, r3
 801f4e2:	f7ff f880 	bl	801e5e6 <lv_area_get_width>
 801f4e6:	66b8      	str	r0, [r7, #104]	@ 0x68
    int32_t item_h = lv_area_get_height(&item->coords);
 801f4e8:	68fb      	ldr	r3, [r7, #12]
 801f4ea:	3314      	adds	r3, #20
 801f4ec:	4618      	mov	r0, r3
 801f4ee:	f7ff f88a 	bl	801e606 <lv_area_get_height>
 801f4f2:	6678      	str	r0, [r7, #100]	@ 0x64

    switch(col_align) {
 801f4f4:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
 801f4f8:	2b03      	cmp	r3, #3
 801f4fa:	d01a      	beq.n	801f532 <item_repos+0x17a>
 801f4fc:	2b03      	cmp	r3, #3
 801f4fe:	dc03      	bgt.n	801f508 <item_repos+0x150>
 801f500:	2b01      	cmp	r3, #1
 801f502:	d032      	beq.n	801f56a <item_repos+0x1b2>
 801f504:	2b02      	cmp	r3, #2
 801f506:	d055      	beq.n	801f5b4 <item_repos+0x1fc>
        default:
        case LV_GRID_ALIGN_START:
            x = c->x[col_pos] + lv_obj_get_style_margin_left(item, LV_PART_MAIN);
 801f508:	68bb      	ldr	r3, [r7, #8]
 801f50a:	681a      	ldr	r2, [r3, #0]
 801f50c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801f50e:	009b      	lsls	r3, r3, #2
 801f510:	4413      	add	r3, r2
 801f512:	681c      	ldr	r4, [r3, #0]
 801f514:	2100      	movs	r1, #0
 801f516:	68f8      	ldr	r0, [r7, #12]
 801f518:	f7ff f93d 	bl	801e796 <lv_obj_get_style_margin_left>
 801f51c:	4603      	mov	r3, r0
 801f51e:	4423      	add	r3, r4
 801f520:	673b      	str	r3, [r7, #112]	@ 0x70
            item->w_layout = 0;
 801f522:	68fa      	ldr	r2, [r7, #12]
 801f524:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801f528:	f36f 03c3 	bfc	r3, #3, #1
 801f52c:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
            break;
 801f530:	e05c      	b.n	801f5ec <item_repos+0x234>
        case LV_GRID_ALIGN_STRETCH:
            x = c->x[col_pos] + lv_obj_get_style_margin_left(item, LV_PART_MAIN);
 801f532:	68bb      	ldr	r3, [r7, #8]
 801f534:	681a      	ldr	r2, [r3, #0]
 801f536:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801f538:	009b      	lsls	r3, r3, #2
 801f53a:	4413      	add	r3, r2
 801f53c:	681c      	ldr	r4, [r3, #0]
 801f53e:	2100      	movs	r1, #0
 801f540:	68f8      	ldr	r0, [r7, #12]
 801f542:	f7ff f928 	bl	801e796 <lv_obj_get_style_margin_left>
 801f546:	4603      	mov	r3, r0
 801f548:	4423      	add	r3, r4
 801f54a:	673b      	str	r3, [r7, #112]	@ 0x70
            item_w = col_w - get_margin_hor(item);
 801f54c:	68f8      	ldr	r0, [r7, #12]
 801f54e:	f7ff faef 	bl	801eb30 <get_margin_hor>
 801f552:	4602      	mov	r2, r0
 801f554:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801f556:	1a9b      	subs	r3, r3, r2
 801f558:	66bb      	str	r3, [r7, #104]	@ 0x68
            item->w_layout = 1;
 801f55a:	68fa      	ldr	r2, [r7, #12]
 801f55c:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801f560:	f043 0308 	orr.w	r3, r3, #8
 801f564:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
            break;
 801f568:	e040      	b.n	801f5ec <item_repos+0x234>
        case LV_GRID_ALIGN_CENTER:
            x = c->x[col_pos] + (col_w - item_w) / 2 + (lv_obj_get_style_margin_left(item, LV_PART_MAIN) -
 801f56a:	68bb      	ldr	r3, [r7, #8]
 801f56c:	681a      	ldr	r2, [r3, #0]
 801f56e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801f570:	009b      	lsls	r3, r3, #2
 801f572:	4413      	add	r3, r2
 801f574:	681a      	ldr	r2, [r3, #0]
 801f576:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 801f578:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801f57a:	1acb      	subs	r3, r1, r3
 801f57c:	0fd9      	lsrs	r1, r3, #31
 801f57e:	440b      	add	r3, r1
 801f580:	105b      	asrs	r3, r3, #1
 801f582:	18d4      	adds	r4, r2, r3
 801f584:	2100      	movs	r1, #0
 801f586:	68f8      	ldr	r0, [r7, #12]
 801f588:	f7ff f905 	bl	801e796 <lv_obj_get_style_margin_left>
 801f58c:	4605      	mov	r5, r0
                                                        lv_obj_get_style_margin_right(item, LV_PART_MAIN)) / 2;
 801f58e:	2100      	movs	r1, #0
 801f590:	68f8      	ldr	r0, [r7, #12]
 801f592:	f7ff f911 	bl	801e7b8 <lv_obj_get_style_margin_right>
 801f596:	4603      	mov	r3, r0
            x = c->x[col_pos] + (col_w - item_w) / 2 + (lv_obj_get_style_margin_left(item, LV_PART_MAIN) -
 801f598:	1aeb      	subs	r3, r5, r3
                                                        lv_obj_get_style_margin_right(item, LV_PART_MAIN)) / 2;
 801f59a:	0fda      	lsrs	r2, r3, #31
 801f59c:	4413      	add	r3, r2
 801f59e:	105b      	asrs	r3, r3, #1
            x = c->x[col_pos] + (col_w - item_w) / 2 + (lv_obj_get_style_margin_left(item, LV_PART_MAIN) -
 801f5a0:	4423      	add	r3, r4
 801f5a2:	673b      	str	r3, [r7, #112]	@ 0x70
            item->w_layout = 0;
 801f5a4:	68fa      	ldr	r2, [r7, #12]
 801f5a6:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801f5aa:	f36f 03c3 	bfc	r3, #3, #1
 801f5ae:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
            break;
 801f5b2:	e01b      	b.n	801f5ec <item_repos+0x234>
        case LV_GRID_ALIGN_END:
            x = c->x[col_pos] + col_w - lv_obj_get_width(item) - lv_obj_get_style_margin_right(item, LV_PART_MAIN);
 801f5b4:	68bb      	ldr	r3, [r7, #8]
 801f5b6:	681a      	ldr	r2, [r3, #0]
 801f5b8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 801f5ba:	009b      	lsls	r3, r3, #2
 801f5bc:	4413      	add	r3, r2
 801f5be:	681a      	ldr	r2, [r3, #0]
 801f5c0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801f5c2:	18d4      	adds	r4, r2, r3
 801f5c4:	68f8      	ldr	r0, [r7, #12]
 801f5c6:	f7e6 fbb3 	bl	8005d30 <lv_obj_get_width>
 801f5ca:	4603      	mov	r3, r0
 801f5cc:	1ae4      	subs	r4, r4, r3
 801f5ce:	2100      	movs	r1, #0
 801f5d0:	68f8      	ldr	r0, [r7, #12]
 801f5d2:	f7ff f8f1 	bl	801e7b8 <lv_obj_get_style_margin_right>
 801f5d6:	4603      	mov	r3, r0
 801f5d8:	1ae3      	subs	r3, r4, r3
 801f5da:	673b      	str	r3, [r7, #112]	@ 0x70
            item->w_layout = 0;
 801f5dc:	68fa      	ldr	r2, [r7, #12]
 801f5de:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801f5e2:	f36f 03c3 	bfc	r3, #3, #1
 801f5e6:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
            break;
 801f5ea:	bf00      	nop
    }

    switch(row_align) {
 801f5ec:	f897 304b 	ldrb.w	r3, [r7, #75]	@ 0x4b
 801f5f0:	2b03      	cmp	r3, #3
 801f5f2:	d01a      	beq.n	801f62a <item_repos+0x272>
 801f5f4:	2b03      	cmp	r3, #3
 801f5f6:	dc03      	bgt.n	801f600 <item_repos+0x248>
 801f5f8:	2b01      	cmp	r3, #1
 801f5fa:	d035      	beq.n	801f668 <item_repos+0x2b0>
 801f5fc:	2b02      	cmp	r3, #2
 801f5fe:	d058      	beq.n	801f6b2 <item_repos+0x2fa>
        default:
        case LV_GRID_ALIGN_START:
            y = c->y[row_pos] + lv_obj_get_style_margin_top(item, LV_PART_MAIN);
 801f600:	68bb      	ldr	r3, [r7, #8]
 801f602:	685a      	ldr	r2, [r3, #4]
 801f604:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801f606:	009b      	lsls	r3, r3, #2
 801f608:	4413      	add	r3, r2
 801f60a:	681c      	ldr	r4, [r3, #0]
 801f60c:	2100      	movs	r1, #0
 801f60e:	68f8      	ldr	r0, [r7, #12]
 801f610:	f7ff f89f 	bl	801e752 <lv_obj_get_style_margin_top>
 801f614:	4603      	mov	r3, r0
 801f616:	4423      	add	r3, r4
 801f618:	66fb      	str	r3, [r7, #108]	@ 0x6c
            item->h_layout = 0;
 801f61a:	68fa      	ldr	r2, [r7, #12]
 801f61c:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801f620:	f36f 0382 	bfc	r3, #2, #1
 801f624:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
            break;
 801f628:	e05f      	b.n	801f6ea <item_repos+0x332>
        case LV_GRID_ALIGN_STRETCH:
            y = c->y[row_pos] + lv_obj_get_style_margin_top(item, LV_PART_MAIN);
 801f62a:	68bb      	ldr	r3, [r7, #8]
 801f62c:	685a      	ldr	r2, [r3, #4]
 801f62e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801f630:	009b      	lsls	r3, r3, #2
 801f632:	4413      	add	r3, r2
 801f634:	681c      	ldr	r4, [r3, #0]
 801f636:	2100      	movs	r1, #0
 801f638:	68f8      	ldr	r0, [r7, #12]
 801f63a:	f7ff f88a 	bl	801e752 <lv_obj_get_style_margin_top>
 801f63e:	4603      	mov	r3, r0
 801f640:	4423      	add	r3, r4
 801f642:	66fb      	str	r3, [r7, #108]	@ 0x6c
            item_h = row_h - get_margin_ver(item);
 801f644:	68f8      	ldr	r0, [r7, #12]
 801f646:	f7ff fa86 	bl	801eb56 <get_margin_ver>
 801f64a:	4602      	mov	r2, r0
 801f64c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f64e:	1a9b      	subs	r3, r3, r2
 801f650:	667b      	str	r3, [r7, #100]	@ 0x64
            item->h_layout = 1;
 801f652:	68fa      	ldr	r2, [r7, #12]
 801f654:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801f658:	f043 0304 	orr.w	r3, r3, #4
 801f65c:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
            break;
 801f660:	e043      	b.n	801f6ea <item_repos+0x332>
 801f662:	bf00      	nop
 801f664:	00060001 	.word	0x00060001
        case LV_GRID_ALIGN_CENTER:
            y = c->y[row_pos] + (row_h - item_h) / 2 + (lv_obj_get_style_margin_top(item, LV_PART_MAIN) -
 801f668:	68bb      	ldr	r3, [r7, #8]
 801f66a:	685a      	ldr	r2, [r3, #4]
 801f66c:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801f66e:	009b      	lsls	r3, r3, #2
 801f670:	4413      	add	r3, r2
 801f672:	681a      	ldr	r2, [r3, #0]
 801f674:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 801f676:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801f678:	1acb      	subs	r3, r1, r3
 801f67a:	0fd9      	lsrs	r1, r3, #31
 801f67c:	440b      	add	r3, r1
 801f67e:	105b      	asrs	r3, r3, #1
 801f680:	18d4      	adds	r4, r2, r3
 801f682:	2100      	movs	r1, #0
 801f684:	68f8      	ldr	r0, [r7, #12]
 801f686:	f7ff f864 	bl	801e752 <lv_obj_get_style_margin_top>
 801f68a:	4605      	mov	r5, r0
                                                        lv_obj_get_style_margin_bottom(item, LV_PART_MAIN)) / 2;
 801f68c:	2100      	movs	r1, #0
 801f68e:	68f8      	ldr	r0, [r7, #12]
 801f690:	f7ff f870 	bl	801e774 <lv_obj_get_style_margin_bottom>
 801f694:	4603      	mov	r3, r0
            y = c->y[row_pos] + (row_h - item_h) / 2 + (lv_obj_get_style_margin_top(item, LV_PART_MAIN) -
 801f696:	1aeb      	subs	r3, r5, r3
                                                        lv_obj_get_style_margin_bottom(item, LV_PART_MAIN)) / 2;
 801f698:	0fda      	lsrs	r2, r3, #31
 801f69a:	4413      	add	r3, r2
 801f69c:	105b      	asrs	r3, r3, #1
            y = c->y[row_pos] + (row_h - item_h) / 2 + (lv_obj_get_style_margin_top(item, LV_PART_MAIN) -
 801f69e:	4423      	add	r3, r4
 801f6a0:	66fb      	str	r3, [r7, #108]	@ 0x6c
            item->h_layout = 0;
 801f6a2:	68fa      	ldr	r2, [r7, #12]
 801f6a4:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801f6a8:	f36f 0382 	bfc	r3, #2, #1
 801f6ac:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
            break;
 801f6b0:	e01b      	b.n	801f6ea <item_repos+0x332>
        case LV_GRID_ALIGN_END:
            y = c->y[row_pos] + row_h - lv_obj_get_height(item) - lv_obj_get_style_margin_bottom(item, LV_PART_MAIN);
 801f6b2:	68bb      	ldr	r3, [r7, #8]
 801f6b4:	685a      	ldr	r2, [r3, #4]
 801f6b6:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 801f6b8:	009b      	lsls	r3, r3, #2
 801f6ba:	4413      	add	r3, r2
 801f6bc:	681a      	ldr	r2, [r3, #0]
 801f6be:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f6c0:	18d4      	adds	r4, r2, r3
 801f6c2:	68f8      	ldr	r0, [r7, #12]
 801f6c4:	f7e6 fb42 	bl	8005d4c <lv_obj_get_height>
 801f6c8:	4603      	mov	r3, r0
 801f6ca:	1ae4      	subs	r4, r4, r3
 801f6cc:	2100      	movs	r1, #0
 801f6ce:	68f8      	ldr	r0, [r7, #12]
 801f6d0:	f7ff f850 	bl	801e774 <lv_obj_get_style_margin_bottom>
 801f6d4:	4603      	mov	r3, r0
 801f6d6:	1ae3      	subs	r3, r4, r3
 801f6d8:	66fb      	str	r3, [r7, #108]	@ 0x6c
            item->h_layout = 0;
 801f6da:	68fa      	ldr	r2, [r7, #12]
 801f6dc:	f892 302b 	ldrb.w	r3, [r2, #43]	@ 0x2b
 801f6e0:	f36f 0382 	bfc	r3, #2, #1
 801f6e4:	f882 302b 	strb.w	r3, [r2, #43]	@ 0x2b
            break;
 801f6e8:	bf00      	nop
    }

    /*Set a new size if required*/
    if(lv_obj_get_width(item) != item_w || lv_obj_get_height(item) != item_h) {
 801f6ea:	68f8      	ldr	r0, [r7, #12]
 801f6ec:	f7e6 fb20 	bl	8005d30 <lv_obj_get_width>
 801f6f0:	4602      	mov	r2, r0
 801f6f2:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 801f6f4:	4293      	cmp	r3, r2
 801f6f6:	d106      	bne.n	801f706 <item_repos+0x34e>
 801f6f8:	68f8      	ldr	r0, [r7, #12]
 801f6fa:	f7e6 fb27 	bl	8005d4c <lv_obj_get_height>
 801f6fe:	4602      	mov	r2, r0
 801f700:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 801f702:	4293      	cmp	r3, r2
 801f704:	d02a      	beq.n	801f75c <item_repos+0x3a4>
        lv_area_t old_coords;
        lv_area_copy(&old_coords, &item->coords);
 801f706:	68fb      	ldr	r3, [r7, #12]
 801f708:	f103 0214 	add.w	r2, r3, #20
 801f70c:	f107 0310 	add.w	r3, r7, #16
 801f710:	4611      	mov	r1, r2
 801f712:	4618      	mov	r0, r3
 801f714:	f7fe ff4c 	bl	801e5b0 <lv_area_copy>
        lv_obj_invalidate(item);
 801f718:	68f8      	ldr	r0, [r7, #12]
 801f71a:	f7e6 ff91 	bl	8006640 <lv_obj_invalidate>
        lv_area_set_width(&item->coords, item_w);
 801f71e:	68fb      	ldr	r3, [r7, #12]
 801f720:	3314      	adds	r3, #20
 801f722:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 801f724:	4618      	mov	r0, r3
 801f726:	f002 f888 	bl	802183a <lv_area_set_width>
        lv_area_set_height(&item->coords, item_h);
 801f72a:	68fb      	ldr	r3, [r7, #12]
 801f72c:	3314      	adds	r3, #20
 801f72e:	6e79      	ldr	r1, [r7, #100]	@ 0x64
 801f730:	4618      	mov	r0, r3
 801f732:	f002 f894 	bl	802185e <lv_area_set_height>
        lv_obj_invalidate(item);
 801f736:	68f8      	ldr	r0, [r7, #12]
 801f738:	f7e6 ff82 	bl	8006640 <lv_obj_invalidate>
        lv_obj_send_event(item, LV_EVENT_SIZE_CHANGED, &old_coords);
 801f73c:	f107 0310 	add.w	r3, r7, #16
 801f740:	461a      	mov	r2, r3
 801f742:	212b      	movs	r1, #43	@ 0x2b
 801f744:	68f8      	ldr	r0, [r7, #12]
 801f746:	f7e5 fb65 	bl	8004e14 <lv_obj_send_event>
        lv_obj_send_event(lv_obj_get_parent(item), LV_EVENT_CHILD_CHANGED, item);
 801f74a:	68f8      	ldr	r0, [r7, #12]
 801f74c:	f7eb fb72 	bl	800ae34 <lv_obj_get_parent>
 801f750:	4603      	mov	r3, r0
 801f752:	68fa      	ldr	r2, [r7, #12]
 801f754:	2124      	movs	r1, #36	@ 0x24
 801f756:	4618      	mov	r0, r3
 801f758:	f7e5 fb5c 	bl	8004e14 <lv_obj_send_event>

    }

    /*Handle percentage value of translate*/
    int32_t tr_x = lv_obj_get_style_translate_x(item, LV_PART_MAIN);
 801f75c:	2100      	movs	r1, #0
 801f75e:	68f8      	ldr	r0, [r7, #12]
 801f760:	f7fe ff91 	bl	801e686 <lv_obj_get_style_translate_x>
 801f764:	6638      	str	r0, [r7, #96]	@ 0x60
    int32_t tr_y = lv_obj_get_style_translate_y(item, LV_PART_MAIN);
 801f766:	2100      	movs	r1, #0
 801f768:	68f8      	ldr	r0, [r7, #12]
 801f76a:	f7fe ff9d 	bl	801e6a8 <lv_obj_get_style_translate_y>
 801f76e:	65f8      	str	r0, [r7, #92]	@ 0x5c
    int32_t w = lv_obj_get_width(item);
 801f770:	68f8      	ldr	r0, [r7, #12]
 801f772:	f7e6 fadd 	bl	8005d30 <lv_obj_get_width>
 801f776:	62f8      	str	r0, [r7, #44]	@ 0x2c
    int32_t h = lv_obj_get_height(item);
 801f778:	68f8      	ldr	r0, [r7, #12]
 801f77a:	f7e6 fae7 	bl	8005d4c <lv_obj_get_height>
 801f77e:	62b8      	str	r0, [r7, #40]	@ 0x28
    if(LV_COORD_IS_PCT(tr_x)) tr_x = (w * LV_COORD_GET_PCT(tr_x)) / 100;
 801f780:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801f782:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 801f786:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 801f78a:	d11e      	bne.n	801f7ca <item_repos+0x412>
 801f78c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801f78e:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801f792:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 801f796:	dc18      	bgt.n	801f7ca <item_repos+0x412>
 801f798:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801f79a:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801f79e:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 801f7a2:	dd05      	ble.n	801f7b0 <item_repos+0x3f8>
 801f7a4:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801f7a6:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801f7aa:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 801f7ae:	e002      	b.n	801f7b6 <item_repos+0x3fe>
 801f7b0:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801f7b2:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801f7b6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801f7b8:	fb02 f303 	mul.w	r3, r2, r3
 801f7bc:	4a3a      	ldr	r2, [pc, #232]	@ (801f8a8 <item_repos+0x4f0>)
 801f7be:	fb82 1203 	smull	r1, r2, r2, r3
 801f7c2:	1152      	asrs	r2, r2, #5
 801f7c4:	17db      	asrs	r3, r3, #31
 801f7c6:	1ad3      	subs	r3, r2, r3
 801f7c8:	663b      	str	r3, [r7, #96]	@ 0x60
    if(LV_COORD_IS_PCT(tr_y)) tr_y = (h * LV_COORD_GET_PCT(tr_y)) / 100;
 801f7ca:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801f7cc:	f003 43c0 	and.w	r3, r3, #1610612736	@ 0x60000000
 801f7d0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 801f7d4:	d11e      	bne.n	801f814 <item_repos+0x45c>
 801f7d6:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801f7d8:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801f7dc:	f5b3 6ffa 	cmp.w	r3, #2000	@ 0x7d0
 801f7e0:	dc18      	bgt.n	801f814 <item_repos+0x45c>
 801f7e2:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801f7e4:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801f7e8:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 801f7ec:	dd05      	ble.n	801f7fa <item_repos+0x442>
 801f7ee:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801f7f0:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801f7f4:	f5c3 737a 	rsb	r3, r3, #1000	@ 0x3e8
 801f7f8:	e002      	b.n	801f800 <item_repos+0x448>
 801f7fa:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801f7fc:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 801f800:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801f802:	fb02 f303 	mul.w	r3, r2, r3
 801f806:	4a28      	ldr	r2, [pc, #160]	@ (801f8a8 <item_repos+0x4f0>)
 801f808:	fb82 1203 	smull	r1, r2, r2, r3
 801f80c:	1152      	asrs	r2, r2, #5
 801f80e:	17db      	asrs	r3, r3, #31
 801f810:	1ad3      	subs	r3, r2, r3
 801f812:	65fb      	str	r3, [r7, #92]	@ 0x5c

    x += tr_x;
 801f814:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 801f816:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801f818:	4413      	add	r3, r2
 801f81a:	673b      	str	r3, [r7, #112]	@ 0x70
    y += tr_y;
 801f81c:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 801f81e:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 801f820:	4413      	add	r3, r2
 801f822:	66fb      	str	r3, [r7, #108]	@ 0x6c

    int32_t diff_x = hint->grid_abs.x + x - item->coords.x1;
 801f824:	687b      	ldr	r3, [r7, #4]
 801f826:	689a      	ldr	r2, [r3, #8]
 801f828:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 801f82a:	441a      	add	r2, r3
 801f82c:	68fb      	ldr	r3, [r7, #12]
 801f82e:	695b      	ldr	r3, [r3, #20]
 801f830:	1ad3      	subs	r3, r2, r3
 801f832:	627b      	str	r3, [r7, #36]	@ 0x24
    int32_t diff_y = hint->grid_abs.y + y - item->coords.y1;
 801f834:	687b      	ldr	r3, [r7, #4]
 801f836:	68da      	ldr	r2, [r3, #12]
 801f838:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801f83a:	441a      	add	r2, r3
 801f83c:	68fb      	ldr	r3, [r7, #12]
 801f83e:	699b      	ldr	r3, [r3, #24]
 801f840:	1ad3      	subs	r3, r2, r3
 801f842:	623b      	str	r3, [r7, #32]
    if(diff_x || diff_y) {
 801f844:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f846:	2b00      	cmp	r3, #0
 801f848:	d102      	bne.n	801f850 <item_repos+0x498>
 801f84a:	6a3b      	ldr	r3, [r7, #32]
 801f84c:	2b00      	cmp	r3, #0
 801f84e:	d027      	beq.n	801f8a0 <item_repos+0x4e8>
        lv_obj_invalidate(item);
 801f850:	68f8      	ldr	r0, [r7, #12]
 801f852:	f7e6 fef5 	bl	8006640 <lv_obj_invalidate>
        item->coords.x1 += diff_x;
 801f856:	68fb      	ldr	r3, [r7, #12]
 801f858:	695a      	ldr	r2, [r3, #20]
 801f85a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f85c:	441a      	add	r2, r3
 801f85e:	68fb      	ldr	r3, [r7, #12]
 801f860:	615a      	str	r2, [r3, #20]
        item->coords.x2 += diff_x;
 801f862:	68fb      	ldr	r3, [r7, #12]
 801f864:	69da      	ldr	r2, [r3, #28]
 801f866:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801f868:	441a      	add	r2, r3
 801f86a:	68fb      	ldr	r3, [r7, #12]
 801f86c:	61da      	str	r2, [r3, #28]
        item->coords.y1 += diff_y;
 801f86e:	68fb      	ldr	r3, [r7, #12]
 801f870:	699a      	ldr	r2, [r3, #24]
 801f872:	6a3b      	ldr	r3, [r7, #32]
 801f874:	441a      	add	r2, r3
 801f876:	68fb      	ldr	r3, [r7, #12]
 801f878:	619a      	str	r2, [r3, #24]
        item->coords.y2 += diff_y;
 801f87a:	68fb      	ldr	r3, [r7, #12]
 801f87c:	6a1a      	ldr	r2, [r3, #32]
 801f87e:	6a3b      	ldr	r3, [r7, #32]
 801f880:	441a      	add	r2, r3
 801f882:	68fb      	ldr	r3, [r7, #12]
 801f884:	621a      	str	r2, [r3, #32]
        lv_obj_invalidate(item);
 801f886:	68f8      	ldr	r0, [r7, #12]
 801f888:	f7e6 feda 	bl	8006640 <lv_obj_invalidate>
        lv_obj_move_children_by(item, diff_x, diff_y, false);
 801f88c:	2300      	movs	r3, #0
 801f88e:	6a3a      	ldr	r2, [r7, #32]
 801f890:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 801f892:	68f8      	ldr	r0, [r7, #12]
 801f894:	f7e6 fd81 	bl	800639a <lv_obj_move_children_by>
 801f898:	e002      	b.n	801f8a0 <item_repos+0x4e8>
    if(lv_obj_has_flag_any(item, LV_OBJ_FLAG_IGNORE_LAYOUT | LV_OBJ_FLAG_HIDDEN | LV_OBJ_FLAG_FLOATING)) return;
 801f89a:	bf00      	nop
 801f89c:	e000      	b.n	801f8a0 <item_repos+0x4e8>
    if(row_span == 0 || col_span == 0) return;
 801f89e:	bf00      	nop
    }
}
 801f8a0:	3778      	adds	r7, #120	@ 0x78
 801f8a2:	46bd      	mov	sp, r7
 801f8a4:	bdb0      	pop	{r4, r5, r7, pc}
 801f8a6:	bf00      	nop
 801f8a8:	51eb851f 	.word	0x51eb851f

0801f8ac <grid_align>:
 * @return the total size of the grid
 */
static int32_t grid_align(int32_t cont_size,  bool auto_size, lv_grid_align_t align, int32_t gap,
                          uint32_t track_num,
                          int32_t * size_array, int32_t * pos_array, bool reverse)
{
 801f8ac:	b480      	push	{r7}
 801f8ae:	b089      	sub	sp, #36	@ 0x24
 801f8b0:	af00      	add	r7, sp, #0
 801f8b2:	60f8      	str	r0, [r7, #12]
 801f8b4:	607b      	str	r3, [r7, #4]
 801f8b6:	460b      	mov	r3, r1
 801f8b8:	72fb      	strb	r3, [r7, #11]
 801f8ba:	4613      	mov	r3, r2
 801f8bc:	72bb      	strb	r3, [r7, #10]
    int32_t grid_size = 0;
 801f8be:	2300      	movs	r3, #0
 801f8c0:	61fb      	str	r3, [r7, #28]
    uint32_t i;

    if(auto_size) {
 801f8c2:	7afb      	ldrb	r3, [r7, #11]
 801f8c4:	2b00      	cmp	r3, #0
 801f8c6:	d003      	beq.n	801f8d0 <grid_align+0x24>
        pos_array[0] = 0;
 801f8c8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f8ca:	2200      	movs	r2, #0
 801f8cc:	601a      	str	r2, [r3, #0]
 801f8ce:	e077      	b.n	801f9c0 <grid_align+0x114>
    }
    else {
        /*With spaced alignment gap will be calculated from the remaining space*/
        if(align == LV_GRID_ALIGN_SPACE_AROUND || align == LV_GRID_ALIGN_SPACE_BETWEEN || align == LV_GRID_ALIGN_SPACE_EVENLY) {
 801f8d0:	7abb      	ldrb	r3, [r7, #10]
 801f8d2:	2b05      	cmp	r3, #5
 801f8d4:	d005      	beq.n	801f8e2 <grid_align+0x36>
 801f8d6:	7abb      	ldrb	r3, [r7, #10]
 801f8d8:	2b06      	cmp	r3, #6
 801f8da:	d002      	beq.n	801f8e2 <grid_align+0x36>
 801f8dc:	7abb      	ldrb	r3, [r7, #10]
 801f8de:	2b04      	cmp	r3, #4
 801f8e0:	d106      	bne.n	801f8f0 <grid_align+0x44>
            gap = 0;
 801f8e2:	2300      	movs	r3, #0
 801f8e4:	607b      	str	r3, [r7, #4]
            if(track_num == 1) align = LV_GRID_ALIGN_CENTER;
 801f8e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f8e8:	2b01      	cmp	r3, #1
 801f8ea:	d101      	bne.n	801f8f0 <grid_align+0x44>
 801f8ec:	2301      	movs	r3, #1
 801f8ee:	72bb      	strb	r3, [r7, #10]
        }

        /*Get the full grid size with gap*/
        for(i = 0; i < track_num; i++) {
 801f8f0:	2300      	movs	r3, #0
 801f8f2:	61bb      	str	r3, [r7, #24]
 801f8f4:	e00c      	b.n	801f910 <grid_align+0x64>
            grid_size += size_array[i] + gap;
 801f8f6:	69bb      	ldr	r3, [r7, #24]
 801f8f8:	009b      	lsls	r3, r3, #2
 801f8fa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801f8fc:	4413      	add	r3, r2
 801f8fe:	681a      	ldr	r2, [r3, #0]
 801f900:	687b      	ldr	r3, [r7, #4]
 801f902:	4413      	add	r3, r2
 801f904:	69fa      	ldr	r2, [r7, #28]
 801f906:	4413      	add	r3, r2
 801f908:	61fb      	str	r3, [r7, #28]
        for(i = 0; i < track_num; i++) {
 801f90a:	69bb      	ldr	r3, [r7, #24]
 801f90c:	3301      	adds	r3, #1
 801f90e:	61bb      	str	r3, [r7, #24]
 801f910:	69ba      	ldr	r2, [r7, #24]
 801f912:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f914:	429a      	cmp	r2, r3
 801f916:	d3ee      	bcc.n	801f8f6 <grid_align+0x4a>
        }
        grid_size -= gap;
 801f918:	69fa      	ldr	r2, [r7, #28]
 801f91a:	687b      	ldr	r3, [r7, #4]
 801f91c:	1ad3      	subs	r3, r2, r3
 801f91e:	61fb      	str	r3, [r7, #28]

        /*Calculate the position of the first item and set gap is necessary*/
        switch(align) {
 801f920:	7abb      	ldrb	r3, [r7, #10]
 801f922:	2b06      	cmp	r3, #6
 801f924:	d84b      	bhi.n	801f9be <grid_align+0x112>
 801f926:	a201      	add	r2, pc, #4	@ (adr r2, 801f92c <grid_align+0x80>)
 801f928:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801f92c:	0801f949 	.word	0x0801f949
 801f930:	0801f951 	.word	0x0801f951
 801f934:	0801f965 	.word	0x0801f965
 801f938:	0801f9bf 	.word	0x0801f9bf
 801f93c:	0801f9a7 	.word	0x0801f9a7
 801f940:	0801f989 	.word	0x0801f989
 801f944:	0801f971 	.word	0x0801f971
            case LV_GRID_ALIGN_START:
                pos_array[0] = 0;
 801f948:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f94a:	2200      	movs	r2, #0
 801f94c:	601a      	str	r2, [r3, #0]
                break;
 801f94e:	e037      	b.n	801f9c0 <grid_align+0x114>
            case LV_GRID_ALIGN_CENTER:
                pos_array[0] = (cont_size - grid_size) / 2;
 801f950:	68fa      	ldr	r2, [r7, #12]
 801f952:	69fb      	ldr	r3, [r7, #28]
 801f954:	1ad3      	subs	r3, r2, r3
 801f956:	0fda      	lsrs	r2, r3, #31
 801f958:	4413      	add	r3, r2
 801f95a:	105b      	asrs	r3, r3, #1
 801f95c:	461a      	mov	r2, r3
 801f95e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f960:	601a      	str	r2, [r3, #0]
                break;
 801f962:	e02d      	b.n	801f9c0 <grid_align+0x114>
            case LV_GRID_ALIGN_END:
                pos_array[0] = cont_size - grid_size;
 801f964:	68fa      	ldr	r2, [r7, #12]
 801f966:	69fb      	ldr	r3, [r7, #28]
 801f968:	1ad2      	subs	r2, r2, r3
 801f96a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f96c:	601a      	str	r2, [r3, #0]
                break;
 801f96e:	e027      	b.n	801f9c0 <grid_align+0x114>
            case LV_GRID_ALIGN_SPACE_BETWEEN:
                pos_array[0] = 0;
 801f970:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f972:	2200      	movs	r2, #0
 801f974:	601a      	str	r2, [r3, #0]
                gap = (int32_t)(cont_size - grid_size) / (int32_t)(track_num - 1);
 801f976:	68fa      	ldr	r2, [r7, #12]
 801f978:	69fb      	ldr	r3, [r7, #28]
 801f97a:	1ad3      	subs	r3, r2, r3
 801f97c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801f97e:	3a01      	subs	r2, #1
 801f980:	fb93 f3f2 	sdiv	r3, r3, r2
 801f984:	607b      	str	r3, [r7, #4]
                break;
 801f986:	e01b      	b.n	801f9c0 <grid_align+0x114>
            case LV_GRID_ALIGN_SPACE_AROUND:
                gap = (int32_t)(cont_size - grid_size) / (int32_t)(track_num);
 801f988:	68fa      	ldr	r2, [r7, #12]
 801f98a:	69fb      	ldr	r3, [r7, #28]
 801f98c:	1ad2      	subs	r2, r2, r3
 801f98e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f990:	fb92 f3f3 	sdiv	r3, r2, r3
 801f994:	607b      	str	r3, [r7, #4]
                pos_array[0] = gap / 2;
 801f996:	687b      	ldr	r3, [r7, #4]
 801f998:	0fda      	lsrs	r2, r3, #31
 801f99a:	4413      	add	r3, r2
 801f99c:	105b      	asrs	r3, r3, #1
 801f99e:	461a      	mov	r2, r3
 801f9a0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f9a2:	601a      	str	r2, [r3, #0]
                break;
 801f9a4:	e00c      	b.n	801f9c0 <grid_align+0x114>
            case LV_GRID_ALIGN_SPACE_EVENLY:
                gap = (int32_t)(cont_size - grid_size) / (int32_t)(track_num + 1);
 801f9a6:	68fa      	ldr	r2, [r7, #12]
 801f9a8:	69fb      	ldr	r3, [r7, #28]
 801f9aa:	1ad3      	subs	r3, r2, r3
 801f9ac:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801f9ae:	3201      	adds	r2, #1
 801f9b0:	fb93 f3f2 	sdiv	r3, r3, r2
 801f9b4:	607b      	str	r3, [r7, #4]
                pos_array[0] = gap;
 801f9b6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801f9b8:	687a      	ldr	r2, [r7, #4]
 801f9ba:	601a      	str	r2, [r3, #0]
                break;
 801f9bc:	e000      	b.n	801f9c0 <grid_align+0x114>
            default:
                break;
 801f9be:	bf00      	nop
        }
    }

    /*Set the position of all tracks from the start position, gaps and track sizes*/
    for(i = 0; i < track_num - 1; i++) {
 801f9c0:	2300      	movs	r3, #0
 801f9c2:	61bb      	str	r3, [r7, #24]
 801f9c4:	e015      	b.n	801f9f2 <grid_align+0x146>
        pos_array[i + 1] = pos_array[i] + size_array[i] + gap;
 801f9c6:	69bb      	ldr	r3, [r7, #24]
 801f9c8:	009b      	lsls	r3, r3, #2
 801f9ca:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801f9cc:	4413      	add	r3, r2
 801f9ce:	681a      	ldr	r2, [r3, #0]
 801f9d0:	69bb      	ldr	r3, [r7, #24]
 801f9d2:	009b      	lsls	r3, r3, #2
 801f9d4:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 801f9d6:	440b      	add	r3, r1
 801f9d8:	681b      	ldr	r3, [r3, #0]
 801f9da:	18d1      	adds	r1, r2, r3
 801f9dc:	69bb      	ldr	r3, [r7, #24]
 801f9de:	3301      	adds	r3, #1
 801f9e0:	009b      	lsls	r3, r3, #2
 801f9e2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801f9e4:	4413      	add	r3, r2
 801f9e6:	687a      	ldr	r2, [r7, #4]
 801f9e8:	440a      	add	r2, r1
 801f9ea:	601a      	str	r2, [r3, #0]
    for(i = 0; i < track_num - 1; i++) {
 801f9ec:	69bb      	ldr	r3, [r7, #24]
 801f9ee:	3301      	adds	r3, #1
 801f9f0:	61bb      	str	r3, [r7, #24]
 801f9f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f9f4:	3b01      	subs	r3, #1
 801f9f6:	69ba      	ldr	r2, [r7, #24]
 801f9f8:	429a      	cmp	r2, r3
 801f9fa:	d3e4      	bcc.n	801f9c6 <grid_align+0x11a>
    }

    int32_t total_gird_size = pos_array[track_num - 1] + size_array[track_num - 1] - pos_array[0];
 801f9fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801f9fe:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 801fa02:	3b01      	subs	r3, #1
 801fa04:	009b      	lsls	r3, r3, #2
 801fa06:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801fa08:	4413      	add	r3, r2
 801fa0a:	681a      	ldr	r2, [r3, #0]
 801fa0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801fa0e:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 801fa12:	3b01      	subs	r3, #1
 801fa14:	009b      	lsls	r3, r3, #2
 801fa16:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 801fa18:	440b      	add	r3, r1
 801fa1a:	681b      	ldr	r3, [r3, #0]
 801fa1c:	441a      	add	r2, r3
 801fa1e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 801fa20:	681b      	ldr	r3, [r3, #0]
 801fa22:	1ad3      	subs	r3, r2, r3
 801fa24:	617b      	str	r3, [r7, #20]

    if(reverse) {
 801fa26:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 801fa2a:	2b00      	cmp	r3, #0
 801fa2c:	d01b      	beq.n	801fa66 <grid_align+0x1ba>
        for(i = 0; i < track_num; i++) {
 801fa2e:	2300      	movs	r3, #0
 801fa30:	61bb      	str	r3, [r7, #24]
 801fa32:	e014      	b.n	801fa5e <grid_align+0x1b2>
            pos_array[i] = cont_size - pos_array[i] - size_array[i];
 801fa34:	69bb      	ldr	r3, [r7, #24]
 801fa36:	009b      	lsls	r3, r3, #2
 801fa38:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801fa3a:	4413      	add	r3, r2
 801fa3c:	681b      	ldr	r3, [r3, #0]
 801fa3e:	68fa      	ldr	r2, [r7, #12]
 801fa40:	1ad1      	subs	r1, r2, r3
 801fa42:	69bb      	ldr	r3, [r7, #24]
 801fa44:	009b      	lsls	r3, r3, #2
 801fa46:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 801fa48:	4413      	add	r3, r2
 801fa4a:	681a      	ldr	r2, [r3, #0]
 801fa4c:	69bb      	ldr	r3, [r7, #24]
 801fa4e:	009b      	lsls	r3, r3, #2
 801fa50:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 801fa52:	4403      	add	r3, r0
 801fa54:	1a8a      	subs	r2, r1, r2
 801fa56:	601a      	str	r2, [r3, #0]
        for(i = 0; i < track_num; i++) {
 801fa58:	69bb      	ldr	r3, [r7, #24]
 801fa5a:	3301      	adds	r3, #1
 801fa5c:	61bb      	str	r3, [r7, #24]
 801fa5e:	69ba      	ldr	r2, [r7, #24]
 801fa60:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801fa62:	429a      	cmp	r2, r3
 801fa64:	d3e6      	bcc.n	801fa34 <grid_align+0x188>
        }

    }

    /*Return the full size of the grid*/
    return total_gird_size;
 801fa66:	697b      	ldr	r3, [r7, #20]
}
 801fa68:	4618      	mov	r0, r3
 801fa6a:	3724      	adds	r7, #36	@ 0x24
 801fa6c:	46bd      	mov	sp, r7
 801fa6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fa72:	4770      	bx	lr

0801fa74 <count_tracks>:

static uint32_t count_tracks(const int32_t * templ)
{
 801fa74:	b480      	push	{r7}
 801fa76:	b085      	sub	sp, #20
 801fa78:	af00      	add	r7, sp, #0
 801fa7a:	6078      	str	r0, [r7, #4]
    uint32_t i;
    for(i = 0; templ[i] != LV_GRID_TEMPLATE_LAST; i++);
 801fa7c:	2300      	movs	r3, #0
 801fa7e:	60fb      	str	r3, [r7, #12]
 801fa80:	e002      	b.n	801fa88 <count_tracks+0x14>
 801fa82:	68fb      	ldr	r3, [r7, #12]
 801fa84:	3301      	adds	r3, #1
 801fa86:	60fb      	str	r3, [r7, #12]
 801fa88:	68fb      	ldr	r3, [r7, #12]
 801fa8a:	009b      	lsls	r3, r3, #2
 801fa8c:	687a      	ldr	r2, [r7, #4]
 801fa8e:	4413      	add	r3, r2
 801fa90:	681b      	ldr	r3, [r3, #0]
 801fa92:	f06f 4260 	mvn.w	r2, #3758096384	@ 0xe0000000
 801fa96:	4293      	cmp	r3, r2
 801fa98:	d1f3      	bne.n	801fa82 <count_tracks+0xe>

    return i;
 801fa9a:	68fb      	ldr	r3, [r7, #12]
}
 801fa9c:	4618      	mov	r0, r3
 801fa9e:	3714      	adds	r7, #20
 801faa0:	46bd      	mov	sp, r7
 801faa2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801faa6:	4770      	bx	lr

0801faa8 <lv_obj_get_style_layout>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BLEND_MODE);
    return (lv_blend_mode_t)v.num;
}

static inline uint16_t lv_obj_get_style_layout(const lv_obj_t * obj, uint32_t part)
{
 801faa8:	b580      	push	{r7, lr}
 801faaa:	b084      	sub	sp, #16
 801faac:	af00      	add	r7, sp, #0
 801faae:	6078      	str	r0, [r7, #4]
 801fab0:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_LAYOUT);
 801fab2:	2216      	movs	r2, #22
 801fab4:	6839      	ldr	r1, [r7, #0]
 801fab6:	6878      	ldr	r0, [r7, #4]
 801fab8:	f7e9 fe36 	bl	8009728 <lv_obj_get_style_prop>
 801fabc:	4603      	mov	r3, r0
 801fabe:	60fb      	str	r3, [r7, #12]
    return (uint16_t)v.num;
 801fac0:	68fb      	ldr	r3, [r7, #12]
 801fac2:	b29b      	uxth	r3, r3
}
 801fac4:	4618      	mov	r0, r3
 801fac6:	3710      	adds	r7, #16
 801fac8:	46bd      	mov	sp, r7
 801faca:	bd80      	pop	{r7, pc}

0801facc <_lv_layout_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void _lv_layout_init(void)
{
 801facc:	b580      	push	{r7, lr}
 801face:	af00      	add	r7, sp, #0
    /*Malloc a list for the built in layouts*/
    layout_list_def = lv_malloc(layout_cnt * sizeof(lv_layout_dsc_t));
 801fad0:	4b07      	ldr	r3, [pc, #28]	@ (801faf0 <_lv_layout_init+0x24>)
 801fad2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 801fad4:	00db      	lsls	r3, r3, #3
 801fad6:	4618      	mov	r0, r3
 801fad8:	f006 f976 	bl	8025dc8 <lv_malloc>
 801fadc:	4603      	mov	r3, r0
 801fade:	4a04      	ldr	r2, [pc, #16]	@ (801faf0 <_lv_layout_init+0x24>)
 801fae0:	65d3      	str	r3, [r2, #92]	@ 0x5c

#if LV_USE_FLEX
    lv_flex_init();
 801fae2:	f7fd fce9 	bl	801d4b8 <lv_flex_init>
#endif

#if LV_USE_GRID
    lv_grid_init();
 801fae6:	f7ff f849 	bl	801eb7c <lv_grid_init>
#endif
}
 801faea:	bf00      	nop
 801faec:	bd80      	pop	{r7, pc}
 801faee:	bf00      	nop
 801faf0:	2000009c 	.word	0x2000009c

0801faf4 <_lv_layout_apply>:
    layout_list_def[layout_cnt].user_data = user_data;
    return layout_cnt++;
}

void _lv_layout_apply(lv_obj_t * obj)
{
 801faf4:	b580      	push	{r7, lr}
 801faf6:	b084      	sub	sp, #16
 801faf8:	af00      	add	r7, sp, #0
 801fafa:	6078      	str	r0, [r7, #4]
    lv_layout_t layout_id = lv_obj_get_style_layout(obj, LV_PART_MAIN);
 801fafc:	2100      	movs	r1, #0
 801fafe:	6878      	ldr	r0, [r7, #4]
 801fb00:	f7ff ffd2 	bl	801faa8 <lv_obj_get_style_layout>
 801fb04:	4603      	mov	r3, r0
 801fb06:	73fb      	strb	r3, [r7, #15]
    if(layout_id > 0 && layout_id <= layout_cnt) {
 801fb08:	7bfb      	ldrb	r3, [r7, #15]
 801fb0a:	2b00      	cmp	r3, #0
 801fb0c:	d014      	beq.n	801fb38 <_lv_layout_apply+0x44>
 801fb0e:	7bfa      	ldrb	r2, [r7, #15]
 801fb10:	4b0b      	ldr	r3, [pc, #44]	@ (801fb40 <_lv_layout_apply+0x4c>)
 801fb12:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 801fb14:	429a      	cmp	r2, r3
 801fb16:	d80f      	bhi.n	801fb38 <_lv_layout_apply+0x44>
        void  * user_data = layout_list_def[layout_id].user_data;
 801fb18:	4b09      	ldr	r3, [pc, #36]	@ (801fb40 <_lv_layout_apply+0x4c>)
 801fb1a:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 801fb1c:	7bfb      	ldrb	r3, [r7, #15]
 801fb1e:	00db      	lsls	r3, r3, #3
 801fb20:	4413      	add	r3, r2
 801fb22:	685b      	ldr	r3, [r3, #4]
 801fb24:	60bb      	str	r3, [r7, #8]
        layout_list_def[layout_id].cb(obj, user_data);
 801fb26:	4b06      	ldr	r3, [pc, #24]	@ (801fb40 <_lv_layout_apply+0x4c>)
 801fb28:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 801fb2a:	7bfb      	ldrb	r3, [r7, #15]
 801fb2c:	00db      	lsls	r3, r3, #3
 801fb2e:	4413      	add	r3, r2
 801fb30:	681b      	ldr	r3, [r3, #0]
 801fb32:	68b9      	ldr	r1, [r7, #8]
 801fb34:	6878      	ldr	r0, [r7, #4]
 801fb36:	4798      	blx	r3
    }
}
 801fb38:	bf00      	nop
 801fb3a:	3710      	adds	r7, #16
 801fb3c:	46bd      	mov	sp, r7
 801fb3e:	bd80      	pop	{r7, pc}
 801fb40:	2000009c 	.word	0x2000009c

0801fb44 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline int32_t lv_area_get_width(const lv_area_t * area_p)
{
 801fb44:	b480      	push	{r7}
 801fb46:	b083      	sub	sp, #12
 801fb48:	af00      	add	r7, sp, #0
 801fb4a:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 801fb4c:	687b      	ldr	r3, [r7, #4]
 801fb4e:	689a      	ldr	r2, [r3, #8]
 801fb50:	687b      	ldr	r3, [r7, #4]
 801fb52:	681b      	ldr	r3, [r3, #0]
 801fb54:	1ad3      	subs	r3, r2, r3
 801fb56:	3301      	adds	r3, #1
}
 801fb58:	4618      	mov	r0, r3
 801fb5a:	370c      	adds	r7, #12
 801fb5c:	46bd      	mov	sp, r7
 801fb5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fb62:	4770      	bx	lr

0801fb64 <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 801fb64:	b580      	push	{r7, lr}
 801fb66:	b082      	sub	sp, #8
 801fb68:	af00      	add	r7, sp, #0
 801fb6a:	6078      	str	r0, [r7, #4]
 801fb6c:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 801fb6e:	683a      	ldr	r2, [r7, #0]
 801fb70:	2100      	movs	r1, #0
 801fb72:	6878      	ldr	r0, [r7, #4]
 801fb74:	f005 f955 	bl	8024e22 <lv_memset>
}
 801fb78:	bf00      	nop
 801fb7a:	3708      	adds	r7, #8
 801fb7c:	46bd      	mov	sp, r7
 801fb7e:	bd80      	pop	{r7, pc}

0801fb80 <lv_draw_buf_from_image>:
 * As of now, draw buf share same definition as `lv_image_dsc_t`.
 * And is interchangeable with `lv_image_dsc_t`.
 */

static inline void lv_draw_buf_from_image(lv_draw_buf_t * buf, const lv_image_dsc_t * img)
{
 801fb80:	b580      	push	{r7, lr}
 801fb82:	b082      	sub	sp, #8
 801fb84:	af00      	add	r7, sp, #0
 801fb86:	6078      	str	r0, [r7, #4]
 801fb88:	6039      	str	r1, [r7, #0]
    lv_memcpy(buf, img, sizeof(lv_image_dsc_t));
 801fb8a:	2218      	movs	r2, #24
 801fb8c:	6839      	ldr	r1, [r7, #0]
 801fb8e:	6878      	ldr	r0, [r7, #4]
 801fb90:	f004 ff2a 	bl	80249e8 <lv_memcpy>
    buf->unaligned_data = buf->data;
 801fb94:	687b      	ldr	r3, [r7, #4]
 801fb96:	691a      	ldr	r2, [r3, #16]
 801fb98:	687b      	ldr	r3, [r7, #4]
 801fb9a:	615a      	str	r2, [r3, #20]
}
 801fb9c:	bf00      	nop
 801fb9e:	3708      	adds	r7, #8
 801fba0:	46bd      	mov	sp, r7
 801fba2:	bd80      	pop	{r7, pc}

0801fba4 <lv_bin_decoder_init>:

/**
 * Initialize the lvgl binary image decoder module
 */
void lv_bin_decoder_init(void)
{
 801fba4:	b580      	push	{r7, lr}
 801fba6:	b082      	sub	sp, #8
 801fba8:	af00      	add	r7, sp, #0
    lv_image_decoder_t * decoder;

    decoder = lv_image_decoder_create();
 801fbaa:	f7ee fd2d 	bl	800e608 <lv_image_decoder_create>
 801fbae:	6078      	str	r0, [r7, #4]
    LV_ASSERT_MALLOC(decoder);
 801fbb0:	687b      	ldr	r3, [r7, #4]
 801fbb2:	2b00      	cmp	r3, #0
 801fbb4:	d101      	bne.n	801fbba <lv_bin_decoder_init+0x16>
 801fbb6:	bf00      	nop
 801fbb8:	e7fd      	b.n	801fbb6 <lv_bin_decoder_init+0x12>
    if(decoder == NULL) {
 801fbba:	687b      	ldr	r3, [r7, #4]
 801fbbc:	2b00      	cmp	r3, #0
 801fbbe:	d014      	beq.n	801fbea <lv_bin_decoder_init+0x46>
        LV_LOG_WARN("Out of memory");
        return;
    }

    lv_image_decoder_set_info_cb(decoder, lv_bin_decoder_info);
 801fbc0:	490c      	ldr	r1, [pc, #48]	@ (801fbf4 <lv_bin_decoder_init+0x50>)
 801fbc2:	6878      	ldr	r0, [r7, #4]
 801fbc4:	f7ee fd3c 	bl	800e640 <lv_image_decoder_set_info_cb>
    lv_image_decoder_set_open_cb(decoder, lv_bin_decoder_open);
 801fbc8:	490b      	ldr	r1, [pc, #44]	@ (801fbf8 <lv_bin_decoder_init+0x54>)
 801fbca:	6878      	ldr	r0, [r7, #4]
 801fbcc:	f7ee fd46 	bl	800e65c <lv_image_decoder_set_open_cb>
    lv_image_decoder_set_get_area_cb(decoder, lv_bin_decoder_get_area);
 801fbd0:	490a      	ldr	r1, [pc, #40]	@ (801fbfc <lv_bin_decoder_init+0x58>)
 801fbd2:	6878      	ldr	r0, [r7, #4]
 801fbd4:	f7ee fd50 	bl	800e678 <lv_image_decoder_set_get_area_cb>
    lv_image_decoder_set_close_cb(decoder, lv_bin_decoder_close);
 801fbd8:	4909      	ldr	r1, [pc, #36]	@ (801fc00 <lv_bin_decoder_init+0x5c>)
 801fbda:	6878      	ldr	r0, [r7, #4]
 801fbdc:	f7ee fd5a 	bl	800e694 <lv_image_decoder_set_close_cb>
    lv_image_decoder_set_cache_free_cb(decoder, NULL); /*Use general cache free method*/
 801fbe0:	2100      	movs	r1, #0
 801fbe2:	6878      	ldr	r0, [r7, #4]
 801fbe4:	f7ee fd64 	bl	800e6b0 <lv_image_decoder_set_cache_free_cb>
 801fbe8:	e000      	b.n	801fbec <lv_bin_decoder_init+0x48>
        return;
 801fbea:	bf00      	nop
}
 801fbec:	3708      	adds	r7, #8
 801fbee:	46bd      	mov	sp, r7
 801fbf0:	bd80      	pop	{r7, pc}
 801fbf2:	bf00      	nop
 801fbf4:	0801fc05 	.word	0x0801fc05
 801fbf8:	0801fd11 	.word	0x0801fd11
 801fbfc:	08020015 	.word	0x08020015
 801fc00:	0801ffc1 	.word	0x0801ffc1

0801fc04 <lv_bin_decoder_info>:

lv_result_t lv_bin_decoder_info(lv_image_decoder_t * decoder, const void * src, lv_image_header_t * header)
{
 801fc04:	b580      	push	{r7, lr}
 801fc06:	b08a      	sub	sp, #40	@ 0x28
 801fc08:	af00      	add	r7, sp, #0
 801fc0a:	60f8      	str	r0, [r7, #12]
 801fc0c:	60b9      	str	r1, [r7, #8]
 801fc0e:	607a      	str	r2, [r7, #4]
    LV_UNUSED(decoder); /*Unused*/

    lv_image_src_t src_type = lv_image_src_get_type(src);
 801fc10:	68b8      	ldr	r0, [r7, #8]
 801fc12:	f7ec fd8f 	bl	800c734 <lv_image_src_get_type>
 801fc16:	4603      	mov	r3, r0
 801fc18:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    if(src_type == LV_IMAGE_SRC_VARIABLE) {
 801fc1c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801fc20:	2b00      	cmp	r3, #0
 801fc22:	d108      	bne.n	801fc36 <lv_bin_decoder_info+0x32>
        lv_image_dsc_t * image = (lv_image_dsc_t *)src;
 801fc24:	68bb      	ldr	r3, [r7, #8]
 801fc26:	623b      	str	r3, [r7, #32]
        lv_memcpy(header, &image->header, sizeof(lv_image_header_t));
 801fc28:	6a3b      	ldr	r3, [r7, #32]
 801fc2a:	220c      	movs	r2, #12
 801fc2c:	4619      	mov	r1, r3
 801fc2e:	6878      	ldr	r0, [r7, #4]
 801fc30:	f004 feda 	bl	80249e8 <lv_memcpy>
 801fc34:	e05a      	b.n	801fcec <lv_bin_decoder_info+0xe8>
    }
    else if(src_type == LV_IMAGE_SRC_FILE) {
 801fc36:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801fc3a:	2b01      	cmp	r3, #1
 801fc3c:	d146      	bne.n	801fccc <lv_bin_decoder_info+0xc8>
        /*Support only "*.bin" files*/
        if(lv_strcmp(lv_fs_get_ext(src), "bin")) return LV_RESULT_INVALID;
 801fc3e:	68b8      	ldr	r0, [r7, #8]
 801fc40:	f003 f9a2 	bl	8022f88 <lv_fs_get_ext>
 801fc44:	4603      	mov	r3, r0
 801fc46:	4931      	ldr	r1, [pc, #196]	@ (801fd0c <lv_bin_decoder_info+0x108>)
 801fc48:	4618      	mov	r0, r3
 801fc4a:	f005 f9e7 	bl	802501c <lv_strcmp>
 801fc4e:	4603      	mov	r3, r0
 801fc50:	2b00      	cmp	r3, #0
 801fc52:	d001      	beq.n	801fc58 <lv_bin_decoder_info+0x54>
 801fc54:	2300      	movs	r3, #0
 801fc56:	e055      	b.n	801fd04 <lv_bin_decoder_info+0x100>

        lv_fs_file_t f;
        lv_fs_res_t res = lv_fs_open(&f, src, LV_FS_MODE_RD);
 801fc58:	f107 0314 	add.w	r3, r7, #20
 801fc5c:	2202      	movs	r2, #2
 801fc5e:	68b9      	ldr	r1, [r7, #8]
 801fc60:	4618      	mov	r0, r3
 801fc62:	f002 fe41 	bl	80228e8 <lv_fs_open>
 801fc66:	4603      	mov	r3, r0
 801fc68:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
        if(res == LV_FS_RES_OK) {
 801fc6c:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 801fc70:	2b00      	cmp	r3, #0
 801fc72:	d13b      	bne.n	801fcec <lv_bin_decoder_info+0xe8>
            uint32_t rn;
            res = lv_fs_read(&f, header, sizeof(lv_image_header_t), &rn);
 801fc74:	f107 0310 	add.w	r3, r7, #16
 801fc78:	f107 0014 	add.w	r0, r7, #20
 801fc7c:	220c      	movs	r2, #12
 801fc7e:	6879      	ldr	r1, [r7, #4]
 801fc80:	f003 f83c 	bl	8022cfc <lv_fs_read>
 801fc84:	4603      	mov	r3, r0
 801fc86:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
            lv_fs_close(&f);
 801fc8a:	f107 0314 	add.w	r3, r7, #20
 801fc8e:	4618      	mov	r0, r3
 801fc90:	f002 feb7 	bl	8022a02 <lv_fs_close>
            if(res != LV_FS_RES_OK || rn != sizeof(lv_image_header_t)) {
 801fc94:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 801fc98:	2b00      	cmp	r3, #0
 801fc9a:	d102      	bne.n	801fca2 <lv_bin_decoder_info+0x9e>
 801fc9c:	693b      	ldr	r3, [r7, #16]
 801fc9e:	2b0c      	cmp	r3, #12
 801fca0:	d001      	beq.n	801fca6 <lv_bin_decoder_info+0xa2>
                LV_LOG_WARN("Read file header failed: %d", res);
                return LV_RESULT_INVALID;
 801fca2:	2300      	movs	r3, #0
        if(lv_strcmp(lv_fs_get_ext(src), "bin")) return LV_RESULT_INVALID;
 801fca4:	e02e      	b.n	801fd04 <lv_bin_decoder_info+0x100>
            /**
             * @todo
             * This is a temp backward compatibility solution after adding
             * magic in image header.
             */
            if(header->magic != LV_IMAGE_HEADER_MAGIC) {
 801fca6:	687b      	ldr	r3, [r7, #4]
 801fca8:	781b      	ldrb	r3, [r3, #0]
 801fcaa:	2b19      	cmp	r3, #25
 801fcac:	d006      	beq.n	801fcbc <lv_bin_decoder_info+0xb8>
                LV_LOG_WARN("Legacy bin image detected: %s", (char *)src);
                header->cf = header->magic;
 801fcae:	687b      	ldr	r3, [r7, #4]
 801fcb0:	781a      	ldrb	r2, [r3, #0]
 801fcb2:	687b      	ldr	r3, [r7, #4]
 801fcb4:	705a      	strb	r2, [r3, #1]
                header->magic = LV_IMAGE_HEADER_MAGIC;
 801fcb6:	687b      	ldr	r3, [r7, #4]
 801fcb8:	2219      	movs	r2, #25
 801fcba:	701a      	strb	r2, [r3, #0]
            }

            /*File is always read to buf, thus data can be modified.*/
            header->flags |= LV_IMAGE_FLAGS_MODIFIABLE;
 801fcbc:	687b      	ldr	r3, [r7, #4]
 801fcbe:	885b      	ldrh	r3, [r3, #2]
 801fcc0:	f043 0320 	orr.w	r3, r3, #32
 801fcc4:	b29a      	uxth	r2, r3
 801fcc6:	687b      	ldr	r3, [r7, #4]
 801fcc8:	805a      	strh	r2, [r3, #2]
 801fcca:	e00f      	b.n	801fcec <lv_bin_decoder_info+0xe8>
        }
    }
    else if(src_type == LV_IMAGE_SRC_SYMBOL) {
 801fccc:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 801fcd0:	2b02      	cmp	r3, #2
 801fcd2:	d109      	bne.n	801fce8 <lv_bin_decoder_info+0xe4>
        /*The size depend on the font but it is unknown here. It should be handled outside of the
         *function*/
        header->w = 1;
 801fcd4:	687b      	ldr	r3, [r7, #4]
 801fcd6:	2201      	movs	r2, #1
 801fcd8:	809a      	strh	r2, [r3, #4]
        header->h = 1;
 801fcda:	687b      	ldr	r3, [r7, #4]
 801fcdc:	2201      	movs	r2, #1
 801fcde:	80da      	strh	r2, [r3, #6]
        /*Symbols always have transparent parts. Important because of cover check in the draw
         *function. The actual value doesn't matter because lv_draw_label will draw it*/
        header->cf = LV_COLOR_FORMAT_A8;
 801fce0:	687b      	ldr	r3, [r7, #4]
 801fce2:	220e      	movs	r2, #14
 801fce4:	705a      	strb	r2, [r3, #1]
 801fce6:	e001      	b.n	801fcec <lv_bin_decoder_info+0xe8>
    }
    else {
        LV_LOG_WARN("Image get info found unknown src type");
        return LV_RESULT_INVALID;
 801fce8:	2300      	movs	r3, #0
 801fcea:	e00b      	b.n	801fd04 <lv_bin_decoder_info+0x100>
    }

    /*For backward compatibility, all images are not premultiplied for now.*/
    if(header->magic != LV_IMAGE_HEADER_MAGIC) {
 801fcec:	687b      	ldr	r3, [r7, #4]
 801fcee:	781b      	ldrb	r3, [r3, #0]
 801fcf0:	2b19      	cmp	r3, #25
 801fcf2:	d006      	beq.n	801fd02 <lv_bin_decoder_info+0xfe>
        header->flags &= ~LV_IMAGE_FLAGS_PREMULTIPLIED;
 801fcf4:	687b      	ldr	r3, [r7, #4]
 801fcf6:	885b      	ldrh	r3, [r3, #2]
 801fcf8:	f023 0301 	bic.w	r3, r3, #1
 801fcfc:	b29a      	uxth	r2, r3
 801fcfe:	687b      	ldr	r3, [r7, #4]
 801fd00:	805a      	strh	r2, [r3, #2]
    }

    return LV_RESULT_OK;
 801fd02:	2301      	movs	r3, #1
}
 801fd04:	4618      	mov	r0, r3
 801fd06:	3728      	adds	r7, #40	@ 0x28
 801fd08:	46bd      	mov	sp, r7
 801fd0a:	bd80      	pop	{r7, pc}
 801fd0c:	08027b94 	.word	0x08027b94

0801fd10 <lv_bin_decoder_open>:
 * @param decoder pointer to the decoder
 * @param dsc     pointer to the decoder descriptor
 * @return LV_RESULT_OK: no error; LV_RESULT_INVALID: can't open the image
 */
lv_result_t lv_bin_decoder_open(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
{
 801fd10:	b580      	push	{r7, lr}
 801fd12:	b090      	sub	sp, #64	@ 0x40
 801fd14:	af00      	add	r7, sp, #0
 801fd16:	6078      	str	r0, [r7, #4]
 801fd18:	6039      	str	r1, [r7, #0]
    LV_UNUSED(decoder);

    lv_fs_res_t res = LV_RESULT_INVALID;
 801fd1a:	2300      	movs	r3, #0
 801fd1c:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    bool use_directly = false; /*If the image is already decoded and can be used directly*/
 801fd20:	2300      	movs	r3, #0
 801fd22:	f887 303e 	strb.w	r3, [r7, #62]	@ 0x3e

    /*Open the file if it's a file*/
    if(dsc->src_type == LV_IMAGE_SRC_FILE) {
 801fd26:	683b      	ldr	r3, [r7, #0]
 801fd28:	7b1b      	ldrb	r3, [r3, #12]
 801fd2a:	2b01      	cmp	r3, #1
 801fd2c:	d17c      	bne.n	801fe28 <lv_bin_decoder_open+0x118>
        /*Support only "*.bin" files*/
        if(lv_strcmp(lv_fs_get_ext(dsc->src), "bin")) return LV_RESULT_INVALID;
 801fd2e:	683b      	ldr	r3, [r7, #0]
 801fd30:	689b      	ldr	r3, [r3, #8]
 801fd32:	4618      	mov	r0, r3
 801fd34:	f003 f928 	bl	8022f88 <lv_fs_get_ext>
 801fd38:	4603      	mov	r3, r0
 801fd3a:	49a0      	ldr	r1, [pc, #640]	@ (801ffbc <lv_bin_decoder_open+0x2ac>)
 801fd3c:	4618      	mov	r0, r3
 801fd3e:	f005 f96d 	bl	802501c <lv_strcmp>
 801fd42:	4603      	mov	r3, r0
 801fd44:	2b00      	cmp	r3, #0
 801fd46:	d001      	beq.n	801fd4c <lv_bin_decoder_open+0x3c>
 801fd48:	2300      	movs	r3, #0
 801fd4a:	e132      	b.n	801ffb2 <lv_bin_decoder_open+0x2a2>

        /*If the file was open successfully save the file descriptor*/
        decoder_data_t * decoder_data = get_decoder_data(dsc);
 801fd4c:	6838      	ldr	r0, [r7, #0]
 801fd4e:	f000 fb55 	bl	80203fc <get_decoder_data>
 801fd52:	6238      	str	r0, [r7, #32]
        if(decoder_data == NULL) {
 801fd54:	6a3b      	ldr	r3, [r7, #32]
 801fd56:	2b00      	cmp	r3, #0
 801fd58:	d101      	bne.n	801fd5e <lv_bin_decoder_open+0x4e>
            return LV_RESULT_INVALID;
 801fd5a:	2300      	movs	r3, #0
 801fd5c:	e129      	b.n	801ffb2 <lv_bin_decoder_open+0x2a2>
        }

        dsc->user_data = decoder_data;
 801fd5e:	683b      	ldr	r3, [r7, #0]
 801fd60:	6a3a      	ldr	r2, [r7, #32]
 801fd62:	639a      	str	r2, [r3, #56]	@ 0x38
        lv_fs_file_t * f = lv_malloc(sizeof(*f));
 801fd64:	200c      	movs	r0, #12
 801fd66:	f006 f82f 	bl	8025dc8 <lv_malloc>
 801fd6a:	61f8      	str	r0, [r7, #28]
        if(f == NULL) {
 801fd6c:	69fb      	ldr	r3, [r7, #28]
 801fd6e:	2b00      	cmp	r3, #0
 801fd70:	d104      	bne.n	801fd7c <lv_bin_decoder_open+0x6c>
            free_decoder_data(dsc);
 801fd72:	6838      	ldr	r0, [r7, #0]
 801fd74:	f000 fb62 	bl	802043c <free_decoder_data>
            return LV_RESULT_INVALID;
 801fd78:	2300      	movs	r3, #0
 801fd7a:	e11a      	b.n	801ffb2 <lv_bin_decoder_open+0x2a2>
        }

        res = lv_fs_open(f, dsc->src, LV_FS_MODE_RD);
 801fd7c:	683b      	ldr	r3, [r7, #0]
 801fd7e:	689b      	ldr	r3, [r3, #8]
 801fd80:	2202      	movs	r2, #2
 801fd82:	4619      	mov	r1, r3
 801fd84:	69f8      	ldr	r0, [r7, #28]
 801fd86:	f002 fdaf 	bl	80228e8 <lv_fs_open>
 801fd8a:	4603      	mov	r3, r0
 801fd8c:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
        if(res != LV_FS_RES_OK) {
 801fd90:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 801fd94:	2b00      	cmp	r3, #0
 801fd96:	d007      	beq.n	801fda8 <lv_bin_decoder_open+0x98>
            LV_LOG_WARN("Open file failed: %d", res);
            lv_free(f);
 801fd98:	69f8      	ldr	r0, [r7, #28]
 801fd9a:	f006 f84d 	bl	8025e38 <lv_free>
            free_decoder_data(dsc);
 801fd9e:	6838      	ldr	r0, [r7, #0]
 801fda0:	f000 fb4c 	bl	802043c <free_decoder_data>
            return LV_RESULT_INVALID;
 801fda4:	2300      	movs	r3, #0
 801fda6:	e104      	b.n	801ffb2 <lv_bin_decoder_open+0x2a2>
        }

        decoder_data->f = f;    /*Now free_decoder_data will take care of the file*/
 801fda8:	6a3b      	ldr	r3, [r7, #32]
 801fdaa:	69fa      	ldr	r2, [r7, #28]
 801fdac:	601a      	str	r2, [r3, #0]

        lv_color_format_t cf = dsc->header.cf;
 801fdae:	683b      	ldr	r3, [r7, #0]
 801fdb0:	7c5b      	ldrb	r3, [r3, #17]
 801fdb2:	76fb      	strb	r3, [r7, #27]

        if(dsc->header.flags & LV_IMAGE_FLAGS_COMPRESSED) {
 801fdb4:	683b      	ldr	r3, [r7, #0]
 801fdb6:	8a5b      	ldrh	r3, [r3, #18]
 801fdb8:	f003 0308 	and.w	r3, r3, #8
 801fdbc:	2b00      	cmp	r3, #0
 801fdbe:	d007      	beq.n	801fdd0 <lv_bin_decoder_open+0xc0>
            res = decode_compressed(decoder, dsc);
 801fdc0:	6839      	ldr	r1, [r7, #0]
 801fdc2:	6878      	ldr	r0, [r7, #4]
 801fdc4:	f000 fd27 	bl	8020816 <decode_compressed>
 801fdc8:	4603      	mov	r3, r0
 801fdca:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
 801fdce:	e0b1      	b.n	801ff34 <lv_bin_decoder_open+0x224>
        }
        else if(LV_COLOR_FORMAT_IS_INDEXED(cf)) {
 801fdd0:	7efb      	ldrb	r3, [r7, #27]
 801fdd2:	2b06      	cmp	r3, #6
 801fdd4:	d916      	bls.n	801fe04 <lv_bin_decoder_open+0xf4>
 801fdd6:	7efb      	ldrb	r3, [r7, #27]
 801fdd8:	2b0a      	cmp	r3, #10
 801fdda:	d813      	bhi.n	801fe04 <lv_bin_decoder_open+0xf4>
            if(dsc->args.use_indexed) {
 801fddc:	683b      	ldr	r3, [r7, #0]
 801fdde:	79db      	ldrb	r3, [r3, #7]
 801fde0:	2b00      	cmp	r3, #0
 801fde2:	d007      	beq.n	801fdf4 <lv_bin_decoder_open+0xe4>
                /*Palette for indexed image and whole image of A8 image are always loaded to RAM for simplicity*/
                res = load_indexed(decoder, dsc);
 801fde4:	6839      	ldr	r1, [r7, #0]
 801fde6:	6878      	ldr	r0, [r7, #4]
 801fde8:	f000 fc0d 	bl	8020606 <load_indexed>
 801fdec:	4603      	mov	r3, r0
 801fdee:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
            if(dsc->args.use_indexed) {
 801fdf2:	e09f      	b.n	801ff34 <lv_bin_decoder_open+0x224>
            }
            else {
                res = decode_indexed(decoder, dsc);
 801fdf4:	6839      	ldr	r1, [r7, #0]
 801fdf6:	6878      	ldr	r0, [r7, #4]
 801fdf8:	f000 fb5a 	bl	80204b0 <decode_indexed>
 801fdfc:	4603      	mov	r3, r0
 801fdfe:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
            if(dsc->args.use_indexed) {
 801fe02:	e097      	b.n	801ff34 <lv_bin_decoder_open+0x224>
            }
        }
        else if(LV_COLOR_FORMAT_IS_ALPHA_ONLY(cf)) {
 801fe04:	7efb      	ldrb	r3, [r7, #27]
 801fe06:	2b0a      	cmp	r3, #10
 801fe08:	d90a      	bls.n	801fe20 <lv_bin_decoder_open+0x110>
 801fe0a:	7efb      	ldrb	r3, [r7, #27]
 801fe0c:	2b0e      	cmp	r3, #14
 801fe0e:	d807      	bhi.n	801fe20 <lv_bin_decoder_open+0x110>
            res = decode_alpha_only(decoder, dsc);
 801fe10:	6839      	ldr	r1, [r7, #0]
 801fe12:	6878      	ldr	r0, [r7, #4]
 801fe14:	f000 fc2f 	bl	8020676 <decode_alpha_only>
 801fe18:	4603      	mov	r3, r0
 801fe1a:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
 801fe1e:	e089      	b.n	801ff34 <lv_bin_decoder_open+0x224>
            res = decode_rgb(decoder, dsc);
        }
#else
        else {
            /* decode them in get_area_cb */
            res = LV_RESULT_OK;
 801fe20:	2301      	movs	r3, #1
 801fe22:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
 801fe26:	e085      	b.n	801ff34 <lv_bin_decoder_open+0x224>
        }
#endif
    }

    else if(dsc->src_type == LV_IMAGE_SRC_VARIABLE) {
 801fe28:	683b      	ldr	r3, [r7, #0]
 801fe2a:	7b1b      	ldrb	r3, [r3, #12]
 801fe2c:	2b00      	cmp	r3, #0
 801fe2e:	f040 8081 	bne.w	801ff34 <lv_bin_decoder_open+0x224>
        /*The variables should have valid data*/
        lv_image_dsc_t * image = (lv_image_dsc_t *)dsc->src;
 801fe32:	683b      	ldr	r3, [r7, #0]
 801fe34:	689b      	ldr	r3, [r3, #8]
 801fe36:	637b      	str	r3, [r7, #52]	@ 0x34
        if(image->data == NULL) {
 801fe38:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801fe3a:	691b      	ldr	r3, [r3, #16]
 801fe3c:	2b00      	cmp	r3, #0
 801fe3e:	d101      	bne.n	801fe44 <lv_bin_decoder_open+0x134>
            return LV_RESULT_INVALID;
 801fe40:	2300      	movs	r3, #0
 801fe42:	e0b6      	b.n	801ffb2 <lv_bin_decoder_open+0x2a2>
        }

        lv_color_format_t cf = image->header.cf;
 801fe44:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801fe46:	785b      	ldrb	r3, [r3, #1]
 801fe48:	f887 3033 	strb.w	r3, [r7, #51]	@ 0x33
        if(dsc->header.flags & LV_IMAGE_FLAGS_COMPRESSED) {
 801fe4c:	683b      	ldr	r3, [r7, #0]
 801fe4e:	8a5b      	ldrh	r3, [r3, #18]
 801fe50:	f003 0308 	and.w	r3, r3, #8
 801fe54:	2b00      	cmp	r3, #0
 801fe56:	d007      	beq.n	801fe68 <lv_bin_decoder_open+0x158>
            res = decode_compressed(decoder, dsc);
 801fe58:	6839      	ldr	r1, [r7, #0]
 801fe5a:	6878      	ldr	r0, [r7, #4]
 801fe5c:	f000 fcdb 	bl	8020816 <decode_compressed>
 801fe60:	4603      	mov	r3, r0
 801fe62:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
 801fe66:	e065      	b.n	801ff34 <lv_bin_decoder_open+0x224>
        }
        else if(LV_COLOR_FORMAT_IS_INDEXED(cf)) {
 801fe68:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 801fe6c:	2b06      	cmp	r3, #6
 801fe6e:	d923      	bls.n	801feb8 <lv_bin_decoder_open+0x1a8>
 801fe70:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 801fe74:	2b0a      	cmp	r3, #10
 801fe76:	d81f      	bhi.n	801feb8 <lv_bin_decoder_open+0x1a8>
            /*Need decoder data to store converted image*/
            decoder_data_t * decoder_data = get_decoder_data(dsc);
 801fe78:	6838      	ldr	r0, [r7, #0]
 801fe7a:	f000 fabf 	bl	80203fc <get_decoder_data>
 801fe7e:	62f8      	str	r0, [r7, #44]	@ 0x2c
            if(decoder_data == NULL) {
 801fe80:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801fe82:	2b00      	cmp	r3, #0
 801fe84:	d101      	bne.n	801fe8a <lv_bin_decoder_open+0x17a>
                return LV_RESULT_INVALID;
 801fe86:	2300      	movs	r3, #0
 801fe88:	e093      	b.n	801ffb2 <lv_bin_decoder_open+0x2a2>
            }

            if(dsc->args.use_indexed) {
 801fe8a:	683b      	ldr	r3, [r7, #0]
 801fe8c:	79db      	ldrb	r3, [r3, #7]
 801fe8e:	2b00      	cmp	r3, #0
 801fe90:	d00a      	beq.n	801fea8 <lv_bin_decoder_open+0x198>
                /*Palette for indexed image and whole image of A8 image are always loaded to RAM for simplicity*/
                res = load_indexed(decoder, dsc);
 801fe92:	6839      	ldr	r1, [r7, #0]
 801fe94:	6878      	ldr	r0, [r7, #4]
 801fe96:	f000 fbb6 	bl	8020606 <load_indexed>
 801fe9a:	4603      	mov	r3, r0
 801fe9c:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
                use_directly = true; /*If draw unit supports indexed image, it can be used directly.*/
 801fea0:	2301      	movs	r3, #1
 801fea2:	f887 303e 	strb.w	r3, [r7, #62]	@ 0x3e
        else if(LV_COLOR_FORMAT_IS_INDEXED(cf)) {
 801fea6:	e045      	b.n	801ff34 <lv_bin_decoder_open+0x224>
            }
            else {
                res = decode_indexed(decoder, dsc);
 801fea8:	6839      	ldr	r1, [r7, #0]
 801feaa:	6878      	ldr	r0, [r7, #4]
 801feac:	f000 fb00 	bl	80204b0 <decode_indexed>
 801feb0:	4603      	mov	r3, r0
 801feb2:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
        else if(LV_COLOR_FORMAT_IS_INDEXED(cf)) {
 801feb6:	e03d      	b.n	801ff34 <lv_bin_decoder_open+0x224>
            }
        }
        else if(LV_COLOR_FORMAT_IS_ALPHA_ONLY(cf)) {
 801feb8:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 801febc:	2b0a      	cmp	r3, #10
 801febe:	d914      	bls.n	801feea <lv_bin_decoder_open+0x1da>
 801fec0:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 801fec4:	2b0e      	cmp	r3, #14
 801fec6:	d810      	bhi.n	801feea <lv_bin_decoder_open+0x1da>
            /*Alpha only image will need decoder data to store pointer to decoded image, to free it when decoder closes*/
            decoder_data_t * decoder_data = get_decoder_data(dsc);
 801fec8:	6838      	ldr	r0, [r7, #0]
 801feca:	f000 fa97 	bl	80203fc <get_decoder_data>
 801fece:	62b8      	str	r0, [r7, #40]	@ 0x28
            if(decoder_data == NULL) {
 801fed0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801fed2:	2b00      	cmp	r3, #0
 801fed4:	d101      	bne.n	801feda <lv_bin_decoder_open+0x1ca>
                return LV_RESULT_INVALID;
 801fed6:	2300      	movs	r3, #0
 801fed8:	e06b      	b.n	801ffb2 <lv_bin_decoder_open+0x2a2>
            }

            res = decode_alpha_only(decoder, dsc);
 801feda:	6839      	ldr	r1, [r7, #0]
 801fedc:	6878      	ldr	r0, [r7, #4]
 801fede:	f000 fbca 	bl	8020676 <decode_alpha_only>
 801fee2:	4603      	mov	r3, r0
 801fee4:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
        else if(LV_COLOR_FORMAT_IS_ALPHA_ONLY(cf)) {
 801fee8:	e024      	b.n	801ff34 <lv_bin_decoder_open+0x224>
        }
        else {
            /*In case of uncompressed formats the image stored in the ROM/RAM.
             *So simply give its pointer*/

            decoder_data_t * decoder_data = get_decoder_data(dsc);
 801feea:	6838      	ldr	r0, [r7, #0]
 801feec:	f000 fa86 	bl	80203fc <get_decoder_data>
 801fef0:	6278      	str	r0, [r7, #36]	@ 0x24
            lv_draw_buf_t * decoded;
            if(image->header.flags & LV_IMAGE_FLAGS_ALLOCATED) {
 801fef2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801fef4:	885b      	ldrh	r3, [r3, #2]
 801fef6:	f003 0310 	and.w	r3, r3, #16
 801fefa:	2b00      	cmp	r3, #0
 801fefc:	d002      	beq.n	801ff04 <lv_bin_decoder_open+0x1f4>
                decoded = (lv_draw_buf_t *)image;
 801fefe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801ff00:	63bb      	str	r3, [r7, #56]	@ 0x38
 801ff02:	e006      	b.n	801ff12 <lv_bin_decoder_open+0x202>
            }
            else {
                decoded = &decoder_data->c_array;
 801ff04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801ff06:	3324      	adds	r3, #36	@ 0x24
 801ff08:	63bb      	str	r3, [r7, #56]	@ 0x38
                lv_draw_buf_from_image(decoded, image);
 801ff0a:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 801ff0c:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801ff0e:	f7ff fe37 	bl	801fb80 <lv_draw_buf_from_image>
            }

            dsc->decoded = decoded;
 801ff12:	683b      	ldr	r3, [r7, #0]
 801ff14:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801ff16:	61da      	str	r2, [r3, #28]

            if(decoded->header.stride == 0) {
 801ff18:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801ff1a:	891b      	ldrh	r3, [r3, #8]
 801ff1c:	2b00      	cmp	r3, #0
 801ff1e:	d103      	bne.n	801ff28 <lv_bin_decoder_open+0x218>
                /*Use the auto calculated value from decoder_info callback*/
                decoded->header.stride = dsc->header.stride;
 801ff20:	683b      	ldr	r3, [r7, #0]
 801ff22:	8b1a      	ldrh	r2, [r3, #24]
 801ff24:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801ff26:	811a      	strh	r2, [r3, #8]
            }

            res = LV_RESULT_OK;
 801ff28:	2301      	movs	r3, #1
 801ff2a:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
            use_directly = true; /*A variable image that can be used directly.*/
 801ff2e:	2301      	movs	r3, #1
 801ff30:	f887 303e 	strb.w	r3, [r7, #62]	@ 0x3e
        }
    }

    if(res != LV_RESULT_OK) {
 801ff34:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 801ff38:	2b01      	cmp	r3, #1
 801ff3a:	d005      	beq.n	801ff48 <lv_bin_decoder_open+0x238>
        free_decoder_data(dsc);
 801ff3c:	6838      	ldr	r0, [r7, #0]
 801ff3e:	f000 fa7d 	bl	802043c <free_decoder_data>
        return res;
 801ff42:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 801ff46:	e034      	b.n	801ffb2 <lv_bin_decoder_open+0x2a2>
    }

    if(dsc->decoded == NULL) return LV_RESULT_OK; /*Need to read via get_area_cb*/
 801ff48:	683b      	ldr	r3, [r7, #0]
 801ff4a:	69db      	ldr	r3, [r3, #28]
 801ff4c:	2b00      	cmp	r3, #0
 801ff4e:	d101      	bne.n	801ff54 <lv_bin_decoder_open+0x244>
 801ff50:	2301      	movs	r3, #1
 801ff52:	e02e      	b.n	801ffb2 <lv_bin_decoder_open+0x2a2>

    lv_draw_buf_t * decoded = (lv_draw_buf_t *)dsc->decoded;
 801ff54:	683b      	ldr	r3, [r7, #0]
 801ff56:	69db      	ldr	r3, [r3, #28]
 801ff58:	617b      	str	r3, [r7, #20]
    lv_draw_buf_t * adjusted = lv_image_decoder_post_process(dsc, decoded);
 801ff5a:	6979      	ldr	r1, [r7, #20]
 801ff5c:	6838      	ldr	r0, [r7, #0]
 801ff5e:	f7ee fbb5 	bl	800e6cc <lv_image_decoder_post_process>
 801ff62:	6138      	str	r0, [r7, #16]
    if(adjusted == NULL) {
 801ff64:	693b      	ldr	r3, [r7, #16]
 801ff66:	2b00      	cmp	r3, #0
 801ff68:	d104      	bne.n	801ff74 <lv_bin_decoder_open+0x264>
        free_decoder_data(dsc);
 801ff6a:	6838      	ldr	r0, [r7, #0]
 801ff6c:	f000 fa66 	bl	802043c <free_decoder_data>
        return LV_RESULT_INVALID;
 801ff70:	2300      	movs	r3, #0
 801ff72:	e01e      	b.n	801ffb2 <lv_bin_decoder_open+0x2a2>
    }

    /*The adjusted draw buffer is newly allocated.*/
    if(adjusted != decoded) {
 801ff74:	693a      	ldr	r2, [r7, #16]
 801ff76:	697b      	ldr	r3, [r7, #20]
 801ff78:	429a      	cmp	r2, r3
 801ff7a:	d00c      	beq.n	801ff96 <lv_bin_decoder_open+0x286>
        use_directly = false; /*Cannot use original image directly*/
 801ff7c:	2300      	movs	r3, #0
 801ff7e:	f887 303e 	strb.w	r3, [r7, #62]	@ 0x3e
        free_decoder_data(dsc);
 801ff82:	6838      	ldr	r0, [r7, #0]
 801ff84:	f000 fa5a 	bl	802043c <free_decoder_data>
        decoder_data_t * decoder_data = get_decoder_data(dsc);
 801ff88:	6838      	ldr	r0, [r7, #0]
 801ff8a:	f000 fa37 	bl	80203fc <get_decoder_data>
 801ff8e:	60f8      	str	r0, [r7, #12]
        decoder_data->decoded = adjusted; /*Now this new buffer need to be free'd on decoder close*/
 801ff90:	68fb      	ldr	r3, [r7, #12]
 801ff92:	693a      	ldr	r2, [r7, #16]
 801ff94:	61da      	str	r2, [r3, #28]
    }
    dsc->decoded = adjusted;
 801ff96:	683b      	ldr	r3, [r7, #0]
 801ff98:	693a      	ldr	r2, [r7, #16]
 801ff9a:	61da      	str	r2, [r3, #28]

    if(use_directly || dsc->args.no_cache) return LV_RESULT_OK; /*Do not put image to cache if it can be used directly.*/
 801ff9c:	f897 303e 	ldrb.w	r3, [r7, #62]	@ 0x3e
 801ffa0:	2b00      	cmp	r3, #0
 801ffa2:	d103      	bne.n	801ffac <lv_bin_decoder_open+0x29c>
 801ffa4:	683b      	ldr	r3, [r7, #0]
 801ffa6:	799b      	ldrb	r3, [r3, #6]
 801ffa8:	2b00      	cmp	r3, #0
 801ffaa:	d001      	beq.n	801ffb0 <lv_bin_decoder_open+0x2a0>
 801ffac:	2301      	movs	r3, #1
 801ffae:	e000      	b.n	801ffb2 <lv_bin_decoder_open+0x2a2>
    dsc->cache_entry = cache_entry;
    decoder_data_t * decoder_data = get_decoder_data(dsc);
    decoder_data->decoded = NULL; /*Cache will take care of it*/
#endif

    return LV_RESULT_OK;
 801ffb0:	2301      	movs	r3, #1
}
 801ffb2:	4618      	mov	r0, r3
 801ffb4:	3740      	adds	r7, #64	@ 0x40
 801ffb6:	46bd      	mov	sp, r7
 801ffb8:	bd80      	pop	{r7, pc}
 801ffba:	bf00      	nop
 801ffbc:	08027b94 	.word	0x08027b94

0801ffc0 <lv_bin_decoder_close>:

void lv_bin_decoder_close(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
{
 801ffc0:	b580      	push	{r7, lr}
 801ffc2:	b084      	sub	sp, #16
 801ffc4:	af00      	add	r7, sp, #0
 801ffc6:	6078      	str	r0, [r7, #4]
 801ffc8:	6039      	str	r1, [r7, #0]
    LV_UNUSED(decoder); /*Unused*/

    decoder_data_t * decoder_data = dsc->user_data;
 801ffca:	683b      	ldr	r3, [r7, #0]
 801ffcc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801ffce:	60fb      	str	r3, [r7, #12]
    if(decoder_data && decoder_data->decoded_partial) {
 801ffd0:	68fb      	ldr	r3, [r7, #12]
 801ffd2:	2b00      	cmp	r3, #0
 801ffd4:	d00b      	beq.n	801ffee <lv_bin_decoder_close+0x2e>
 801ffd6:	68fb      	ldr	r3, [r7, #12]
 801ffd8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801ffda:	2b00      	cmp	r3, #0
 801ffdc:	d007      	beq.n	801ffee <lv_bin_decoder_close+0x2e>
        lv_draw_buf_destroy(decoder_data->decoded_partial);
 801ffde:	68fb      	ldr	r3, [r7, #12]
 801ffe0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801ffe2:	4618      	mov	r0, r3
 801ffe4:	f7eb ffe2 	bl	800bfac <lv_draw_buf_destroy>
        decoder_data->decoded_partial = NULL;
 801ffe8:	68fb      	ldr	r3, [r7, #12]
 801ffea:	2200      	movs	r2, #0
 801ffec:	63da      	str	r2, [r3, #60]	@ 0x3c
    }

    free_decoder_data(dsc);
 801ffee:	6838      	ldr	r0, [r7, #0]
 801fff0:	f000 fa24 	bl	802043c <free_decoder_data>

    if(dsc->cache_entry) {
 801fff4:	683b      	ldr	r3, [r7, #0]
 801fff6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801fff8:	2b00      	cmp	r3, #0
 801fffa:	d007      	beq.n	802000c <lv_bin_decoder_close+0x4c>
        /*Decoded data is in cache, release it from cache's callback*/
        lv_cache_release(dsc->cache, dsc->cache_entry, NULL);
 801fffc:	683b      	ldr	r3, [r7, #0]
 801fffe:	6b18      	ldr	r0, [r3, #48]	@ 0x30
 8020000:	683b      	ldr	r3, [r7, #0]
 8020002:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8020004:	2200      	movs	r2, #0
 8020006:	4619      	mov	r1, r3
 8020008:	f000 feb4 	bl	8020d74 <lv_cache_release>
    }

}
 802000c:	bf00      	nop
 802000e:	3710      	adds	r7, #16
 8020010:	46bd      	mov	sp, r7
 8020012:	bd80      	pop	{r7, pc}

08020014 <lv_bin_decoder_get_area>:

lv_result_t lv_bin_decoder_get_area(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc,
                                    const lv_area_t * full_area, lv_area_t * decoded_area)
{
 8020014:	b590      	push	{r4, r7, lr}
 8020016:	b097      	sub	sp, #92	@ 0x5c
 8020018:	af02      	add	r7, sp, #8
 802001a:	60f8      	str	r0, [r7, #12]
 802001c:	60b9      	str	r1, [r7, #8]
 802001e:	607a      	str	r2, [r7, #4]
 8020020:	603b      	str	r3, [r7, #0]
    LV_UNUSED(decoder); /*Unused*/

    lv_color_format_t cf = dsc->header.cf;
 8020022:	68bb      	ldr	r3, [r7, #8]
 8020024:	7c5b      	ldrb	r3, [r3, #17]
 8020026:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
                     || cf == LV_COLOR_FORMAT_ARGB8888  \
                     || cf == LV_COLOR_FORMAT_XRGB8888  \
                     || cf == LV_COLOR_FORMAT_RGB888    \
                     || cf == LV_COLOR_FORMAT_RGB565    \
                     || cf == LV_COLOR_FORMAT_ARGB8565  \
                     || cf == LV_COLOR_FORMAT_RGB565A8;
 802002a:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 802002e:	2b06      	cmp	r3, #6
 8020030:	d903      	bls.n	802003a <lv_bin_decoder_get_area+0x26>
    bool supported = LV_COLOR_FORMAT_IS_INDEXED(cf)
 8020032:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 8020036:	2b0a      	cmp	r3, #10
 8020038:	d917      	bls.n	802006a <lv_bin_decoder_get_area+0x56>
                     || cf == LV_COLOR_FORMAT_ARGB8888  \
 802003a:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 802003e:	2b10      	cmp	r3, #16
 8020040:	d013      	beq.n	802006a <lv_bin_decoder_get_area+0x56>
                     || cf == LV_COLOR_FORMAT_XRGB8888  \
 8020042:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 8020046:	2b11      	cmp	r3, #17
 8020048:	d00f      	beq.n	802006a <lv_bin_decoder_get_area+0x56>
                     || cf == LV_COLOR_FORMAT_RGB888    \
 802004a:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 802004e:	2b0f      	cmp	r3, #15
 8020050:	d00b      	beq.n	802006a <lv_bin_decoder_get_area+0x56>
                     || cf == LV_COLOR_FORMAT_RGB565    \
 8020052:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 8020056:	2b12      	cmp	r3, #18
 8020058:	d007      	beq.n	802006a <lv_bin_decoder_get_area+0x56>
                     || cf == LV_COLOR_FORMAT_ARGB8565  \
 802005a:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 802005e:	2b13      	cmp	r3, #19
 8020060:	d003      	beq.n	802006a <lv_bin_decoder_get_area+0x56>
                     || cf == LV_COLOR_FORMAT_RGB565A8;
 8020062:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 8020066:	2b14      	cmp	r3, #20
 8020068:	d101      	bne.n	802006e <lv_bin_decoder_get_area+0x5a>
 802006a:	2301      	movs	r3, #1
 802006c:	e000      	b.n	8020070 <lv_bin_decoder_get_area+0x5c>
 802006e:	2300      	movs	r3, #0
    bool supported = LV_COLOR_FORMAT_IS_INDEXED(cf)
 8020070:	f887 3046 	strb.w	r3, [r7, #70]	@ 0x46
 8020074:	f897 3046 	ldrb.w	r3, [r7, #70]	@ 0x46
 8020078:	f003 0301 	and.w	r3, r3, #1
 802007c:	f887 3046 	strb.w	r3, [r7, #70]	@ 0x46
    if(!supported) {
 8020080:	f897 3046 	ldrb.w	r3, [r7, #70]	@ 0x46
 8020084:	f083 0301 	eor.w	r3, r3, #1
 8020088:	b2db      	uxtb	r3, r3
 802008a:	2b00      	cmp	r3, #0
 802008c:	d001      	beq.n	8020092 <lv_bin_decoder_get_area+0x7e>
        LV_LOG_WARN("CF: %d is not supported", cf);
        return LV_RESULT_INVALID;
 802008e:	2300      	movs	r3, #0
 8020090:	e1b0      	b.n	80203f4 <lv_bin_decoder_get_area+0x3e0>
    }

    lv_result_t res = LV_RESULT_INVALID;
 8020092:	2300      	movs	r3, #0
 8020094:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
    decoder_data_t * decoder_data = dsc->user_data;
 8020098:	68bb      	ldr	r3, [r7, #8]
 802009a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 802009c:	643b      	str	r3, [r7, #64]	@ 0x40
    if(decoder_data == NULL) {
 802009e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80200a0:	2b00      	cmp	r3, #0
 80200a2:	d101      	bne.n	80200a8 <lv_bin_decoder_get_area+0x94>
        LV_LOG_ERROR("Unexpected null decoder data");
        return LV_RESULT_INVALID;
 80200a4:	2300      	movs	r3, #0
 80200a6:	e1a5      	b.n	80203f4 <lv_bin_decoder_get_area+0x3e0>
    }

    lv_fs_file_t * f = decoder_data->f;
 80200a8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80200aa:	681b      	ldr	r3, [r3, #0]
 80200ac:	63fb      	str	r3, [r7, #60]	@ 0x3c
    uint32_t bpp = lv_color_format_get_bpp(cf);
 80200ae:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80200b2:	4618      	mov	r0, r3
 80200b4:	f002 fa28 	bl	8022508 <lv_color_format_get_bpp>
 80200b8:	4603      	mov	r3, r0
 80200ba:	63bb      	str	r3, [r7, #56]	@ 0x38
    int32_t w_px = lv_area_get_width(full_area);
 80200bc:	6878      	ldr	r0, [r7, #4]
 80200be:	f7ff fd41 	bl	801fb44 <lv_area_get_width>
 80200c2:	6378      	str	r0, [r7, #52]	@ 0x34
    uint8_t * img_data = NULL;
 80200c4:	2300      	movs	r3, #0
 80200c6:	633b      	str	r3, [r7, #48]	@ 0x30
    lv_draw_buf_t * decoded = NULL;
 80200c8:	2300      	movs	r3, #0
 80200ca:	64fb      	str	r3, [r7, #76]	@ 0x4c
    uint32_t offset = 0;
 80200cc:	2300      	movs	r3, #0
 80200ce:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /*We only support read line by line for now*/
    if(decoded_area->y1 == LV_COORD_MIN) {
 80200d0:	683b      	ldr	r3, [r7, #0]
 80200d2:	685b      	ldr	r3, [r3, #4]
 80200d4:	4a93      	ldr	r2, [pc, #588]	@ (8020324 <lv_bin_decoder_get_area+0x310>)
 80200d6:	4293      	cmp	r3, r2
 80200d8:	d146      	bne.n	8020168 <lv_bin_decoder_get_area+0x154>
        /*Indexed image is converted to ARGB888*/
        uint32_t len = LV_COLOR_FORMAT_IS_INDEXED(cf) ? sizeof(lv_color32_t) * 8 : bpp;
 80200da:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80200de:	2b06      	cmp	r3, #6
 80200e0:	d903      	bls.n	80200ea <lv_bin_decoder_get_area+0xd6>
 80200e2:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80200e6:	2b0a      	cmp	r3, #10
 80200e8:	d901      	bls.n	80200ee <lv_bin_decoder_get_area+0xda>
 80200ea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80200ec:	e000      	b.n	80200f0 <lv_bin_decoder_get_area+0xdc>
 80200ee:	2320      	movs	r3, #32
 80200f0:	62bb      	str	r3, [r7, #40]	@ 0x28
        lv_color_format_t cf_decoded = LV_COLOR_FORMAT_IS_INDEXED(cf) ? LV_COLOR_FORMAT_ARGB8888 : cf;
 80200f2:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80200f6:	2b06      	cmp	r3, #6
 80200f8:	d903      	bls.n	8020102 <lv_bin_decoder_get_area+0xee>
 80200fa:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80200fe:	2b0a      	cmp	r3, #10
 8020100:	d902      	bls.n	8020108 <lv_bin_decoder_get_area+0xf4>
 8020102:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 8020106:	e000      	b.n	802010a <lv_bin_decoder_get_area+0xf6>
 8020108:	2310      	movs	r3, #16
 802010a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        len = (len * w_px) / 8;
 802010e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8020110:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8020112:	fb02 f303 	mul.w	r3, r2, r3
 8020116:	08db      	lsrs	r3, r3, #3
 8020118:	62bb      	str	r3, [r7, #40]	@ 0x28
        decoded = decoder_data->decoded_partial;
 802011a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802011c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 802011e:	64fb      	str	r3, [r7, #76]	@ 0x4c
        if(decoded && decoded->header.w == w_px) {
 8020120:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020122:	2b00      	cmp	r3, #0
 8020124:	d005      	beq.n	8020132 <lv_bin_decoder_get_area+0x11e>
 8020126:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020128:	889b      	ldrh	r3, [r3, #4]
 802012a:	461a      	mov	r2, r3
 802012c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802012e:	4293      	cmp	r3, r2
 8020130:	d00c      	beq.n	802014c <lv_bin_decoder_get_area+0x138>
            /*Use existing one directly*/
        }
        else {
            decoded = lv_draw_buf_create(w_px, 1, cf_decoded, LV_STRIDE_AUTO);
 8020132:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8020134:	f897 2027 	ldrb.w	r2, [r7, #39]	@ 0x27
 8020138:	2300      	movs	r3, #0
 802013a:	2101      	movs	r1, #1
 802013c:	f7eb fe64 	bl	800be08 <lv_draw_buf_create>
 8020140:	64f8      	str	r0, [r7, #76]	@ 0x4c
            if(decoded == NULL)
 8020142:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020144:	2b00      	cmp	r3, #0
 8020146:	d101      	bne.n	802014c <lv_bin_decoder_get_area+0x138>
                return LV_RESULT_INVALID;
 8020148:	2300      	movs	r3, #0
 802014a:	e153      	b.n	80203f4 <lv_bin_decoder_get_area+0x3e0>
        }

        *decoded_area = *full_area;
 802014c:	683a      	ldr	r2, [r7, #0]
 802014e:	687b      	ldr	r3, [r7, #4]
 8020150:	4614      	mov	r4, r2
 8020152:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8020154:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        decoded_area->y2 = decoded_area->y1;
 8020158:	683b      	ldr	r3, [r7, #0]
 802015a:	685a      	ldr	r2, [r3, #4]
 802015c:	683b      	ldr	r3, [r7, #0]
 802015e:	60da      	str	r2, [r3, #12]
        decoder_data->decoded_partial = decoded; /*Free on decoder close*/
 8020160:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8020162:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020164:	63da      	str	r2, [r3, #60]	@ 0x3c
 8020166:	e00c      	b.n	8020182 <lv_bin_decoder_get_area+0x16e>
    }
    else {
        decoded_area->y1++;
 8020168:	683b      	ldr	r3, [r7, #0]
 802016a:	685b      	ldr	r3, [r3, #4]
 802016c:	1c5a      	adds	r2, r3, #1
 802016e:	683b      	ldr	r3, [r7, #0]
 8020170:	605a      	str	r2, [r3, #4]
        decoded_area->y2++;
 8020172:	683b      	ldr	r3, [r7, #0]
 8020174:	68db      	ldr	r3, [r3, #12]
 8020176:	1c5a      	adds	r2, r3, #1
 8020178:	683b      	ldr	r3, [r7, #0]
 802017a:	60da      	str	r2, [r3, #12]
        decoded = decoder_data->decoded_partial; /*Already alloced*/
 802017c:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 802017e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8020180:	64fb      	str	r3, [r7, #76]	@ 0x4c
    }

    img_data = decoded->data; /*Get the buffer to operate on*/
 8020182:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020184:	691b      	ldr	r3, [r3, #16]
 8020186:	633b      	str	r3, [r7, #48]	@ 0x30

    if(decoded_area->y1 > full_area->y2) {
 8020188:	683b      	ldr	r3, [r7, #0]
 802018a:	685a      	ldr	r2, [r3, #4]
 802018c:	687b      	ldr	r3, [r7, #4]
 802018e:	68db      	ldr	r3, [r3, #12]
 8020190:	429a      	cmp	r2, r3
 8020192:	dd01      	ble.n	8020198 <lv_bin_decoder_get_area+0x184>
        return LV_RESULT_INVALID;
 8020194:	2300      	movs	r3, #0
 8020196:	e12d      	b.n	80203f4 <lv_bin_decoder_get_area+0x3e0>
    }

    if(LV_COLOR_FORMAT_IS_INDEXED(cf)) {
 8020198:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 802019c:	2b06      	cmp	r3, #6
 802019e:	d97d      	bls.n	802029c <lv_bin_decoder_get_area+0x288>
 80201a0:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80201a4:	2b0a      	cmp	r3, #10
 80201a6:	d879      	bhi.n	802029c <lv_bin_decoder_get_area+0x288>
        int32_t x_fraction = decoded_area->x1 % (8 / bpp);
 80201a8:	683b      	ldr	r3, [r7, #0]
 80201aa:	681b      	ldr	r3, [r3, #0]
 80201ac:	461a      	mov	r2, r3
 80201ae:	2108      	movs	r1, #8
 80201b0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80201b2:	fbb1 f3f3 	udiv	r3, r1, r3
 80201b6:	fbb2 f1f3 	udiv	r1, r2, r3
 80201ba:	fb01 f303 	mul.w	r3, r1, r3
 80201be:	1ad3      	subs	r3, r2, r3
 80201c0:	623b      	str	r3, [r7, #32]
        uint32_t len = (w_px * bpp + 7) / 8 + 1; /*10px for 1bpp may across 3bytes*/
 80201c2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80201c4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80201c6:	fb02 f303 	mul.w	r3, r2, r3
 80201ca:	3307      	adds	r3, #7
 80201cc:	08db      	lsrs	r3, r3, #3
 80201ce:	3301      	adds	r3, #1
 80201d0:	61fb      	str	r3, [r7, #28]
        uint8_t * buf = NULL;
 80201d2:	2300      	movs	r3, #0
 80201d4:	64bb      	str	r3, [r7, #72]	@ 0x48

        offset += dsc->palette_size * 4; /*Skip palette*/
 80201d6:	68bb      	ldr	r3, [r7, #8]
 80201d8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80201da:	009b      	lsls	r3, r3, #2
 80201dc:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80201de:	4413      	add	r3, r2
 80201e0:	62fb      	str	r3, [r7, #44]	@ 0x2c
        offset += decoded_area->y1 * dsc->header.stride;
 80201e2:	683b      	ldr	r3, [r7, #0]
 80201e4:	685b      	ldr	r3, [r3, #4]
 80201e6:	68ba      	ldr	r2, [r7, #8]
 80201e8:	8b12      	ldrh	r2, [r2, #24]
 80201ea:	fb02 f303 	mul.w	r3, r2, r3
 80201ee:	461a      	mov	r2, r3
 80201f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80201f2:	4413      	add	r3, r2
 80201f4:	62fb      	str	r3, [r7, #44]	@ 0x2c
        offset += decoded_area->x1 * bpp / 8; /*Move to x1*/
 80201f6:	683b      	ldr	r3, [r7, #0]
 80201f8:	681b      	ldr	r3, [r3, #0]
 80201fa:	461a      	mov	r2, r3
 80201fc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80201fe:	fb02 f303 	mul.w	r3, r2, r3
 8020202:	08db      	lsrs	r3, r3, #3
 8020204:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020206:	4413      	add	r3, r2
 8020208:	62fb      	str	r3, [r7, #44]	@ 0x2c
        if(dsc->src_type == LV_IMAGE_SRC_FILE) {
 802020a:	68bb      	ldr	r3, [r7, #8]
 802020c:	7b1b      	ldrb	r3, [r3, #12]
 802020e:	2b01      	cmp	r3, #1
 8020210:	d124      	bne.n	802025c <lv_bin_decoder_get_area+0x248>
            offset += sizeof(lv_image_header_t); /*File image starts with image header*/
 8020212:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020214:	330c      	adds	r3, #12
 8020216:	62fb      	str	r3, [r7, #44]	@ 0x2c
            buf = lv_malloc(len);
 8020218:	69f8      	ldr	r0, [r7, #28]
 802021a:	f005 fdd5 	bl	8025dc8 <lv_malloc>
 802021e:	64b8      	str	r0, [r7, #72]	@ 0x48
            LV_ASSERT_NULL(buf);
 8020220:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8020222:	2b00      	cmp	r3, #0
 8020224:	d101      	bne.n	802022a <lv_bin_decoder_get_area+0x216>
 8020226:	bf00      	nop
 8020228:	e7fd      	b.n	8020226 <lv_bin_decoder_get_area+0x212>
            if(buf == NULL)
 802022a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802022c:	2b00      	cmp	r3, #0
 802022e:	d101      	bne.n	8020234 <lv_bin_decoder_get_area+0x220>
                return LV_RESULT_INVALID;
 8020230:	2300      	movs	r3, #0
 8020232:	e0df      	b.n	80203f4 <lv_bin_decoder_get_area+0x3e0>

            res = fs_read_file_at(f, offset, buf, len, NULL);
 8020234:	2300      	movs	r3, #0
 8020236:	9300      	str	r3, [sp, #0]
 8020238:	69fb      	ldr	r3, [r7, #28]
 802023a:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 802023c:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 802023e:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8020240:	f000 fc84 	bl	8020b4c <fs_read_file_at>
 8020244:	4603      	mov	r3, r0
 8020246:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
            if(res != LV_FS_RES_OK) {
 802024a:	f897 3045 	ldrb.w	r3, [r7, #69]	@ 0x45
 802024e:	2b00      	cmp	r3, #0
 8020250:	d00c      	beq.n	802026c <lv_bin_decoder_get_area+0x258>
                lv_free(buf);
 8020252:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 8020254:	f005 fdf0 	bl	8025e38 <lv_free>
                return LV_RESULT_INVALID;
 8020258:	2300      	movs	r3, #0
 802025a:	e0cb      	b.n	80203f4 <lv_bin_decoder_get_area+0x3e0>
            }
        }
        else {
            const lv_image_dsc_t * image = dsc->src;
 802025c:	68bb      	ldr	r3, [r7, #8]
 802025e:	689b      	ldr	r3, [r3, #8]
 8020260:	61bb      	str	r3, [r7, #24]
            buf = (void *)(image->data + offset);
 8020262:	69bb      	ldr	r3, [r7, #24]
 8020264:	691a      	ldr	r2, [r3, #16]
 8020266:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020268:	4413      	add	r3, r2
 802026a:	64bb      	str	r3, [r7, #72]	@ 0x48
        }

        decode_indexed_line(cf, dsc->palette, x_fraction, w_px, buf, (lv_color32_t *)img_data);
 802026c:	68bb      	ldr	r3, [r7, #8]
 802026e:	6a19      	ldr	r1, [r3, #32]
 8020270:	f897 0047 	ldrb.w	r0, [r7, #71]	@ 0x47
 8020274:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8020276:	9301      	str	r3, [sp, #4]
 8020278:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802027a:	9300      	str	r3, [sp, #0]
 802027c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802027e:	6a3a      	ldr	r2, [r7, #32]
 8020280:	f000 fbc0 	bl	8020a04 <decode_indexed_line>

        if(dsc->src_type == LV_IMAGE_SRC_FILE) lv_free((void *)buf);
 8020284:	68bb      	ldr	r3, [r7, #8]
 8020286:	7b1b      	ldrb	r3, [r3, #12]
 8020288:	2b01      	cmp	r3, #1
 802028a:	d102      	bne.n	8020292 <lv_bin_decoder_get_area+0x27e>
 802028c:	6cb8      	ldr	r0, [r7, #72]	@ 0x48
 802028e:	f005 fdd3 	bl	8025e38 <lv_free>

        dsc->decoded = decoded; /*Return decoded image*/
 8020292:	68bb      	ldr	r3, [r7, #8]
 8020294:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8020296:	61da      	str	r2, [r3, #28]
        return LV_RESULT_OK;
 8020298:	2301      	movs	r3, #1
 802029a:	e0ab      	b.n	80203f4 <lv_bin_decoder_get_area+0x3e0>
    }

    if(cf == LV_COLOR_FORMAT_ARGB8888 || cf == LV_COLOR_FORMAT_XRGB8888 || cf == LV_COLOR_FORMAT_RGB888
 802029c:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80202a0:	2b10      	cmp	r3, #16
 80202a2:	d00f      	beq.n	80202c4 <lv_bin_decoder_get_area+0x2b0>
 80202a4:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80202a8:	2b11      	cmp	r3, #17
 80202aa:	d00b      	beq.n	80202c4 <lv_bin_decoder_get_area+0x2b0>
 80202ac:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80202b0:	2b0f      	cmp	r3, #15
 80202b2:	d007      	beq.n	80202c4 <lv_bin_decoder_get_area+0x2b0>
       || cf == LV_COLOR_FORMAT_RGB565 || cf == LV_COLOR_FORMAT_ARGB8565) {
 80202b4:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80202b8:	2b12      	cmp	r3, #18
 80202ba:	d003      	beq.n	80202c4 <lv_bin_decoder_get_area+0x2b0>
 80202bc:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80202c0:	2b13      	cmp	r3, #19
 80202c2:	d131      	bne.n	8020328 <lv_bin_decoder_get_area+0x314>
        uint32_t len = (w_px * bpp) / 8;
 80202c4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80202c6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80202c8:	fb02 f303 	mul.w	r3, r2, r3
 80202cc:	08db      	lsrs	r3, r3, #3
 80202ce:	613b      	str	r3, [r7, #16]
        offset += decoded_area->y1 * dsc->header.stride;
 80202d0:	683b      	ldr	r3, [r7, #0]
 80202d2:	685b      	ldr	r3, [r3, #4]
 80202d4:	68ba      	ldr	r2, [r7, #8]
 80202d6:	8b12      	ldrh	r2, [r2, #24]
 80202d8:	fb02 f303 	mul.w	r3, r2, r3
 80202dc:	461a      	mov	r2, r3
 80202de:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80202e0:	4413      	add	r3, r2
 80202e2:	62fb      	str	r3, [r7, #44]	@ 0x2c
        offset += decoded_area->x1 * bpp / 8; /*Move to x1*/
 80202e4:	683b      	ldr	r3, [r7, #0]
 80202e6:	681b      	ldr	r3, [r3, #0]
 80202e8:	461a      	mov	r2, r3
 80202ea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80202ec:	fb02 f303 	mul.w	r3, r2, r3
 80202f0:	08db      	lsrs	r3, r3, #3
 80202f2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80202f4:	4413      	add	r3, r2
 80202f6:	62fb      	str	r3, [r7, #44]	@ 0x2c
        res = fs_read_file_at(f, offset, img_data, len, NULL);
 80202f8:	2300      	movs	r3, #0
 80202fa:	9300      	str	r3, [sp, #0]
 80202fc:	693b      	ldr	r3, [r7, #16]
 80202fe:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8020300:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8020302:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 8020304:	f000 fc22 	bl	8020b4c <fs_read_file_at>
 8020308:	4603      	mov	r3, r0
 802030a:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
        if(res != LV_FS_RES_OK) {
 802030e:	f897 3045 	ldrb.w	r3, [r7, #69]	@ 0x45
 8020312:	2b00      	cmp	r3, #0
 8020314:	d001      	beq.n	802031a <lv_bin_decoder_get_area+0x306>
            return LV_RESULT_INVALID;
 8020316:	2300      	movs	r3, #0
 8020318:	e06c      	b.n	80203f4 <lv_bin_decoder_get_area+0x3e0>
        }

        dsc->decoded = decoded; /*Return decoded image*/
 802031a:	68bb      	ldr	r3, [r7, #8]
 802031c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 802031e:	61da      	str	r2, [r3, #28]
        return LV_RESULT_OK;
 8020320:	2301      	movs	r3, #1
 8020322:	e067      	b.n	80203f4 <lv_bin_decoder_get_area+0x3e0>
 8020324:	e0000001 	.word	0xe0000001
    }

    if(cf == LV_COLOR_FORMAT_RGB565A8) {
 8020328:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 802032c:	2b14      	cmp	r3, #20
 802032e:	d160      	bne.n	80203f2 <lv_bin_decoder_get_area+0x3de>
        bpp = 16; /* RGB565 + A8 mask*/
 8020330:	2310      	movs	r3, #16
 8020332:	63bb      	str	r3, [r7, #56]	@ 0x38
        uint32_t len = decoded->header.stride;
 8020334:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8020336:	891b      	ldrh	r3, [r3, #8]
 8020338:	617b      	str	r3, [r7, #20]
        offset += decoded_area->y1 * dsc->header.stride; /*Move to y1*/
 802033a:	683b      	ldr	r3, [r7, #0]
 802033c:	685b      	ldr	r3, [r3, #4]
 802033e:	68ba      	ldr	r2, [r7, #8]
 8020340:	8b12      	ldrh	r2, [r2, #24]
 8020342:	fb02 f303 	mul.w	r3, r2, r3
 8020346:	461a      	mov	r2, r3
 8020348:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802034a:	4413      	add	r3, r2
 802034c:	62fb      	str	r3, [r7, #44]	@ 0x2c
        offset += decoded_area->x1 * bpp / 8; /*Move to x1*/
 802034e:	683b      	ldr	r3, [r7, #0]
 8020350:	681b      	ldr	r3, [r3, #0]
 8020352:	461a      	mov	r2, r3
 8020354:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8020356:	fb02 f303 	mul.w	r3, r2, r3
 802035a:	08db      	lsrs	r3, r3, #3
 802035c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 802035e:	4413      	add	r3, r2
 8020360:	62fb      	str	r3, [r7, #44]	@ 0x2c
        res = fs_read_file_at(f, offset, img_data, len, NULL);
 8020362:	2300      	movs	r3, #0
 8020364:	9300      	str	r3, [sp, #0]
 8020366:	697b      	ldr	r3, [r7, #20]
 8020368:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 802036a:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 802036c:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 802036e:	f000 fbed 	bl	8020b4c <fs_read_file_at>
 8020372:	4603      	mov	r3, r0
 8020374:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
        if(res != LV_FS_RES_OK) {
 8020378:	f897 3045 	ldrb.w	r3, [r7, #69]	@ 0x45
 802037c:	2b00      	cmp	r3, #0
 802037e:	d001      	beq.n	8020384 <lv_bin_decoder_get_area+0x370>
            return LV_RESULT_INVALID;
 8020380:	2300      	movs	r3, #0
 8020382:	e037      	b.n	80203f4 <lv_bin_decoder_get_area+0x3e0>
        }

        /*Now the A8 mask*/
        offset = sizeof(lv_image_header_t);
 8020384:	230c      	movs	r3, #12
 8020386:	62fb      	str	r3, [r7, #44]	@ 0x2c
        offset += dsc->header.h * dsc->header.stride; /*Move to A8 map*/
 8020388:	68bb      	ldr	r3, [r7, #8]
 802038a:	8adb      	ldrh	r3, [r3, #22]
 802038c:	461a      	mov	r2, r3
 802038e:	68bb      	ldr	r3, [r7, #8]
 8020390:	8b1b      	ldrh	r3, [r3, #24]
 8020392:	fb02 f303 	mul.w	r3, r2, r3
 8020396:	461a      	mov	r2, r3
 8020398:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802039a:	4413      	add	r3, r2
 802039c:	62fb      	str	r3, [r7, #44]	@ 0x2c
        offset += decoded_area->y1 * (dsc->header.stride / 2); /*Move to y1*/
 802039e:	683b      	ldr	r3, [r7, #0]
 80203a0:	685b      	ldr	r3, [r3, #4]
 80203a2:	68ba      	ldr	r2, [r7, #8]
 80203a4:	8b12      	ldrh	r2, [r2, #24]
 80203a6:	0852      	lsrs	r2, r2, #1
 80203a8:	b292      	uxth	r2, r2
 80203aa:	fb02 f303 	mul.w	r3, r2, r3
 80203ae:	461a      	mov	r2, r3
 80203b0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80203b2:	4413      	add	r3, r2
 80203b4:	62fb      	str	r3, [r7, #44]	@ 0x2c
        offset += decoded_area->x1 * 1; /*Move to x1*/
 80203b6:	683b      	ldr	r3, [r7, #0]
 80203b8:	681b      	ldr	r3, [r3, #0]
 80203ba:	461a      	mov	r2, r3
 80203bc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80203be:	4413      	add	r3, r2
 80203c0:	62fb      	str	r3, [r7, #44]	@ 0x2c
        res = fs_read_file_at(f, offset, img_data + len, w_px * 1, NULL);
 80203c2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80203c4:	697b      	ldr	r3, [r7, #20]
 80203c6:	441a      	add	r2, r3
 80203c8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80203ca:	2100      	movs	r1, #0
 80203cc:	9100      	str	r1, [sp, #0]
 80203ce:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80203d0:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 80203d2:	f000 fbbb 	bl	8020b4c <fs_read_file_at>
 80203d6:	4603      	mov	r3, r0
 80203d8:	f887 3045 	strb.w	r3, [r7, #69]	@ 0x45
        if(res != LV_FS_RES_OK) {
 80203dc:	f897 3045 	ldrb.w	r3, [r7, #69]	@ 0x45
 80203e0:	2b00      	cmp	r3, #0
 80203e2:	d001      	beq.n	80203e8 <lv_bin_decoder_get_area+0x3d4>
            return LV_RESULT_INVALID;
 80203e4:	2300      	movs	r3, #0
 80203e6:	e005      	b.n	80203f4 <lv_bin_decoder_get_area+0x3e0>
        }

        dsc->decoded = decoded; /*Return decoded image*/
 80203e8:	68bb      	ldr	r3, [r7, #8]
 80203ea:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 80203ec:	61da      	str	r2, [r3, #28]
        return LV_RESULT_OK;
 80203ee:	2301      	movs	r3, #1
 80203f0:	e000      	b.n	80203f4 <lv_bin_decoder_get_area+0x3e0>
    }

    return LV_RESULT_INVALID;
 80203f2:	2300      	movs	r3, #0
}
 80203f4:	4618      	mov	r0, r3
 80203f6:	3754      	adds	r7, #84	@ 0x54
 80203f8:	46bd      	mov	sp, r7
 80203fa:	bd90      	pop	{r4, r7, pc}

080203fc <get_decoder_data>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static decoder_data_t * get_decoder_data(lv_image_decoder_dsc_t * dsc)
{
 80203fc:	b580      	push	{r7, lr}
 80203fe:	b084      	sub	sp, #16
 8020400:	af00      	add	r7, sp, #0
 8020402:	6078      	str	r0, [r7, #4]
    decoder_data_t * data = dsc->user_data;
 8020404:	687b      	ldr	r3, [r7, #4]
 8020406:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8020408:	60fb      	str	r3, [r7, #12]
    if(data == NULL) {
 802040a:	68fb      	ldr	r3, [r7, #12]
 802040c:	2b00      	cmp	r3, #0
 802040e:	d110      	bne.n	8020432 <get_decoder_data+0x36>
        data = lv_malloc_zeroed(sizeof(decoder_data_t));
 8020410:	2040      	movs	r0, #64	@ 0x40
 8020412:	f005 fcf3 	bl	8025dfc <lv_malloc_zeroed>
 8020416:	60f8      	str	r0, [r7, #12]
        LV_ASSERT_MALLOC(data);
 8020418:	68fb      	ldr	r3, [r7, #12]
 802041a:	2b00      	cmp	r3, #0
 802041c:	d101      	bne.n	8020422 <get_decoder_data+0x26>
 802041e:	bf00      	nop
 8020420:	e7fd      	b.n	802041e <get_decoder_data+0x22>
        if(data == NULL) {
 8020422:	68fb      	ldr	r3, [r7, #12]
 8020424:	2b00      	cmp	r3, #0
 8020426:	d101      	bne.n	802042c <get_decoder_data+0x30>
            LV_LOG_ERROR("Out of memory");
            return NULL;
 8020428:	2300      	movs	r3, #0
 802042a:	e003      	b.n	8020434 <get_decoder_data+0x38>
        }

        dsc->user_data = data;
 802042c:	687b      	ldr	r3, [r7, #4]
 802042e:	68fa      	ldr	r2, [r7, #12]
 8020430:	639a      	str	r2, [r3, #56]	@ 0x38
    }

    return data;
 8020432:	68fb      	ldr	r3, [r7, #12]
}
 8020434:	4618      	mov	r0, r3
 8020436:	3710      	adds	r7, #16
 8020438:	46bd      	mov	sp, r7
 802043a:	bd80      	pop	{r7, pc}

0802043c <free_decoder_data>:

static void free_decoder_data(lv_image_decoder_dsc_t * dsc)
{
 802043c:	b580      	push	{r7, lr}
 802043e:	b084      	sub	sp, #16
 8020440:	af00      	add	r7, sp, #0
 8020442:	6078      	str	r0, [r7, #4]
    decoder_data_t * decoder_data = dsc->user_data;
 8020444:	687b      	ldr	r3, [r7, #4]
 8020446:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8020448:	60fb      	str	r3, [r7, #12]
    if(decoder_data == NULL) return;
 802044a:	68fb      	ldr	r3, [r7, #12]
 802044c:	2b00      	cmp	r3, #0
 802044e:	d02b      	beq.n	80204a8 <free_decoder_data+0x6c>

    if(decoder_data->f) {
 8020450:	68fb      	ldr	r3, [r7, #12]
 8020452:	681b      	ldr	r3, [r3, #0]
 8020454:	2b00      	cmp	r3, #0
 8020456:	d009      	beq.n	802046c <free_decoder_data+0x30>
        lv_fs_close(decoder_data->f);
 8020458:	68fb      	ldr	r3, [r7, #12]
 802045a:	681b      	ldr	r3, [r3, #0]
 802045c:	4618      	mov	r0, r3
 802045e:	f002 fad0 	bl	8022a02 <lv_fs_close>
        lv_free(decoder_data->f);
 8020462:	68fb      	ldr	r3, [r7, #12]
 8020464:	681b      	ldr	r3, [r3, #0]
 8020466:	4618      	mov	r0, r3
 8020468:	f005 fce6 	bl	8025e38 <lv_free>
    }

    if(decoder_data->decoded) lv_draw_buf_destroy(decoder_data->decoded);
 802046c:	68fb      	ldr	r3, [r7, #12]
 802046e:	69db      	ldr	r3, [r3, #28]
 8020470:	2b00      	cmp	r3, #0
 8020472:	d004      	beq.n	802047e <free_decoder_data+0x42>
 8020474:	68fb      	ldr	r3, [r7, #12]
 8020476:	69db      	ldr	r3, [r3, #28]
 8020478:	4618      	mov	r0, r3
 802047a:	f7eb fd97 	bl	800bfac <lv_draw_buf_destroy>
    if(decoder_data->decompressed) lv_draw_buf_destroy(decoder_data->decompressed);
 802047e:	68fb      	ldr	r3, [r7, #12]
 8020480:	6a1b      	ldr	r3, [r3, #32]
 8020482:	2b00      	cmp	r3, #0
 8020484:	d004      	beq.n	8020490 <free_decoder_data+0x54>
 8020486:	68fb      	ldr	r3, [r7, #12]
 8020488:	6a1b      	ldr	r3, [r3, #32]
 802048a:	4618      	mov	r0, r3
 802048c:	f7eb fd8e 	bl	800bfac <lv_draw_buf_destroy>
    lv_free(decoder_data->palette);
 8020490:	68fb      	ldr	r3, [r7, #12]
 8020492:	685b      	ldr	r3, [r3, #4]
 8020494:	4618      	mov	r0, r3
 8020496:	f005 fccf 	bl	8025e38 <lv_free>
    lv_free(decoder_data);
 802049a:	68f8      	ldr	r0, [r7, #12]
 802049c:	f005 fccc 	bl	8025e38 <lv_free>
    dsc->user_data = NULL;
 80204a0:	687b      	ldr	r3, [r7, #4]
 80204a2:	2200      	movs	r2, #0
 80204a4:	639a      	str	r2, [r3, #56]	@ 0x38
 80204a6:	e000      	b.n	80204aa <free_decoder_data+0x6e>
    if(decoder_data == NULL) return;
 80204a8:	bf00      	nop
}
 80204aa:	3710      	adds	r7, #16
 80204ac:	46bd      	mov	sp, r7
 80204ae:	bd80      	pop	{r7, pc}

080204b0 <decode_indexed>:

static lv_result_t decode_indexed(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
{
 80204b0:	b580      	push	{r7, lr}
 80204b2:	b092      	sub	sp, #72	@ 0x48
 80204b4:	af02      	add	r7, sp, #8
 80204b6:	6078      	str	r0, [r7, #4]
 80204b8:	6039      	str	r1, [r7, #0]
    LV_UNUSED(decoder); /*Unused*/
    lv_result_t res;
    uint32_t rn;
    decoder_data_t * decoder_data = dsc->user_data;
 80204ba:	683b      	ldr	r3, [r7, #0]
 80204bc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80204be:	63bb      	str	r3, [r7, #56]	@ 0x38
    lv_fs_file_t * f = decoder_data->f;
 80204c0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80204c2:	681b      	ldr	r3, [r3, #0]
 80204c4:	637b      	str	r3, [r7, #52]	@ 0x34
    lv_color_format_t cf = dsc->header.cf;
 80204c6:	683b      	ldr	r3, [r7, #0]
 80204c8:	7c5b      	ldrb	r3, [r3, #17]
 80204ca:	f887 3033 	strb.w	r3, [r7, #51]	@ 0x33
    uint32_t palette_len = sizeof(lv_color32_t) * LV_COLOR_INDEXED_PALETTE_SIZE(cf);
 80204ce:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 80204d2:	2b07      	cmp	r3, #7
 80204d4:	d014      	beq.n	8020500 <decode_indexed+0x50>
 80204d6:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 80204da:	2b08      	cmp	r3, #8
 80204dc:	d00e      	beq.n	80204fc <decode_indexed+0x4c>
 80204de:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 80204e2:	2b09      	cmp	r3, #9
 80204e4:	d008      	beq.n	80204f8 <decode_indexed+0x48>
 80204e6:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 80204ea:	2b0a      	cmp	r3, #10
 80204ec:	d102      	bne.n	80204f4 <decode_indexed+0x44>
 80204ee:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80204f2:	e006      	b.n	8020502 <decode_indexed+0x52>
 80204f4:	2300      	movs	r3, #0
 80204f6:	e004      	b.n	8020502 <decode_indexed+0x52>
 80204f8:	2340      	movs	r3, #64	@ 0x40
 80204fa:	e002      	b.n	8020502 <decode_indexed+0x52>
 80204fc:	2310      	movs	r3, #16
 80204fe:	e000      	b.n	8020502 <decode_indexed+0x52>
 8020500:	2308      	movs	r3, #8
 8020502:	62fb      	str	r3, [r7, #44]	@ 0x2c
    const lv_color32_t * palette;
    const uint8_t * indexed_data = NULL;
 8020504:	2300      	movs	r3, #0
 8020506:	62bb      	str	r3, [r7, #40]	@ 0x28
    lv_draw_buf_t * draw_buf_indexed = NULL;
 8020508:	2300      	movs	r3, #0
 802050a:	627b      	str	r3, [r7, #36]	@ 0x24
    uint32_t stride = dsc->header.stride;
 802050c:	683b      	ldr	r3, [r7, #0]
 802050e:	8b1b      	ldrh	r3, [r3, #24]
 8020510:	623b      	str	r3, [r7, #32]

    bool is_compressed = dsc->header.flags & LV_IMAGE_FLAGS_COMPRESSED;
 8020512:	683b      	ldr	r3, [r7, #0]
 8020514:	8a5b      	ldrh	r3, [r3, #18]
 8020516:	f003 0308 	and.w	r3, r3, #8
 802051a:	2b00      	cmp	r3, #0
 802051c:	bf14      	ite	ne
 802051e:	2301      	movne	r3, #1
 8020520:	2300      	moveq	r3, #0
 8020522:	77fb      	strb	r3, [r7, #31]
    if(is_compressed) {
 8020524:	7ffb      	ldrb	r3, [r7, #31]
 8020526:	2b00      	cmp	r3, #0
 8020528:	d00a      	beq.n	8020540 <decode_indexed+0x90>
        uint8_t * data = decoder_data->decompressed->data;
 802052a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802052c:	6a1b      	ldr	r3, [r3, #32]
 802052e:	691b      	ldr	r3, [r3, #16]
 8020530:	613b      	str	r3, [r7, #16]
        palette = (lv_color32_t *)data;
 8020532:	693b      	ldr	r3, [r7, #16]
 8020534:	63fb      	str	r3, [r7, #60]	@ 0x3c
        indexed_data = data + palette_len;
 8020536:	693a      	ldr	r2, [r7, #16]
 8020538:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802053a:	4413      	add	r3, r2
 802053c:	62bb      	str	r3, [r7, #40]	@ 0x28
 802053e:	e03e      	b.n	80205be <decode_indexed+0x10e>
    }
    else if(dsc->src_type == LV_IMAGE_SRC_FILE) {
 8020540:	683b      	ldr	r3, [r7, #0]
 8020542:	7b1b      	ldrb	r3, [r3, #12]
 8020544:	2b01      	cmp	r3, #1
 8020546:	d128      	bne.n	802059a <decode_indexed+0xea>
        /*read palette for indexed image*/
        palette = lv_malloc(palette_len);
 8020548:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 802054a:	f005 fc3d 	bl	8025dc8 <lv_malloc>
 802054e:	63f8      	str	r0, [r7, #60]	@ 0x3c
        LV_ASSERT_MALLOC(palette);
 8020550:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8020552:	2b00      	cmp	r3, #0
 8020554:	d101      	bne.n	802055a <decode_indexed+0xaa>
 8020556:	bf00      	nop
 8020558:	e7fd      	b.n	8020556 <decode_indexed+0xa6>
        if(palette == NULL) {
 802055a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802055c:	2b00      	cmp	r3, #0
 802055e:	d101      	bne.n	8020564 <decode_indexed+0xb4>
            LV_LOG_ERROR("Out of memory");
            return LV_RESULT_INVALID;
 8020560:	2300      	movs	r3, #0
 8020562:	e04c      	b.n	80205fe <decode_indexed+0x14e>
        }

        res = fs_read_file_at(f, sizeof(lv_image_header_t), (uint8_t *)palette, palette_len, &rn);
 8020564:	f107 030c 	add.w	r3, r7, #12
 8020568:	9300      	str	r3, [sp, #0]
 802056a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802056c:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802056e:	210c      	movs	r1, #12
 8020570:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8020572:	f000 faeb 	bl	8020b4c <fs_read_file_at>
 8020576:	4603      	mov	r3, r0
 8020578:	75fb      	strb	r3, [r7, #23]
        if(res != LV_FS_RES_OK || rn != palette_len) {
 802057a:	7dfb      	ldrb	r3, [r7, #23]
 802057c:	2b00      	cmp	r3, #0
 802057e:	d103      	bne.n	8020588 <decode_indexed+0xd8>
 8020580:	68fb      	ldr	r3, [r7, #12]
 8020582:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020584:	429a      	cmp	r2, r3
 8020586:	d004      	beq.n	8020592 <decode_indexed+0xe2>
            LV_LOG_WARN("Read palette failed: %d", res);
            lv_free((void *)palette);
 8020588:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 802058a:	f005 fc55 	bl	8025e38 <lv_free>
            return LV_RESULT_INVALID;
 802058e:	2300      	movs	r3, #0
 8020590:	e035      	b.n	80205fe <decode_indexed+0x14e>
        }

        decoder_data->palette = (void *)palette; /*Need to free when decoder closes*/
 8020592:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8020594:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8020596:	605a      	str	r2, [r3, #4]
 8020598:	e011      	b.n	80205be <decode_indexed+0x10e>
            LV_LOG_WARN("Read indexed image failed: %d", res);
            goto exit_with_buf;
        }
#endif
    }
    else if(dsc->src_type == LV_IMAGE_SRC_VARIABLE) {
 802059a:	683b      	ldr	r3, [r7, #0]
 802059c:	7b1b      	ldrb	r3, [r3, #12]
 802059e:	2b00      	cmp	r3, #0
 80205a0:	d10b      	bne.n	80205ba <decode_indexed+0x10a>
        lv_image_dsc_t * image = (lv_image_dsc_t *)dsc->src;
 80205a2:	683b      	ldr	r3, [r7, #0]
 80205a4:	689b      	ldr	r3, [r3, #8]
 80205a6:	61bb      	str	r3, [r7, #24]
        palette = (lv_color32_t *)image->data;
 80205a8:	69bb      	ldr	r3, [r7, #24]
 80205aa:	691b      	ldr	r3, [r3, #16]
 80205ac:	63fb      	str	r3, [r7, #60]	@ 0x3c
        indexed_data = image->data + palette_len;
 80205ae:	69bb      	ldr	r3, [r7, #24]
 80205b0:	691a      	ldr	r2, [r3, #16]
 80205b2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80205b4:	4413      	add	r3, r2
 80205b6:	62bb      	str	r3, [r7, #40]	@ 0x28
 80205b8:	e001      	b.n	80205be <decode_indexed+0x10e>
    }
    else {
        return LV_RESULT_INVALID;
 80205ba:	2300      	movs	r3, #0
 80205bc:	e01f      	b.n	80205fe <decode_indexed+0x14e>
    }

    dsc->palette = palette;
 80205be:	683b      	ldr	r3, [r7, #0]
 80205c0:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80205c2:	621a      	str	r2, [r3, #32]
    dsc->palette_size = LV_COLOR_INDEXED_PALETTE_SIZE(cf);
 80205c4:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 80205c8:	2b07      	cmp	r3, #7
 80205ca:	d014      	beq.n	80205f6 <decode_indexed+0x146>
 80205cc:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 80205d0:	2b08      	cmp	r3, #8
 80205d2:	d00e      	beq.n	80205f2 <decode_indexed+0x142>
 80205d4:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 80205d8:	2b09      	cmp	r3, #9
 80205da:	d008      	beq.n	80205ee <decode_indexed+0x13e>
 80205dc:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 80205e0:	2b0a      	cmp	r3, #10
 80205e2:	d102      	bne.n	80205ea <decode_indexed+0x13a>
 80205e4:	f44f 7380 	mov.w	r3, #256	@ 0x100
 80205e8:	e006      	b.n	80205f8 <decode_indexed+0x148>
 80205ea:	2300      	movs	r3, #0
 80205ec:	e004      	b.n	80205f8 <decode_indexed+0x148>
 80205ee:	2310      	movs	r3, #16
 80205f0:	e002      	b.n	80205f8 <decode_indexed+0x148>
 80205f2:	2304      	movs	r3, #4
 80205f4:	e000      	b.n	80205f8 <decode_indexed+0x148>
 80205f6:	2302      	movs	r3, #2
 80205f8:	683a      	ldr	r2, [r7, #0]
 80205fa:	6253      	str	r3, [r2, #36]	@ 0x24
#else
    LV_UNUSED(stride);
    LV_UNUSED(indexed_data);
    LV_UNUSED(draw_buf_indexed);
    /*It needs to be read by get_area_cb later*/
    return LV_RESULT_OK;
 80205fc:	2301      	movs	r3, #1
#endif
}
 80205fe:	4618      	mov	r0, r3
 8020600:	3740      	adds	r7, #64	@ 0x40
 8020602:	46bd      	mov	sp, r7
 8020604:	bd80      	pop	{r7, pc}

08020606 <load_indexed>:

static lv_result_t load_indexed(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
{
 8020606:	b480      	push	{r7}
 8020608:	b083      	sub	sp, #12
 802060a:	af00      	add	r7, sp, #0
 802060c:	6078      	str	r0, [r7, #4]
 802060e:	6039      	str	r1, [r7, #0]
#if LV_BIN_DECODER_RAM_LOAD == 0
    LV_UNUSED(decoder); /*Unused*/
    LV_UNUSED(dsc); /*Unused*/
    LV_LOG_ERROR("LV_BIN_DECODER_RAM_LOAD is disabled");
    return LV_RESULT_INVALID;
 8020610:	2300      	movs	r3, #0
    }

    LV_LOG_ERROR("Unknown src type: %d", dsc->src_type);
    return LV_RESULT_INVALID;
#endif
}
 8020612:	4618      	mov	r0, r3
 8020614:	370c      	adds	r7, #12
 8020616:	46bd      	mov	sp, r7
 8020618:	f85d 7b04 	ldr.w	r7, [sp], #4
 802061c:	4770      	bx	lr

0802061e <bit_extend>:

/**
 * Extend A1/2/4 to A8 with interpolation to reduce rounding error.
 */
static inline uint8_t bit_extend(uint8_t value, uint8_t bpp)
{
 802061e:	b480      	push	{r7}
 8020620:	b085      	sub	sp, #20
 8020622:	af00      	add	r7, sp, #0
 8020624:	4603      	mov	r3, r0
 8020626:	460a      	mov	r2, r1
 8020628:	71fb      	strb	r3, [r7, #7]
 802062a:	4613      	mov	r3, r2
 802062c:	71bb      	strb	r3, [r7, #6]
    if(value == 0) return 0;
 802062e:	79fb      	ldrb	r3, [r7, #7]
 8020630:	2b00      	cmp	r3, #0
 8020632:	d101      	bne.n	8020638 <bit_extend+0x1a>
 8020634:	2300      	movs	r3, #0
 8020636:	e018      	b.n	802066a <bit_extend+0x4c>

    uint8_t res = value;
 8020638:	79fb      	ldrb	r3, [r7, #7]
 802063a:	73fb      	strb	r3, [r7, #15]
    uint8_t bpp_now = bpp;
 802063c:	79bb      	ldrb	r3, [r7, #6]
 802063e:	73bb      	strb	r3, [r7, #14]
    while(bpp_now < 8) {
 8020640:	e00f      	b.n	8020662 <bit_extend+0x44>
        res |= value << (8 - bpp_now);
 8020642:	79fa      	ldrb	r2, [r7, #7]
 8020644:	7bbb      	ldrb	r3, [r7, #14]
 8020646:	f1c3 0308 	rsb	r3, r3, #8
 802064a:	fa02 f303 	lsl.w	r3, r2, r3
 802064e:	b25a      	sxtb	r2, r3
 8020650:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8020654:	4313      	orrs	r3, r2
 8020656:	b25b      	sxtb	r3, r3
 8020658:	73fb      	strb	r3, [r7, #15]
        bpp_now += bpp;
 802065a:	7bba      	ldrb	r2, [r7, #14]
 802065c:	79bb      	ldrb	r3, [r7, #6]
 802065e:	4413      	add	r3, r2
 8020660:	73bb      	strb	r3, [r7, #14]
    while(bpp_now < 8) {
 8020662:	7bbb      	ldrb	r3, [r7, #14]
 8020664:	2b07      	cmp	r3, #7
 8020666:	d9ec      	bls.n	8020642 <bit_extend+0x24>
    };

    return res;
 8020668:	7bfb      	ldrb	r3, [r7, #15]
}
 802066a:	4618      	mov	r0, r3
 802066c:	3714      	adds	r7, #20
 802066e:	46bd      	mov	sp, r7
 8020670:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020674:	4770      	bx	lr

08020676 <decode_alpha_only>:

static lv_result_t decode_alpha_only(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
{
 8020676:	b580      	push	{r7, lr}
 8020678:	b092      	sub	sp, #72	@ 0x48
 802067a:	af02      	add	r7, sp, #8
 802067c:	6078      	str	r0, [r7, #4]
 802067e:	6039      	str	r1, [r7, #0]
    LV_UNUSED(decoder);
    lv_result_t res;
    uint32_t rn;
    decoder_data_t * decoder_data = dsc->user_data;
 8020680:	683b      	ldr	r3, [r7, #0]
 8020682:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8020684:	62fb      	str	r3, [r7, #44]	@ 0x2c
    uint8_t bpp = lv_color_format_get_bpp(dsc->header.cf);
 8020686:	683b      	ldr	r3, [r7, #0]
 8020688:	7c5b      	ldrb	r3, [r3, #17]
 802068a:	4618      	mov	r0, r3
 802068c:	f001 ff3c 	bl	8022508 <lv_color_format_get_bpp>
 8020690:	4603      	mov	r3, r0
 8020692:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
    uint32_t w = (dsc->header.stride * 8) / bpp;
 8020696:	683b      	ldr	r3, [r7, #0]
 8020698:	8b1b      	ldrh	r3, [r3, #24]
 802069a:	00da      	lsls	r2, r3, #3
 802069c:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 80206a0:	fb92 f3f3 	sdiv	r3, r2, r3
 80206a4:	627b      	str	r3, [r7, #36]	@ 0x24
    uint32_t buf_stride = (w * 8 + 7) >> 3; /*stride for img_data*/
 80206a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80206a8:	00db      	lsls	r3, r3, #3
 80206aa:	3307      	adds	r3, #7
 80206ac:	08db      	lsrs	r3, r3, #3
 80206ae:	623b      	str	r3, [r7, #32]
    uint32_t buf_len = w * dsc->header.h; /*always decode to A8 format*/
 80206b0:	683b      	ldr	r3, [r7, #0]
 80206b2:	8adb      	ldrh	r3, [r3, #22]
 80206b4:	461a      	mov	r2, r3
 80206b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80206b8:	fb02 f303 	mul.w	r3, r2, r3
 80206bc:	61fb      	str	r3, [r7, #28]
    lv_draw_buf_t * decoded;
    uint32_t file_len = (uint32_t)dsc->header.stride * dsc->header.h;
 80206be:	683b      	ldr	r3, [r7, #0]
 80206c0:	8b1b      	ldrh	r3, [r3, #24]
 80206c2:	461a      	mov	r2, r3
 80206c4:	683b      	ldr	r3, [r7, #0]
 80206c6:	8adb      	ldrh	r3, [r3, #22]
 80206c8:	fb02 f303 	mul.w	r3, r2, r3
 80206cc:	61bb      	str	r3, [r7, #24]

    decoded = lv_draw_buf_create(dsc->header.w, dsc->header.h, LV_COLOR_FORMAT_A8, buf_stride);
 80206ce:	683b      	ldr	r3, [r7, #0]
 80206d0:	8a9b      	ldrh	r3, [r3, #20]
 80206d2:	4618      	mov	r0, r3
 80206d4:	683b      	ldr	r3, [r7, #0]
 80206d6:	8adb      	ldrh	r3, [r3, #22]
 80206d8:	4619      	mov	r1, r3
 80206da:	6a3b      	ldr	r3, [r7, #32]
 80206dc:	220e      	movs	r2, #14
 80206de:	f7eb fb93 	bl	800be08 <lv_draw_buf_create>
 80206e2:	6178      	str	r0, [r7, #20]
    if(decoded == NULL) {
 80206e4:	697b      	ldr	r3, [r7, #20]
 80206e6:	2b00      	cmp	r3, #0
 80206e8:	d101      	bne.n	80206ee <decode_alpha_only+0x78>
        LV_LOG_ERROR("Out of memory");
        return LV_RESULT_INVALID;
 80206ea:	2300      	movs	r3, #0
 80206ec:	e08f      	b.n	802080e <decode_alpha_only+0x198>
    }

    uint8_t * img_data = decoded->data;
 80206ee:	697b      	ldr	r3, [r7, #20]
 80206f0:	691b      	ldr	r3, [r3, #16]
 80206f2:	613b      	str	r3, [r7, #16]

    if(dsc->header.flags & LV_IMAGE_FLAGS_COMPRESSED) {
 80206f4:	683b      	ldr	r3, [r7, #0]
 80206f6:	8a5b      	ldrh	r3, [r3, #18]
 80206f8:	f003 0308 	and.w	r3, r3, #8
 80206fc:	2b00      	cmp	r3, #0
 80206fe:	d008      	beq.n	8020712 <decode_alpha_only+0x9c>
        /*Copy from image data*/
        lv_memcpy(img_data, decoder_data->decompressed->data, file_len);
 8020700:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020702:	6a1b      	ldr	r3, [r3, #32]
 8020704:	691b      	ldr	r3, [r3, #16]
 8020706:	69ba      	ldr	r2, [r7, #24]
 8020708:	4619      	mov	r1, r3
 802070a:	6938      	ldr	r0, [r7, #16]
 802070c:	f004 f96c 	bl	80249e8 <lv_memcpy>
 8020710:	e027      	b.n	8020762 <decode_alpha_only+0xec>
    }
    else if(dsc->src_type == LV_IMAGE_SRC_FILE) {
 8020712:	683b      	ldr	r3, [r7, #0]
 8020714:	7b1b      	ldrb	r3, [r3, #12]
 8020716:	2b01      	cmp	r3, #1
 8020718:	d117      	bne.n	802074a <decode_alpha_only+0xd4>
        res = fs_read_file_at(decoder_data->f, sizeof(lv_image_header_t), img_data, file_len, &rn);
 802071a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802071c:	6818      	ldr	r0, [r3, #0]
 802071e:	f107 0308 	add.w	r3, r7, #8
 8020722:	9300      	str	r3, [sp, #0]
 8020724:	69bb      	ldr	r3, [r7, #24]
 8020726:	693a      	ldr	r2, [r7, #16]
 8020728:	210c      	movs	r1, #12
 802072a:	f000 fa0f 	bl	8020b4c <fs_read_file_at>
 802072e:	4603      	mov	r3, r0
 8020730:	73fb      	strb	r3, [r7, #15]
        if(res != LV_FS_RES_OK || rn != file_len) {
 8020732:	7bfb      	ldrb	r3, [r7, #15]
 8020734:	2b00      	cmp	r3, #0
 8020736:	d103      	bne.n	8020740 <decode_alpha_only+0xca>
 8020738:	68bb      	ldr	r3, [r7, #8]
 802073a:	69ba      	ldr	r2, [r7, #24]
 802073c:	429a      	cmp	r2, r3
 802073e:	d010      	beq.n	8020762 <decode_alpha_only+0xec>
            LV_LOG_WARN("Read header failed: %d", res);
            lv_draw_buf_destroy(decoded);
 8020740:	6978      	ldr	r0, [r7, #20]
 8020742:	f7eb fc33 	bl	800bfac <lv_draw_buf_destroy>
            return LV_RESULT_INVALID;
 8020746:	2300      	movs	r3, #0
 8020748:	e061      	b.n	802080e <decode_alpha_only+0x198>
        }
    }
    else if(dsc->src_type == LV_IMAGE_SRC_VARIABLE) {
 802074a:	683b      	ldr	r3, [r7, #0]
 802074c:	7b1b      	ldrb	r3, [r3, #12]
 802074e:	2b00      	cmp	r3, #0
 8020750:	d107      	bne.n	8020762 <decode_alpha_only+0xec>
        /*Copy from image data*/
        lv_memcpy(img_data, ((lv_image_dsc_t *)dsc->src)->data, file_len);
 8020752:	683b      	ldr	r3, [r7, #0]
 8020754:	689b      	ldr	r3, [r3, #8]
 8020756:	691b      	ldr	r3, [r3, #16]
 8020758:	69ba      	ldr	r2, [r7, #24]
 802075a:	4619      	mov	r1, r3
 802075c:	6938      	ldr	r0, [r7, #16]
 802075e:	f004 f943 	bl	80249e8 <lv_memcpy>
    }

    if(dsc->header.cf != LV_COLOR_FORMAT_A8) {
 8020762:	683b      	ldr	r3, [r7, #0]
 8020764:	7c5b      	ldrb	r3, [r3, #17]
 8020766:	2b0e      	cmp	r3, #14
 8020768:	d04a      	beq.n	8020800 <decode_alpha_only+0x18a>
        /*Convert A1/2/4 to A8 from last pixel to first pixel*/
        uint8_t * in = img_data + file_len - 1;
 802076a:	69bb      	ldr	r3, [r7, #24]
 802076c:	3b01      	subs	r3, #1
 802076e:	693a      	ldr	r2, [r7, #16]
 8020770:	4413      	add	r3, r2
 8020772:	63fb      	str	r3, [r7, #60]	@ 0x3c
        uint8_t * out = img_data + buf_len - 1;
 8020774:	69fb      	ldr	r3, [r7, #28]
 8020776:	3b01      	subs	r3, #1
 8020778:	693a      	ldr	r2, [r7, #16]
 802077a:	4413      	add	r3, r2
 802077c:	63bb      	str	r3, [r7, #56]	@ 0x38
        uint8_t mask = (1 << bpp) - 1;
 802077e:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 8020782:	2201      	movs	r2, #1
 8020784:	fa02 f303 	lsl.w	r3, r2, r3
 8020788:	b2db      	uxtb	r3, r3
 802078a:	3b01      	subs	r3, #1
 802078c:	73bb      	strb	r3, [r7, #14]
        uint8_t shift = 0;
 802078e:	2300      	movs	r3, #0
 8020790:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
        for(uint32_t i = 0; i < buf_len; i++) {
 8020794:	2300      	movs	r3, #0
 8020796:	633b      	str	r3, [r7, #48]	@ 0x30
 8020798:	e02e      	b.n	80207f8 <decode_alpha_only+0x182>
             * thus causes error. We can simply interpolate the value to fix it.
             *
             * Equation: *out = ((*in >> shift) & mask) << (8 - bpp);
             * Ideal: *out = ((*in >> shift) & mask) * 255 / ((1L << bpp) - 1)
             */
            uint8_t value = ((*in >> shift) & mask);
 802079a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802079c:	781b      	ldrb	r3, [r3, #0]
 802079e:	461a      	mov	r2, r3
 80207a0:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 80207a4:	fa42 f303 	asr.w	r3, r2, r3
 80207a8:	b25a      	sxtb	r2, r3
 80207aa:	f997 300e 	ldrsb.w	r3, [r7, #14]
 80207ae:	4013      	ands	r3, r2
 80207b0:	b25b      	sxtb	r3, r3
 80207b2:	737b      	strb	r3, [r7, #13]
            *out = bit_extend(value, bpp);
 80207b4:	f897 202b 	ldrb.w	r2, [r7, #43]	@ 0x2b
 80207b8:	7b7b      	ldrb	r3, [r7, #13]
 80207ba:	4611      	mov	r1, r2
 80207bc:	4618      	mov	r0, r3
 80207be:	f7ff ff2e 	bl	802061e <bit_extend>
 80207c2:	4603      	mov	r3, r0
 80207c4:	461a      	mov	r2, r3
 80207c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80207c8:	701a      	strb	r2, [r3, #0]
            shift += bpp;
 80207ca:	f897 2037 	ldrb.w	r2, [r7, #55]	@ 0x37
 80207ce:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 80207d2:	4413      	add	r3, r2
 80207d4:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
            if(shift >= 8) {
 80207d8:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 80207dc:	2b07      	cmp	r3, #7
 80207de:	d905      	bls.n	80207ec <decode_alpha_only+0x176>
                shift = 0;
 80207e0:	2300      	movs	r3, #0
 80207e2:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
                in--;
 80207e6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80207e8:	3b01      	subs	r3, #1
 80207ea:	63fb      	str	r3, [r7, #60]	@ 0x3c
            }
            out--;
 80207ec:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80207ee:	3b01      	subs	r3, #1
 80207f0:	63bb      	str	r3, [r7, #56]	@ 0x38
        for(uint32_t i = 0; i < buf_len; i++) {
 80207f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80207f4:	3301      	adds	r3, #1
 80207f6:	633b      	str	r3, [r7, #48]	@ 0x30
 80207f8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80207fa:	69fb      	ldr	r3, [r7, #28]
 80207fc:	429a      	cmp	r2, r3
 80207fe:	d3cc      	bcc.n	802079a <decode_alpha_only+0x124>
        }
    }

    decoder_data->decoded = decoded;
 8020800:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020802:	697a      	ldr	r2, [r7, #20]
 8020804:	61da      	str	r2, [r3, #28]
    dsc->decoded = decoded;
 8020806:	683b      	ldr	r3, [r7, #0]
 8020808:	697a      	ldr	r2, [r7, #20]
 802080a:	61da      	str	r2, [r3, #28]
    return LV_RESULT_OK;
 802080c:	2301      	movs	r3, #1
}
 802080e:	4618      	mov	r0, r3
 8020810:	3740      	adds	r7, #64	@ 0x40
 8020812:	46bd      	mov	sp, r7
 8020814:	bd80      	pop	{r7, pc}

08020816 <decode_compressed>:

static lv_result_t decode_compressed(lv_image_decoder_t * decoder, lv_image_decoder_dsc_t * dsc)
{
 8020816:	b580      	push	{r7, lr}
 8020818:	b090      	sub	sp, #64	@ 0x40
 802081a:	af02      	add	r7, sp, #8
 802081c:	6078      	str	r0, [r7, #4]
 802081e:	6039      	str	r1, [r7, #0]
    uint32_t rn;
    uint32_t len;
    uint32_t compressed_len;
    decoder_data_t * decoder_data = get_decoder_data(dsc);
 8020820:	6838      	ldr	r0, [r7, #0]
 8020822:	f7ff fdeb 	bl	80203fc <get_decoder_data>
 8020826:	62f8      	str	r0, [r7, #44]	@ 0x2c
    lv_result_t res;
    uint8_t * file_buf = NULL;
 8020828:	2300      	movs	r3, #0
 802082a:	633b      	str	r3, [r7, #48]	@ 0x30
    lv_image_compressed_t * compressed = &decoder_data->compressed;
 802082c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802082e:	330c      	adds	r3, #12
 8020830:	62bb      	str	r3, [r7, #40]	@ 0x28

    lv_memzero(compressed, sizeof(lv_image_compressed_t));
 8020832:	2110      	movs	r1, #16
 8020834:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8020836:	f7ff f995 	bl	801fb64 <lv_memzero>

    if(dsc->src_type == LV_IMAGE_SRC_FILE) {
 802083a:	683b      	ldr	r3, [r7, #0]
 802083c:	7b1b      	ldrb	r3, [r3, #12]
 802083e:	2b01      	cmp	r3, #1
 8020840:	d15f      	bne.n	8020902 <decode_compressed+0xec>
        lv_fs_file_t * f = decoder_data->f;
 8020842:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8020844:	681b      	ldr	r3, [r3, #0]
 8020846:	61fb      	str	r3, [r7, #28]

        if(lv_fs_seek(f, 0, LV_FS_SEEK_END) != LV_FS_RES_OK ||
 8020848:	2202      	movs	r2, #2
 802084a:	2100      	movs	r1, #0
 802084c:	69f8      	ldr	r0, [r7, #28]
 802084e:	f002 fa9a 	bl	8022d86 <lv_fs_seek>
 8020852:	4603      	mov	r3, r0
 8020854:	2b00      	cmp	r3, #0
 8020856:	d108      	bne.n	802086a <decode_compressed+0x54>
           lv_fs_tell(f, &compressed_len) != LV_FS_RES_OK) {
 8020858:	f107 030c 	add.w	r3, r7, #12
 802085c:	4619      	mov	r1, r3
 802085e:	69f8      	ldr	r0, [r7, #28]
 8020860:	f002 fb3b 	bl	8022eda <lv_fs_tell>
 8020864:	4603      	mov	r3, r0
        if(lv_fs_seek(f, 0, LV_FS_SEEK_END) != LV_FS_RES_OK ||
 8020866:	2b00      	cmp	r3, #0
 8020868:	d001      	beq.n	802086e <decode_compressed+0x58>
            LV_LOG_WARN("Failed to get compressed file len");
            return LV_RESULT_INVALID;
 802086a:	2300      	movs	r3, #0
 802086c:	e0c6      	b.n	80209fc <decode_compressed+0x1e6>
        }

        compressed_len -= sizeof(lv_image_header_t);
 802086e:	68fb      	ldr	r3, [r7, #12]
 8020870:	3b0c      	subs	r3, #12
 8020872:	60fb      	str	r3, [r7, #12]
        compressed_len -= 12;
 8020874:	68fb      	ldr	r3, [r7, #12]
 8020876:	3b0c      	subs	r3, #12
 8020878:	60fb      	str	r3, [r7, #12]

        /*Read compress header*/
        len = 12;
 802087a:	230c      	movs	r3, #12
 802087c:	623b      	str	r3, [r7, #32]
        res = fs_read_file_at(f, sizeof(lv_image_header_t), compressed, len, &rn);
 802087e:	f107 0310 	add.w	r3, r7, #16
 8020882:	9300      	str	r3, [sp, #0]
 8020884:	6a3b      	ldr	r3, [r7, #32]
 8020886:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8020888:	210c      	movs	r1, #12
 802088a:	69f8      	ldr	r0, [r7, #28]
 802088c:	f000 f95e 	bl	8020b4c <fs_read_file_at>
 8020890:	4603      	mov	r3, r0
 8020892:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
        if(res != LV_FS_RES_OK || rn != len) {
 8020896:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 802089a:	2b00      	cmp	r3, #0
 802089c:	d103      	bne.n	80208a6 <decode_compressed+0x90>
 802089e:	693b      	ldr	r3, [r7, #16]
 80208a0:	6a3a      	ldr	r2, [r7, #32]
 80208a2:	429a      	cmp	r2, r3
 80208a4:	d001      	beq.n	80208aa <decode_compressed+0x94>
            LV_LOG_WARN("Read compressed header failed: %d", res);
            return LV_RESULT_INVALID;
 80208a6:	2300      	movs	r3, #0
 80208a8:	e0a8      	b.n	80209fc <decode_compressed+0x1e6>
        }

        if(compressed->compressed_size != compressed_len) {
 80208aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80208ac:	685a      	ldr	r2, [r3, #4]
 80208ae:	68fb      	ldr	r3, [r7, #12]
 80208b0:	429a      	cmp	r2, r3
 80208b2:	d001      	beq.n	80208b8 <decode_compressed+0xa2>
            LV_LOG_WARN("Compressed size mismatch: %" LV_PRIu32" != %" LV_PRIu32, compressed->compressed_size, compressed_len);
            return LV_RESULT_INVALID;
 80208b4:	2300      	movs	r3, #0
 80208b6:	e0a1      	b.n	80209fc <decode_compressed+0x1e6>
        }

        file_buf = lv_malloc(compressed_len);
 80208b8:	68fb      	ldr	r3, [r7, #12]
 80208ba:	4618      	mov	r0, r3
 80208bc:	f005 fa84 	bl	8025dc8 <lv_malloc>
 80208c0:	6338      	str	r0, [r7, #48]	@ 0x30
        if(file_buf == NULL) {
 80208c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80208c4:	2b00      	cmp	r3, #0
 80208c6:	d101      	bne.n	80208cc <decode_compressed+0xb6>
            LV_LOG_WARN("No memory for compressed file");
            return LV_RESULT_INVALID;
 80208c8:	2300      	movs	r3, #0
 80208ca:	e097      	b.n	80209fc <decode_compressed+0x1e6>

        }

        /*Continue to read the compressed data following compression header*/
        res = lv_fs_read(f, file_buf, compressed_len, &rn);
 80208cc:	68fa      	ldr	r2, [r7, #12]
 80208ce:	f107 0310 	add.w	r3, r7, #16
 80208d2:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 80208d4:	69f8      	ldr	r0, [r7, #28]
 80208d6:	f002 fa11 	bl	8022cfc <lv_fs_read>
 80208da:	4603      	mov	r3, r0
 80208dc:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
        if(res != LV_FS_RES_OK || rn != compressed_len) {
 80208e0:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 80208e4:	2b00      	cmp	r3, #0
 80208e6:	d103      	bne.n	80208f0 <decode_compressed+0xda>
 80208e8:	693a      	ldr	r2, [r7, #16]
 80208ea:	68fb      	ldr	r3, [r7, #12]
 80208ec:	429a      	cmp	r2, r3
 80208ee:	d004      	beq.n	80208fa <decode_compressed+0xe4>
            LV_LOG_WARN("Read compressed file failed: %d", res);
            lv_free(file_buf);
 80208f0:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80208f2:	f005 faa1 	bl	8025e38 <lv_free>
            return LV_RESULT_INVALID;
 80208f6:	2300      	movs	r3, #0
 80208f8:	e080      	b.n	80209fc <decode_compressed+0x1e6>
        }

        /*Decompress the image*/
        compressed->data = file_buf;
 80208fa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80208fc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80208fe:	60da      	str	r2, [r3, #12]
 8020900:	e025      	b.n	802094e <decode_compressed+0x138>
    }
    else if(dsc->src_type == LV_IMAGE_SRC_VARIABLE) {
 8020902:	683b      	ldr	r3, [r7, #0]
 8020904:	7b1b      	ldrb	r3, [r3, #12]
 8020906:	2b00      	cmp	r3, #0
 8020908:	d11f      	bne.n	802094a <decode_compressed+0x134>
        lv_image_dsc_t * image = (lv_image_dsc_t *)dsc->src;
 802090a:	683b      	ldr	r3, [r7, #0]
 802090c:	689b      	ldr	r3, [r3, #8]
 802090e:	627b      	str	r3, [r7, #36]	@ 0x24
        compressed_len = image->data_size;
 8020910:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020912:	68db      	ldr	r3, [r3, #12]
 8020914:	60fb      	str	r3, [r7, #12]

        /*Read compress header*/
        len = 12;
 8020916:	230c      	movs	r3, #12
 8020918:	623b      	str	r3, [r7, #32]
        compressed_len -= len;
 802091a:	68fa      	ldr	r2, [r7, #12]
 802091c:	6a3b      	ldr	r3, [r7, #32]
 802091e:	1ad3      	subs	r3, r2, r3
 8020920:	60fb      	str	r3, [r7, #12]
        lv_memcpy(compressed, image->data, len);
 8020922:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020924:	691b      	ldr	r3, [r3, #16]
 8020926:	6a3a      	ldr	r2, [r7, #32]
 8020928:	4619      	mov	r1, r3
 802092a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 802092c:	f004 f85c 	bl	80249e8 <lv_memcpy>
        compressed->data = image->data + len;
 8020930:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8020932:	691a      	ldr	r2, [r3, #16]
 8020934:	6a3b      	ldr	r3, [r7, #32]
 8020936:	441a      	add	r2, r3
 8020938:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802093a:	60da      	str	r2, [r3, #12]
        if(compressed->compressed_size != compressed_len) {
 802093c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802093e:	685a      	ldr	r2, [r3, #4]
 8020940:	68fb      	ldr	r3, [r7, #12]
 8020942:	429a      	cmp	r2, r3
 8020944:	d003      	beq.n	802094e <decode_compressed+0x138>
            LV_LOG_WARN("Compressed size mismatch: %" LV_PRIu32" != %" LV_PRIu32, compressed->compressed_size, compressed_len);
            return LV_RESULT_INVALID;
 8020946:	2300      	movs	r3, #0
 8020948:	e058      	b.n	80209fc <decode_compressed+0x1e6>
        }
    }
    else {
        LV_LOG_WARN("Compressed image only support file or variable");
        return LV_RESULT_INVALID;
 802094a:	2300      	movs	r3, #0
 802094c:	e056      	b.n	80209fc <decode_compressed+0x1e6>
    }

    res = decompress_image(dsc, compressed);
 802094e:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8020950:	6838      	ldr	r0, [r7, #0]
 8020952:	f000 f929 	bl	8020ba8 <decompress_image>
 8020956:	4603      	mov	r3, r0
 8020958:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
    compressed->data = NULL; /*No need to store the data any more*/
 802095c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802095e:	2200      	movs	r2, #0
 8020960:	60da      	str	r2, [r3, #12]
    lv_free(file_buf);
 8020962:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8020964:	f005 fa68 	bl	8025e38 <lv_free>
    if(res != LV_RESULT_OK) {
 8020968:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 802096c:	2b01      	cmp	r3, #1
 802096e:	d001      	beq.n	8020974 <decode_compressed+0x15e>
        LV_LOG_WARN("Decompress failed");
        return LV_RESULT_INVALID;
 8020970:	2300      	movs	r3, #0
 8020972:	e043      	b.n	80209fc <decode_compressed+0x1e6>
    }

    /*Depends on the cf, need to further decode image like an C-array image*/
    lv_image_dsc_t * image = (lv_image_dsc_t *)dsc->src;
 8020974:	683b      	ldr	r3, [r7, #0]
 8020976:	689b      	ldr	r3, [r3, #8]
 8020978:	61bb      	str	r3, [r7, #24]
    if(image->data == NULL) {
 802097a:	69bb      	ldr	r3, [r7, #24]
 802097c:	691b      	ldr	r3, [r3, #16]
 802097e:	2b00      	cmp	r3, #0
 8020980:	d101      	bne.n	8020986 <decode_compressed+0x170>
        return LV_RESULT_INVALID;
 8020982:	2300      	movs	r3, #0
 8020984:	e03a      	b.n	80209fc <decode_compressed+0x1e6>
    }

    lv_color_format_t cf = dsc->header.cf;
 8020986:	683b      	ldr	r3, [r7, #0]
 8020988:	7c5b      	ldrb	r3, [r3, #17]
 802098a:	75fb      	strb	r3, [r7, #23]
    if(LV_COLOR_FORMAT_IS_INDEXED(cf)) {
 802098c:	7dfb      	ldrb	r3, [r7, #23]
 802098e:	2b06      	cmp	r3, #6
 8020990:	d916      	bls.n	80209c0 <decode_compressed+0x1aa>
 8020992:	7dfb      	ldrb	r3, [r7, #23]
 8020994:	2b0a      	cmp	r3, #10
 8020996:	d813      	bhi.n	80209c0 <decode_compressed+0x1aa>
        if(dsc->args.use_indexed) res = load_indexed(decoder, dsc);
 8020998:	683b      	ldr	r3, [r7, #0]
 802099a:	79db      	ldrb	r3, [r3, #7]
 802099c:	2b00      	cmp	r3, #0
 802099e:	d007      	beq.n	80209b0 <decode_compressed+0x19a>
 80209a0:	6839      	ldr	r1, [r7, #0]
 80209a2:	6878      	ldr	r0, [r7, #4]
 80209a4:	f7ff fe2f 	bl	8020606 <load_indexed>
 80209a8:	4603      	mov	r3, r0
 80209aa:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
 80209ae:	e023      	b.n	80209f8 <decode_compressed+0x1e2>
        else res = decode_indexed(decoder, dsc);
 80209b0:	6839      	ldr	r1, [r7, #0]
 80209b2:	6878      	ldr	r0, [r7, #4]
 80209b4:	f7ff fd7c 	bl	80204b0 <decode_indexed>
 80209b8:	4603      	mov	r3, r0
 80209ba:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
        if(dsc->args.use_indexed) res = load_indexed(decoder, dsc);
 80209be:	e01b      	b.n	80209f8 <decode_compressed+0x1e2>
    }
    else if(LV_COLOR_FORMAT_IS_ALPHA_ONLY(cf)) {
 80209c0:	7dfb      	ldrb	r3, [r7, #23]
 80209c2:	2b0a      	cmp	r3, #10
 80209c4:	d90a      	bls.n	80209dc <decode_compressed+0x1c6>
 80209c6:	7dfb      	ldrb	r3, [r7, #23]
 80209c8:	2b0e      	cmp	r3, #14
 80209ca:	d807      	bhi.n	80209dc <decode_compressed+0x1c6>
        res = decode_alpha_only(decoder, dsc);
 80209cc:	6839      	ldr	r1, [r7, #0]
 80209ce:	6878      	ldr	r0, [r7, #4]
 80209d0:	f7ff fe51 	bl	8020676 <decode_alpha_only>
 80209d4:	4603      	mov	r3, r0
 80209d6:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
 80209da:	e00d      	b.n	80209f8 <decode_compressed+0x1e2>
    }
    else {
        /*The decompressed data is the original image data.*/
        dsc->decoded = decoder_data->decompressed;
 80209dc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80209de:	6a1a      	ldr	r2, [r3, #32]
 80209e0:	683b      	ldr	r3, [r7, #0]
 80209e2:	61da      	str	r2, [r3, #28]

        /*Transfer ownership of decompressed to `decoded` since it can be used directly*/
        decoder_data->decoded = decoder_data->decompressed;
 80209e4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80209e6:	6a1a      	ldr	r2, [r3, #32]
 80209e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80209ea:	61da      	str	r2, [r3, #28]
        decoder_data->decompressed = NULL;
 80209ec:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80209ee:	2200      	movs	r2, #0
 80209f0:	621a      	str	r2, [r3, #32]
        res = LV_RESULT_OK;
 80209f2:	2301      	movs	r3, #1
 80209f4:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
    }

    return res;
 80209f8:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
}
 80209fc:	4618      	mov	r0, r3
 80209fe:	3738      	adds	r7, #56	@ 0x38
 8020a00:	46bd      	mov	sp, r7
 8020a02:	bd80      	pop	{r7, pc}

08020a04 <decode_indexed_line>:

static lv_result_t decode_indexed_line(lv_color_format_t color_format, const lv_color32_t * palette, int32_t x,
                                       int32_t w_px, const uint8_t * in, lv_color32_t * out)
{
 8020a04:	b480      	push	{r7}
 8020a06:	b089      	sub	sp, #36	@ 0x24
 8020a08:	af00      	add	r7, sp, #0
 8020a0a:	60b9      	str	r1, [r7, #8]
 8020a0c:	607a      	str	r2, [r7, #4]
 8020a0e:	603b      	str	r3, [r7, #0]
 8020a10:	4603      	mov	r3, r0
 8020a12:	73fb      	strb	r3, [r7, #15]
    uint8_t px_size;
    uint16_t mask;

    int8_t shift   = 0;
 8020a14:	2300      	movs	r3, #0
 8020a16:	77bb      	strb	r3, [r7, #30]
    switch(color_format) {
 8020a18:	7bfb      	ldrb	r3, [r7, #15]
 8020a1a:	3b07      	subs	r3, #7
 8020a1c:	2b03      	cmp	r3, #3
 8020a1e:	d850      	bhi.n	8020ac2 <decode_indexed_line+0xbe>
 8020a20:	a201      	add	r2, pc, #4	@ (adr r2, 8020a28 <decode_indexed_line+0x24>)
 8020a22:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8020a26:	bf00      	nop
 8020a28:	08020a39 	.word	0x08020a39
 8020a2c:	08020a5f 	.word	0x08020a5f
 8020a30:	08020a89 	.word	0x08020a89
 8020a34:	08020ab1 	.word	0x08020ab1
        case LV_COLOR_FORMAT_I1:
            px_size = 1;
 8020a38:	2301      	movs	r3, #1
 8020a3a:	77fb      	strb	r3, [r7, #31]
            in += x / 8;                /*8pixel per byte*/
 8020a3c:	687b      	ldr	r3, [r7, #4]
 8020a3e:	2b00      	cmp	r3, #0
 8020a40:	da00      	bge.n	8020a44 <decode_indexed_line+0x40>
 8020a42:	3307      	adds	r3, #7
 8020a44:	10db      	asrs	r3, r3, #3
 8020a46:	461a      	mov	r2, r3
 8020a48:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020a4a:	4413      	add	r3, r2
 8020a4c:	62bb      	str	r3, [r7, #40]	@ 0x28
            shift = 7 - (x & 0x7);
 8020a4e:	687b      	ldr	r3, [r7, #4]
 8020a50:	b25b      	sxtb	r3, r3
 8020a52:	43db      	mvns	r3, r3
 8020a54:	b25b      	sxtb	r3, r3
 8020a56:	f003 0307 	and.w	r3, r3, #7
 8020a5a:	77bb      	strb	r3, [r7, #30]
            break;
 8020a5c:	e033      	b.n	8020ac6 <decode_indexed_line+0xc2>
        case LV_COLOR_FORMAT_I2:
            px_size = 2;
 8020a5e:	2302      	movs	r3, #2
 8020a60:	77fb      	strb	r3, [r7, #31]
            in += x / 4;                /*4pixel per byte*/
 8020a62:	687b      	ldr	r3, [r7, #4]
 8020a64:	2b00      	cmp	r3, #0
 8020a66:	da00      	bge.n	8020a6a <decode_indexed_line+0x66>
 8020a68:	3303      	adds	r3, #3
 8020a6a:	109b      	asrs	r3, r3, #2
 8020a6c:	461a      	mov	r2, r3
 8020a6e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020a70:	4413      	add	r3, r2
 8020a72:	62bb      	str	r3, [r7, #40]	@ 0x28
            shift = 6 - 2 * (x & 0x3);
 8020a74:	687b      	ldr	r3, [r7, #4]
 8020a76:	43db      	mvns	r3, r3
 8020a78:	b2db      	uxtb	r3, r3
 8020a7a:	f003 0303 	and.w	r3, r3, #3
 8020a7e:	b2db      	uxtb	r3, r3
 8020a80:	005b      	lsls	r3, r3, #1
 8020a82:	b2db      	uxtb	r3, r3
 8020a84:	77bb      	strb	r3, [r7, #30]
            break;
 8020a86:	e01e      	b.n	8020ac6 <decode_indexed_line+0xc2>
        case LV_COLOR_FORMAT_I4:
            px_size = 4;
 8020a88:	2304      	movs	r3, #4
 8020a8a:	77fb      	strb	r3, [r7, #31]
            in += x / 2;                /*2pixel per byte*/
 8020a8c:	687b      	ldr	r3, [r7, #4]
 8020a8e:	0fda      	lsrs	r2, r3, #31
 8020a90:	4413      	add	r3, r2
 8020a92:	105b      	asrs	r3, r3, #1
 8020a94:	461a      	mov	r2, r3
 8020a96:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020a98:	4413      	add	r3, r2
 8020a9a:	62bb      	str	r3, [r7, #40]	@ 0x28
            shift = 4 - 4 * (x & 0x1);
 8020a9c:	687b      	ldr	r3, [r7, #4]
 8020a9e:	f003 0301 	and.w	r3, r3, #1
 8020aa2:	2b00      	cmp	r3, #0
 8020aa4:	d101      	bne.n	8020aaa <decode_indexed_line+0xa6>
 8020aa6:	2304      	movs	r3, #4
 8020aa8:	e000      	b.n	8020aac <decode_indexed_line+0xa8>
 8020aaa:	2300      	movs	r3, #0
 8020aac:	77bb      	strb	r3, [r7, #30]
            break;
 8020aae:	e00a      	b.n	8020ac6 <decode_indexed_line+0xc2>
        case LV_COLOR_FORMAT_I8:
            px_size = 8;
 8020ab0:	2308      	movs	r3, #8
 8020ab2:	77fb      	strb	r3, [r7, #31]
            in += x;
 8020ab4:	687b      	ldr	r3, [r7, #4]
 8020ab6:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8020ab8:	4413      	add	r3, r2
 8020aba:	62bb      	str	r3, [r7, #40]	@ 0x28
            shift = 0;
 8020abc:	2300      	movs	r3, #0
 8020abe:	77bb      	strb	r3, [r7, #30]
            break;
 8020ac0:	e001      	b.n	8020ac6 <decode_indexed_line+0xc2>
        default:
            return LV_RESULT_INVALID;
 8020ac2:	2300      	movs	r3, #0
 8020ac4:	e03b      	b.n	8020b3e <decode_indexed_line+0x13a>
    }

    mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
 8020ac6:	7ffb      	ldrb	r3, [r7, #31]
 8020ac8:	2201      	movs	r2, #1
 8020aca:	fa02 f303 	lsl.w	r3, r2, r3
 8020ace:	b29b      	uxth	r3, r3
 8020ad0:	3b01      	subs	r3, #1
 8020ad2:	82fb      	strh	r3, [r7, #22]

    int32_t i;
    for(i = 0; i < w_px; i++) {
 8020ad4:	2300      	movs	r3, #0
 8020ad6:	61bb      	str	r3, [r7, #24]
 8020ad8:	e02c      	b.n	8020b34 <decode_indexed_line+0x130>
        uint8_t val_act = (*in >> shift) & mask;
 8020ada:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020adc:	781b      	ldrb	r3, [r3, #0]
 8020ade:	461a      	mov	r2, r3
 8020ae0:	f997 301e 	ldrsb.w	r3, [r7, #30]
 8020ae4:	fa42 f303 	asr.w	r3, r2, r3
 8020ae8:	b25a      	sxtb	r2, r3
 8020aea:	8afb      	ldrh	r3, [r7, #22]
 8020aec:	b25b      	sxtb	r3, r3
 8020aee:	4013      	ands	r3, r2
 8020af0:	b25b      	sxtb	r3, r3
 8020af2:	757b      	strb	r3, [r7, #21]
        out[i] = palette[val_act];
 8020af4:	7d7b      	ldrb	r3, [r7, #21]
 8020af6:	009b      	lsls	r3, r3, #2
 8020af8:	68ba      	ldr	r2, [r7, #8]
 8020afa:	18d1      	adds	r1, r2, r3
 8020afc:	69bb      	ldr	r3, [r7, #24]
 8020afe:	009b      	lsls	r3, r3, #2
 8020b00:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8020b02:	4413      	add	r3, r2
 8020b04:	461a      	mov	r2, r3
 8020b06:	460b      	mov	r3, r1
 8020b08:	681b      	ldr	r3, [r3, #0]
 8020b0a:	6013      	str	r3, [r2, #0]

        shift -= px_size;
 8020b0c:	7fba      	ldrb	r2, [r7, #30]
 8020b0e:	7ffb      	ldrb	r3, [r7, #31]
 8020b10:	1ad3      	subs	r3, r2, r3
 8020b12:	b2db      	uxtb	r3, r3
 8020b14:	77bb      	strb	r3, [r7, #30]
        if(shift < 0) {
 8020b16:	f997 301e 	ldrsb.w	r3, [r7, #30]
 8020b1a:	2b00      	cmp	r3, #0
 8020b1c:	da07      	bge.n	8020b2e <decode_indexed_line+0x12a>
            shift = 8 - px_size;
 8020b1e:	7ffb      	ldrb	r3, [r7, #31]
 8020b20:	f1c3 0308 	rsb	r3, r3, #8
 8020b24:	b2db      	uxtb	r3, r3
 8020b26:	77bb      	strb	r3, [r7, #30]
            in++;
 8020b28:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8020b2a:	3301      	adds	r3, #1
 8020b2c:	62bb      	str	r3, [r7, #40]	@ 0x28
    for(i = 0; i < w_px; i++) {
 8020b2e:	69bb      	ldr	r3, [r7, #24]
 8020b30:	3301      	adds	r3, #1
 8020b32:	61bb      	str	r3, [r7, #24]
 8020b34:	69ba      	ldr	r2, [r7, #24]
 8020b36:	683b      	ldr	r3, [r7, #0]
 8020b38:	429a      	cmp	r2, r3
 8020b3a:	dbce      	blt.n	8020ada <decode_indexed_line+0xd6>
        }
    }
    return LV_RESULT_OK;
 8020b3c:	2301      	movs	r3, #1
}
 8020b3e:	4618      	mov	r0, r3
 8020b40:	3724      	adds	r7, #36	@ 0x24
 8020b42:	46bd      	mov	sp, r7
 8020b44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b48:	4770      	bx	lr
 8020b4a:	bf00      	nop

08020b4c <fs_read_file_at>:

static lv_fs_res_t fs_read_file_at(lv_fs_file_t * f, uint32_t pos, void * buff, uint32_t btr, uint32_t * br)
{
 8020b4c:	b580      	push	{r7, lr}
 8020b4e:	b086      	sub	sp, #24
 8020b50:	af00      	add	r7, sp, #0
 8020b52:	60f8      	str	r0, [r7, #12]
 8020b54:	60b9      	str	r1, [r7, #8]
 8020b56:	607a      	str	r2, [r7, #4]
 8020b58:	603b      	str	r3, [r7, #0]
    lv_fs_res_t res;
    if(br) *br = 0;
 8020b5a:	6a3b      	ldr	r3, [r7, #32]
 8020b5c:	2b00      	cmp	r3, #0
 8020b5e:	d002      	beq.n	8020b66 <fs_read_file_at+0x1a>
 8020b60:	6a3b      	ldr	r3, [r7, #32]
 8020b62:	2200      	movs	r2, #0
 8020b64:	601a      	str	r2, [r3, #0]

    res = lv_fs_seek(f, pos, LV_FS_SEEK_SET);
 8020b66:	2200      	movs	r2, #0
 8020b68:	68b9      	ldr	r1, [r7, #8]
 8020b6a:	68f8      	ldr	r0, [r7, #12]
 8020b6c:	f002 f90b 	bl	8022d86 <lv_fs_seek>
 8020b70:	4603      	mov	r3, r0
 8020b72:	75fb      	strb	r3, [r7, #23]
    if(res != LV_FS_RES_OK) {
 8020b74:	7dfb      	ldrb	r3, [r7, #23]
 8020b76:	2b00      	cmp	r3, #0
 8020b78:	d001      	beq.n	8020b7e <fs_read_file_at+0x32>
        return res;
 8020b7a:	7dfb      	ldrb	r3, [r7, #23]
 8020b7c:	e010      	b.n	8020ba0 <fs_read_file_at+0x54>
    }

    res |= lv_fs_read(f, buff, btr, br);
 8020b7e:	6a3b      	ldr	r3, [r7, #32]
 8020b80:	683a      	ldr	r2, [r7, #0]
 8020b82:	6879      	ldr	r1, [r7, #4]
 8020b84:	68f8      	ldr	r0, [r7, #12]
 8020b86:	f002 f8b9 	bl	8022cfc <lv_fs_read>
 8020b8a:	4603      	mov	r3, r0
 8020b8c:	461a      	mov	r2, r3
 8020b8e:	7dfb      	ldrb	r3, [r7, #23]
 8020b90:	4313      	orrs	r3, r2
 8020b92:	75fb      	strb	r3, [r7, #23]
    if(res != LV_FS_RES_OK) {
 8020b94:	7dfb      	ldrb	r3, [r7, #23]
 8020b96:	2b00      	cmp	r3, #0
 8020b98:	d001      	beq.n	8020b9e <fs_read_file_at+0x52>
        return res;
 8020b9a:	7dfb      	ldrb	r3, [r7, #23]
 8020b9c:	e000      	b.n	8020ba0 <fs_read_file_at+0x54>
    }

    return LV_FS_RES_OK;
 8020b9e:	2300      	movs	r3, #0
}
 8020ba0:	4618      	mov	r0, r3
 8020ba2:	3718      	adds	r7, #24
 8020ba4:	46bd      	mov	sp, r7
 8020ba6:	bd80      	pop	{r7, pc}

08020ba8 <decompress_image>:

static lv_result_t decompress_image(lv_image_decoder_dsc_t * dsc, const lv_image_compressed_t * compressed)
{
 8020ba8:	b580      	push	{r7, lr}
 8020baa:	b088      	sub	sp, #32
 8020bac:	af00      	add	r7, sp, #0
 8020bae:	6078      	str	r0, [r7, #4]
 8020bb0:	6039      	str	r1, [r7, #0]
    /*Need to store decompressed data to decoder to free on close*/
    decoder_data_t * decoder_data = get_decoder_data(dsc);
 8020bb2:	6878      	ldr	r0, [r7, #4]
 8020bb4:	f7ff fc22 	bl	80203fc <get_decoder_data>
 8020bb8:	61f8      	str	r0, [r7, #28]
    if(decoder_data == NULL) {
 8020bba:	69fb      	ldr	r3, [r7, #28]
 8020bbc:	2b00      	cmp	r3, #0
 8020bbe:	d101      	bne.n	8020bc4 <decompress_image+0x1c>
        return LV_RESULT_INVALID;
 8020bc0:	2300      	movs	r3, #0
 8020bc2:	e036      	b.n	8020c32 <decompress_image+0x8a>
    }

    uint8_t * img_data;
    uint32_t out_len = compressed->decompressed_size;
 8020bc4:	683b      	ldr	r3, [r7, #0]
 8020bc6:	689b      	ldr	r3, [r3, #8]
 8020bc8:	61bb      	str	r3, [r7, #24]
    uint32_t input_len = compressed->compressed_size;
 8020bca:	683b      	ldr	r3, [r7, #0]
 8020bcc:	685b      	ldr	r3, [r3, #4]
 8020bce:	617b      	str	r3, [r7, #20]
    LV_UNUSED(input_len);
    LV_UNUSED(out_len);

    lv_draw_buf_t * decompressed = lv_draw_buf_create(dsc->header.w, dsc->header.h, dsc->header.cf,
 8020bd0:	687b      	ldr	r3, [r7, #4]
 8020bd2:	8a9b      	ldrh	r3, [r3, #20]
 8020bd4:	4618      	mov	r0, r3
 8020bd6:	687b      	ldr	r3, [r7, #4]
 8020bd8:	8adb      	ldrh	r3, [r3, #22]
 8020bda:	4619      	mov	r1, r3
 8020bdc:	687b      	ldr	r3, [r7, #4]
 8020bde:	7c5a      	ldrb	r2, [r3, #17]
                                                      dsc->header.stride);
 8020be0:	687b      	ldr	r3, [r7, #4]
 8020be2:	8b1b      	ldrh	r3, [r3, #24]
    lv_draw_buf_t * decompressed = lv_draw_buf_create(dsc->header.w, dsc->header.h, dsc->header.cf,
 8020be4:	f7eb f910 	bl	800be08 <lv_draw_buf_create>
 8020be8:	6138      	str	r0, [r7, #16]
    if(decompressed == NULL) {
 8020bea:	693b      	ldr	r3, [r7, #16]
 8020bec:	2b00      	cmp	r3, #0
 8020bee:	d101      	bne.n	8020bf4 <decompress_image+0x4c>
        LV_LOG_WARN("No memory for decompressed image, input: %" LV_PRIu32 ", output: %" LV_PRIu32, input_len, out_len);
        return LV_RESULT_INVALID;
 8020bf0:	2300      	movs	r3, #0
 8020bf2:	e01e      	b.n	8020c32 <decompress_image+0x8a>
    }

    img_data = decompressed->data;
 8020bf4:	693b      	ldr	r3, [r7, #16]
 8020bf6:	691b      	ldr	r3, [r3, #16]
 8020bf8:	60fb      	str	r3, [r7, #12]

    if(compressed->method == LV_IMAGE_COMPRESS_RLE) {
 8020bfa:	683b      	ldr	r3, [r7, #0]
 8020bfc:	781b      	ldrb	r3, [r3, #0]
 8020bfe:	f003 030f 	and.w	r3, r3, #15
 8020c02:	b2db      	uxtb	r3, r3
 8020c04:	2b01      	cmp	r3, #1
 8020c06:	d104      	bne.n	8020c12 <decompress_image+0x6a>
            lv_draw_buf_destroy(decompressed);
            return LV_RESULT_INVALID;
        }
#else
        LV_LOG_WARN("RLE decompress is not enabled");
        lv_draw_buf_destroy(decompressed);
 8020c08:	6938      	ldr	r0, [r7, #16]
 8020c0a:	f7eb f9cf 	bl	800bfac <lv_draw_buf_destroy>
        return LV_RESULT_INVALID;
 8020c0e:	2300      	movs	r3, #0
 8020c10:	e00f      	b.n	8020c32 <decompress_image+0x8a>
#endif
    }
    else if(compressed->method == LV_IMAGE_COMPRESS_LZ4) {
 8020c12:	683b      	ldr	r3, [r7, #0]
 8020c14:	781b      	ldrb	r3, [r3, #0]
 8020c16:	f003 030f 	and.w	r3, r3, #15
 8020c1a:	b2db      	uxtb	r3, r3
 8020c1c:	2b02      	cmp	r3, #2
 8020c1e:	d104      	bne.n	8020c2a <decompress_image+0x82>
            lv_draw_buf_destroy(decompressed);
            return LV_RESULT_INVALID;
        }
#else
        LV_LOG_WARN("LZ4 decompress is not enabled");
        lv_draw_buf_destroy(decompressed);
 8020c20:	6938      	ldr	r0, [r7, #16]
 8020c22:	f7eb f9c3 	bl	800bfac <lv_draw_buf_destroy>
        return LV_RESULT_INVALID;
 8020c26:	2300      	movs	r3, #0
 8020c28:	e003      	b.n	8020c32 <decompress_image+0x8a>
#endif
    }
    else {
        LV_UNUSED(img_data);
        LV_LOG_WARN("Unknown compression method: %d", compressed->method);
        lv_draw_buf_destroy(decompressed);
 8020c2a:	6938      	ldr	r0, [r7, #16]
 8020c2c:	f7eb f9be 	bl	800bfac <lv_draw_buf_destroy>
        return LV_RESULT_INVALID;
 8020c30:	2300      	movs	r3, #0
    }

    decoder_data->decompressed = decompressed; /*Free on decoder close*/
    return LV_RESULT_OK;
}
 8020c32:	4618      	mov	r0, r3
 8020c34:	3720      	adds	r7, #32
 8020c36:	46bd      	mov	sp, r7
 8020c38:	bd80      	pop	{r7, pc}

08020c3a <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 8020c3a:	b580      	push	{r7, lr}
 8020c3c:	b082      	sub	sp, #8
 8020c3e:	af00      	add	r7, sp, #0
 8020c40:	6078      	str	r0, [r7, #4]
 8020c42:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 8020c44:	683a      	ldr	r2, [r7, #0]
 8020c46:	2100      	movs	r1, #0
 8020c48:	6878      	ldr	r0, [r7, #4]
 8020c4a:	f004 f8ea 	bl	8024e22 <lv_memset>
}
 8020c4e:	bf00      	nop
 8020c50:	3708      	adds	r7, #8
 8020c52:	46bd      	mov	sp, r7
 8020c54:	bd80      	pop	{r7, pc}
	...

08020c58 <lv_global_init>:

/**********************
 *   GLOBAL FUNCTIONS
 **********************/
static inline void lv_global_init(lv_global_t * global)
{
 8020c58:	b580      	push	{r7, lr}
 8020c5a:	b082      	sub	sp, #8
 8020c5c:	af00      	add	r7, sp, #0
 8020c5e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_NULL(global);
 8020c60:	687b      	ldr	r3, [r7, #4]
 8020c62:	2b00      	cmp	r3, #0
 8020c64:	d101      	bne.n	8020c6a <lv_global_init+0x12>
 8020c66:	bf00      	nop
 8020c68:	e7fd      	b.n	8020c66 <lv_global_init+0xe>

    if(global == NULL) {
 8020c6a:	687b      	ldr	r3, [r7, #4]
 8020c6c:	2b00      	cmp	r3, #0
 8020c6e:	d029      	beq.n	8020cc4 <lv_global_init+0x6c>
        LV_LOG_ERROR("lv_global cannot be null");
        return;
    }

    lv_memzero(global, sizeof(lv_global_t));
 8020c70:	f44f 71d8 	mov.w	r1, #432	@ 0x1b0
 8020c74:	6878      	ldr	r0, [r7, #4]
 8020c76:	f7ff ffe0 	bl	8020c3a <lv_memzero>

    _lv_ll_init(&(global->disp_ll), sizeof(lv_display_t));
 8020c7a:	687b      	ldr	r3, [r7, #4]
 8020c7c:	3304      	adds	r3, #4
 8020c7e:	f44f 7142 	mov.w	r1, #776	@ 0x308
 8020c82:	4618      	mov	r0, r3
 8020c84:	f002 f9c5 	bl	8023012 <_lv_ll_init>
    _lv_ll_init(&(global->indev_ll), sizeof(lv_indev_t));
 8020c88:	687b      	ldr	r3, [r7, #4]
 8020c8a:	3344      	adds	r3, #68	@ 0x44
 8020c8c:	21b8      	movs	r1, #184	@ 0xb8
 8020c8e:	4618      	mov	r0, r3
 8020c90:	f002 f9bf 	bl	8023012 <_lv_ll_init>

    global->memory_zero = ZERO_MEM_SENTINEL;
 8020c94:	687b      	ldr	r3, [r7, #4]
 8020c96:	4a0d      	ldr	r2, [pc, #52]	@ (8020ccc <lv_global_init+0x74>)
 8020c98:	665a      	str	r2, [r3, #100]	@ 0x64
    global->style_refresh = true;
 8020c9a:	687b      	ldr	r3, [r7, #4]
 8020c9c:	2201      	movs	r2, #1
 8020c9e:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
    global->layout_count = _LV_LAYOUT_LAST;
 8020ca2:	687b      	ldr	r3, [r7, #4]
 8020ca4:	2203      	movs	r2, #3
 8020ca6:	659a      	str	r2, [r3, #88]	@ 0x58
    global->style_last_custom_prop_id = (uint32_t)_LV_STYLE_LAST_BUILT_IN_PROP;
 8020ca8:	687b      	ldr	r3, [r7, #4]
 8020caa:	228c      	movs	r2, #140	@ 0x8c
 8020cac:	62da      	str	r2, [r3, #44]	@ 0x2c
    global->area_trans_cache.angle_prev = INT32_MIN;
 8020cae:	687b      	ldr	r3, [r7, #4]
 8020cb0:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
 8020cb4:	66da      	str	r2, [r3, #108]	@ 0x6c
    global->event_last_register_id = _LV_EVENT_LAST;
 8020cb6:	687b      	ldr	r3, [r7, #4]
 8020cb8:	223c      	movs	r2, #60	@ 0x3c
 8020cba:	67da      	str	r2, [r3, #124]	@ 0x7c
    lv_rand_set_seed(0x1234ABCD);
 8020cbc:	4804      	ldr	r0, [pc, #16]	@ (8020cd0 <lv_global_init+0x78>)
 8020cbe:	f002 fce3 	bl	8023688 <lv_rand_set_seed>
 8020cc2:	e000      	b.n	8020cc6 <lv_global_init+0x6e>
        return;
 8020cc4:	bf00      	nop

#if defined(LV_DRAW_SW_SHADOW_CACHE_SIZE) && LV_DRAW_SW_SHADOW_CACHE_SIZE > 0
    global->sw_shadow_cache.cache_size = -1;
    global->sw_shadow_cache.cache_r = -1;
#endif
}
 8020cc6:	3708      	adds	r7, #8
 8020cc8:	46bd      	mov	sp, r7
 8020cca:	bd80      	pop	{r7, pc}
 8020ccc:	a1b2c3d4 	.word	0xa1b2c3d4
 8020cd0:	1234abcd 	.word	0x1234abcd

08020cd4 <lv_init>:
    return lv_initialized;
#endif
}

void lv_init(void)
{
 8020cd4:	b580      	push	{r7, lr}
 8020cd6:	b086      	sub	sp, #24
 8020cd8:	af00      	add	r7, sp, #0
#ifdef LV_GC_INIT
    LV_GC_INIT();
#endif

    /*Do nothing if already initialized*/
    if(lv_initialized) {
 8020cda:	4b23      	ldr	r3, [pc, #140]	@ (8020d68 <lv_init+0x94>)
 8020cdc:	781b      	ldrb	r3, [r3, #0]
 8020cde:	2b00      	cmp	r3, #0
 8020ce0:	d13e      	bne.n	8020d60 <lv_init+0x8c>
    }

    LV_LOG_INFO("begin");

    /*Initialize members of static variable lv_global */
    LV_GLOBAL_INIT(LV_GLOBAL_DEFAULT());
 8020ce2:	4821      	ldr	r0, [pc, #132]	@ (8020d68 <lv_init+0x94>)
 8020ce4:	f7ff ffb8 	bl	8020c58 <lv_global_init>

    lv_mem_init();
 8020ce8:	f003 fdc0 	bl	802486c <lv_mem_init>

    _lv_draw_buf_init_handlers();
 8020cec:	f7ea ff42 	bl	800bb74 <_lv_draw_buf_init_handlers>

#if LV_USE_SPAN != 0
    lv_span_stack_init();
 8020cf0:	f006 fede 	bl	8027ab0 <lv_span_stack_init>
    lv_profiler_builtin_config_t profiler_config;
    lv_profiler_builtin_config_init(&profiler_config);
    lv_profiler_builtin_init(&profiler_config);
#endif

    _lv_timer_core_init();
 8020cf4:	f003 fcb4 	bl	8024660 <_lv_timer_core_init>

    _lv_fs_init();
 8020cf8:	f001 fdec 	bl	80228d4 <_lv_fs_init>

    _lv_layout_init();
 8020cfc:	f7fe fee6 	bl	801facc <_lv_layout_init>

    _lv_anim_core_init();
 8020d00:	f000 f8f8 	bl	8020ef4 <_lv_anim_core_init>

    _lv_group_init();
 8020d04:	f7e1 fa7e 	bl	8002204 <_lv_group_init>

    lv_draw_init();
 8020d08:	f7ea fb8a 	bl	800b420 <lv_draw_init>

#if LV_USE_DRAW_SW
    lv_draw_sw_init();
 8020d0c:	f7f1 fd68 	bl	80127e0 <lv_draw_sw_init>

#if LV_USE_WINDOWS
    lv_windows_platform_init();
#endif

    _lv_obj_style_init();
 8020d10:	f7e8 f9f4 	bl	80090fc <_lv_obj_style_init>

    /*Initialize the screen refresh system*/
    _lv_refr_init();
 8020d14:	f7ea f902 	bl	800af1c <_lv_refr_init>

#if LV_USE_SYSMON
    _lv_sysmon_builtin_init();
#endif

    _lv_image_decoder_init();
 8020d18:	f7ed fbde 	bl	800e4d8 <_lv_image_decoder_init>
    lv_bin_decoder_init();  /*LVGL built-in binary image decoder*/
 8020d1c:	f7fe ff42 	bl	801fba4 <lv_bin_decoder_init>
#if LV_USE_DRAW_VG_LITE
    lv_draw_vg_lite_init();
#endif

    /*Test if the IDE has UTF-8 encoding*/
    const char * txt = "Á";
 8020d20:	4b12      	ldr	r3, [pc, #72]	@ (8020d6c <lv_init+0x98>)
 8020d22:	617b      	str	r3, [r7, #20]

    uint8_t * txt_u8 = (uint8_t *)txt;
 8020d24:	697b      	ldr	r3, [r7, #20]
 8020d26:	613b      	str	r3, [r7, #16]
    if(txt_u8[0] != 0xc3 || txt_u8[1] != 0x81 || txt_u8[2] != 0x00) {
 8020d28:	693b      	ldr	r3, [r7, #16]
 8020d2a:	781b      	ldrb	r3, [r3, #0]
 8020d2c:	2bc3      	cmp	r3, #195	@ 0xc3
 8020d2e:	d103      	bne.n	8020d38 <lv_init+0x64>
 8020d30:	693b      	ldr	r3, [r7, #16]
 8020d32:	3301      	adds	r3, #1
 8020d34:	781b      	ldrb	r3, [r3, #0]
 8020d36:	2b81      	cmp	r3, #129	@ 0x81
        LV_LOG_WARN("The strings have no UTF-8 encoding. Non-ASCII characters won't be displayed.");
    }

    uint32_t endianness_test = 0x11223344;
 8020d38:	4b0d      	ldr	r3, [pc, #52]	@ (8020d70 <lv_init+0x9c>)
 8020d3a:	607b      	str	r3, [r7, #4]
    uint8_t * endianness_test_p = (uint8_t *) &endianness_test;
 8020d3c:	1d3b      	adds	r3, r7, #4
 8020d3e:	60fb      	str	r3, [r7, #12]
    bool big_endian = endianness_test_p[0] == 0x11;
 8020d40:	68fb      	ldr	r3, [r7, #12]
 8020d42:	781b      	ldrb	r3, [r3, #0]
 8020d44:	2b11      	cmp	r3, #17
 8020d46:	bf0c      	ite	eq
 8020d48:	2301      	moveq	r3, #1
 8020d4a:	2300      	movne	r3, #0
 8020d4c:	72fb      	strb	r3, [r7, #11]

    if(big_endian) {
 8020d4e:	7afb      	ldrb	r3, [r7, #11]
 8020d50:	2b00      	cmp	r3, #0
 8020d52:	d001      	beq.n	8020d58 <lv_init+0x84>
        LV_ASSERT_MSG(LV_BIG_ENDIAN_SYSTEM == 1,
 8020d54:	bf00      	nop
 8020d56:	e7fd      	b.n	8020d54 <lv_init+0x80>

#if LV_USE_TINY_TTF
    lv_tiny_ttf_init();
#endif

    lv_initialized = true;
 8020d58:	4b03      	ldr	r3, [pc, #12]	@ (8020d68 <lv_init+0x94>)
 8020d5a:	2201      	movs	r2, #1
 8020d5c:	701a      	strb	r2, [r3, #0]
 8020d5e:	e000      	b.n	8020d62 <lv_init+0x8e>
        return;
 8020d60:	bf00      	nop

    LV_LOG_TRACE("finished");
}
 8020d62:	3718      	adds	r7, #24
 8020d64:	46bd      	mov	sp, r7
 8020d66:	bd80      	pop	{r7, pc}
 8020d68:	2000009c 	.word	0x2000009c
 8020d6c:	08027b98 	.word	0x08027b98
 8020d70:	11223344 	.word	0x11223344

08020d74 <lv_cache_release>:
    }
    lv_mutex_unlock(&cache->lock);
    return entry;
}
void lv_cache_release(lv_cache_t * cache, lv_cache_entry_t * entry, void * user_data)
{
 8020d74:	b590      	push	{r4, r7, lr}
 8020d76:	b085      	sub	sp, #20
 8020d78:	af00      	add	r7, sp, #0
 8020d7a:	60f8      	str	r0, [r7, #12]
 8020d7c:	60b9      	str	r1, [r7, #8]
 8020d7e:	607a      	str	r2, [r7, #4]
    LV_ASSERT_NULL(entry);
 8020d80:	68bb      	ldr	r3, [r7, #8]
 8020d82:	2b00      	cmp	r3, #0
 8020d84:	d101      	bne.n	8020d8a <lv_cache_release+0x16>
 8020d86:	bf00      	nop
 8020d88:	e7fd      	b.n	8020d86 <lv_cache_release+0x12>

    lv_mutex_lock(&cache->lock);
 8020d8a:	68fb      	ldr	r3, [r7, #12]
 8020d8c:	331c      	adds	r3, #28
 8020d8e:	4618      	mov	r0, r3
 8020d90:	f003 fd55 	bl	802483e <lv_mutex_lock>
    lv_cache_entry_release_data(entry, user_data);
 8020d94:	6879      	ldr	r1, [r7, #4]
 8020d96:	68b8      	ldr	r0, [r7, #8]
 8020d98:	f000 f872 	bl	8020e80 <lv_cache_entry_release_data>

    if(lv_cache_entry_get_ref(entry) == 0 && lv_cache_entry_is_invalid(entry)) {
 8020d9c:	68b8      	ldr	r0, [r7, #8]
 8020d9e:	f000 f839 	bl	8020e14 <lv_cache_entry_get_ref>
 8020da2:	4603      	mov	r3, r0
 8020da4:	2b00      	cmp	r3, #0
 8020da6:	d111      	bne.n	8020dcc <lv_cache_release+0x58>
 8020da8:	68b8      	ldr	r0, [r7, #8]
 8020daa:	f000 f844 	bl	8020e36 <lv_cache_entry_is_invalid>
 8020dae:	4603      	mov	r3, r0
 8020db0:	2b00      	cmp	r3, #0
 8020db2:	d00b      	beq.n	8020dcc <lv_cache_release+0x58>
        cache->ops.free_cb(lv_cache_entry_get_data(entry), user_data);
 8020db4:	68fb      	ldr	r3, [r7, #12]
 8020db6:	699c      	ldr	r4, [r3, #24]
 8020db8:	68b8      	ldr	r0, [r7, #8]
 8020dba:	f000 f84d 	bl	8020e58 <lv_cache_entry_get_data>
 8020dbe:	4603      	mov	r3, r0
 8020dc0:	6879      	ldr	r1, [r7, #4]
 8020dc2:	4618      	mov	r0, r3
 8020dc4:	47a0      	blx	r4
        lv_cache_entry_delete(entry);
 8020dc6:	68b8      	ldr	r0, [r7, #8]
 8020dc8:	f000 f872 	bl	8020eb0 <lv_cache_entry_delete>
    }
    lv_mutex_unlock(&cache->lock);
 8020dcc:	68fb      	ldr	r3, [r7, #12]
 8020dce:	331c      	adds	r3, #28
 8020dd0:	4618      	mov	r0, r3
 8020dd2:	f003 fd3f 	bl	8024854 <lv_mutex_unlock>
}
 8020dd6:	bf00      	nop
 8020dd8:	3714      	adds	r7, #20
 8020dda:	46bd      	mov	sp, r7
 8020ddc:	bd90      	pop	{r4, r7, pc}

08020dde <lv_cache_entry_dec_ref>:
{
    LV_ASSERT_NULL(entry);
    entry->ref_cnt++;
}
void lv_cache_entry_dec_ref(lv_cache_entry_t * entry)
{
 8020dde:	b480      	push	{r7}
 8020de0:	b083      	sub	sp, #12
 8020de2:	af00      	add	r7, sp, #0
 8020de4:	6078      	str	r0, [r7, #4]
    LV_ASSERT_NULL(entry);
 8020de6:	687b      	ldr	r3, [r7, #4]
 8020de8:	2b00      	cmp	r3, #0
 8020dea:	d101      	bne.n	8020df0 <lv_cache_entry_dec_ref+0x12>
 8020dec:	bf00      	nop
 8020dee:	e7fd      	b.n	8020dec <lv_cache_entry_dec_ref+0xe>
    entry->ref_cnt--;
 8020df0:	687b      	ldr	r3, [r7, #4]
 8020df2:	685b      	ldr	r3, [r3, #4]
 8020df4:	1e5a      	subs	r2, r3, #1
 8020df6:	687b      	ldr	r3, [r7, #4]
 8020df8:	605a      	str	r2, [r3, #4]
    if(entry->ref_cnt < 0) {
 8020dfa:	687b      	ldr	r3, [r7, #4]
 8020dfc:	685b      	ldr	r3, [r3, #4]
 8020dfe:	2b00      	cmp	r3, #0
 8020e00:	da02      	bge.n	8020e08 <lv_cache_entry_dec_ref+0x2a>
        LV_LOG_WARN("ref_cnt(%" LV_PRIu32 ") < 0", entry->ref_cnt);
        entry->ref_cnt = 0;
 8020e02:	687b      	ldr	r3, [r7, #4]
 8020e04:	2200      	movs	r2, #0
 8020e06:	605a      	str	r2, [r3, #4]
    }
}
 8020e08:	bf00      	nop
 8020e0a:	370c      	adds	r7, #12
 8020e0c:	46bd      	mov	sp, r7
 8020e0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e12:	4770      	bx	lr

08020e14 <lv_cache_entry_get_ref>:
int32_t lv_cache_entry_get_ref(lv_cache_entry_t * entry)
{
 8020e14:	b480      	push	{r7}
 8020e16:	b083      	sub	sp, #12
 8020e18:	af00      	add	r7, sp, #0
 8020e1a:	6078      	str	r0, [r7, #4]
    LV_ASSERT_NULL(entry);
 8020e1c:	687b      	ldr	r3, [r7, #4]
 8020e1e:	2b00      	cmp	r3, #0
 8020e20:	d101      	bne.n	8020e26 <lv_cache_entry_get_ref+0x12>
 8020e22:	bf00      	nop
 8020e24:	e7fd      	b.n	8020e22 <lv_cache_entry_get_ref+0xe>
    return entry->ref_cnt;
 8020e26:	687b      	ldr	r3, [r7, #4]
 8020e28:	685b      	ldr	r3, [r3, #4]
}
 8020e2a:	4618      	mov	r0, r3
 8020e2c:	370c      	adds	r7, #12
 8020e2e:	46bd      	mov	sp, r7
 8020e30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e34:	4770      	bx	lr

08020e36 <lv_cache_entry_is_invalid>:
{
    LV_ASSERT_NULL(entry);
    entry->is_invalid = is_invalid;
}
bool lv_cache_entry_is_invalid(lv_cache_entry_t * entry)
{
 8020e36:	b480      	push	{r7}
 8020e38:	b083      	sub	sp, #12
 8020e3a:	af00      	add	r7, sp, #0
 8020e3c:	6078      	str	r0, [r7, #4]
    LV_ASSERT_NULL(entry);
 8020e3e:	687b      	ldr	r3, [r7, #4]
 8020e40:	2b00      	cmp	r3, #0
 8020e42:	d101      	bne.n	8020e48 <lv_cache_entry_is_invalid+0x12>
 8020e44:	bf00      	nop
 8020e46:	e7fd      	b.n	8020e44 <lv_cache_entry_is_invalid+0xe>
    return entry->is_invalid;
 8020e48:	687b      	ldr	r3, [r7, #4]
 8020e4a:	7b1b      	ldrb	r3, [r3, #12]
}
 8020e4c:	4618      	mov	r0, r3
 8020e4e:	370c      	adds	r7, #12
 8020e50:	46bd      	mov	sp, r7
 8020e52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e56:	4770      	bx	lr

08020e58 <lv_cache_entry_get_data>:
void * lv_cache_entry_get_data(lv_cache_entry_t * entry)
{
 8020e58:	b480      	push	{r7}
 8020e5a:	b083      	sub	sp, #12
 8020e5c:	af00      	add	r7, sp, #0
 8020e5e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_NULL(entry);
 8020e60:	687b      	ldr	r3, [r7, #4]
 8020e62:	2b00      	cmp	r3, #0
 8020e64:	d101      	bne.n	8020e6a <lv_cache_entry_get_data+0x12>
 8020e66:	bf00      	nop
 8020e68:	e7fd      	b.n	8020e66 <lv_cache_entry_get_data+0xe>
    return (uint8_t *)entry - entry->node_size;
 8020e6a:	687b      	ldr	r3, [r7, #4]
 8020e6c:	689b      	ldr	r3, [r3, #8]
 8020e6e:	425b      	negs	r3, r3
 8020e70:	687a      	ldr	r2, [r7, #4]
 8020e72:	4413      	add	r3, r2
}
 8020e74:	4618      	mov	r0, r3
 8020e76:	370c      	adds	r7, #12
 8020e78:	46bd      	mov	sp, r7
 8020e7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e7e:	4770      	bx	lr

08020e80 <lv_cache_entry_release_data>:

    lv_cache_entry_inc_ref(entry);
    return lv_cache_entry_get_data(entry);
}
void lv_cache_entry_release_data(lv_cache_entry_t * entry, void * user_data)
{
 8020e80:	b580      	push	{r7, lr}
 8020e82:	b082      	sub	sp, #8
 8020e84:	af00      	add	r7, sp, #0
 8020e86:	6078      	str	r0, [r7, #4]
 8020e88:	6039      	str	r1, [r7, #0]
    LV_UNUSED(user_data);

    LV_ASSERT_NULL(entry);
 8020e8a:	687b      	ldr	r3, [r7, #4]
 8020e8c:	2b00      	cmp	r3, #0
 8020e8e:	d101      	bne.n	8020e94 <lv_cache_entry_release_data+0x14>
 8020e90:	bf00      	nop
 8020e92:	e7fd      	b.n	8020e90 <lv_cache_entry_release_data+0x10>
    if(lv_cache_entry_get_ref(entry) == 0) {
 8020e94:	6878      	ldr	r0, [r7, #4]
 8020e96:	f7ff ffbd 	bl	8020e14 <lv_cache_entry_get_ref>
 8020e9a:	4603      	mov	r3, r0
 8020e9c:	2b00      	cmp	r3, #0
 8020e9e:	d003      	beq.n	8020ea8 <lv_cache_entry_release_data+0x28>
        LV_LOG_ERROR("ref_cnt(%" LV_PRIu32 ") == 0", entry->ref_cnt);
        return;
    }

    lv_cache_entry_dec_ref(entry);
 8020ea0:	6878      	ldr	r0, [r7, #4]
 8020ea2:	f7ff ff9c 	bl	8020dde <lv_cache_entry_dec_ref>
 8020ea6:	e000      	b.n	8020eaa <lv_cache_entry_release_data+0x2a>
        return;
 8020ea8:	bf00      	nop
}
 8020eaa:	3708      	adds	r7, #8
 8020eac:	46bd      	mov	sp, r7
 8020eae:	bd80      	pop	{r7, pc}

08020eb0 <lv_cache_entry_delete>:
    entry->node_size = node_size;
    entry->ref_cnt = 0;
    entry->is_invalid = false;
}
void lv_cache_entry_delete(lv_cache_entry_t * entry)
{
 8020eb0:	b580      	push	{r7, lr}
 8020eb2:	b084      	sub	sp, #16
 8020eb4:	af00      	add	r7, sp, #0
 8020eb6:	6078      	str	r0, [r7, #4]
    LV_ASSERT_NULL(entry);
 8020eb8:	687b      	ldr	r3, [r7, #4]
 8020eba:	2b00      	cmp	r3, #0
 8020ebc:	d101      	bne.n	8020ec2 <lv_cache_entry_delete+0x12>
 8020ebe:	bf00      	nop
 8020ec0:	e7fd      	b.n	8020ebe <lv_cache_entry_delete+0xe>

    void * data = lv_cache_entry_get_data(entry);
 8020ec2:	6878      	ldr	r0, [r7, #4]
 8020ec4:	f7ff ffc8 	bl	8020e58 <lv_cache_entry_get_data>
 8020ec8:	60f8      	str	r0, [r7, #12]
    lv_free(data);
 8020eca:	68f8      	ldr	r0, [r7, #12]
 8020ecc:	f004 ffb4 	bl	8025e38 <lv_free>
}
 8020ed0:	bf00      	nop
 8020ed2:	3710      	adds	r7, #16
 8020ed4:	46bd      	mov	sp, r7
 8020ed6:	bd80      	pop	{r7, pc}

08020ed8 <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 8020ed8:	b580      	push	{r7, lr}
 8020eda:	b082      	sub	sp, #8
 8020edc:	af00      	add	r7, sp, #0
 8020ede:	6078      	str	r0, [r7, #4]
 8020ee0:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 8020ee2:	683a      	ldr	r2, [r7, #0]
 8020ee4:	2100      	movs	r1, #0
 8020ee6:	6878      	ldr	r0, [r7, #4]
 8020ee8:	f003 ff9b 	bl	8024e22 <lv_memset>
}
 8020eec:	bf00      	nop
 8020eee:	3708      	adds	r7, #8
 8020ef0:	46bd      	mov	sp, r7
 8020ef2:	bd80      	pop	{r7, pc}

08020ef4 <_lv_anim_core_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void _lv_anim_core_init(void)
{
 8020ef4:	b580      	push	{r7, lr}
 8020ef6:	af00      	add	r7, sp, #0
    _lv_ll_init(anim_ll_p, sizeof(lv_anim_t));
 8020ef8:	2158      	movs	r1, #88	@ 0x58
 8020efa:	480c      	ldr	r0, [pc, #48]	@ (8020f2c <_lv_anim_core_init+0x38>)
 8020efc:	f002 f889 	bl	8023012 <_lv_ll_init>
    state.timer = lv_timer_create(anim_timer, LV_DEF_REFR_PERIOD, NULL);
 8020f00:	2200      	movs	r2, #0
 8020f02:	2121      	movs	r1, #33	@ 0x21
 8020f04:	480a      	ldr	r0, [pc, #40]	@ (8020f30 <_lv_anim_core_init+0x3c>)
 8020f06:	f003 fbb9 	bl	802467c <lv_timer_create>
 8020f0a:	4603      	mov	r3, r0
 8020f0c:	4a09      	ldr	r2, [pc, #36]	@ (8020f34 <_lv_anim_core_init+0x40>)
 8020f0e:	f8c2 30b4 	str.w	r3, [r2, #180]	@ 0xb4
    anim_mark_list_change(); /*Turn off the animation timer*/
 8020f12:	f000 fb15 	bl	8021540 <anim_mark_list_change>
    state.anim_list_changed = false;
 8020f16:	4b07      	ldr	r3, [pc, #28]	@ (8020f34 <_lv_anim_core_init+0x40>)
 8020f18:	2200      	movs	r2, #0
 8020f1a:	f883 20b0 	strb.w	r2, [r3, #176]	@ 0xb0
    state.anim_run_round = false;
 8020f1e:	4b05      	ldr	r3, [pc, #20]	@ (8020f34 <_lv_anim_core_init+0x40>)
 8020f20:	2200      	movs	r2, #0
 8020f22:	f883 20b1 	strb.w	r2, [r3, #177]	@ 0xb1
}
 8020f26:	bf00      	nop
 8020f28:	bd80      	pop	{r7, pc}
 8020f2a:	bf00      	nop
 8020f2c:	20000154 	.word	0x20000154
 8020f30:	08021261 	.word	0x08021261
 8020f34:	2000009c 	.word	0x2000009c

08020f38 <lv_anim_init>:
{
    lv_anim_delete_all();
}

void lv_anim_init(lv_anim_t * a)
{
 8020f38:	b580      	push	{r7, lr}
 8020f3a:	b082      	sub	sp, #8
 8020f3c:	af00      	add	r7, sp, #0
 8020f3e:	6078      	str	r0, [r7, #4]
    lv_memzero(a, sizeof(lv_anim_t));
 8020f40:	2158      	movs	r1, #88	@ 0x58
 8020f42:	6878      	ldr	r0, [r7, #4]
 8020f44:	f7ff ffc8 	bl	8020ed8 <lv_memzero>
    a->duration = 500;
 8020f48:	687b      	ldr	r3, [r7, #4]
 8020f4a:	f44f 72fa 	mov.w	r2, #500	@ 0x1f4
 8020f4e:	631a      	str	r2, [r3, #48]	@ 0x30
    a->start_value = 0;
 8020f50:	687b      	ldr	r3, [r7, #4]
 8020f52:	2200      	movs	r2, #0
 8020f54:	625a      	str	r2, [r3, #36]	@ 0x24
    a->end_value = 100;
 8020f56:	687b      	ldr	r3, [r7, #4]
 8020f58:	2264      	movs	r2, #100	@ 0x64
 8020f5a:	62da      	str	r2, [r3, #44]	@ 0x2c
    a->repeat_cnt = 1;
 8020f5c:	687b      	ldr	r3, [r7, #4]
 8020f5e:	2201      	movs	r2, #1
 8020f60:	f8a3 2044 	strh.w	r2, [r3, #68]	@ 0x44
    a->path_cb = lv_anim_path_linear;
 8020f64:	687b      	ldr	r3, [r7, #4]
 8020f66:	4a06      	ldr	r2, [pc, #24]	@ (8020f80 <lv_anim_init+0x48>)
 8020f68:	621a      	str	r2, [r3, #32]
    a->early_apply = 1;
 8020f6a:	687a      	ldr	r2, [r7, #4]
 8020f6c:	f892 304e 	ldrb.w	r3, [r2, #78]	@ 0x4e
 8020f70:	f043 0301 	orr.w	r3, r3, #1
 8020f74:	f882 304e 	strb.w	r3, [r2, #78]	@ 0x4e
}
 8020f78:	bf00      	nop
 8020f7a:	3708      	adds	r7, #8
 8020f7c:	46bd      	mov	sp, r7
 8020f7e:	bd80      	pop	{r7, pc}
 8020f80:	080211ed 	.word	0x080211ed

08020f84 <lv_anim_start>:

lv_anim_t * lv_anim_start(const lv_anim_t * a)
{
 8020f84:	b580      	push	{r7, lr}
 8020f86:	b084      	sub	sp, #16
 8020f88:	af00      	add	r7, sp, #0
 8020f8a:	6078      	str	r0, [r7, #4]
    LV_TRACE_ANIM("begin");

    /*Add the new animation to the animation linked list*/
    lv_anim_t * new_anim = _lv_ll_ins_head(anim_ll_p);
 8020f8c:	4839      	ldr	r0, [pc, #228]	@ (8021074 <lv_anim_start+0xf0>)
 8020f8e:	f002 f859 	bl	8023044 <_lv_ll_ins_head>
 8020f92:	60f8      	str	r0, [r7, #12]
    LV_ASSERT_MALLOC(new_anim);
 8020f94:	68fb      	ldr	r3, [r7, #12]
 8020f96:	2b00      	cmp	r3, #0
 8020f98:	d101      	bne.n	8020f9e <lv_anim_start+0x1a>
 8020f9a:	bf00      	nop
 8020f9c:	e7fd      	b.n	8020f9a <lv_anim_start+0x16>
    if(new_anim == NULL) return NULL;
 8020f9e:	68fb      	ldr	r3, [r7, #12]
 8020fa0:	2b00      	cmp	r3, #0
 8020fa2:	d101      	bne.n	8020fa8 <lv_anim_start+0x24>
 8020fa4:	2300      	movs	r3, #0
 8020fa6:	e060      	b.n	802106a <lv_anim_start+0xe6>

    /*Initialize the animation descriptor*/
    lv_memcpy(new_anim, a, sizeof(lv_anim_t));
 8020fa8:	2258      	movs	r2, #88	@ 0x58
 8020faa:	6879      	ldr	r1, [r7, #4]
 8020fac:	68f8      	ldr	r0, [r7, #12]
 8020fae:	f003 fd1b 	bl	80249e8 <lv_memcpy>
    if(a->var == a) new_anim->var = new_anim;
 8020fb2:	687b      	ldr	r3, [r7, #4]
 8020fb4:	681b      	ldr	r3, [r3, #0]
 8020fb6:	687a      	ldr	r2, [r7, #4]
 8020fb8:	429a      	cmp	r2, r3
 8020fba:	d102      	bne.n	8020fc2 <lv_anim_start+0x3e>
 8020fbc:	68fb      	ldr	r3, [r7, #12]
 8020fbe:	68fa      	ldr	r2, [r7, #12]
 8020fc0:	601a      	str	r2, [r3, #0]
    new_anim->run_round = state.anim_run_round;
 8020fc2:	4b2d      	ldr	r3, [pc, #180]	@ (8021078 <lv_anim_start+0xf4>)
 8020fc4:	f893 10b1 	ldrb.w	r1, [r3, #177]	@ 0xb1
 8020fc8:	68fa      	ldr	r2, [r7, #12]
 8020fca:	f892 3054 	ldrb.w	r3, [r2, #84]	@ 0x54
 8020fce:	f361 0341 	bfi	r3, r1, #1, #1
 8020fd2:	f882 3054 	strb.w	r3, [r2, #84]	@ 0x54
    new_anim->last_timer_run = lv_tick_get();
 8020fd6:	f004 ffe5 	bl	8025fa4 <lv_tick_get>
 8020fda:	4602      	mov	r2, r0
 8020fdc:	68fb      	ldr	r3, [r7, #12]
 8020fde:	651a      	str	r2, [r3, #80]	@ 0x50

    /*Set the start value*/
    if(new_anim->early_apply) {
 8020fe0:	68fb      	ldr	r3, [r7, #12]
 8020fe2:	f893 304e 	ldrb.w	r3, [r3, #78]	@ 0x4e
 8020fe6:	f003 0301 	and.w	r3, r3, #1
 8020fea:	b2db      	uxtb	r3, r3
 8020fec:	2b00      	cmp	r3, #0
 8020fee:	d039      	beq.n	8021064 <lv_anim_start+0xe0>
        if(new_anim->get_value_cb) {
 8020ff0:	68fb      	ldr	r3, [r7, #12]
 8020ff2:	699b      	ldr	r3, [r3, #24]
 8020ff4:	2b00      	cmp	r3, #0
 8020ff6:	d010      	beq.n	802101a <lv_anim_start+0x96>
            int32_t v_ofs = new_anim->get_value_cb(new_anim);
 8020ff8:	68fb      	ldr	r3, [r7, #12]
 8020ffa:	699b      	ldr	r3, [r3, #24]
 8020ffc:	68f8      	ldr	r0, [r7, #12]
 8020ffe:	4798      	blx	r3
 8021000:	60b8      	str	r0, [r7, #8]
            new_anim->start_value += v_ofs;
 8021002:	68fb      	ldr	r3, [r7, #12]
 8021004:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8021006:	68bb      	ldr	r3, [r7, #8]
 8021008:	441a      	add	r2, r3
 802100a:	68fb      	ldr	r3, [r7, #12]
 802100c:	625a      	str	r2, [r3, #36]	@ 0x24
            new_anim->end_value += v_ofs;
 802100e:	68fb      	ldr	r3, [r7, #12]
 8021010:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8021012:	68bb      	ldr	r3, [r7, #8]
 8021014:	441a      	add	r2, r3
 8021016:	68fb      	ldr	r3, [r7, #12]
 8021018:	62da      	str	r2, [r3, #44]	@ 0x2c

        }

        resolve_time(new_anim);
 802101a:	68f8      	ldr	r0, [r7, #12]
 802101c:	f000 fb24 	bl	8021668 <resolve_time>

        /*Do not let two animations for the same 'var' with the same 'exec_cb'*/
        if(a->exec_cb || a->custom_exec_cb) remove_concurrent_anims(new_anim);
 8021020:	687b      	ldr	r3, [r7, #4]
 8021022:	685b      	ldr	r3, [r3, #4]
 8021024:	2b00      	cmp	r3, #0
 8021026:	d103      	bne.n	8021030 <lv_anim_start+0xac>
 8021028:	687b      	ldr	r3, [r7, #4]
 802102a:	689b      	ldr	r3, [r3, #8]
 802102c:	2b00      	cmp	r3, #0
 802102e:	d002      	beq.n	8021036 <lv_anim_start+0xb2>
 8021030:	68f8      	ldr	r0, [r7, #12]
 8021032:	f000 fb53 	bl	80216dc <remove_concurrent_anims>

        if(new_anim->exec_cb) {
 8021036:	68fb      	ldr	r3, [r7, #12]
 8021038:	685b      	ldr	r3, [r3, #4]
 802103a:	2b00      	cmp	r3, #0
 802103c:	d007      	beq.n	802104e <lv_anim_start+0xca>
            new_anim->exec_cb(new_anim->var, new_anim->start_value);
 802103e:	68fb      	ldr	r3, [r7, #12]
 8021040:	685b      	ldr	r3, [r3, #4]
 8021042:	68fa      	ldr	r2, [r7, #12]
 8021044:	6810      	ldr	r0, [r2, #0]
 8021046:	68fa      	ldr	r2, [r7, #12]
 8021048:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 802104a:	4611      	mov	r1, r2
 802104c:	4798      	blx	r3
        }
        if(new_anim->custom_exec_cb) {
 802104e:	68fb      	ldr	r3, [r7, #12]
 8021050:	689b      	ldr	r3, [r3, #8]
 8021052:	2b00      	cmp	r3, #0
 8021054:	d006      	beq.n	8021064 <lv_anim_start+0xe0>
            new_anim->custom_exec_cb(new_anim, new_anim->start_value);
 8021056:	68fb      	ldr	r3, [r7, #12]
 8021058:	689b      	ldr	r3, [r3, #8]
 802105a:	68fa      	ldr	r2, [r7, #12]
 802105c:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 802105e:	4611      	mov	r1, r2
 8021060:	68f8      	ldr	r0, [r7, #12]
 8021062:	4798      	blx	r3
        }
    }

    /*Creating an animation changed the linked list.
     *It's important if it happens in a ready callback. (see `anim_timer`)*/
    anim_mark_list_change();
 8021064:	f000 fa6c 	bl	8021540 <anim_mark_list_change>

    LV_TRACE_ANIM("finished");
    return new_anim;
 8021068:	68fb      	ldr	r3, [r7, #12]
}
 802106a:	4618      	mov	r0, r3
 802106c:	3710      	adds	r7, #16
 802106e:	46bd      	mov	sp, r7
 8021070:	bd80      	pop	{r7, pc}
 8021072:	bf00      	nop
 8021074:	20000154 	.word	0x20000154
 8021078:	2000009c 	.word	0x2000009c

0802107c <lv_anim_delete>:
    playtime = playtime * a->repeat_cnt;
    return playtime;
}

bool lv_anim_delete(void * var, lv_anim_exec_xcb_t exec_cb)
{
 802107c:	b580      	push	{r7, lr}
 802107e:	b084      	sub	sp, #16
 8021080:	af00      	add	r7, sp, #0
 8021082:	6078      	str	r0, [r7, #4]
 8021084:	6039      	str	r1, [r7, #0]
    lv_anim_t * a;
    bool del_any = false;
 8021086:	2300      	movs	r3, #0
 8021088:	72fb      	strb	r3, [r7, #11]
    a        = _lv_ll_get_head(anim_ll_p);
 802108a:	4821      	ldr	r0, [pc, #132]	@ (8021110 <lv_anim_delete+0x94>)
 802108c:	f002 f89f 	bl	80231ce <_lv_ll_get_head>
 8021090:	60f8      	str	r0, [r7, #12]
    while(a != NULL) {
 8021092:	e034      	b.n	80210fe <lv_anim_delete+0x82>
        bool del = false;
 8021094:	2300      	movs	r3, #0
 8021096:	72bb      	strb	r3, [r7, #10]
        if((a->var == var || var == NULL) && (a->exec_cb == exec_cb || exec_cb == NULL)) {
 8021098:	68fb      	ldr	r3, [r7, #12]
 802109a:	681b      	ldr	r3, [r3, #0]
 802109c:	687a      	ldr	r2, [r7, #4]
 802109e:	429a      	cmp	r2, r3
 80210a0:	d002      	beq.n	80210a8 <lv_anim_delete+0x2c>
 80210a2:	687b      	ldr	r3, [r7, #4]
 80210a4:	2b00      	cmp	r3, #0
 80210a6:	d11c      	bne.n	80210e2 <lv_anim_delete+0x66>
 80210a8:	68fb      	ldr	r3, [r7, #12]
 80210aa:	685b      	ldr	r3, [r3, #4]
 80210ac:	683a      	ldr	r2, [r7, #0]
 80210ae:	429a      	cmp	r2, r3
 80210b0:	d002      	beq.n	80210b8 <lv_anim_delete+0x3c>
 80210b2:	683b      	ldr	r3, [r7, #0]
 80210b4:	2b00      	cmp	r3, #0
 80210b6:	d114      	bne.n	80210e2 <lv_anim_delete+0x66>
            _lv_ll_remove(anim_ll_p, a);
 80210b8:	68f9      	ldr	r1, [r7, #12]
 80210ba:	4815      	ldr	r0, [pc, #84]	@ (8021110 <lv_anim_delete+0x94>)
 80210bc:	f002 f82a 	bl	8023114 <_lv_ll_remove>
            if(a->deleted_cb != NULL) a->deleted_cb(a);
 80210c0:	68fb      	ldr	r3, [r7, #12]
 80210c2:	695b      	ldr	r3, [r3, #20]
 80210c4:	2b00      	cmp	r3, #0
 80210c6:	d003      	beq.n	80210d0 <lv_anim_delete+0x54>
 80210c8:	68fb      	ldr	r3, [r7, #12]
 80210ca:	695b      	ldr	r3, [r3, #20]
 80210cc:	68f8      	ldr	r0, [r7, #12]
 80210ce:	4798      	blx	r3
            lv_free(a);
 80210d0:	68f8      	ldr	r0, [r7, #12]
 80210d2:	f004 feb1 	bl	8025e38 <lv_free>
            anim_mark_list_change(); /*Read by `anim_timer`. It need to know if a delete occurred in
 80210d6:	f000 fa33 	bl	8021540 <anim_mark_list_change>
                                       the linked list*/
            del_any = true;
 80210da:	2301      	movs	r3, #1
 80210dc:	72fb      	strb	r3, [r7, #11]
            del = true;
 80210de:	2301      	movs	r3, #1
 80210e0:	72bb      	strb	r3, [r7, #10]
        }

        /*Always start from the head on delete, because we don't know
         *how `anim_ll_p` was changes in `a->deleted_cb` */
        a = del ? _lv_ll_get_head(anim_ll_p) : _lv_ll_get_next(anim_ll_p, a);
 80210e2:	7abb      	ldrb	r3, [r7, #10]
 80210e4:	2b00      	cmp	r3, #0
 80210e6:	d004      	beq.n	80210f2 <lv_anim_delete+0x76>
 80210e8:	4809      	ldr	r0, [pc, #36]	@ (8021110 <lv_anim_delete+0x94>)
 80210ea:	f002 f870 	bl	80231ce <_lv_ll_get_head>
 80210ee:	4603      	mov	r3, r0
 80210f0:	e004      	b.n	80210fc <lv_anim_delete+0x80>
 80210f2:	68f9      	ldr	r1, [r7, #12]
 80210f4:	4806      	ldr	r0, [pc, #24]	@ (8021110 <lv_anim_delete+0x94>)
 80210f6:	f002 f88c 	bl	8023212 <_lv_ll_get_next>
 80210fa:	4603      	mov	r3, r0
 80210fc:	60fb      	str	r3, [r7, #12]
    while(a != NULL) {
 80210fe:	68fb      	ldr	r3, [r7, #12]
 8021100:	2b00      	cmp	r3, #0
 8021102:	d1c7      	bne.n	8021094 <lv_anim_delete+0x18>
    }

    return del_any;
 8021104:	7afb      	ldrb	r3, [r7, #11]
}
 8021106:	4618      	mov	r0, r3
 8021108:	3710      	adds	r7, #16
 802110a:	46bd      	mov	sp, r7
 802110c:	bd80      	pop	{r7, pc}
 802110e:	bf00      	nop
 8021110:	20000154 	.word	0x20000154

08021114 <lv_anim_get>:
    _lv_ll_clear(anim_ll_p);
    anim_mark_list_change();
}

lv_anim_t * lv_anim_get(void * var, lv_anim_exec_xcb_t exec_cb)
{
 8021114:	b580      	push	{r7, lr}
 8021116:	b084      	sub	sp, #16
 8021118:	af00      	add	r7, sp, #0
 802111a:	6078      	str	r0, [r7, #4]
 802111c:	6039      	str	r1, [r7, #0]
    lv_anim_t * a;
    _LV_LL_READ(anim_ll_p, a) {
 802111e:	4810      	ldr	r0, [pc, #64]	@ (8021160 <lv_anim_get+0x4c>)
 8021120:	f002 f855 	bl	80231ce <_lv_ll_get_head>
 8021124:	60f8      	str	r0, [r7, #12]
 8021126:	e013      	b.n	8021150 <lv_anim_get+0x3c>
        if(a->var == var && (a->exec_cb == exec_cb || exec_cb == NULL)) {
 8021128:	68fb      	ldr	r3, [r7, #12]
 802112a:	681b      	ldr	r3, [r3, #0]
 802112c:	687a      	ldr	r2, [r7, #4]
 802112e:	429a      	cmp	r2, r3
 8021130:	d109      	bne.n	8021146 <lv_anim_get+0x32>
 8021132:	68fb      	ldr	r3, [r7, #12]
 8021134:	685b      	ldr	r3, [r3, #4]
 8021136:	683a      	ldr	r2, [r7, #0]
 8021138:	429a      	cmp	r2, r3
 802113a:	d002      	beq.n	8021142 <lv_anim_get+0x2e>
 802113c:	683b      	ldr	r3, [r7, #0]
 802113e:	2b00      	cmp	r3, #0
 8021140:	d101      	bne.n	8021146 <lv_anim_get+0x32>
            return a;
 8021142:	68fb      	ldr	r3, [r7, #12]
 8021144:	e008      	b.n	8021158 <lv_anim_get+0x44>
    _LV_LL_READ(anim_ll_p, a) {
 8021146:	68f9      	ldr	r1, [r7, #12]
 8021148:	4805      	ldr	r0, [pc, #20]	@ (8021160 <lv_anim_get+0x4c>)
 802114a:	f002 f862 	bl	8023212 <_lv_ll_get_next>
 802114e:	60f8      	str	r0, [r7, #12]
 8021150:	68fb      	ldr	r3, [r7, #12]
 8021152:	2b00      	cmp	r3, #0
 8021154:	d1e8      	bne.n	8021128 <lv_anim_get+0x14>
        }
    }

    return NULL;
 8021156:	2300      	movs	r3, #0
}
 8021158:	4618      	mov	r0, r3
 802115a:	3710      	adds	r7, #16
 802115c:	46bd      	mov	sp, r7
 802115e:	bd80      	pop	{r7, pc}
 8021160:	20000154 	.word	0x20000154

08021164 <lv_anim_speed_clamped>:

    return cnt;
}

uint32_t lv_anim_speed_clamped(uint32_t speed, uint32_t min_time, uint32_t max_time)
{
 8021164:	b480      	push	{r7}
 8021166:	b085      	sub	sp, #20
 8021168:	af00      	add	r7, sp, #0
 802116a:	60f8      	str	r0, [r7, #12]
 802116c:	60b9      	str	r1, [r7, #8]
 802116e:	607a      	str	r2, [r7, #4]

    if(speed > 10000) {
 8021170:	68fb      	ldr	r3, [r7, #12]
 8021172:	f242 7210 	movw	r2, #10000	@ 0x2710
 8021176:	4293      	cmp	r3, r2
 8021178:	d902      	bls.n	8021180 <lv_anim_speed_clamped+0x1c>
        LV_LOG_WARN("speed is truncated to 10000 (was %"LV_PRIu32")", speed);
        speed = 10230;
 802117a:	f242 73f6 	movw	r3, #10230	@ 0x27f6
 802117e:	60fb      	str	r3, [r7, #12]
    }
    if(min_time > 10000) {
 8021180:	68bb      	ldr	r3, [r7, #8]
 8021182:	f242 7210 	movw	r2, #10000	@ 0x2710
 8021186:	4293      	cmp	r3, r2
 8021188:	d902      	bls.n	8021190 <lv_anim_speed_clamped+0x2c>
        LV_LOG_WARN("min_time is truncated to 10000 (was %"LV_PRIu32")", min_time);
        min_time = 10230;
 802118a:	f242 73f6 	movw	r3, #10230	@ 0x27f6
 802118e:	60bb      	str	r3, [r7, #8]
    }
    if(max_time > 10000) {
 8021190:	687b      	ldr	r3, [r7, #4]
 8021192:	f242 7210 	movw	r2, #10000	@ 0x2710
 8021196:	4293      	cmp	r3, r2
 8021198:	d902      	bls.n	80211a0 <lv_anim_speed_clamped+0x3c>
        LV_LOG_WARN("max_time is truncated to 10000 (was %"LV_PRIu32")", max_time);
        max_time = 10230;
 802119a:	f242 73f6 	movw	r3, #10230	@ 0x27f6
 802119e:	607b      	str	r3, [r7, #4]
    }

    /*Lower the resolution to fit the 0.1023 range*/
    speed = (speed + 5) / 10;
 80211a0:	68fb      	ldr	r3, [r7, #12]
 80211a2:	3305      	adds	r3, #5
 80211a4:	4a10      	ldr	r2, [pc, #64]	@ (80211e8 <lv_anim_speed_clamped+0x84>)
 80211a6:	fba2 2303 	umull	r2, r3, r2, r3
 80211aa:	08db      	lsrs	r3, r3, #3
 80211ac:	60fb      	str	r3, [r7, #12]
    min_time = (min_time + 5) / 10;
 80211ae:	68bb      	ldr	r3, [r7, #8]
 80211b0:	3305      	adds	r3, #5
 80211b2:	4a0d      	ldr	r2, [pc, #52]	@ (80211e8 <lv_anim_speed_clamped+0x84>)
 80211b4:	fba2 2303 	umull	r2, r3, r2, r3
 80211b8:	08db      	lsrs	r3, r3, #3
 80211ba:	60bb      	str	r3, [r7, #8]
    max_time = (max_time + 5) / 10;
 80211bc:	687b      	ldr	r3, [r7, #4]
 80211be:	3305      	adds	r3, #5
 80211c0:	4a09      	ldr	r2, [pc, #36]	@ (80211e8 <lv_anim_speed_clamped+0x84>)
 80211c2:	fba2 2303 	umull	r2, r3, r2, r3
 80211c6:	08db      	lsrs	r3, r3, #3
 80211c8:	607b      	str	r3, [r7, #4]

    return 0x80000000 + (max_time << 20) + (min_time << 10) + speed;
 80211ca:	687b      	ldr	r3, [r7, #4]
 80211cc:	051a      	lsls	r2, r3, #20
 80211ce:	68bb      	ldr	r3, [r7, #8]
 80211d0:	029b      	lsls	r3, r3, #10
 80211d2:	441a      	add	r2, r3
 80211d4:	68fb      	ldr	r3, [r7, #12]
 80211d6:	4413      	add	r3, r2
 80211d8:	f103 4300 	add.w	r3, r3, #2147483648	@ 0x80000000

}
 80211dc:	4618      	mov	r0, r3
 80211de:	3714      	adds	r7, #20
 80211e0:	46bd      	mov	sp, r7
 80211e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80211e6:	4770      	bx	lr
 80211e8:	cccccccd 	.word	0xcccccccd

080211ec <lv_anim_path_linear>:
{
    anim_timer(NULL);
}

int32_t lv_anim_path_linear(const lv_anim_t * a)
{
 80211ec:	b580      	push	{r7, lr}
 80211ee:	b086      	sub	sp, #24
 80211f0:	af02      	add	r7, sp, #8
 80211f2:	6078      	str	r0, [r7, #4]
    /*Calculate the current step*/
    int32_t step = lv_map(a->act_time, 0, a->duration, 0, LV_ANIM_RESOLUTION);
 80211f4:	687b      	ldr	r3, [r7, #4]
 80211f6:	6b58      	ldr	r0, [r3, #52]	@ 0x34
 80211f8:	687b      	ldr	r3, [r7, #4]
 80211fa:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80211fc:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8021200:	9300      	str	r3, [sp, #0]
 8021202:	2300      	movs	r3, #0
 8021204:	2100      	movs	r1, #0
 8021206:	f002 f9f7 	bl	80235f8 <lv_map>
 802120a:	60f8      	str	r0, [r7, #12]

    /*Get the new value which will be proportional to `step`
     *and the `start` and `end` values*/
    int32_t new_value;
    new_value = step * (a->end_value - a->start_value);
 802120c:	687b      	ldr	r3, [r7, #4]
 802120e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8021210:	687b      	ldr	r3, [r7, #4]
 8021212:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8021214:	1ad2      	subs	r2, r2, r3
 8021216:	68fb      	ldr	r3, [r7, #12]
 8021218:	fb02 f303 	mul.w	r3, r2, r3
 802121c:	60bb      	str	r3, [r7, #8]
    new_value = new_value >> LV_ANIM_RES_SHIFT;
 802121e:	68bb      	ldr	r3, [r7, #8]
 8021220:	129b      	asrs	r3, r3, #10
 8021222:	60bb      	str	r3, [r7, #8]
    new_value += a->start_value;
 8021224:	687b      	ldr	r3, [r7, #4]
 8021226:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8021228:	68ba      	ldr	r2, [r7, #8]
 802122a:	4413      	add	r3, r2
 802122c:	60bb      	str	r3, [r7, #8]

    return new_value;
 802122e:	68bb      	ldr	r3, [r7, #8]
}
 8021230:	4618      	mov	r0, r3
 8021232:	3710      	adds	r7, #16
 8021234:	46bd      	mov	sp, r7
 8021236:	bd80      	pop	{r7, pc}

08021238 <lv_anim_path_ease_out>:
    return lv_anim_path_cubic_bezier(a, LV_BEZIER_VAL_FLOAT(0.42), LV_BEZIER_VAL_FLOAT(0),
                                     LV_BEZIER_VAL_FLOAT(1), LV_BEZIER_VAL_FLOAT(1));
}

int32_t lv_anim_path_ease_out(const lv_anim_t * a)
{
 8021238:	b580      	push	{r7, lr}
 802123a:	b084      	sub	sp, #16
 802123c:	af02      	add	r7, sp, #8
 802123e:	6078      	str	r0, [r7, #4]
    return lv_anim_path_cubic_bezier(a, LV_BEZIER_VAL_FLOAT(0), LV_BEZIER_VAL_FLOAT(0),
 8021240:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8021244:	9300      	str	r3, [sp, #0]
 8021246:	f240 2351 	movw	r3, #593	@ 0x251
 802124a:	2200      	movs	r2, #0
 802124c:	2100      	movs	r1, #0
 802124e:	6878      	ldr	r0, [r7, #4]
 8021250:	f000 f996 	bl	8021580 <lv_anim_path_cubic_bezier>
 8021254:	4603      	mov	r3, r0
                                     LV_BEZIER_VAL_FLOAT(0.58), LV_BEZIER_VAL_FLOAT(1));
}
 8021256:	4618      	mov	r0, r3
 8021258:	3708      	adds	r7, #8
 802125a:	46bd      	mov	sp, r7
 802125c:	bd80      	pop	{r7, pc}
	...

08021260 <anim_timer>:
/**
 * Periodically handle the animations.
 * @param param unused
 */
static void anim_timer(lv_timer_t * param)
{
 8021260:	b580      	push	{r7, lr}
 8021262:	b086      	sub	sp, #24
 8021264:	af00      	add	r7, sp, #0
 8021266:	6078      	str	r0, [r7, #4]
    LV_UNUSED(param);

    /*Flip the run round*/
    state.anim_run_round = state.anim_run_round ? false : true;
 8021268:	4b6c      	ldr	r3, [pc, #432]	@ (802141c <anim_timer+0x1bc>)
 802126a:	f893 30b1 	ldrb.w	r3, [r3, #177]	@ 0xb1
 802126e:	f083 0301 	eor.w	r3, r3, #1
 8021272:	b2da      	uxtb	r2, r3
 8021274:	4b69      	ldr	r3, [pc, #420]	@ (802141c <anim_timer+0x1bc>)
 8021276:	f883 20b1 	strb.w	r2, [r3, #177]	@ 0xb1

    lv_anim_t * a = _lv_ll_get_head(anim_ll_p);
 802127a:	4869      	ldr	r0, [pc, #420]	@ (8021420 <anim_timer+0x1c0>)
 802127c:	f001 ffa7 	bl	80231ce <_lv_ll_get_head>
 8021280:	6178      	str	r0, [r7, #20]

    while(a != NULL) {
 8021282:	e0c1      	b.n	8021408 <anim_timer+0x1a8>

        //        printf("%p, %d\n", a, a->start_value);

        uint32_t elaps = lv_tick_elaps(a->last_timer_run);
 8021284:	697b      	ldr	r3, [r7, #20]
 8021286:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8021288:	4618      	mov	r0, r3
 802128a:	f004 feab 	bl	8025fe4 <lv_tick_elaps>
 802128e:	6138      	str	r0, [r7, #16]
        a->act_time += elaps;
 8021290:	697b      	ldr	r3, [r7, #20]
 8021292:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8021294:	461a      	mov	r2, r3
 8021296:	693b      	ldr	r3, [r7, #16]
 8021298:	4413      	add	r3, r2
 802129a:	461a      	mov	r2, r3
 802129c:	697b      	ldr	r3, [r7, #20]
 802129e:	635a      	str	r2, [r3, #52]	@ 0x34

        a->last_timer_run = lv_tick_get();
 80212a0:	f004 fe80 	bl	8025fa4 <lv_tick_get>
 80212a4:	4602      	mov	r2, r0
 80212a6:	697b      	ldr	r3, [r7, #20]
 80212a8:	651a      	str	r2, [r3, #80]	@ 0x50

        /*It can be set by `lv_anim_delete()` typically in `end_cb`. If set then an animation delete
         * happened in `anim_completed_handler` which could make this linked list reading corrupt
         * because the list is changed meanwhile
         */
        state.anim_list_changed = false;
 80212aa:	4b5c      	ldr	r3, [pc, #368]	@ (802141c <anim_timer+0x1bc>)
 80212ac:	2200      	movs	r2, #0
 80212ae:	f883 20b0 	strb.w	r2, [r3, #176]	@ 0xb0

        if(a->run_round != state.anim_run_round) {
 80212b2:	697b      	ldr	r3, [r7, #20]
 80212b4:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 80212b8:	f3c3 0340 	ubfx	r3, r3, #1, #1
 80212bc:	b2da      	uxtb	r2, r3
 80212be:	4b57      	ldr	r3, [pc, #348]	@ (802141c <anim_timer+0x1bc>)
 80212c0:	f893 30b1 	ldrb.w	r3, [r3, #177]	@ 0xb1
 80212c4:	429a      	cmp	r2, r3
 80212c6:	f000 8090 	beq.w	80213ea <anim_timer+0x18a>
            a->run_round = state.anim_run_round; /*The list readying might be reset so need to know which anim has run already*/
 80212ca:	4b54      	ldr	r3, [pc, #336]	@ (802141c <anim_timer+0x1bc>)
 80212cc:	f893 10b1 	ldrb.w	r1, [r3, #177]	@ 0xb1
 80212d0:	697a      	ldr	r2, [r7, #20]
 80212d2:	f892 3054 	ldrb.w	r3, [r2, #84]	@ 0x54
 80212d6:	f361 0341 	bfi	r3, r1, #1, #1
 80212da:	f882 3054 	strb.w	r3, [r2, #84]	@ 0x54

            /*The animation will run now for the first time. Call `start_cb`*/
            if(!a->start_cb_called && a->act_time >= 0) {
 80212de:	697b      	ldr	r3, [r7, #20]
 80212e0:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 80212e4:	f003 0304 	and.w	r3, r3, #4
 80212e8:	b2db      	uxtb	r3, r3
 80212ea:	2b00      	cmp	r3, #0
 80212ec:	d135      	bne.n	802135a <anim_timer+0xfa>
 80212ee:	697b      	ldr	r3, [r7, #20]
 80212f0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80212f2:	2b00      	cmp	r3, #0
 80212f4:	db31      	blt.n	802135a <anim_timer+0xfa>

                if(a->early_apply == 0 && a->get_value_cb) {
 80212f6:	697b      	ldr	r3, [r7, #20]
 80212f8:	f893 304e 	ldrb.w	r3, [r3, #78]	@ 0x4e
 80212fc:	f003 0301 	and.w	r3, r3, #1
 8021300:	b2db      	uxtb	r3, r3
 8021302:	2b00      	cmp	r3, #0
 8021304:	d114      	bne.n	8021330 <anim_timer+0xd0>
 8021306:	697b      	ldr	r3, [r7, #20]
 8021308:	699b      	ldr	r3, [r3, #24]
 802130a:	2b00      	cmp	r3, #0
 802130c:	d010      	beq.n	8021330 <anim_timer+0xd0>
                    int32_t v_ofs = a->get_value_cb(a);
 802130e:	697b      	ldr	r3, [r7, #20]
 8021310:	699b      	ldr	r3, [r3, #24]
 8021312:	6978      	ldr	r0, [r7, #20]
 8021314:	4798      	blx	r3
 8021316:	60f8      	str	r0, [r7, #12]
                    a->start_value += v_ofs;
 8021318:	697b      	ldr	r3, [r7, #20]
 802131a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 802131c:	68fb      	ldr	r3, [r7, #12]
 802131e:	441a      	add	r2, r3
 8021320:	697b      	ldr	r3, [r7, #20]
 8021322:	625a      	str	r2, [r3, #36]	@ 0x24
                    a->end_value += v_ofs;
 8021324:	697b      	ldr	r3, [r7, #20]
 8021326:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8021328:	68fb      	ldr	r3, [r7, #12]
 802132a:	441a      	add	r2, r3
 802132c:	697b      	ldr	r3, [r7, #20]
 802132e:	62da      	str	r2, [r3, #44]	@ 0x2c
                }

                resolve_time(a);
 8021330:	6978      	ldr	r0, [r7, #20]
 8021332:	f000 f999 	bl	8021668 <resolve_time>

                if(a->start_cb) a->start_cb(a);
 8021336:	697b      	ldr	r3, [r7, #20]
 8021338:	68db      	ldr	r3, [r3, #12]
 802133a:	2b00      	cmp	r3, #0
 802133c:	d003      	beq.n	8021346 <anim_timer+0xe6>
 802133e:	697b      	ldr	r3, [r7, #20]
 8021340:	68db      	ldr	r3, [r3, #12]
 8021342:	6978      	ldr	r0, [r7, #20]
 8021344:	4798      	blx	r3
                a->start_cb_called = 1;
 8021346:	697a      	ldr	r2, [r7, #20]
 8021348:	f892 3054 	ldrb.w	r3, [r2, #84]	@ 0x54
 802134c:	f043 0304 	orr.w	r3, r3, #4
 8021350:	f882 3054 	strb.w	r3, [r2, #84]	@ 0x54

                /*Do not let two animations for the same 'var' with the same 'exec_cb'*/
                remove_concurrent_anims(a);
 8021354:	6978      	ldr	r0, [r7, #20]
 8021356:	f000 f9c1 	bl	80216dc <remove_concurrent_anims>
            }

            if(a->act_time >= 0) {
 802135a:	697b      	ldr	r3, [r7, #20]
 802135c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 802135e:	2b00      	cmp	r3, #0
 8021360:	db43      	blt.n	80213ea <anim_timer+0x18a>
                if(a->act_time > a->duration) a->act_time = a->duration;
 8021362:	697b      	ldr	r3, [r7, #20]
 8021364:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8021366:	697b      	ldr	r3, [r7, #20]
 8021368:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 802136a:	429a      	cmp	r2, r3
 802136c:	dd03      	ble.n	8021376 <anim_timer+0x116>
 802136e:	697b      	ldr	r3, [r7, #20]
 8021370:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8021372:	697b      	ldr	r3, [r7, #20]
 8021374:	635a      	str	r2, [r3, #52]	@ 0x34

                int32_t new_value;
                new_value = a->path_cb(a);
 8021376:	697b      	ldr	r3, [r7, #20]
 8021378:	6a1b      	ldr	r3, [r3, #32]
 802137a:	6978      	ldr	r0, [r7, #20]
 802137c:	4798      	blx	r3
 802137e:	60b8      	str	r0, [r7, #8]

                if(new_value != a->current_value) {
 8021380:	697b      	ldr	r3, [r7, #20]
 8021382:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8021384:	68ba      	ldr	r2, [r7, #8]
 8021386:	429a      	cmp	r2, r3
 8021388:	d01e      	beq.n	80213c8 <anim_timer+0x168>
                    a->current_value = new_value;
 802138a:	697b      	ldr	r3, [r7, #20]
 802138c:	68ba      	ldr	r2, [r7, #8]
 802138e:	629a      	str	r2, [r3, #40]	@ 0x28
                    /*Apply the calculated value*/
                    if(a->exec_cb) a->exec_cb(a->var, new_value);
 8021390:	697b      	ldr	r3, [r7, #20]
 8021392:	685b      	ldr	r3, [r3, #4]
 8021394:	2b00      	cmp	r3, #0
 8021396:	d006      	beq.n	80213a6 <anim_timer+0x146>
 8021398:	697b      	ldr	r3, [r7, #20]
 802139a:	685b      	ldr	r3, [r3, #4]
 802139c:	697a      	ldr	r2, [r7, #20]
 802139e:	6812      	ldr	r2, [r2, #0]
 80213a0:	68b9      	ldr	r1, [r7, #8]
 80213a2:	4610      	mov	r0, r2
 80213a4:	4798      	blx	r3
                    if(!state.anim_list_changed && a->custom_exec_cb) a->custom_exec_cb(a, new_value);
 80213a6:	4b1d      	ldr	r3, [pc, #116]	@ (802141c <anim_timer+0x1bc>)
 80213a8:	f893 30b0 	ldrb.w	r3, [r3, #176]	@ 0xb0
 80213ac:	f083 0301 	eor.w	r3, r3, #1
 80213b0:	b2db      	uxtb	r3, r3
 80213b2:	2b00      	cmp	r3, #0
 80213b4:	d008      	beq.n	80213c8 <anim_timer+0x168>
 80213b6:	697b      	ldr	r3, [r7, #20]
 80213b8:	689b      	ldr	r3, [r3, #8]
 80213ba:	2b00      	cmp	r3, #0
 80213bc:	d004      	beq.n	80213c8 <anim_timer+0x168>
 80213be:	697b      	ldr	r3, [r7, #20]
 80213c0:	689b      	ldr	r3, [r3, #8]
 80213c2:	68b9      	ldr	r1, [r7, #8]
 80213c4:	6978      	ldr	r0, [r7, #20]
 80213c6:	4798      	blx	r3
                }

                /*If the time is elapsed the animation is ready*/
                if(!state.anim_list_changed && a->act_time >= a->duration) {
 80213c8:	4b14      	ldr	r3, [pc, #80]	@ (802141c <anim_timer+0x1bc>)
 80213ca:	f893 30b0 	ldrb.w	r3, [r3, #176]	@ 0xb0
 80213ce:	f083 0301 	eor.w	r3, r3, #1
 80213d2:	b2db      	uxtb	r3, r3
 80213d4:	2b00      	cmp	r3, #0
 80213d6:	d008      	beq.n	80213ea <anim_timer+0x18a>
 80213d8:	697b      	ldr	r3, [r7, #20]
 80213da:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80213dc:	697b      	ldr	r3, [r7, #20]
 80213de:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80213e0:	429a      	cmp	r2, r3
 80213e2:	db02      	blt.n	80213ea <anim_timer+0x18a>
                    anim_completed_handler(a);
 80213e4:	6978      	ldr	r0, [r7, #20]
 80213e6:	f000 f81d 	bl	8021424 <anim_completed_handler>
            }
        }

        /*If the linked list changed due to anim. delete then it's not safe to continue
         *the reading of the list from here -> start from the head*/
        if(state.anim_list_changed)
 80213ea:	4b0c      	ldr	r3, [pc, #48]	@ (802141c <anim_timer+0x1bc>)
 80213ec:	f893 30b0 	ldrb.w	r3, [r3, #176]	@ 0xb0
 80213f0:	2b00      	cmp	r3, #0
 80213f2:	d004      	beq.n	80213fe <anim_timer+0x19e>
            a = _lv_ll_get_head(anim_ll_p);
 80213f4:	480a      	ldr	r0, [pc, #40]	@ (8021420 <anim_timer+0x1c0>)
 80213f6:	f001 feea 	bl	80231ce <_lv_ll_get_head>
 80213fa:	6178      	str	r0, [r7, #20]
 80213fc:	e004      	b.n	8021408 <anim_timer+0x1a8>
        else
            a = _lv_ll_get_next(anim_ll_p, a);
 80213fe:	6979      	ldr	r1, [r7, #20]
 8021400:	4807      	ldr	r0, [pc, #28]	@ (8021420 <anim_timer+0x1c0>)
 8021402:	f001 ff06 	bl	8023212 <_lv_ll_get_next>
 8021406:	6178      	str	r0, [r7, #20]
    while(a != NULL) {
 8021408:	697b      	ldr	r3, [r7, #20]
 802140a:	2b00      	cmp	r3, #0
 802140c:	f47f af3a 	bne.w	8021284 <anim_timer+0x24>
    }

}
 8021410:	bf00      	nop
 8021412:	bf00      	nop
 8021414:	3718      	adds	r7, #24
 8021416:	46bd      	mov	sp, r7
 8021418:	bd80      	pop	{r7, pc}
 802141a:	bf00      	nop
 802141c:	2000009c 	.word	0x2000009c
 8021420:	20000154 	.word	0x20000154

08021424 <anim_completed_handler>:
 * Called when an animation is completed to do the necessary things
 * e.g. repeat, play back, delete etc.
 * @param a pointer to an animation descriptor
 */
static void anim_completed_handler(lv_anim_t * a)
{
 8021424:	b580      	push	{r7, lr}
 8021426:	b084      	sub	sp, #16
 8021428:	af00      	add	r7, sp, #0
 802142a:	6078      	str	r0, [r7, #4]
    /*In the end of a forward anim decrement repeat cnt.*/
    if(a->playback_now == 0 && a->repeat_cnt > 0 && a->repeat_cnt != LV_ANIM_REPEAT_INFINITE) {
 802142c:	687b      	ldr	r3, [r7, #4]
 802142e:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 8021432:	f003 0301 	and.w	r3, r3, #1
 8021436:	b2db      	uxtb	r3, r3
 8021438:	2b00      	cmp	r3, #0
 802143a:	d113      	bne.n	8021464 <anim_completed_handler+0x40>
 802143c:	687b      	ldr	r3, [r7, #4]
 802143e:	f8b3 3044 	ldrh.w	r3, [r3, #68]	@ 0x44
 8021442:	2b00      	cmp	r3, #0
 8021444:	d00e      	beq.n	8021464 <anim_completed_handler+0x40>
 8021446:	687b      	ldr	r3, [r7, #4]
 8021448:	f8b3 3044 	ldrh.w	r3, [r3, #68]	@ 0x44
 802144c:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8021450:	4293      	cmp	r3, r2
 8021452:	d007      	beq.n	8021464 <anim_completed_handler+0x40>
        a->repeat_cnt--;
 8021454:	687b      	ldr	r3, [r7, #4]
 8021456:	f8b3 3044 	ldrh.w	r3, [r3, #68]	@ 0x44
 802145a:	3b01      	subs	r3, #1
 802145c:	b29a      	uxth	r2, r3
 802145e:	687b      	ldr	r3, [r7, #4]
 8021460:	f8a3 2044 	strh.w	r2, [r3, #68]	@ 0x44
    }

    /*Delete the animation if
     * - no repeat left and no play back (simple one shot animation)
     * - no repeat, play back is enabled and play back is ready*/
    if(a->repeat_cnt == 0 && (a->playback_duration == 0 || a->playback_now == 1)) {
 8021464:	687b      	ldr	r3, [r7, #4]
 8021466:	f8b3 3044 	ldrh.w	r3, [r3, #68]	@ 0x44
 802146a:	2b00      	cmp	r3, #0
 802146c:	d125      	bne.n	80214ba <anim_completed_handler+0x96>
 802146e:	687b      	ldr	r3, [r7, #4]
 8021470:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8021472:	2b00      	cmp	r3, #0
 8021474:	d007      	beq.n	8021486 <anim_completed_handler+0x62>
 8021476:	687b      	ldr	r3, [r7, #4]
 8021478:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 802147c:	f003 0301 	and.w	r3, r3, #1
 8021480:	b2db      	uxtb	r3, r3
 8021482:	2b00      	cmp	r3, #0
 8021484:	d019      	beq.n	80214ba <anim_completed_handler+0x96>

        /*Delete the animation from the list.
         * This way the `completed_cb` will see the animations like it's animation is already deleted*/
        _lv_ll_remove(anim_ll_p, a);
 8021486:	6879      	ldr	r1, [r7, #4]
 8021488:	482c      	ldr	r0, [pc, #176]	@ (802153c <anim_completed_handler+0x118>)
 802148a:	f001 fe43 	bl	8023114 <_lv_ll_remove>
        /*Flag that the list has changed*/
        anim_mark_list_change();
 802148e:	f000 f857 	bl	8021540 <anim_mark_list_change>

        /*Call the callback function at the end*/
        if(a->completed_cb != NULL) a->completed_cb(a);
 8021492:	687b      	ldr	r3, [r7, #4]
 8021494:	691b      	ldr	r3, [r3, #16]
 8021496:	2b00      	cmp	r3, #0
 8021498:	d003      	beq.n	80214a2 <anim_completed_handler+0x7e>
 802149a:	687b      	ldr	r3, [r7, #4]
 802149c:	691b      	ldr	r3, [r3, #16]
 802149e:	6878      	ldr	r0, [r7, #4]
 80214a0:	4798      	blx	r3
        if(a->deleted_cb != NULL) a->deleted_cb(a);
 80214a2:	687b      	ldr	r3, [r7, #4]
 80214a4:	695b      	ldr	r3, [r3, #20]
 80214a6:	2b00      	cmp	r3, #0
 80214a8:	d003      	beq.n	80214b2 <anim_completed_handler+0x8e>
 80214aa:	687b      	ldr	r3, [r7, #4]
 80214ac:	695b      	ldr	r3, [r3, #20]
 80214ae:	6878      	ldr	r0, [r7, #4]
 80214b0:	4798      	blx	r3
        lv_free(a);
 80214b2:	6878      	ldr	r0, [r7, #4]
 80214b4:	f004 fcc0 	bl	8025e38 <lv_free>
            tmp = a->duration;
            a->duration = a->playback_duration;
            a->playback_duration = tmp;
        }
    }
}
 80214b8:	e03c      	b.n	8021534 <anim_completed_handler+0x110>
        a->act_time = -(int32_t)(a->repeat_delay); /*Restart the animation*/
 80214ba:	687b      	ldr	r3, [r7, #4]
 80214bc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80214be:	425a      	negs	r2, r3
 80214c0:	687b      	ldr	r3, [r7, #4]
 80214c2:	635a      	str	r2, [r3, #52]	@ 0x34
        if(a->playback_duration != 0) {
 80214c4:	687b      	ldr	r3, [r7, #4]
 80214c6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80214c8:	2b00      	cmp	r3, #0
 80214ca:	d033      	beq.n	8021534 <anim_completed_handler+0x110>
            if(a->playback_now == 0) a->act_time = -(int32_t)(a->playback_delay);
 80214cc:	687b      	ldr	r3, [r7, #4]
 80214ce:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 80214d2:	f003 0301 	and.w	r3, r3, #1
 80214d6:	b2db      	uxtb	r3, r3
 80214d8:	2b00      	cmp	r3, #0
 80214da:	d104      	bne.n	80214e6 <anim_completed_handler+0xc2>
 80214dc:	687b      	ldr	r3, [r7, #4]
 80214de:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80214e0:	425a      	negs	r2, r3
 80214e2:	687b      	ldr	r3, [r7, #4]
 80214e4:	635a      	str	r2, [r3, #52]	@ 0x34
            a->playback_now = a->playback_now == 0 ? 1 : 0;
 80214e6:	687b      	ldr	r3, [r7, #4]
 80214e8:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 80214ec:	f003 0301 	and.w	r3, r3, #1
 80214f0:	b2db      	uxtb	r3, r3
 80214f2:	2b00      	cmp	r3, #0
 80214f4:	bf0c      	ite	eq
 80214f6:	2301      	moveq	r3, #1
 80214f8:	2300      	movne	r3, #0
 80214fa:	b2d9      	uxtb	r1, r3
 80214fc:	687a      	ldr	r2, [r7, #4]
 80214fe:	f892 3054 	ldrb.w	r3, [r2, #84]	@ 0x54
 8021502:	f361 0300 	bfi	r3, r1, #0, #1
 8021506:	f882 3054 	strb.w	r3, [r2, #84]	@ 0x54
            int32_t tmp    = a->start_value;
 802150a:	687b      	ldr	r3, [r7, #4]
 802150c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 802150e:	60fb      	str	r3, [r7, #12]
            a->start_value = a->end_value;
 8021510:	687b      	ldr	r3, [r7, #4]
 8021512:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8021514:	687b      	ldr	r3, [r7, #4]
 8021516:	625a      	str	r2, [r3, #36]	@ 0x24
            a->end_value   = tmp;
 8021518:	687b      	ldr	r3, [r7, #4]
 802151a:	68fa      	ldr	r2, [r7, #12]
 802151c:	62da      	str	r2, [r3, #44]	@ 0x2c
            tmp = a->duration;
 802151e:	687b      	ldr	r3, [r7, #4]
 8021520:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8021522:	60fb      	str	r3, [r7, #12]
            a->duration = a->playback_duration;
 8021524:	687b      	ldr	r3, [r7, #4]
 8021526:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8021528:	461a      	mov	r2, r3
 802152a:	687b      	ldr	r3, [r7, #4]
 802152c:	631a      	str	r2, [r3, #48]	@ 0x30
            a->playback_duration = tmp;
 802152e:	68fa      	ldr	r2, [r7, #12]
 8021530:	687b      	ldr	r3, [r7, #4]
 8021532:	63da      	str	r2, [r3, #60]	@ 0x3c
}
 8021534:	bf00      	nop
 8021536:	3710      	adds	r7, #16
 8021538:	46bd      	mov	sp, r7
 802153a:	bd80      	pop	{r7, pc}
 802153c:	20000154 	.word	0x20000154

08021540 <anim_mark_list_change>:

static void anim_mark_list_change(void)
{
 8021540:	b580      	push	{r7, lr}
 8021542:	af00      	add	r7, sp, #0
    state.anim_list_changed = true;
 8021544:	4b0c      	ldr	r3, [pc, #48]	@ (8021578 <anim_mark_list_change+0x38>)
 8021546:	2201      	movs	r2, #1
 8021548:	f883 20b0 	strb.w	r2, [r3, #176]	@ 0xb0
    if(_lv_ll_get_head(anim_ll_p) == NULL)
 802154c:	480b      	ldr	r0, [pc, #44]	@ (802157c <anim_mark_list_change+0x3c>)
 802154e:	f001 fe3e 	bl	80231ce <_lv_ll_get_head>
 8021552:	4603      	mov	r3, r0
 8021554:	2b00      	cmp	r3, #0
 8021556:	d106      	bne.n	8021566 <anim_mark_list_change+0x26>
        lv_timer_pause(state.timer);
 8021558:	4b07      	ldr	r3, [pc, #28]	@ (8021578 <anim_mark_list_change+0x38>)
 802155a:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 802155e:	4618      	mov	r0, r3
 8021560:	f003 f8ce 	bl	8024700 <lv_timer_pause>
    else
        lv_timer_resume(state.timer);
}
 8021564:	e005      	b.n	8021572 <anim_mark_list_change+0x32>
        lv_timer_resume(state.timer);
 8021566:	4b04      	ldr	r3, [pc, #16]	@ (8021578 <anim_mark_list_change+0x38>)
 8021568:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 802156c:	4618      	mov	r0, r3
 802156e:	f003 f8db 	bl	8024728 <lv_timer_resume>
}
 8021572:	bf00      	nop
 8021574:	bd80      	pop	{r7, pc}
 8021576:	bf00      	nop
 8021578:	2000009c 	.word	0x2000009c
 802157c:	20000154 	.word	0x20000154

08021580 <lv_anim_path_cubic_bezier>:

static int32_t lv_anim_path_cubic_bezier(const lv_anim_t * a, int32_t x1, int32_t y1, int32_t x2, int32_t y2)
{
 8021580:	b580      	push	{r7, lr}
 8021582:	b08a      	sub	sp, #40	@ 0x28
 8021584:	af02      	add	r7, sp, #8
 8021586:	60f8      	str	r0, [r7, #12]
 8021588:	60b9      	str	r1, [r7, #8]
 802158a:	607a      	str	r2, [r7, #4]
 802158c:	603b      	str	r3, [r7, #0]
    /*Calculate the current step*/
    uint32_t t = lv_map(a->act_time, 0, a->duration, 0, LV_BEZIER_VAL_MAX);
 802158e:	68fb      	ldr	r3, [r7, #12]
 8021590:	6b58      	ldr	r0, [r3, #52]	@ 0x34
 8021592:	68fb      	ldr	r3, [r7, #12]
 8021594:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8021596:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 802159a:	9300      	str	r3, [sp, #0]
 802159c:	2300      	movs	r3, #0
 802159e:	2100      	movs	r1, #0
 80215a0:	f002 f82a 	bl	80235f8 <lv_map>
 80215a4:	4603      	mov	r3, r0
 80215a6:	61fb      	str	r3, [r7, #28]
    int32_t step = lv_cubic_bezier(t, x1, y1, x2, y2);
 80215a8:	69f8      	ldr	r0, [r7, #28]
 80215aa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80215ac:	9300      	str	r3, [sp, #0]
 80215ae:	683b      	ldr	r3, [r7, #0]
 80215b0:	687a      	ldr	r2, [r7, #4]
 80215b2:	68b9      	ldr	r1, [r7, #8]
 80215b4:	f001 ff34 	bl	8023420 <lv_cubic_bezier>
 80215b8:	61b8      	str	r0, [r7, #24]

    int32_t new_value;
    new_value = step * (a->end_value - a->start_value);
 80215ba:	68fb      	ldr	r3, [r7, #12]
 80215bc:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80215be:	68fb      	ldr	r3, [r7, #12]
 80215c0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80215c2:	1ad2      	subs	r2, r2, r3
 80215c4:	69bb      	ldr	r3, [r7, #24]
 80215c6:	fb02 f303 	mul.w	r3, r2, r3
 80215ca:	617b      	str	r3, [r7, #20]
    new_value = new_value >> LV_BEZIER_VAL_SHIFT;
 80215cc:	697b      	ldr	r3, [r7, #20]
 80215ce:	129b      	asrs	r3, r3, #10
 80215d0:	617b      	str	r3, [r7, #20]
    new_value += a->start_value;
 80215d2:	68fb      	ldr	r3, [r7, #12]
 80215d4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80215d6:	697a      	ldr	r2, [r7, #20]
 80215d8:	4413      	add	r3, r2
 80215da:	617b      	str	r3, [r7, #20]

    return new_value;
 80215dc:	697b      	ldr	r3, [r7, #20]
}
 80215de:	4618      	mov	r0, r3
 80215e0:	3720      	adds	r7, #32
 80215e2:	46bd      	mov	sp, r7
 80215e4:	bd80      	pop	{r7, pc}

080215e6 <convert_speed_to_time>:

static uint32_t convert_speed_to_time(uint32_t speed_or_time, int32_t start, int32_t end)
{
 80215e6:	b480      	push	{r7}
 80215e8:	b08b      	sub	sp, #44	@ 0x2c
 80215ea:	af00      	add	r7, sp, #0
 80215ec:	60f8      	str	r0, [r7, #12]
 80215ee:	60b9      	str	r1, [r7, #8]
 80215f0:	607a      	str	r2, [r7, #4]
    /*It was a simple time*/
    if((speed_or_time & 0x80000000) == 0) return speed_or_time;
 80215f2:	68fb      	ldr	r3, [r7, #12]
 80215f4:	2b00      	cmp	r3, #0
 80215f6:	db01      	blt.n	80215fc <convert_speed_to_time+0x16>
 80215f8:	68fb      	ldr	r3, [r7, #12]
 80215fa:	e02f      	b.n	802165c <convert_speed_to_time+0x76>

    uint32_t d    = LV_ABS(start - end);
 80215fc:	68ba      	ldr	r2, [r7, #8]
 80215fe:	687b      	ldr	r3, [r7, #4]
 8021600:	1ad3      	subs	r3, r2, r3
 8021602:	2b00      	cmp	r3, #0
 8021604:	bfb8      	it	lt
 8021606:	425b      	neglt	r3, r3
 8021608:	627b      	str	r3, [r7, #36]	@ 0x24
    uint32_t speed = speed_or_time & 0x3FF;
 802160a:	68fb      	ldr	r3, [r7, #12]
 802160c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8021610:	623b      	str	r3, [r7, #32]
    uint32_t time = (d * 100) / speed; /*Speed is in 10 units per sec*/
 8021612:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8021614:	2264      	movs	r2, #100	@ 0x64
 8021616:	fb03 f202 	mul.w	r2, r3, r2
 802161a:	6a3b      	ldr	r3, [r7, #32]
 802161c:	fbb2 f3f3 	udiv	r3, r2, r3
 8021620:	61fb      	str	r3, [r7, #28]
    uint32_t max_time = (speed_or_time >> 20) & 0x3FF;
 8021622:	68fb      	ldr	r3, [r7, #12]
 8021624:	0d1b      	lsrs	r3, r3, #20
 8021626:	f3c3 0309 	ubfx	r3, r3, #0, #10
 802162a:	61bb      	str	r3, [r7, #24]
    uint32_t min_time = (speed_or_time >> 10) & 0x3FF;
 802162c:	68fb      	ldr	r3, [r7, #12]
 802162e:	0a9b      	lsrs	r3, r3, #10
 8021630:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8021634:	617b      	str	r3, [r7, #20]

    return LV_CLAMP(min_time * 10, time, max_time * 10);
 8021636:	69ba      	ldr	r2, [r7, #24]
 8021638:	4613      	mov	r3, r2
 802163a:	009b      	lsls	r3, r3, #2
 802163c:	4413      	add	r3, r2
 802163e:	005b      	lsls	r3, r3, #1
 8021640:	461a      	mov	r2, r3
 8021642:	69fb      	ldr	r3, [r7, #28]
 8021644:	429a      	cmp	r2, r3
 8021646:	bf28      	it	cs
 8021648:	461a      	movcs	r2, r3
 802164a:	4611      	mov	r1, r2
 802164c:	697a      	ldr	r2, [r7, #20]
 802164e:	4613      	mov	r3, r2
 8021650:	009b      	lsls	r3, r3, #2
 8021652:	4413      	add	r3, r2
 8021654:	005b      	lsls	r3, r3, #1
 8021656:	428b      	cmp	r3, r1
 8021658:	bf38      	it	cc
 802165a:	460b      	movcc	r3, r1
}
 802165c:	4618      	mov	r0, r3
 802165e:	372c      	adds	r7, #44	@ 0x2c
 8021660:	46bd      	mov	sp, r7
 8021662:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021666:	4770      	bx	lr

08021668 <resolve_time>:

static void resolve_time(lv_anim_t * a)
{
 8021668:	b580      	push	{r7, lr}
 802166a:	b082      	sub	sp, #8
 802166c:	af00      	add	r7, sp, #0
 802166e:	6078      	str	r0, [r7, #4]
    a->duration = convert_speed_to_time(a->duration, a->start_value, a->end_value);
 8021670:	687b      	ldr	r3, [r7, #4]
 8021672:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8021674:	4618      	mov	r0, r3
 8021676:	687b      	ldr	r3, [r7, #4]
 8021678:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 802167a:	687b      	ldr	r3, [r7, #4]
 802167c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802167e:	461a      	mov	r2, r3
 8021680:	f7ff ffb1 	bl	80215e6 <convert_speed_to_time>
 8021684:	4603      	mov	r3, r0
 8021686:	461a      	mov	r2, r3
 8021688:	687b      	ldr	r3, [r7, #4]
 802168a:	631a      	str	r2, [r3, #48]	@ 0x30
    a->playback_duration = convert_speed_to_time(a->playback_duration, a->start_value, a->end_value);
 802168c:	687b      	ldr	r3, [r7, #4]
 802168e:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 8021690:	687b      	ldr	r3, [r7, #4]
 8021692:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 8021694:	687b      	ldr	r3, [r7, #4]
 8021696:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8021698:	461a      	mov	r2, r3
 802169a:	f7ff ffa4 	bl	80215e6 <convert_speed_to_time>
 802169e:	4602      	mov	r2, r0
 80216a0:	687b      	ldr	r3, [r7, #4]
 80216a2:	63da      	str	r2, [r3, #60]	@ 0x3c
    a->playback_delay = convert_speed_to_time(a->playback_delay, a->start_value, a->end_value);
 80216a4:	687b      	ldr	r3, [r7, #4]
 80216a6:	6b98      	ldr	r0, [r3, #56]	@ 0x38
 80216a8:	687b      	ldr	r3, [r7, #4]
 80216aa:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 80216ac:	687b      	ldr	r3, [r7, #4]
 80216ae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80216b0:	461a      	mov	r2, r3
 80216b2:	f7ff ff98 	bl	80215e6 <convert_speed_to_time>
 80216b6:	4602      	mov	r2, r0
 80216b8:	687b      	ldr	r3, [r7, #4]
 80216ba:	639a      	str	r2, [r3, #56]	@ 0x38
    a->repeat_delay = convert_speed_to_time(a->repeat_delay, a->start_value, a->end_value);
 80216bc:	687b      	ldr	r3, [r7, #4]
 80216be:	6c18      	ldr	r0, [r3, #64]	@ 0x40
 80216c0:	687b      	ldr	r3, [r7, #4]
 80216c2:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 80216c4:	687b      	ldr	r3, [r7, #4]
 80216c6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80216c8:	461a      	mov	r2, r3
 80216ca:	f7ff ff8c 	bl	80215e6 <convert_speed_to_time>
 80216ce:	4602      	mov	r2, r0
 80216d0:	687b      	ldr	r3, [r7, #4]
 80216d2:	641a      	str	r2, [r3, #64]	@ 0x40
}
 80216d4:	bf00      	nop
 80216d6:	3708      	adds	r7, #8
 80216d8:	46bd      	mov	sp, r7
 80216da:	bd80      	pop	{r7, pc}

080216dc <remove_concurrent_anims>:
 * and they are already running or they have early_apply
 * @param a_current     the current animation, use its var and exec_cb as reference to know what to remove
 * @return              true: at least one animation was delete
 */
static bool remove_concurrent_anims(lv_anim_t * a_current)
{
 80216dc:	b580      	push	{r7, lr}
 80216de:	b084      	sub	sp, #16
 80216e0:	af00      	add	r7, sp, #0
 80216e2:	6078      	str	r0, [r7, #4]
    if(a_current->exec_cb == NULL && a_current->custom_exec_cb == NULL) return false;
 80216e4:	687b      	ldr	r3, [r7, #4]
 80216e6:	685b      	ldr	r3, [r3, #4]
 80216e8:	2b00      	cmp	r3, #0
 80216ea:	d105      	bne.n	80216f8 <remove_concurrent_anims+0x1c>
 80216ec:	687b      	ldr	r3, [r7, #4]
 80216ee:	689b      	ldr	r3, [r3, #8]
 80216f0:	2b00      	cmp	r3, #0
 80216f2:	d101      	bne.n	80216f8 <remove_concurrent_anims+0x1c>
 80216f4:	2300      	movs	r3, #0
 80216f6:	e04f      	b.n	8021798 <remove_concurrent_anims+0xbc>

    lv_anim_t * a;
    bool del_any = false;
 80216f8:	2300      	movs	r3, #0
 80216fa:	72fb      	strb	r3, [r7, #11]
    a = _lv_ll_get_head(anim_ll_p);
 80216fc:	4828      	ldr	r0, [pc, #160]	@ (80217a0 <remove_concurrent_anims+0xc4>)
 80216fe:	f001 fd66 	bl	80231ce <_lv_ll_get_head>
 8021702:	60f8      	str	r0, [r7, #12]
    while(a != NULL) {
 8021704:	e044      	b.n	8021790 <remove_concurrent_anims+0xb4>
        bool del = false;
 8021706:	2300      	movs	r3, #0
 8021708:	72bb      	strb	r3, [r7, #10]
        /*We can't test for custom_exec_cb equality because in the MicroPython binding
         *a wrapper callback is used here an the real callback data is stored in the `user_data`.
         *Therefore equality check would remove all animations.*/
        if(a != a_current &&
 802170a:	68fa      	ldr	r2, [r7, #12]
 802170c:	687b      	ldr	r3, [r7, #4]
 802170e:	429a      	cmp	r2, r3
 8021710:	d030      	beq.n	8021774 <remove_concurrent_anims+0x98>
           (a->act_time >= 0 || a->early_apply) &&
 8021712:	68fb      	ldr	r3, [r7, #12]
 8021714:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
        if(a != a_current &&
 8021716:	2b00      	cmp	r3, #0
 8021718:	da07      	bge.n	802172a <remove_concurrent_anims+0x4e>
           (a->act_time >= 0 || a->early_apply) &&
 802171a:	68fb      	ldr	r3, [r7, #12]
 802171c:	f893 304e 	ldrb.w	r3, [r3, #78]	@ 0x4e
 8021720:	f003 0301 	and.w	r3, r3, #1
 8021724:	b2db      	uxtb	r3, r3
 8021726:	2b00      	cmp	r3, #0
 8021728:	d024      	beq.n	8021774 <remove_concurrent_anims+0x98>
           (a->var == a_current->var) &&
 802172a:	68fb      	ldr	r3, [r7, #12]
 802172c:	681a      	ldr	r2, [r3, #0]
 802172e:	687b      	ldr	r3, [r7, #4]
 8021730:	681b      	ldr	r3, [r3, #0]
           (a->act_time >= 0 || a->early_apply) &&
 8021732:	429a      	cmp	r2, r3
 8021734:	d11e      	bne.n	8021774 <remove_concurrent_anims+0x98>
           ((a->exec_cb && a->exec_cb == a_current->exec_cb)
 8021736:	68fb      	ldr	r3, [r7, #12]
 8021738:	685b      	ldr	r3, [r3, #4]
           (a->var == a_current->var) &&
 802173a:	2b00      	cmp	r3, #0
 802173c:	d01a      	beq.n	8021774 <remove_concurrent_anims+0x98>
           ((a->exec_cb && a->exec_cb == a_current->exec_cb)
 802173e:	68fb      	ldr	r3, [r7, #12]
 8021740:	685a      	ldr	r2, [r3, #4]
 8021742:	687b      	ldr	r3, [r7, #4]
 8021744:	685b      	ldr	r3, [r3, #4]
 8021746:	429a      	cmp	r2, r3
 8021748:	d114      	bne.n	8021774 <remove_concurrent_anims+0x98>
            /*|| (a->custom_exec_cb && a->custom_exec_cb == a_current->custom_exec_cb)*/)) {
            _lv_ll_remove(anim_ll_p, a);
 802174a:	68f9      	ldr	r1, [r7, #12]
 802174c:	4814      	ldr	r0, [pc, #80]	@ (80217a0 <remove_concurrent_anims+0xc4>)
 802174e:	f001 fce1 	bl	8023114 <_lv_ll_remove>
            if(a->deleted_cb != NULL) a->deleted_cb(a);
 8021752:	68fb      	ldr	r3, [r7, #12]
 8021754:	695b      	ldr	r3, [r3, #20]
 8021756:	2b00      	cmp	r3, #0
 8021758:	d003      	beq.n	8021762 <remove_concurrent_anims+0x86>
 802175a:	68fb      	ldr	r3, [r7, #12]
 802175c:	695b      	ldr	r3, [r3, #20]
 802175e:	68f8      	ldr	r0, [r7, #12]
 8021760:	4798      	blx	r3
            lv_free(a);
 8021762:	68f8      	ldr	r0, [r7, #12]
 8021764:	f004 fb68 	bl	8025e38 <lv_free>
            /*Read by `anim_timer`. It need to know if a delete occurred in the linked list*/
            anim_mark_list_change();
 8021768:	f7ff feea 	bl	8021540 <anim_mark_list_change>

            del_any = true;
 802176c:	2301      	movs	r3, #1
 802176e:	72fb      	strb	r3, [r7, #11]
            del = true;
 8021770:	2301      	movs	r3, #1
 8021772:	72bb      	strb	r3, [r7, #10]
        }

        /*Always start from the head on delete, because we don't know
         *how `anim_ll_p` was changes in `a->deleted_cb` */
        a = del ? _lv_ll_get_head(anim_ll_p) : _lv_ll_get_next(anim_ll_p, a);
 8021774:	7abb      	ldrb	r3, [r7, #10]
 8021776:	2b00      	cmp	r3, #0
 8021778:	d004      	beq.n	8021784 <remove_concurrent_anims+0xa8>
 802177a:	4809      	ldr	r0, [pc, #36]	@ (80217a0 <remove_concurrent_anims+0xc4>)
 802177c:	f001 fd27 	bl	80231ce <_lv_ll_get_head>
 8021780:	4603      	mov	r3, r0
 8021782:	e004      	b.n	802178e <remove_concurrent_anims+0xb2>
 8021784:	68f9      	ldr	r1, [r7, #12]
 8021786:	4806      	ldr	r0, [pc, #24]	@ (80217a0 <remove_concurrent_anims+0xc4>)
 8021788:	f001 fd43 	bl	8023212 <_lv_ll_get_next>
 802178c:	4603      	mov	r3, r0
 802178e:	60fb      	str	r3, [r7, #12]
    while(a != NULL) {
 8021790:	68fb      	ldr	r3, [r7, #12]
 8021792:	2b00      	cmp	r3, #0
 8021794:	d1b7      	bne.n	8021706 <remove_concurrent_anims+0x2a>
    }

    return del_any;
 8021796:	7afb      	ldrb	r3, [r7, #11]
}
 8021798:	4618      	mov	r0, r3
 802179a:	3710      	adds	r7, #16
 802179c:	46bd      	mov	sp, r7
 802179e:	bd80      	pop	{r7, pc}
 80217a0:	20000154 	.word	0x20000154

080217a4 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline int32_t lv_area_get_width(const lv_area_t * area_p)
{
 80217a4:	b480      	push	{r7}
 80217a6:	b083      	sub	sp, #12
 80217a8:	af00      	add	r7, sp, #0
 80217aa:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 80217ac:	687b      	ldr	r3, [r7, #4]
 80217ae:	689a      	ldr	r2, [r3, #8]
 80217b0:	687b      	ldr	r3, [r7, #4]
 80217b2:	681b      	ldr	r3, [r3, #0]
 80217b4:	1ad3      	subs	r3, r2, r3
 80217b6:	3301      	adds	r3, #1
}
 80217b8:	4618      	mov	r0, r3
 80217ba:	370c      	adds	r7, #12
 80217bc:	46bd      	mov	sp, r7
 80217be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80217c2:	4770      	bx	lr

080217c4 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline int32_t lv_area_get_height(const lv_area_t * area_p)
{
 80217c4:	b480      	push	{r7}
 80217c6:	b083      	sub	sp, #12
 80217c8:	af00      	add	r7, sp, #0
 80217ca:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 80217cc:	687b      	ldr	r3, [r7, #4]
 80217ce:	68da      	ldr	r2, [r3, #12]
 80217d0:	687b      	ldr	r3, [r7, #4]
 80217d2:	685b      	ldr	r3, [r3, #4]
 80217d4:	1ad3      	subs	r3, r2, r3
 80217d6:	3301      	adds	r3, #1
}
 80217d8:	4618      	mov	r0, r3
 80217da:	370c      	adds	r7, #12
 80217dc:	46bd      	mov	sp, r7
 80217de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80217e2:	4770      	bx	lr

080217e4 <lv_point_set>:

    return point;
}

static inline void lv_point_set(lv_point_t * p, int32_t x, int32_t y)
{
 80217e4:	b480      	push	{r7}
 80217e6:	b085      	sub	sp, #20
 80217e8:	af00      	add	r7, sp, #0
 80217ea:	60f8      	str	r0, [r7, #12]
 80217ec:	60b9      	str	r1, [r7, #8]
 80217ee:	607a      	str	r2, [r7, #4]
    p->x = x;
 80217f0:	68fb      	ldr	r3, [r7, #12]
 80217f2:	68ba      	ldr	r2, [r7, #8]
 80217f4:	601a      	str	r2, [r3, #0]
    p->y = y;
 80217f6:	68fb      	ldr	r3, [r7, #12]
 80217f8:	687a      	ldr	r2, [r7, #4]
 80217fa:	605a      	str	r2, [r3, #4]
}
 80217fc:	bf00      	nop
 80217fe:	3714      	adds	r7, #20
 8021800:	46bd      	mov	sp, r7
 8021802:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021806:	4770      	bx	lr

08021808 <lv_area_set>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_area_set(lv_area_t * area_p, int32_t x1, int32_t y1, int32_t x2, int32_t y2)
{
 8021808:	b480      	push	{r7}
 802180a:	b085      	sub	sp, #20
 802180c:	af00      	add	r7, sp, #0
 802180e:	60f8      	str	r0, [r7, #12]
 8021810:	60b9      	str	r1, [r7, #8]
 8021812:	607a      	str	r2, [r7, #4]
 8021814:	603b      	str	r3, [r7, #0]
    area_p->x1 = x1;
 8021816:	68fb      	ldr	r3, [r7, #12]
 8021818:	68ba      	ldr	r2, [r7, #8]
 802181a:	601a      	str	r2, [r3, #0]
    area_p->y1 = y1;
 802181c:	68fb      	ldr	r3, [r7, #12]
 802181e:	687a      	ldr	r2, [r7, #4]
 8021820:	605a      	str	r2, [r3, #4]
    area_p->x2 = x2;
 8021822:	68fb      	ldr	r3, [r7, #12]
 8021824:	683a      	ldr	r2, [r7, #0]
 8021826:	609a      	str	r2, [r3, #8]
    area_p->y2 = y2;
 8021828:	68fb      	ldr	r3, [r7, #12]
 802182a:	69ba      	ldr	r2, [r7, #24]
 802182c:	60da      	str	r2, [r3, #12]
}
 802182e:	bf00      	nop
 8021830:	3714      	adds	r7, #20
 8021832:	46bd      	mov	sp, r7
 8021834:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021838:	4770      	bx	lr

0802183a <lv_area_set_width>:

void lv_area_set_width(lv_area_t * area_p, int32_t w)
{
 802183a:	b480      	push	{r7}
 802183c:	b083      	sub	sp, #12
 802183e:	af00      	add	r7, sp, #0
 8021840:	6078      	str	r0, [r7, #4]
 8021842:	6039      	str	r1, [r7, #0]
    area_p->x2 = area_p->x1 + w - 1;
 8021844:	687b      	ldr	r3, [r7, #4]
 8021846:	681a      	ldr	r2, [r3, #0]
 8021848:	683b      	ldr	r3, [r7, #0]
 802184a:	4413      	add	r3, r2
 802184c:	1e5a      	subs	r2, r3, #1
 802184e:	687b      	ldr	r3, [r7, #4]
 8021850:	609a      	str	r2, [r3, #8]
}
 8021852:	bf00      	nop
 8021854:	370c      	adds	r7, #12
 8021856:	46bd      	mov	sp, r7
 8021858:	f85d 7b04 	ldr.w	r7, [sp], #4
 802185c:	4770      	bx	lr

0802185e <lv_area_set_height>:

void lv_area_set_height(lv_area_t * area_p, int32_t h)
{
 802185e:	b480      	push	{r7}
 8021860:	b083      	sub	sp, #12
 8021862:	af00      	add	r7, sp, #0
 8021864:	6078      	str	r0, [r7, #4]
 8021866:	6039      	str	r1, [r7, #0]
    area_p->y2 = area_p->y1 + h - 1;
 8021868:	687b      	ldr	r3, [r7, #4]
 802186a:	685a      	ldr	r2, [r3, #4]
 802186c:	683b      	ldr	r3, [r7, #0]
 802186e:	4413      	add	r3, r2
 8021870:	1e5a      	subs	r2, r3, #1
 8021872:	687b      	ldr	r3, [r7, #4]
 8021874:	60da      	str	r2, [r3, #12]
}
 8021876:	bf00      	nop
 8021878:	370c      	adds	r7, #12
 802187a:	46bd      	mov	sp, r7
 802187c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021880:	4770      	bx	lr

08021882 <lv_area_get_size>:
    lv_area_set_width(area_p, w);
    lv_area_set_height(area_p, h);
}

uint32_t lv_area_get_size(const lv_area_t * area_p)
{
 8021882:	b480      	push	{r7}
 8021884:	b085      	sub	sp, #20
 8021886:	af00      	add	r7, sp, #0
 8021888:	6078      	str	r0, [r7, #4]
    uint32_t size;

    size = (uint32_t)(area_p->x2 - area_p->x1 + 1) * (area_p->y2 - area_p->y1 + 1);
 802188a:	687b      	ldr	r3, [r7, #4]
 802188c:	689a      	ldr	r2, [r3, #8]
 802188e:	687b      	ldr	r3, [r7, #4]
 8021890:	681b      	ldr	r3, [r3, #0]
 8021892:	1ad3      	subs	r3, r2, r3
 8021894:	3301      	adds	r3, #1
 8021896:	4619      	mov	r1, r3
 8021898:	687b      	ldr	r3, [r7, #4]
 802189a:	68da      	ldr	r2, [r3, #12]
 802189c:	687b      	ldr	r3, [r7, #4]
 802189e:	685b      	ldr	r3, [r3, #4]
 80218a0:	1ad3      	subs	r3, r2, r3
 80218a2:	3301      	adds	r3, #1
 80218a4:	fb01 f303 	mul.w	r3, r1, r3
 80218a8:	60fb      	str	r3, [r7, #12]

    return size;
 80218aa:	68fb      	ldr	r3, [r7, #12]
}
 80218ac:	4618      	mov	r0, r3
 80218ae:	3714      	adds	r7, #20
 80218b0:	46bd      	mov	sp, r7
 80218b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80218b6:	4770      	bx	lr

080218b8 <lv_area_increase>:

void lv_area_increase(lv_area_t * area, int32_t w_extra, int32_t h_extra)
{
 80218b8:	b480      	push	{r7}
 80218ba:	b085      	sub	sp, #20
 80218bc:	af00      	add	r7, sp, #0
 80218be:	60f8      	str	r0, [r7, #12]
 80218c0:	60b9      	str	r1, [r7, #8]
 80218c2:	607a      	str	r2, [r7, #4]
    area->x1 -= w_extra;
 80218c4:	68fb      	ldr	r3, [r7, #12]
 80218c6:	681a      	ldr	r2, [r3, #0]
 80218c8:	68bb      	ldr	r3, [r7, #8]
 80218ca:	1ad2      	subs	r2, r2, r3
 80218cc:	68fb      	ldr	r3, [r7, #12]
 80218ce:	601a      	str	r2, [r3, #0]
    area->x2 += w_extra;
 80218d0:	68fb      	ldr	r3, [r7, #12]
 80218d2:	689a      	ldr	r2, [r3, #8]
 80218d4:	68bb      	ldr	r3, [r7, #8]
 80218d6:	441a      	add	r2, r3
 80218d8:	68fb      	ldr	r3, [r7, #12]
 80218da:	609a      	str	r2, [r3, #8]
    area->y1 -= h_extra;
 80218dc:	68fb      	ldr	r3, [r7, #12]
 80218de:	685a      	ldr	r2, [r3, #4]
 80218e0:	687b      	ldr	r3, [r7, #4]
 80218e2:	1ad2      	subs	r2, r2, r3
 80218e4:	68fb      	ldr	r3, [r7, #12]
 80218e6:	605a      	str	r2, [r3, #4]
    area->y2 += h_extra;
 80218e8:	68fb      	ldr	r3, [r7, #12]
 80218ea:	68da      	ldr	r2, [r3, #12]
 80218ec:	687b      	ldr	r3, [r7, #4]
 80218ee:	441a      	add	r2, r3
 80218f0:	68fb      	ldr	r3, [r7, #12]
 80218f2:	60da      	str	r2, [r3, #12]
}
 80218f4:	bf00      	nop
 80218f6:	3714      	adds	r7, #20
 80218f8:	46bd      	mov	sp, r7
 80218fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80218fe:	4770      	bx	lr

08021900 <lv_area_move>:

void lv_area_move(lv_area_t * area, int32_t x_ofs, int32_t y_ofs)
{
 8021900:	b480      	push	{r7}
 8021902:	b085      	sub	sp, #20
 8021904:	af00      	add	r7, sp, #0
 8021906:	60f8      	str	r0, [r7, #12]
 8021908:	60b9      	str	r1, [r7, #8]
 802190a:	607a      	str	r2, [r7, #4]
    area->x1 += x_ofs;
 802190c:	68fb      	ldr	r3, [r7, #12]
 802190e:	681a      	ldr	r2, [r3, #0]
 8021910:	68bb      	ldr	r3, [r7, #8]
 8021912:	441a      	add	r2, r3
 8021914:	68fb      	ldr	r3, [r7, #12]
 8021916:	601a      	str	r2, [r3, #0]
    area->x2 += x_ofs;
 8021918:	68fb      	ldr	r3, [r7, #12]
 802191a:	689a      	ldr	r2, [r3, #8]
 802191c:	68bb      	ldr	r3, [r7, #8]
 802191e:	441a      	add	r2, r3
 8021920:	68fb      	ldr	r3, [r7, #12]
 8021922:	609a      	str	r2, [r3, #8]
    area->y1 += y_ofs;
 8021924:	68fb      	ldr	r3, [r7, #12]
 8021926:	685a      	ldr	r2, [r3, #4]
 8021928:	687b      	ldr	r3, [r7, #4]
 802192a:	441a      	add	r2, r3
 802192c:	68fb      	ldr	r3, [r7, #12]
 802192e:	605a      	str	r2, [r3, #4]
    area->y2 += y_ofs;
 8021930:	68fb      	ldr	r3, [r7, #12]
 8021932:	68da      	ldr	r2, [r3, #12]
 8021934:	687b      	ldr	r3, [r7, #4]
 8021936:	441a      	add	r2, r3
 8021938:	68fb      	ldr	r3, [r7, #12]
 802193a:	60da      	str	r2, [r3, #12]
}
 802193c:	bf00      	nop
 802193e:	3714      	adds	r7, #20
 8021940:	46bd      	mov	sp, r7
 8021942:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021946:	4770      	bx	lr

08021948 <_lv_area_intersect>:

bool _lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 8021948:	b480      	push	{r7}
 802194a:	b087      	sub	sp, #28
 802194c:	af00      	add	r7, sp, #0
 802194e:	60f8      	str	r0, [r7, #12]
 8021950:	60b9      	str	r1, [r7, #8]
 8021952:	607a      	str	r2, [r7, #4]
    /*Get the smaller area from 'a1_p' and 'a2_p'*/
    res_p->x1 = LV_MAX(a1_p->x1, a2_p->x1);
 8021954:	687b      	ldr	r3, [r7, #4]
 8021956:	681a      	ldr	r2, [r3, #0]
 8021958:	68bb      	ldr	r3, [r7, #8]
 802195a:	681b      	ldr	r3, [r3, #0]
 802195c:	429a      	cmp	r2, r3
 802195e:	bfb8      	it	lt
 8021960:	461a      	movlt	r2, r3
 8021962:	68fb      	ldr	r3, [r7, #12]
 8021964:	601a      	str	r2, [r3, #0]
    res_p->y1 = LV_MAX(a1_p->y1, a2_p->y1);
 8021966:	687b      	ldr	r3, [r7, #4]
 8021968:	685a      	ldr	r2, [r3, #4]
 802196a:	68bb      	ldr	r3, [r7, #8]
 802196c:	685b      	ldr	r3, [r3, #4]
 802196e:	429a      	cmp	r2, r3
 8021970:	bfb8      	it	lt
 8021972:	461a      	movlt	r2, r3
 8021974:	68fb      	ldr	r3, [r7, #12]
 8021976:	605a      	str	r2, [r3, #4]
    res_p->x2 = LV_MIN(a1_p->x2, a2_p->x2);
 8021978:	687b      	ldr	r3, [r7, #4]
 802197a:	689a      	ldr	r2, [r3, #8]
 802197c:	68bb      	ldr	r3, [r7, #8]
 802197e:	689b      	ldr	r3, [r3, #8]
 8021980:	429a      	cmp	r2, r3
 8021982:	bfa8      	it	ge
 8021984:	461a      	movge	r2, r3
 8021986:	68fb      	ldr	r3, [r7, #12]
 8021988:	609a      	str	r2, [r3, #8]
    res_p->y2 = LV_MIN(a1_p->y2, a2_p->y2);
 802198a:	687b      	ldr	r3, [r7, #4]
 802198c:	68da      	ldr	r2, [r3, #12]
 802198e:	68bb      	ldr	r3, [r7, #8]
 8021990:	68db      	ldr	r3, [r3, #12]
 8021992:	429a      	cmp	r2, r3
 8021994:	bfa8      	it	ge
 8021996:	461a      	movge	r2, r3
 8021998:	68fb      	ldr	r3, [r7, #12]
 802199a:	60da      	str	r2, [r3, #12]

    /*If x1 or y1 greater than x2 or y2 then the areas union is empty*/
    bool union_ok = true;
 802199c:	2301      	movs	r3, #1
 802199e:	75fb      	strb	r3, [r7, #23]
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
 80219a0:	68fb      	ldr	r3, [r7, #12]
 80219a2:	681a      	ldr	r2, [r3, #0]
 80219a4:	68fb      	ldr	r3, [r7, #12]
 80219a6:	689b      	ldr	r3, [r3, #8]
 80219a8:	429a      	cmp	r2, r3
 80219aa:	dc05      	bgt.n	80219b8 <_lv_area_intersect+0x70>
 80219ac:	68fb      	ldr	r3, [r7, #12]
 80219ae:	685a      	ldr	r2, [r3, #4]
 80219b0:	68fb      	ldr	r3, [r7, #12]
 80219b2:	68db      	ldr	r3, [r3, #12]
 80219b4:	429a      	cmp	r2, r3
 80219b6:	dd01      	ble.n	80219bc <_lv_area_intersect+0x74>
        union_ok = false;
 80219b8:	2300      	movs	r3, #0
 80219ba:	75fb      	strb	r3, [r7, #23]
    }

    return union_ok;
 80219bc:	7dfb      	ldrb	r3, [r7, #23]
}
 80219be:	4618      	mov	r0, r3
 80219c0:	371c      	adds	r7, #28
 80219c2:	46bd      	mov	sp, r7
 80219c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80219c8:	4770      	bx	lr

080219ca <_lv_area_is_point_on>:
    a_res_p->x2 = LV_MAX(a1_p->x2, a2_p->x2);
    a_res_p->y2 = LV_MAX(a1_p->y2, a2_p->y2);
}

bool _lv_area_is_point_on(const lv_area_t * a_p, const lv_point_t * p_p, int32_t radius)
{
 80219ca:	b580      	push	{r7, lr}
 80219cc:	b08c      	sub	sp, #48	@ 0x30
 80219ce:	af00      	add	r7, sp, #0
 80219d0:	60f8      	str	r0, [r7, #12]
 80219d2:	60b9      	str	r1, [r7, #8]
 80219d4:	607a      	str	r2, [r7, #4]
    /*First check the basic area*/
    bool is_on_rect = false;
 80219d6:	2300      	movs	r3, #0
 80219d8:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if((p_p->x >= a_p->x1 && p_p->x <= a_p->x2) && ((p_p->y >= a_p->y1 && p_p->y <= a_p->y2))) {
 80219dc:	68bb      	ldr	r3, [r7, #8]
 80219de:	681a      	ldr	r2, [r3, #0]
 80219e0:	68fb      	ldr	r3, [r7, #12]
 80219e2:	681b      	ldr	r3, [r3, #0]
 80219e4:	429a      	cmp	r2, r3
 80219e6:	db14      	blt.n	8021a12 <_lv_area_is_point_on+0x48>
 80219e8:	68bb      	ldr	r3, [r7, #8]
 80219ea:	681a      	ldr	r2, [r3, #0]
 80219ec:	68fb      	ldr	r3, [r7, #12]
 80219ee:	689b      	ldr	r3, [r3, #8]
 80219f0:	429a      	cmp	r2, r3
 80219f2:	dc0e      	bgt.n	8021a12 <_lv_area_is_point_on+0x48>
 80219f4:	68bb      	ldr	r3, [r7, #8]
 80219f6:	685a      	ldr	r2, [r3, #4]
 80219f8:	68fb      	ldr	r3, [r7, #12]
 80219fa:	685b      	ldr	r3, [r3, #4]
 80219fc:	429a      	cmp	r2, r3
 80219fe:	db08      	blt.n	8021a12 <_lv_area_is_point_on+0x48>
 8021a00:	68bb      	ldr	r3, [r7, #8]
 8021a02:	685a      	ldr	r2, [r3, #4]
 8021a04:	68fb      	ldr	r3, [r7, #12]
 8021a06:	68db      	ldr	r3, [r3, #12]
 8021a08:	429a      	cmp	r2, r3
 8021a0a:	dc02      	bgt.n	8021a12 <_lv_area_is_point_on+0x48>
        is_on_rect = true;
 8021a0c:	2301      	movs	r3, #1
 8021a0e:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    }
    if(!is_on_rect)
 8021a12:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8021a16:	f083 0301 	eor.w	r3, r3, #1
 8021a1a:	b2db      	uxtb	r3, r3
 8021a1c:	2b00      	cmp	r3, #0
 8021a1e:	d001      	beq.n	8021a24 <_lv_area_is_point_on+0x5a>
        return false;
 8021a20:	2300      	movs	r3, #0
 8021a22:	e0b1      	b.n	8021b88 <_lv_area_is_point_on+0x1be>
    /*Now handle potential rounded rectangles*/
    if(radius <= 0) {
 8021a24:	687b      	ldr	r3, [r7, #4]
 8021a26:	2b00      	cmp	r3, #0
 8021a28:	dc01      	bgt.n	8021a2e <_lv_area_is_point_on+0x64>
        /*No radius, it is within the rectangle*/
        return true;
 8021a2a:	2301      	movs	r3, #1
 8021a2c:	e0ac      	b.n	8021b88 <_lv_area_is_point_on+0x1be>
    }
    int32_t w = lv_area_get_width(a_p) / 2;
 8021a2e:	68f8      	ldr	r0, [r7, #12]
 8021a30:	f7ff feb8 	bl	80217a4 <lv_area_get_width>
 8021a34:	4603      	mov	r3, r0
 8021a36:	0fda      	lsrs	r2, r3, #31
 8021a38:	4413      	add	r3, r2
 8021a3a:	105b      	asrs	r3, r3, #1
 8021a3c:	62bb      	str	r3, [r7, #40]	@ 0x28
    int32_t h = lv_area_get_height(a_p) / 2;
 8021a3e:	68f8      	ldr	r0, [r7, #12]
 8021a40:	f7ff fec0 	bl	80217c4 <lv_area_get_height>
 8021a44:	4603      	mov	r3, r0
 8021a46:	0fda      	lsrs	r2, r3, #31
 8021a48:	4413      	add	r3, r2
 8021a4a:	105b      	asrs	r3, r3, #1
 8021a4c:	627b      	str	r3, [r7, #36]	@ 0x24
    int32_t max_radius = LV_MIN(w, h);
 8021a4e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8021a50:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8021a52:	4293      	cmp	r3, r2
 8021a54:	bfa8      	it	ge
 8021a56:	4613      	movge	r3, r2
 8021a58:	623b      	str	r3, [r7, #32]
    if(radius > max_radius)
 8021a5a:	687a      	ldr	r2, [r7, #4]
 8021a5c:	6a3b      	ldr	r3, [r7, #32]
 8021a5e:	429a      	cmp	r2, r3
 8021a60:	dd01      	ble.n	8021a66 <_lv_area_is_point_on+0x9c>
        radius = max_radius;
 8021a62:	6a3b      	ldr	r3, [r7, #32]
 8021a64:	607b      	str	r3, [r7, #4]

    /*Check if it's in one of the corners*/
    lv_area_t corner_area;
    /*Top left*/
    corner_area.x1 = a_p->x1;
 8021a66:	68fb      	ldr	r3, [r7, #12]
 8021a68:	681b      	ldr	r3, [r3, #0]
 8021a6a:	613b      	str	r3, [r7, #16]
    corner_area.x2 = a_p->x1 + radius;
 8021a6c:	68fb      	ldr	r3, [r7, #12]
 8021a6e:	681a      	ldr	r2, [r3, #0]
 8021a70:	687b      	ldr	r3, [r7, #4]
 8021a72:	4413      	add	r3, r2
 8021a74:	61bb      	str	r3, [r7, #24]
    corner_area.y1 = a_p->y1;
 8021a76:	68fb      	ldr	r3, [r7, #12]
 8021a78:	685b      	ldr	r3, [r3, #4]
 8021a7a:	617b      	str	r3, [r7, #20]
    corner_area.y2 = a_p->y1 + radius;
 8021a7c:	68fb      	ldr	r3, [r7, #12]
 8021a7e:	685a      	ldr	r2, [r3, #4]
 8021a80:	687b      	ldr	r3, [r7, #4]
 8021a82:	4413      	add	r3, r2
 8021a84:	61fb      	str	r3, [r7, #28]
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
 8021a86:	f107 0310 	add.w	r3, r7, #16
 8021a8a:	2200      	movs	r2, #0
 8021a8c:	68b9      	ldr	r1, [r7, #8]
 8021a8e:	4618      	mov	r0, r3
 8021a90:	f7ff ff9b 	bl	80219ca <_lv_area_is_point_on>
 8021a94:	4603      	mov	r3, r0
 8021a96:	2b00      	cmp	r3, #0
 8021a98:	d00f      	beq.n	8021aba <_lv_area_is_point_on+0xf0>
        corner_area.x2 += radius;
 8021a9a:	69ba      	ldr	r2, [r7, #24]
 8021a9c:	687b      	ldr	r3, [r7, #4]
 8021a9e:	4413      	add	r3, r2
 8021aa0:	61bb      	str	r3, [r7, #24]
        corner_area.y2 += radius;
 8021aa2:	69fa      	ldr	r2, [r7, #28]
 8021aa4:	687b      	ldr	r3, [r7, #4]
 8021aa6:	4413      	add	r3, r2
 8021aa8:	61fb      	str	r3, [r7, #28]
        return lv_point_within_circle(&corner_area, p_p);
 8021aaa:	f107 0310 	add.w	r3, r7, #16
 8021aae:	68b9      	ldr	r1, [r7, #8]
 8021ab0:	4618      	mov	r0, r3
 8021ab2:	f000 fcb3 	bl	802241c <lv_point_within_circle>
 8021ab6:	4603      	mov	r3, r0
 8021ab8:	e066      	b.n	8021b88 <_lv_area_is_point_on+0x1be>
    }
    /*Bottom left*/
    corner_area.y1 = a_p->y2 - radius;
 8021aba:	68fb      	ldr	r3, [r7, #12]
 8021abc:	68da      	ldr	r2, [r3, #12]
 8021abe:	687b      	ldr	r3, [r7, #4]
 8021ac0:	1ad3      	subs	r3, r2, r3
 8021ac2:	617b      	str	r3, [r7, #20]
    corner_area.y2 = a_p->y2;
 8021ac4:	68fb      	ldr	r3, [r7, #12]
 8021ac6:	68db      	ldr	r3, [r3, #12]
 8021ac8:	61fb      	str	r3, [r7, #28]
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
 8021aca:	f107 0310 	add.w	r3, r7, #16
 8021ace:	2200      	movs	r2, #0
 8021ad0:	68b9      	ldr	r1, [r7, #8]
 8021ad2:	4618      	mov	r0, r3
 8021ad4:	f7ff ff79 	bl	80219ca <_lv_area_is_point_on>
 8021ad8:	4603      	mov	r3, r0
 8021ada:	2b00      	cmp	r3, #0
 8021adc:	d00f      	beq.n	8021afe <_lv_area_is_point_on+0x134>
        corner_area.x2 += radius;
 8021ade:	69ba      	ldr	r2, [r7, #24]
 8021ae0:	687b      	ldr	r3, [r7, #4]
 8021ae2:	4413      	add	r3, r2
 8021ae4:	61bb      	str	r3, [r7, #24]
        corner_area.y1 -= radius;
 8021ae6:	697a      	ldr	r2, [r7, #20]
 8021ae8:	687b      	ldr	r3, [r7, #4]
 8021aea:	1ad3      	subs	r3, r2, r3
 8021aec:	617b      	str	r3, [r7, #20]
        return lv_point_within_circle(&corner_area, p_p);
 8021aee:	f107 0310 	add.w	r3, r7, #16
 8021af2:	68b9      	ldr	r1, [r7, #8]
 8021af4:	4618      	mov	r0, r3
 8021af6:	f000 fc91 	bl	802241c <lv_point_within_circle>
 8021afa:	4603      	mov	r3, r0
 8021afc:	e044      	b.n	8021b88 <_lv_area_is_point_on+0x1be>
    }
    /*Bottom right*/
    corner_area.x1 = a_p->x2 - radius;
 8021afe:	68fb      	ldr	r3, [r7, #12]
 8021b00:	689a      	ldr	r2, [r3, #8]
 8021b02:	687b      	ldr	r3, [r7, #4]
 8021b04:	1ad3      	subs	r3, r2, r3
 8021b06:	613b      	str	r3, [r7, #16]
    corner_area.x2 = a_p->x2;
 8021b08:	68fb      	ldr	r3, [r7, #12]
 8021b0a:	689b      	ldr	r3, [r3, #8]
 8021b0c:	61bb      	str	r3, [r7, #24]
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
 8021b0e:	f107 0310 	add.w	r3, r7, #16
 8021b12:	2200      	movs	r2, #0
 8021b14:	68b9      	ldr	r1, [r7, #8]
 8021b16:	4618      	mov	r0, r3
 8021b18:	f7ff ff57 	bl	80219ca <_lv_area_is_point_on>
 8021b1c:	4603      	mov	r3, r0
 8021b1e:	2b00      	cmp	r3, #0
 8021b20:	d00f      	beq.n	8021b42 <_lv_area_is_point_on+0x178>
        corner_area.x1 -= radius;
 8021b22:	693a      	ldr	r2, [r7, #16]
 8021b24:	687b      	ldr	r3, [r7, #4]
 8021b26:	1ad3      	subs	r3, r2, r3
 8021b28:	613b      	str	r3, [r7, #16]
        corner_area.y1 -= radius;
 8021b2a:	697a      	ldr	r2, [r7, #20]
 8021b2c:	687b      	ldr	r3, [r7, #4]
 8021b2e:	1ad3      	subs	r3, r2, r3
 8021b30:	617b      	str	r3, [r7, #20]
        return lv_point_within_circle(&corner_area, p_p);
 8021b32:	f107 0310 	add.w	r3, r7, #16
 8021b36:	68b9      	ldr	r1, [r7, #8]
 8021b38:	4618      	mov	r0, r3
 8021b3a:	f000 fc6f 	bl	802241c <lv_point_within_circle>
 8021b3e:	4603      	mov	r3, r0
 8021b40:	e022      	b.n	8021b88 <_lv_area_is_point_on+0x1be>
    }
    /*Top right*/
    corner_area.y1 = a_p->y1;
 8021b42:	68fb      	ldr	r3, [r7, #12]
 8021b44:	685b      	ldr	r3, [r3, #4]
 8021b46:	617b      	str	r3, [r7, #20]
    corner_area.y2 = a_p->y1 + radius;
 8021b48:	68fb      	ldr	r3, [r7, #12]
 8021b4a:	685a      	ldr	r2, [r3, #4]
 8021b4c:	687b      	ldr	r3, [r7, #4]
 8021b4e:	4413      	add	r3, r2
 8021b50:	61fb      	str	r3, [r7, #28]
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
 8021b52:	f107 0310 	add.w	r3, r7, #16
 8021b56:	2200      	movs	r2, #0
 8021b58:	68b9      	ldr	r1, [r7, #8]
 8021b5a:	4618      	mov	r0, r3
 8021b5c:	f7ff ff35 	bl	80219ca <_lv_area_is_point_on>
 8021b60:	4603      	mov	r3, r0
 8021b62:	2b00      	cmp	r3, #0
 8021b64:	d00f      	beq.n	8021b86 <_lv_area_is_point_on+0x1bc>
        corner_area.x1 -= radius;
 8021b66:	693a      	ldr	r2, [r7, #16]
 8021b68:	687b      	ldr	r3, [r7, #4]
 8021b6a:	1ad3      	subs	r3, r2, r3
 8021b6c:	613b      	str	r3, [r7, #16]
        corner_area.y2 += radius;
 8021b6e:	69fa      	ldr	r2, [r7, #28]
 8021b70:	687b      	ldr	r3, [r7, #4]
 8021b72:	4413      	add	r3, r2
 8021b74:	61fb      	str	r3, [r7, #28]
        return lv_point_within_circle(&corner_area, p_p);
 8021b76:	f107 0310 	add.w	r3, r7, #16
 8021b7a:	68b9      	ldr	r1, [r7, #8]
 8021b7c:	4618      	mov	r0, r3
 8021b7e:	f000 fc4d 	bl	802241c <lv_point_within_circle>
 8021b82:	4603      	mov	r3, r0
 8021b84:	e000      	b.n	8021b88 <_lv_area_is_point_on+0x1be>
    }
    /*Not within corners*/
    return true;
 8021b86:	2301      	movs	r3, #1
}
 8021b88:	4618      	mov	r0, r3
 8021b8a:	3730      	adds	r7, #48	@ 0x30
 8021b8c:	46bd      	mov	sp, r7
 8021b8e:	bd80      	pop	{r7, pc}

08021b90 <_lv_area_is_in>:
        return false;
    }
}

bool _lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p, int32_t radius)
{
 8021b90:	b580      	push	{r7, lr}
 8021b92:	b088      	sub	sp, #32
 8021b94:	af00      	add	r7, sp, #0
 8021b96:	60f8      	str	r0, [r7, #12]
 8021b98:	60b9      	str	r1, [r7, #8]
 8021b9a:	607a      	str	r2, [r7, #4]
    bool is_in = false;
 8021b9c:	2300      	movs	r3, #0
 8021b9e:	77fb      	strb	r3, [r7, #31]

    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
 8021ba0:	68fb      	ldr	r3, [r7, #12]
 8021ba2:	681a      	ldr	r2, [r3, #0]
 8021ba4:	68bb      	ldr	r3, [r7, #8]
 8021ba6:	681b      	ldr	r3, [r3, #0]
 8021ba8:	429a      	cmp	r2, r3
 8021baa:	db13      	blt.n	8021bd4 <_lv_area_is_in+0x44>
 8021bac:	68fb      	ldr	r3, [r7, #12]
 8021bae:	685a      	ldr	r2, [r3, #4]
 8021bb0:	68bb      	ldr	r3, [r7, #8]
 8021bb2:	685b      	ldr	r3, [r3, #4]
 8021bb4:	429a      	cmp	r2, r3
 8021bb6:	db0d      	blt.n	8021bd4 <_lv_area_is_in+0x44>
 8021bb8:	68fb      	ldr	r3, [r7, #12]
 8021bba:	689a      	ldr	r2, [r3, #8]
 8021bbc:	68bb      	ldr	r3, [r7, #8]
 8021bbe:	689b      	ldr	r3, [r3, #8]
 8021bc0:	429a      	cmp	r2, r3
 8021bc2:	dc07      	bgt.n	8021bd4 <_lv_area_is_in+0x44>
       ain_p->y2 <= aholder_p->y2) {
 8021bc4:	68fb      	ldr	r3, [r7, #12]
 8021bc6:	68da      	ldr	r2, [r3, #12]
 8021bc8:	68bb      	ldr	r3, [r7, #8]
 8021bca:	68db      	ldr	r3, [r3, #12]
    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
 8021bcc:	429a      	cmp	r2, r3
 8021bce:	dc01      	bgt.n	8021bd4 <_lv_area_is_in+0x44>
        is_in = true;
 8021bd0:	2301      	movs	r3, #1
 8021bd2:	77fb      	strb	r3, [r7, #31]
    }

    if(!is_in) return false;
 8021bd4:	7ffb      	ldrb	r3, [r7, #31]
 8021bd6:	f083 0301 	eor.w	r3, r3, #1
 8021bda:	b2db      	uxtb	r3, r3
 8021bdc:	2b00      	cmp	r3, #0
 8021bde:	d001      	beq.n	8021be4 <_lv_area_is_in+0x54>
 8021be0:	2300      	movs	r3, #0
 8021be2:	e065      	b.n	8021cb0 <_lv_area_is_in+0x120>
    if(radius == 0) return true;
 8021be4:	687b      	ldr	r3, [r7, #4]
 8021be6:	2b00      	cmp	r3, #0
 8021be8:	d101      	bne.n	8021bee <_lv_area_is_in+0x5e>
 8021bea:	2301      	movs	r3, #1
 8021bec:	e060      	b.n	8021cb0 <_lv_area_is_in+0x120>

    /*Check if the corner points are inside the radius or not*/
    lv_point_t p;

    lv_point_set(&p, ain_p->x1, ain_p->y1);
 8021bee:	68fb      	ldr	r3, [r7, #12]
 8021bf0:	6819      	ldr	r1, [r3, #0]
 8021bf2:	68fb      	ldr	r3, [r7, #12]
 8021bf4:	685a      	ldr	r2, [r3, #4]
 8021bf6:	f107 0314 	add.w	r3, r7, #20
 8021bfa:	4618      	mov	r0, r3
 8021bfc:	f7ff fdf2 	bl	80217e4 <lv_point_set>
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
 8021c00:	f107 0314 	add.w	r3, r7, #20
 8021c04:	687a      	ldr	r2, [r7, #4]
 8021c06:	4619      	mov	r1, r3
 8021c08:	68b8      	ldr	r0, [r7, #8]
 8021c0a:	f7ff fede 	bl	80219ca <_lv_area_is_point_on>
 8021c0e:	4603      	mov	r3, r0
 8021c10:	f083 0301 	eor.w	r3, r3, #1
 8021c14:	b2db      	uxtb	r3, r3
 8021c16:	2b00      	cmp	r3, #0
 8021c18:	d001      	beq.n	8021c1e <_lv_area_is_in+0x8e>
 8021c1a:	2300      	movs	r3, #0
 8021c1c:	e048      	b.n	8021cb0 <_lv_area_is_in+0x120>

    lv_point_set(&p, ain_p->x2, ain_p->y1);
 8021c1e:	68fb      	ldr	r3, [r7, #12]
 8021c20:	6899      	ldr	r1, [r3, #8]
 8021c22:	68fb      	ldr	r3, [r7, #12]
 8021c24:	685a      	ldr	r2, [r3, #4]
 8021c26:	f107 0314 	add.w	r3, r7, #20
 8021c2a:	4618      	mov	r0, r3
 8021c2c:	f7ff fdda 	bl	80217e4 <lv_point_set>
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
 8021c30:	f107 0314 	add.w	r3, r7, #20
 8021c34:	687a      	ldr	r2, [r7, #4]
 8021c36:	4619      	mov	r1, r3
 8021c38:	68b8      	ldr	r0, [r7, #8]
 8021c3a:	f7ff fec6 	bl	80219ca <_lv_area_is_point_on>
 8021c3e:	4603      	mov	r3, r0
 8021c40:	f083 0301 	eor.w	r3, r3, #1
 8021c44:	b2db      	uxtb	r3, r3
 8021c46:	2b00      	cmp	r3, #0
 8021c48:	d001      	beq.n	8021c4e <_lv_area_is_in+0xbe>
 8021c4a:	2300      	movs	r3, #0
 8021c4c:	e030      	b.n	8021cb0 <_lv_area_is_in+0x120>

    lv_point_set(&p, ain_p->x1, ain_p->y2);
 8021c4e:	68fb      	ldr	r3, [r7, #12]
 8021c50:	6819      	ldr	r1, [r3, #0]
 8021c52:	68fb      	ldr	r3, [r7, #12]
 8021c54:	68da      	ldr	r2, [r3, #12]
 8021c56:	f107 0314 	add.w	r3, r7, #20
 8021c5a:	4618      	mov	r0, r3
 8021c5c:	f7ff fdc2 	bl	80217e4 <lv_point_set>
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
 8021c60:	f107 0314 	add.w	r3, r7, #20
 8021c64:	687a      	ldr	r2, [r7, #4]
 8021c66:	4619      	mov	r1, r3
 8021c68:	68b8      	ldr	r0, [r7, #8]
 8021c6a:	f7ff feae 	bl	80219ca <_lv_area_is_point_on>
 8021c6e:	4603      	mov	r3, r0
 8021c70:	f083 0301 	eor.w	r3, r3, #1
 8021c74:	b2db      	uxtb	r3, r3
 8021c76:	2b00      	cmp	r3, #0
 8021c78:	d001      	beq.n	8021c7e <_lv_area_is_in+0xee>
 8021c7a:	2300      	movs	r3, #0
 8021c7c:	e018      	b.n	8021cb0 <_lv_area_is_in+0x120>

    lv_point_set(&p, ain_p->x2, ain_p->y2);
 8021c7e:	68fb      	ldr	r3, [r7, #12]
 8021c80:	6899      	ldr	r1, [r3, #8]
 8021c82:	68fb      	ldr	r3, [r7, #12]
 8021c84:	68da      	ldr	r2, [r3, #12]
 8021c86:	f107 0314 	add.w	r3, r7, #20
 8021c8a:	4618      	mov	r0, r3
 8021c8c:	f7ff fdaa 	bl	80217e4 <lv_point_set>
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
 8021c90:	f107 0314 	add.w	r3, r7, #20
 8021c94:	687a      	ldr	r2, [r7, #4]
 8021c96:	4619      	mov	r1, r3
 8021c98:	68b8      	ldr	r0, [r7, #8]
 8021c9a:	f7ff fe96 	bl	80219ca <_lv_area_is_point_on>
 8021c9e:	4603      	mov	r3, r0
 8021ca0:	f083 0301 	eor.w	r3, r3, #1
 8021ca4:	b2db      	uxtb	r3, r3
 8021ca6:	2b00      	cmp	r3, #0
 8021ca8:	d001      	beq.n	8021cae <_lv_area_is_in+0x11e>
 8021caa:	2300      	movs	r3, #0
 8021cac:	e000      	b.n	8021cb0 <_lv_area_is_in+0x120>

    return true;
 8021cae:	2301      	movs	r3, #1
}
 8021cb0:	4618      	mov	r0, r3
 8021cb2:	3720      	adds	r7, #32
 8021cb4:	46bd      	mov	sp, r7
 8021cb6:	bd80      	pop	{r7, pc}

08021cb8 <_lv_area_is_out>:

bool _lv_area_is_out(const lv_area_t * aout_p, const lv_area_t * aholder_p, int32_t radius)
{
 8021cb8:	b580      	push	{r7, lr}
 8021cba:	b086      	sub	sp, #24
 8021cbc:	af00      	add	r7, sp, #0
 8021cbe:	60f8      	str	r0, [r7, #12]
 8021cc0:	60b9      	str	r1, [r7, #8]
 8021cc2:	607a      	str	r2, [r7, #4]
    if(aout_p->x2 < aholder_p->x1 || aout_p->y2 < aholder_p->y1 || aout_p->x1 > aholder_p->x2 ||
 8021cc4:	68fb      	ldr	r3, [r7, #12]
 8021cc6:	689a      	ldr	r2, [r3, #8]
 8021cc8:	68bb      	ldr	r3, [r7, #8]
 8021cca:	681b      	ldr	r3, [r3, #0]
 8021ccc:	429a      	cmp	r2, r3
 8021cce:	db11      	blt.n	8021cf4 <_lv_area_is_out+0x3c>
 8021cd0:	68fb      	ldr	r3, [r7, #12]
 8021cd2:	68da      	ldr	r2, [r3, #12]
 8021cd4:	68bb      	ldr	r3, [r7, #8]
 8021cd6:	685b      	ldr	r3, [r3, #4]
 8021cd8:	429a      	cmp	r2, r3
 8021cda:	db0b      	blt.n	8021cf4 <_lv_area_is_out+0x3c>
 8021cdc:	68fb      	ldr	r3, [r7, #12]
 8021cde:	681a      	ldr	r2, [r3, #0]
 8021ce0:	68bb      	ldr	r3, [r7, #8]
 8021ce2:	689b      	ldr	r3, [r3, #8]
 8021ce4:	429a      	cmp	r2, r3
 8021ce6:	dc05      	bgt.n	8021cf4 <_lv_area_is_out+0x3c>
       aout_p->y1 > aholder_p->y2) {
 8021ce8:	68fb      	ldr	r3, [r7, #12]
 8021cea:	685a      	ldr	r2, [r3, #4]
 8021cec:	68bb      	ldr	r3, [r7, #8]
 8021cee:	68db      	ldr	r3, [r3, #12]
    if(aout_p->x2 < aholder_p->x1 || aout_p->y2 < aholder_p->y1 || aout_p->x1 > aholder_p->x2 ||
 8021cf0:	429a      	cmp	r2, r3
 8021cf2:	dd01      	ble.n	8021cf8 <_lv_area_is_out+0x40>
        return true;
 8021cf4:	2301      	movs	r3, #1
 8021cf6:	e059      	b.n	8021dac <_lv_area_is_out+0xf4>
    }

    if(radius == 0) return false;
 8021cf8:	687b      	ldr	r3, [r7, #4]
 8021cfa:	2b00      	cmp	r3, #0
 8021cfc:	d101      	bne.n	8021d02 <_lv_area_is_out+0x4a>
 8021cfe:	2300      	movs	r3, #0
 8021d00:	e054      	b.n	8021dac <_lv_area_is_out+0xf4>

    /*Check if the corner points are outside the radius or not*/
    lv_point_t p;

    lv_point_set(&p, aout_p->x1, aout_p->y1);
 8021d02:	68fb      	ldr	r3, [r7, #12]
 8021d04:	6819      	ldr	r1, [r3, #0]
 8021d06:	68fb      	ldr	r3, [r7, #12]
 8021d08:	685a      	ldr	r2, [r3, #4]
 8021d0a:	f107 0310 	add.w	r3, r7, #16
 8021d0e:	4618      	mov	r0, r3
 8021d10:	f7ff fd68 	bl	80217e4 <lv_point_set>
    if(_lv_area_is_point_on(aholder_p, &p, radius)) return false;
 8021d14:	f107 0310 	add.w	r3, r7, #16
 8021d18:	687a      	ldr	r2, [r7, #4]
 8021d1a:	4619      	mov	r1, r3
 8021d1c:	68b8      	ldr	r0, [r7, #8]
 8021d1e:	f7ff fe54 	bl	80219ca <_lv_area_is_point_on>
 8021d22:	4603      	mov	r3, r0
 8021d24:	2b00      	cmp	r3, #0
 8021d26:	d001      	beq.n	8021d2c <_lv_area_is_out+0x74>
 8021d28:	2300      	movs	r3, #0
 8021d2a:	e03f      	b.n	8021dac <_lv_area_is_out+0xf4>

    lv_point_set(&p, aout_p->x2, aout_p->y1);
 8021d2c:	68fb      	ldr	r3, [r7, #12]
 8021d2e:	6899      	ldr	r1, [r3, #8]
 8021d30:	68fb      	ldr	r3, [r7, #12]
 8021d32:	685a      	ldr	r2, [r3, #4]
 8021d34:	f107 0310 	add.w	r3, r7, #16
 8021d38:	4618      	mov	r0, r3
 8021d3a:	f7ff fd53 	bl	80217e4 <lv_point_set>
    if(_lv_area_is_point_on(aholder_p, &p, radius)) return false;
 8021d3e:	f107 0310 	add.w	r3, r7, #16
 8021d42:	687a      	ldr	r2, [r7, #4]
 8021d44:	4619      	mov	r1, r3
 8021d46:	68b8      	ldr	r0, [r7, #8]
 8021d48:	f7ff fe3f 	bl	80219ca <_lv_area_is_point_on>
 8021d4c:	4603      	mov	r3, r0
 8021d4e:	2b00      	cmp	r3, #0
 8021d50:	d001      	beq.n	8021d56 <_lv_area_is_out+0x9e>
 8021d52:	2300      	movs	r3, #0
 8021d54:	e02a      	b.n	8021dac <_lv_area_is_out+0xf4>

    lv_point_set(&p, aout_p->x1, aout_p->y2);
 8021d56:	68fb      	ldr	r3, [r7, #12]
 8021d58:	6819      	ldr	r1, [r3, #0]
 8021d5a:	68fb      	ldr	r3, [r7, #12]
 8021d5c:	68da      	ldr	r2, [r3, #12]
 8021d5e:	f107 0310 	add.w	r3, r7, #16
 8021d62:	4618      	mov	r0, r3
 8021d64:	f7ff fd3e 	bl	80217e4 <lv_point_set>
    if(_lv_area_is_point_on(aholder_p, &p, radius)) return false;
 8021d68:	f107 0310 	add.w	r3, r7, #16
 8021d6c:	687a      	ldr	r2, [r7, #4]
 8021d6e:	4619      	mov	r1, r3
 8021d70:	68b8      	ldr	r0, [r7, #8]
 8021d72:	f7ff fe2a 	bl	80219ca <_lv_area_is_point_on>
 8021d76:	4603      	mov	r3, r0
 8021d78:	2b00      	cmp	r3, #0
 8021d7a:	d001      	beq.n	8021d80 <_lv_area_is_out+0xc8>
 8021d7c:	2300      	movs	r3, #0
 8021d7e:	e015      	b.n	8021dac <_lv_area_is_out+0xf4>

    lv_point_set(&p, aout_p->x2, aout_p->y2);
 8021d80:	68fb      	ldr	r3, [r7, #12]
 8021d82:	6899      	ldr	r1, [r3, #8]
 8021d84:	68fb      	ldr	r3, [r7, #12]
 8021d86:	68da      	ldr	r2, [r3, #12]
 8021d88:	f107 0310 	add.w	r3, r7, #16
 8021d8c:	4618      	mov	r0, r3
 8021d8e:	f7ff fd29 	bl	80217e4 <lv_point_set>
    if(_lv_area_is_point_on(aholder_p, &p, radius)) return false;
 8021d92:	f107 0310 	add.w	r3, r7, #16
 8021d96:	687a      	ldr	r2, [r7, #4]
 8021d98:	4619      	mov	r1, r3
 8021d9a:	68b8      	ldr	r0, [r7, #8]
 8021d9c:	f7ff fe15 	bl	80219ca <_lv_area_is_point_on>
 8021da0:	4603      	mov	r3, r0
 8021da2:	2b00      	cmp	r3, #0
 8021da4:	d001      	beq.n	8021daa <_lv_area_is_out+0xf2>
 8021da6:	2300      	movs	r3, #0
 8021da8:	e000      	b.n	8021dac <_lv_area_is_out+0xf4>

    return true;
 8021daa:	2301      	movs	r3, #1
}
 8021dac:	4618      	mov	r0, r3
 8021dae:	3718      	adds	r7, #24
 8021db0:	46bd      	mov	sp, r7
 8021db2:	bd80      	pop	{r7, pc}

08021db4 <lv_area_align>:
{
    return a->x1 == b->x1 && a->x2 == b->x2 && a->y1 == b->y1 && a->y2 == b->y2;
}

void lv_area_align(const lv_area_t * base, lv_area_t * to_align, lv_align_t align, int32_t ofs_x, int32_t ofs_y)
{
 8021db4:	b590      	push	{r4, r7, lr}
 8021db6:	b089      	sub	sp, #36	@ 0x24
 8021db8:	af00      	add	r7, sp, #0
 8021dba:	60f8      	str	r0, [r7, #12]
 8021dbc:	60b9      	str	r1, [r7, #8]
 8021dbe:	603b      	str	r3, [r7, #0]
 8021dc0:	4613      	mov	r3, r2
 8021dc2:	71fb      	strb	r3, [r7, #7]

    int32_t x;
    int32_t y;
    switch(align) {
 8021dc4:	79fb      	ldrb	r3, [r7, #7]
 8021dc6:	3b01      	subs	r3, #1
 8021dc8:	2b14      	cmp	r3, #20
 8021dca:	f200 81aa 	bhi.w	8022122 <lv_area_align+0x36e>
 8021dce:	a201      	add	r2, pc, #4	@ (adr r2, 8021dd4 <lv_area_align+0x20>)
 8021dd0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8021dd4:	08021e73 	.word	0x08021e73
 8021dd8:	08021e7d 	.word	0x08021e7d
 8021ddc:	08021ea7 	.word	0x08021ea7
 8021de0:	08021ec1 	.word	0x08021ec1
 8021de4:	08021edb 	.word	0x08021edb
 8021de8:	08021f15 	.word	0x08021f15
 8021dec:	08021f3f 	.word	0x08021f3f
 8021df0:	08021f69 	.word	0x08021f69
 8021df4:	08021e29 	.word	0x08021e29
 8021df8:	08021fa3 	.word	0x08021fa3
 8021dfc:	08021fb5 	.word	0x08021fb5
 8021e00:	08021fe7 	.word	0x08021fe7
 8021e04:	08022009 	.word	0x08022009
 8021e08:	08022017 	.word	0x08022017
 8021e0c:	08022045 	.word	0x08022045
 8021e10:	08022063 	.word	0x08022063
 8021e14:	08022075 	.word	0x08022075
 8021e18:	080220a7 	.word	0x080220a7
 8021e1c:	080220c9 	.word	0x080220c9
 8021e20:	080220d7 	.word	0x080220d7
 8021e24:	08022105 	.word	0x08022105
        case LV_ALIGN_CENTER:
            x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
 8021e28:	68f8      	ldr	r0, [r7, #12]
 8021e2a:	f7ff fcbb 	bl	80217a4 <lv_area_get_width>
 8021e2e:	4603      	mov	r3, r0
 8021e30:	0fda      	lsrs	r2, r3, #31
 8021e32:	4413      	add	r3, r2
 8021e34:	105b      	asrs	r3, r3, #1
 8021e36:	461c      	mov	r4, r3
 8021e38:	68b8      	ldr	r0, [r7, #8]
 8021e3a:	f7ff fcb3 	bl	80217a4 <lv_area_get_width>
 8021e3e:	4603      	mov	r3, r0
 8021e40:	0fda      	lsrs	r2, r3, #31
 8021e42:	4413      	add	r3, r2
 8021e44:	105b      	asrs	r3, r3, #1
 8021e46:	425b      	negs	r3, r3
 8021e48:	4423      	add	r3, r4
 8021e4a:	61fb      	str	r3, [r7, #28]
            y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;
 8021e4c:	68f8      	ldr	r0, [r7, #12]
 8021e4e:	f7ff fcb9 	bl	80217c4 <lv_area_get_height>
 8021e52:	4603      	mov	r3, r0
 8021e54:	0fda      	lsrs	r2, r3, #31
 8021e56:	4413      	add	r3, r2
 8021e58:	105b      	asrs	r3, r3, #1
 8021e5a:	461c      	mov	r4, r3
 8021e5c:	68b8      	ldr	r0, [r7, #8]
 8021e5e:	f7ff fcb1 	bl	80217c4 <lv_area_get_height>
 8021e62:	4603      	mov	r3, r0
 8021e64:	0fda      	lsrs	r2, r3, #31
 8021e66:	4413      	add	r3, r2
 8021e68:	105b      	asrs	r3, r3, #1
 8021e6a:	425b      	negs	r3, r3
 8021e6c:	4423      	add	r3, r4
 8021e6e:	61bb      	str	r3, [r7, #24]
            break;
 8021e70:	e15c      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_TOP_LEFT:
            x = 0;
 8021e72:	2300      	movs	r3, #0
 8021e74:	61fb      	str	r3, [r7, #28]
            y = 0;
 8021e76:	2300      	movs	r3, #0
 8021e78:	61bb      	str	r3, [r7, #24]
            break;
 8021e7a:	e157      	b.n	802212c <lv_area_align+0x378>
        case LV_ALIGN_TOP_MID:
            x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
 8021e7c:	68f8      	ldr	r0, [r7, #12]
 8021e7e:	f7ff fc91 	bl	80217a4 <lv_area_get_width>
 8021e82:	4603      	mov	r3, r0
 8021e84:	0fda      	lsrs	r2, r3, #31
 8021e86:	4413      	add	r3, r2
 8021e88:	105b      	asrs	r3, r3, #1
 8021e8a:	461c      	mov	r4, r3
 8021e8c:	68b8      	ldr	r0, [r7, #8]
 8021e8e:	f7ff fc89 	bl	80217a4 <lv_area_get_width>
 8021e92:	4603      	mov	r3, r0
 8021e94:	0fda      	lsrs	r2, r3, #31
 8021e96:	4413      	add	r3, r2
 8021e98:	105b      	asrs	r3, r3, #1
 8021e9a:	425b      	negs	r3, r3
 8021e9c:	4423      	add	r3, r4
 8021e9e:	61fb      	str	r3, [r7, #28]
            y = 0;
 8021ea0:	2300      	movs	r3, #0
 8021ea2:	61bb      	str	r3, [r7, #24]
            break;
 8021ea4:	e142      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_TOP_RIGHT:
            x = lv_area_get_width(base) - lv_area_get_width(to_align);
 8021ea6:	68f8      	ldr	r0, [r7, #12]
 8021ea8:	f7ff fc7c 	bl	80217a4 <lv_area_get_width>
 8021eac:	4604      	mov	r4, r0
 8021eae:	68b8      	ldr	r0, [r7, #8]
 8021eb0:	f7ff fc78 	bl	80217a4 <lv_area_get_width>
 8021eb4:	4603      	mov	r3, r0
 8021eb6:	1ae3      	subs	r3, r4, r3
 8021eb8:	61fb      	str	r3, [r7, #28]
            y = 0;
 8021eba:	2300      	movs	r3, #0
 8021ebc:	61bb      	str	r3, [r7, #24]
            break;
 8021ebe:	e135      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_BOTTOM_LEFT:
            x = 0;
 8021ec0:	2300      	movs	r3, #0
 8021ec2:	61fb      	str	r3, [r7, #28]
            y = lv_area_get_height(base) - lv_area_get_height(to_align);
 8021ec4:	68f8      	ldr	r0, [r7, #12]
 8021ec6:	f7ff fc7d 	bl	80217c4 <lv_area_get_height>
 8021eca:	4604      	mov	r4, r0
 8021ecc:	68b8      	ldr	r0, [r7, #8]
 8021ece:	f7ff fc79 	bl	80217c4 <lv_area_get_height>
 8021ed2:	4603      	mov	r3, r0
 8021ed4:	1ae3      	subs	r3, r4, r3
 8021ed6:	61bb      	str	r3, [r7, #24]
            break;
 8021ed8:	e128      	b.n	802212c <lv_area_align+0x378>
        case LV_ALIGN_BOTTOM_MID:
            x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
 8021eda:	68f8      	ldr	r0, [r7, #12]
 8021edc:	f7ff fc62 	bl	80217a4 <lv_area_get_width>
 8021ee0:	4603      	mov	r3, r0
 8021ee2:	0fda      	lsrs	r2, r3, #31
 8021ee4:	4413      	add	r3, r2
 8021ee6:	105b      	asrs	r3, r3, #1
 8021ee8:	461c      	mov	r4, r3
 8021eea:	68b8      	ldr	r0, [r7, #8]
 8021eec:	f7ff fc5a 	bl	80217a4 <lv_area_get_width>
 8021ef0:	4603      	mov	r3, r0
 8021ef2:	0fda      	lsrs	r2, r3, #31
 8021ef4:	4413      	add	r3, r2
 8021ef6:	105b      	asrs	r3, r3, #1
 8021ef8:	425b      	negs	r3, r3
 8021efa:	4423      	add	r3, r4
 8021efc:	61fb      	str	r3, [r7, #28]
            y = lv_area_get_height(base) - lv_area_get_height(to_align);
 8021efe:	68f8      	ldr	r0, [r7, #12]
 8021f00:	f7ff fc60 	bl	80217c4 <lv_area_get_height>
 8021f04:	4604      	mov	r4, r0
 8021f06:	68b8      	ldr	r0, [r7, #8]
 8021f08:	f7ff fc5c 	bl	80217c4 <lv_area_get_height>
 8021f0c:	4603      	mov	r3, r0
 8021f0e:	1ae3      	subs	r3, r4, r3
 8021f10:	61bb      	str	r3, [r7, #24]
            break;
 8021f12:	e10b      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_BOTTOM_RIGHT:
            x = lv_area_get_width(base) - lv_area_get_width(to_align);
 8021f14:	68f8      	ldr	r0, [r7, #12]
 8021f16:	f7ff fc45 	bl	80217a4 <lv_area_get_width>
 8021f1a:	4604      	mov	r4, r0
 8021f1c:	68b8      	ldr	r0, [r7, #8]
 8021f1e:	f7ff fc41 	bl	80217a4 <lv_area_get_width>
 8021f22:	4603      	mov	r3, r0
 8021f24:	1ae3      	subs	r3, r4, r3
 8021f26:	61fb      	str	r3, [r7, #28]
            y = lv_area_get_height(base) - lv_area_get_height(to_align);
 8021f28:	68f8      	ldr	r0, [r7, #12]
 8021f2a:	f7ff fc4b 	bl	80217c4 <lv_area_get_height>
 8021f2e:	4604      	mov	r4, r0
 8021f30:	68b8      	ldr	r0, [r7, #8]
 8021f32:	f7ff fc47 	bl	80217c4 <lv_area_get_height>
 8021f36:	4603      	mov	r3, r0
 8021f38:	1ae3      	subs	r3, r4, r3
 8021f3a:	61bb      	str	r3, [r7, #24]
            break;
 8021f3c:	e0f6      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_LEFT_MID:
            x = 0;
 8021f3e:	2300      	movs	r3, #0
 8021f40:	61fb      	str	r3, [r7, #28]
            y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;
 8021f42:	68f8      	ldr	r0, [r7, #12]
 8021f44:	f7ff fc3e 	bl	80217c4 <lv_area_get_height>
 8021f48:	4603      	mov	r3, r0
 8021f4a:	0fda      	lsrs	r2, r3, #31
 8021f4c:	4413      	add	r3, r2
 8021f4e:	105b      	asrs	r3, r3, #1
 8021f50:	461c      	mov	r4, r3
 8021f52:	68b8      	ldr	r0, [r7, #8]
 8021f54:	f7ff fc36 	bl	80217c4 <lv_area_get_height>
 8021f58:	4603      	mov	r3, r0
 8021f5a:	0fda      	lsrs	r2, r3, #31
 8021f5c:	4413      	add	r3, r2
 8021f5e:	105b      	asrs	r3, r3, #1
 8021f60:	425b      	negs	r3, r3
 8021f62:	4423      	add	r3, r4
 8021f64:	61bb      	str	r3, [r7, #24]
            break;
 8021f66:	e0e1      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_RIGHT_MID:
            x = lv_area_get_width(base) - lv_area_get_width(to_align);
 8021f68:	68f8      	ldr	r0, [r7, #12]
 8021f6a:	f7ff fc1b 	bl	80217a4 <lv_area_get_width>
 8021f6e:	4604      	mov	r4, r0
 8021f70:	68b8      	ldr	r0, [r7, #8]
 8021f72:	f7ff fc17 	bl	80217a4 <lv_area_get_width>
 8021f76:	4603      	mov	r3, r0
 8021f78:	1ae3      	subs	r3, r4, r3
 8021f7a:	61fb      	str	r3, [r7, #28]
            y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;
 8021f7c:	68f8      	ldr	r0, [r7, #12]
 8021f7e:	f7ff fc21 	bl	80217c4 <lv_area_get_height>
 8021f82:	4603      	mov	r3, r0
 8021f84:	0fda      	lsrs	r2, r3, #31
 8021f86:	4413      	add	r3, r2
 8021f88:	105b      	asrs	r3, r3, #1
 8021f8a:	461c      	mov	r4, r3
 8021f8c:	68b8      	ldr	r0, [r7, #8]
 8021f8e:	f7ff fc19 	bl	80217c4 <lv_area_get_height>
 8021f92:	4603      	mov	r3, r0
 8021f94:	0fda      	lsrs	r2, r3, #31
 8021f96:	4413      	add	r3, r2
 8021f98:	105b      	asrs	r3, r3, #1
 8021f9a:	425b      	negs	r3, r3
 8021f9c:	4423      	add	r3, r4
 8021f9e:	61bb      	str	r3, [r7, #24]
            break;
 8021fa0:	e0c4      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_OUT_TOP_LEFT:
            x = 0;
 8021fa2:	2300      	movs	r3, #0
 8021fa4:	61fb      	str	r3, [r7, #28]
            y = -lv_area_get_height(to_align);
 8021fa6:	68b8      	ldr	r0, [r7, #8]
 8021fa8:	f7ff fc0c 	bl	80217c4 <lv_area_get_height>
 8021fac:	4603      	mov	r3, r0
 8021fae:	425b      	negs	r3, r3
 8021fb0:	61bb      	str	r3, [r7, #24]
            break;
 8021fb2:	e0bb      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_OUT_TOP_MID:
            x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
 8021fb4:	68f8      	ldr	r0, [r7, #12]
 8021fb6:	f7ff fbf5 	bl	80217a4 <lv_area_get_width>
 8021fba:	4603      	mov	r3, r0
 8021fbc:	0fda      	lsrs	r2, r3, #31
 8021fbe:	4413      	add	r3, r2
 8021fc0:	105b      	asrs	r3, r3, #1
 8021fc2:	461c      	mov	r4, r3
 8021fc4:	68b8      	ldr	r0, [r7, #8]
 8021fc6:	f7ff fbed 	bl	80217a4 <lv_area_get_width>
 8021fca:	4603      	mov	r3, r0
 8021fcc:	0fda      	lsrs	r2, r3, #31
 8021fce:	4413      	add	r3, r2
 8021fd0:	105b      	asrs	r3, r3, #1
 8021fd2:	425b      	negs	r3, r3
 8021fd4:	4423      	add	r3, r4
 8021fd6:	61fb      	str	r3, [r7, #28]
            y = -lv_area_get_height(to_align);
 8021fd8:	68b8      	ldr	r0, [r7, #8]
 8021fda:	f7ff fbf3 	bl	80217c4 <lv_area_get_height>
 8021fde:	4603      	mov	r3, r0
 8021fe0:	425b      	negs	r3, r3
 8021fe2:	61bb      	str	r3, [r7, #24]
            break;
 8021fe4:	e0a2      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_OUT_TOP_RIGHT:
            x = lv_area_get_width(base) - lv_area_get_width(to_align);
 8021fe6:	68f8      	ldr	r0, [r7, #12]
 8021fe8:	f7ff fbdc 	bl	80217a4 <lv_area_get_width>
 8021fec:	4604      	mov	r4, r0
 8021fee:	68b8      	ldr	r0, [r7, #8]
 8021ff0:	f7ff fbd8 	bl	80217a4 <lv_area_get_width>
 8021ff4:	4603      	mov	r3, r0
 8021ff6:	1ae3      	subs	r3, r4, r3
 8021ff8:	61fb      	str	r3, [r7, #28]
            y = -lv_area_get_height(to_align);
 8021ffa:	68b8      	ldr	r0, [r7, #8]
 8021ffc:	f7ff fbe2 	bl	80217c4 <lv_area_get_height>
 8022000:	4603      	mov	r3, r0
 8022002:	425b      	negs	r3, r3
 8022004:	61bb      	str	r3, [r7, #24]
            break;
 8022006:	e091      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_OUT_BOTTOM_LEFT:
            x = 0;
 8022008:	2300      	movs	r3, #0
 802200a:	61fb      	str	r3, [r7, #28]
            y = lv_area_get_height(base);
 802200c:	68f8      	ldr	r0, [r7, #12]
 802200e:	f7ff fbd9 	bl	80217c4 <lv_area_get_height>
 8022012:	61b8      	str	r0, [r7, #24]
            break;
 8022014:	e08a      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_OUT_BOTTOM_MID:
            x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
 8022016:	68f8      	ldr	r0, [r7, #12]
 8022018:	f7ff fbc4 	bl	80217a4 <lv_area_get_width>
 802201c:	4603      	mov	r3, r0
 802201e:	0fda      	lsrs	r2, r3, #31
 8022020:	4413      	add	r3, r2
 8022022:	105b      	asrs	r3, r3, #1
 8022024:	461c      	mov	r4, r3
 8022026:	68b8      	ldr	r0, [r7, #8]
 8022028:	f7ff fbbc 	bl	80217a4 <lv_area_get_width>
 802202c:	4603      	mov	r3, r0
 802202e:	0fda      	lsrs	r2, r3, #31
 8022030:	4413      	add	r3, r2
 8022032:	105b      	asrs	r3, r3, #1
 8022034:	425b      	negs	r3, r3
 8022036:	4423      	add	r3, r4
 8022038:	61fb      	str	r3, [r7, #28]
            y = lv_area_get_height(base);
 802203a:	68f8      	ldr	r0, [r7, #12]
 802203c:	f7ff fbc2 	bl	80217c4 <lv_area_get_height>
 8022040:	61b8      	str	r0, [r7, #24]
            break;
 8022042:	e073      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_OUT_BOTTOM_RIGHT:
            x = lv_area_get_width(base) - lv_area_get_width(to_align);
 8022044:	68f8      	ldr	r0, [r7, #12]
 8022046:	f7ff fbad 	bl	80217a4 <lv_area_get_width>
 802204a:	4604      	mov	r4, r0
 802204c:	68b8      	ldr	r0, [r7, #8]
 802204e:	f7ff fba9 	bl	80217a4 <lv_area_get_width>
 8022052:	4603      	mov	r3, r0
 8022054:	1ae3      	subs	r3, r4, r3
 8022056:	61fb      	str	r3, [r7, #28]
            y = lv_area_get_height(base);
 8022058:	68f8      	ldr	r0, [r7, #12]
 802205a:	f7ff fbb3 	bl	80217c4 <lv_area_get_height>
 802205e:	61b8      	str	r0, [r7, #24]
            break;
 8022060:	e064      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_OUT_LEFT_TOP:
            x = -lv_area_get_width(to_align);
 8022062:	68b8      	ldr	r0, [r7, #8]
 8022064:	f7ff fb9e 	bl	80217a4 <lv_area_get_width>
 8022068:	4603      	mov	r3, r0
 802206a:	425b      	negs	r3, r3
 802206c:	61fb      	str	r3, [r7, #28]
            y = 0;
 802206e:	2300      	movs	r3, #0
 8022070:	61bb      	str	r3, [r7, #24]
            break;
 8022072:	e05b      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_OUT_LEFT_MID:
            x = -lv_area_get_width(to_align);
 8022074:	68b8      	ldr	r0, [r7, #8]
 8022076:	f7ff fb95 	bl	80217a4 <lv_area_get_width>
 802207a:	4603      	mov	r3, r0
 802207c:	425b      	negs	r3, r3
 802207e:	61fb      	str	r3, [r7, #28]
            y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;
 8022080:	68f8      	ldr	r0, [r7, #12]
 8022082:	f7ff fb9f 	bl	80217c4 <lv_area_get_height>
 8022086:	4603      	mov	r3, r0
 8022088:	0fda      	lsrs	r2, r3, #31
 802208a:	4413      	add	r3, r2
 802208c:	105b      	asrs	r3, r3, #1
 802208e:	461c      	mov	r4, r3
 8022090:	68b8      	ldr	r0, [r7, #8]
 8022092:	f7ff fb97 	bl	80217c4 <lv_area_get_height>
 8022096:	4603      	mov	r3, r0
 8022098:	0fda      	lsrs	r2, r3, #31
 802209a:	4413      	add	r3, r2
 802209c:	105b      	asrs	r3, r3, #1
 802209e:	425b      	negs	r3, r3
 80220a0:	4423      	add	r3, r4
 80220a2:	61bb      	str	r3, [r7, #24]
            break;
 80220a4:	e042      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_OUT_LEFT_BOTTOM:
            x = -lv_area_get_width(to_align);
 80220a6:	68b8      	ldr	r0, [r7, #8]
 80220a8:	f7ff fb7c 	bl	80217a4 <lv_area_get_width>
 80220ac:	4603      	mov	r3, r0
 80220ae:	425b      	negs	r3, r3
 80220b0:	61fb      	str	r3, [r7, #28]
            y = lv_area_get_height(base) - lv_area_get_height(to_align);
 80220b2:	68f8      	ldr	r0, [r7, #12]
 80220b4:	f7ff fb86 	bl	80217c4 <lv_area_get_height>
 80220b8:	4604      	mov	r4, r0
 80220ba:	68b8      	ldr	r0, [r7, #8]
 80220bc:	f7ff fb82 	bl	80217c4 <lv_area_get_height>
 80220c0:	4603      	mov	r3, r0
 80220c2:	1ae3      	subs	r3, r4, r3
 80220c4:	61bb      	str	r3, [r7, #24]
            break;
 80220c6:	e031      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_OUT_RIGHT_TOP:
            x = lv_area_get_width(base);
 80220c8:	68f8      	ldr	r0, [r7, #12]
 80220ca:	f7ff fb6b 	bl	80217a4 <lv_area_get_width>
 80220ce:	61f8      	str	r0, [r7, #28]
            y = 0;
 80220d0:	2300      	movs	r3, #0
 80220d2:	61bb      	str	r3, [r7, #24]
            break;
 80220d4:	e02a      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_OUT_RIGHT_MID:
            x = lv_area_get_width(base);
 80220d6:	68f8      	ldr	r0, [r7, #12]
 80220d8:	f7ff fb64 	bl	80217a4 <lv_area_get_width>
 80220dc:	61f8      	str	r0, [r7, #28]
            y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;
 80220de:	68f8      	ldr	r0, [r7, #12]
 80220e0:	f7ff fb70 	bl	80217c4 <lv_area_get_height>
 80220e4:	4603      	mov	r3, r0
 80220e6:	0fda      	lsrs	r2, r3, #31
 80220e8:	4413      	add	r3, r2
 80220ea:	105b      	asrs	r3, r3, #1
 80220ec:	461c      	mov	r4, r3
 80220ee:	68b8      	ldr	r0, [r7, #8]
 80220f0:	f7ff fb68 	bl	80217c4 <lv_area_get_height>
 80220f4:	4603      	mov	r3, r0
 80220f6:	0fda      	lsrs	r2, r3, #31
 80220f8:	4413      	add	r3, r2
 80220fa:	105b      	asrs	r3, r3, #1
 80220fc:	425b      	negs	r3, r3
 80220fe:	4423      	add	r3, r4
 8022100:	61bb      	str	r3, [r7, #24]
            break;
 8022102:	e013      	b.n	802212c <lv_area_align+0x378>

        case LV_ALIGN_OUT_RIGHT_BOTTOM:
            x = lv_area_get_width(base);
 8022104:	68f8      	ldr	r0, [r7, #12]
 8022106:	f7ff fb4d 	bl	80217a4 <lv_area_get_width>
 802210a:	61f8      	str	r0, [r7, #28]
            y = lv_area_get_height(base) - lv_area_get_height(to_align);
 802210c:	68f8      	ldr	r0, [r7, #12]
 802210e:	f7ff fb59 	bl	80217c4 <lv_area_get_height>
 8022112:	4604      	mov	r4, r0
 8022114:	68b8      	ldr	r0, [r7, #8]
 8022116:	f7ff fb55 	bl	80217c4 <lv_area_get_height>
 802211a:	4603      	mov	r3, r0
 802211c:	1ae3      	subs	r3, r4, r3
 802211e:	61bb      	str	r3, [r7, #24]
            break;
 8022120:	e004      	b.n	802212c <lv_area_align+0x378>
        default:
            x = 0;
 8022122:	2300      	movs	r3, #0
 8022124:	61fb      	str	r3, [r7, #28]
            y = 0;
 8022126:	2300      	movs	r3, #0
 8022128:	61bb      	str	r3, [r7, #24]
            break;
 802212a:	bf00      	nop
    }

    x += base->x1;
 802212c:	68fb      	ldr	r3, [r7, #12]
 802212e:	681b      	ldr	r3, [r3, #0]
 8022130:	69fa      	ldr	r2, [r7, #28]
 8022132:	4413      	add	r3, r2
 8022134:	61fb      	str	r3, [r7, #28]
    y += base->y1;
 8022136:	68fb      	ldr	r3, [r7, #12]
 8022138:	685b      	ldr	r3, [r3, #4]
 802213a:	69ba      	ldr	r2, [r7, #24]
 802213c:	4413      	add	r3, r2
 802213e:	61bb      	str	r3, [r7, #24]

    int32_t w = lv_area_get_width(to_align);
 8022140:	68b8      	ldr	r0, [r7, #8]
 8022142:	f7ff fb2f 	bl	80217a4 <lv_area_get_width>
 8022146:	6178      	str	r0, [r7, #20]
    int32_t h = lv_area_get_height(to_align);
 8022148:	68b8      	ldr	r0, [r7, #8]
 802214a:	f7ff fb3b 	bl	80217c4 <lv_area_get_height>
 802214e:	6138      	str	r0, [r7, #16]
    to_align->x1 = x + ofs_x;
 8022150:	69fa      	ldr	r2, [r7, #28]
 8022152:	683b      	ldr	r3, [r7, #0]
 8022154:	441a      	add	r2, r3
 8022156:	68bb      	ldr	r3, [r7, #8]
 8022158:	601a      	str	r2, [r3, #0]
    to_align->y1 = y + ofs_y;
 802215a:	69ba      	ldr	r2, [r7, #24]
 802215c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802215e:	441a      	add	r2, r3
 8022160:	68bb      	ldr	r3, [r7, #8]
 8022162:	605a      	str	r2, [r3, #4]
    to_align->x2 = to_align->x1 + w - 1;
 8022164:	68bb      	ldr	r3, [r7, #8]
 8022166:	681a      	ldr	r2, [r3, #0]
 8022168:	697b      	ldr	r3, [r7, #20]
 802216a:	4413      	add	r3, r2
 802216c:	1e5a      	subs	r2, r3, #1
 802216e:	68bb      	ldr	r3, [r7, #8]
 8022170:	609a      	str	r2, [r3, #8]
    to_align->y2 = to_align->y1 + h - 1;
 8022172:	68bb      	ldr	r3, [r7, #8]
 8022174:	685a      	ldr	r2, [r3, #4]
 8022176:	693b      	ldr	r3, [r7, #16]
 8022178:	4413      	add	r3, r2
 802217a:	1e5a      	subs	r2, r3, #1
 802217c:	68bb      	ldr	r3, [r7, #8]
 802217e:	60da      	str	r2, [r3, #12]
}
 8022180:	bf00      	nop
 8022182:	3724      	adds	r7, #36	@ 0x24
 8022184:	46bd      	mov	sp, r7
 8022186:	bd90      	pop	{r4, r7, pc}

08022188 <lv_point_transform>:

#define _LV_TRANSFORM_TRIGO_SHIFT 10
void lv_point_transform(lv_point_t * p, int32_t angle, int32_t scale_x, int32_t scale_y, const lv_point_t * pivot,
                        bool zoom_first)
{
 8022188:	b580      	push	{r7, lr}
 802218a:	b090      	sub	sp, #64	@ 0x40
 802218c:	af00      	add	r7, sp, #0
 802218e:	60f8      	str	r0, [r7, #12]
 8022190:	60b9      	str	r1, [r7, #8]
 8022192:	607a      	str	r2, [r7, #4]
 8022194:	603b      	str	r3, [r7, #0]
    if(angle == 0 && scale_x == 256 && scale_y == 256) {
 8022196:	68bb      	ldr	r3, [r7, #8]
 8022198:	2b00      	cmp	r3, #0
 802219a:	d108      	bne.n	80221ae <lv_point_transform+0x26>
 802219c:	687b      	ldr	r3, [r7, #4]
 802219e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80221a2:	d104      	bne.n	80221ae <lv_point_transform+0x26>
 80221a4:	683b      	ldr	r3, [r7, #0]
 80221a6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80221aa:	f000 812f 	beq.w	802240c <lv_point_transform+0x284>
        return;
    }

    p->x -= pivot->x;
 80221ae:	68fb      	ldr	r3, [r7, #12]
 80221b0:	681a      	ldr	r2, [r3, #0]
 80221b2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80221b4:	681b      	ldr	r3, [r3, #0]
 80221b6:	1ad2      	subs	r2, r2, r3
 80221b8:	68fb      	ldr	r3, [r7, #12]
 80221ba:	601a      	str	r2, [r3, #0]
    p->y -= pivot->y;
 80221bc:	68fb      	ldr	r3, [r7, #12]
 80221be:	685a      	ldr	r2, [r3, #4]
 80221c0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80221c2:	685b      	ldr	r3, [r3, #4]
 80221c4:	1ad2      	subs	r2, r2, r3
 80221c6:	68fb      	ldr	r3, [r7, #12]
 80221c8:	605a      	str	r2, [r3, #4]

    if(angle == 0) {
 80221ca:	68bb      	ldr	r3, [r7, #8]
 80221cc:	2b00      	cmp	r3, #0
 80221ce:	d116      	bne.n	80221fe <lv_point_transform+0x76>
        p->x = (((int32_t)(p->x) * scale_x) >> 8) + pivot->x;
 80221d0:	68fb      	ldr	r3, [r7, #12]
 80221d2:	681b      	ldr	r3, [r3, #0]
 80221d4:	687a      	ldr	r2, [r7, #4]
 80221d6:	fb02 f303 	mul.w	r3, r2, r3
 80221da:	121a      	asrs	r2, r3, #8
 80221dc:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80221de:	681b      	ldr	r3, [r3, #0]
 80221e0:	441a      	add	r2, r3
 80221e2:	68fb      	ldr	r3, [r7, #12]
 80221e4:	601a      	str	r2, [r3, #0]
        p->y = (((int32_t)(p->y) * scale_y) >> 8) + pivot->y;
 80221e6:	68fb      	ldr	r3, [r7, #12]
 80221e8:	685b      	ldr	r3, [r3, #4]
 80221ea:	683a      	ldr	r2, [r7, #0]
 80221ec:	fb02 f303 	mul.w	r3, r2, r3
 80221f0:	121a      	asrs	r2, r3, #8
 80221f2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80221f4:	685b      	ldr	r3, [r3, #4]
 80221f6:	441a      	add	r2, r3
 80221f8:	68fb      	ldr	r3, [r7, #12]
 80221fa:	605a      	str	r2, [r3, #4]
        return;
 80221fc:	e107      	b.n	802240e <lv_point_transform+0x286>
    }
    lv_area_transform_cache_t * cache = &trans_cache;
 80221fe:	4b85      	ldr	r3, [pc, #532]	@ (8022414 <lv_point_transform+0x28c>)
 8022200:	63bb      	str	r3, [r7, #56]	@ 0x38
    if(cache->angle_prev != angle) {
 8022202:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022204:	681b      	ldr	r3, [r3, #0]
 8022206:	68ba      	ldr	r2, [r7, #8]
 8022208:	429a      	cmp	r2, r3
 802220a:	d074      	beq.n	80222f6 <lv_point_transform+0x16e>
        int32_t angle_limited = angle;
 802220c:	68bb      	ldr	r3, [r7, #8]
 802220e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        if(angle_limited > 3600) angle_limited -= 3600;
 8022210:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8022212:	f5b3 6f61 	cmp.w	r3, #3600	@ 0xe10
 8022216:	dd03      	ble.n	8022220 <lv_point_transform+0x98>
 8022218:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 802221a:	f5a3 6361 	sub.w	r3, r3, #3600	@ 0xe10
 802221e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        if(angle_limited < 0) angle_limited += 3600;
 8022220:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8022222:	2b00      	cmp	r3, #0
 8022224:	da03      	bge.n	802222e <lv_point_transform+0xa6>
 8022226:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8022228:	f503 6361 	add.w	r3, r3, #3600	@ 0xe10
 802222c:	63fb      	str	r3, [r7, #60]	@ 0x3c

        int32_t angle_low = angle_limited / 10;
 802222e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8022230:	4a79      	ldr	r2, [pc, #484]	@ (8022418 <lv_point_transform+0x290>)
 8022232:	fb82 1203 	smull	r1, r2, r2, r3
 8022236:	1092      	asrs	r2, r2, #2
 8022238:	17db      	asrs	r3, r3, #31
 802223a:	1ad3      	subs	r3, r2, r3
 802223c:	637b      	str	r3, [r7, #52]	@ 0x34
        int32_t angle_high = angle_low + 1;
 802223e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022240:	3301      	adds	r3, #1
 8022242:	633b      	str	r3, [r7, #48]	@ 0x30
        int32_t angle_rem = angle_limited  - (angle_low * 10);
 8022244:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022246:	f06f 0209 	mvn.w	r2, #9
 802224a:	fb02 f303 	mul.w	r3, r2, r3
 802224e:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8022250:	4413      	add	r3, r2
 8022252:	62fb      	str	r3, [r7, #44]	@ 0x2c

        int32_t s1 = lv_trigo_sin(angle_low);
 8022254:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022256:	b21b      	sxth	r3, r3
 8022258:	4618      	mov	r0, r3
 802225a:	f001 f843 	bl	80232e4 <lv_trigo_sin>
 802225e:	62b8      	str	r0, [r7, #40]	@ 0x28
        int32_t s2 = lv_trigo_sin(angle_high);
 8022260:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8022262:	b21b      	sxth	r3, r3
 8022264:	4618      	mov	r0, r3
 8022266:	f001 f83d 	bl	80232e4 <lv_trigo_sin>
 802226a:	6278      	str	r0, [r7, #36]	@ 0x24

        int32_t c1 = lv_trigo_sin(angle_low + 90);
 802226c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 802226e:	b29b      	uxth	r3, r3
 8022270:	335a      	adds	r3, #90	@ 0x5a
 8022272:	b29b      	uxth	r3, r3
 8022274:	b21b      	sxth	r3, r3
 8022276:	4618      	mov	r0, r3
 8022278:	f001 f834 	bl	80232e4 <lv_trigo_sin>
 802227c:	6238      	str	r0, [r7, #32]
        int32_t c2 = lv_trigo_sin(angle_high + 90);
 802227e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8022280:	b29b      	uxth	r3, r3
 8022282:	335a      	adds	r3, #90	@ 0x5a
 8022284:	b29b      	uxth	r3, r3
 8022286:	b21b      	sxth	r3, r3
 8022288:	4618      	mov	r0, r3
 802228a:	f001 f82b 	bl	80232e4 <lv_trigo_sin>
 802228e:	61f8      	str	r0, [r7, #28]

        cache->sinma = (s1 * (10 - angle_rem) + s2 * angle_rem) / 10;
 8022290:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022292:	f1c3 030a 	rsb	r3, r3, #10
 8022296:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8022298:	fb03 f202 	mul.w	r2, r3, r2
 802229c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802229e:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80222a0:	fb01 f303 	mul.w	r3, r1, r3
 80222a4:	4413      	add	r3, r2
 80222a6:	4a5c      	ldr	r2, [pc, #368]	@ (8022418 <lv_point_transform+0x290>)
 80222a8:	fb82 1203 	smull	r1, r2, r2, r3
 80222ac:	1092      	asrs	r2, r2, #2
 80222ae:	17db      	asrs	r3, r3, #31
 80222b0:	1ad2      	subs	r2, r2, r3
 80222b2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80222b4:	605a      	str	r2, [r3, #4]
        cache->cosma = (c1 * (10 - angle_rem) + c2 * angle_rem) / 10;
 80222b6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80222b8:	f1c3 030a 	rsb	r3, r3, #10
 80222bc:	6a3a      	ldr	r2, [r7, #32]
 80222be:	fb03 f202 	mul.w	r2, r3, r2
 80222c2:	69fb      	ldr	r3, [r7, #28]
 80222c4:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80222c6:	fb01 f303 	mul.w	r3, r1, r3
 80222ca:	4413      	add	r3, r2
 80222cc:	4a52      	ldr	r2, [pc, #328]	@ (8022418 <lv_point_transform+0x290>)
 80222ce:	fb82 1203 	smull	r1, r2, r2, r3
 80222d2:	1092      	asrs	r2, r2, #2
 80222d4:	17db      	asrs	r3, r3, #31
 80222d6:	1ad2      	subs	r2, r2, r3
 80222d8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80222da:	609a      	str	r2, [r3, #8]
        cache->sinma = cache->sinma >> (LV_TRIGO_SHIFT - _LV_TRANSFORM_TRIGO_SHIFT);
 80222dc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80222de:	685b      	ldr	r3, [r3, #4]
 80222e0:	115a      	asrs	r2, r3, #5
 80222e2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80222e4:	605a      	str	r2, [r3, #4]
        cache->cosma = cache->cosma >> (LV_TRIGO_SHIFT - _LV_TRANSFORM_TRIGO_SHIFT);
 80222e6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80222e8:	689b      	ldr	r3, [r3, #8]
 80222ea:	115a      	asrs	r2, r3, #5
 80222ec:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80222ee:	609a      	str	r2, [r3, #8]
        cache->angle_prev = angle;
 80222f0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80222f2:	68ba      	ldr	r2, [r7, #8]
 80222f4:	601a      	str	r2, [r3, #0]
    }
    int32_t x = p->x;
 80222f6:	68fb      	ldr	r3, [r7, #12]
 80222f8:	681b      	ldr	r3, [r3, #0]
 80222fa:	61bb      	str	r3, [r7, #24]
    int32_t y = p->y;
 80222fc:	68fb      	ldr	r3, [r7, #12]
 80222fe:	685b      	ldr	r3, [r3, #4]
 8022300:	617b      	str	r3, [r7, #20]
    if(scale_x == 256 && scale_y == 256) {
 8022302:	687b      	ldr	r3, [r7, #4]
 8022304:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8022308:	d126      	bne.n	8022358 <lv_point_transform+0x1d0>
 802230a:	683b      	ldr	r3, [r7, #0]
 802230c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8022310:	d122      	bne.n	8022358 <lv_point_transform+0x1d0>
        p->x = ((cache->cosma * x - cache->sinma * y) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->x;
 8022312:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022314:	689b      	ldr	r3, [r3, #8]
 8022316:	69ba      	ldr	r2, [r7, #24]
 8022318:	fb03 f202 	mul.w	r2, r3, r2
 802231c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802231e:	685b      	ldr	r3, [r3, #4]
 8022320:	6979      	ldr	r1, [r7, #20]
 8022322:	fb01 f303 	mul.w	r3, r1, r3
 8022326:	1ad3      	subs	r3, r2, r3
 8022328:	129a      	asrs	r2, r3, #10
 802232a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802232c:	681b      	ldr	r3, [r3, #0]
 802232e:	441a      	add	r2, r3
 8022330:	68fb      	ldr	r3, [r7, #12]
 8022332:	601a      	str	r2, [r3, #0]
        p->y = ((cache->sinma * x + cache->cosma * y) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->y;
 8022334:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022336:	685b      	ldr	r3, [r3, #4]
 8022338:	69ba      	ldr	r2, [r7, #24]
 802233a:	fb03 f202 	mul.w	r2, r3, r2
 802233e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022340:	689b      	ldr	r3, [r3, #8]
 8022342:	6979      	ldr	r1, [r7, #20]
 8022344:	fb01 f303 	mul.w	r3, r1, r3
 8022348:	4413      	add	r3, r2
 802234a:	129a      	asrs	r2, r3, #10
 802234c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802234e:	685b      	ldr	r3, [r3, #4]
 8022350:	441a      	add	r2, r3
 8022352:	68fb      	ldr	r3, [r7, #12]
 8022354:	605a      	str	r2, [r3, #4]
 8022356:	e05a      	b.n	802240e <lv_point_transform+0x286>
    }
    else {
        if(zoom_first) {
 8022358:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
 802235c:	2b00      	cmp	r3, #0
 802235e:	d02c      	beq.n	80223ba <lv_point_transform+0x232>
            x *= scale_x;
 8022360:	69bb      	ldr	r3, [r7, #24]
 8022362:	687a      	ldr	r2, [r7, #4]
 8022364:	fb02 f303 	mul.w	r3, r2, r3
 8022368:	61bb      	str	r3, [r7, #24]
            y *= scale_y;
 802236a:	697b      	ldr	r3, [r7, #20]
 802236c:	683a      	ldr	r2, [r7, #0]
 802236e:	fb02 f303 	mul.w	r3, r2, r3
 8022372:	617b      	str	r3, [r7, #20]
            p->x = (((cache->cosma * x - cache->sinma * y)) >> (_LV_TRANSFORM_TRIGO_SHIFT + 8)) + pivot->x;
 8022374:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022376:	689b      	ldr	r3, [r3, #8]
 8022378:	69ba      	ldr	r2, [r7, #24]
 802237a:	fb03 f202 	mul.w	r2, r3, r2
 802237e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022380:	685b      	ldr	r3, [r3, #4]
 8022382:	6979      	ldr	r1, [r7, #20]
 8022384:	fb01 f303 	mul.w	r3, r1, r3
 8022388:	1ad3      	subs	r3, r2, r3
 802238a:	149a      	asrs	r2, r3, #18
 802238c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 802238e:	681b      	ldr	r3, [r3, #0]
 8022390:	441a      	add	r2, r3
 8022392:	68fb      	ldr	r3, [r7, #12]
 8022394:	601a      	str	r2, [r3, #0]
            p->y = (((cache->sinma * x + cache->cosma * y)) >> (_LV_TRANSFORM_TRIGO_SHIFT + 8)) + pivot->y;
 8022396:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022398:	685b      	ldr	r3, [r3, #4]
 802239a:	69ba      	ldr	r2, [r7, #24]
 802239c:	fb03 f202 	mul.w	r2, r3, r2
 80223a0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80223a2:	689b      	ldr	r3, [r3, #8]
 80223a4:	6979      	ldr	r1, [r7, #20]
 80223a6:	fb01 f303 	mul.w	r3, r1, r3
 80223aa:	4413      	add	r3, r2
 80223ac:	149a      	asrs	r2, r3, #18
 80223ae:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80223b0:	685b      	ldr	r3, [r3, #4]
 80223b2:	441a      	add	r2, r3
 80223b4:	68fb      	ldr	r3, [r7, #12]
 80223b6:	605a      	str	r2, [r3, #4]
 80223b8:	e029      	b.n	802240e <lv_point_transform+0x286>
        }
        else {
            p->x = (((cache->cosma * x - cache->sinma * y) * scale_x) >> (_LV_TRANSFORM_TRIGO_SHIFT + 8)) + pivot->x;
 80223ba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80223bc:	689b      	ldr	r3, [r3, #8]
 80223be:	69ba      	ldr	r2, [r7, #24]
 80223c0:	fb03 f202 	mul.w	r2, r3, r2
 80223c4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80223c6:	685b      	ldr	r3, [r3, #4]
 80223c8:	6979      	ldr	r1, [r7, #20]
 80223ca:	fb01 f303 	mul.w	r3, r1, r3
 80223ce:	1ad3      	subs	r3, r2, r3
 80223d0:	687a      	ldr	r2, [r7, #4]
 80223d2:	fb02 f303 	mul.w	r3, r2, r3
 80223d6:	149a      	asrs	r2, r3, #18
 80223d8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80223da:	681b      	ldr	r3, [r3, #0]
 80223dc:	441a      	add	r2, r3
 80223de:	68fb      	ldr	r3, [r7, #12]
 80223e0:	601a      	str	r2, [r3, #0]
            p->y = (((cache->sinma * x + cache->cosma * y) * scale_y) >> (_LV_TRANSFORM_TRIGO_SHIFT + 8)) + pivot->y;
 80223e2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80223e4:	685b      	ldr	r3, [r3, #4]
 80223e6:	69ba      	ldr	r2, [r7, #24]
 80223e8:	fb03 f202 	mul.w	r2, r3, r2
 80223ec:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80223ee:	689b      	ldr	r3, [r3, #8]
 80223f0:	6979      	ldr	r1, [r7, #20]
 80223f2:	fb01 f303 	mul.w	r3, r1, r3
 80223f6:	4413      	add	r3, r2
 80223f8:	683a      	ldr	r2, [r7, #0]
 80223fa:	fb02 f303 	mul.w	r3, r2, r3
 80223fe:	149a      	asrs	r2, r3, #18
 8022400:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8022402:	685b      	ldr	r3, [r3, #4]
 8022404:	441a      	add	r2, r3
 8022406:	68fb      	ldr	r3, [r7, #12]
 8022408:	605a      	str	r2, [r3, #4]
 802240a:	e000      	b.n	802240e <lv_point_transform+0x286>
        return;
 802240c:	bf00      	nop
        }

    }
}
 802240e:	3740      	adds	r7, #64	@ 0x40
 8022410:	46bd      	mov	sp, r7
 8022412:	bd80      	pop	{r7, pc}
 8022414:	20000108 	.word	0x20000108
 8022418:	66666667 	.word	0x66666667

0802241c <lv_point_within_circle>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static bool lv_point_within_circle(const lv_area_t * area, const lv_point_t * p)
{
 802241c:	b480      	push	{r7}
 802241e:	b08b      	sub	sp, #44	@ 0x2c
 8022420:	af00      	add	r7, sp, #0
 8022422:	6078      	str	r0, [r7, #4]
 8022424:	6039      	str	r1, [r7, #0]
    int32_t r = (area->x2 - area->x1) / 2;
 8022426:	687b      	ldr	r3, [r7, #4]
 8022428:	689a      	ldr	r2, [r3, #8]
 802242a:	687b      	ldr	r3, [r7, #4]
 802242c:	681b      	ldr	r3, [r3, #0]
 802242e:	1ad3      	subs	r3, r2, r3
 8022430:	0fda      	lsrs	r2, r3, #31
 8022432:	4413      	add	r3, r2
 8022434:	105b      	asrs	r3, r3, #1
 8022436:	627b      	str	r3, [r7, #36]	@ 0x24

    /*Circle center*/
    int32_t cx = area->x1 + r;
 8022438:	687b      	ldr	r3, [r7, #4]
 802243a:	681b      	ldr	r3, [r3, #0]
 802243c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802243e:	4413      	add	r3, r2
 8022440:	623b      	str	r3, [r7, #32]
    int32_t cy = area->y1 + r;
 8022442:	687b      	ldr	r3, [r7, #4]
 8022444:	685b      	ldr	r3, [r3, #4]
 8022446:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8022448:	4413      	add	r3, r2
 802244a:	61fb      	str	r3, [r7, #28]

    /*Simplify the code by moving everything to (0, 0)*/
    int32_t px = p->x - cx;
 802244c:	683b      	ldr	r3, [r7, #0]
 802244e:	681a      	ldr	r2, [r3, #0]
 8022450:	6a3b      	ldr	r3, [r7, #32]
 8022452:	1ad3      	subs	r3, r2, r3
 8022454:	61bb      	str	r3, [r7, #24]
    int32_t py = p->y - cy;
 8022456:	683b      	ldr	r3, [r7, #0]
 8022458:	685a      	ldr	r2, [r3, #4]
 802245a:	69fb      	ldr	r3, [r7, #28]
 802245c:	1ad3      	subs	r3, r2, r3
 802245e:	617b      	str	r3, [r7, #20]

    uint32_t r_sqrd = r * r;
 8022460:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022462:	fb03 f303 	mul.w	r3, r3, r3
 8022466:	613b      	str	r3, [r7, #16]
    uint32_t dist = (px * px) + (py * py);
 8022468:	69bb      	ldr	r3, [r7, #24]
 802246a:	fb03 f203 	mul.w	r2, r3, r3
 802246e:	697b      	ldr	r3, [r7, #20]
 8022470:	fb03 f303 	mul.w	r3, r3, r3
 8022474:	4413      	add	r3, r2
 8022476:	60fb      	str	r3, [r7, #12]

    if(dist <= r_sqrd)
 8022478:	68fa      	ldr	r2, [r7, #12]
 802247a:	693b      	ldr	r3, [r7, #16]
 802247c:	429a      	cmp	r2, r3
 802247e:	d801      	bhi.n	8022484 <lv_point_within_circle+0x68>
        return true;
 8022480:	2301      	movs	r3, #1
 8022482:	e000      	b.n	8022486 <lv_point_within_circle+0x6a>
    else
        return false;
 8022484:	2300      	movs	r3, #0
}
 8022486:	4618      	mov	r0, r3
 8022488:	372c      	adds	r7, #44	@ 0x2c
 802248a:	46bd      	mov	sp, r7
 802248c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022490:	4770      	bx	lr

08022492 <lv_array_deinit>:
    array->data = lv_malloc(capacity * element_size);
    LV_ASSERT_MALLOC(array->data);
}

void lv_array_deinit(lv_array_t * array)
{
 8022492:	b580      	push	{r7, lr}
 8022494:	b082      	sub	sp, #8
 8022496:	af00      	add	r7, sp, #0
 8022498:	6078      	str	r0, [r7, #4]
    if(array->data) {
 802249a:	687b      	ldr	r3, [r7, #4]
 802249c:	681b      	ldr	r3, [r3, #0]
 802249e:	2b00      	cmp	r3, #0
 80224a0:	d007      	beq.n	80224b2 <lv_array_deinit+0x20>
        lv_free(array->data);
 80224a2:	687b      	ldr	r3, [r7, #4]
 80224a4:	681b      	ldr	r3, [r3, #0]
 80224a6:	4618      	mov	r0, r3
 80224a8:	f003 fcc6 	bl	8025e38 <lv_free>
        array->data = NULL;
 80224ac:	687b      	ldr	r3, [r7, #4]
 80224ae:	2200      	movs	r2, #0
 80224b0:	601a      	str	r2, [r3, #0]
    }

    array->size = 0;
 80224b2:	687b      	ldr	r3, [r7, #4]
 80224b4:	2200      	movs	r2, #0
 80224b6:	605a      	str	r2, [r3, #4]
    array->capacity = 0;
 80224b8:	687b      	ldr	r3, [r7, #4]
 80224ba:	2200      	movs	r2, #0
 80224bc:	609a      	str	r2, [r3, #8]
}
 80224be:	bf00      	nop
 80224c0:	3708      	adds	r7, #8
 80224c2:	46bd      	mov	sp, r7
 80224c4:	bd80      	pop	{r7, pc}

080224c6 <lv_array_at>:
    array->size++;
    return LV_RESULT_OK;
}

void * lv_array_at(const lv_array_t * array, uint32_t index)
{
 80224c6:	b480      	push	{r7}
 80224c8:	b083      	sub	sp, #12
 80224ca:	af00      	add	r7, sp, #0
 80224cc:	6078      	str	r0, [r7, #4]
 80224ce:	6039      	str	r1, [r7, #0]
    if(index >= array->size) {
 80224d0:	687b      	ldr	r3, [r7, #4]
 80224d2:	685b      	ldr	r3, [r3, #4]
 80224d4:	683a      	ldr	r2, [r7, #0]
 80224d6:	429a      	cmp	r2, r3
 80224d8:	d301      	bcc.n	80224de <lv_array_at+0x18>
        return NULL;
 80224da:	2300      	movs	r3, #0
 80224dc:	e00d      	b.n	80224fa <lv_array_at+0x34>
    }

    LV_ASSERT_NULL(array->data);
 80224de:	687b      	ldr	r3, [r7, #4]
 80224e0:	681b      	ldr	r3, [r3, #0]
 80224e2:	2b00      	cmp	r3, #0
 80224e4:	d101      	bne.n	80224ea <lv_array_at+0x24>
 80224e6:	bf00      	nop
 80224e8:	e7fd      	b.n	80224e6 <lv_array_at+0x20>
    return array->data + index * array->element_size;
 80224ea:	687b      	ldr	r3, [r7, #4]
 80224ec:	681a      	ldr	r2, [r3, #0]
 80224ee:	687b      	ldr	r3, [r7, #4]
 80224f0:	68db      	ldr	r3, [r3, #12]
 80224f2:	6839      	ldr	r1, [r7, #0]
 80224f4:	fb01 f303 	mul.w	r3, r1, r3
 80224f8:	4413      	add	r3, r2
}
 80224fa:	4618      	mov	r0, r3
 80224fc:	370c      	adds	r7, #12
 80224fe:	46bd      	mov	sp, r7
 8022500:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022504:	4770      	bx	lr
	...

08022508 <lv_color_format_get_bpp>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

uint8_t lv_color_format_get_bpp(lv_color_format_t cf)
{
 8022508:	b480      	push	{r7}
 802250a:	b083      	sub	sp, #12
 802250c:	af00      	add	r7, sp, #0
 802250e:	4603      	mov	r3, r0
 8022510:	71fb      	strb	r3, [r7, #7]
    switch(cf) {
 8022512:	79fb      	ldrb	r3, [r7, #7]
 8022514:	3b06      	subs	r3, #6
 8022516:	2b0e      	cmp	r3, #14
 8022518:	d82e      	bhi.n	8022578 <lv_color_format_get_bpp+0x70>
 802251a:	a201      	add	r2, pc, #4	@ (adr r2, 8022520 <lv_color_format_get_bpp+0x18>)
 802251c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8022520:	08022569 	.word	0x08022569
 8022524:	0802255d 	.word	0x0802255d
 8022528:	08022561 	.word	0x08022561
 802252c:	08022565 	.word	0x08022565
 8022530:	08022569 	.word	0x08022569
 8022534:	0802255d 	.word	0x0802255d
 8022538:	08022561 	.word	0x08022561
 802253c:	08022565 	.word	0x08022565
 8022540:	08022569 	.word	0x08022569
 8022544:	08022571 	.word	0x08022571
 8022548:	08022575 	.word	0x08022575
 802254c:	08022575 	.word	0x08022575
 8022550:	0802256d 	.word	0x0802256d
 8022554:	08022571 	.word	0x08022571
 8022558:	0802256d 	.word	0x0802256d
        case LV_COLOR_FORMAT_I1:
        case LV_COLOR_FORMAT_A1:
            return 1;
 802255c:	2301      	movs	r3, #1
 802255e:	e00c      	b.n	802257a <lv_color_format_get_bpp+0x72>
        case LV_COLOR_FORMAT_I2:
        case LV_COLOR_FORMAT_A2:
            return 2;
 8022560:	2302      	movs	r3, #2
 8022562:	e00a      	b.n	802257a <lv_color_format_get_bpp+0x72>
        case LV_COLOR_FORMAT_I4:
        case LV_COLOR_FORMAT_A4:
            return 4;
 8022564:	2304      	movs	r3, #4
 8022566:	e008      	b.n	802257a <lv_color_format_get_bpp+0x72>
        case LV_COLOR_FORMAT_L8:
        case LV_COLOR_FORMAT_A8:
        case LV_COLOR_FORMAT_I8:
            return 8;
 8022568:	2308      	movs	r3, #8
 802256a:	e006      	b.n	802257a <lv_color_format_get_bpp+0x72>

        case LV_COLOR_FORMAT_RGB565A8:
        case LV_COLOR_FORMAT_RGB565:
            return 16;
 802256c:	2310      	movs	r3, #16
 802256e:	e004      	b.n	802257a <lv_color_format_get_bpp+0x72>

        case LV_COLOR_FORMAT_ARGB8565:
        case LV_COLOR_FORMAT_RGB888:
            return 24;
 8022570:	2318      	movs	r3, #24
 8022572:	e002      	b.n	802257a <lv_color_format_get_bpp+0x72>
        case LV_COLOR_FORMAT_ARGB8888:
        case LV_COLOR_FORMAT_XRGB8888:
            return 32;
 8022574:	2320      	movs	r3, #32
 8022576:	e000      	b.n	802257a <lv_color_format_get_bpp+0x72>

        case LV_COLOR_FORMAT_UNKNOWN:
        default:
            return 0;
 8022578:	2300      	movs	r3, #0
    }
}
 802257a:	4618      	mov	r0, r3
 802257c:	370c      	adds	r7, #12
 802257e:	46bd      	mov	sp, r7
 8022580:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022584:	4770      	bx	lr
 8022586:	bf00      	nop

08022588 <lv_color_format_has_alpha>:

bool lv_color_format_has_alpha(lv_color_format_t cf)
{
 8022588:	b480      	push	{r7}
 802258a:	b083      	sub	sp, #12
 802258c:	af00      	add	r7, sp, #0
 802258e:	4603      	mov	r3, r0
 8022590:	71fb      	strb	r3, [r7, #7]
    switch(cf) {
 8022592:	79fb      	ldrb	r3, [r7, #7]
 8022594:	3b07      	subs	r3, #7
 8022596:	2b0d      	cmp	r3, #13
 8022598:	bf8c      	ite	hi
 802259a:	2201      	movhi	r2, #1
 802259c:	2200      	movls	r2, #0
 802259e:	b2d2      	uxtb	r2, r2
 80225a0:	2a00      	cmp	r2, #0
 80225a2:	d10e      	bne.n	80225c2 <lv_color_format_has_alpha+0x3a>
 80225a4:	f242 22ff 	movw	r2, #8959	@ 0x22ff
 80225a8:	fa22 f303 	lsr.w	r3, r2, r3
 80225ac:	f003 0301 	and.w	r3, r3, #1
 80225b0:	2b00      	cmp	r3, #0
 80225b2:	bf14      	ite	ne
 80225b4:	2301      	movne	r3, #1
 80225b6:	2300      	moveq	r3, #0
 80225b8:	b2db      	uxtb	r3, r3
 80225ba:	2b00      	cmp	r3, #0
 80225bc:	d001      	beq.n	80225c2 <lv_color_format_has_alpha+0x3a>
        case LV_COLOR_FORMAT_I2:
        case LV_COLOR_FORMAT_I4:
        case LV_COLOR_FORMAT_I8:
        case LV_COLOR_FORMAT_RGB565A8:
        case LV_COLOR_FORMAT_ARGB8888:
            return true;
 80225be:	2301      	movs	r3, #1
 80225c0:	e000      	b.n	80225c4 <lv_color_format_has_alpha+0x3c>
        default:
            return false;
 80225c2:	2300      	movs	r3, #0
    }
}
 80225c4:	4618      	mov	r0, r3
 80225c6:	370c      	adds	r7, #12
 80225c8:	46bd      	mov	sp, r7
 80225ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80225ce:	4770      	bx	lr

080225d0 <lv_color_to_32>:

lv_color32_t lv_color_to_32(lv_color_t color, lv_opa_t opa)
{
 80225d0:	b480      	push	{r7}
 80225d2:	b085      	sub	sp, #20
 80225d4:	af00      	add	r7, sp, #0
 80225d6:	6078      	str	r0, [r7, #4]
 80225d8:	460b      	mov	r3, r1
 80225da:	70fb      	strb	r3, [r7, #3]
    lv_color32_t c32;
    c32.red = color.red;
 80225dc:	79bb      	ldrb	r3, [r7, #6]
 80225de:	72bb      	strb	r3, [r7, #10]
    c32.green = color.green;
 80225e0:	797b      	ldrb	r3, [r7, #5]
 80225e2:	727b      	strb	r3, [r7, #9]
    c32.blue = color.blue;
 80225e4:	793b      	ldrb	r3, [r7, #4]
 80225e6:	723b      	strb	r3, [r7, #8]
    c32.alpha = opa;
 80225e8:	78fb      	ldrb	r3, [r7, #3]
 80225ea:	72fb      	strb	r3, [r7, #11]
    return c32;
 80225ec:	68bb      	ldr	r3, [r7, #8]
 80225ee:	60fb      	str	r3, [r7, #12]
 80225f0:	2300      	movs	r3, #0
 80225f2:	7b3a      	ldrb	r2, [r7, #12]
 80225f4:	f362 0307 	bfi	r3, r2, #0, #8
 80225f8:	7b7a      	ldrb	r2, [r7, #13]
 80225fa:	f362 230f 	bfi	r3, r2, #8, #8
 80225fe:	7bba      	ldrb	r2, [r7, #14]
 8022600:	f362 4317 	bfi	r3, r2, #16, #8
 8022604:	7bfa      	ldrb	r2, [r7, #15]
 8022606:	f362 631f 	bfi	r3, r2, #24, #8
}
 802260a:	4618      	mov	r0, r3
 802260c:	3714      	adds	r7, #20
 802260e:	46bd      	mov	sp, r7
 8022610:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022614:	4770      	bx	lr

08022616 <lv_color_to_u16>:

uint16_t lv_color_to_u16(lv_color_t color)
{
 8022616:	b480      	push	{r7}
 8022618:	b083      	sub	sp, #12
 802261a:	af00      	add	r7, sp, #0
 802261c:	6078      	str	r0, [r7, #4]
    return ((color.red & 0xF8) << 8) + ((color.green & 0xFC) << 3) + ((color.blue & 0xF8) >> 3);
 802261e:	79bb      	ldrb	r3, [r7, #6]
 8022620:	021b      	lsls	r3, r3, #8
 8022622:	b21b      	sxth	r3, r3
 8022624:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
 8022628:	f023 0307 	bic.w	r3, r3, #7
 802262c:	b21a      	sxth	r2, r3
 802262e:	797b      	ldrb	r3, [r7, #5]
 8022630:	00db      	lsls	r3, r3, #3
 8022632:	b21b      	sxth	r3, r3
 8022634:	f403 63fc 	and.w	r3, r3, #2016	@ 0x7e0
 8022638:	b21b      	sxth	r3, r3
 802263a:	4313      	orrs	r3, r2
 802263c:	b21b      	sxth	r3, r3
 802263e:	b29b      	uxth	r3, r3
 8022640:	793a      	ldrb	r2, [r7, #4]
 8022642:	08d2      	lsrs	r2, r2, #3
 8022644:	b2d2      	uxtb	r2, r2
 8022646:	4413      	add	r3, r2
 8022648:	b29b      	uxth	r3, r3
}
 802264a:	4618      	mov	r0, r3
 802264c:	370c      	adds	r7, #12
 802264e:	46bd      	mov	sp, r7
 8022650:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022654:	4770      	bx	lr

08022656 <lv_color_to_u32>:

uint32_t lv_color_to_u32(lv_color_t color)
{
 8022656:	b480      	push	{r7}
 8022658:	b083      	sub	sp, #12
 802265a:	af00      	add	r7, sp, #0
 802265c:	6078      	str	r0, [r7, #4]
    return (uint32_t)((uint32_t)0xff << 24) + (color.red << 16) + (color.green << 8) + (color.blue);
 802265e:	79bb      	ldrb	r3, [r7, #6]
 8022660:	041a      	lsls	r2, r3, #16
 8022662:	797b      	ldrb	r3, [r7, #5]
 8022664:	021b      	lsls	r3, r3, #8
 8022666:	4413      	add	r3, r2
 8022668:	793a      	ldrb	r2, [r7, #4]
 802266a:	4413      	add	r3, r2
 802266c:	f103 437f 	add.w	r3, r3, #4278190080	@ 0xff000000
}
 8022670:	4618      	mov	r0, r3
 8022672:	370c      	adds	r7, #12
 8022674:	46bd      	mov	sp, r7
 8022676:	f85d 7b04 	ldr.w	r7, [sp], #4
 802267a:	4770      	bx	lr

0802267c <lv_array_size>:
 * Return how many elements are stored in the array.
 * @param array pointer to an `lv_array_t` variable
 * @return the number of elements stored in the array
 */
static inline uint32_t lv_array_size(const lv_array_t * array)
{
 802267c:	b480      	push	{r7}
 802267e:	b083      	sub	sp, #12
 8022680:	af00      	add	r7, sp, #0
 8022682:	6078      	str	r0, [r7, #4]
    return array->size;
 8022684:	687b      	ldr	r3, [r7, #4]
 8022686:	685b      	ldr	r3, [r3, #4]
}
 8022688:	4618      	mov	r0, r3
 802268a:	370c      	adds	r7, #12
 802268c:	46bd      	mov	sp, r7
 802268e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022692:	4770      	bx	lr

08022694 <lv_array_front>:
 * Returns a pointer to the first element in the array.
 * @param array pointer to an `lv_array_t` variable
 * @return a pointer to the first element in the array
 */
static inline void * lv_array_front(const lv_array_t * array)
{
 8022694:	b580      	push	{r7, lr}
 8022696:	b082      	sub	sp, #8
 8022698:	af00      	add	r7, sp, #0
 802269a:	6078      	str	r0, [r7, #4]
    return lv_array_at(array, 0);
 802269c:	2100      	movs	r1, #0
 802269e:	6878      	ldr	r0, [r7, #4]
 80226a0:	f7ff ff11 	bl	80224c6 <lv_array_at>
 80226a4:	4603      	mov	r3, r0
}
 80226a6:	4618      	mov	r0, r3
 80226a8:	3708      	adds	r7, #8
 80226aa:	46bd      	mov	sp, r7
 80226ac:	bd80      	pop	{r7, pc}
	...

080226b0 <_lv_event_push>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void _lv_event_push(lv_event_t * e)
{
 80226b0:	b480      	push	{r7}
 80226b2:	b083      	sub	sp, #12
 80226b4:	af00      	add	r7, sp, #0
 80226b6:	6078      	str	r0, [r7, #4]
    /*Build a simple linked list from the objects used in the events
     *It's important to know if this object was deleted by a nested event
     *called from this `event_cb`.*/
    e->prev = event_head;
 80226b8:	4b06      	ldr	r3, [pc, #24]	@ (80226d4 <_lv_event_push+0x24>)
 80226ba:	6f9a      	ldr	r2, [r3, #120]	@ 0x78
 80226bc:	687b      	ldr	r3, [r7, #4]
 80226be:	615a      	str	r2, [r3, #20]
    event_head = e;
 80226c0:	4a04      	ldr	r2, [pc, #16]	@ (80226d4 <_lv_event_push+0x24>)
 80226c2:	687b      	ldr	r3, [r7, #4]
 80226c4:	6793      	str	r3, [r2, #120]	@ 0x78

}
 80226c6:	bf00      	nop
 80226c8:	370c      	adds	r7, #12
 80226ca:	46bd      	mov	sp, r7
 80226cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80226d0:	4770      	bx	lr
 80226d2:	bf00      	nop
 80226d4:	2000009c 	.word	0x2000009c

080226d8 <_lv_event_pop>:

void _lv_event_pop(lv_event_t * e)
{
 80226d8:	b480      	push	{r7}
 80226da:	b083      	sub	sp, #12
 80226dc:	af00      	add	r7, sp, #0
 80226de:	6078      	str	r0, [r7, #4]
    event_head = e->prev;
 80226e0:	687b      	ldr	r3, [r7, #4]
 80226e2:	695b      	ldr	r3, [r3, #20]
 80226e4:	4a03      	ldr	r2, [pc, #12]	@ (80226f4 <_lv_event_pop+0x1c>)
 80226e6:	6793      	str	r3, [r2, #120]	@ 0x78
}
 80226e8:	bf00      	nop
 80226ea:	370c      	adds	r7, #12
 80226ec:	46bd      	mov	sp, r7
 80226ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80226f2:	4770      	bx	lr
 80226f4:	2000009c 	.word	0x2000009c

080226f8 <lv_event_send>:

lv_result_t lv_event_send(lv_event_list_t * list, lv_event_t * e, bool preprocess)
{
 80226f8:	b580      	push	{r7, lr}
 80226fa:	b088      	sub	sp, #32
 80226fc:	af00      	add	r7, sp, #0
 80226fe:	60f8      	str	r0, [r7, #12]
 8022700:	60b9      	str	r1, [r7, #8]
 8022702:	4613      	mov	r3, r2
 8022704:	71fb      	strb	r3, [r7, #7]
    if(list == NULL) return LV_RESULT_OK;
 8022706:	68fb      	ldr	r3, [r7, #12]
 8022708:	2b00      	cmp	r3, #0
 802270a:	d101      	bne.n	8022710 <lv_event_send+0x18>
 802270c:	2301      	movs	r3, #1
 802270e:	e064      	b.n	80227da <lv_event_send+0xe2>

    uint32_t i = 0;
 8022710:	2300      	movs	r3, #0
 8022712:	61fb      	str	r3, [r7, #28]
    lv_event_dsc_t ** dsc = lv_array_front(list);
 8022714:	68f8      	ldr	r0, [r7, #12]
 8022716:	f7ff ffbd 	bl	8022694 <lv_array_front>
 802271a:	61b8      	str	r0, [r7, #24]
    uint32_t size = lv_array_size(list);
 802271c:	68f8      	ldr	r0, [r7, #12]
 802271e:	f7ff ffad 	bl	802267c <lv_array_size>
 8022722:	6178      	str	r0, [r7, #20]
    for(i = 0; i < size; i++) {
 8022724:	2300      	movs	r3, #0
 8022726:	61fb      	str	r3, [r7, #28]
 8022728:	e052      	b.n	80227d0 <lv_event_send+0xd8>
        if(dsc[i]->cb == NULL) continue;
 802272a:	69fb      	ldr	r3, [r7, #28]
 802272c:	009b      	lsls	r3, r3, #2
 802272e:	69ba      	ldr	r2, [r7, #24]
 8022730:	4413      	add	r3, r2
 8022732:	681b      	ldr	r3, [r3, #0]
 8022734:	681b      	ldr	r3, [r3, #0]
 8022736:	2b00      	cmp	r3, #0
 8022738:	d044      	beq.n	80227c4 <lv_event_send+0xcc>
        bool is_preprocessed = (dsc[i]->filter & LV_EVENT_PREPROCESS) != 0;
 802273a:	69fb      	ldr	r3, [r7, #28]
 802273c:	009b      	lsls	r3, r3, #2
 802273e:	69ba      	ldr	r2, [r7, #24]
 8022740:	4413      	add	r3, r2
 8022742:	681b      	ldr	r3, [r3, #0]
 8022744:	689b      	ldr	r3, [r3, #8]
 8022746:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 802274a:	2b00      	cmp	r3, #0
 802274c:	bf14      	ite	ne
 802274e:	2301      	movne	r3, #1
 8022750:	2300      	moveq	r3, #0
 8022752:	74fb      	strb	r3, [r7, #19]
        if(is_preprocessed != preprocess) continue;
 8022754:	7cfa      	ldrb	r2, [r7, #19]
 8022756:	79fb      	ldrb	r3, [r7, #7]
 8022758:	429a      	cmp	r2, r3
 802275a:	d135      	bne.n	80227c8 <lv_event_send+0xd0>
        lv_event_code_t filter = dsc[i]->filter & ~LV_EVENT_PREPROCESS;
 802275c:	69fb      	ldr	r3, [r7, #28]
 802275e:	009b      	lsls	r3, r3, #2
 8022760:	69ba      	ldr	r2, [r7, #24]
 8022762:	4413      	add	r3, r2
 8022764:	681b      	ldr	r3, [r3, #0]
 8022766:	689b      	ldr	r3, [r3, #8]
 8022768:	b29b      	uxth	r3, r3
 802276a:	f3c3 030e 	ubfx	r3, r3, #0, #15
 802276e:	823b      	strh	r3, [r7, #16]
        if(filter == LV_EVENT_ALL || filter == e->code) {
 8022770:	8a3b      	ldrh	r3, [r7, #16]
 8022772:	2b00      	cmp	r3, #0
 8022774:	d004      	beq.n	8022780 <lv_event_send+0x88>
 8022776:	68bb      	ldr	r3, [r7, #8]
 8022778:	891b      	ldrh	r3, [r3, #8]
 802277a:	8a3a      	ldrh	r2, [r7, #16]
 802277c:	429a      	cmp	r2, r3
 802277e:	d124      	bne.n	80227ca <lv_event_send+0xd2>
            e->user_data = dsc[i]->user_data;
 8022780:	69fb      	ldr	r3, [r7, #28]
 8022782:	009b      	lsls	r3, r3, #2
 8022784:	69ba      	ldr	r2, [r7, #24]
 8022786:	4413      	add	r3, r2
 8022788:	681b      	ldr	r3, [r3, #0]
 802278a:	685a      	ldr	r2, [r3, #4]
 802278c:	68bb      	ldr	r3, [r7, #8]
 802278e:	60da      	str	r2, [r3, #12]
            dsc[i]->cb(e);
 8022790:	69fb      	ldr	r3, [r7, #28]
 8022792:	009b      	lsls	r3, r3, #2
 8022794:	69ba      	ldr	r2, [r7, #24]
 8022796:	4413      	add	r3, r2
 8022798:	681b      	ldr	r3, [r3, #0]
 802279a:	681b      	ldr	r3, [r3, #0]
 802279c:	68b8      	ldr	r0, [r7, #8]
 802279e:	4798      	blx	r3
            if(e->stop_processing) return LV_RESULT_OK;
 80227a0:	68bb      	ldr	r3, [r7, #8]
 80227a2:	7e1b      	ldrb	r3, [r3, #24]
 80227a4:	f003 0302 	and.w	r3, r3, #2
 80227a8:	b2db      	uxtb	r3, r3
 80227aa:	2b00      	cmp	r3, #0
 80227ac:	d001      	beq.n	80227b2 <lv_event_send+0xba>
 80227ae:	2301      	movs	r3, #1
 80227b0:	e013      	b.n	80227da <lv_event_send+0xe2>

            /*Stop if the object is deleted*/
            if(e->deleted) return LV_RESULT_INVALID;
 80227b2:	68bb      	ldr	r3, [r7, #8]
 80227b4:	7e1b      	ldrb	r3, [r3, #24]
 80227b6:	f003 0301 	and.w	r3, r3, #1
 80227ba:	b2db      	uxtb	r3, r3
 80227bc:	2b00      	cmp	r3, #0
 80227be:	d004      	beq.n	80227ca <lv_event_send+0xd2>
 80227c0:	2300      	movs	r3, #0
 80227c2:	e00a      	b.n	80227da <lv_event_send+0xe2>
        if(dsc[i]->cb == NULL) continue;
 80227c4:	bf00      	nop
 80227c6:	e000      	b.n	80227ca <lv_event_send+0xd2>
        if(is_preprocessed != preprocess) continue;
 80227c8:	bf00      	nop
    for(i = 0; i < size; i++) {
 80227ca:	69fb      	ldr	r3, [r7, #28]
 80227cc:	3301      	adds	r3, #1
 80227ce:	61fb      	str	r3, [r7, #28]
 80227d0:	69fa      	ldr	r2, [r7, #28]
 80227d2:	697b      	ldr	r3, [r7, #20]
 80227d4:	429a      	cmp	r2, r3
 80227d6:	d3a8      	bcc.n	802272a <lv_event_send+0x32>

        }
    }
    return LV_RESULT_OK;
 80227d8:	2301      	movs	r3, #1
}
 80227da:	4618      	mov	r0, r3
 80227dc:	3720      	adds	r7, #32
 80227de:	46bd      	mov	sp, r7
 80227e0:	bd80      	pop	{r7, pc}

080227e2 <lv_event_remove_all>:
    lv_free(dsc);
    return lv_array_remove(list, index);
}

void lv_event_remove_all(lv_event_list_t * list)
{
 80227e2:	b580      	push	{r7, lr}
 80227e4:	b086      	sub	sp, #24
 80227e6:	af00      	add	r7, sp, #0
 80227e8:	6078      	str	r0, [r7, #4]
    LV_ASSERT_NULL(list);
 80227ea:	687b      	ldr	r3, [r7, #4]
 80227ec:	2b00      	cmp	r3, #0
 80227ee:	d101      	bne.n	80227f4 <lv_event_remove_all+0x12>
 80227f0:	bf00      	nop
 80227f2:	e7fd      	b.n	80227f0 <lv_event_remove_all+0xe>
    int size = lv_array_size(list);
 80227f4:	6878      	ldr	r0, [r7, #4]
 80227f6:	f7ff ff41 	bl	802267c <lv_array_size>
 80227fa:	4603      	mov	r3, r0
 80227fc:	613b      	str	r3, [r7, #16]
    lv_event_dsc_t ** dsc = lv_array_front(list);
 80227fe:	6878      	ldr	r0, [r7, #4]
 8022800:	f7ff ff48 	bl	8022694 <lv_array_front>
 8022804:	60f8      	str	r0, [r7, #12]
    for(int i = 0; i < size; i++) {
 8022806:	2300      	movs	r3, #0
 8022808:	617b      	str	r3, [r7, #20]
 802280a:	e00a      	b.n	8022822 <lv_event_remove_all+0x40>
        lv_free(dsc[i]);
 802280c:	697b      	ldr	r3, [r7, #20]
 802280e:	009b      	lsls	r3, r3, #2
 8022810:	68fa      	ldr	r2, [r7, #12]
 8022812:	4413      	add	r3, r2
 8022814:	681b      	ldr	r3, [r3, #0]
 8022816:	4618      	mov	r0, r3
 8022818:	f003 fb0e 	bl	8025e38 <lv_free>
    for(int i = 0; i < size; i++) {
 802281c:	697b      	ldr	r3, [r7, #20]
 802281e:	3301      	adds	r3, #1
 8022820:	617b      	str	r3, [r7, #20]
 8022822:	697a      	ldr	r2, [r7, #20]
 8022824:	693b      	ldr	r3, [r7, #16]
 8022826:	429a      	cmp	r2, r3
 8022828:	dbf0      	blt.n	802280c <lv_event_remove_all+0x2a>
    }
    lv_array_deinit(list);
 802282a:	6878      	ldr	r0, [r7, #4]
 802282c:	f7ff fe31 	bl	8022492 <lv_array_deinit>
}
 8022830:	bf00      	nop
 8022832:	3718      	adds	r7, #24
 8022834:	46bd      	mov	sp, r7
 8022836:	bd80      	pop	{r7, pc}

08022838 <lv_event_get_current_target>:

void * lv_event_get_current_target(lv_event_t * e)
{
 8022838:	b480      	push	{r7}
 802283a:	b083      	sub	sp, #12
 802283c:	af00      	add	r7, sp, #0
 802283e:	6078      	str	r0, [r7, #4]
    return e->current_target;
 8022840:	687b      	ldr	r3, [r7, #4]
 8022842:	681b      	ldr	r3, [r3, #0]
}
 8022844:	4618      	mov	r0, r3
 8022846:	370c      	adds	r7, #12
 8022848:	46bd      	mov	sp, r7
 802284a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802284e:	4770      	bx	lr

08022850 <lv_event_get_code>:
{
    return e->original_target;
}

lv_event_code_t lv_event_get_code(lv_event_t * e)
{
 8022850:	b480      	push	{r7}
 8022852:	b083      	sub	sp, #12
 8022854:	af00      	add	r7, sp, #0
 8022856:	6078      	str	r0, [r7, #4]
    return e->code & ~LV_EVENT_PREPROCESS;
 8022858:	687b      	ldr	r3, [r7, #4]
 802285a:	891b      	ldrh	r3, [r3, #8]
 802285c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8022860:	b29b      	uxth	r3, r3
}
 8022862:	4618      	mov	r0, r3
 8022864:	370c      	adds	r7, #12
 8022866:	46bd      	mov	sp, r7
 8022868:	f85d 7b04 	ldr.w	r7, [sp], #4
 802286c:	4770      	bx	lr

0802286e <lv_event_get_param>:

void * lv_event_get_param(lv_event_t * e)
{
 802286e:	b480      	push	{r7}
 8022870:	b083      	sub	sp, #12
 8022872:	af00      	add	r7, sp, #0
 8022874:	6078      	str	r0, [r7, #4]
    return e->param;
 8022876:	687b      	ldr	r3, [r7, #4]
 8022878:	691b      	ldr	r3, [r3, #16]
}
 802287a:	4618      	mov	r0, r3
 802287c:	370c      	adds	r7, #12
 802287e:	46bd      	mov	sp, r7
 8022880:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022884:	4770      	bx	lr
	...

08022888 <_lv_event_mark_deleted>:
    event_last_id ++;
    return event_last_id;
}

void _lv_event_mark_deleted(void * target)
{
 8022888:	b480      	push	{r7}
 802288a:	b085      	sub	sp, #20
 802288c:	af00      	add	r7, sp, #0
 802288e:	6078      	str	r0, [r7, #4]
    lv_event_t * e = event_head;
 8022890:	4b0f      	ldr	r3, [pc, #60]	@ (80228d0 <_lv_event_mark_deleted+0x48>)
 8022892:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8022894:	60fb      	str	r3, [r7, #12]

    while(e) {
 8022896:	e011      	b.n	80228bc <_lv_event_mark_deleted+0x34>
        if(e->original_target == target || e->current_target == target) e->deleted = 1;
 8022898:	68fb      	ldr	r3, [r7, #12]
 802289a:	685b      	ldr	r3, [r3, #4]
 802289c:	687a      	ldr	r2, [r7, #4]
 802289e:	429a      	cmp	r2, r3
 80228a0:	d004      	beq.n	80228ac <_lv_event_mark_deleted+0x24>
 80228a2:	68fb      	ldr	r3, [r7, #12]
 80228a4:	681b      	ldr	r3, [r3, #0]
 80228a6:	687a      	ldr	r2, [r7, #4]
 80228a8:	429a      	cmp	r2, r3
 80228aa:	d104      	bne.n	80228b6 <_lv_event_mark_deleted+0x2e>
 80228ac:	68fa      	ldr	r2, [r7, #12]
 80228ae:	7e13      	ldrb	r3, [r2, #24]
 80228b0:	f043 0301 	orr.w	r3, r3, #1
 80228b4:	7613      	strb	r3, [r2, #24]
        e = e->prev;
 80228b6:	68fb      	ldr	r3, [r7, #12]
 80228b8:	695b      	ldr	r3, [r3, #20]
 80228ba:	60fb      	str	r3, [r7, #12]
    while(e) {
 80228bc:	68fb      	ldr	r3, [r7, #12]
 80228be:	2b00      	cmp	r3, #0
 80228c0:	d1ea      	bne.n	8022898 <_lv_event_mark_deleted+0x10>
    }
}
 80228c2:	bf00      	nop
 80228c4:	bf00      	nop
 80228c6:	3714      	adds	r7, #20
 80228c8:	46bd      	mov	sp, r7
 80228ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80228ce:	4770      	bx	lr
 80228d0:	2000009c 	.word	0x2000009c

080228d4 <_lv_fs_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void _lv_fs_init(void)
{
 80228d4:	b580      	push	{r7, lr}
 80228d6:	af00      	add	r7, sp, #0
    _lv_ll_init(fsdrv_ll_p, sizeof(lv_fs_drv_t *));
 80228d8:	2104      	movs	r1, #4
 80228da:	4802      	ldr	r0, [pc, #8]	@ (80228e4 <_lv_fs_init+0x10>)
 80228dc:	f000 fb99 	bl	8023012 <_lv_ll_init>
}
 80228e0:	bf00      	nop
 80228e2:	bd80      	pop	{r7, pc}
 80228e4:	20000238 	.word	0x20000238

080228e8 <lv_fs_open>:

    return drv->ready_cb(drv);
}

lv_fs_res_t lv_fs_open(lv_fs_file_t * file_p, const char * path, lv_fs_mode_t mode)
{
 80228e8:	b580      	push	{r7, lr}
 80228ea:	b08a      	sub	sp, #40	@ 0x28
 80228ec:	af00      	add	r7, sp, #0
 80228ee:	60f8      	str	r0, [r7, #12]
 80228f0:	60b9      	str	r1, [r7, #8]
 80228f2:	4613      	mov	r3, r2
 80228f4:	71fb      	strb	r3, [r7, #7]
    if(path == NULL) {
 80228f6:	68bb      	ldr	r3, [r7, #8]
 80228f8:	2b00      	cmp	r3, #0
 80228fa:	d101      	bne.n	8022900 <lv_fs_open+0x18>
        LV_LOG_WARN("Can't open file: path is NULL");
        return LV_FS_RES_INV_PARAM;
 80228fc:	230b      	movs	r3, #11
 80228fe:	e07c      	b.n	80229fa <lv_fs_open+0x112>
    }

    char letter = path[0];
 8022900:	68bb      	ldr	r3, [r7, #8]
 8022902:	781b      	ldrb	r3, [r3, #0]
 8022904:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    lv_fs_drv_t * drv = lv_fs_get_drv(letter);
 8022908:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 802290c:	4618      	mov	r0, r3
 802290e:	f000 fb19 	bl	8022f44 <lv_fs_get_drv>
 8022912:	6238      	str	r0, [r7, #32]

    if(drv == NULL) {
 8022914:	6a3b      	ldr	r3, [r7, #32]
 8022916:	2b00      	cmp	r3, #0
 8022918:	d101      	bne.n	802291e <lv_fs_open+0x36>
        LV_LOG_WARN("Can't open file (%s): unknown driver letter", path);
        return LV_FS_RES_NOT_EX;
 802291a:	2303      	movs	r3, #3
 802291c:	e06d      	b.n	80229fa <lv_fs_open+0x112>
    }

    if(drv->ready_cb) {
 802291e:	6a3b      	ldr	r3, [r7, #32]
 8022920:	689b      	ldr	r3, [r3, #8]
 8022922:	2b00      	cmp	r3, #0
 8022924:	d00b      	beq.n	802293e <lv_fs_open+0x56>
        if(drv->ready_cb(drv) == false) {
 8022926:	6a3b      	ldr	r3, [r7, #32]
 8022928:	689b      	ldr	r3, [r3, #8]
 802292a:	6a38      	ldr	r0, [r7, #32]
 802292c:	4798      	blx	r3
 802292e:	4603      	mov	r3, r0
 8022930:	f083 0301 	eor.w	r3, r3, #1
 8022934:	b2db      	uxtb	r3, r3
 8022936:	2b00      	cmp	r3, #0
 8022938:	d001      	beq.n	802293e <lv_fs_open+0x56>
            LV_LOG_WARN("Can't open file (%s): driver not ready", path);
            return LV_FS_RES_HW_ERR;
 802293a:	2301      	movs	r3, #1
 802293c:	e05d      	b.n	80229fa <lv_fs_open+0x112>
        }
    }

    if(drv->open_cb == NULL) {
 802293e:	6a3b      	ldr	r3, [r7, #32]
 8022940:	68db      	ldr	r3, [r3, #12]
 8022942:	2b00      	cmp	r3, #0
 8022944:	d101      	bne.n	802294a <lv_fs_open+0x62>
        LV_LOG_WARN("Can't open file (%s): open function not exists", path);
        return LV_FS_RES_NOT_IMP;
 8022946:	2309      	movs	r3, #9
 8022948:	e057      	b.n	80229fa <lv_fs_open+0x112>
    }

    file_p->drv = drv;
 802294a:	68fb      	ldr	r3, [r7, #12]
 802294c:	6a3a      	ldr	r2, [r7, #32]
 802294e:	605a      	str	r2, [r3, #4]

    /* For memory-mapped files we set the file handle to our file descriptor so that we can access the cache from the file operations */
    if(drv->cache_size == LV_FS_CACHE_FROM_BUFFER) {
 8022950:	6a3b      	ldr	r3, [r7, #32]
 8022952:	685b      	ldr	r3, [r3, #4]
 8022954:	f1b3 3fff 	cmp.w	r3, #4294967295
 8022958:	d103      	bne.n	8022962 <lv_fs_open+0x7a>
        file_p->file_d = file_p;
 802295a:	68fb      	ldr	r3, [r7, #12]
 802295c:	68fa      	ldr	r2, [r7, #12]
 802295e:	601a      	str	r2, [r3, #0]
 8022960:	e016      	b.n	8022990 <lv_fs_open+0xa8>
    }
    else {
        const char * real_path = lv_fs_get_real_path(path);
 8022962:	68b8      	ldr	r0, [r7, #8]
 8022964:	f000 fb40 	bl	8022fe8 <lv_fs_get_real_path>
 8022968:	61f8      	str	r0, [r7, #28]
        void * file_d = drv->open_cb(drv, real_path, mode);
 802296a:	6a3b      	ldr	r3, [r7, #32]
 802296c:	68db      	ldr	r3, [r3, #12]
 802296e:	79fa      	ldrb	r2, [r7, #7]
 8022970:	69f9      	ldr	r1, [r7, #28]
 8022972:	6a38      	ldr	r0, [r7, #32]
 8022974:	4798      	blx	r3
 8022976:	61b8      	str	r0, [r7, #24]
        if(file_d == NULL || file_d == (void *)(-1)) {
 8022978:	69bb      	ldr	r3, [r7, #24]
 802297a:	2b00      	cmp	r3, #0
 802297c:	d003      	beq.n	8022986 <lv_fs_open+0x9e>
 802297e:	69bb      	ldr	r3, [r7, #24]
 8022980:	f1b3 3fff 	cmp.w	r3, #4294967295
 8022984:	d101      	bne.n	802298a <lv_fs_open+0xa2>
            return LV_FS_RES_UNKNOWN;
 8022986:	230c      	movs	r3, #12
 8022988:	e037      	b.n	80229fa <lv_fs_open+0x112>
        }
        file_p->file_d = file_d;
 802298a:	68fb      	ldr	r3, [r7, #12]
 802298c:	69ba      	ldr	r2, [r7, #24]
 802298e:	601a      	str	r2, [r3, #0]
    }

    if(drv->cache_size) {
 8022990:	6a3b      	ldr	r3, [r7, #32]
 8022992:	685b      	ldr	r3, [r3, #4]
 8022994:	2b00      	cmp	r3, #0
 8022996:	d02f      	beq.n	80229f8 <lv_fs_open+0x110>
        file_p->cache = lv_malloc_zeroed(sizeof(lv_fs_file_cache_t));
 8022998:	2010      	movs	r0, #16
 802299a:	f003 fa2f 	bl	8025dfc <lv_malloc_zeroed>
 802299e:	4602      	mov	r2, r0
 80229a0:	68fb      	ldr	r3, [r7, #12]
 80229a2:	609a      	str	r2, [r3, #8]
        LV_ASSERT_MALLOC(file_p->cache);
 80229a4:	68fb      	ldr	r3, [r7, #12]
 80229a6:	689b      	ldr	r3, [r3, #8]
 80229a8:	2b00      	cmp	r3, #0
 80229aa:	d101      	bne.n	80229b0 <lv_fs_open+0xc8>
 80229ac:	bf00      	nop
 80229ae:	e7fd      	b.n	80229ac <lv_fs_open+0xc4>

        /* If this is a memory-mapped file, then set "cache" to the memory buffer */
        if(drv->cache_size == LV_FS_CACHE_FROM_BUFFER) {
 80229b0:	6a3b      	ldr	r3, [r7, #32]
 80229b2:	685b      	ldr	r3, [r3, #4]
 80229b4:	f1b3 3fff 	cmp.w	r3, #4294967295
 80229b8:	d114      	bne.n	80229e4 <lv_fs_open+0xfc>
            lv_fs_path_ex_t * path_ex = (lv_fs_path_ex_t *)path;
 80229ba:	68bb      	ldr	r3, [r7, #8]
 80229bc:	617b      	str	r3, [r7, #20]
            file_p->cache->buffer = (void *)path_ex->buffer;
 80229be:	68fb      	ldr	r3, [r7, #12]
 80229c0:	689b      	ldr	r3, [r3, #8]
 80229c2:	697a      	ldr	r2, [r7, #20]
 80229c4:	6852      	ldr	r2, [r2, #4]
 80229c6:	60da      	str	r2, [r3, #12]
            file_p->cache->start = 0;
 80229c8:	68fb      	ldr	r3, [r7, #12]
 80229ca:	689b      	ldr	r3, [r3, #8]
 80229cc:	2200      	movs	r2, #0
 80229ce:	601a      	str	r2, [r3, #0]
            file_p->cache->file_position = 0;
 80229d0:	68fb      	ldr	r3, [r7, #12]
 80229d2:	689b      	ldr	r3, [r3, #8]
 80229d4:	2200      	movs	r2, #0
 80229d6:	609a      	str	r2, [r3, #8]
            file_p->cache->end = path_ex->size;
 80229d8:	68fb      	ldr	r3, [r7, #12]
 80229da:	689b      	ldr	r3, [r3, #8]
 80229dc:	697a      	ldr	r2, [r7, #20]
 80229de:	6892      	ldr	r2, [r2, #8]
 80229e0:	605a      	str	r2, [r3, #4]
 80229e2:	e009      	b.n	80229f8 <lv_fs_open+0x110>
        }
        /*Set an invalid range by default*/
        else {
            file_p->cache->start = UINT32_MAX;
 80229e4:	68fb      	ldr	r3, [r7, #12]
 80229e6:	689b      	ldr	r3, [r3, #8]
 80229e8:	f04f 32ff 	mov.w	r2, #4294967295
 80229ec:	601a      	str	r2, [r3, #0]
            file_p->cache->end = UINT32_MAX - 1;
 80229ee:	68fb      	ldr	r3, [r7, #12]
 80229f0:	689b      	ldr	r3, [r3, #8]
 80229f2:	f06f 0201 	mvn.w	r2, #1
 80229f6:	605a      	str	r2, [r3, #4]
        }
    }

    return LV_FS_RES_OK;
 80229f8:	2300      	movs	r3, #0
}
 80229fa:	4618      	mov	r0, r3
 80229fc:	3728      	adds	r7, #40	@ 0x28
 80229fe:	46bd      	mov	sp, r7
 8022a00:	bd80      	pop	{r7, pc}

08022a02 <lv_fs_close>:
    path->buffer = buf;
    path->size = size;
}

lv_fs_res_t lv_fs_close(lv_fs_file_t * file_p)
{
 8022a02:	b580      	push	{r7, lr}
 8022a04:	b084      	sub	sp, #16
 8022a06:	af00      	add	r7, sp, #0
 8022a08:	6078      	str	r0, [r7, #4]
    if(file_p->drv == NULL) {
 8022a0a:	687b      	ldr	r3, [r7, #4]
 8022a0c:	685b      	ldr	r3, [r3, #4]
 8022a0e:	2b00      	cmp	r3, #0
 8022a10:	d101      	bne.n	8022a16 <lv_fs_close+0x14>
        return LV_FS_RES_INV_PARAM;
 8022a12:	230b      	movs	r3, #11
 8022a14:	e03a      	b.n	8022a8c <lv_fs_close+0x8a>
    }

    if(file_p->drv->close_cb == NULL) {
 8022a16:	687b      	ldr	r3, [r7, #4]
 8022a18:	685b      	ldr	r3, [r3, #4]
 8022a1a:	691b      	ldr	r3, [r3, #16]
 8022a1c:	2b00      	cmp	r3, #0
 8022a1e:	d101      	bne.n	8022a24 <lv_fs_close+0x22>
        return LV_FS_RES_NOT_IMP;
 8022a20:	2309      	movs	r3, #9
 8022a22:	e033      	b.n	8022a8c <lv_fs_close+0x8a>
    }

    lv_fs_res_t res = file_p->drv->close_cb(file_p->drv, file_p->file_d);
 8022a24:	687b      	ldr	r3, [r7, #4]
 8022a26:	685b      	ldr	r3, [r3, #4]
 8022a28:	691b      	ldr	r3, [r3, #16]
 8022a2a:	687a      	ldr	r2, [r7, #4]
 8022a2c:	6850      	ldr	r0, [r2, #4]
 8022a2e:	687a      	ldr	r2, [r7, #4]
 8022a30:	6812      	ldr	r2, [r2, #0]
 8022a32:	4611      	mov	r1, r2
 8022a34:	4798      	blx	r3
 8022a36:	4603      	mov	r3, r0
 8022a38:	73fb      	strb	r3, [r7, #15]

    if(file_p->drv->cache_size && file_p->cache) {
 8022a3a:	687b      	ldr	r3, [r7, #4]
 8022a3c:	685b      	ldr	r3, [r3, #4]
 8022a3e:	685b      	ldr	r3, [r3, #4]
 8022a40:	2b00      	cmp	r3, #0
 8022a42:	d019      	beq.n	8022a78 <lv_fs_close+0x76>
 8022a44:	687b      	ldr	r3, [r7, #4]
 8022a46:	689b      	ldr	r3, [r3, #8]
 8022a48:	2b00      	cmp	r3, #0
 8022a4a:	d015      	beq.n	8022a78 <lv_fs_close+0x76>
        /* Only free cache if it was pre-allocated (for memory-mapped files it is never allocated) */
        if(file_p->drv->cache_size != LV_FS_CACHE_FROM_BUFFER && file_p->cache->buffer) {
 8022a4c:	687b      	ldr	r3, [r7, #4]
 8022a4e:	685b      	ldr	r3, [r3, #4]
 8022a50:	685b      	ldr	r3, [r3, #4]
 8022a52:	f1b3 3fff 	cmp.w	r3, #4294967295
 8022a56:	d00a      	beq.n	8022a6e <lv_fs_close+0x6c>
 8022a58:	687b      	ldr	r3, [r7, #4]
 8022a5a:	689b      	ldr	r3, [r3, #8]
 8022a5c:	68db      	ldr	r3, [r3, #12]
 8022a5e:	2b00      	cmp	r3, #0
 8022a60:	d005      	beq.n	8022a6e <lv_fs_close+0x6c>
            lv_free(file_p->cache->buffer);
 8022a62:	687b      	ldr	r3, [r7, #4]
 8022a64:	689b      	ldr	r3, [r3, #8]
 8022a66:	68db      	ldr	r3, [r3, #12]
 8022a68:	4618      	mov	r0, r3
 8022a6a:	f003 f9e5 	bl	8025e38 <lv_free>
        }

        lv_free(file_p->cache);
 8022a6e:	687b      	ldr	r3, [r7, #4]
 8022a70:	689b      	ldr	r3, [r3, #8]
 8022a72:	4618      	mov	r0, r3
 8022a74:	f003 f9e0 	bl	8025e38 <lv_free>
    }

    file_p->file_d = NULL;
 8022a78:	687b      	ldr	r3, [r7, #4]
 8022a7a:	2200      	movs	r2, #0
 8022a7c:	601a      	str	r2, [r3, #0]
    file_p->drv    = NULL;
 8022a7e:	687b      	ldr	r3, [r7, #4]
 8022a80:	2200      	movs	r2, #0
 8022a82:	605a      	str	r2, [r3, #4]
    file_p->cache  = NULL;
 8022a84:	687b      	ldr	r3, [r7, #4]
 8022a86:	2200      	movs	r2, #0
 8022a88:	609a      	str	r2, [r3, #8]

    return res;
 8022a8a:	7bfb      	ldrb	r3, [r7, #15]
}
 8022a8c:	4618      	mov	r0, r3
 8022a8e:	3710      	adds	r7, #16
 8022a90:	46bd      	mov	sp, r7
 8022a92:	bd80      	pop	{r7, pc}

08022a94 <lv_fs_read_cached>:

static lv_fs_res_t lv_fs_read_cached(lv_fs_file_t * file_p, char * buf, uint32_t btr, uint32_t * br)
{
 8022a94:	b5b0      	push	{r4, r5, r7, lr}
 8022a96:	b092      	sub	sp, #72	@ 0x48
 8022a98:	af02      	add	r7, sp, #8
 8022a9a:	60f8      	str	r0, [r7, #12]
 8022a9c:	60b9      	str	r1, [r7, #8]
 8022a9e:	607a      	str	r2, [r7, #4]
 8022aa0:	603b      	str	r3, [r7, #0]
    lv_fs_res_t res = LV_FS_RES_OK;
 8022aa2:	2300      	movs	r3, #0
 8022aa4:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
    uint32_t file_position = file_p->cache->file_position;
 8022aa8:	68fb      	ldr	r3, [r7, #12]
 8022aaa:	689b      	ldr	r3, [r3, #8]
 8022aac:	689b      	ldr	r3, [r3, #8]
 8022aae:	637b      	str	r3, [r7, #52]	@ 0x34
    uint32_t start = file_p->cache->start;
 8022ab0:	68fb      	ldr	r3, [r7, #12]
 8022ab2:	689b      	ldr	r3, [r3, #8]
 8022ab4:	681b      	ldr	r3, [r3, #0]
 8022ab6:	633b      	str	r3, [r7, #48]	@ 0x30
    uint32_t end = file_p->cache->end;
 8022ab8:	68fb      	ldr	r3, [r7, #12]
 8022aba:	689b      	ldr	r3, [r3, #8]
 8022abc:	685b      	ldr	r3, [r3, #4]
 8022abe:	62fb      	str	r3, [r7, #44]	@ 0x2c
    char * buffer = file_p->cache->buffer;
 8022ac0:	68fb      	ldr	r3, [r7, #12]
 8022ac2:	689b      	ldr	r3, [r3, #8]
 8022ac4:	68db      	ldr	r3, [r3, #12]
 8022ac6:	63bb      	str	r3, [r7, #56]	@ 0x38
    uint32_t buffer_size = file_p->drv->cache_size;
 8022ac8:	68fb      	ldr	r3, [r7, #12]
 8022aca:	685b      	ldr	r3, [r3, #4]
 8022acc:	685b      	ldr	r3, [r3, #4]
 8022ace:	62bb      	str	r3, [r7, #40]	@ 0x28

    if(start <= file_position && file_position <= end) {
 8022ad0:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8022ad2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022ad4:	429a      	cmp	r2, r3
 8022ad6:	f200 809c 	bhi.w	8022c12 <lv_fs_read_cached+0x17e>
 8022ada:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8022adc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8022ade:	429a      	cmp	r2, r3
 8022ae0:	f200 8097 	bhi.w	8022c12 <lv_fs_read_cached+0x17e>
        /* Data can be read from cache buffer */
        uint32_t buffer_remaining_length = (uint32_t)end - file_position + 1;
 8022ae4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8022ae6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8022ae8:	1ad3      	subs	r3, r2, r3
 8022aea:	3301      	adds	r3, #1
 8022aec:	627b      	str	r3, [r7, #36]	@ 0x24
        uint32_t buffer_offset = (end - start) - buffer_remaining_length + 1;
 8022aee:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8022af0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8022af2:	1ad2      	subs	r2, r2, r3
 8022af4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022af6:	1ad3      	subs	r3, r2, r3
 8022af8:	3301      	adds	r3, #1
 8022afa:	623b      	str	r3, [r7, #32]

        /* Do not allow reading beyond the actual memory block for memory-mapped files */
        if(file_p->drv->cache_size == LV_FS_CACHE_FROM_BUFFER) {
 8022afc:	68fb      	ldr	r3, [r7, #12]
 8022afe:	685b      	ldr	r3, [r3, #4]
 8022b00:	685b      	ldr	r3, [r3, #4]
 8022b02:	f1b3 3fff 	cmp.w	r3, #4294967295
 8022b06:	d106      	bne.n	8022b16 <lv_fs_read_cached+0x82>
            if(btr > buffer_remaining_length)
 8022b08:	687a      	ldr	r2, [r7, #4]
 8022b0a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022b0c:	429a      	cmp	r2, r3
 8022b0e:	d902      	bls.n	8022b16 <lv_fs_read_cached+0x82>
                btr = buffer_remaining_length - 1;
 8022b10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022b12:	3b01      	subs	r3, #1
 8022b14:	607b      	str	r3, [r7, #4]
        }

        if(btr <= buffer_remaining_length) {
 8022b16:	687a      	ldr	r2, [r7, #4]
 8022b18:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022b1a:	429a      	cmp	r2, r3
 8022b1c:	d80b      	bhi.n	8022b36 <lv_fs_read_cached+0xa2>
            /*Data is in cache buffer, and buffer end not reached, no need to read from FS*/
            lv_memcpy(buf, buffer + buffer_offset, btr);
 8022b1e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8022b20:	6a3b      	ldr	r3, [r7, #32]
 8022b22:	4413      	add	r3, r2
 8022b24:	687a      	ldr	r2, [r7, #4]
 8022b26:	4619      	mov	r1, r3
 8022b28:	68b8      	ldr	r0, [r7, #8]
 8022b2a:	f001 ff5d 	bl	80249e8 <lv_memcpy>
            *br = btr;
 8022b2e:	683b      	ldr	r3, [r7, #0]
 8022b30:	687a      	ldr	r2, [r7, #4]
 8022b32:	601a      	str	r2, [r3, #0]
    if(start <= file_position && file_position <= end) {
 8022b34:	e0cf      	b.n	8022cd6 <lv_fs_read_cached+0x242>
        }
        else {
            /*First part of data is in cache buffer, but we need to read rest of data from FS*/
            lv_memcpy(buf, buffer + buffer_offset, buffer_remaining_length);
 8022b36:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8022b38:	6a3b      	ldr	r3, [r7, #32]
 8022b3a:	4413      	add	r3, r2
 8022b3c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8022b3e:	4619      	mov	r1, r3
 8022b40:	68b8      	ldr	r0, [r7, #8]
 8022b42:	f001 ff51 	bl	80249e8 <lv_memcpy>

            file_p->drv->seek_cb(file_p->drv, file_p->file_d, file_p->cache->end + 1,
 8022b46:	68fb      	ldr	r3, [r7, #12]
 8022b48:	685b      	ldr	r3, [r3, #4]
 8022b4a:	69dc      	ldr	r4, [r3, #28]
 8022b4c:	68fb      	ldr	r3, [r7, #12]
 8022b4e:	6858      	ldr	r0, [r3, #4]
 8022b50:	68fb      	ldr	r3, [r7, #12]
 8022b52:	6819      	ldr	r1, [r3, #0]
 8022b54:	68fb      	ldr	r3, [r7, #12]
 8022b56:	689b      	ldr	r3, [r3, #8]
 8022b58:	685b      	ldr	r3, [r3, #4]
 8022b5a:	1c5a      	adds	r2, r3, #1
 8022b5c:	2300      	movs	r3, #0
 8022b5e:	47a0      	blx	r4
                                 LV_FS_SEEK_SET);

            uint32_t bytes_read_to_buffer = 0;
 8022b60:	2300      	movs	r3, #0
 8022b62:	61bb      	str	r3, [r7, #24]
            if(btr - buffer_remaining_length > buffer_size) {
 8022b64:	687a      	ldr	r2, [r7, #4]
 8022b66:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022b68:	1ad3      	subs	r3, r2, r3
 8022b6a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8022b6c:	429a      	cmp	r2, r3
 8022b6e:	d216      	bcs.n	8022b9e <lv_fs_read_cached+0x10a>
                /*If remaining data chuck is bigger than buffer size, then do not use cache, instead read it directly from FS*/
                res = file_p->drv->read_cb(file_p->drv, file_p->file_d, (void *)(buf + buffer_remaining_length),
 8022b70:	68fb      	ldr	r3, [r7, #12]
 8022b72:	685b      	ldr	r3, [r3, #4]
 8022b74:	695c      	ldr	r4, [r3, #20]
 8022b76:	68fb      	ldr	r3, [r7, #12]
 8022b78:	6858      	ldr	r0, [r3, #4]
 8022b7a:	68fb      	ldr	r3, [r7, #12]
 8022b7c:	6819      	ldr	r1, [r3, #0]
 8022b7e:	68ba      	ldr	r2, [r7, #8]
 8022b80:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022b82:	18d5      	adds	r5, r2, r3
 8022b84:	687a      	ldr	r2, [r7, #4]
 8022b86:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022b88:	1ad2      	subs	r2, r2, r3
 8022b8a:	f107 0318 	add.w	r3, r7, #24
 8022b8e:	9300      	str	r3, [sp, #0]
 8022b90:	4613      	mov	r3, r2
 8022b92:	462a      	mov	r2, r5
 8022b94:	47a0      	blx	r4
 8022b96:	4603      	mov	r3, r0
 8022b98:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
 8022b9c:	e02f      	b.n	8022bfe <lv_fs_read_cached+0x16a>
                                           btr - buffer_remaining_length, &bytes_read_to_buffer);
            }
            else {
                /*If remaining data chunk is smaller than buffer size, then read into cache buffer*/
                res = file_p->drv->read_cb(file_p->drv, file_p->file_d, (void *)buffer, buffer_size, &bytes_read_to_buffer);
 8022b9e:	68fb      	ldr	r3, [r7, #12]
 8022ba0:	685b      	ldr	r3, [r3, #4]
 8022ba2:	695c      	ldr	r4, [r3, #20]
 8022ba4:	68fb      	ldr	r3, [r7, #12]
 8022ba6:	6858      	ldr	r0, [r3, #4]
 8022ba8:	68fb      	ldr	r3, [r7, #12]
 8022baa:	6819      	ldr	r1, [r3, #0]
 8022bac:	f107 0318 	add.w	r3, r7, #24
 8022bb0:	9300      	str	r3, [sp, #0]
 8022bb2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022bb4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8022bb6:	47a0      	blx	r4
 8022bb8:	4603      	mov	r3, r0
 8022bba:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
                file_p->cache->start = file_p->cache->end + 1;
 8022bbe:	68fb      	ldr	r3, [r7, #12]
 8022bc0:	689b      	ldr	r3, [r3, #8]
 8022bc2:	685a      	ldr	r2, [r3, #4]
 8022bc4:	68fb      	ldr	r3, [r7, #12]
 8022bc6:	689b      	ldr	r3, [r3, #8]
 8022bc8:	3201      	adds	r2, #1
 8022bca:	601a      	str	r2, [r3, #0]
                file_p->cache->end = file_p->cache->start + bytes_read_to_buffer - 1;
 8022bcc:	68fb      	ldr	r3, [r7, #12]
 8022bce:	689b      	ldr	r3, [r3, #8]
 8022bd0:	681a      	ldr	r2, [r3, #0]
 8022bd2:	69bb      	ldr	r3, [r7, #24]
 8022bd4:	441a      	add	r2, r3
 8022bd6:	68fb      	ldr	r3, [r7, #12]
 8022bd8:	689b      	ldr	r3, [r3, #8]
 8022bda:	3a01      	subs	r2, #1
 8022bdc:	605a      	str	r2, [r3, #4]

                uint16_t data_chunk_remaining = LV_MIN(btr - buffer_remaining_length, bytes_read_to_buffer);
 8022bde:	687a      	ldr	r2, [r7, #4]
 8022be0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022be2:	1ad2      	subs	r2, r2, r3
 8022be4:	69bb      	ldr	r3, [r7, #24]
 8022be6:	4293      	cmp	r3, r2
 8022be8:	bf28      	it	cs
 8022bea:	4613      	movcs	r3, r2
 8022bec:	83fb      	strh	r3, [r7, #30]
                lv_memcpy(buf + buffer_remaining_length, buffer, data_chunk_remaining);
 8022bee:	68ba      	ldr	r2, [r7, #8]
 8022bf0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022bf2:	4413      	add	r3, r2
 8022bf4:	8bfa      	ldrh	r2, [r7, #30]
 8022bf6:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8022bf8:	4618      	mov	r0, r3
 8022bfa:	f001 fef5 	bl	80249e8 <lv_memcpy>
            }
            *br = LV_MIN(buffer_remaining_length + bytes_read_to_buffer, btr);
 8022bfe:	69ba      	ldr	r2, [r7, #24]
 8022c00:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8022c02:	441a      	add	r2, r3
 8022c04:	687b      	ldr	r3, [r7, #4]
 8022c06:	429a      	cmp	r2, r3
 8022c08:	bf28      	it	cs
 8022c0a:	461a      	movcs	r2, r3
 8022c0c:	683b      	ldr	r3, [r7, #0]
 8022c0e:	601a      	str	r2, [r3, #0]
    if(start <= file_position && file_position <= end) {
 8022c10:	e061      	b.n	8022cd6 <lv_fs_read_cached+0x242>
        }
    }
    else {
        file_p->drv->seek_cb(file_p->drv, file_p->file_d, file_p->cache->file_position,
 8022c12:	68fb      	ldr	r3, [r7, #12]
 8022c14:	685b      	ldr	r3, [r3, #4]
 8022c16:	69dc      	ldr	r4, [r3, #28]
 8022c18:	68fb      	ldr	r3, [r7, #12]
 8022c1a:	6858      	ldr	r0, [r3, #4]
 8022c1c:	68fb      	ldr	r3, [r7, #12]
 8022c1e:	6819      	ldr	r1, [r3, #0]
 8022c20:	68fb      	ldr	r3, [r7, #12]
 8022c22:	689b      	ldr	r3, [r3, #8]
 8022c24:	689a      	ldr	r2, [r3, #8]
 8022c26:	2300      	movs	r3, #0
 8022c28:	47a0      	blx	r4
                             LV_FS_SEEK_SET);

        /*Data is not in cache buffer*/
        if(btr > buffer_size) {
 8022c2a:	687a      	ldr	r2, [r7, #4]
 8022c2c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022c2e:	429a      	cmp	r2, r3
 8022c30:	d90f      	bls.n	8022c52 <lv_fs_read_cached+0x1be>
            /*If bigger data is requested, then do not use cache, instead read it directly*/
            res = file_p->drv->read_cb(file_p->drv, file_p->file_d, (void *)buf, btr, br);
 8022c32:	68fb      	ldr	r3, [r7, #12]
 8022c34:	685b      	ldr	r3, [r3, #4]
 8022c36:	695c      	ldr	r4, [r3, #20]
 8022c38:	68fb      	ldr	r3, [r7, #12]
 8022c3a:	6858      	ldr	r0, [r3, #4]
 8022c3c:	68fb      	ldr	r3, [r7, #12]
 8022c3e:	6819      	ldr	r1, [r3, #0]
 8022c40:	683b      	ldr	r3, [r7, #0]
 8022c42:	9300      	str	r3, [sp, #0]
 8022c44:	687b      	ldr	r3, [r7, #4]
 8022c46:	68ba      	ldr	r2, [r7, #8]
 8022c48:	47a0      	blx	r4
 8022c4a:	4603      	mov	r3, r0
 8022c4c:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
 8022c50:	e041      	b.n	8022cd6 <lv_fs_read_cached+0x242>
        }
        else {
            /*If small data is requested, then read from FS into cache buffer*/
            if(buffer == NULL) {
 8022c52:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8022c54:	2b00      	cmp	r3, #0
 8022c56:	d111      	bne.n	8022c7c <lv_fs_read_cached+0x1e8>
                file_p->cache->buffer = lv_malloc(buffer_size);
 8022c58:	68fb      	ldr	r3, [r7, #12]
 8022c5a:	689c      	ldr	r4, [r3, #8]
 8022c5c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8022c5e:	f003 f8b3 	bl	8025dc8 <lv_malloc>
 8022c62:	4603      	mov	r3, r0
 8022c64:	60e3      	str	r3, [r4, #12]
                LV_ASSERT_MALLOC(file_p->cache->buffer);
 8022c66:	68fb      	ldr	r3, [r7, #12]
 8022c68:	689b      	ldr	r3, [r3, #8]
 8022c6a:	68db      	ldr	r3, [r3, #12]
 8022c6c:	2b00      	cmp	r3, #0
 8022c6e:	d101      	bne.n	8022c74 <lv_fs_read_cached+0x1e0>
 8022c70:	bf00      	nop
 8022c72:	e7fd      	b.n	8022c70 <lv_fs_read_cached+0x1dc>
                buffer = file_p->cache->buffer;
 8022c74:	68fb      	ldr	r3, [r7, #12]
 8022c76:	689b      	ldr	r3, [r3, #8]
 8022c78:	68db      	ldr	r3, [r3, #12]
 8022c7a:	63bb      	str	r3, [r7, #56]	@ 0x38
            }

            uint32_t bytes_read_to_buffer = 0;
 8022c7c:	2300      	movs	r3, #0
 8022c7e:	617b      	str	r3, [r7, #20]
            res = file_p->drv->read_cb(file_p->drv, file_p->file_d, (void *)buffer, buffer_size, &bytes_read_to_buffer);
 8022c80:	68fb      	ldr	r3, [r7, #12]
 8022c82:	685b      	ldr	r3, [r3, #4]
 8022c84:	695c      	ldr	r4, [r3, #20]
 8022c86:	68fb      	ldr	r3, [r7, #12]
 8022c88:	6858      	ldr	r0, [r3, #4]
 8022c8a:	68fb      	ldr	r3, [r7, #12]
 8022c8c:	6819      	ldr	r1, [r3, #0]
 8022c8e:	f107 0314 	add.w	r3, r7, #20
 8022c92:	9300      	str	r3, [sp, #0]
 8022c94:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8022c96:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8022c98:	47a0      	blx	r4
 8022c9a:	4603      	mov	r3, r0
 8022c9c:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
            file_p->cache->start = file_position;
 8022ca0:	68fb      	ldr	r3, [r7, #12]
 8022ca2:	689b      	ldr	r3, [r3, #8]
 8022ca4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8022ca6:	601a      	str	r2, [r3, #0]
            file_p->cache->end = file_p->cache->start + bytes_read_to_buffer - 1;
 8022ca8:	68fb      	ldr	r3, [r7, #12]
 8022caa:	689b      	ldr	r3, [r3, #8]
 8022cac:	681a      	ldr	r2, [r3, #0]
 8022cae:	697b      	ldr	r3, [r7, #20]
 8022cb0:	441a      	add	r2, r3
 8022cb2:	68fb      	ldr	r3, [r7, #12]
 8022cb4:	689b      	ldr	r3, [r3, #8]
 8022cb6:	3a01      	subs	r2, #1
 8022cb8:	605a      	str	r2, [r3, #4]

            *br = LV_MIN(btr, bytes_read_to_buffer);
 8022cba:	697a      	ldr	r2, [r7, #20]
 8022cbc:	687b      	ldr	r3, [r7, #4]
 8022cbe:	429a      	cmp	r2, r3
 8022cc0:	bf28      	it	cs
 8022cc2:	461a      	movcs	r2, r3
 8022cc4:	683b      	ldr	r3, [r7, #0]
 8022cc6:	601a      	str	r2, [r3, #0]
            lv_memcpy(buf, buffer, *br);
 8022cc8:	683b      	ldr	r3, [r7, #0]
 8022cca:	681b      	ldr	r3, [r3, #0]
 8022ccc:	461a      	mov	r2, r3
 8022cce:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8022cd0:	68b8      	ldr	r0, [r7, #8]
 8022cd2:	f001 fe89 	bl	80249e8 <lv_memcpy>

        }
    }

    if(res == LV_FS_RES_OK) {
 8022cd6:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 8022cda:	2b00      	cmp	r3, #0
 8022cdc:	d108      	bne.n	8022cf0 <lv_fs_read_cached+0x25c>
        file_p->cache->file_position += *br;
 8022cde:	68fb      	ldr	r3, [r7, #12]
 8022ce0:	689b      	ldr	r3, [r3, #8]
 8022ce2:	6899      	ldr	r1, [r3, #8]
 8022ce4:	683b      	ldr	r3, [r7, #0]
 8022ce6:	681a      	ldr	r2, [r3, #0]
 8022ce8:	68fb      	ldr	r3, [r7, #12]
 8022cea:	689b      	ldr	r3, [r3, #8]
 8022cec:	440a      	add	r2, r1
 8022cee:	609a      	str	r2, [r3, #8]
    }

    return res;
 8022cf0:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
}
 8022cf4:	4618      	mov	r0, r3
 8022cf6:	3740      	adds	r7, #64	@ 0x40
 8022cf8:	46bd      	mov	sp, r7
 8022cfa:	bdb0      	pop	{r4, r5, r7, pc}

08022cfc <lv_fs_read>:

lv_fs_res_t lv_fs_read(lv_fs_file_t * file_p, void * buf, uint32_t btr, uint32_t * br)
{
 8022cfc:	b590      	push	{r4, r7, lr}
 8022cfe:	b089      	sub	sp, #36	@ 0x24
 8022d00:	af02      	add	r7, sp, #8
 8022d02:	60f8      	str	r0, [r7, #12]
 8022d04:	60b9      	str	r1, [r7, #8]
 8022d06:	607a      	str	r2, [r7, #4]
 8022d08:	603b      	str	r3, [r7, #0]
    if(br != NULL) *br = 0;
 8022d0a:	683b      	ldr	r3, [r7, #0]
 8022d0c:	2b00      	cmp	r3, #0
 8022d0e:	d002      	beq.n	8022d16 <lv_fs_read+0x1a>
 8022d10:	683b      	ldr	r3, [r7, #0]
 8022d12:	2200      	movs	r2, #0
 8022d14:	601a      	str	r2, [r3, #0]
    if(file_p->drv == NULL) return LV_FS_RES_INV_PARAM;
 8022d16:	68fb      	ldr	r3, [r7, #12]
 8022d18:	685b      	ldr	r3, [r3, #4]
 8022d1a:	2b00      	cmp	r3, #0
 8022d1c:	d101      	bne.n	8022d22 <lv_fs_read+0x26>
 8022d1e:	230b      	movs	r3, #11
 8022d20:	e02d      	b.n	8022d7e <lv_fs_read+0x82>
    if(file_p->drv->read_cb == NULL) return LV_FS_RES_NOT_IMP;
 8022d22:	68fb      	ldr	r3, [r7, #12]
 8022d24:	685b      	ldr	r3, [r3, #4]
 8022d26:	695b      	ldr	r3, [r3, #20]
 8022d28:	2b00      	cmp	r3, #0
 8022d2a:	d101      	bne.n	8022d30 <lv_fs_read+0x34>
 8022d2c:	2309      	movs	r3, #9
 8022d2e:	e026      	b.n	8022d7e <lv_fs_read+0x82>

    uint32_t br_tmp = 0;
 8022d30:	2300      	movs	r3, #0
 8022d32:	613b      	str	r3, [r7, #16]
    lv_fs_res_t res;

    if(file_p->drv->cache_size) {
 8022d34:	68fb      	ldr	r3, [r7, #12]
 8022d36:	685b      	ldr	r3, [r3, #4]
 8022d38:	685b      	ldr	r3, [r3, #4]
 8022d3a:	2b00      	cmp	r3, #0
 8022d3c:	d009      	beq.n	8022d52 <lv_fs_read+0x56>
        res = lv_fs_read_cached(file_p, (char *)buf, btr, &br_tmp);
 8022d3e:	f107 0310 	add.w	r3, r7, #16
 8022d42:	687a      	ldr	r2, [r7, #4]
 8022d44:	68b9      	ldr	r1, [r7, #8]
 8022d46:	68f8      	ldr	r0, [r7, #12]
 8022d48:	f7ff fea4 	bl	8022a94 <lv_fs_read_cached>
 8022d4c:	4603      	mov	r3, r0
 8022d4e:	75fb      	strb	r3, [r7, #23]
 8022d50:	e00e      	b.n	8022d70 <lv_fs_read+0x74>
    }
    else {
        res = file_p->drv->read_cb(file_p->drv, file_p->file_d, buf, btr, &br_tmp);
 8022d52:	68fb      	ldr	r3, [r7, #12]
 8022d54:	685b      	ldr	r3, [r3, #4]
 8022d56:	695c      	ldr	r4, [r3, #20]
 8022d58:	68fb      	ldr	r3, [r7, #12]
 8022d5a:	6858      	ldr	r0, [r3, #4]
 8022d5c:	68fb      	ldr	r3, [r7, #12]
 8022d5e:	6819      	ldr	r1, [r3, #0]
 8022d60:	f107 0310 	add.w	r3, r7, #16
 8022d64:	9300      	str	r3, [sp, #0]
 8022d66:	687b      	ldr	r3, [r7, #4]
 8022d68:	68ba      	ldr	r2, [r7, #8]
 8022d6a:	47a0      	blx	r4
 8022d6c:	4603      	mov	r3, r0
 8022d6e:	75fb      	strb	r3, [r7, #23]
    }

    if(br != NULL) *br = br_tmp;
 8022d70:	683b      	ldr	r3, [r7, #0]
 8022d72:	2b00      	cmp	r3, #0
 8022d74:	d002      	beq.n	8022d7c <lv_fs_read+0x80>
 8022d76:	693a      	ldr	r2, [r7, #16]
 8022d78:	683b      	ldr	r3, [r7, #0]
 8022d7a:	601a      	str	r2, [r3, #0]

    return res;
 8022d7c:	7dfb      	ldrb	r3, [r7, #23]
}
 8022d7e:	4618      	mov	r0, r3
 8022d80:	371c      	adds	r7, #28
 8022d82:	46bd      	mov	sp, r7
 8022d84:	bd90      	pop	{r4, r7, pc}

08022d86 <lv_fs_seek>:

    return res;
}

lv_fs_res_t lv_fs_seek(lv_fs_file_t * file_p, uint32_t pos, lv_fs_whence_t whence)
{
 8022d86:	b590      	push	{r4, r7, lr}
 8022d88:	b087      	sub	sp, #28
 8022d8a:	af00      	add	r7, sp, #0
 8022d8c:	60f8      	str	r0, [r7, #12]
 8022d8e:	60b9      	str	r1, [r7, #8]
 8022d90:	4613      	mov	r3, r2
 8022d92:	71fb      	strb	r3, [r7, #7]
    if(file_p->drv == NULL) {
 8022d94:	68fb      	ldr	r3, [r7, #12]
 8022d96:	685b      	ldr	r3, [r3, #4]
 8022d98:	2b00      	cmp	r3, #0
 8022d9a:	d101      	bne.n	8022da0 <lv_fs_seek+0x1a>
        return LV_FS_RES_INV_PARAM;
 8022d9c:	230b      	movs	r3, #11
 8022d9e:	e098      	b.n	8022ed2 <lv_fs_seek+0x14c>
    }

    if(file_p->drv->seek_cb == NULL) {
 8022da0:	68fb      	ldr	r3, [r7, #12]
 8022da2:	685b      	ldr	r3, [r3, #4]
 8022da4:	69db      	ldr	r3, [r3, #28]
 8022da6:	2b00      	cmp	r3, #0
 8022da8:	d101      	bne.n	8022dae <lv_fs_seek+0x28>
        return LV_FS_RES_NOT_IMP;
 8022daa:	2309      	movs	r3, #9
 8022dac:	e091      	b.n	8022ed2 <lv_fs_seek+0x14c>
    }

    lv_fs_res_t res = LV_FS_RES_OK;
 8022dae:	2300      	movs	r3, #0
 8022db0:	75fb      	strb	r3, [r7, #23]
    if(file_p->drv->cache_size) {
 8022db2:	68fb      	ldr	r3, [r7, #12]
 8022db4:	685b      	ldr	r3, [r3, #4]
 8022db6:	685b      	ldr	r3, [r3, #4]
 8022db8:	2b00      	cmp	r3, #0
 8022dba:	d077      	beq.n	8022eac <lv_fs_seek+0x126>
        switch(whence) {
 8022dbc:	79fb      	ldrb	r3, [r7, #7]
 8022dbe:	2b02      	cmp	r3, #2
 8022dc0:	d051      	beq.n	8022e66 <lv_fs_seek+0xe0>
 8022dc2:	2b02      	cmp	r3, #2
 8022dc4:	f300 8084 	bgt.w	8022ed0 <lv_fs_seek+0x14a>
 8022dc8:	2b00      	cmp	r3, #0
 8022dca:	d002      	beq.n	8022dd2 <lv_fs_seek+0x4c>
 8022dcc:	2b01      	cmp	r3, #1
 8022dce:	d023      	beq.n	8022e18 <lv_fs_seek+0x92>
 8022dd0:	e07e      	b.n	8022ed0 <lv_fs_seek+0x14a>
            case LV_FS_SEEK_SET: {
                    file_p->cache->file_position = pos;
 8022dd2:	68fb      	ldr	r3, [r7, #12]
 8022dd4:	689b      	ldr	r3, [r3, #8]
 8022dd6:	68ba      	ldr	r2, [r7, #8]
 8022dd8:	609a      	str	r2, [r3, #8]

                    /*FS seek if new position is outside cache buffer*/
                    if(file_p->cache->file_position < file_p->cache->start || file_p->cache->file_position > file_p->cache->end) {
 8022dda:	68fb      	ldr	r3, [r7, #12]
 8022ddc:	689b      	ldr	r3, [r3, #8]
 8022dde:	689a      	ldr	r2, [r3, #8]
 8022de0:	68fb      	ldr	r3, [r7, #12]
 8022de2:	689b      	ldr	r3, [r3, #8]
 8022de4:	681b      	ldr	r3, [r3, #0]
 8022de6:	429a      	cmp	r2, r3
 8022de8:	d307      	bcc.n	8022dfa <lv_fs_seek+0x74>
 8022dea:	68fb      	ldr	r3, [r7, #12]
 8022dec:	689b      	ldr	r3, [r3, #8]
 8022dee:	689a      	ldr	r2, [r3, #8]
 8022df0:	68fb      	ldr	r3, [r7, #12]
 8022df2:	689b      	ldr	r3, [r3, #8]
 8022df4:	685b      	ldr	r3, [r3, #4]
 8022df6:	429a      	cmp	r2, r3
 8022df8:	d965      	bls.n	8022ec6 <lv_fs_seek+0x140>
                        res = file_p->drv->seek_cb(file_p->drv, file_p->file_d, file_p->cache->file_position, LV_FS_SEEK_SET);
 8022dfa:	68fb      	ldr	r3, [r7, #12]
 8022dfc:	685b      	ldr	r3, [r3, #4]
 8022dfe:	69dc      	ldr	r4, [r3, #28]
 8022e00:	68fb      	ldr	r3, [r7, #12]
 8022e02:	6858      	ldr	r0, [r3, #4]
 8022e04:	68fb      	ldr	r3, [r7, #12]
 8022e06:	6819      	ldr	r1, [r3, #0]
 8022e08:	68fb      	ldr	r3, [r7, #12]
 8022e0a:	689b      	ldr	r3, [r3, #8]
 8022e0c:	689a      	ldr	r2, [r3, #8]
 8022e0e:	2300      	movs	r3, #0
 8022e10:	47a0      	blx	r4
 8022e12:	4603      	mov	r3, r0
 8022e14:	75fb      	strb	r3, [r7, #23]
                    }

                    break;
 8022e16:	e056      	b.n	8022ec6 <lv_fs_seek+0x140>
                }
            case LV_FS_SEEK_CUR: {
                    file_p->cache->file_position += pos;
 8022e18:	68fb      	ldr	r3, [r7, #12]
 8022e1a:	689b      	ldr	r3, [r3, #8]
 8022e1c:	6899      	ldr	r1, [r3, #8]
 8022e1e:	68fb      	ldr	r3, [r7, #12]
 8022e20:	689b      	ldr	r3, [r3, #8]
 8022e22:	68ba      	ldr	r2, [r7, #8]
 8022e24:	440a      	add	r2, r1
 8022e26:	609a      	str	r2, [r3, #8]

                    /*FS seek if new position is outside cache buffer*/
                    if(file_p->cache->file_position < file_p->cache->start || file_p->cache->file_position > file_p->cache->end) {
 8022e28:	68fb      	ldr	r3, [r7, #12]
 8022e2a:	689b      	ldr	r3, [r3, #8]
 8022e2c:	689a      	ldr	r2, [r3, #8]
 8022e2e:	68fb      	ldr	r3, [r7, #12]
 8022e30:	689b      	ldr	r3, [r3, #8]
 8022e32:	681b      	ldr	r3, [r3, #0]
 8022e34:	429a      	cmp	r2, r3
 8022e36:	d307      	bcc.n	8022e48 <lv_fs_seek+0xc2>
 8022e38:	68fb      	ldr	r3, [r7, #12]
 8022e3a:	689b      	ldr	r3, [r3, #8]
 8022e3c:	689a      	ldr	r2, [r3, #8]
 8022e3e:	68fb      	ldr	r3, [r7, #12]
 8022e40:	689b      	ldr	r3, [r3, #8]
 8022e42:	685b      	ldr	r3, [r3, #4]
 8022e44:	429a      	cmp	r2, r3
 8022e46:	d940      	bls.n	8022eca <lv_fs_seek+0x144>
                        res = file_p->drv->seek_cb(file_p->drv, file_p->file_d, file_p->cache->file_position, LV_FS_SEEK_SET);
 8022e48:	68fb      	ldr	r3, [r7, #12]
 8022e4a:	685b      	ldr	r3, [r3, #4]
 8022e4c:	69dc      	ldr	r4, [r3, #28]
 8022e4e:	68fb      	ldr	r3, [r7, #12]
 8022e50:	6858      	ldr	r0, [r3, #4]
 8022e52:	68fb      	ldr	r3, [r7, #12]
 8022e54:	6819      	ldr	r1, [r3, #0]
 8022e56:	68fb      	ldr	r3, [r7, #12]
 8022e58:	689b      	ldr	r3, [r3, #8]
 8022e5a:	689a      	ldr	r2, [r3, #8]
 8022e5c:	2300      	movs	r3, #0
 8022e5e:	47a0      	blx	r4
 8022e60:	4603      	mov	r3, r0
 8022e62:	75fb      	strb	r3, [r7, #23]
                    }

                    break;
 8022e64:	e031      	b.n	8022eca <lv_fs_seek+0x144>
                }
            case LV_FS_SEEK_END: {
                    /*Because we don't know the file size, we do a little trick: do a FS seek, then get the new file position from FS*/
                    res = file_p->drv->seek_cb(file_p->drv, file_p->file_d, pos, whence);
 8022e66:	68fb      	ldr	r3, [r7, #12]
 8022e68:	685b      	ldr	r3, [r3, #4]
 8022e6a:	69dc      	ldr	r4, [r3, #28]
 8022e6c:	68fb      	ldr	r3, [r7, #12]
 8022e6e:	6858      	ldr	r0, [r3, #4]
 8022e70:	68fb      	ldr	r3, [r7, #12]
 8022e72:	6819      	ldr	r1, [r3, #0]
 8022e74:	79fb      	ldrb	r3, [r7, #7]
 8022e76:	68ba      	ldr	r2, [r7, #8]
 8022e78:	47a0      	blx	r4
 8022e7a:	4603      	mov	r3, r0
 8022e7c:	75fb      	strb	r3, [r7, #23]
                    if(res == LV_FS_RES_OK) {
 8022e7e:	7dfb      	ldrb	r3, [r7, #23]
 8022e80:	2b00      	cmp	r3, #0
 8022e82:	d124      	bne.n	8022ece <lv_fs_seek+0x148>
                        uint32_t tmp_position;
                        res = file_p->drv->tell_cb(file_p->drv, file_p->file_d, &tmp_position);
 8022e84:	68fb      	ldr	r3, [r7, #12]
 8022e86:	685b      	ldr	r3, [r3, #4]
 8022e88:	6a1b      	ldr	r3, [r3, #32]
 8022e8a:	68fa      	ldr	r2, [r7, #12]
 8022e8c:	6850      	ldr	r0, [r2, #4]
 8022e8e:	68fa      	ldr	r2, [r7, #12]
 8022e90:	6811      	ldr	r1, [r2, #0]
 8022e92:	f107 0210 	add.w	r2, r7, #16
 8022e96:	4798      	blx	r3
 8022e98:	4603      	mov	r3, r0
 8022e9a:	75fb      	strb	r3, [r7, #23]

                        if(res == LV_FS_RES_OK) {
 8022e9c:	7dfb      	ldrb	r3, [r7, #23]
 8022e9e:	2b00      	cmp	r3, #0
 8022ea0:	d115      	bne.n	8022ece <lv_fs_seek+0x148>
                            file_p->cache->file_position = tmp_position;
 8022ea2:	68fb      	ldr	r3, [r7, #12]
 8022ea4:	689b      	ldr	r3, [r3, #8]
 8022ea6:	693a      	ldr	r2, [r7, #16]
 8022ea8:	609a      	str	r2, [r3, #8]
                        }
                    }
                    break;
 8022eaa:	e010      	b.n	8022ece <lv_fs_seek+0x148>
                }
        }
    }
    else {
        res = file_p->drv->seek_cb(file_p->drv, file_p->file_d, pos, whence);
 8022eac:	68fb      	ldr	r3, [r7, #12]
 8022eae:	685b      	ldr	r3, [r3, #4]
 8022eb0:	69dc      	ldr	r4, [r3, #28]
 8022eb2:	68fb      	ldr	r3, [r7, #12]
 8022eb4:	6858      	ldr	r0, [r3, #4]
 8022eb6:	68fb      	ldr	r3, [r7, #12]
 8022eb8:	6819      	ldr	r1, [r3, #0]
 8022eba:	79fb      	ldrb	r3, [r7, #7]
 8022ebc:	68ba      	ldr	r2, [r7, #8]
 8022ebe:	47a0      	blx	r4
 8022ec0:	4603      	mov	r3, r0
 8022ec2:	75fb      	strb	r3, [r7, #23]
 8022ec4:	e004      	b.n	8022ed0 <lv_fs_seek+0x14a>
                    break;
 8022ec6:	bf00      	nop
 8022ec8:	e002      	b.n	8022ed0 <lv_fs_seek+0x14a>
                    break;
 8022eca:	bf00      	nop
 8022ecc:	e000      	b.n	8022ed0 <lv_fs_seek+0x14a>
                    break;
 8022ece:	bf00      	nop
    }

    return res;
 8022ed0:	7dfb      	ldrb	r3, [r7, #23]
}
 8022ed2:	4618      	mov	r0, r3
 8022ed4:	371c      	adds	r7, #28
 8022ed6:	46bd      	mov	sp, r7
 8022ed8:	bd90      	pop	{r4, r7, pc}

08022eda <lv_fs_tell>:

lv_fs_res_t lv_fs_tell(lv_fs_file_t * file_p, uint32_t * pos)
{
 8022eda:	b580      	push	{r7, lr}
 8022edc:	b084      	sub	sp, #16
 8022ede:	af00      	add	r7, sp, #0
 8022ee0:	6078      	str	r0, [r7, #4]
 8022ee2:	6039      	str	r1, [r7, #0]
    if(file_p->drv == NULL) {
 8022ee4:	687b      	ldr	r3, [r7, #4]
 8022ee6:	685b      	ldr	r3, [r3, #4]
 8022ee8:	2b00      	cmp	r3, #0
 8022eea:	d104      	bne.n	8022ef6 <lv_fs_tell+0x1c>
        *pos = 0;
 8022eec:	683b      	ldr	r3, [r7, #0]
 8022eee:	2200      	movs	r2, #0
 8022ef0:	601a      	str	r2, [r3, #0]
        return LV_FS_RES_INV_PARAM;
 8022ef2:	230b      	movs	r3, #11
 8022ef4:	e022      	b.n	8022f3c <lv_fs_tell+0x62>
    }

    if(file_p->drv->tell_cb == NULL) {
 8022ef6:	687b      	ldr	r3, [r7, #4]
 8022ef8:	685b      	ldr	r3, [r3, #4]
 8022efa:	6a1b      	ldr	r3, [r3, #32]
 8022efc:	2b00      	cmp	r3, #0
 8022efe:	d104      	bne.n	8022f0a <lv_fs_tell+0x30>
        *pos = 0;
 8022f00:	683b      	ldr	r3, [r7, #0]
 8022f02:	2200      	movs	r2, #0
 8022f04:	601a      	str	r2, [r3, #0]
        return LV_FS_RES_NOT_IMP;
 8022f06:	2309      	movs	r3, #9
 8022f08:	e018      	b.n	8022f3c <lv_fs_tell+0x62>
    }

    lv_fs_res_t res;
    if(file_p->drv->cache_size) {
 8022f0a:	687b      	ldr	r3, [r7, #4]
 8022f0c:	685b      	ldr	r3, [r3, #4]
 8022f0e:	685b      	ldr	r3, [r3, #4]
 8022f10:	2b00      	cmp	r3, #0
 8022f12:	d007      	beq.n	8022f24 <lv_fs_tell+0x4a>
        *pos = file_p->cache->file_position;
 8022f14:	687b      	ldr	r3, [r7, #4]
 8022f16:	689b      	ldr	r3, [r3, #8]
 8022f18:	689a      	ldr	r2, [r3, #8]
 8022f1a:	683b      	ldr	r3, [r7, #0]
 8022f1c:	601a      	str	r2, [r3, #0]
        res = LV_FS_RES_OK;
 8022f1e:	2300      	movs	r3, #0
 8022f20:	73fb      	strb	r3, [r7, #15]
 8022f22:	e00a      	b.n	8022f3a <lv_fs_tell+0x60>
    }
    else {
        res = file_p->drv->tell_cb(file_p->drv, file_p->file_d, pos);
 8022f24:	687b      	ldr	r3, [r7, #4]
 8022f26:	685b      	ldr	r3, [r3, #4]
 8022f28:	6a1b      	ldr	r3, [r3, #32]
 8022f2a:	687a      	ldr	r2, [r7, #4]
 8022f2c:	6850      	ldr	r0, [r2, #4]
 8022f2e:	687a      	ldr	r2, [r7, #4]
 8022f30:	6811      	ldr	r1, [r2, #0]
 8022f32:	683a      	ldr	r2, [r7, #0]
 8022f34:	4798      	blx	r3
 8022f36:	4603      	mov	r3, r0
 8022f38:	73fb      	strb	r3, [r7, #15]
    }

    return res;
 8022f3a:	7bfb      	ldrb	r3, [r7, #15]
}
 8022f3c:	4618      	mov	r0, r3
 8022f3e:	3710      	adds	r7, #16
 8022f40:	46bd      	mov	sp, r7
 8022f42:	bd80      	pop	{r7, pc}

08022f44 <lv_fs_get_drv>:

    *new_drv = drv_p;
}

lv_fs_drv_t * lv_fs_get_drv(char letter)
{
 8022f44:	b580      	push	{r7, lr}
 8022f46:	b084      	sub	sp, #16
 8022f48:	af00      	add	r7, sp, #0
 8022f4a:	4603      	mov	r3, r0
 8022f4c:	71fb      	strb	r3, [r7, #7]
    lv_fs_drv_t ** drv;

    _LV_LL_READ(fsdrv_ll_p, drv) {
 8022f4e:	480d      	ldr	r0, [pc, #52]	@ (8022f84 <lv_fs_get_drv+0x40>)
 8022f50:	f000 f93d 	bl	80231ce <_lv_ll_get_head>
 8022f54:	60f8      	str	r0, [r7, #12]
 8022f56:	e00d      	b.n	8022f74 <lv_fs_get_drv+0x30>
        if((*drv)->letter == letter) {
 8022f58:	68fb      	ldr	r3, [r7, #12]
 8022f5a:	681b      	ldr	r3, [r3, #0]
 8022f5c:	781b      	ldrb	r3, [r3, #0]
 8022f5e:	79fa      	ldrb	r2, [r7, #7]
 8022f60:	429a      	cmp	r2, r3
 8022f62:	d102      	bne.n	8022f6a <lv_fs_get_drv+0x26>
            return *drv;
 8022f64:	68fb      	ldr	r3, [r7, #12]
 8022f66:	681b      	ldr	r3, [r3, #0]
 8022f68:	e008      	b.n	8022f7c <lv_fs_get_drv+0x38>
    _LV_LL_READ(fsdrv_ll_p, drv) {
 8022f6a:	68f9      	ldr	r1, [r7, #12]
 8022f6c:	4805      	ldr	r0, [pc, #20]	@ (8022f84 <lv_fs_get_drv+0x40>)
 8022f6e:	f000 f950 	bl	8023212 <_lv_ll_get_next>
 8022f72:	60f8      	str	r0, [r7, #12]
 8022f74:	68fb      	ldr	r3, [r7, #12]
 8022f76:	2b00      	cmp	r3, #0
 8022f78:	d1ee      	bne.n	8022f58 <lv_fs_get_drv+0x14>
        }
    }

    return NULL;
 8022f7a:	2300      	movs	r3, #0
}
 8022f7c:	4618      	mov	r0, r3
 8022f7e:	3710      	adds	r7, #16
 8022f80:	46bd      	mov	sp, r7
 8022f82:	bd80      	pop	{r7, pc}
 8022f84:	20000238 	.word	0x20000238

08022f88 <lv_fs_get_ext>:

    return buf;
}

const char * lv_fs_get_ext(const char * fn)
{
 8022f88:	b580      	push	{r7, lr}
 8022f8a:	b084      	sub	sp, #16
 8022f8c:	af00      	add	r7, sp, #0
 8022f8e:	6078      	str	r0, [r7, #4]
    size_t i;
    for(i = lv_strlen(fn); i > 0; i--) {
 8022f90:	6878      	ldr	r0, [r7, #4]
 8022f92:	f002 f812 	bl	8024fba <lv_strlen>
 8022f96:	60f8      	str	r0, [r7, #12]
 8022f98:	e01b      	b.n	8022fd2 <lv_fs_get_ext+0x4a>
        if(fn[i] == '.') {
 8022f9a:	687a      	ldr	r2, [r7, #4]
 8022f9c:	68fb      	ldr	r3, [r7, #12]
 8022f9e:	4413      	add	r3, r2
 8022fa0:	781b      	ldrb	r3, [r3, #0]
 8022fa2:	2b2e      	cmp	r3, #46	@ 0x2e
 8022fa4:	d104      	bne.n	8022fb0 <lv_fs_get_ext+0x28>
            return &fn[i + 1];
 8022fa6:	68fb      	ldr	r3, [r7, #12]
 8022fa8:	3301      	adds	r3, #1
 8022faa:	687a      	ldr	r2, [r7, #4]
 8022fac:	4413      	add	r3, r2
 8022fae:	e014      	b.n	8022fda <lv_fs_get_ext+0x52>
        }
        else if(fn[i] == '/' || fn[i] == '\\') {
 8022fb0:	687a      	ldr	r2, [r7, #4]
 8022fb2:	68fb      	ldr	r3, [r7, #12]
 8022fb4:	4413      	add	r3, r2
 8022fb6:	781b      	ldrb	r3, [r3, #0]
 8022fb8:	2b2f      	cmp	r3, #47	@ 0x2f
 8022fba:	d005      	beq.n	8022fc8 <lv_fs_get_ext+0x40>
 8022fbc:	687a      	ldr	r2, [r7, #4]
 8022fbe:	68fb      	ldr	r3, [r7, #12]
 8022fc0:	4413      	add	r3, r2
 8022fc2:	781b      	ldrb	r3, [r3, #0]
 8022fc4:	2b5c      	cmp	r3, #92	@ 0x5c
 8022fc6:	d101      	bne.n	8022fcc <lv_fs_get_ext+0x44>
            return ""; /*No extension if a '\' or '/' found*/
 8022fc8:	4b06      	ldr	r3, [pc, #24]	@ (8022fe4 <lv_fs_get_ext+0x5c>)
 8022fca:	e006      	b.n	8022fda <lv_fs_get_ext+0x52>
    for(i = lv_strlen(fn); i > 0; i--) {
 8022fcc:	68fb      	ldr	r3, [r7, #12]
 8022fce:	3b01      	subs	r3, #1
 8022fd0:	60fb      	str	r3, [r7, #12]
 8022fd2:	68fb      	ldr	r3, [r7, #12]
 8022fd4:	2b00      	cmp	r3, #0
 8022fd6:	d1e0      	bne.n	8022f9a <lv_fs_get_ext+0x12>
        }
    }

    return ""; /*Empty string if no '.' in the file name.*/
 8022fd8:	4b02      	ldr	r3, [pc, #8]	@ (8022fe4 <lv_fs_get_ext+0x5c>)
}
 8022fda:	4618      	mov	r0, r3
 8022fdc:	3710      	adds	r7, #16
 8022fde:	46bd      	mov	sp, r7
 8022fe0:	bd80      	pop	{r7, pc}
 8022fe2:	bf00      	nop
 8022fe4:	08027b9c 	.word	0x08027b9c

08022fe8 <lv_fs_get_real_path>:
 * Skip the driver letter and the possible : after the letter
 * @param path path string (E.g. S:/folder/file.txt)
 * @return pointer to the beginning of the real path (E.g. /folder/file.txt)
 */
static const char * lv_fs_get_real_path(const char * path)
{
 8022fe8:	b480      	push	{r7}
 8022fea:	b083      	sub	sp, #12
 8022fec:	af00      	add	r7, sp, #0
 8022fee:	6078      	str	r0, [r7, #4]
    path++; /*Ignore the driver letter*/
 8022ff0:	687b      	ldr	r3, [r7, #4]
 8022ff2:	3301      	adds	r3, #1
 8022ff4:	607b      	str	r3, [r7, #4]
    if(*path == ':') path++;
 8022ff6:	687b      	ldr	r3, [r7, #4]
 8022ff8:	781b      	ldrb	r3, [r3, #0]
 8022ffa:	2b3a      	cmp	r3, #58	@ 0x3a
 8022ffc:	d102      	bne.n	8023004 <lv_fs_get_real_path+0x1c>
 8022ffe:	687b      	ldr	r3, [r7, #4]
 8023000:	3301      	adds	r3, #1
 8023002:	607b      	str	r3, [r7, #4]

    return path;
 8023004:	687b      	ldr	r3, [r7, #4]
}
 8023006:	4618      	mov	r0, r3
 8023008:	370c      	adds	r7, #12
 802300a:	46bd      	mov	sp, r7
 802300c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023010:	4770      	bx	lr

08023012 <_lv_ll_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void _lv_ll_init(lv_ll_t * ll_p, uint32_t node_size)
{
 8023012:	b480      	push	{r7}
 8023014:	b083      	sub	sp, #12
 8023016:	af00      	add	r7, sp, #0
 8023018:	6078      	str	r0, [r7, #4]
 802301a:	6039      	str	r1, [r7, #0]
    ll_p->head = NULL;
 802301c:	687b      	ldr	r3, [r7, #4]
 802301e:	2200      	movs	r2, #0
 8023020:	605a      	str	r2, [r3, #4]
    ll_p->tail = NULL;
 8023022:	687b      	ldr	r3, [r7, #4]
 8023024:	2200      	movs	r2, #0
 8023026:	609a      	str	r2, [r3, #8]
#ifdef LV_ARCH_64
    /*Round the size up to 8*/
    node_size = (node_size + 7) & (~0x7);
#else
    /*Round the size up to 4*/
    node_size = (node_size + 3) & (~0x3);
 8023028:	683b      	ldr	r3, [r7, #0]
 802302a:	3303      	adds	r3, #3
 802302c:	f023 0303 	bic.w	r3, r3, #3
 8023030:	603b      	str	r3, [r7, #0]
#endif

    ll_p->n_size = node_size;
 8023032:	687b      	ldr	r3, [r7, #4]
 8023034:	683a      	ldr	r2, [r7, #0]
 8023036:	601a      	str	r2, [r3, #0]
}
 8023038:	bf00      	nop
 802303a:	370c      	adds	r7, #12
 802303c:	46bd      	mov	sp, r7
 802303e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023042:	4770      	bx	lr

08023044 <_lv_ll_ins_head>:

void * _lv_ll_ins_head(lv_ll_t * ll_p)
{
 8023044:	b580      	push	{r7, lr}
 8023046:	b084      	sub	sp, #16
 8023048:	af00      	add	r7, sp, #0
 802304a:	6078      	str	r0, [r7, #4]
    lv_ll_node_t * n_new;

    n_new = lv_malloc(ll_p->n_size + LL_NODE_META_SIZE);
 802304c:	687b      	ldr	r3, [r7, #4]
 802304e:	681b      	ldr	r3, [r3, #0]
 8023050:	3308      	adds	r3, #8
 8023052:	4618      	mov	r0, r3
 8023054:	f002 feb8 	bl	8025dc8 <lv_malloc>
 8023058:	60f8      	str	r0, [r7, #12]

    if(n_new != NULL) {
 802305a:	68fb      	ldr	r3, [r7, #12]
 802305c:	2b00      	cmp	r3, #0
 802305e:	d020      	beq.n	80230a2 <_lv_ll_ins_head+0x5e>
        node_set_prev(ll_p, n_new, NULL);       /*No prev. before the new head*/
 8023060:	2200      	movs	r2, #0
 8023062:	68f9      	ldr	r1, [r7, #12]
 8023064:	6878      	ldr	r0, [r7, #4]
 8023066:	f000 f8fd 	bl	8023264 <node_set_prev>
        node_set_next(ll_p, n_new, ll_p->head); /*After new comes the old head*/
 802306a:	687b      	ldr	r3, [r7, #4]
 802306c:	685b      	ldr	r3, [r3, #4]
 802306e:	461a      	mov	r2, r3
 8023070:	68f9      	ldr	r1, [r7, #12]
 8023072:	6878      	ldr	r0, [r7, #4]
 8023074:	f000 f915 	bl	80232a2 <node_set_next>

        if(ll_p->head != NULL) { /*If there is old head then before it goes the new*/
 8023078:	687b      	ldr	r3, [r7, #4]
 802307a:	685b      	ldr	r3, [r3, #4]
 802307c:	2b00      	cmp	r3, #0
 802307e:	d006      	beq.n	802308e <_lv_ll_ins_head+0x4a>
            node_set_prev(ll_p, ll_p->head, n_new);
 8023080:	687b      	ldr	r3, [r7, #4]
 8023082:	685b      	ldr	r3, [r3, #4]
 8023084:	68fa      	ldr	r2, [r7, #12]
 8023086:	4619      	mov	r1, r3
 8023088:	6878      	ldr	r0, [r7, #4]
 802308a:	f000 f8eb 	bl	8023264 <node_set_prev>
        }

        ll_p->head = n_new;      /*Set the new head in the dsc.*/
 802308e:	687b      	ldr	r3, [r7, #4]
 8023090:	68fa      	ldr	r2, [r7, #12]
 8023092:	605a      	str	r2, [r3, #4]
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
 8023094:	687b      	ldr	r3, [r7, #4]
 8023096:	689b      	ldr	r3, [r3, #8]
 8023098:	2b00      	cmp	r3, #0
 802309a:	d102      	bne.n	80230a2 <_lv_ll_ins_head+0x5e>
            ll_p->tail = n_new;
 802309c:	687b      	ldr	r3, [r7, #4]
 802309e:	68fa      	ldr	r2, [r7, #12]
 80230a0:	609a      	str	r2, [r3, #8]
        }
    }

    return n_new;
 80230a2:	68fb      	ldr	r3, [r7, #12]
}
 80230a4:	4618      	mov	r0, r3
 80230a6:	3710      	adds	r7, #16
 80230a8:	46bd      	mov	sp, r7
 80230aa:	bd80      	pop	{r7, pc}

080230ac <_lv_ll_ins_tail>:

    return n_new;
}

void * _lv_ll_ins_tail(lv_ll_t * ll_p)
{
 80230ac:	b580      	push	{r7, lr}
 80230ae:	b084      	sub	sp, #16
 80230b0:	af00      	add	r7, sp, #0
 80230b2:	6078      	str	r0, [r7, #4]
    lv_ll_node_t * n_new;

    n_new = lv_malloc(ll_p->n_size + LL_NODE_META_SIZE);
 80230b4:	687b      	ldr	r3, [r7, #4]
 80230b6:	681b      	ldr	r3, [r3, #0]
 80230b8:	3308      	adds	r3, #8
 80230ba:	4618      	mov	r0, r3
 80230bc:	f002 fe84 	bl	8025dc8 <lv_malloc>
 80230c0:	60f8      	str	r0, [r7, #12]

    if(n_new != NULL) {
 80230c2:	68fb      	ldr	r3, [r7, #12]
 80230c4:	2b00      	cmp	r3, #0
 80230c6:	d020      	beq.n	802310a <_lv_ll_ins_tail+0x5e>
        node_set_next(ll_p, n_new, NULL);       /*No next after the new tail*/
 80230c8:	2200      	movs	r2, #0
 80230ca:	68f9      	ldr	r1, [r7, #12]
 80230cc:	6878      	ldr	r0, [r7, #4]
 80230ce:	f000 f8e8 	bl	80232a2 <node_set_next>
        node_set_prev(ll_p, n_new, ll_p->tail); /*The prev. before new is the old tail*/
 80230d2:	687b      	ldr	r3, [r7, #4]
 80230d4:	689b      	ldr	r3, [r3, #8]
 80230d6:	461a      	mov	r2, r3
 80230d8:	68f9      	ldr	r1, [r7, #12]
 80230da:	6878      	ldr	r0, [r7, #4]
 80230dc:	f000 f8c2 	bl	8023264 <node_set_prev>
        if(ll_p->tail != NULL) {                /*If there is old tail then the new comes after it*/
 80230e0:	687b      	ldr	r3, [r7, #4]
 80230e2:	689b      	ldr	r3, [r3, #8]
 80230e4:	2b00      	cmp	r3, #0
 80230e6:	d006      	beq.n	80230f6 <_lv_ll_ins_tail+0x4a>
            node_set_next(ll_p, ll_p->tail, n_new);
 80230e8:	687b      	ldr	r3, [r7, #4]
 80230ea:	689b      	ldr	r3, [r3, #8]
 80230ec:	68fa      	ldr	r2, [r7, #12]
 80230ee:	4619      	mov	r1, r3
 80230f0:	6878      	ldr	r0, [r7, #4]
 80230f2:	f000 f8d6 	bl	80232a2 <node_set_next>
        }

        ll_p->tail = n_new;      /*Set the new tail in the dsc.*/
 80230f6:	687b      	ldr	r3, [r7, #4]
 80230f8:	68fa      	ldr	r2, [r7, #12]
 80230fa:	609a      	str	r2, [r3, #8]
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
 80230fc:	687b      	ldr	r3, [r7, #4]
 80230fe:	685b      	ldr	r3, [r3, #4]
 8023100:	2b00      	cmp	r3, #0
 8023102:	d102      	bne.n	802310a <_lv_ll_ins_tail+0x5e>
            ll_p->head = n_new;
 8023104:	687b      	ldr	r3, [r7, #4]
 8023106:	68fa      	ldr	r2, [r7, #12]
 8023108:	605a      	str	r2, [r3, #4]
        }
    }

    return n_new;
 802310a:	68fb      	ldr	r3, [r7, #12]
}
 802310c:	4618      	mov	r0, r3
 802310e:	3710      	adds	r7, #16
 8023110:	46bd      	mov	sp, r7
 8023112:	bd80      	pop	{r7, pc}

08023114 <_lv_ll_remove>:

void _lv_ll_remove(lv_ll_t * ll_p, void * node_p)
{
 8023114:	b580      	push	{r7, lr}
 8023116:	b084      	sub	sp, #16
 8023118:	af00      	add	r7, sp, #0
 802311a:	6078      	str	r0, [r7, #4]
 802311c:	6039      	str	r1, [r7, #0]
    if(ll_p == NULL) return;
 802311e:	687b      	ldr	r3, [r7, #4]
 8023120:	2b00      	cmp	r3, #0
 8023122:	d050      	beq.n	80231c6 <_lv_ll_remove+0xb2>

    if(_lv_ll_get_head(ll_p) == node_p) {
 8023124:	6878      	ldr	r0, [r7, #4]
 8023126:	f000 f852 	bl	80231ce <_lv_ll_get_head>
 802312a:	4602      	mov	r2, r0
 802312c:	683b      	ldr	r3, [r7, #0]
 802312e:	4293      	cmp	r3, r2
 8023130:	d116      	bne.n	8023160 <_lv_ll_remove+0x4c>
        /*The new head will be the node after 'n_act'*/
        ll_p->head = _lv_ll_get_next(ll_p, node_p);
 8023132:	6839      	ldr	r1, [r7, #0]
 8023134:	6878      	ldr	r0, [r7, #4]
 8023136:	f000 f86c 	bl	8023212 <_lv_ll_get_next>
 802313a:	4602      	mov	r2, r0
 802313c:	687b      	ldr	r3, [r7, #4]
 802313e:	605a      	str	r2, [r3, #4]
        if(ll_p->head == NULL) {
 8023140:	687b      	ldr	r3, [r7, #4]
 8023142:	685b      	ldr	r3, [r3, #4]
 8023144:	2b00      	cmp	r3, #0
 8023146:	d103      	bne.n	8023150 <_lv_ll_remove+0x3c>
            ll_p->tail = NULL;
 8023148:	687b      	ldr	r3, [r7, #4]
 802314a:	2200      	movs	r2, #0
 802314c:	609a      	str	r2, [r3, #8]
 802314e:	e03b      	b.n	80231c8 <_lv_ll_remove+0xb4>
        }
        else {
            node_set_prev(ll_p, ll_p->head, NULL);
 8023150:	687b      	ldr	r3, [r7, #4]
 8023152:	685b      	ldr	r3, [r3, #4]
 8023154:	2200      	movs	r2, #0
 8023156:	4619      	mov	r1, r3
 8023158:	6878      	ldr	r0, [r7, #4]
 802315a:	f000 f883 	bl	8023264 <node_set_prev>
 802315e:	e033      	b.n	80231c8 <_lv_ll_remove+0xb4>
        }
    }
    else if(_lv_ll_get_tail(ll_p) == node_p) {
 8023160:	6878      	ldr	r0, [r7, #4]
 8023162:	f000 f845 	bl	80231f0 <_lv_ll_get_tail>
 8023166:	4602      	mov	r2, r0
 8023168:	683b      	ldr	r3, [r7, #0]
 802316a:	4293      	cmp	r3, r2
 802316c:	d116      	bne.n	802319c <_lv_ll_remove+0x88>
        /*The new tail will be the node before 'n_act'*/
        ll_p->tail = _lv_ll_get_prev(ll_p, node_p);
 802316e:	6839      	ldr	r1, [r7, #0]
 8023170:	6878      	ldr	r0, [r7, #4]
 8023172:	f000 f863 	bl	802323c <_lv_ll_get_prev>
 8023176:	4602      	mov	r2, r0
 8023178:	687b      	ldr	r3, [r7, #4]
 802317a:	609a      	str	r2, [r3, #8]
        if(ll_p->tail == NULL) {
 802317c:	687b      	ldr	r3, [r7, #4]
 802317e:	689b      	ldr	r3, [r3, #8]
 8023180:	2b00      	cmp	r3, #0
 8023182:	d103      	bne.n	802318c <_lv_ll_remove+0x78>
            ll_p->head = NULL;
 8023184:	687b      	ldr	r3, [r7, #4]
 8023186:	2200      	movs	r2, #0
 8023188:	605a      	str	r2, [r3, #4]
 802318a:	e01d      	b.n	80231c8 <_lv_ll_remove+0xb4>
        }
        else {
            node_set_next(ll_p, ll_p->tail, NULL);
 802318c:	687b      	ldr	r3, [r7, #4]
 802318e:	689b      	ldr	r3, [r3, #8]
 8023190:	2200      	movs	r2, #0
 8023192:	4619      	mov	r1, r3
 8023194:	6878      	ldr	r0, [r7, #4]
 8023196:	f000 f884 	bl	80232a2 <node_set_next>
 802319a:	e015      	b.n	80231c8 <_lv_ll_remove+0xb4>
        }
    }
    else {
        lv_ll_node_t * n_prev = _lv_ll_get_prev(ll_p, node_p);
 802319c:	6839      	ldr	r1, [r7, #0]
 802319e:	6878      	ldr	r0, [r7, #4]
 80231a0:	f000 f84c 	bl	802323c <_lv_ll_get_prev>
 80231a4:	60f8      	str	r0, [r7, #12]
        lv_ll_node_t * n_next = _lv_ll_get_next(ll_p, node_p);
 80231a6:	6839      	ldr	r1, [r7, #0]
 80231a8:	6878      	ldr	r0, [r7, #4]
 80231aa:	f000 f832 	bl	8023212 <_lv_ll_get_next>
 80231ae:	60b8      	str	r0, [r7, #8]

        node_set_next(ll_p, n_prev, n_next);
 80231b0:	68ba      	ldr	r2, [r7, #8]
 80231b2:	68f9      	ldr	r1, [r7, #12]
 80231b4:	6878      	ldr	r0, [r7, #4]
 80231b6:	f000 f874 	bl	80232a2 <node_set_next>
        node_set_prev(ll_p, n_next, n_prev);
 80231ba:	68fa      	ldr	r2, [r7, #12]
 80231bc:	68b9      	ldr	r1, [r7, #8]
 80231be:	6878      	ldr	r0, [r7, #4]
 80231c0:	f000 f850 	bl	8023264 <node_set_prev>
 80231c4:	e000      	b.n	80231c8 <_lv_ll_remove+0xb4>
    if(ll_p == NULL) return;
 80231c6:	bf00      	nop
    }
}
 80231c8:	3710      	adds	r7, #16
 80231ca:	46bd      	mov	sp, r7
 80231cc:	bd80      	pop	{r7, pc}

080231ce <_lv_ll_get_head>:
        }
    }
}

void * _lv_ll_get_head(const lv_ll_t * ll_p)
{
 80231ce:	b480      	push	{r7}
 80231d0:	b083      	sub	sp, #12
 80231d2:	af00      	add	r7, sp, #0
 80231d4:	6078      	str	r0, [r7, #4]
    if(ll_p == NULL) return NULL;
 80231d6:	687b      	ldr	r3, [r7, #4]
 80231d8:	2b00      	cmp	r3, #0
 80231da:	d101      	bne.n	80231e0 <_lv_ll_get_head+0x12>
 80231dc:	2300      	movs	r3, #0
 80231de:	e001      	b.n	80231e4 <_lv_ll_get_head+0x16>
    return ll_p->head;
 80231e0:	687b      	ldr	r3, [r7, #4]
 80231e2:	685b      	ldr	r3, [r3, #4]
}
 80231e4:	4618      	mov	r0, r3
 80231e6:	370c      	adds	r7, #12
 80231e8:	46bd      	mov	sp, r7
 80231ea:	f85d 7b04 	ldr.w	r7, [sp], #4
 80231ee:	4770      	bx	lr

080231f0 <_lv_ll_get_tail>:

void * _lv_ll_get_tail(const lv_ll_t * ll_p)
{
 80231f0:	b480      	push	{r7}
 80231f2:	b083      	sub	sp, #12
 80231f4:	af00      	add	r7, sp, #0
 80231f6:	6078      	str	r0, [r7, #4]
    if(ll_p == NULL) return NULL;
 80231f8:	687b      	ldr	r3, [r7, #4]
 80231fa:	2b00      	cmp	r3, #0
 80231fc:	d101      	bne.n	8023202 <_lv_ll_get_tail+0x12>
 80231fe:	2300      	movs	r3, #0
 8023200:	e001      	b.n	8023206 <_lv_ll_get_tail+0x16>
    return ll_p->tail;
 8023202:	687b      	ldr	r3, [r7, #4]
 8023204:	689b      	ldr	r3, [r3, #8]
}
 8023206:	4618      	mov	r0, r3
 8023208:	370c      	adds	r7, #12
 802320a:	46bd      	mov	sp, r7
 802320c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023210:	4770      	bx	lr

08023212 <_lv_ll_get_next>:

void * _lv_ll_get_next(const lv_ll_t * ll_p, const void * n_act)
{
 8023212:	b480      	push	{r7}
 8023214:	b085      	sub	sp, #20
 8023216:	af00      	add	r7, sp, #0
 8023218:	6078      	str	r0, [r7, #4]
 802321a:	6039      	str	r1, [r7, #0]
    /*Pointer to the next node is stored in the end of this node.
     *Go there and return the address found there*/
    const lv_ll_node_t * n_act_d = n_act;
 802321c:	683b      	ldr	r3, [r7, #0]
 802321e:	60fb      	str	r3, [r7, #12]
    n_act_d += LL_NEXT_P_OFFSET(ll_p);
 8023220:	687b      	ldr	r3, [r7, #4]
 8023222:	681b      	ldr	r3, [r3, #0]
 8023224:	3304      	adds	r3, #4
 8023226:	68fa      	ldr	r2, [r7, #12]
 8023228:	4413      	add	r3, r2
 802322a:	60fb      	str	r3, [r7, #12]
    return *((lv_ll_node_t **)n_act_d);
 802322c:	68fb      	ldr	r3, [r7, #12]
 802322e:	681b      	ldr	r3, [r3, #0]
}
 8023230:	4618      	mov	r0, r3
 8023232:	3714      	adds	r7, #20
 8023234:	46bd      	mov	sp, r7
 8023236:	f85d 7b04 	ldr.w	r7, [sp], #4
 802323a:	4770      	bx	lr

0802323c <_lv_ll_get_prev>:

void * _lv_ll_get_prev(const lv_ll_t * ll_p, const void * n_act)
{
 802323c:	b480      	push	{r7}
 802323e:	b085      	sub	sp, #20
 8023240:	af00      	add	r7, sp, #0
 8023242:	6078      	str	r0, [r7, #4]
 8023244:	6039      	str	r1, [r7, #0]
    /*Pointer to the prev. node is stored in the end of this node.
     *Go there and return the address found there*/
    const lv_ll_node_t * n_act_d = n_act;
 8023246:	683b      	ldr	r3, [r7, #0]
 8023248:	60fb      	str	r3, [r7, #12]
    n_act_d += LL_PREV_P_OFFSET(ll_p);
 802324a:	687b      	ldr	r3, [r7, #4]
 802324c:	681b      	ldr	r3, [r3, #0]
 802324e:	68fa      	ldr	r2, [r7, #12]
 8023250:	4413      	add	r3, r2
 8023252:	60fb      	str	r3, [r7, #12]
    return *((lv_ll_node_t **)n_act_d);
 8023254:	68fb      	ldr	r3, [r7, #12]
 8023256:	681b      	ldr	r3, [r3, #0]
}
 8023258:	4618      	mov	r0, r3
 802325a:	3714      	adds	r7, #20
 802325c:	46bd      	mov	sp, r7
 802325e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023262:	4770      	bx	lr

08023264 <node_set_prev>:
 * @param ll_p pointer to linked list
 * @param act pointer to a node which prev. node pointer should be set
 * @param prev pointer to a node which should be the previous node before 'act'
 */
static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * prev)
{
 8023264:	b480      	push	{r7}
 8023266:	b089      	sub	sp, #36	@ 0x24
 8023268:	af00      	add	r7, sp, #0
 802326a:	60f8      	str	r0, [r7, #12]
 802326c:	60b9      	str	r1, [r7, #8]
 802326e:	607a      	str	r2, [r7, #4]
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
 8023270:	68bb      	ldr	r3, [r7, #8]
 8023272:	2b00      	cmp	r3, #0
 8023274:	d00f      	beq.n	8023296 <node_set_prev+0x32>

    uint8_t * act8 = (uint8_t *)act;
 8023276:	68bb      	ldr	r3, [r7, #8]
 8023278:	61fb      	str	r3, [r7, #28]

    act8 += LL_PREV_P_OFFSET(ll_p);
 802327a:	68fb      	ldr	r3, [r7, #12]
 802327c:	681b      	ldr	r3, [r3, #0]
 802327e:	69fa      	ldr	r2, [r7, #28]
 8023280:	4413      	add	r3, r2
 8023282:	61fb      	str	r3, [r7, #28]

    lv_ll_node_t ** act_node_p = (lv_ll_node_t **) act8;
 8023284:	69fb      	ldr	r3, [r7, #28]
 8023286:	61bb      	str	r3, [r7, #24]
    lv_ll_node_t ** prev_node_p = (lv_ll_node_t **) &prev;
 8023288:	1d3b      	adds	r3, r7, #4
 802328a:	617b      	str	r3, [r7, #20]

    *act_node_p = *prev_node_p;
 802328c:	697b      	ldr	r3, [r7, #20]
 802328e:	681a      	ldr	r2, [r3, #0]
 8023290:	69bb      	ldr	r3, [r7, #24]
 8023292:	601a      	str	r2, [r3, #0]
 8023294:	e000      	b.n	8023298 <node_set_prev+0x34>
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
 8023296:	bf00      	nop
}
 8023298:	3724      	adds	r7, #36	@ 0x24
 802329a:	46bd      	mov	sp, r7
 802329c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80232a0:	4770      	bx	lr

080232a2 <node_set_next>:
 * @param ll_p pointer to linked list
 * @param act pointer to a node which next node pointer should be set
 * @param next pointer to a node which should be the next node before 'act'
 */
static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
{
 80232a2:	b480      	push	{r7}
 80232a4:	b089      	sub	sp, #36	@ 0x24
 80232a6:	af00      	add	r7, sp, #0
 80232a8:	60f8      	str	r0, [r7, #12]
 80232aa:	60b9      	str	r1, [r7, #8]
 80232ac:	607a      	str	r2, [r7, #4]
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
 80232ae:	68bb      	ldr	r3, [r7, #8]
 80232b0:	2b00      	cmp	r3, #0
 80232b2:	d010      	beq.n	80232d6 <node_set_next+0x34>
    uint8_t * act8 = (uint8_t *)act;
 80232b4:	68bb      	ldr	r3, [r7, #8]
 80232b6:	61fb      	str	r3, [r7, #28]

    act8 += LL_NEXT_P_OFFSET(ll_p);
 80232b8:	68fb      	ldr	r3, [r7, #12]
 80232ba:	681b      	ldr	r3, [r3, #0]
 80232bc:	3304      	adds	r3, #4
 80232be:	69fa      	ldr	r2, [r7, #28]
 80232c0:	4413      	add	r3, r2
 80232c2:	61fb      	str	r3, [r7, #28]
    lv_ll_node_t ** act_node_p = (lv_ll_node_t **) act8;
 80232c4:	69fb      	ldr	r3, [r7, #28]
 80232c6:	61bb      	str	r3, [r7, #24]
    lv_ll_node_t ** next_node_p = (lv_ll_node_t **) &next;
 80232c8:	1d3b      	adds	r3, r7, #4
 80232ca:	617b      	str	r3, [r7, #20]

    *act_node_p = *next_node_p;
 80232cc:	697b      	ldr	r3, [r7, #20]
 80232ce:	681a      	ldr	r2, [r3, #0]
 80232d0:	69bb      	ldr	r3, [r7, #24]
 80232d2:	601a      	str	r2, [r3, #0]
 80232d4:	e000      	b.n	80232d8 <node_set_next+0x36>
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
 80232d6:	bf00      	nop
}
 80232d8:	3724      	adds	r7, #36	@ 0x24
 80232da:	46bd      	mov	sp, r7
 80232dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80232e0:	4770      	bx	lr
	...

080232e4 <lv_trigo_sin>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

int32_t LV_ATTRIBUTE_FAST_MEM lv_trigo_sin(int16_t angle)
{
 80232e4:	b480      	push	{r7}
 80232e6:	b085      	sub	sp, #20
 80232e8:	af00      	add	r7, sp, #0
 80232ea:	4603      	mov	r3, r0
 80232ec:	80fb      	strh	r3, [r7, #6]
    int32_t ret = 0;
 80232ee:	2300      	movs	r3, #0
 80232f0:	60fb      	str	r3, [r7, #12]
    while(angle < 0) angle += 360;
 80232f2:	e004      	b.n	80232fe <lv_trigo_sin+0x1a>
 80232f4:	88fb      	ldrh	r3, [r7, #6]
 80232f6:	f503 73b4 	add.w	r3, r3, #360	@ 0x168
 80232fa:	b29b      	uxth	r3, r3
 80232fc:	80fb      	strh	r3, [r7, #6]
 80232fe:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8023302:	2b00      	cmp	r3, #0
 8023304:	dbf6      	blt.n	80232f4 <lv_trigo_sin+0x10>
    while(angle >= 360) angle -= 360;
 8023306:	e004      	b.n	8023312 <lv_trigo_sin+0x2e>
 8023308:	88fb      	ldrh	r3, [r7, #6]
 802330a:	f5a3 73b4 	sub.w	r3, r3, #360	@ 0x168
 802330e:	b29b      	uxth	r3, r3
 8023310:	80fb      	strh	r3, [r7, #6]
 8023312:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8023316:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
 802331a:	daf5      	bge.n	8023308 <lv_trigo_sin+0x24>

    if(angle < 90) {
 802331c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8023320:	2b59      	cmp	r3, #89	@ 0x59
 8023322:	dc06      	bgt.n	8023332 <lv_trigo_sin+0x4e>
        ret = sin0_90_table[angle];
 8023324:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8023328:	4a27      	ldr	r2, [pc, #156]	@ (80233c8 <lv_trigo_sin+0xe4>)
 802332a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 802332e:	60fb      	str	r3, [r7, #12]
 8023330:	e034      	b.n	802339c <lv_trigo_sin+0xb8>
    }
    else if(angle >= 90 && angle < 180) {
 8023332:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8023336:	2b59      	cmp	r3, #89	@ 0x59
 8023338:	dd0f      	ble.n	802335a <lv_trigo_sin+0x76>
 802333a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 802333e:	2bb3      	cmp	r3, #179	@ 0xb3
 8023340:	dc0b      	bgt.n	802335a <lv_trigo_sin+0x76>
        angle = 180 - angle;
 8023342:	88fb      	ldrh	r3, [r7, #6]
 8023344:	f1c3 03b4 	rsb	r3, r3, #180	@ 0xb4
 8023348:	b29b      	uxth	r3, r3
 802334a:	80fb      	strh	r3, [r7, #6]
        ret   = sin0_90_table[angle];
 802334c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8023350:	4a1d      	ldr	r2, [pc, #116]	@ (80233c8 <lv_trigo_sin+0xe4>)
 8023352:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8023356:	60fb      	str	r3, [r7, #12]
 8023358:	e020      	b.n	802339c <lv_trigo_sin+0xb8>
    }
    else if(angle >= 180 && angle < 270) {
 802335a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 802335e:	2bb3      	cmp	r3, #179	@ 0xb3
 8023360:	dd10      	ble.n	8023384 <lv_trigo_sin+0xa0>
 8023362:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8023366:	f5b3 7f87 	cmp.w	r3, #270	@ 0x10e
 802336a:	da0b      	bge.n	8023384 <lv_trigo_sin+0xa0>
        angle = angle - 180;
 802336c:	88fb      	ldrh	r3, [r7, #6]
 802336e:	3bb4      	subs	r3, #180	@ 0xb4
 8023370:	b29b      	uxth	r3, r3
 8023372:	80fb      	strh	r3, [r7, #6]
        ret   = -sin0_90_table[angle];
 8023374:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8023378:	4a13      	ldr	r2, [pc, #76]	@ (80233c8 <lv_trigo_sin+0xe4>)
 802337a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 802337e:	425b      	negs	r3, r3
 8023380:	60fb      	str	r3, [r7, #12]
 8023382:	e00b      	b.n	802339c <lv_trigo_sin+0xb8>
    }
    else {   /*angle >=270*/
        angle = 360 - angle;
 8023384:	88fb      	ldrh	r3, [r7, #6]
 8023386:	f5c3 73b4 	rsb	r3, r3, #360	@ 0x168
 802338a:	b29b      	uxth	r3, r3
 802338c:	80fb      	strh	r3, [r7, #6]
        ret   = -sin0_90_table[angle];
 802338e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8023392:	4a0d      	ldr	r2, [pc, #52]	@ (80233c8 <lv_trigo_sin+0xe4>)
 8023394:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8023398:	425b      	negs	r3, r3
 802339a:	60fb      	str	r3, [r7, #12]
    }

    if(ret == 32767) return 32768;
 802339c:	68fb      	ldr	r3, [r7, #12]
 802339e:	f647 72ff 	movw	r2, #32767	@ 0x7fff
 80233a2:	4293      	cmp	r3, r2
 80233a4:	d102      	bne.n	80233ac <lv_trigo_sin+0xc8>
 80233a6:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80233aa:	e006      	b.n	80233ba <lv_trigo_sin+0xd6>
    else if(ret == -32767) return -32768;
 80233ac:	68fb      	ldr	r3, [r7, #12]
 80233ae:	4a07      	ldr	r2, [pc, #28]	@ (80233cc <lv_trigo_sin+0xe8>)
 80233b0:	4293      	cmp	r3, r2
 80233b2:	d101      	bne.n	80233b8 <lv_trigo_sin+0xd4>
 80233b4:	4b06      	ldr	r3, [pc, #24]	@ (80233d0 <lv_trigo_sin+0xec>)
 80233b6:	e000      	b.n	80233ba <lv_trigo_sin+0xd6>
    else return ret;
 80233b8:	68fb      	ldr	r3, [r7, #12]
}
 80233ba:	4618      	mov	r0, r3
 80233bc:	3714      	adds	r7, #20
 80233be:	46bd      	mov	sp, r7
 80233c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80233c4:	4770      	bx	lr
 80233c6:	bf00      	nop
 80233c8:	0802b178 	.word	0x0802b178
 80233cc:	ffff8001 	.word	0xffff8001
 80233d0:	ffff8000 	.word	0xffff8000

080233d4 <do_cubic_bezier>:
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 */

static int32_t do_cubic_bezier(int32_t t, int32_t a, int32_t b, int32_t c)
{
 80233d4:	b480      	push	{r7}
 80233d6:	b087      	sub	sp, #28
 80233d8:	af00      	add	r7, sp, #0
 80233da:	60f8      	str	r0, [r7, #12]
 80233dc:	60b9      	str	r1, [r7, #8]
 80233de:	607a      	str	r2, [r7, #4]
 80233e0:	603b      	str	r3, [r7, #0]
    int64_t ret;
#else
    int32_t ret;
#endif

    ret = a;
 80233e2:	68bb      	ldr	r3, [r7, #8]
 80233e4:	617b      	str	r3, [r7, #20]
    ret = (ret * t) >> CUBIC_PRECISION_BITS;
 80233e6:	697b      	ldr	r3, [r7, #20]
 80233e8:	68fa      	ldr	r2, [r7, #12]
 80233ea:	fb02 f303 	mul.w	r3, r2, r3
 80233ee:	129b      	asrs	r3, r3, #10
 80233f0:	617b      	str	r3, [r7, #20]
    ret = ((ret + b) * t) >> CUBIC_PRECISION_BITS;
 80233f2:	697a      	ldr	r2, [r7, #20]
 80233f4:	687b      	ldr	r3, [r7, #4]
 80233f6:	4413      	add	r3, r2
 80233f8:	68fa      	ldr	r2, [r7, #12]
 80233fa:	fb02 f303 	mul.w	r3, r2, r3
 80233fe:	129b      	asrs	r3, r3, #10
 8023400:	617b      	str	r3, [r7, #20]
    ret = ((ret + c) * t) >> CUBIC_PRECISION_BITS;
 8023402:	697a      	ldr	r2, [r7, #20]
 8023404:	683b      	ldr	r3, [r7, #0]
 8023406:	4413      	add	r3, r2
 8023408:	68fa      	ldr	r2, [r7, #12]
 802340a:	fb02 f303 	mul.w	r3, r2, r3
 802340e:	129b      	asrs	r3, r3, #10
 8023410:	617b      	str	r3, [r7, #20]
    return ret;
 8023412:	697b      	ldr	r3, [r7, #20]
}
 8023414:	4618      	mov	r0, r3
 8023416:	371c      	adds	r7, #28
 8023418:	46bd      	mov	sp, r7
 802341a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802341e:	4770      	bx	lr

08023420 <lv_cubic_bezier>:

int32_t lv_cubic_bezier(int32_t x, int32_t x1, int32_t y1, int32_t x2, int32_t y2)
{
 8023420:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8023424:	b090      	sub	sp, #64	@ 0x40
 8023426:	af00      	add	r7, sp, #0
 8023428:	60f8      	str	r0, [r7, #12]
 802342a:	60b9      	str	r1, [r7, #8]
 802342c:	607a      	str	r2, [r7, #4]
 802342e:	603b      	str	r3, [r7, #0]
    int64_t d; /*slope value at specified t*/
#else
    int32_t d;
#endif

    if(x == 0 || x == LV_BEZIER_VAL_MAX) return x;
 8023430:	68fb      	ldr	r3, [r7, #12]
 8023432:	2b00      	cmp	r3, #0
 8023434:	d003      	beq.n	802343e <lv_cubic_bezier+0x1e>
 8023436:	68fb      	ldr	r3, [r7, #12]
 8023438:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 802343c:	d101      	bne.n	8023442 <lv_cubic_bezier+0x22>
 802343e:	68fb      	ldr	r3, [r7, #12]
 8023440:	e0d5      	b.n	80235ee <lv_cubic_bezier+0x1ce>
    x2 <<= CUBIC_PRECISION_BITS - LV_BEZIER_VAL_SHIFT;
    y1 <<= CUBIC_PRECISION_BITS - LV_BEZIER_VAL_SHIFT;
    y2 <<= CUBIC_PRECISION_BITS - LV_BEZIER_VAL_SHIFT;
#endif

    cx = 3 * x1;
 8023442:	68ba      	ldr	r2, [r7, #8]
 8023444:	4613      	mov	r3, r2
 8023446:	005b      	lsls	r3, r3, #1
 8023448:	4413      	add	r3, r2
 802344a:	62fb      	str	r3, [r7, #44]	@ 0x2c
    bx = 3 * (x2 - x1) - cx;
 802344c:	683a      	ldr	r2, [r7, #0]
 802344e:	68bb      	ldr	r3, [r7, #8]
 8023450:	1ad2      	subs	r2, r2, r3
 8023452:	4613      	mov	r3, r2
 8023454:	005b      	lsls	r3, r3, #1
 8023456:	441a      	add	r2, r3
 8023458:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802345a:	1ad3      	subs	r3, r2, r3
 802345c:	62bb      	str	r3, [r7, #40]	@ 0x28
    ax = (1L << CUBIC_PRECISION_BITS) - cx - bx;
 802345e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023460:	f5c3 6280 	rsb	r2, r3, #1024	@ 0x400
 8023464:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8023466:	1ad3      	subs	r3, r2, r3
 8023468:	627b      	str	r3, [r7, #36]	@ 0x24

    cy = 3 * y1;
 802346a:	687a      	ldr	r2, [r7, #4]
 802346c:	4613      	mov	r3, r2
 802346e:	005b      	lsls	r3, r3, #1
 8023470:	4413      	add	r3, r2
 8023472:	623b      	str	r3, [r7, #32]
    by = 3 * (y2 - y1) - cy;
 8023474:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8023476:	687b      	ldr	r3, [r7, #4]
 8023478:	1ad2      	subs	r2, r2, r3
 802347a:	4613      	mov	r3, r2
 802347c:	005b      	lsls	r3, r3, #1
 802347e:	441a      	add	r2, r3
 8023480:	6a3b      	ldr	r3, [r7, #32]
 8023482:	1ad3      	subs	r3, r2, r3
 8023484:	61fb      	str	r3, [r7, #28]
    ay = (1L << CUBIC_PRECISION_BITS)  - cy - by;
 8023486:	6a3b      	ldr	r3, [r7, #32]
 8023488:	f5c3 6280 	rsb	r2, r3, #1024	@ 0x400
 802348c:	69fb      	ldr	r3, [r7, #28]
 802348e:	1ad3      	subs	r3, r2, r3
 8023490:	61bb      	str	r3, [r7, #24]

    /*Try Newton's method firstly */
    t = x; /*Make a guess*/
 8023492:	68fb      	ldr	r3, [r7, #12]
 8023494:	637b      	str	r3, [r7, #52]	@ 0x34
    for(int i = 0; i < CUBIC_NEWTON_ITERATIONS; i++) {
 8023496:	2300      	movs	r3, #0
 8023498:	633b      	str	r3, [r7, #48]	@ 0x30
 802349a:	e052      	b.n	8023542 <lv_cubic_bezier+0x122>
        /*Check if x on curve at t matches input x*/
        xs = do_cubic_bezier(t, ax, bx, cx) - x;
 802349c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802349e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80234a0:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80234a2:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80234a4:	f7ff ff96 	bl	80233d4 <do_cubic_bezier>
 80234a8:	4602      	mov	r2, r0
 80234aa:	68fb      	ldr	r3, [r7, #12]
 80234ac:	1ad3      	subs	r3, r2, r3
 80234ae:	617b      	str	r3, [r7, #20]
        if(LV_ABS(xs) <= 1) goto found;
 80234b0:	697b      	ldr	r3, [r7, #20]
 80234b2:	f1b3 3fff 	cmp.w	r3, #4294967295
 80234b6:	db03      	blt.n	80234c0 <lv_cubic_bezier+0xa0>
 80234b8:	697b      	ldr	r3, [r7, #20]
 80234ba:	2b01      	cmp	r3, #1
 80234bc:	f340 808b 	ble.w	80235d6 <lv_cubic_bezier+0x1b6>

        /* get slop at t, d = 3 * ax * t^2 + 2 * bx + t + cx */
        d = ax; /* use 64bit operation if needed. */
 80234c0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80234c2:	613b      	str	r3, [r7, #16]
        d = (3 * d * t) >> CUBIC_PRECISION_BITS;
 80234c4:	693b      	ldr	r3, [r7, #16]
 80234c6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80234c8:	fb03 f202 	mul.w	r2, r3, r2
 80234cc:	4613      	mov	r3, r2
 80234ce:	005b      	lsls	r3, r3, #1
 80234d0:	4413      	add	r3, r2
 80234d2:	129b      	asrs	r3, r3, #10
 80234d4:	613b      	str	r3, [r7, #16]
        d = ((d + 2 * bx) * t) >> CUBIC_PRECISION_BITS;
 80234d6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80234d8:	005a      	lsls	r2, r3, #1
 80234da:	693b      	ldr	r3, [r7, #16]
 80234dc:	4413      	add	r3, r2
 80234de:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80234e0:	fb02 f303 	mul.w	r3, r2, r3
 80234e4:	129b      	asrs	r3, r3, #10
 80234e6:	613b      	str	r3, [r7, #16]
        d += cx;
 80234e8:	693a      	ldr	r2, [r7, #16]
 80234ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80234ec:	4413      	add	r3, r2
 80234ee:	613b      	str	r3, [r7, #16]

        if(LV_ABS(d) <= 1) break;
 80234f0:	693b      	ldr	r3, [r7, #16]
 80234f2:	f1b3 3fff 	cmp.w	r3, #4294967295
 80234f6:	db02      	blt.n	80234fe <lv_cubic_bezier+0xde>
 80234f8:	693b      	ldr	r3, [r7, #16]
 80234fa:	2b01      	cmp	r3, #1
 80234fc:	dd25      	ble.n	802354a <lv_cubic_bezier+0x12a>

        d = ((int64_t)xs * (1L << CUBIC_PRECISION_BITS)) / d;
 80234fe:	697b      	ldr	r3, [r7, #20]
 8023500:	17da      	asrs	r2, r3, #31
 8023502:	461c      	mov	r4, r3
 8023504:	4615      	mov	r5, r2
 8023506:	f04f 0000 	mov.w	r0, #0
 802350a:	f04f 0100 	mov.w	r1, #0
 802350e:	02a9      	lsls	r1, r5, #10
 8023510:	ea41 5194 	orr.w	r1, r1, r4, lsr #22
 8023514:	02a0      	lsls	r0, r4, #10
 8023516:	693b      	ldr	r3, [r7, #16]
 8023518:	17da      	asrs	r2, r3, #31
 802351a:	4698      	mov	r8, r3
 802351c:	4691      	mov	r9, r2
 802351e:	4642      	mov	r2, r8
 8023520:	464b      	mov	r3, r9
 8023522:	f7dc fe59 	bl	80001d8 <__aeabi_ldivmod>
 8023526:	4602      	mov	r2, r0
 8023528:	460b      	mov	r3, r1
 802352a:	4613      	mov	r3, r2
 802352c:	613b      	str	r3, [r7, #16]
        if(d == 0) break;  /*Reached precision limits*/
 802352e:	693b      	ldr	r3, [r7, #16]
 8023530:	2b00      	cmp	r3, #0
 8023532:	d00c      	beq.n	802354e <lv_cubic_bezier+0x12e>
        t -= d;
 8023534:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8023536:	693b      	ldr	r3, [r7, #16]
 8023538:	1ad3      	subs	r3, r2, r3
 802353a:	637b      	str	r3, [r7, #52]	@ 0x34
    for(int i = 0; i < CUBIC_NEWTON_ITERATIONS; i++) {
 802353c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802353e:	3301      	adds	r3, #1
 8023540:	633b      	str	r3, [r7, #48]	@ 0x30
 8023542:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8023544:	2b07      	cmp	r3, #7
 8023546:	dda9      	ble.n	802349c <lv_cubic_bezier+0x7c>
 8023548:	e002      	b.n	8023550 <lv_cubic_bezier+0x130>
        if(LV_ABS(d) <= 1) break;
 802354a:	bf00      	nop
 802354c:	e000      	b.n	8023550 <lv_cubic_bezier+0x130>
        if(d == 0) break;  /*Reached precision limits*/
 802354e:	bf00      	nop
    }

    /*Fallback to bisection method for reliability*/
    tl = 0, tr = 1L << CUBIC_PRECISION_BITS, t = x;
 8023550:	2300      	movs	r3, #0
 8023552:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8023554:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8023558:	63bb      	str	r3, [r7, #56]	@ 0x38
 802355a:	68fb      	ldr	r3, [r7, #12]
 802355c:	637b      	str	r3, [r7, #52]	@ 0x34

    if(t < tl) {
 802355e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8023560:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8023562:	429a      	cmp	r2, r3
 8023564:	da02      	bge.n	802356c <lv_cubic_bezier+0x14c>
        t = tl;
 8023566:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8023568:	637b      	str	r3, [r7, #52]	@ 0x34
        goto found;
 802356a:	e039      	b.n	80235e0 <lv_cubic_bezier+0x1c0>
    }

    if(t > tr) {
 802356c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 802356e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8023570:	429a      	cmp	r2, r3
 8023572:	dd2b      	ble.n	80235cc <lv_cubic_bezier+0x1ac>
        t = tr;
 8023574:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8023576:	637b      	str	r3, [r7, #52]	@ 0x34
        goto found;
 8023578:	e032      	b.n	80235e0 <lv_cubic_bezier+0x1c0>
    }

    while(tl < tr) {
        xs = do_cubic_bezier(t, ax, bx, cx);
 802357a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802357c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 802357e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8023580:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 8023582:	f7ff ff27 	bl	80233d4 <do_cubic_bezier>
 8023586:	6178      	str	r0, [r7, #20]
        if(LV_ABS(xs - x) <= 1) goto found;
 8023588:	697a      	ldr	r2, [r7, #20]
 802358a:	68fb      	ldr	r3, [r7, #12]
 802358c:	1ad3      	subs	r3, r2, r3
 802358e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8023592:	db04      	blt.n	802359e <lv_cubic_bezier+0x17e>
 8023594:	697a      	ldr	r2, [r7, #20]
 8023596:	68fb      	ldr	r3, [r7, #12]
 8023598:	1ad3      	subs	r3, r2, r3
 802359a:	2b01      	cmp	r3, #1
 802359c:	dd1d      	ble.n	80235da <lv_cubic_bezier+0x1ba>
        x > xs ? (tl = t) : (tr = t);
 802359e:	68fa      	ldr	r2, [r7, #12]
 80235a0:	697b      	ldr	r3, [r7, #20]
 80235a2:	429a      	cmp	r2, r3
 80235a4:	dd02      	ble.n	80235ac <lv_cubic_bezier+0x18c>
 80235a6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80235a8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80235aa:	e001      	b.n	80235b0 <lv_cubic_bezier+0x190>
 80235ac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80235ae:	63bb      	str	r3, [r7, #56]	@ 0x38
        t = (tr - tl) / 2 + tl;
 80235b0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80235b2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80235b4:	1ad3      	subs	r3, r2, r3
 80235b6:	0fda      	lsrs	r2, r3, #31
 80235b8:	4413      	add	r3, r2
 80235ba:	105b      	asrs	r3, r3, #1
 80235bc:	461a      	mov	r2, r3
 80235be:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80235c0:	4413      	add	r3, r2
 80235c2:	637b      	str	r3, [r7, #52]	@ 0x34
        if(t == tl) break;
 80235c4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80235c6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80235c8:	429a      	cmp	r2, r3
 80235ca:	d008      	beq.n	80235de <lv_cubic_bezier+0x1be>
    while(tl < tr) {
 80235cc:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 80235ce:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80235d0:	429a      	cmp	r2, r3
 80235d2:	dbd2      	blt.n	802357a <lv_cubic_bezier+0x15a>
    }

    /*Failed to find suitable t for given x, return a value anyway.*/
found:
 80235d4:	e004      	b.n	80235e0 <lv_cubic_bezier+0x1c0>
        if(LV_ABS(xs) <= 1) goto found;
 80235d6:	bf00      	nop
 80235d8:	e002      	b.n	80235e0 <lv_cubic_bezier+0x1c0>
        if(LV_ABS(xs - x) <= 1) goto found;
 80235da:	bf00      	nop
 80235dc:	e000      	b.n	80235e0 <lv_cubic_bezier+0x1c0>
        if(t == tl) break;
 80235de:	bf00      	nop
    /*Return y at t*/
#if CUBIC_PRECISION_BITS != LV_BEZIER_VAL_SHIFT
    return do_cubic_bezier(t, ay, by, cy) >> (CUBIC_PRECISION_BITS - LV_BEZIER_VAL_SHIFT);
#else
    return do_cubic_bezier(t, ay, by, cy);
 80235e0:	6a3b      	ldr	r3, [r7, #32]
 80235e2:	69fa      	ldr	r2, [r7, #28]
 80235e4:	69b9      	ldr	r1, [r7, #24]
 80235e6:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 80235e8:	f7ff fef4 	bl	80233d4 <do_cubic_bezier>
 80235ec:	4603      	mov	r3, r0
#endif
}
 80235ee:	4618      	mov	r0, r3
 80235f0:	3740      	adds	r7, #64	@ 0x40
 80235f2:	46bd      	mov	sp, r7
 80235f4:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}

080235f8 <lv_map>:

    return result;
}

int32_t lv_map(int32_t x, int32_t min_in, int32_t max_in, int32_t min_out, int32_t max_out)
{
 80235f8:	b480      	push	{r7}
 80235fa:	b087      	sub	sp, #28
 80235fc:	af00      	add	r7, sp, #0
 80235fe:	60f8      	str	r0, [r7, #12]
 8023600:	60b9      	str	r1, [r7, #8]
 8023602:	607a      	str	r2, [r7, #4]
 8023604:	603b      	str	r3, [r7, #0]
    if(max_in >= min_in && x >= max_in) return max_out;
 8023606:	687a      	ldr	r2, [r7, #4]
 8023608:	68bb      	ldr	r3, [r7, #8]
 802360a:	429a      	cmp	r2, r3
 802360c:	db05      	blt.n	802361a <lv_map+0x22>
 802360e:	68fa      	ldr	r2, [r7, #12]
 8023610:	687b      	ldr	r3, [r7, #4]
 8023612:	429a      	cmp	r2, r3
 8023614:	db01      	blt.n	802361a <lv_map+0x22>
 8023616:	6a3b      	ldr	r3, [r7, #32]
 8023618:	e030      	b.n	802367c <lv_map+0x84>
    if(max_in >= min_in && x <= min_in) return min_out;
 802361a:	687a      	ldr	r2, [r7, #4]
 802361c:	68bb      	ldr	r3, [r7, #8]
 802361e:	429a      	cmp	r2, r3
 8023620:	db05      	blt.n	802362e <lv_map+0x36>
 8023622:	68fa      	ldr	r2, [r7, #12]
 8023624:	68bb      	ldr	r3, [r7, #8]
 8023626:	429a      	cmp	r2, r3
 8023628:	dc01      	bgt.n	802362e <lv_map+0x36>
 802362a:	683b      	ldr	r3, [r7, #0]
 802362c:	e026      	b.n	802367c <lv_map+0x84>

    if(max_in <= min_in && x <= max_in) return max_out;
 802362e:	687a      	ldr	r2, [r7, #4]
 8023630:	68bb      	ldr	r3, [r7, #8]
 8023632:	429a      	cmp	r2, r3
 8023634:	dc05      	bgt.n	8023642 <lv_map+0x4a>
 8023636:	68fa      	ldr	r2, [r7, #12]
 8023638:	687b      	ldr	r3, [r7, #4]
 802363a:	429a      	cmp	r2, r3
 802363c:	dc01      	bgt.n	8023642 <lv_map+0x4a>
 802363e:	6a3b      	ldr	r3, [r7, #32]
 8023640:	e01c      	b.n	802367c <lv_map+0x84>
    if(max_in <= min_in && x >= min_in) return min_out;
 8023642:	687a      	ldr	r2, [r7, #4]
 8023644:	68bb      	ldr	r3, [r7, #8]
 8023646:	429a      	cmp	r2, r3
 8023648:	dc05      	bgt.n	8023656 <lv_map+0x5e>
 802364a:	68fa      	ldr	r2, [r7, #12]
 802364c:	68bb      	ldr	r3, [r7, #8]
 802364e:	429a      	cmp	r2, r3
 8023650:	db01      	blt.n	8023656 <lv_map+0x5e>
 8023652:	683b      	ldr	r3, [r7, #0]
 8023654:	e012      	b.n	802367c <lv_map+0x84>
     *   ((x - min_in) * delta_out) / delta in) + min_out
     * To avoid rounding error reorder the operations:
     *   (x - min_in) * (delta_out / delta_min) + min_out
     */

    int32_t delta_in = max_in - min_in;
 8023656:	687a      	ldr	r2, [r7, #4]
 8023658:	68bb      	ldr	r3, [r7, #8]
 802365a:	1ad3      	subs	r3, r2, r3
 802365c:	617b      	str	r3, [r7, #20]
    int32_t delta_out = max_out - min_out;
 802365e:	6a3a      	ldr	r2, [r7, #32]
 8023660:	683b      	ldr	r3, [r7, #0]
 8023662:	1ad3      	subs	r3, r2, r3
 8023664:	613b      	str	r3, [r7, #16]

    return ((x - min_in) * delta_out) / delta_in + min_out;
 8023666:	68fa      	ldr	r2, [r7, #12]
 8023668:	68bb      	ldr	r3, [r7, #8]
 802366a:	1ad3      	subs	r3, r2, r3
 802366c:	693a      	ldr	r2, [r7, #16]
 802366e:	fb03 f202 	mul.w	r2, r3, r2
 8023672:	697b      	ldr	r3, [r7, #20]
 8023674:	fb92 f2f3 	sdiv	r2, r2, r3
 8023678:	683b      	ldr	r3, [r7, #0]
 802367a:	4413      	add	r3, r2
}
 802367c:	4618      	mov	r0, r3
 802367e:	371c      	adds	r7, #28
 8023680:	46bd      	mov	sp, r7
 8023682:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023686:	4770      	bx	lr

08023688 <lv_rand_set_seed>:

void lv_rand_set_seed(uint32_t seed)
{
 8023688:	b480      	push	{r7}
 802368a:	b083      	sub	sp, #12
 802368c:	af00      	add	r7, sp, #0
 802368e:	6078      	str	r0, [r7, #4]
    rand_seed = seed;
 8023690:	4a04      	ldr	r2, [pc, #16]	@ (80236a4 <lv_rand_set_seed+0x1c>)
 8023692:	687b      	ldr	r3, [r7, #4]
 8023694:	6693      	str	r3, [r2, #104]	@ 0x68
}
 8023696:	bf00      	nop
 8023698:	370c      	adds	r7, #12
 802369a:	46bd      	mov	sp, r7
 802369c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80236a0:	4770      	bx	lr
 80236a2:	bf00      	nop
 80236a4:	2000009c 	.word	0x2000009c

080236a8 <lv_color_make>:
 * @param g     the green channel (0..255)
 * @param b     the blue channel (0..255)
 * @return      the color
 */
static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
{
 80236a8:	b480      	push	{r7}
 80236aa:	b085      	sub	sp, #20
 80236ac:	af00      	add	r7, sp, #0
 80236ae:	4603      	mov	r3, r0
 80236b0:	71fb      	strb	r3, [r7, #7]
 80236b2:	460b      	mov	r3, r1
 80236b4:	71bb      	strb	r3, [r7, #6]
 80236b6:	4613      	mov	r3, r2
 80236b8:	717b      	strb	r3, [r7, #5]
    lv_color_t ret;
    ret.red = r;
 80236ba:	79fb      	ldrb	r3, [r7, #7]
 80236bc:	72bb      	strb	r3, [r7, #10]
    ret.green = g;
 80236be:	79bb      	ldrb	r3, [r7, #6]
 80236c0:	727b      	strb	r3, [r7, #9]
    ret.blue = b;
 80236c2:	797b      	ldrb	r3, [r7, #5]
 80236c4:	723b      	strb	r3, [r7, #8]
    return ret;
 80236c6:	f107 030c 	add.w	r3, r7, #12
 80236ca:	f107 0208 	add.w	r2, r7, #8
 80236ce:	6812      	ldr	r2, [r2, #0]
 80236d0:	4611      	mov	r1, r2
 80236d2:	8019      	strh	r1, [r3, #0]
 80236d4:	3302      	adds	r3, #2
 80236d6:	0c12      	lsrs	r2, r2, #16
 80236d8:	701a      	strb	r2, [r3, #0]
 80236da:	2300      	movs	r3, #0
 80236dc:	7b3a      	ldrb	r2, [r7, #12]
 80236de:	f362 0307 	bfi	r3, r2, #0, #8
 80236e2:	7b7a      	ldrb	r2, [r7, #13]
 80236e4:	f362 230f 	bfi	r3, r2, #8, #8
 80236e8:	7bba      	ldrb	r2, [r7, #14]
 80236ea:	f362 4317 	bfi	r3, r2, #16, #8
}
 80236ee:	4618      	mov	r0, r3
 80236f0:	3714      	adds	r7, #20
 80236f2:	46bd      	mov	sp, r7
 80236f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80236f8:	4770      	bx	lr

080236fa <lv_color_black>:
/**
 * A helper for black color
 * @return      a black color
 */
static inline lv_color_t lv_color_black(void)
{
 80236fa:	b580      	push	{r7, lr}
 80236fc:	b082      	sub	sp, #8
 80236fe:	af00      	add	r7, sp, #0
    return lv_color_make(0x00, 0x00, 0x00);
 8023700:	2200      	movs	r2, #0
 8023702:	2100      	movs	r1, #0
 8023704:	2000      	movs	r0, #0
 8023706:	f7ff ffcf 	bl	80236a8 <lv_color_make>
 802370a:	4603      	mov	r3, r0
 802370c:	461a      	mov	r2, r3
 802370e:	713a      	strb	r2, [r7, #4]
 8023710:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8023714:	717a      	strb	r2, [r7, #5]
 8023716:	f3c3 4307 	ubfx	r3, r3, #16, #8
 802371a:	71bb      	strb	r3, [r7, #6]
 802371c:	2300      	movs	r3, #0
 802371e:	793a      	ldrb	r2, [r7, #4]
 8023720:	f362 0307 	bfi	r3, r2, #0, #8
 8023724:	797a      	ldrb	r2, [r7, #5]
 8023726:	f362 230f 	bfi	r3, r2, #8, #8
 802372a:	79ba      	ldrb	r2, [r7, #6]
 802372c:	f362 4317 	bfi	r3, r2, #16, #8
}
 8023730:	4618      	mov	r0, r3
 8023732:	3708      	adds	r7, #8
 8023734:	46bd      	mov	sp, r7
 8023736:	bd80      	pop	{r7, pc}

08023738 <lv_palette_main>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

lv_color_t lv_palette_main(lv_palette_t p)
{
 8023738:	b580      	push	{r7, lr}
 802373a:	b084      	sub	sp, #16
 802373c:	af00      	add	r7, sp, #0
 802373e:	4603      	mov	r3, r0
 8023740:	71fb      	strb	r3, [r7, #7]
        LV_COLOR_MAKE(0x00, 0x96, 0x88), LV_COLOR_MAKE(0x4C, 0xAF, 0x50), LV_COLOR_MAKE(0x8B, 0xC3, 0x4A), LV_COLOR_MAKE(0xCD, 0xDC, 0x39),
        LV_COLOR_MAKE(0xFF, 0xEB, 0x3B), LV_COLOR_MAKE(0xFF, 0xC1, 0x07), LV_COLOR_MAKE(0xFF, 0x98, 0x00), LV_COLOR_MAKE(0xFF, 0x57, 0x22),
        LV_COLOR_MAKE(0x79, 0x55, 0x48), LV_COLOR_MAKE(0x60, 0x7D, 0x8B), LV_COLOR_MAKE(0x9E, 0x9E, 0x9E)
    };

    if(p >= _LV_PALETTE_LAST) {
 8023742:	79fb      	ldrb	r3, [r7, #7]
 8023744:	2b12      	cmp	r3, #18
 8023746:	d90b      	bls.n	8023760 <lv_palette_main+0x28>
        LV_LOG_WARN("Invalid palette: %d", p);
        return lv_color_black();
 8023748:	f7ff ffd7 	bl	80236fa <lv_color_black>
 802374c:	4603      	mov	r3, r0
 802374e:	461a      	mov	r2, r3
 8023750:	733a      	strb	r2, [r7, #12]
 8023752:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8023756:	737a      	strb	r2, [r7, #13]
 8023758:	f3c3 4307 	ubfx	r3, r3, #16, #8
 802375c:	73bb      	strb	r3, [r7, #14]
 802375e:	e00b      	b.n	8023778 <lv_palette_main+0x40>
    }

    return colors[p];
 8023760:	79fa      	ldrb	r2, [r7, #7]
 8023762:	490c      	ldr	r1, [pc, #48]	@ (8023794 <lv_palette_main+0x5c>)
 8023764:	4613      	mov	r3, r2
 8023766:	005b      	lsls	r3, r3, #1
 8023768:	4413      	add	r3, r2
 802376a:	18ca      	adds	r2, r1, r3
 802376c:	f107 030c 	add.w	r3, r7, #12
 8023770:	8811      	ldrh	r1, [r2, #0]
 8023772:	7892      	ldrb	r2, [r2, #2]
 8023774:	8019      	strh	r1, [r3, #0]
 8023776:	709a      	strb	r2, [r3, #2]

}
 8023778:	2300      	movs	r3, #0
 802377a:	7b3a      	ldrb	r2, [r7, #12]
 802377c:	f362 0307 	bfi	r3, r2, #0, #8
 8023780:	7b7a      	ldrb	r2, [r7, #13]
 8023782:	f362 230f 	bfi	r3, r2, #8, #8
 8023786:	7bba      	ldrb	r2, [r7, #14]
 8023788:	f362 4317 	bfi	r3, r2, #16, #8
 802378c:	4618      	mov	r0, r3
 802378e:	3710      	adds	r7, #16
 8023790:	46bd      	mov	sp, r7
 8023792:	bd80      	pop	{r7, pc}
 8023794:	0802b230 	.word	0x0802b230

08023798 <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 8023798:	b580      	push	{r7, lr}
 802379a:	b082      	sub	sp, #8
 802379c:	af00      	add	r7, sp, #0
 802379e:	6078      	str	r0, [r7, #4]
 80237a0:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 80237a2:	683a      	ldr	r2, [r7, #0]
 80237a4:	2100      	movs	r1, #0
 80237a6:	6878      	ldr	r0, [r7, #4]
 80237a8:	f001 fb3b 	bl	8024e22 <lv_memset>
}
 80237ac:	bf00      	nop
 80237ae:	3708      	adds	r7, #8
 80237b0:	46bd      	mov	sp, r7
 80237b2:	bd80      	pop	{r7, pc}

080237b4 <lv_style_is_const>:
 * Check if a style is constant
 * @param style     pointer to a style
 * @return          true: the style is constant
 */
static inline bool lv_style_is_const(const lv_style_t * style)
{
 80237b4:	b480      	push	{r7}
 80237b6:	b083      	sub	sp, #12
 80237b8:	af00      	add	r7, sp, #0
 80237ba:	6078      	str	r0, [r7, #4]
    if(style->prop_cnt == 255) return true;
 80237bc:	687b      	ldr	r3, [r7, #4]
 80237be:	7a1b      	ldrb	r3, [r3, #8]
 80237c0:	2bff      	cmp	r3, #255	@ 0xff
 80237c2:	d101      	bne.n	80237c8 <lv_style_is_const+0x14>
 80237c4:	2301      	movs	r3, #1
 80237c6:	e000      	b.n	80237ca <lv_style_is_const+0x16>
    return false;
 80237c8:	2300      	movs	r3, #0
}
 80237ca:	4618      	mov	r0, r3
 80237cc:	370c      	adds	r7, #12
 80237ce:	46bd      	mov	sp, r7
 80237d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80237d4:	4770      	bx	lr

080237d6 <lv_style_get_prop_inlined>:
 * @note For performance reasons there are no sanity check on `style`
 * @note This function is the same as ::lv_style_get_prop but inlined. Use it only on performance critical places
 */
static inline lv_style_res_t lv_style_get_prop_inlined(const lv_style_t * style, lv_style_prop_t prop,
                                                       lv_style_value_t * value)
{
 80237d6:	b580      	push	{r7, lr}
 80237d8:	b08a      	sub	sp, #40	@ 0x28
 80237da:	af00      	add	r7, sp, #0
 80237dc:	60f8      	str	r0, [r7, #12]
 80237de:	460b      	mov	r3, r1
 80237e0:	607a      	str	r2, [r7, #4]
 80237e2:	72fb      	strb	r3, [r7, #11]
    if(lv_style_is_const(style)) {
 80237e4:	68f8      	ldr	r0, [r7, #12]
 80237e6:	f7ff ffe5 	bl	80237b4 <lv_style_is_const>
 80237ea:	4603      	mov	r3, r0
 80237ec:	2b00      	cmp	r3, #0
 80237ee:	d022      	beq.n	8023836 <lv_style_get_prop_inlined+0x60>
        lv_style_const_prop_t * props = (lv_style_const_prop_t *)style->values_and_props;
 80237f0:	68fb      	ldr	r3, [r7, #12]
 80237f2:	681b      	ldr	r3, [r3, #0]
 80237f4:	617b      	str	r3, [r7, #20]
        uint32_t i;
        for(i = 0; props[i].prop_ptr; i++) {
 80237f6:	2300      	movs	r3, #0
 80237f8:	627b      	str	r3, [r7, #36]	@ 0x24
 80237fa:	e014      	b.n	8023826 <lv_style_get_prop_inlined+0x50>
            if(*props[i].prop_ptr == prop) {
 80237fc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80237fe:	00db      	lsls	r3, r3, #3
 8023800:	697a      	ldr	r2, [r7, #20]
 8023802:	4413      	add	r3, r2
 8023804:	681b      	ldr	r3, [r3, #0]
 8023806:	781b      	ldrb	r3, [r3, #0]
 8023808:	7afa      	ldrb	r2, [r7, #11]
 802380a:	429a      	cmp	r2, r3
 802380c:	d108      	bne.n	8023820 <lv_style_get_prop_inlined+0x4a>
                *value = props[i].value;
 802380e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023810:	00db      	lsls	r3, r3, #3
 8023812:	697a      	ldr	r2, [r7, #20]
 8023814:	441a      	add	r2, r3
 8023816:	687b      	ldr	r3, [r7, #4]
 8023818:	6852      	ldr	r2, [r2, #4]
 802381a:	601a      	str	r2, [r3, #0]
                return LV_STYLE_RES_FOUND;
 802381c:	2301      	movs	r3, #1
 802381e:	e031      	b.n	8023884 <lv_style_get_prop_inlined+0xae>
        for(i = 0; props[i].prop_ptr; i++) {
 8023820:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023822:	3301      	adds	r3, #1
 8023824:	627b      	str	r3, [r7, #36]	@ 0x24
 8023826:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023828:	00db      	lsls	r3, r3, #3
 802382a:	697a      	ldr	r2, [r7, #20]
 802382c:	4413      	add	r3, r2
 802382e:	681b      	ldr	r3, [r3, #0]
 8023830:	2b00      	cmp	r3, #0
 8023832:	d1e3      	bne.n	80237fc <lv_style_get_prop_inlined+0x26>
 8023834:	e025      	b.n	8023882 <lv_style_get_prop_inlined+0xac>
            }
        }
    }
    else {
        lv_style_prop_t * props = (lv_style_prop_t *)style->values_and_props + style->prop_cnt * sizeof(lv_style_value_t);
 8023836:	68fb      	ldr	r3, [r7, #12]
 8023838:	681a      	ldr	r2, [r3, #0]
 802383a:	68fb      	ldr	r3, [r7, #12]
 802383c:	7a1b      	ldrb	r3, [r3, #8]
 802383e:	009b      	lsls	r3, r3, #2
 8023840:	4413      	add	r3, r2
 8023842:	61fb      	str	r3, [r7, #28]
        uint32_t i;
        for(i = 0; i < style->prop_cnt; i++) {
 8023844:	2300      	movs	r3, #0
 8023846:	623b      	str	r3, [r7, #32]
 8023848:	e015      	b.n	8023876 <lv_style_get_prop_inlined+0xa0>
            if(props[i] == prop) {
 802384a:	69fa      	ldr	r2, [r7, #28]
 802384c:	6a3b      	ldr	r3, [r7, #32]
 802384e:	4413      	add	r3, r2
 8023850:	781b      	ldrb	r3, [r3, #0]
 8023852:	7afa      	ldrb	r2, [r7, #11]
 8023854:	429a      	cmp	r2, r3
 8023856:	d10b      	bne.n	8023870 <lv_style_get_prop_inlined+0x9a>
                lv_style_value_t * values = (lv_style_value_t *)style->values_and_props;
 8023858:	68fb      	ldr	r3, [r7, #12]
 802385a:	681b      	ldr	r3, [r3, #0]
 802385c:	61bb      	str	r3, [r7, #24]
                *value = values[i];
 802385e:	6a3b      	ldr	r3, [r7, #32]
 8023860:	009b      	lsls	r3, r3, #2
 8023862:	69ba      	ldr	r2, [r7, #24]
 8023864:	441a      	add	r2, r3
 8023866:	687b      	ldr	r3, [r7, #4]
 8023868:	6812      	ldr	r2, [r2, #0]
 802386a:	601a      	str	r2, [r3, #0]
                return LV_STYLE_RES_FOUND;
 802386c:	2301      	movs	r3, #1
 802386e:	e009      	b.n	8023884 <lv_style_get_prop_inlined+0xae>
        for(i = 0; i < style->prop_cnt; i++) {
 8023870:	6a3b      	ldr	r3, [r7, #32]
 8023872:	3301      	adds	r3, #1
 8023874:	623b      	str	r3, [r7, #32]
 8023876:	68fb      	ldr	r3, [r7, #12]
 8023878:	7a1b      	ldrb	r3, [r3, #8]
 802387a:	461a      	mov	r2, r3
 802387c:	6a3b      	ldr	r3, [r7, #32]
 802387e:	4293      	cmp	r3, r2
 8023880:	d3e3      	bcc.n	802384a <lv_style_get_prop_inlined+0x74>
            }
        }
    }
    return LV_STYLE_RES_NOT_FOUND;
 8023882:	2300      	movs	r3, #0
}
 8023884:	4618      	mov	r0, r3
 8023886:	3728      	adds	r7, #40	@ 0x28
 8023888:	46bd      	mov	sp, r7
 802388a:	bd80      	pop	{r7, pc}

0802388c <_lv_style_get_prop_group>:
 * It allows early skipping the style if the property is not exists in the style at all.
 * @param prop a style property
 * @return the group [0..30] 30 means all the custom properties with index > 120
 */
static inline uint32_t _lv_style_get_prop_group(lv_style_prop_t prop)
{
 802388c:	b480      	push	{r7}
 802388e:	b085      	sub	sp, #20
 8023890:	af00      	add	r7, sp, #0
 8023892:	4603      	mov	r3, r0
 8023894:	71fb      	strb	r3, [r7, #7]
    uint32_t group = prop >> 2;
 8023896:	79fb      	ldrb	r3, [r7, #7]
 8023898:	089b      	lsrs	r3, r3, #2
 802389a:	b2db      	uxtb	r3, r3
 802389c:	60fb      	str	r3, [r7, #12]
    if(group > 30) group = 31;    /*The MSB marks all the custom properties*/
 802389e:	68fb      	ldr	r3, [r7, #12]
 80238a0:	2b1e      	cmp	r3, #30
 80238a2:	d901      	bls.n	80238a8 <_lv_style_get_prop_group+0x1c>
 80238a4:	231f      	movs	r3, #31
 80238a6:	60fb      	str	r3, [r7, #12]
    return group;
 80238a8:	68fb      	ldr	r3, [r7, #12]

}
 80238aa:	4618      	mov	r0, r3
 80238ac:	3714      	adds	r7, #20
 80238ae:	46bd      	mov	sp, r7
 80238b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80238b4:	4770      	bx	lr

080238b6 <lv_style_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_style_init(lv_style_t * style)
{
 80238b6:	b580      	push	{r7, lr}
 80238b8:	b082      	sub	sp, #8
 80238ba:	af00      	add	r7, sp, #0
 80238bc:	6078      	str	r0, [r7, #4]
    if(style->sentinel == LV_STYLE_SENTINEL_VALUE && style->prop_cnt > 1) {
        LV_LOG_WARN("Style might be already inited. (Potential memory leak)");
    }
#endif

    lv_memzero(style, sizeof(lv_style_t));
 80238be:	210c      	movs	r1, #12
 80238c0:	6878      	ldr	r0, [r7, #4]
 80238c2:	f7ff ff69 	bl	8023798 <lv_memzero>
#if LV_USE_ASSERT_STYLE
    style->sentinel = LV_STYLE_SENTINEL_VALUE;
#endif
}
 80238c6:	bf00      	nop
 80238c8:	3708      	adds	r7, #8
 80238ca:	46bd      	mov	sp, r7
 80238cc:	bd80      	pop	{r7, pc}

080238ce <lv_style_reset>:

void lv_style_reset(lv_style_t * style)
{
 80238ce:	b580      	push	{r7, lr}
 80238d0:	b082      	sub	sp, #8
 80238d2:	af00      	add	r7, sp, #0
 80238d4:	6078      	str	r0, [r7, #4]
    LV_ASSERT_STYLE(style);

    if(style->prop_cnt != 255) lv_free(style->values_and_props);
 80238d6:	687b      	ldr	r3, [r7, #4]
 80238d8:	7a1b      	ldrb	r3, [r3, #8]
 80238da:	2bff      	cmp	r3, #255	@ 0xff
 80238dc:	d004      	beq.n	80238e8 <lv_style_reset+0x1a>
 80238de:	687b      	ldr	r3, [r7, #4]
 80238e0:	681b      	ldr	r3, [r3, #0]
 80238e2:	4618      	mov	r0, r3
 80238e4:	f002 faa8 	bl	8025e38 <lv_free>
    lv_memzero(style, sizeof(lv_style_t));
 80238e8:	210c      	movs	r1, #12
 80238ea:	6878      	ldr	r0, [r7, #4]
 80238ec:	f7ff ff54 	bl	8023798 <lv_memzero>
#if LV_USE_ASSERT_STYLE
    style->sentinel = LV_STYLE_SENTINEL_VALUE;
#endif
}
 80238f0:	bf00      	nop
 80238f2:	3708      	adds	r7, #8
 80238f4:	46bd      	mov	sp, r7
 80238f6:	bd80      	pop	{r7, pc}

080238f8 <lv_style_remove_prop>:
{
    return last_custom_prop_id - _LV_STYLE_LAST_BUILT_IN_PROP;
}

bool lv_style_remove_prop(lv_style_t * style, lv_style_prop_t prop)
{
 80238f8:	b580      	push	{r7, lr}
 80238fa:	b08c      	sub	sp, #48	@ 0x30
 80238fc:	af00      	add	r7, sp, #0
 80238fe:	6078      	str	r0, [r7, #4]
 8023900:	460b      	mov	r3, r1
 8023902:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_STYLE(style);

    if(lv_style_is_const(style)) {
 8023904:	6878      	ldr	r0, [r7, #4]
 8023906:	f7ff ff55 	bl	80237b4 <lv_style_is_const>
 802390a:	4603      	mov	r3, r0
 802390c:	2b00      	cmp	r3, #0
 802390e:	d001      	beq.n	8023914 <lv_style_remove_prop+0x1c>
        LV_LOG_ERROR("Cannot remove prop from const style");
        return false;
 8023910:	2300      	movs	r3, #0
 8023912:	e077      	b.n	8023a04 <lv_style_remove_prop+0x10c>
    }

    if(style->prop_cnt == 0)  return false;
 8023914:	687b      	ldr	r3, [r7, #4]
 8023916:	7a1b      	ldrb	r3, [r3, #8]
 8023918:	2b00      	cmp	r3, #0
 802391a:	d101      	bne.n	8023920 <lv_style_remove_prop+0x28>
 802391c:	2300      	movs	r3, #0
 802391e:	e071      	b.n	8023a04 <lv_style_remove_prop+0x10c>

    uint8_t * tmp = (lv_style_prop_t *)style->values_and_props + style->prop_cnt * sizeof(lv_style_value_t);
 8023920:	687b      	ldr	r3, [r7, #4]
 8023922:	681a      	ldr	r2, [r3, #0]
 8023924:	687b      	ldr	r3, [r7, #4]
 8023926:	7a1b      	ldrb	r3, [r3, #8]
 8023928:	009b      	lsls	r3, r3, #2
 802392a:	4413      	add	r3, r2
 802392c:	627b      	str	r3, [r7, #36]	@ 0x24
    uint8_t * old_props = (uint8_t *)tmp;
 802392e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023930:	623b      	str	r3, [r7, #32]
    uint32_t i;
    for(i = 0; i < style->prop_cnt; i++) {
 8023932:	2300      	movs	r3, #0
 8023934:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8023936:	e05e      	b.n	80239f6 <lv_style_remove_prop+0xfe>
        if(old_props[i] == prop) {
 8023938:	6a3a      	ldr	r2, [r7, #32]
 802393a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 802393c:	4413      	add	r3, r2
 802393e:	781b      	ldrb	r3, [r3, #0]
 8023940:	78fa      	ldrb	r2, [r7, #3]
 8023942:	429a      	cmp	r2, r3
 8023944:	d154      	bne.n	80239f0 <lv_style_remove_prop+0xf8>
            lv_style_value_t * old_values = (lv_style_value_t *)style->values_and_props;
 8023946:	687b      	ldr	r3, [r7, #4]
 8023948:	681b      	ldr	r3, [r3, #0]
 802394a:	61fb      	str	r3, [r7, #28]

            size_t size = (style->prop_cnt - 1) * (sizeof(lv_style_value_t) + sizeof(lv_style_prop_t));
 802394c:	687b      	ldr	r3, [r7, #4]
 802394e:	7a1b      	ldrb	r3, [r3, #8]
 8023950:	3b01      	subs	r3, #1
 8023952:	461a      	mov	r2, r3
 8023954:	4613      	mov	r3, r2
 8023956:	009b      	lsls	r3, r3, #2
 8023958:	4413      	add	r3, r2
 802395a:	61bb      	str	r3, [r7, #24]
            uint8_t * new_values_and_props = lv_malloc(size);
 802395c:	69b8      	ldr	r0, [r7, #24]
 802395e:	f002 fa33 	bl	8025dc8 <lv_malloc>
 8023962:	6178      	str	r0, [r7, #20]
            if(new_values_and_props == NULL) return false;
 8023964:	697b      	ldr	r3, [r7, #20]
 8023966:	2b00      	cmp	r3, #0
 8023968:	d101      	bne.n	802396e <lv_style_remove_prop+0x76>
 802396a:	2300      	movs	r3, #0
 802396c:	e04a      	b.n	8023a04 <lv_style_remove_prop+0x10c>
            style->values_and_props = new_values_and_props;
 802396e:	687b      	ldr	r3, [r7, #4]
 8023970:	697a      	ldr	r2, [r7, #20]
 8023972:	601a      	str	r2, [r3, #0]
            style->prop_cnt--;
 8023974:	687b      	ldr	r3, [r7, #4]
 8023976:	7a1b      	ldrb	r3, [r3, #8]
 8023978:	3b01      	subs	r3, #1
 802397a:	b2da      	uxtb	r2, r3
 802397c:	687b      	ldr	r3, [r7, #4]
 802397e:	721a      	strb	r2, [r3, #8]

            tmp = new_values_and_props + style->prop_cnt * sizeof(lv_style_value_t);
 8023980:	687b      	ldr	r3, [r7, #4]
 8023982:	7a1b      	ldrb	r3, [r3, #8]
 8023984:	009b      	lsls	r3, r3, #2
 8023986:	697a      	ldr	r2, [r7, #20]
 8023988:	4413      	add	r3, r2
 802398a:	627b      	str	r3, [r7, #36]	@ 0x24
            uint8_t * new_props = (uint8_t *)tmp;
 802398c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802398e:	613b      	str	r3, [r7, #16]
            lv_style_value_t * new_values = (lv_style_value_t *)new_values_and_props;
 8023990:	697b      	ldr	r3, [r7, #20]
 8023992:	60fb      	str	r3, [r7, #12]

            uint32_t j;
            for(i = j = 0; j <= style->prop_cnt;
 8023994:	2300      	movs	r3, #0
 8023996:	62bb      	str	r3, [r7, #40]	@ 0x28
 8023998:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 802399a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 802399c:	e01d      	b.n	80239da <lv_style_remove_prop+0xe2>
                j++) { /*<=: because prop_cnt already reduced but all the old props. needs to be checked.*/
                if(old_props[j] != prop) {
 802399e:	6a3a      	ldr	r2, [r7, #32]
 80239a0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80239a2:	4413      	add	r3, r2
 80239a4:	781b      	ldrb	r3, [r3, #0]
 80239a6:	78fa      	ldrb	r2, [r7, #3]
 80239a8:	429a      	cmp	r2, r3
 80239aa:	d013      	beq.n	80239d4 <lv_style_remove_prop+0xdc>
                    new_values[i] = old_values[j];
 80239ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80239ae:	009b      	lsls	r3, r3, #2
 80239b0:	69fa      	ldr	r2, [r7, #28]
 80239b2:	441a      	add	r2, r3
 80239b4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80239b6:	009b      	lsls	r3, r3, #2
 80239b8:	68f9      	ldr	r1, [r7, #12]
 80239ba:	440b      	add	r3, r1
 80239bc:	6812      	ldr	r2, [r2, #0]
 80239be:	601a      	str	r2, [r3, #0]
                    new_props[i++] = old_props[j];
 80239c0:	6a3a      	ldr	r2, [r7, #32]
 80239c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80239c4:	441a      	add	r2, r3
 80239c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80239c8:	1c59      	adds	r1, r3, #1
 80239ca:	62f9      	str	r1, [r7, #44]	@ 0x2c
 80239cc:	6939      	ldr	r1, [r7, #16]
 80239ce:	440b      	add	r3, r1
 80239d0:	7812      	ldrb	r2, [r2, #0]
 80239d2:	701a      	strb	r2, [r3, #0]
                j++) { /*<=: because prop_cnt already reduced but all the old props. needs to be checked.*/
 80239d4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80239d6:	3301      	adds	r3, #1
 80239d8:	62bb      	str	r3, [r7, #40]	@ 0x28
            for(i = j = 0; j <= style->prop_cnt;
 80239da:	687b      	ldr	r3, [r7, #4]
 80239dc:	7a1b      	ldrb	r3, [r3, #8]
 80239de:	461a      	mov	r2, r3
 80239e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80239e2:	4293      	cmp	r3, r2
 80239e4:	d9db      	bls.n	802399e <lv_style_remove_prop+0xa6>
                }
            }

            lv_free(old_values);
 80239e6:	69f8      	ldr	r0, [r7, #28]
 80239e8:	f002 fa26 	bl	8025e38 <lv_free>
            return true;
 80239ec:	2301      	movs	r3, #1
 80239ee:	e009      	b.n	8023a04 <lv_style_remove_prop+0x10c>
    for(i = 0; i < style->prop_cnt; i++) {
 80239f0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80239f2:	3301      	adds	r3, #1
 80239f4:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80239f6:	687b      	ldr	r3, [r7, #4]
 80239f8:	7a1b      	ldrb	r3, [r3, #8]
 80239fa:	461a      	mov	r2, r3
 80239fc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80239fe:	4293      	cmp	r3, r2
 8023a00:	d39a      	bcc.n	8023938 <lv_style_remove_prop+0x40>
        }
    }

    return false;
 8023a02:	2300      	movs	r3, #0
}
 8023a04:	4618      	mov	r0, r3
 8023a06:	3730      	adds	r7, #48	@ 0x30
 8023a08:	46bd      	mov	sp, r7
 8023a0a:	bd80      	pop	{r7, pc}

08023a0c <lv_style_set_prop>:

void lv_style_set_prop(lv_style_t * style, lv_style_prop_t prop, lv_style_value_t value)
{
 8023a0c:	b580      	push	{r7, lr}
 8023a0e:	b08c      	sub	sp, #48	@ 0x30
 8023a10:	af00      	add	r7, sp, #0
 8023a12:	60f8      	str	r0, [r7, #12]
 8023a14:	460b      	mov	r3, r1
 8023a16:	607a      	str	r2, [r7, #4]
 8023a18:	72fb      	strb	r3, [r7, #11]
    LV_ASSERT_STYLE(style);

    if(lv_style_is_const(style)) {
 8023a1a:	68f8      	ldr	r0, [r7, #12]
 8023a1c:	f7ff feca 	bl	80237b4 <lv_style_is_const>
 8023a20:	4603      	mov	r3, r0
 8023a22:	2b00      	cmp	r3, #0
 8023a24:	f040 8089 	bne.w	8023b3a <lv_style_set_prop+0x12e>
        LV_LOG_ERROR("Cannot set property of constant style");
        return;
    }

    LV_ASSERT(prop != LV_STYLE_PROP_INV);
 8023a28:	7afb      	ldrb	r3, [r7, #11]
 8023a2a:	2b00      	cmp	r3, #0
 8023a2c:	d101      	bne.n	8023a32 <lv_style_set_prop+0x26>
 8023a2e:	bf00      	nop
 8023a30:	e7fd      	b.n	8023a2e <lv_style_set_prop+0x22>

    lv_style_prop_t * props;
    int32_t i;

    if(style->values_and_props) {
 8023a32:	68fb      	ldr	r3, [r7, #12]
 8023a34:	681b      	ldr	r3, [r3, #0]
 8023a36:	2b00      	cmp	r3, #0
 8023a38:	d022      	beq.n	8023a80 <lv_style_set_prop+0x74>
        props = (lv_style_prop_t *)style->values_and_props + style->prop_cnt * sizeof(lv_style_value_t);
 8023a3a:	68fb      	ldr	r3, [r7, #12]
 8023a3c:	681a      	ldr	r2, [r3, #0]
 8023a3e:	68fb      	ldr	r3, [r7, #12]
 8023a40:	7a1b      	ldrb	r3, [r3, #8]
 8023a42:	009b      	lsls	r3, r3, #2
 8023a44:	4413      	add	r3, r2
 8023a46:	62bb      	str	r3, [r7, #40]	@ 0x28
        for(i = style->prop_cnt - 1; i >= 0; i--) {
 8023a48:	68fb      	ldr	r3, [r7, #12]
 8023a4a:	7a1b      	ldrb	r3, [r3, #8]
 8023a4c:	3b01      	subs	r3, #1
 8023a4e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8023a50:	e013      	b.n	8023a7a <lv_style_set_prop+0x6e>
            if(props[i] == prop) {
 8023a52:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023a54:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8023a56:	4413      	add	r3, r2
 8023a58:	781b      	ldrb	r3, [r3, #0]
 8023a5a:	7afa      	ldrb	r2, [r7, #11]
 8023a5c:	429a      	cmp	r2, r3
 8023a5e:	d109      	bne.n	8023a74 <lv_style_set_prop+0x68>
                lv_style_value_t * values = (lv_style_value_t *)style->values_and_props;
 8023a60:	68fb      	ldr	r3, [r7, #12]
 8023a62:	681b      	ldr	r3, [r3, #0]
 8023a64:	627b      	str	r3, [r7, #36]	@ 0x24
                values[i] = value;
 8023a66:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023a68:	009b      	lsls	r3, r3, #2
 8023a6a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8023a6c:	4413      	add	r3, r2
 8023a6e:	687a      	ldr	r2, [r7, #4]
 8023a70:	601a      	str	r2, [r3, #0]
                return;
 8023a72:	e065      	b.n	8023b40 <lv_style_set_prop+0x134>
        for(i = style->prop_cnt - 1; i >= 0; i--) {
 8023a74:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023a76:	3b01      	subs	r3, #1
 8023a78:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8023a7a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023a7c:	2b00      	cmp	r3, #0
 8023a7e:	dae8      	bge.n	8023a52 <lv_style_set_prop+0x46>
            }
        }
    }

    size_t size = (style->prop_cnt + 1) * (sizeof(lv_style_value_t) + sizeof(lv_style_prop_t));
 8023a80:	68fb      	ldr	r3, [r7, #12]
 8023a82:	7a1b      	ldrb	r3, [r3, #8]
 8023a84:	3301      	adds	r3, #1
 8023a86:	461a      	mov	r2, r3
 8023a88:	4613      	mov	r3, r2
 8023a8a:	009b      	lsls	r3, r3, #2
 8023a8c:	4413      	add	r3, r2
 8023a8e:	623b      	str	r3, [r7, #32]
    uint8_t * values_and_props = lv_realloc(style->values_and_props, size);
 8023a90:	68fb      	ldr	r3, [r7, #12]
 8023a92:	681b      	ldr	r3, [r3, #0]
 8023a94:	6a39      	ldr	r1, [r7, #32]
 8023a96:	4618      	mov	r0, r3
 8023a98:	f002 f9e6 	bl	8025e68 <lv_realloc>
 8023a9c:	61f8      	str	r0, [r7, #28]
    if(values_and_props == NULL) return;
 8023a9e:	69fb      	ldr	r3, [r7, #28]
 8023aa0:	2b00      	cmp	r3, #0
 8023aa2:	d04c      	beq.n	8023b3e <lv_style_set_prop+0x132>
    style->values_and_props = values_and_props;
 8023aa4:	68fb      	ldr	r3, [r7, #12]
 8023aa6:	69fa      	ldr	r2, [r7, #28]
 8023aa8:	601a      	str	r2, [r3, #0]

    props = values_and_props + style->prop_cnt * sizeof(lv_style_value_t);
 8023aaa:	68fb      	ldr	r3, [r7, #12]
 8023aac:	7a1b      	ldrb	r3, [r3, #8]
 8023aae:	009b      	lsls	r3, r3, #2
 8023ab0:	69fa      	ldr	r2, [r7, #28]
 8023ab2:	4413      	add	r3, r2
 8023ab4:	62bb      	str	r3, [r7, #40]	@ 0x28
    /*Shift all props to make place for the value before them*/
    for(i = style->prop_cnt - 1; i >= 0; i--) {
 8023ab6:	68fb      	ldr	r3, [r7, #12]
 8023ab8:	7a1b      	ldrb	r3, [r3, #8]
 8023aba:	3b01      	subs	r3, #1
 8023abc:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8023abe:	e00b      	b.n	8023ad8 <lv_style_set_prop+0xcc>
        props[i + sizeof(lv_style_value_t) / sizeof(lv_style_prop_t)] = props[i];
 8023ac0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023ac2:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8023ac4:	441a      	add	r2, r3
 8023ac6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023ac8:	3304      	adds	r3, #4
 8023aca:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8023acc:	440b      	add	r3, r1
 8023ace:	7812      	ldrb	r2, [r2, #0]
 8023ad0:	701a      	strb	r2, [r3, #0]
    for(i = style->prop_cnt - 1; i >= 0; i--) {
 8023ad2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023ad4:	3b01      	subs	r3, #1
 8023ad6:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8023ad8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023ada:	2b00      	cmp	r3, #0
 8023adc:	daf0      	bge.n	8023ac0 <lv_style_set_prop+0xb4>
    }
    style->prop_cnt++;
 8023ade:	68fb      	ldr	r3, [r7, #12]
 8023ae0:	7a1b      	ldrb	r3, [r3, #8]
 8023ae2:	3301      	adds	r3, #1
 8023ae4:	b2da      	uxtb	r2, r3
 8023ae6:	68fb      	ldr	r3, [r7, #12]
 8023ae8:	721a      	strb	r2, [r3, #8]

    /*Go to the new position with the props*/
    props = values_and_props + style->prop_cnt * sizeof(lv_style_value_t);
 8023aea:	68fb      	ldr	r3, [r7, #12]
 8023aec:	7a1b      	ldrb	r3, [r3, #8]
 8023aee:	009b      	lsls	r3, r3, #2
 8023af0:	69fa      	ldr	r2, [r7, #28]
 8023af2:	4413      	add	r3, r2
 8023af4:	62bb      	str	r3, [r7, #40]	@ 0x28
    lv_style_value_t * values = (lv_style_value_t *)values_and_props;
 8023af6:	69fb      	ldr	r3, [r7, #28]
 8023af8:	61bb      	str	r3, [r7, #24]

    /*Set the new property and value*/
    props[style->prop_cnt - 1] = prop;
 8023afa:	68fb      	ldr	r3, [r7, #12]
 8023afc:	7a1b      	ldrb	r3, [r3, #8]
 8023afe:	3b01      	subs	r3, #1
 8023b00:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8023b02:	4413      	add	r3, r2
 8023b04:	7afa      	ldrb	r2, [r7, #11]
 8023b06:	701a      	strb	r2, [r3, #0]
    values[style->prop_cnt - 1] = value;
 8023b08:	68fb      	ldr	r3, [r7, #12]
 8023b0a:	7a1b      	ldrb	r3, [r3, #8]
 8023b0c:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8023b10:	3b01      	subs	r3, #1
 8023b12:	009b      	lsls	r3, r3, #2
 8023b14:	69ba      	ldr	r2, [r7, #24]
 8023b16:	4413      	add	r3, r2
 8023b18:	687a      	ldr	r2, [r7, #4]
 8023b1a:	601a      	str	r2, [r3, #0]

    uint32_t group = _lv_style_get_prop_group(prop);
 8023b1c:	7afb      	ldrb	r3, [r7, #11]
 8023b1e:	4618      	mov	r0, r3
 8023b20:	f7ff feb4 	bl	802388c <_lv_style_get_prop_group>
 8023b24:	6178      	str	r0, [r7, #20]
    style->has_group |= (uint32_t)1 << group;
 8023b26:	68fb      	ldr	r3, [r7, #12]
 8023b28:	685a      	ldr	r2, [r3, #4]
 8023b2a:	2101      	movs	r1, #1
 8023b2c:	697b      	ldr	r3, [r7, #20]
 8023b2e:	fa01 f303 	lsl.w	r3, r1, r3
 8023b32:	431a      	orrs	r2, r3
 8023b34:	68fb      	ldr	r3, [r7, #12]
 8023b36:	605a      	str	r2, [r3, #4]
 8023b38:	e002      	b.n	8023b40 <lv_style_set_prop+0x134>
        return;
 8023b3a:	bf00      	nop
 8023b3c:	e000      	b.n	8023b40 <lv_style_set_prop+0x134>
    if(values_and_props == NULL) return;
 8023b3e:	bf00      	nop
}
 8023b40:	3730      	adds	r7, #48	@ 0x30
 8023b42:	46bd      	mov	sp, r7
 8023b44:	bd80      	pop	{r7, pc}

08023b46 <lv_style_get_prop>:

lv_style_res_t lv_style_get_prop(const lv_style_t * style, lv_style_prop_t prop, lv_style_value_t * value)
{
 8023b46:	b580      	push	{r7, lr}
 8023b48:	b084      	sub	sp, #16
 8023b4a:	af00      	add	r7, sp, #0
 8023b4c:	60f8      	str	r0, [r7, #12]
 8023b4e:	460b      	mov	r3, r1
 8023b50:	607a      	str	r2, [r7, #4]
 8023b52:	72fb      	strb	r3, [r7, #11]
    return lv_style_get_prop_inlined(style, prop, value);
 8023b54:	7afb      	ldrb	r3, [r7, #11]
 8023b56:	687a      	ldr	r2, [r7, #4]
 8023b58:	4619      	mov	r1, r3
 8023b5a:	68f8      	ldr	r0, [r7, #12]
 8023b5c:	f7ff fe3b 	bl	80237d6 <lv_style_get_prop_inlined>
 8023b60:	4603      	mov	r3, r0
}
 8023b62:	4618      	mov	r0, r3
 8023b64:	3710      	adds	r7, #16
 8023b66:	46bd      	mov	sp, r7
 8023b68:	bd80      	pop	{r7, pc}

08023b6a <lv_style_is_empty>:
            };
    }
}

bool lv_style_is_empty(const lv_style_t * style)
{
 8023b6a:	b480      	push	{r7}
 8023b6c:	b083      	sub	sp, #12
 8023b6e:	af00      	add	r7, sp, #0
 8023b70:	6078      	str	r0, [r7, #4]
    LV_ASSERT_STYLE(style);

    return style->prop_cnt == 0;
 8023b72:	687b      	ldr	r3, [r7, #4]
 8023b74:	7a1b      	ldrb	r3, [r3, #8]
 8023b76:	2b00      	cmp	r3, #0
 8023b78:	bf0c      	ite	eq
 8023b7a:	2301      	moveq	r3, #1
 8023b7c:	2300      	movne	r3, #0
 8023b7e:	b2db      	uxtb	r3, r3
}
 8023b80:	4618      	mov	r0, r3
 8023b82:	370c      	adds	r7, #12
 8023b84:	46bd      	mov	sp, r7
 8023b86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023b8a:	4770      	bx	lr

08023b8c <_lv_style_prop_lookup_flags>:

uint8_t _lv_style_prop_lookup_flags(lv_style_prop_t prop)
{
 8023b8c:	b480      	push	{r7}
 8023b8e:	b083      	sub	sp, #12
 8023b90:	af00      	add	r7, sp, #0
 8023b92:	4603      	mov	r3, r0
 8023b94:	71fb      	strb	r3, [r7, #7]
    if(prop == LV_STYLE_PROP_ANY) return LV_STYLE_PROP_FLAG_ALL; /*Any prop can have any flags*/
 8023b96:	79fb      	ldrb	r3, [r7, #7]
 8023b98:	2bff      	cmp	r3, #255	@ 0xff
 8023b9a:	d101      	bne.n	8023ba0 <_lv_style_prop_lookup_flags+0x14>
 8023b9c:	233f      	movs	r3, #63	@ 0x3f
 8023b9e:	e01e      	b.n	8023bde <_lv_style_prop_lookup_flags+0x52>
    if(prop == LV_STYLE_PROP_INV) return 0;
 8023ba0:	79fb      	ldrb	r3, [r7, #7]
 8023ba2:	2b00      	cmp	r3, #0
 8023ba4:	d101      	bne.n	8023baa <_lv_style_prop_lookup_flags+0x1e>
 8023ba6:	2300      	movs	r3, #0
 8023ba8:	e019      	b.n	8023bde <_lv_style_prop_lookup_flags+0x52>

    if(prop < _LV_STYLE_NUM_BUILT_IN_PROPS)
 8023baa:	79fb      	ldrb	r3, [r7, #7]
 8023bac:	2b8c      	cmp	r3, #140	@ 0x8c
 8023bae:	d803      	bhi.n	8023bb8 <_lv_style_prop_lookup_flags+0x2c>
        return _lv_style_builtin_prop_flag_lookup_table[prop];
 8023bb0:	79fb      	ldrb	r3, [r7, #7]
 8023bb2:	4a0e      	ldr	r2, [pc, #56]	@ (8023bec <_lv_style_prop_lookup_flags+0x60>)
 8023bb4:	5cd3      	ldrb	r3, [r2, r3]
 8023bb6:	e012      	b.n	8023bde <_lv_style_prop_lookup_flags+0x52>
    prop -= _LV_STYLE_NUM_BUILT_IN_PROPS;
 8023bb8:	79fb      	ldrb	r3, [r7, #7]
 8023bba:	3373      	adds	r3, #115	@ 0x73
 8023bbc:	71fb      	strb	r3, [r7, #7]
    if(_lv_style_custom_prop_flag_lookup_table != NULL && prop < _lv_style_custom_prop_flag_lookup_table_size)
 8023bbe:	4b0c      	ldr	r3, [pc, #48]	@ (8023bf0 <_lv_style_prop_lookup_flags+0x64>)
 8023bc0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8023bc2:	2b00      	cmp	r3, #0
 8023bc4:	d00a      	beq.n	8023bdc <_lv_style_prop_lookup_flags+0x50>
 8023bc6:	79fa      	ldrb	r2, [r7, #7]
 8023bc8:	4b09      	ldr	r3, [pc, #36]	@ (8023bf0 <_lv_style_prop_lookup_flags+0x64>)
 8023bca:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8023bcc:	429a      	cmp	r2, r3
 8023bce:	d205      	bcs.n	8023bdc <_lv_style_prop_lookup_flags+0x50>
        return _lv_style_custom_prop_flag_lookup_table[prop];
 8023bd0:	4b07      	ldr	r3, [pc, #28]	@ (8023bf0 <_lv_style_prop_lookup_flags+0x64>)
 8023bd2:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8023bd4:	79fb      	ldrb	r3, [r7, #7]
 8023bd6:	4413      	add	r3, r2
 8023bd8:	781b      	ldrb	r3, [r3, #0]
 8023bda:	e000      	b.n	8023bde <_lv_style_prop_lookup_flags+0x52>
    return 0;
 8023bdc:	2300      	movs	r3, #0
}
 8023bde:	4618      	mov	r0, r3
 8023be0:	370c      	adds	r7, #12
 8023be2:	46bd      	mov	sp, r7
 8023be4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023be8:	4770      	bx	lr
 8023bea:	bf00      	nop
 8023bec:	0802b26c 	.word	0x0802b26c
 8023bf0:	2000009c 	.word	0x2000009c

08023bf4 <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font      pointer to a font
 * @return the height of a font
 */
static inline int32_t lv_font_get_line_height(const lv_font_t * font)
{
 8023bf4:	b480      	push	{r7}
 8023bf6:	b083      	sub	sp, #12
 8023bf8:	af00      	add	r7, sp, #0
 8023bfa:	6078      	str	r0, [r7, #4]
    return font->line_height;
 8023bfc:	687b      	ldr	r3, [r7, #4]
 8023bfe:	68db      	ldr	r3, [r3, #12]
}
 8023c00:	4618      	mov	r0, r3
 8023c02:	370c      	adds	r7, #12
 8023c04:	46bd      	mov	sp, r7
 8023c06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023c0a:	4770      	bx	lr

08023c0c <_lv_text_is_break_char>:
 * Test if char is break char or not (a text can broken here or not)
 * @param letter a letter
 * @return false: 'letter' is not break char
 */
static inline bool _lv_text_is_break_char(uint32_t letter)
{
 8023c0c:	b480      	push	{r7}
 8023c0e:	b085      	sub	sp, #20
 8023c10:	af00      	add	r7, sp, #0
 8023c12:	6078      	str	r0, [r7, #4]
    uint8_t i;
    bool ret = false;
 8023c14:	2300      	movs	r3, #0
 8023c16:	73bb      	strb	r3, [r7, #14]

    /*Compare the letter to TXT_BREAK_CHARS*/
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
 8023c18:	2300      	movs	r3, #0
 8023c1a:	73fb      	strb	r3, [r7, #15]
 8023c1c:	e00c      	b.n	8023c38 <_lv_text_is_break_char+0x2c>
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
 8023c1e:	7bfb      	ldrb	r3, [r7, #15]
 8023c20:	4a0b      	ldr	r2, [pc, #44]	@ (8023c50 <_lv_text_is_break_char+0x44>)
 8023c22:	5cd3      	ldrb	r3, [r2, r3]
 8023c24:	461a      	mov	r2, r3
 8023c26:	687b      	ldr	r3, [r7, #4]
 8023c28:	4293      	cmp	r3, r2
 8023c2a:	d102      	bne.n	8023c32 <_lv_text_is_break_char+0x26>
            ret = true; /*If match then it is break char*/
 8023c2c:	2301      	movs	r3, #1
 8023c2e:	73bb      	strb	r3, [r7, #14]
            break;
 8023c30:	e007      	b.n	8023c42 <_lv_text_is_break_char+0x36>
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
 8023c32:	7bfb      	ldrb	r3, [r7, #15]
 8023c34:	3301      	adds	r3, #1
 8023c36:	73fb      	strb	r3, [r7, #15]
 8023c38:	7bfb      	ldrb	r3, [r7, #15]
 8023c3a:	4a05      	ldr	r2, [pc, #20]	@ (8023c50 <_lv_text_is_break_char+0x44>)
 8023c3c:	5cd3      	ldrb	r3, [r2, r3]
 8023c3e:	2b00      	cmp	r3, #0
 8023c40:	d1ed      	bne.n	8023c1e <_lv_text_is_break_char+0x12>
        }
    }

    return ret;
 8023c42:	7bbb      	ldrb	r3, [r7, #14]
}
 8023c44:	4618      	mov	r0, r3
 8023c46:	3714      	adds	r7, #20
 8023c48:	46bd      	mov	sp, r7
 8023c4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023c4e:	4770      	bx	lr
 8023c50:	08027ba0 	.word	0x08027ba0

08023c54 <_lv_text_is_a_word>:
 * Test if char is break char or not (a text can broken here or not)
 * @param letter a letter
 * @return false: 'letter' is not break char
 */
static inline bool _lv_text_is_a_word(uint32_t letter)
{
 8023c54:	b480      	push	{r7}
 8023c56:	b083      	sub	sp, #12
 8023c58:	af00      	add	r7, sp, #0
 8023c5a:	6078      	str	r0, [r7, #4]
    /*Cheap check on invalid letter*/
    if(letter == 0) return false;
 8023c5c:	687b      	ldr	r3, [r7, #4]
 8023c5e:	2b00      	cmp	r3, #0
 8023c60:	d101      	bne.n	8023c66 <_lv_text_is_a_word+0x12>
 8023c62:	2300      	movs	r3, #0
 8023c64:	e056      	b.n	8023d14 <_lv_text_is_a_word+0xc0>

    /*CJK Unified Ideographs*/
    if(letter >= 0x4E00 && letter <= 0x9FFF) {
 8023c66:	687b      	ldr	r3, [r7, #4]
 8023c68:	f5b3 4f9c 	cmp.w	r3, #19968	@ 0x4e00
 8023c6c:	d305      	bcc.n	8023c7a <_lv_text_is_a_word+0x26>
 8023c6e:	687b      	ldr	r3, [r7, #4]
 8023c70:	f5b3 4f20 	cmp.w	r3, #40960	@ 0xa000
 8023c74:	d201      	bcs.n	8023c7a <_lv_text_is_a_word+0x26>
        return true;
 8023c76:	2301      	movs	r3, #1
 8023c78:	e04c      	b.n	8023d14 <_lv_text_is_a_word+0xc0>
    }

    /*Fullwidth ASCII variants*/
    if(letter >= 0xFF01 && letter <= 0xFF5E) {
 8023c7a:	687b      	ldr	r3, [r7, #4]
 8023c7c:	f5b3 4f7f 	cmp.w	r3, #65280	@ 0xff00
 8023c80:	d906      	bls.n	8023c90 <_lv_text_is_a_word+0x3c>
 8023c82:	687b      	ldr	r3, [r7, #4]
 8023c84:	f64f 725e 	movw	r2, #65374	@ 0xff5e
 8023c88:	4293      	cmp	r3, r2
 8023c8a:	d801      	bhi.n	8023c90 <_lv_text_is_a_word+0x3c>
        return true;
 8023c8c:	2301      	movs	r3, #1
 8023c8e:	e041      	b.n	8023d14 <_lv_text_is_a_word+0xc0>
    }

    /*CJK symbols and punctuation*/
    if(letter >= 0x3000 && letter <= 0x303F) {
 8023c90:	687b      	ldr	r3, [r7, #4]
 8023c92:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8023c96:	d305      	bcc.n	8023ca4 <_lv_text_is_a_word+0x50>
 8023c98:	687b      	ldr	r3, [r7, #4]
 8023c9a:	f5b3 5f41 	cmp.w	r3, #12352	@ 0x3040
 8023c9e:	d201      	bcs.n	8023ca4 <_lv_text_is_a_word+0x50>
        return true;
 8023ca0:	2301      	movs	r3, #1
 8023ca2:	e037      	b.n	8023d14 <_lv_text_is_a_word+0xc0>
    }

    /*CJK Radicals Supplement*/
    if(letter >= 0x2E80 && letter <= 0x2EFF) {
 8023ca4:	687b      	ldr	r3, [r7, #4]
 8023ca6:	f5b3 5f3a 	cmp.w	r3, #11904	@ 0x2e80
 8023caa:	d305      	bcc.n	8023cb8 <_lv_text_is_a_word+0x64>
 8023cac:	687b      	ldr	r3, [r7, #4]
 8023cae:	f5b3 5f3c 	cmp.w	r3, #12032	@ 0x2f00
 8023cb2:	d201      	bcs.n	8023cb8 <_lv_text_is_a_word+0x64>
        return true;
 8023cb4:	2301      	movs	r3, #1
 8023cb6:	e02d      	b.n	8023d14 <_lv_text_is_a_word+0xc0>
    }

    /*CJK Strokes*/
    if(letter >= 0x31C0 && letter <= 0x31EF) {
 8023cb8:	687b      	ldr	r3, [r7, #4]
 8023cba:	f5b3 5f47 	cmp.w	r3, #12736	@ 0x31c0
 8023cbe:	d306      	bcc.n	8023cce <_lv_text_is_a_word+0x7a>
 8023cc0:	687b      	ldr	r3, [r7, #4]
 8023cc2:	f243 12ef 	movw	r2, #12783	@ 0x31ef
 8023cc6:	4293      	cmp	r3, r2
 8023cc8:	d801      	bhi.n	8023cce <_lv_text_is_a_word+0x7a>
        return true;
 8023cca:	2301      	movs	r3, #1
 8023ccc:	e022      	b.n	8023d14 <_lv_text_is_a_word+0xc0>
    }

    /*Hiragana and Katakana*/
    if(letter >= 0x3040 && letter <= 0x30FF) {
 8023cce:	687b      	ldr	r3, [r7, #4]
 8023cd0:	f5b3 5f41 	cmp.w	r3, #12352	@ 0x3040
 8023cd4:	d305      	bcc.n	8023ce2 <_lv_text_is_a_word+0x8e>
 8023cd6:	687b      	ldr	r3, [r7, #4]
 8023cd8:	f5b3 5f44 	cmp.w	r3, #12544	@ 0x3100
 8023cdc:	d201      	bcs.n	8023ce2 <_lv_text_is_a_word+0x8e>
        return true;
 8023cde:	2301      	movs	r3, #1
 8023ce0:	e018      	b.n	8023d14 <_lv_text_is_a_word+0xc0>
    }

    /*Chinese Vertical Forms*/
    if(letter >= 0xFE10 && letter <= 0xFE1F) {
 8023ce2:	687b      	ldr	r3, [r7, #4]
 8023ce4:	f64f 620f 	movw	r2, #65039	@ 0xfe0f
 8023ce8:	4293      	cmp	r3, r2
 8023cea:	d906      	bls.n	8023cfa <_lv_text_is_a_word+0xa6>
 8023cec:	687b      	ldr	r3, [r7, #4]
 8023cee:	f64f 621f 	movw	r2, #65055	@ 0xfe1f
 8023cf2:	4293      	cmp	r3, r2
 8023cf4:	d801      	bhi.n	8023cfa <_lv_text_is_a_word+0xa6>
        return true;
 8023cf6:	2301      	movs	r3, #1
 8023cf8:	e00c      	b.n	8023d14 <_lv_text_is_a_word+0xc0>
    }

    /*CJK Compatibility Forms*/
    if(letter >= 0xFE30 && letter <= 0xFE4F) {
 8023cfa:	687b      	ldr	r3, [r7, #4]
 8023cfc:	f64f 622f 	movw	r2, #65071	@ 0xfe2f
 8023d00:	4293      	cmp	r3, r2
 8023d02:	d906      	bls.n	8023d12 <_lv_text_is_a_word+0xbe>
 8023d04:	687b      	ldr	r3, [r7, #4]
 8023d06:	f64f 624f 	movw	r2, #65103	@ 0xfe4f
 8023d0a:	4293      	cmp	r3, r2
 8023d0c:	d801      	bhi.n	8023d12 <_lv_text_is_a_word+0xbe>
        return true;
 8023d0e:	2301      	movs	r3, #1
 8023d10:	e000      	b.n	8023d14 <_lv_text_is_a_word+0xc0>
    }

    return false;
 8023d12:	2300      	movs	r3, #0
}
 8023d14:	4618      	mov	r0, r3
 8023d16:	370c      	adds	r7, #12
 8023d18:	46bd      	mov	sp, r7
 8023d1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023d1e:	4770      	bx	lr

08023d20 <lv_text_get_size>:
 *   GLOBAL FUNCTIONS
 **********************/

void lv_text_get_size(lv_point_t * size_res, const char * text, const lv_font_t * font, int32_t letter_space,
                      int32_t line_space, int32_t max_width, lv_text_flag_t flag)
{
 8023d20:	b580      	push	{r7, lr}
 8023d22:	b08a      	sub	sp, #40	@ 0x28
 8023d24:	af02      	add	r7, sp, #8
 8023d26:	60f8      	str	r0, [r7, #12]
 8023d28:	60b9      	str	r1, [r7, #8]
 8023d2a:	607a      	str	r2, [r7, #4]
 8023d2c:	603b      	str	r3, [r7, #0]
    size_res->x = 0;
 8023d2e:	68fb      	ldr	r3, [r7, #12]
 8023d30:	2200      	movs	r2, #0
 8023d32:	601a      	str	r2, [r3, #0]
    size_res->y = 0;
 8023d34:	68fb      	ldr	r3, [r7, #12]
 8023d36:	2200      	movs	r2, #0
 8023d38:	605a      	str	r2, [r3, #4]

    if(text == NULL) return;
 8023d3a:	68bb      	ldr	r3, [r7, #8]
 8023d3c:	2b00      	cmp	r3, #0
 8023d3e:	d07e      	beq.n	8023e3e <lv_text_get_size+0x11e>
    if(font == NULL) return;
 8023d40:	687b      	ldr	r3, [r7, #4]
 8023d42:	2b00      	cmp	r3, #0
 8023d44:	d07d      	beq.n	8023e42 <lv_text_get_size+0x122>

    if(flag & LV_TEXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 8023d46:	f897 3030 	ldrb.w	r3, [r7, #48]	@ 0x30
 8023d4a:	f003 0301 	and.w	r3, r3, #1
 8023d4e:	2b00      	cmp	r3, #0
 8023d50:	d002      	beq.n	8023d58 <lv_text_get_size+0x38>
 8023d52:	f06f 4360 	mvn.w	r3, #3758096384	@ 0xe0000000
 8023d56:	62fb      	str	r3, [r7, #44]	@ 0x2c

    uint32_t line_start     = 0;
 8023d58:	2300      	movs	r3, #0
 8023d5a:	61fb      	str	r3, [r7, #28]
    uint32_t new_line_start = 0;
 8023d5c:	2300      	movs	r3, #0
 8023d5e:	61bb      	str	r3, [r7, #24]
    uint16_t letter_height = lv_font_get_line_height(font);
 8023d60:	6878      	ldr	r0, [r7, #4]
 8023d62:	f7ff ff47 	bl	8023bf4 <lv_font_get_line_height>
 8023d66:	4603      	mov	r3, r0
 8023d68:	82fb      	strh	r3, [r7, #22]

    /*Calc. the height and longest line*/
    while(text[line_start] != '\0') {
 8023d6a:	e03a      	b.n	8023de2 <lv_text_get_size+0xc2>
        new_line_start += _lv_text_get_next_line(&text[line_start], font, letter_space, max_width, NULL, flag);
 8023d6c:	68ba      	ldr	r2, [r7, #8]
 8023d6e:	69fb      	ldr	r3, [r7, #28]
 8023d70:	18d0      	adds	r0, r2, r3
 8023d72:	f897 3030 	ldrb.w	r3, [r7, #48]	@ 0x30
 8023d76:	9301      	str	r3, [sp, #4]
 8023d78:	2300      	movs	r3, #0
 8023d7a:	9300      	str	r3, [sp, #0]
 8023d7c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023d7e:	683a      	ldr	r2, [r7, #0]
 8023d80:	6879      	ldr	r1, [r7, #4]
 8023d82:	f000 f937 	bl	8023ff4 <_lv_text_get_next_line>
 8023d86:	4602      	mov	r2, r0
 8023d88:	69bb      	ldr	r3, [r7, #24]
 8023d8a:	4413      	add	r3, r2
 8023d8c:	61bb      	str	r3, [r7, #24]

        if((unsigned long)size_res->y + (unsigned long)letter_height + (unsigned long)line_space > LV_MAX_OF(int32_t)) {
 8023d8e:	68fb      	ldr	r3, [r7, #12]
 8023d90:	685b      	ldr	r3, [r3, #4]
 8023d92:	461a      	mov	r2, r3
 8023d94:	8afb      	ldrh	r3, [r7, #22]
 8023d96:	441a      	add	r2, r3
 8023d98:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8023d9a:	4413      	add	r3, r2
 8023d9c:	2b00      	cmp	r3, #0
 8023d9e:	db52      	blt.n	8023e46 <lv_text_get_size+0x126>
            LV_LOG_WARN("integer overflow while calculating text height");
            return;
        }
        else {
            size_res->y += letter_height;
 8023da0:	68fb      	ldr	r3, [r7, #12]
 8023da2:	685a      	ldr	r2, [r3, #4]
 8023da4:	8afb      	ldrh	r3, [r7, #22]
 8023da6:	441a      	add	r2, r3
 8023da8:	68fb      	ldr	r3, [r7, #12]
 8023daa:	605a      	str	r2, [r3, #4]
            size_res->y += line_space;
 8023dac:	68fb      	ldr	r3, [r7, #12]
 8023dae:	685a      	ldr	r2, [r3, #4]
 8023db0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8023db2:	441a      	add	r2, r3
 8023db4:	68fb      	ldr	r3, [r7, #12]
 8023db6:	605a      	str	r2, [r3, #4]
        }

        /*Calculate the longest line*/
        int32_t act_line_length = lv_text_get_width(&text[line_start], new_line_start - line_start, font, letter_space);
 8023db8:	68ba      	ldr	r2, [r7, #8]
 8023dba:	69fb      	ldr	r3, [r7, #28]
 8023dbc:	18d0      	adds	r0, r2, r3
 8023dbe:	69ba      	ldr	r2, [r7, #24]
 8023dc0:	69fb      	ldr	r3, [r7, #28]
 8023dc2:	1ad1      	subs	r1, r2, r3
 8023dc4:	683b      	ldr	r3, [r7, #0]
 8023dc6:	687a      	ldr	r2, [r7, #4]
 8023dc8:	f000 f9e2 	bl	8024190 <lv_text_get_width>
 8023dcc:	6138      	str	r0, [r7, #16]

        size_res->x = LV_MAX(act_line_length, size_res->x);
 8023dce:	68fb      	ldr	r3, [r7, #12]
 8023dd0:	681a      	ldr	r2, [r3, #0]
 8023dd2:	693b      	ldr	r3, [r7, #16]
 8023dd4:	429a      	cmp	r2, r3
 8023dd6:	bfb8      	it	lt
 8023dd8:	461a      	movlt	r2, r3
 8023dda:	68fb      	ldr	r3, [r7, #12]
 8023ddc:	601a      	str	r2, [r3, #0]
        line_start  = new_line_start;
 8023dde:	69bb      	ldr	r3, [r7, #24]
 8023de0:	61fb      	str	r3, [r7, #28]
    while(text[line_start] != '\0') {
 8023de2:	68ba      	ldr	r2, [r7, #8]
 8023de4:	69fb      	ldr	r3, [r7, #28]
 8023de6:	4413      	add	r3, r2
 8023de8:	781b      	ldrb	r3, [r3, #0]
 8023dea:	2b00      	cmp	r3, #0
 8023dec:	d1be      	bne.n	8023d6c <lv_text_get_size+0x4c>
    }

    /*Make the text one line taller if the last character is '\n' or '\r'*/
    if((line_start != 0) && (text[line_start - 1] == '\n' || text[line_start - 1] == '\r')) {
 8023dee:	69fb      	ldr	r3, [r7, #28]
 8023df0:	2b00      	cmp	r3, #0
 8023df2:	d015      	beq.n	8023e20 <lv_text_get_size+0x100>
 8023df4:	69fb      	ldr	r3, [r7, #28]
 8023df6:	3b01      	subs	r3, #1
 8023df8:	68ba      	ldr	r2, [r7, #8]
 8023dfa:	4413      	add	r3, r2
 8023dfc:	781b      	ldrb	r3, [r3, #0]
 8023dfe:	2b0a      	cmp	r3, #10
 8023e00:	d006      	beq.n	8023e10 <lv_text_get_size+0xf0>
 8023e02:	69fb      	ldr	r3, [r7, #28]
 8023e04:	3b01      	subs	r3, #1
 8023e06:	68ba      	ldr	r2, [r7, #8]
 8023e08:	4413      	add	r3, r2
 8023e0a:	781b      	ldrb	r3, [r3, #0]
 8023e0c:	2b0d      	cmp	r3, #13
 8023e0e:	d107      	bne.n	8023e20 <lv_text_get_size+0x100>
        size_res->y += letter_height + line_space;
 8023e10:	68fb      	ldr	r3, [r7, #12]
 8023e12:	685a      	ldr	r2, [r3, #4]
 8023e14:	8af9      	ldrh	r1, [r7, #22]
 8023e16:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8023e18:	440b      	add	r3, r1
 8023e1a:	441a      	add	r2, r3
 8023e1c:	68fb      	ldr	r3, [r7, #12]
 8023e1e:	605a      	str	r2, [r3, #4]
    }

    /*Correction with the last line space or set the height manually if the text is empty*/
    if(size_res->y == 0)
 8023e20:	68fb      	ldr	r3, [r7, #12]
 8023e22:	685b      	ldr	r3, [r3, #4]
 8023e24:	2b00      	cmp	r3, #0
 8023e26:	d103      	bne.n	8023e30 <lv_text_get_size+0x110>
        size_res->y = letter_height;
 8023e28:	8afa      	ldrh	r2, [r7, #22]
 8023e2a:	68fb      	ldr	r3, [r7, #12]
 8023e2c:	605a      	str	r2, [r3, #4]
 8023e2e:	e00b      	b.n	8023e48 <lv_text_get_size+0x128>
    else
        size_res->y -= line_space;
 8023e30:	68fb      	ldr	r3, [r7, #12]
 8023e32:	685a      	ldr	r2, [r3, #4]
 8023e34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8023e36:	1ad2      	subs	r2, r2, r3
 8023e38:	68fb      	ldr	r3, [r7, #12]
 8023e3a:	605a      	str	r2, [r3, #4]
 8023e3c:	e004      	b.n	8023e48 <lv_text_get_size+0x128>
    if(text == NULL) return;
 8023e3e:	bf00      	nop
 8023e40:	e002      	b.n	8023e48 <lv_text_get_size+0x128>
    if(font == NULL) return;
 8023e42:	bf00      	nop
 8023e44:	e000      	b.n	8023e48 <lv_text_get_size+0x128>
            return;
 8023e46:	bf00      	nop
}
 8023e48:	3720      	adds	r7, #32
 8023e4a:	46bd      	mov	sp, r7
 8023e4c:	bd80      	pop	{r7, pc}
	...

08023e50 <lv_text_get_next_word>:
 * @return the index of the first char of the next word (in byte index not letter index. With UTF-8 they are different)
 */
static uint32_t lv_text_get_next_word(const char * txt, const lv_font_t * font,
                                      int32_t letter_space, int32_t max_width,
                                      lv_text_flag_t flag, uint32_t * word_w_ptr, bool force)
{
 8023e50:	b580      	push	{r7, lr}
 8023e52:	b08e      	sub	sp, #56	@ 0x38
 8023e54:	af00      	add	r7, sp, #0
 8023e56:	60f8      	str	r0, [r7, #12]
 8023e58:	60b9      	str	r1, [r7, #8]
 8023e5a:	607a      	str	r2, [r7, #4]
 8023e5c:	603b      	str	r3, [r7, #0]
    if(txt == NULL || txt[0] == '\0') return 0;
 8023e5e:	68fb      	ldr	r3, [r7, #12]
 8023e60:	2b00      	cmp	r3, #0
 8023e62:	d003      	beq.n	8023e6c <lv_text_get_next_word+0x1c>
 8023e64:	68fb      	ldr	r3, [r7, #12]
 8023e66:	781b      	ldrb	r3, [r3, #0]
 8023e68:	2b00      	cmp	r3, #0
 8023e6a:	d101      	bne.n	8023e70 <lv_text_get_next_word+0x20>
 8023e6c:	2300      	movs	r3, #0
 8023e6e:	e0ba      	b.n	8023fe6 <lv_text_get_next_word+0x196>
    if(font == NULL) return 0;
 8023e70:	68bb      	ldr	r3, [r7, #8]
 8023e72:	2b00      	cmp	r3, #0
 8023e74:	d101      	bne.n	8023e7a <lv_text_get_next_word+0x2a>
 8023e76:	2300      	movs	r3, #0
 8023e78:	e0b5      	b.n	8023fe6 <lv_text_get_next_word+0x196>

    if(flag & LV_TEXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 8023e7a:	f897 3040 	ldrb.w	r3, [r7, #64]	@ 0x40
 8023e7e:	f003 0301 	and.w	r3, r3, #1
 8023e82:	2b00      	cmp	r3, #0
 8023e84:	d002      	beq.n	8023e8c <lv_text_get_next_word+0x3c>
 8023e86:	f06f 4360 	mvn.w	r3, #3758096384	@ 0xe0000000
 8023e8a:	603b      	str	r3, [r7, #0]

    uint32_t i = 0, i_next = 0, i_next_next = 0;  /*Iterating index into txt*/
 8023e8c:	2300      	movs	r3, #0
 8023e8e:	637b      	str	r3, [r7, #52]	@ 0x34
 8023e90:	2300      	movs	r3, #0
 8023e92:	617b      	str	r3, [r7, #20]
 8023e94:	2300      	movs	r3, #0
 8023e96:	613b      	str	r3, [r7, #16]
    uint32_t letter = 0;      /*Letter at i*/
 8023e98:	2300      	movs	r3, #0
 8023e9a:	633b      	str	r3, [r7, #48]	@ 0x30
    uint32_t letter_next = 0; /*Letter at i_next*/
 8023e9c:	2300      	movs	r3, #0
 8023e9e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    int32_t letter_w;
    int32_t cur_w = 0;  /*Pixel Width of transversed string*/
 8023ea0:	2300      	movs	r3, #0
 8023ea2:	62bb      	str	r3, [r7, #40]	@ 0x28
    uint32_t word_len = 0;   /*Number of characters in the transversed word*/
 8023ea4:	2300      	movs	r3, #0
 8023ea6:	627b      	str	r3, [r7, #36]	@ 0x24
    uint32_t break_index = NO_BREAK_FOUND; /*only used for "long" words*/
 8023ea8:	f04f 33ff 	mov.w	r3, #4294967295
 8023eac:	623b      	str	r3, [r7, #32]
    uint32_t break_letter_count = 0; /*Number of characters up to the long word break point*/
 8023eae:	2300      	movs	r3, #0
 8023eb0:	61fb      	str	r3, [r7, #28]

    letter = _lv_text_encoded_next(txt, &i_next);
 8023eb2:	4b4f      	ldr	r3, [pc, #316]	@ (8023ff0 <lv_text_get_next_word+0x1a0>)
 8023eb4:	681b      	ldr	r3, [r3, #0]
 8023eb6:	f107 0214 	add.w	r2, r7, #20
 8023eba:	4611      	mov	r1, r2
 8023ebc:	68f8      	ldr	r0, [r7, #12]
 8023ebe:	4798      	blx	r3
 8023ec0:	6338      	str	r0, [r7, #48]	@ 0x30
    i_next_next = i_next;
 8023ec2:	697b      	ldr	r3, [r7, #20]
 8023ec4:	613b      	str	r3, [r7, #16]

    /*Obtain the full word, regardless if it fits or not in max_width*/
    while(txt[i] != '\0') {
 8023ec6:	e06a      	b.n	8023f9e <lv_text_get_next_word+0x14e>
        letter_next = _lv_text_encoded_next(txt, &i_next_next);
 8023ec8:	4b49      	ldr	r3, [pc, #292]	@ (8023ff0 <lv_text_get_next_word+0x1a0>)
 8023eca:	681b      	ldr	r3, [r3, #0]
 8023ecc:	f107 0210 	add.w	r2, r7, #16
 8023ed0:	4611      	mov	r1, r2
 8023ed2:	68f8      	ldr	r0, [r7, #12]
 8023ed4:	4798      	blx	r3
 8023ed6:	62f8      	str	r0, [r7, #44]	@ 0x2c
        word_len++;
 8023ed8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023eda:	3301      	adds	r3, #1
 8023edc:	627b      	str	r3, [r7, #36]	@ 0x24

        letter_w = lv_font_get_glyph_width(font, letter, letter_next);
 8023ede:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8023ee0:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 8023ee2:	68b8      	ldr	r0, [r7, #8]
 8023ee4:	f7f8 fac6 	bl	801c474 <lv_font_get_glyph_width>
 8023ee8:	4603      	mov	r3, r0
 8023eea:	61bb      	str	r3, [r7, #24]
        cur_w += letter_w;
 8023eec:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8023eee:	69bb      	ldr	r3, [r7, #24]
 8023ef0:	4413      	add	r3, r2
 8023ef2:	62bb      	str	r3, [r7, #40]	@ 0x28

        if(letter_w > 0) {
 8023ef4:	69bb      	ldr	r3, [r7, #24]
 8023ef6:	2b00      	cmp	r3, #0
 8023ef8:	dd03      	ble.n	8023f02 <lv_text_get_next_word+0xb2>
            cur_w += letter_space;
 8023efa:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8023efc:	687b      	ldr	r3, [r7, #4]
 8023efe:	4413      	add	r3, r2
 8023f00:	62bb      	str	r3, [r7, #40]	@ 0x28
        }

        /*Test if this character fits within max_width*/
        if(break_index == NO_BREAK_FOUND && (cur_w - letter_space) > max_width) {
 8023f02:	6a3b      	ldr	r3, [r7, #32]
 8023f04:	f1b3 3fff 	cmp.w	r3, #4294967295
 8023f08:	d10a      	bne.n	8023f20 <lv_text_get_next_word+0xd0>
 8023f0a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8023f0c:	687b      	ldr	r3, [r7, #4]
 8023f0e:	1ad3      	subs	r3, r2, r3
 8023f10:	683a      	ldr	r2, [r7, #0]
 8023f12:	429a      	cmp	r2, r3
 8023f14:	da04      	bge.n	8023f20 <lv_text_get_next_word+0xd0>
            break_index = i;
 8023f16:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8023f18:	623b      	str	r3, [r7, #32]
            break_letter_count = word_len - 1;
 8023f1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023f1c:	3b01      	subs	r3, #1
 8023f1e:	61fb      	str	r3, [r7, #28]
            /*break_index is now pointing at the character that doesn't fit*/
        }

        /*Check for new line chars and breakchars*/
        if(letter == '\n' || letter == '\r' || _lv_text_is_break_char(letter)) {
 8023f20:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8023f22:	2b0a      	cmp	r3, #10
 8023f24:	d008      	beq.n	8023f38 <lv_text_get_next_word+0xe8>
 8023f26:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8023f28:	2b0d      	cmp	r3, #13
 8023f2a:	d005      	beq.n	8023f38 <lv_text_get_next_word+0xe8>
 8023f2c:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8023f2e:	f7ff fe6d 	bl	8023c0c <_lv_text_is_break_char>
 8023f32:	4603      	mov	r3, r0
 8023f34:	2b00      	cmp	r3, #0
 8023f36:	d010      	beq.n	8023f5a <lv_text_get_next_word+0x10a>
            /*Update the output width on the first character if it fits.
             *Must do this here in case first letter is a break character.*/
            if(i == 0 && break_index == NO_BREAK_FOUND && word_w_ptr != NULL) *word_w_ptr = cur_w;
 8023f38:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8023f3a:	2b00      	cmp	r3, #0
 8023f3c:	d109      	bne.n	8023f52 <lv_text_get_next_word+0x102>
 8023f3e:	6a3b      	ldr	r3, [r7, #32]
 8023f40:	f1b3 3fff 	cmp.w	r3, #4294967295
 8023f44:	d105      	bne.n	8023f52 <lv_text_get_next_word+0x102>
 8023f46:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f48:	2b00      	cmp	r3, #0
 8023f4a:	d002      	beq.n	8023f52 <lv_text_get_next_word+0x102>
 8023f4c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8023f4e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f50:	601a      	str	r2, [r3, #0]
            word_len--;
 8023f52:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023f54:	3b01      	subs	r3, #1
 8023f56:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
 8023f58:	e027      	b.n	8023faa <lv_text_get_next_word+0x15a>
        }
        else if(_lv_text_is_a_word(letter_next) || _lv_text_is_a_word(letter)) {
 8023f5a:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8023f5c:	f7ff fe7a 	bl	8023c54 <_lv_text_is_a_word>
 8023f60:	4603      	mov	r3, r0
 8023f62:	2b00      	cmp	r3, #0
 8023f64:	d105      	bne.n	8023f72 <lv_text_get_next_word+0x122>
 8023f66:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8023f68:	f7ff fe74 	bl	8023c54 <_lv_text_is_a_word>
 8023f6c:	4603      	mov	r3, r0
 8023f6e:	2b00      	cmp	r3, #0
 8023f70:	d005      	beq.n	8023f7e <lv_text_get_next_word+0x12e>
            /*Found a word for single letter, usually true for CJK*/
            *word_w_ptr = cur_w;
 8023f72:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8023f74:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f76:	601a      	str	r2, [r3, #0]
            i = i_next;
 8023f78:	697b      	ldr	r3, [r7, #20]
 8023f7a:	637b      	str	r3, [r7, #52]	@ 0x34
            break;
 8023f7c:	e015      	b.n	8023faa <lv_text_get_next_word+0x15a>
        }

        /*Update the output width*/
        if(word_w_ptr != NULL && break_index == NO_BREAK_FOUND) *word_w_ptr = cur_w;
 8023f7e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f80:	2b00      	cmp	r3, #0
 8023f82:	d006      	beq.n	8023f92 <lv_text_get_next_word+0x142>
 8023f84:	6a3b      	ldr	r3, [r7, #32]
 8023f86:	f1b3 3fff 	cmp.w	r3, #4294967295
 8023f8a:	d102      	bne.n	8023f92 <lv_text_get_next_word+0x142>
 8023f8c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8023f8e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023f90:	601a      	str	r2, [r3, #0]

        i = i_next;
 8023f92:	697b      	ldr	r3, [r7, #20]
 8023f94:	637b      	str	r3, [r7, #52]	@ 0x34
        i_next = i_next_next;
 8023f96:	693b      	ldr	r3, [r7, #16]
 8023f98:	617b      	str	r3, [r7, #20]
        letter = letter_next;
 8023f9a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023f9c:	633b      	str	r3, [r7, #48]	@ 0x30
    while(txt[i] != '\0') {
 8023f9e:	68fa      	ldr	r2, [r7, #12]
 8023fa0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8023fa2:	4413      	add	r3, r2
 8023fa4:	781b      	ldrb	r3, [r3, #0]
 8023fa6:	2b00      	cmp	r3, #0
 8023fa8:	d18e      	bne.n	8023ec8 <lv_text_get_next_word+0x78>
    }

    /*Entire Word fits in the provided space*/
    if(break_index == NO_BREAK_FOUND) {
 8023faa:	6a3b      	ldr	r3, [r7, #32]
 8023fac:	f1b3 3fff 	cmp.w	r3, #4294967295
 8023fb0:	d10c      	bne.n	8023fcc <lv_text_get_next_word+0x17c>
        if(word_len == 0 || (letter == '\r' && letter_next == '\n')) i = i_next;
 8023fb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8023fb4:	2b00      	cmp	r3, #0
 8023fb6:	d005      	beq.n	8023fc4 <lv_text_get_next_word+0x174>
 8023fb8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8023fba:	2b0d      	cmp	r3, #13
 8023fbc:	d104      	bne.n	8023fc8 <lv_text_get_next_word+0x178>
 8023fbe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8023fc0:	2b0a      	cmp	r3, #10
 8023fc2:	d101      	bne.n	8023fc8 <lv_text_get_next_word+0x178>
 8023fc4:	697b      	ldr	r3, [r7, #20]
 8023fc6:	637b      	str	r3, [r7, #52]	@ 0x34
        return i;
 8023fc8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8023fca:	e00c      	b.n	8023fe6 <lv_text_get_next_word+0x196>
             */
        }
    }
    return i;
#else
    if(force) return break_index;
 8023fcc:	f897 3048 	ldrb.w	r3, [r7, #72]	@ 0x48
 8023fd0:	2b00      	cmp	r3, #0
 8023fd2:	d001      	beq.n	8023fd8 <lv_text_get_next_word+0x188>
 8023fd4:	6a3b      	ldr	r3, [r7, #32]
 8023fd6:	e006      	b.n	8023fe6 <lv_text_get_next_word+0x196>
    if(word_w_ptr != NULL) *word_w_ptr = 0; /*Return no word*/
 8023fd8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023fda:	2b00      	cmp	r3, #0
 8023fdc:	d002      	beq.n	8023fe4 <lv_text_get_next_word+0x194>
 8023fde:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8023fe0:	2200      	movs	r2, #0
 8023fe2:	601a      	str	r2, [r3, #0]
    (void) break_letter_count;
    return 0;
 8023fe4:	2300      	movs	r3, #0
#endif
}
 8023fe6:	4618      	mov	r0, r3
 8023fe8:	3738      	adds	r7, #56	@ 0x38
 8023fea:	46bd      	mov	sp, r7
 8023fec:	bd80      	pop	{r7, pc}
 8023fee:	bf00      	nop
 8023ff0:	20000010 	.word	0x20000010

08023ff4 <_lv_text_get_next_line>:

uint32_t _lv_text_get_next_line(const char * txt, const lv_font_t * font,
                                int32_t letter_space, int32_t max_width,
                                int32_t * used_width, lv_text_flag_t flag)
{
 8023ff4:	b580      	push	{r7, lr}
 8023ff6:	b08e      	sub	sp, #56	@ 0x38
 8023ff8:	af04      	add	r7, sp, #16
 8023ffa:	60f8      	str	r0, [r7, #12]
 8023ffc:	60b9      	str	r1, [r7, #8]
 8023ffe:	607a      	str	r2, [r7, #4]
 8024000:	603b      	str	r3, [r7, #0]
    if(used_width) *used_width = 0;
 8024002:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024004:	2b00      	cmp	r3, #0
 8024006:	d002      	beq.n	802400e <_lv_text_get_next_line+0x1a>
 8024008:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802400a:	2200      	movs	r2, #0
 802400c:	601a      	str	r2, [r3, #0]

    if(txt == NULL) return 0;
 802400e:	68fb      	ldr	r3, [r7, #12]
 8024010:	2b00      	cmp	r3, #0
 8024012:	d101      	bne.n	8024018 <_lv_text_get_next_line+0x24>
 8024014:	2300      	movs	r3, #0
 8024016:	e0b4      	b.n	8024182 <_lv_text_get_next_line+0x18e>
    if(txt[0] == '\0') return 0;
 8024018:	68fb      	ldr	r3, [r7, #12]
 802401a:	781b      	ldrb	r3, [r3, #0]
 802401c:	2b00      	cmp	r3, #0
 802401e:	d101      	bne.n	8024024 <_lv_text_get_next_line+0x30>
 8024020:	2300      	movs	r3, #0
 8024022:	e0ae      	b.n	8024182 <_lv_text_get_next_line+0x18e>
    if(font == NULL) return 0;
 8024024:	68bb      	ldr	r3, [r7, #8]
 8024026:	2b00      	cmp	r3, #0
 8024028:	d101      	bne.n	802402e <_lv_text_get_next_line+0x3a>
 802402a:	2300      	movs	r3, #0
 802402c:	e0a9      	b.n	8024182 <_lv_text_get_next_line+0x18e>

    int32_t line_w = 0;
 802402e:	2300      	movs	r3, #0
 8024030:	627b      	str	r3, [r7, #36]	@ 0x24

    /*If max_width doesn't matter simply find the new line character
     *without thinking about word wrapping*/
    if((flag & LV_TEXT_FLAG_EXPAND) || (flag & LV_TEXT_FLAG_FIT)) {
 8024032:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 8024036:	f003 0301 	and.w	r3, r3, #1
 802403a:	2b00      	cmp	r3, #0
 802403c:	d105      	bne.n	802404a <_lv_text_get_next_line+0x56>
 802403e:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 8024042:	f003 0302 	and.w	r3, r3, #2
 8024046:	2b00      	cmp	r3, #0
 8024048:	d029      	beq.n	802409e <_lv_text_get_next_line+0xaa>
        uint32_t i;
        for(i = 0; txt[i] != '\n' && txt[i] != '\r' && txt[i] != '\0'; i++) {
 802404a:	2300      	movs	r3, #0
 802404c:	623b      	str	r3, [r7, #32]
 802404e:	e002      	b.n	8024056 <_lv_text_get_next_line+0x62>
 8024050:	6a3b      	ldr	r3, [r7, #32]
 8024052:	3301      	adds	r3, #1
 8024054:	623b      	str	r3, [r7, #32]
 8024056:	68fa      	ldr	r2, [r7, #12]
 8024058:	6a3b      	ldr	r3, [r7, #32]
 802405a:	4413      	add	r3, r2
 802405c:	781b      	ldrb	r3, [r3, #0]
 802405e:	2b0a      	cmp	r3, #10
 8024060:	d00b      	beq.n	802407a <_lv_text_get_next_line+0x86>
 8024062:	68fa      	ldr	r2, [r7, #12]
 8024064:	6a3b      	ldr	r3, [r7, #32]
 8024066:	4413      	add	r3, r2
 8024068:	781b      	ldrb	r3, [r3, #0]
 802406a:	2b0d      	cmp	r3, #13
 802406c:	d005      	beq.n	802407a <_lv_text_get_next_line+0x86>
 802406e:	68fa      	ldr	r2, [r7, #12]
 8024070:	6a3b      	ldr	r3, [r7, #32]
 8024072:	4413      	add	r3, r2
 8024074:	781b      	ldrb	r3, [r3, #0]
 8024076:	2b00      	cmp	r3, #0
 8024078:	d1ea      	bne.n	8024050 <_lv_text_get_next_line+0x5c>
            /*Just find the new line chars or string ends by incrementing `i`*/
        }
        if(txt[i] != '\0') i++;    /*To go beyond `\n`*/
 802407a:	68fa      	ldr	r2, [r7, #12]
 802407c:	6a3b      	ldr	r3, [r7, #32]
 802407e:	4413      	add	r3, r2
 8024080:	781b      	ldrb	r3, [r3, #0]
 8024082:	2b00      	cmp	r3, #0
 8024084:	d002      	beq.n	802408c <_lv_text_get_next_line+0x98>
 8024086:	6a3b      	ldr	r3, [r7, #32]
 8024088:	3301      	adds	r3, #1
 802408a:	623b      	str	r3, [r7, #32]
        if(used_width) *used_width = -1;
 802408c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802408e:	2b00      	cmp	r3, #0
 8024090:	d003      	beq.n	802409a <_lv_text_get_next_line+0xa6>
 8024092:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024094:	f04f 32ff 	mov.w	r2, #4294967295
 8024098:	601a      	str	r2, [r3, #0]
        return i;
 802409a:	6a3b      	ldr	r3, [r7, #32]
 802409c:	e071      	b.n	8024182 <_lv_text_get_next_line+0x18e>
    }

    if(flag & LV_TEXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 802409e:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 80240a2:	f003 0301 	and.w	r3, r3, #1
 80240a6:	2b00      	cmp	r3, #0
 80240a8:	d002      	beq.n	80240b0 <_lv_text_get_next_line+0xbc>
 80240aa:	f06f 4360 	mvn.w	r3, #3758096384	@ 0xe0000000
 80240ae:	603b      	str	r3, [r7, #0]
    uint32_t i = 0;                                        /*Iterating index into txt*/
 80240b0:	2300      	movs	r3, #0
 80240b2:	617b      	str	r3, [r7, #20]

    while(txt[i] != '\0' && max_width > 0) {
 80240b4:	e03e      	b.n	8024134 <_lv_text_get_next_line+0x140>
        uint32_t word_w = 0;
 80240b6:	2300      	movs	r3, #0
 80240b8:	613b      	str	r3, [r7, #16]
        uint32_t advance = lv_text_get_next_word(&txt[i], font, letter_space, max_width, flag, &word_w, i == 0);
 80240ba:	697b      	ldr	r3, [r7, #20]
 80240bc:	68fa      	ldr	r2, [r7, #12]
 80240be:	18d0      	adds	r0, r2, r3
 80240c0:	697b      	ldr	r3, [r7, #20]
 80240c2:	2b00      	cmp	r3, #0
 80240c4:	bf0c      	ite	eq
 80240c6:	2301      	moveq	r3, #1
 80240c8:	2300      	movne	r3, #0
 80240ca:	b2db      	uxtb	r3, r3
 80240cc:	9302      	str	r3, [sp, #8]
 80240ce:	f107 0310 	add.w	r3, r7, #16
 80240d2:	9301      	str	r3, [sp, #4]
 80240d4:	f897 3034 	ldrb.w	r3, [r7, #52]	@ 0x34
 80240d8:	9300      	str	r3, [sp, #0]
 80240da:	683b      	ldr	r3, [r7, #0]
 80240dc:	687a      	ldr	r2, [r7, #4]
 80240de:	68b9      	ldr	r1, [r7, #8]
 80240e0:	f7ff feb6 	bl	8023e50 <lv_text_get_next_word>
 80240e4:	61f8      	str	r0, [r7, #28]
        max_width -= word_w;
 80240e6:	683a      	ldr	r2, [r7, #0]
 80240e8:	693b      	ldr	r3, [r7, #16]
 80240ea:	1ad3      	subs	r3, r2, r3
 80240ec:	603b      	str	r3, [r7, #0]
        line_w += word_w;
 80240ee:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80240f0:	693b      	ldr	r3, [r7, #16]
 80240f2:	4413      	add	r3, r2
 80240f4:	627b      	str	r3, [r7, #36]	@ 0x24

        if(advance == 0) {
 80240f6:	69fb      	ldr	r3, [r7, #28]
 80240f8:	2b00      	cmp	r3, #0
 80240fa:	d025      	beq.n	8024148 <_lv_text_get_next_line+0x154>
            break;
        }

        i += advance;
 80240fc:	697a      	ldr	r2, [r7, #20]
 80240fe:	69fb      	ldr	r3, [r7, #28]
 8024100:	4413      	add	r3, r2
 8024102:	617b      	str	r3, [r7, #20]

        if(txt[0] == '\n' || txt[0] == '\r') break;
 8024104:	68fb      	ldr	r3, [r7, #12]
 8024106:	781b      	ldrb	r3, [r3, #0]
 8024108:	2b0a      	cmp	r3, #10
 802410a:	d01d      	beq.n	8024148 <_lv_text_get_next_line+0x154>
 802410c:	68fb      	ldr	r3, [r7, #12]
 802410e:	781b      	ldrb	r3, [r3, #0]
 8024110:	2b0d      	cmp	r3, #13
 8024112:	d019      	beq.n	8024148 <_lv_text_get_next_line+0x154>

        if(txt[i] == '\n' || txt[i] == '\r') {
 8024114:	697b      	ldr	r3, [r7, #20]
 8024116:	68fa      	ldr	r2, [r7, #12]
 8024118:	4413      	add	r3, r2
 802411a:	781b      	ldrb	r3, [r3, #0]
 802411c:	2b0a      	cmp	r3, #10
 802411e:	d005      	beq.n	802412c <_lv_text_get_next_line+0x138>
 8024120:	697b      	ldr	r3, [r7, #20]
 8024122:	68fa      	ldr	r2, [r7, #12]
 8024124:	4413      	add	r3, r2
 8024126:	781b      	ldrb	r3, [r3, #0]
 8024128:	2b0d      	cmp	r3, #13
 802412a:	d103      	bne.n	8024134 <_lv_text_get_next_line+0x140>
            i++;  /*Include the following newline in the current line*/
 802412c:	697b      	ldr	r3, [r7, #20]
 802412e:	3301      	adds	r3, #1
 8024130:	617b      	str	r3, [r7, #20]
            break;
 8024132:	e00a      	b.n	802414a <_lv_text_get_next_line+0x156>
    while(txt[i] != '\0' && max_width > 0) {
 8024134:	697b      	ldr	r3, [r7, #20]
 8024136:	68fa      	ldr	r2, [r7, #12]
 8024138:	4413      	add	r3, r2
 802413a:	781b      	ldrb	r3, [r3, #0]
 802413c:	2b00      	cmp	r3, #0
 802413e:	d004      	beq.n	802414a <_lv_text_get_next_line+0x156>
 8024140:	683b      	ldr	r3, [r7, #0]
 8024142:	2b00      	cmp	r3, #0
 8024144:	dcb7      	bgt.n	80240b6 <_lv_text_get_next_line+0xc2>
 8024146:	e000      	b.n	802414a <_lv_text_get_next_line+0x156>
            break;
 8024148:	bf00      	nop
        }

    }

    /*Always step at least one to avoid infinite loops*/
    if(i == 0) {
 802414a:	697b      	ldr	r3, [r7, #20]
 802414c:	2b00      	cmp	r3, #0
 802414e:	d111      	bne.n	8024174 <_lv_text_get_next_line+0x180>
        uint32_t letter = _lv_text_encoded_next(txt, &i);
 8024150:	4b0e      	ldr	r3, [pc, #56]	@ (802418c <_lv_text_get_next_line+0x198>)
 8024152:	681b      	ldr	r3, [r3, #0]
 8024154:	f107 0214 	add.w	r2, r7, #20
 8024158:	4611      	mov	r1, r2
 802415a:	68f8      	ldr	r0, [r7, #12]
 802415c:	4798      	blx	r3
 802415e:	61b8      	str	r0, [r7, #24]
        if(used_width != NULL) {
 8024160:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024162:	2b00      	cmp	r3, #0
 8024164:	d006      	beq.n	8024174 <_lv_text_get_next_line+0x180>
            line_w = lv_font_get_glyph_width(font, letter, '\0');
 8024166:	2200      	movs	r2, #0
 8024168:	69b9      	ldr	r1, [r7, #24]
 802416a:	68b8      	ldr	r0, [r7, #8]
 802416c:	f7f8 f982 	bl	801c474 <lv_font_get_glyph_width>
 8024170:	4603      	mov	r3, r0
 8024172:	627b      	str	r3, [r7, #36]	@ 0x24
        }
    }

    if(used_width != NULL) {
 8024174:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8024176:	2b00      	cmp	r3, #0
 8024178:	d002      	beq.n	8024180 <_lv_text_get_next_line+0x18c>
        *used_width = line_w;
 802417a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 802417c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802417e:	601a      	str	r2, [r3, #0]
    }

    return i;
 8024180:	697b      	ldr	r3, [r7, #20]
}
 8024182:	4618      	mov	r0, r3
 8024184:	3728      	adds	r7, #40	@ 0x28
 8024186:	46bd      	mov	sp, r7
 8024188:	bd80      	pop	{r7, pc}
 802418a:	bf00      	nop
 802418c:	20000010 	.word	0x20000010

08024190 <lv_text_get_width>:

int32_t lv_text_get_width(const char * txt, uint32_t length, const lv_font_t * font, int32_t letter_space)
{
 8024190:	b580      	push	{r7, lr}
 8024192:	b08a      	sub	sp, #40	@ 0x28
 8024194:	af00      	add	r7, sp, #0
 8024196:	60f8      	str	r0, [r7, #12]
 8024198:	60b9      	str	r1, [r7, #8]
 802419a:	607a      	str	r2, [r7, #4]
 802419c:	603b      	str	r3, [r7, #0]
    if(txt == NULL) return 0;
 802419e:	68fb      	ldr	r3, [r7, #12]
 80241a0:	2b00      	cmp	r3, #0
 80241a2:	d101      	bne.n	80241a8 <lv_text_get_width+0x18>
 80241a4:	2300      	movs	r3, #0
 80241a6:	e03a      	b.n	802421e <lv_text_get_width+0x8e>
    if(font == NULL) return 0;
 80241a8:	687b      	ldr	r3, [r7, #4]
 80241aa:	2b00      	cmp	r3, #0
 80241ac:	d101      	bne.n	80241b2 <lv_text_get_width+0x22>
 80241ae:	2300      	movs	r3, #0
 80241b0:	e035      	b.n	802421e <lv_text_get_width+0x8e>
    if(txt[0] == '\0') return 0;
 80241b2:	68fb      	ldr	r3, [r7, #12]
 80241b4:	781b      	ldrb	r3, [r3, #0]
 80241b6:	2b00      	cmp	r3, #0
 80241b8:	d101      	bne.n	80241be <lv_text_get_width+0x2e>
 80241ba:	2300      	movs	r3, #0
 80241bc:	e02f      	b.n	802421e <lv_text_get_width+0x8e>

    uint32_t i                   = 0;
 80241be:	2300      	movs	r3, #0
 80241c0:	61fb      	str	r3, [r7, #28]
    int32_t width             = 0;
 80241c2:	2300      	movs	r3, #0
 80241c4:	627b      	str	r3, [r7, #36]	@ 0x24

    if(length != 0) {
 80241c6:	68bb      	ldr	r3, [r7, #8]
 80241c8:	2b00      	cmp	r3, #0
 80241ca:	d027      	beq.n	802421c <lv_text_get_width+0x8c>
        while(i < length) {
 80241cc:	e01b      	b.n	8024206 <lv_text_get_width+0x76>
            uint32_t letter;
            uint32_t letter_next;
            _lv_text_encoded_letter_next_2(txt, &letter, &letter_next, &i);
 80241ce:	f107 031c 	add.w	r3, r7, #28
 80241d2:	f107 0214 	add.w	r2, r7, #20
 80241d6:	f107 0118 	add.w	r1, r7, #24
 80241da:	68f8      	ldr	r0, [r7, #12]
 80241dc:	f000 f824 	bl	8024228 <_lv_text_encoded_letter_next_2>

            int32_t char_width = lv_font_get_glyph_width(font, letter, letter_next);
 80241e0:	69bb      	ldr	r3, [r7, #24]
 80241e2:	697a      	ldr	r2, [r7, #20]
 80241e4:	4619      	mov	r1, r3
 80241e6:	6878      	ldr	r0, [r7, #4]
 80241e8:	f7f8 f944 	bl	801c474 <lv_font_get_glyph_width>
 80241ec:	4603      	mov	r3, r0
 80241ee:	623b      	str	r3, [r7, #32]
            if(char_width > 0) {
 80241f0:	6a3b      	ldr	r3, [r7, #32]
 80241f2:	2b00      	cmp	r3, #0
 80241f4:	dd07      	ble.n	8024206 <lv_text_get_width+0x76>
                width += char_width;
 80241f6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80241f8:	6a3b      	ldr	r3, [r7, #32]
 80241fa:	4413      	add	r3, r2
 80241fc:	627b      	str	r3, [r7, #36]	@ 0x24
                width += letter_space;
 80241fe:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8024200:	683b      	ldr	r3, [r7, #0]
 8024202:	4413      	add	r3, r2
 8024204:	627b      	str	r3, [r7, #36]	@ 0x24
        while(i < length) {
 8024206:	69fb      	ldr	r3, [r7, #28]
 8024208:	68ba      	ldr	r2, [r7, #8]
 802420a:	429a      	cmp	r2, r3
 802420c:	d8df      	bhi.n	80241ce <lv_text_get_width+0x3e>
            }
        }

        if(width > 0) {
 802420e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024210:	2b00      	cmp	r3, #0
 8024212:	dd03      	ble.n	802421c <lv_text_get_width+0x8c>
            width -= letter_space; /*Trim the last letter space. Important if the text is center
 8024214:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8024216:	683b      	ldr	r3, [r7, #0]
 8024218:	1ad3      	subs	r3, r2, r3
 802421a:	627b      	str	r3, [r7, #36]	@ 0x24
                                      aligned*/
        }
    }

    return width;
 802421c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 802421e:	4618      	mov	r0, r3
 8024220:	3728      	adds	r7, #40	@ 0x28
 8024222:	46bd      	mov	sp, r7
 8024224:	bd80      	pop	{r7, pc}
	...

08024228 <_lv_text_encoded_letter_next_2>:

    return text;
}

void _lv_text_encoded_letter_next_2(const char * txt, uint32_t * letter, uint32_t * letter_next, uint32_t * ofs)
{
 8024228:	b580      	push	{r7, lr}
 802422a:	b084      	sub	sp, #16
 802422c:	af00      	add	r7, sp, #0
 802422e:	60f8      	str	r0, [r7, #12]
 8024230:	60b9      	str	r1, [r7, #8]
 8024232:	607a      	str	r2, [r7, #4]
 8024234:	603b      	str	r3, [r7, #0]
    *letter = _lv_text_encoded_next(txt, ofs);
 8024236:	4b0f      	ldr	r3, [pc, #60]	@ (8024274 <_lv_text_encoded_letter_next_2+0x4c>)
 8024238:	681b      	ldr	r3, [r3, #0]
 802423a:	6839      	ldr	r1, [r7, #0]
 802423c:	68f8      	ldr	r0, [r7, #12]
 802423e:	4798      	blx	r3
 8024240:	4602      	mov	r2, r0
 8024242:	68bb      	ldr	r3, [r7, #8]
 8024244:	601a      	str	r2, [r3, #0]
    *letter_next = *letter != '\0' ? _lv_text_encoded_next(&txt[*ofs], NULL) : 0;
 8024246:	68bb      	ldr	r3, [r7, #8]
 8024248:	681b      	ldr	r3, [r3, #0]
 802424a:	2b00      	cmp	r3, #0
 802424c:	d00a      	beq.n	8024264 <_lv_text_encoded_letter_next_2+0x3c>
 802424e:	4b09      	ldr	r3, [pc, #36]	@ (8024274 <_lv_text_encoded_letter_next_2+0x4c>)
 8024250:	681b      	ldr	r3, [r3, #0]
 8024252:	683a      	ldr	r2, [r7, #0]
 8024254:	6812      	ldr	r2, [r2, #0]
 8024256:	68f9      	ldr	r1, [r7, #12]
 8024258:	440a      	add	r2, r1
 802425a:	2100      	movs	r1, #0
 802425c:	4610      	mov	r0, r2
 802425e:	4798      	blx	r3
 8024260:	4603      	mov	r3, r0
 8024262:	e000      	b.n	8024266 <_lv_text_encoded_letter_next_2+0x3e>
 8024264:	2300      	movs	r3, #0
 8024266:	687a      	ldr	r2, [r7, #4]
 8024268:	6013      	str	r3, [r2, #0]
}
 802426a:	bf00      	nop
 802426c:	3710      	adds	r7, #16
 802426e:	46bd      	mov	sp, r7
 8024270:	bd80      	pop	{r7, pc}
 8024272:	bf00      	nop
 8024274:	20000010 	.word	0x20000010

08024278 <lv_text_utf8_size>:
 * Give the size of an UTF-8 coded character
 * @param str pointer to a character in a string
 * @return length of the UTF-8 character (1,2,3 or 4), 0 on invalid code.
 */
static uint8_t lv_text_utf8_size(const char * str)
{
 8024278:	b480      	push	{r7}
 802427a:	b083      	sub	sp, #12
 802427c:	af00      	add	r7, sp, #0
 802427e:	6078      	str	r0, [r7, #4]
    if(LV_IS_ASCII(str[0]))
 8024280:	687b      	ldr	r3, [r7, #4]
 8024282:	781b      	ldrb	r3, [r3, #0]
 8024284:	b25b      	sxtb	r3, r3
 8024286:	2b00      	cmp	r3, #0
 8024288:	db01      	blt.n	802428e <lv_text_utf8_size+0x16>
        return 1;
 802428a:	2301      	movs	r3, #1
 802428c:	e018      	b.n	80242c0 <lv_text_utf8_size+0x48>
    else if(LV_IS_2BYTES_UTF8_CODE(str[0]))
 802428e:	687b      	ldr	r3, [r7, #4]
 8024290:	781b      	ldrb	r3, [r3, #0]
 8024292:	f003 03e0 	and.w	r3, r3, #224	@ 0xe0
 8024296:	2bc0      	cmp	r3, #192	@ 0xc0
 8024298:	d101      	bne.n	802429e <lv_text_utf8_size+0x26>
        return 2;
 802429a:	2302      	movs	r3, #2
 802429c:	e010      	b.n	80242c0 <lv_text_utf8_size+0x48>
    else if(LV_IS_3BYTES_UTF8_CODE(str[0]))
 802429e:	687b      	ldr	r3, [r7, #4]
 80242a0:	781b      	ldrb	r3, [r3, #0]
 80242a2:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 80242a6:	2be0      	cmp	r3, #224	@ 0xe0
 80242a8:	d101      	bne.n	80242ae <lv_text_utf8_size+0x36>
        return 3;
 80242aa:	2303      	movs	r3, #3
 80242ac:	e008      	b.n	80242c0 <lv_text_utf8_size+0x48>
    else if(LV_IS_4BYTES_UTF8_CODE(str[0]))
 80242ae:	687b      	ldr	r3, [r7, #4]
 80242b0:	781b      	ldrb	r3, [r3, #0]
 80242b2:	f003 03f8 	and.w	r3, r3, #248	@ 0xf8
 80242b6:	2bf0      	cmp	r3, #240	@ 0xf0
 80242b8:	d101      	bne.n	80242be <lv_text_utf8_size+0x46>
        return 4;
 80242ba:	2304      	movs	r3, #4
 80242bc:	e000      	b.n	80242c0 <lv_text_utf8_size+0x48>
    return 0;
 80242be:	2300      	movs	r3, #0
}
 80242c0:	4618      	mov	r0, r3
 80242c2:	370c      	adds	r7, #12
 80242c4:	46bd      	mov	sp, r7
 80242c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80242ca:	4770      	bx	lr

080242cc <lv_text_utf8_next>:
 *          After call it will point to the next UTF-8 char in 'txt'.
 *          NULL to use txt[0] as index
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_text_utf8_next(const char * txt, uint32_t * i)
{
 80242cc:	b480      	push	{r7}
 80242ce:	b085      	sub	sp, #20
 80242d0:	af00      	add	r7, sp, #0
 80242d2:	6078      	str	r0, [r7, #4]
 80242d4:	6039      	str	r1, [r7, #0]
     * 00000000 00000000 00000yyy yyxxxxxx -> 110yyyyy 10xxxxxx
     * 00000000 00000000 zzzzyyyy yyxxxxxx -> 1110zzzz 10yyyyyy 10xxxxxx
     * 00000000 000wwwzz zzzzyyyy yyxxxxxx -> 11110www 10zzzzzz 10yyyyyy 10xxxxxx
     */

    uint32_t result = 0;
 80242d6:	2300      	movs	r3, #0
 80242d8:	60fb      	str	r3, [r7, #12]

    /*Dummy 'i' pointer is required*/
    uint32_t i_tmp = 0;
 80242da:	2300      	movs	r3, #0
 80242dc:	60bb      	str	r3, [r7, #8]
    if(i == NULL) i = &i_tmp;
 80242de:	683b      	ldr	r3, [r7, #0]
 80242e0:	2b00      	cmp	r3, #0
 80242e2:	d102      	bne.n	80242ea <lv_text_utf8_next+0x1e>
 80242e4:	f107 0308 	add.w	r3, r7, #8
 80242e8:	603b      	str	r3, [r7, #0]

    /*Normal ASCII*/
    if(LV_IS_ASCII(txt[*i])) {
 80242ea:	683b      	ldr	r3, [r7, #0]
 80242ec:	681b      	ldr	r3, [r3, #0]
 80242ee:	687a      	ldr	r2, [r7, #4]
 80242f0:	4413      	add	r3, r2
 80242f2:	781b      	ldrb	r3, [r3, #0]
 80242f4:	b25b      	sxtb	r3, r3
 80242f6:	2b00      	cmp	r3, #0
 80242f8:	db0b      	blt.n	8024312 <lv_text_utf8_next+0x46>
        result = txt[*i];
 80242fa:	683b      	ldr	r3, [r7, #0]
 80242fc:	681b      	ldr	r3, [r3, #0]
 80242fe:	687a      	ldr	r2, [r7, #4]
 8024300:	4413      	add	r3, r2
 8024302:	781b      	ldrb	r3, [r3, #0]
 8024304:	60fb      	str	r3, [r7, #12]
        (*i)++;
 8024306:	683b      	ldr	r3, [r7, #0]
 8024308:	681b      	ldr	r3, [r3, #0]
 802430a:	1c5a      	adds	r2, r3, #1
 802430c:	683b      	ldr	r3, [r7, #0]
 802430e:	601a      	str	r2, [r3, #0]
 8024310:	e0ea      	b.n	80244e8 <lv_text_utf8_next+0x21c>
    }
    /*Real UTF-8 decode*/
    else {
        /*2 bytes UTF-8 code*/
        if(LV_IS_2BYTES_UTF8_CODE(txt[*i])) {
 8024312:	683b      	ldr	r3, [r7, #0]
 8024314:	681b      	ldr	r3, [r3, #0]
 8024316:	687a      	ldr	r2, [r7, #4]
 8024318:	4413      	add	r3, r2
 802431a:	781b      	ldrb	r3, [r3, #0]
 802431c:	f003 03e0 	and.w	r3, r3, #224	@ 0xe0
 8024320:	2bc0      	cmp	r3, #192	@ 0xc0
 8024322:	d128      	bne.n	8024376 <lv_text_utf8_next+0xaa>
            result = (uint32_t)(txt[*i] & 0x1F) << 6;
 8024324:	683b      	ldr	r3, [r7, #0]
 8024326:	681b      	ldr	r3, [r3, #0]
 8024328:	687a      	ldr	r2, [r7, #4]
 802432a:	4413      	add	r3, r2
 802432c:	781b      	ldrb	r3, [r3, #0]
 802432e:	019b      	lsls	r3, r3, #6
 8024330:	f403 63f8 	and.w	r3, r3, #1984	@ 0x7c0
 8024334:	60fb      	str	r3, [r7, #12]
            (*i)++;
 8024336:	683b      	ldr	r3, [r7, #0]
 8024338:	681b      	ldr	r3, [r3, #0]
 802433a:	1c5a      	adds	r2, r3, #1
 802433c:	683b      	ldr	r3, [r7, #0]
 802433e:	601a      	str	r2, [r3, #0]
            if(LV_IS_INVALID_UTF8_CODE(txt[*i])) return 0;
 8024340:	683b      	ldr	r3, [r7, #0]
 8024342:	681b      	ldr	r3, [r3, #0]
 8024344:	687a      	ldr	r2, [r7, #4]
 8024346:	4413      	add	r3, r2
 8024348:	781b      	ldrb	r3, [r3, #0]
 802434a:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 802434e:	2b80      	cmp	r3, #128	@ 0x80
 8024350:	d001      	beq.n	8024356 <lv_text_utf8_next+0x8a>
 8024352:	2300      	movs	r3, #0
 8024354:	e0c9      	b.n	80244ea <lv_text_utf8_next+0x21e>
            result += (txt[*i] & 0x3F);
 8024356:	683b      	ldr	r3, [r7, #0]
 8024358:	681b      	ldr	r3, [r3, #0]
 802435a:	687a      	ldr	r2, [r7, #4]
 802435c:	4413      	add	r3, r2
 802435e:	781b      	ldrb	r3, [r3, #0]
 8024360:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8024364:	68fa      	ldr	r2, [r7, #12]
 8024366:	4413      	add	r3, r2
 8024368:	60fb      	str	r3, [r7, #12]
            (*i)++;
 802436a:	683b      	ldr	r3, [r7, #0]
 802436c:	681b      	ldr	r3, [r3, #0]
 802436e:	1c5a      	adds	r2, r3, #1
 8024370:	683b      	ldr	r3, [r7, #0]
 8024372:	601a      	str	r2, [r3, #0]
 8024374:	e0b8      	b.n	80244e8 <lv_text_utf8_next+0x21c>
        }
        /*3 bytes UTF-8 code*/
        else if(LV_IS_3BYTES_UTF8_CODE(txt[*i])) {
 8024376:	683b      	ldr	r3, [r7, #0]
 8024378:	681b      	ldr	r3, [r3, #0]
 802437a:	687a      	ldr	r2, [r7, #4]
 802437c:	4413      	add	r3, r2
 802437e:	781b      	ldrb	r3, [r3, #0]
 8024380:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8024384:	2be0      	cmp	r3, #224	@ 0xe0
 8024386:	d142      	bne.n	802440e <lv_text_utf8_next+0x142>
            result = (uint32_t)(txt[*i] & 0x0F) << 12;
 8024388:	683b      	ldr	r3, [r7, #0]
 802438a:	681b      	ldr	r3, [r3, #0]
 802438c:	687a      	ldr	r2, [r7, #4]
 802438e:	4413      	add	r3, r2
 8024390:	781b      	ldrb	r3, [r3, #0]
 8024392:	031b      	lsls	r3, r3, #12
 8024394:	b29b      	uxth	r3, r3
 8024396:	60fb      	str	r3, [r7, #12]
            (*i)++;
 8024398:	683b      	ldr	r3, [r7, #0]
 802439a:	681b      	ldr	r3, [r3, #0]
 802439c:	1c5a      	adds	r2, r3, #1
 802439e:	683b      	ldr	r3, [r7, #0]
 80243a0:	601a      	str	r2, [r3, #0]

            if(LV_IS_INVALID_UTF8_CODE(txt[*i])) return 0;
 80243a2:	683b      	ldr	r3, [r7, #0]
 80243a4:	681b      	ldr	r3, [r3, #0]
 80243a6:	687a      	ldr	r2, [r7, #4]
 80243a8:	4413      	add	r3, r2
 80243aa:	781b      	ldrb	r3, [r3, #0]
 80243ac:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 80243b0:	2b80      	cmp	r3, #128	@ 0x80
 80243b2:	d001      	beq.n	80243b8 <lv_text_utf8_next+0xec>
 80243b4:	2300      	movs	r3, #0
 80243b6:	e098      	b.n	80244ea <lv_text_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
 80243b8:	683b      	ldr	r3, [r7, #0]
 80243ba:	681b      	ldr	r3, [r3, #0]
 80243bc:	687a      	ldr	r2, [r7, #4]
 80243be:	4413      	add	r3, r2
 80243c0:	781b      	ldrb	r3, [r3, #0]
 80243c2:	019b      	lsls	r3, r3, #6
 80243c4:	f403 637c 	and.w	r3, r3, #4032	@ 0xfc0
 80243c8:	68fa      	ldr	r2, [r7, #12]
 80243ca:	4413      	add	r3, r2
 80243cc:	60fb      	str	r3, [r7, #12]
            (*i)++;
 80243ce:	683b      	ldr	r3, [r7, #0]
 80243d0:	681b      	ldr	r3, [r3, #0]
 80243d2:	1c5a      	adds	r2, r3, #1
 80243d4:	683b      	ldr	r3, [r7, #0]
 80243d6:	601a      	str	r2, [r3, #0]

            if(LV_IS_INVALID_UTF8_CODE(txt[*i])) return 0;
 80243d8:	683b      	ldr	r3, [r7, #0]
 80243da:	681b      	ldr	r3, [r3, #0]
 80243dc:	687a      	ldr	r2, [r7, #4]
 80243de:	4413      	add	r3, r2
 80243e0:	781b      	ldrb	r3, [r3, #0]
 80243e2:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 80243e6:	2b80      	cmp	r3, #128	@ 0x80
 80243e8:	d001      	beq.n	80243ee <lv_text_utf8_next+0x122>
 80243ea:	2300      	movs	r3, #0
 80243ec:	e07d      	b.n	80244ea <lv_text_utf8_next+0x21e>
            result += (txt[*i] & 0x3F);
 80243ee:	683b      	ldr	r3, [r7, #0]
 80243f0:	681b      	ldr	r3, [r3, #0]
 80243f2:	687a      	ldr	r2, [r7, #4]
 80243f4:	4413      	add	r3, r2
 80243f6:	781b      	ldrb	r3, [r3, #0]
 80243f8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 80243fc:	68fa      	ldr	r2, [r7, #12]
 80243fe:	4413      	add	r3, r2
 8024400:	60fb      	str	r3, [r7, #12]
            (*i)++;
 8024402:	683b      	ldr	r3, [r7, #0]
 8024404:	681b      	ldr	r3, [r3, #0]
 8024406:	1c5a      	adds	r2, r3, #1
 8024408:	683b      	ldr	r3, [r7, #0]
 802440a:	601a      	str	r2, [r3, #0]
 802440c:	e06c      	b.n	80244e8 <lv_text_utf8_next+0x21c>
        }
        /*4 bytes UTF-8 code*/
        else if(LV_IS_4BYTES_UTF8_CODE(txt[*i])) {
 802440e:	683b      	ldr	r3, [r7, #0]
 8024410:	681b      	ldr	r3, [r3, #0]
 8024412:	687a      	ldr	r2, [r7, #4]
 8024414:	4413      	add	r3, r2
 8024416:	781b      	ldrb	r3, [r3, #0]
 8024418:	f003 03f8 	and.w	r3, r3, #248	@ 0xf8
 802441c:	2bf0      	cmp	r3, #240	@ 0xf0
 802441e:	d15e      	bne.n	80244de <lv_text_utf8_next+0x212>
            result = (uint32_t)(txt[*i] & 0x07) << 18;
 8024420:	683b      	ldr	r3, [r7, #0]
 8024422:	681b      	ldr	r3, [r3, #0]
 8024424:	687a      	ldr	r2, [r7, #4]
 8024426:	4413      	add	r3, r2
 8024428:	781b      	ldrb	r3, [r3, #0]
 802442a:	049b      	lsls	r3, r3, #18
 802442c:	f403 13e0 	and.w	r3, r3, #1835008	@ 0x1c0000
 8024430:	60fb      	str	r3, [r7, #12]
            (*i)++;
 8024432:	683b      	ldr	r3, [r7, #0]
 8024434:	681b      	ldr	r3, [r3, #0]
 8024436:	1c5a      	adds	r2, r3, #1
 8024438:	683b      	ldr	r3, [r7, #0]
 802443a:	601a      	str	r2, [r3, #0]

            if(LV_IS_INVALID_UTF8_CODE(txt[*i])) return 0;
 802443c:	683b      	ldr	r3, [r7, #0]
 802443e:	681b      	ldr	r3, [r3, #0]
 8024440:	687a      	ldr	r2, [r7, #4]
 8024442:	4413      	add	r3, r2
 8024444:	781b      	ldrb	r3, [r3, #0]
 8024446:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 802444a:	2b80      	cmp	r3, #128	@ 0x80
 802444c:	d001      	beq.n	8024452 <lv_text_utf8_next+0x186>
 802444e:	2300      	movs	r3, #0
 8024450:	e04b      	b.n	80244ea <lv_text_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 12;
 8024452:	683b      	ldr	r3, [r7, #0]
 8024454:	681b      	ldr	r3, [r3, #0]
 8024456:	687a      	ldr	r2, [r7, #4]
 8024458:	4413      	add	r3, r2
 802445a:	781b      	ldrb	r3, [r3, #0]
 802445c:	031b      	lsls	r3, r3, #12
 802445e:	f403 337c 	and.w	r3, r3, #258048	@ 0x3f000
 8024462:	68fa      	ldr	r2, [r7, #12]
 8024464:	4413      	add	r3, r2
 8024466:	60fb      	str	r3, [r7, #12]
            (*i)++;
 8024468:	683b      	ldr	r3, [r7, #0]
 802446a:	681b      	ldr	r3, [r3, #0]
 802446c:	1c5a      	adds	r2, r3, #1
 802446e:	683b      	ldr	r3, [r7, #0]
 8024470:	601a      	str	r2, [r3, #0]

            if(LV_IS_INVALID_UTF8_CODE(txt[*i])) return 0;
 8024472:	683b      	ldr	r3, [r7, #0]
 8024474:	681b      	ldr	r3, [r3, #0]
 8024476:	687a      	ldr	r2, [r7, #4]
 8024478:	4413      	add	r3, r2
 802447a:	781b      	ldrb	r3, [r3, #0]
 802447c:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 8024480:	2b80      	cmp	r3, #128	@ 0x80
 8024482:	d001      	beq.n	8024488 <lv_text_utf8_next+0x1bc>
 8024484:	2300      	movs	r3, #0
 8024486:	e030      	b.n	80244ea <lv_text_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
 8024488:	683b      	ldr	r3, [r7, #0]
 802448a:	681b      	ldr	r3, [r3, #0]
 802448c:	687a      	ldr	r2, [r7, #4]
 802448e:	4413      	add	r3, r2
 8024490:	781b      	ldrb	r3, [r3, #0]
 8024492:	019b      	lsls	r3, r3, #6
 8024494:	f403 637c 	and.w	r3, r3, #4032	@ 0xfc0
 8024498:	68fa      	ldr	r2, [r7, #12]
 802449a:	4413      	add	r3, r2
 802449c:	60fb      	str	r3, [r7, #12]
            (*i)++;
 802449e:	683b      	ldr	r3, [r7, #0]
 80244a0:	681b      	ldr	r3, [r3, #0]
 80244a2:	1c5a      	adds	r2, r3, #1
 80244a4:	683b      	ldr	r3, [r7, #0]
 80244a6:	601a      	str	r2, [r3, #0]

            if(LV_IS_INVALID_UTF8_CODE(txt[*i])) return 0;
 80244a8:	683b      	ldr	r3, [r7, #0]
 80244aa:	681b      	ldr	r3, [r3, #0]
 80244ac:	687a      	ldr	r2, [r7, #4]
 80244ae:	4413      	add	r3, r2
 80244b0:	781b      	ldrb	r3, [r3, #0]
 80244b2:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
 80244b6:	2b80      	cmp	r3, #128	@ 0x80
 80244b8:	d001      	beq.n	80244be <lv_text_utf8_next+0x1f2>
 80244ba:	2300      	movs	r3, #0
 80244bc:	e015      	b.n	80244ea <lv_text_utf8_next+0x21e>
            result += txt[*i] & 0x3F;
 80244be:	683b      	ldr	r3, [r7, #0]
 80244c0:	681b      	ldr	r3, [r3, #0]
 80244c2:	687a      	ldr	r2, [r7, #4]
 80244c4:	4413      	add	r3, r2
 80244c6:	781b      	ldrb	r3, [r3, #0]
 80244c8:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 80244cc:	68fa      	ldr	r2, [r7, #12]
 80244ce:	4413      	add	r3, r2
 80244d0:	60fb      	str	r3, [r7, #12]
            (*i)++;
 80244d2:	683b      	ldr	r3, [r7, #0]
 80244d4:	681b      	ldr	r3, [r3, #0]
 80244d6:	1c5a      	adds	r2, r3, #1
 80244d8:	683b      	ldr	r3, [r7, #0]
 80244da:	601a      	str	r2, [r3, #0]
 80244dc:	e004      	b.n	80244e8 <lv_text_utf8_next+0x21c>
        }
        else {
            (*i)++; /*Not UTF-8 char. Go the next.*/
 80244de:	683b      	ldr	r3, [r7, #0]
 80244e0:	681b      	ldr	r3, [r3, #0]
 80244e2:	1c5a      	adds	r2, r3, #1
 80244e4:	683b      	ldr	r3, [r7, #0]
 80244e6:	601a      	str	r2, [r3, #0]
        }
    }
    return result;
 80244e8:	68fb      	ldr	r3, [r7, #12]
}
 80244ea:	4618      	mov	r0, r3
 80244ec:	3714      	adds	r7, #20
 80244ee:	46bd      	mov	sp, r7
 80244f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80244f4:	4770      	bx	lr
	...

080244f8 <lv_text_utf8_prev>:
 * @param i start byte index in 'txt' where to start. After the call it will point to the previous
 * UTF-8 char in 'txt'.
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_text_utf8_prev(const char * txt, uint32_t * i)
{
 80244f8:	b580      	push	{r7, lr}
 80244fa:	b086      	sub	sp, #24
 80244fc:	af00      	add	r7, sp, #0
 80244fe:	6078      	str	r0, [r7, #4]
 8024500:	6039      	str	r1, [r7, #0]
    uint8_t c_size;
    uint8_t cnt = 0;
 8024502:	2300      	movs	r3, #0
 8024504:	75fb      	strb	r3, [r7, #23]

    /*Try to find a !0 long UTF-8 char by stepping one character back*/
    (*i)--;
 8024506:	683b      	ldr	r3, [r7, #0]
 8024508:	681b      	ldr	r3, [r3, #0]
 802450a:	1e5a      	subs	r2, r3, #1
 802450c:	683b      	ldr	r3, [r7, #0]
 802450e:	601a      	str	r2, [r3, #0]
    do {
        if(cnt >= 4) return 0; /*No UTF-8 char found before the initial*/
 8024510:	7dfb      	ldrb	r3, [r7, #23]
 8024512:	2b03      	cmp	r3, #3
 8024514:	d901      	bls.n	802451a <lv_text_utf8_prev+0x22>
 8024516:	2300      	movs	r3, #0
 8024518:	e02a      	b.n	8024570 <lv_text_utf8_prev+0x78>

        c_size = _lv_text_encoded_size(&txt[*i]);
 802451a:	4b17      	ldr	r3, [pc, #92]	@ (8024578 <lv_text_utf8_prev+0x80>)
 802451c:	681b      	ldr	r3, [r3, #0]
 802451e:	683a      	ldr	r2, [r7, #0]
 8024520:	6812      	ldr	r2, [r2, #0]
 8024522:	6879      	ldr	r1, [r7, #4]
 8024524:	440a      	add	r2, r1
 8024526:	4610      	mov	r0, r2
 8024528:	4798      	blx	r3
 802452a:	4603      	mov	r3, r0
 802452c:	75bb      	strb	r3, [r7, #22]
        if(c_size == 0) {
 802452e:	7dbb      	ldrb	r3, [r7, #22]
 8024530:	2b00      	cmp	r3, #0
 8024532:	d10b      	bne.n	802454c <lv_text_utf8_prev+0x54>
            if(*i != 0)
 8024534:	683b      	ldr	r3, [r7, #0]
 8024536:	681b      	ldr	r3, [r3, #0]
 8024538:	2b00      	cmp	r3, #0
 802453a:	d005      	beq.n	8024548 <lv_text_utf8_prev+0x50>
                (*i)--;
 802453c:	683b      	ldr	r3, [r7, #0]
 802453e:	681b      	ldr	r3, [r3, #0]
 8024540:	1e5a      	subs	r2, r3, #1
 8024542:	683b      	ldr	r3, [r7, #0]
 8024544:	601a      	str	r2, [r3, #0]
 8024546:	e001      	b.n	802454c <lv_text_utf8_prev+0x54>
            else
                return 0;
 8024548:	2300      	movs	r3, #0
 802454a:	e011      	b.n	8024570 <lv_text_utf8_prev+0x78>
        }
        cnt++;
 802454c:	7dfb      	ldrb	r3, [r7, #23]
 802454e:	3301      	adds	r3, #1
 8024550:	75fb      	strb	r3, [r7, #23]
    } while(c_size == 0);
 8024552:	7dbb      	ldrb	r3, [r7, #22]
 8024554:	2b00      	cmp	r3, #0
 8024556:	d0db      	beq.n	8024510 <lv_text_utf8_prev+0x18>

    uint32_t i_tmp  = *i;
 8024558:	683b      	ldr	r3, [r7, #0]
 802455a:	681b      	ldr	r3, [r3, #0]
 802455c:	60fb      	str	r3, [r7, #12]
    uint32_t letter = _lv_text_encoded_next(txt, &i_tmp); /*Character found, get it*/
 802455e:	4b07      	ldr	r3, [pc, #28]	@ (802457c <lv_text_utf8_prev+0x84>)
 8024560:	681b      	ldr	r3, [r3, #0]
 8024562:	f107 020c 	add.w	r2, r7, #12
 8024566:	4611      	mov	r1, r2
 8024568:	6878      	ldr	r0, [r7, #4]
 802456a:	4798      	blx	r3
 802456c:	6138      	str	r0, [r7, #16]

    return letter;
 802456e:	693b      	ldr	r3, [r7, #16]
}
 8024570:	4618      	mov	r0, r3
 8024572:	3718      	adds	r7, #24
 8024574:	46bd      	mov	sp, r7
 8024576:	bd80      	pop	{r7, pc}
 8024578:	2000000c 	.word	0x2000000c
 802457c:	20000010 	.word	0x20000010

08024580 <lv_text_utf8_get_byte_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param utf8_id character index
 * @return byte index of the 'utf8_id'th letter
 */
static uint32_t lv_text_utf8_get_byte_id(const char * txt, uint32_t utf8_id)
{
 8024580:	b580      	push	{r7, lr}
 8024582:	b086      	sub	sp, #24
 8024584:	af00      	add	r7, sp, #0
 8024586:	6078      	str	r0, [r7, #4]
 8024588:	6039      	str	r1, [r7, #0]
    uint32_t i;
    uint32_t byte_cnt = 0;
 802458a:	2300      	movs	r3, #0
 802458c:	613b      	str	r3, [r7, #16]
    for(i = 0; i < utf8_id && txt[byte_cnt] != '\0'; i++) {
 802458e:	2300      	movs	r3, #0
 8024590:	617b      	str	r3, [r7, #20]
 8024592:	e014      	b.n	80245be <lv_text_utf8_get_byte_id+0x3e>
        uint8_t c_size = _lv_text_encoded_size(&txt[byte_cnt]);
 8024594:	4b11      	ldr	r3, [pc, #68]	@ (80245dc <lv_text_utf8_get_byte_id+0x5c>)
 8024596:	681b      	ldr	r3, [r3, #0]
 8024598:	6879      	ldr	r1, [r7, #4]
 802459a:	693a      	ldr	r2, [r7, #16]
 802459c:	440a      	add	r2, r1
 802459e:	4610      	mov	r0, r2
 80245a0:	4798      	blx	r3
 80245a2:	4603      	mov	r3, r0
 80245a4:	73fb      	strb	r3, [r7, #15]
        /* If the char was invalid tell it's 1 byte long*/
        byte_cnt += c_size ? c_size : 1;
 80245a6:	7bfb      	ldrb	r3, [r7, #15]
 80245a8:	2b00      	cmp	r3, #0
 80245aa:	d001      	beq.n	80245b0 <lv_text_utf8_get_byte_id+0x30>
 80245ac:	7bfb      	ldrb	r3, [r7, #15]
 80245ae:	e000      	b.n	80245b2 <lv_text_utf8_get_byte_id+0x32>
 80245b0:	2301      	movs	r3, #1
 80245b2:	693a      	ldr	r2, [r7, #16]
 80245b4:	4413      	add	r3, r2
 80245b6:	613b      	str	r3, [r7, #16]
    for(i = 0; i < utf8_id && txt[byte_cnt] != '\0'; i++) {
 80245b8:	697b      	ldr	r3, [r7, #20]
 80245ba:	3301      	adds	r3, #1
 80245bc:	617b      	str	r3, [r7, #20]
 80245be:	697a      	ldr	r2, [r7, #20]
 80245c0:	683b      	ldr	r3, [r7, #0]
 80245c2:	429a      	cmp	r2, r3
 80245c4:	d205      	bcs.n	80245d2 <lv_text_utf8_get_byte_id+0x52>
 80245c6:	687a      	ldr	r2, [r7, #4]
 80245c8:	693b      	ldr	r3, [r7, #16]
 80245ca:	4413      	add	r3, r2
 80245cc:	781b      	ldrb	r3, [r3, #0]
 80245ce:	2b00      	cmp	r3, #0
 80245d0:	d1e0      	bne.n	8024594 <lv_text_utf8_get_byte_id+0x14>
    }

    return byte_cnt;
 80245d2:	693b      	ldr	r3, [r7, #16]
}
 80245d4:	4618      	mov	r0, r3
 80245d6:	3718      	adds	r7, #24
 80245d8:	46bd      	mov	sp, r7
 80245da:	bd80      	pop	{r7, pc}
 80245dc:	2000000c 	.word	0x2000000c

080245e0 <lv_text_utf8_get_char_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param byte_id byte index
 * @return character index of the letter at 'byte_id'th position
 */
static uint32_t lv_text_utf8_get_char_id(const char * txt, uint32_t byte_id)
{
 80245e0:	b580      	push	{r7, lr}
 80245e2:	b084      	sub	sp, #16
 80245e4:	af00      	add	r7, sp, #0
 80245e6:	6078      	str	r0, [r7, #4]
 80245e8:	6039      	str	r1, [r7, #0]
    uint32_t i        = 0;
 80245ea:	2300      	movs	r3, #0
 80245ec:	60bb      	str	r3, [r7, #8]
    uint32_t char_cnt = 0;
 80245ee:	2300      	movs	r3, #0
 80245f0:	60fb      	str	r3, [r7, #12]

    while(i < byte_id) {
 80245f2:	e009      	b.n	8024608 <lv_text_utf8_get_char_id+0x28>
        _lv_text_encoded_next(txt, &i); /*'i' points to the next letter so use the prev. value*/
 80245f4:	4b09      	ldr	r3, [pc, #36]	@ (802461c <lv_text_utf8_get_char_id+0x3c>)
 80245f6:	681b      	ldr	r3, [r3, #0]
 80245f8:	f107 0208 	add.w	r2, r7, #8
 80245fc:	4611      	mov	r1, r2
 80245fe:	6878      	ldr	r0, [r7, #4]
 8024600:	4798      	blx	r3
        char_cnt++;
 8024602:	68fb      	ldr	r3, [r7, #12]
 8024604:	3301      	adds	r3, #1
 8024606:	60fb      	str	r3, [r7, #12]
    while(i < byte_id) {
 8024608:	68bb      	ldr	r3, [r7, #8]
 802460a:	683a      	ldr	r2, [r7, #0]
 802460c:	429a      	cmp	r2, r3
 802460e:	d8f1      	bhi.n	80245f4 <lv_text_utf8_get_char_id+0x14>
    }

    return char_cnt;
 8024610:	68fb      	ldr	r3, [r7, #12]
}
 8024612:	4618      	mov	r0, r3
 8024614:	3710      	adds	r7, #16
 8024616:	46bd      	mov	sp, r7
 8024618:	bd80      	pop	{r7, pc}
 802461a:	bf00      	nop
 802461c:	20000010 	.word	0x20000010

08024620 <lv_text_utf8_get_length>:
 * E.g.: "ÁBC" is 3 characters (but 4 bytes)
 * @param txt a '\0' terminated char string
 * @return number of characters
 */
static uint32_t lv_text_utf8_get_length(const char * txt)
{
 8024620:	b580      	push	{r7, lr}
 8024622:	b084      	sub	sp, #16
 8024624:	af00      	add	r7, sp, #0
 8024626:	6078      	str	r0, [r7, #4]
    uint32_t len = 0;
 8024628:	2300      	movs	r3, #0
 802462a:	60fb      	str	r3, [r7, #12]
    uint32_t i   = 0;
 802462c:	2300      	movs	r3, #0
 802462e:	60bb      	str	r3, [r7, #8]

    while(txt[i] != '\0') {
 8024630:	e009      	b.n	8024646 <lv_text_utf8_get_length+0x26>
        _lv_text_encoded_next(txt, &i);
 8024632:	4b0a      	ldr	r3, [pc, #40]	@ (802465c <lv_text_utf8_get_length+0x3c>)
 8024634:	681b      	ldr	r3, [r3, #0]
 8024636:	f107 0208 	add.w	r2, r7, #8
 802463a:	4611      	mov	r1, r2
 802463c:	6878      	ldr	r0, [r7, #4]
 802463e:	4798      	blx	r3
        len++;
 8024640:	68fb      	ldr	r3, [r7, #12]
 8024642:	3301      	adds	r3, #1
 8024644:	60fb      	str	r3, [r7, #12]
    while(txt[i] != '\0') {
 8024646:	68bb      	ldr	r3, [r7, #8]
 8024648:	687a      	ldr	r2, [r7, #4]
 802464a:	4413      	add	r3, r2
 802464c:	781b      	ldrb	r3, [r3, #0]
 802464e:	2b00      	cmp	r3, #0
 8024650:	d1ef      	bne.n	8024632 <lv_text_utf8_get_length+0x12>
    }

    return len;
 8024652:	68fb      	ldr	r3, [r7, #12]
}
 8024654:	4618      	mov	r0, r3
 8024656:	3710      	adds	r7, #16
 8024658:	46bd      	mov	sp, r7
 802465a:	bd80      	pop	{r7, pc}
 802465c:	20000010 	.word	0x20000010

08024660 <_lv_timer_core_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void _lv_timer_core_init(void)
{
 8024660:	b580      	push	{r7, lr}
 8024662:	af00      	add	r7, sp, #0
    _lv_ll_init(timer_ll_p, sizeof(lv_timer_t));
 8024664:	2118      	movs	r1, #24
 8024666:	4804      	ldr	r0, [pc, #16]	@ (8024678 <_lv_timer_core_init+0x18>)
 8024668:	f7fe fcd3 	bl	8023012 <_lv_ll_init>

    /*Initially enable the lv_timer handling*/
    lv_timer_enable(true);
 802466c:	2001      	movs	r0, #1
 802466e:	f000 f86f 	bl	8024750 <lv_timer_enable>
}
 8024672:	bf00      	nop
 8024674:	bd80      	pop	{r7, pc}
 8024676:	bf00      	nop
 8024678:	2000011c 	.word	0x2000011c

0802467c <lv_timer_create>:
{
    return lv_timer_create(NULL, DEF_PERIOD, NULL);
}

lv_timer_t * lv_timer_create(lv_timer_cb_t timer_xcb, uint32_t period, void * user_data)
{
 802467c:	b580      	push	{r7, lr}
 802467e:	b086      	sub	sp, #24
 8024680:	af00      	add	r7, sp, #0
 8024682:	60f8      	str	r0, [r7, #12]
 8024684:	60b9      	str	r1, [r7, #8]
 8024686:	607a      	str	r2, [r7, #4]
    lv_timer_t * new_timer = NULL;
 8024688:	2300      	movs	r3, #0
 802468a:	617b      	str	r3, [r7, #20]

    new_timer = _lv_ll_ins_head(timer_ll_p);
 802468c:	481a      	ldr	r0, [pc, #104]	@ (80246f8 <lv_timer_create+0x7c>)
 802468e:	f7fe fcd9 	bl	8023044 <_lv_ll_ins_head>
 8024692:	6178      	str	r0, [r7, #20]
    LV_ASSERT_MALLOC(new_timer);
 8024694:	697b      	ldr	r3, [r7, #20]
 8024696:	2b00      	cmp	r3, #0
 8024698:	d101      	bne.n	802469e <lv_timer_create+0x22>
 802469a:	bf00      	nop
 802469c:	e7fd      	b.n	802469a <lv_timer_create+0x1e>
    if(new_timer == NULL) return NULL;
 802469e:	697b      	ldr	r3, [r7, #20]
 80246a0:	2b00      	cmp	r3, #0
 80246a2:	d101      	bne.n	80246a8 <lv_timer_create+0x2c>
 80246a4:	2300      	movs	r3, #0
 80246a6:	e022      	b.n	80246ee <lv_timer_create+0x72>

    new_timer->period = period;
 80246a8:	697b      	ldr	r3, [r7, #20]
 80246aa:	68ba      	ldr	r2, [r7, #8]
 80246ac:	601a      	str	r2, [r3, #0]
    new_timer->timer_cb = timer_xcb;
 80246ae:	697b      	ldr	r3, [r7, #20]
 80246b0:	68fa      	ldr	r2, [r7, #12]
 80246b2:	609a      	str	r2, [r3, #8]
    new_timer->repeat_count = -1;
 80246b4:	697b      	ldr	r3, [r7, #20]
 80246b6:	f04f 32ff 	mov.w	r2, #4294967295
 80246ba:	611a      	str	r2, [r3, #16]
    new_timer->paused = 0;
 80246bc:	697a      	ldr	r2, [r7, #20]
 80246be:	7d13      	ldrb	r3, [r2, #20]
 80246c0:	f36f 0300 	bfc	r3, #0, #1
 80246c4:	7513      	strb	r3, [r2, #20]
    new_timer->last_run = lv_tick_get();
 80246c6:	f001 fc6d 	bl	8025fa4 <lv_tick_get>
 80246ca:	4602      	mov	r2, r0
 80246cc:	697b      	ldr	r3, [r7, #20]
 80246ce:	605a      	str	r2, [r3, #4]
    new_timer->user_data = user_data;
 80246d0:	697b      	ldr	r3, [r7, #20]
 80246d2:	687a      	ldr	r2, [r7, #4]
 80246d4:	60da      	str	r2, [r3, #12]
    new_timer->auto_delete = true;
 80246d6:	697a      	ldr	r2, [r7, #20]
 80246d8:	7d13      	ldrb	r3, [r2, #20]
 80246da:	f043 0302 	orr.w	r3, r3, #2
 80246de:	7513      	strb	r3, [r2, #20]

    state.timer_created = true;
 80246e0:	4b06      	ldr	r3, [pc, #24]	@ (80246fc <lv_timer_create+0x80>)
 80246e2:	2201      	movs	r2, #1
 80246e4:	f883 208f 	strb.w	r2, [r3, #143]	@ 0x8f

    lv_timer_handler_resume();
 80246e8:	f000 f846 	bl	8024778 <lv_timer_handler_resume>

    return new_timer;
 80246ec:	697b      	ldr	r3, [r7, #20]
}
 80246ee:	4618      	mov	r0, r3
 80246f0:	3718      	adds	r7, #24
 80246f2:	46bd      	mov	sp, r7
 80246f4:	bd80      	pop	{r7, pc}
 80246f6:	bf00      	nop
 80246f8:	2000011c 	.word	0x2000011c
 80246fc:	2000009c 	.word	0x2000009c

08024700 <lv_timer_pause>:

    lv_free(timer);
}

void lv_timer_pause(lv_timer_t * timer)
{
 8024700:	b480      	push	{r7}
 8024702:	b083      	sub	sp, #12
 8024704:	af00      	add	r7, sp, #0
 8024706:	6078      	str	r0, [r7, #4]
    LV_ASSERT_NULL(timer);
 8024708:	687b      	ldr	r3, [r7, #4]
 802470a:	2b00      	cmp	r3, #0
 802470c:	d101      	bne.n	8024712 <lv_timer_pause+0x12>
 802470e:	bf00      	nop
 8024710:	e7fd      	b.n	802470e <lv_timer_pause+0xe>
    timer->paused = true;
 8024712:	687a      	ldr	r2, [r7, #4]
 8024714:	7d13      	ldrb	r3, [r2, #20]
 8024716:	f043 0301 	orr.w	r3, r3, #1
 802471a:	7513      	strb	r3, [r2, #20]
}
 802471c:	bf00      	nop
 802471e:	370c      	adds	r7, #12
 8024720:	46bd      	mov	sp, r7
 8024722:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024726:	4770      	bx	lr

08024728 <lv_timer_resume>:

void lv_timer_resume(lv_timer_t * timer)
{
 8024728:	b580      	push	{r7, lr}
 802472a:	b082      	sub	sp, #8
 802472c:	af00      	add	r7, sp, #0
 802472e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_NULL(timer);
 8024730:	687b      	ldr	r3, [r7, #4]
 8024732:	2b00      	cmp	r3, #0
 8024734:	d101      	bne.n	802473a <lv_timer_resume+0x12>
 8024736:	bf00      	nop
 8024738:	e7fd      	b.n	8024736 <lv_timer_resume+0xe>
    timer->paused = false;
 802473a:	687a      	ldr	r2, [r7, #4]
 802473c:	7d13      	ldrb	r3, [r2, #20]
 802473e:	f36f 0300 	bfc	r3, #0, #1
 8024742:	7513      	strb	r3, [r2, #20]
    lv_timer_handler_resume();
 8024744:	f000 f818 	bl	8024778 <lv_timer_handler_resume>
}
 8024748:	bf00      	nop
 802474a:	3708      	adds	r7, #8
 802474c:	46bd      	mov	sp, r7
 802474e:	bd80      	pop	{r7, pc}

08024750 <lv_timer_enable>:
    timer->last_run = lv_tick_get();
    lv_timer_handler_resume();
}

void lv_timer_enable(bool en)
{
 8024750:	b580      	push	{r7, lr}
 8024752:	b082      	sub	sp, #8
 8024754:	af00      	add	r7, sp, #0
 8024756:	4603      	mov	r3, r0
 8024758:	71fb      	strb	r3, [r7, #7]
    state.lv_timer_run = en;
 802475a:	4a06      	ldr	r2, [pc, #24]	@ (8024774 <lv_timer_enable+0x24>)
 802475c:	79fb      	ldrb	r3, [r7, #7]
 802475e:	f882 308c 	strb.w	r3, [r2, #140]	@ 0x8c
    if(en) lv_timer_handler_resume();
 8024762:	79fb      	ldrb	r3, [r7, #7]
 8024764:	2b00      	cmp	r3, #0
 8024766:	d001      	beq.n	802476c <lv_timer_enable+0x1c>
 8024768:	f000 f806 	bl	8024778 <lv_timer_handler_resume>
}
 802476c:	bf00      	nop
 802476e:	3708      	adds	r7, #8
 8024770:	46bd      	mov	sp, r7
 8024772:	bd80      	pop	{r7, pc}
 8024774:	2000009c 	.word	0x2000009c

08024778 <lv_timer_handler_resume>:

/**
 * Call the ready lv_timer
 */
static void lv_timer_handler_resume(void)
{
 8024778:	b580      	push	{r7, lr}
 802477a:	af00      	add	r7, sp, #0
    /*If there is a timer which is ready to run then resume the timer loop*/
    state.timer_time_until_next = 0;
 802477c:	4b09      	ldr	r3, [pc, #36]	@ (80247a4 <lv_timer_handler_resume+0x2c>)
 802477e:	2200      	movs	r2, #0
 8024780:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    if(state.resume_cb) {
 8024784:	4b07      	ldr	r3, [pc, #28]	@ (80247a4 <lv_timer_handler_resume+0x2c>)
 8024786:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 802478a:	2b00      	cmp	r3, #0
 802478c:	d007      	beq.n	802479e <lv_timer_handler_resume+0x26>
        state.resume_cb(state.resume_data);
 802478e:	4b05      	ldr	r3, [pc, #20]	@ (80247a4 <lv_timer_handler_resume+0x2c>)
 8024790:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8024794:	4a03      	ldr	r2, [pc, #12]	@ (80247a4 <lv_timer_handler_resume+0x2c>)
 8024796:	f8d2 20ac 	ldr.w	r2, [r2, #172]	@ 0xac
 802479a:	4610      	mov	r0, r2
 802479c:	4798      	blx	r3
    }
}
 802479e:	bf00      	nop
 80247a0:	bd80      	pop	{r7, pc}
 80247a2:	bf00      	nop
 80247a4:	2000009c 	.word	0x2000009c

080247a8 <_lv_utils_bsearch>:
 *   GLOBAL FUNCTIONS
 **********************/

void * _lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,
                         int32_t (*cmp)(const void * pRef, const void * pElement))
{
 80247a8:	b580      	push	{r7, lr}
 80247aa:	b086      	sub	sp, #24
 80247ac:	af00      	add	r7, sp, #0
 80247ae:	60f8      	str	r0, [r7, #12]
 80247b0:	60b9      	str	r1, [r7, #8]
 80247b2:	607a      	str	r2, [r7, #4]
 80247b4:	603b      	str	r3, [r7, #0]
    const char * middle;
    int32_t c;

    for(middle = base; n != 0;) {
 80247b6:	68bb      	ldr	r3, [r7, #8]
 80247b8:	617b      	str	r3, [r7, #20]
 80247ba:	e02d      	b.n	8024818 <_lv_utils_bsearch+0x70>
        middle += (n / 2) * size;
 80247bc:	687b      	ldr	r3, [r7, #4]
 80247be:	085b      	lsrs	r3, r3, #1
 80247c0:	683a      	ldr	r2, [r7, #0]
 80247c2:	fb02 f303 	mul.w	r3, r2, r3
 80247c6:	697a      	ldr	r2, [r7, #20]
 80247c8:	4413      	add	r3, r2
 80247ca:	617b      	str	r3, [r7, #20]
        if((c = (*cmp)(key, middle)) > 0) {
 80247cc:	6a3b      	ldr	r3, [r7, #32]
 80247ce:	6979      	ldr	r1, [r7, #20]
 80247d0:	68f8      	ldr	r0, [r7, #12]
 80247d2:	4798      	blx	r3
 80247d4:	6138      	str	r0, [r7, #16]
 80247d6:	693b      	ldr	r3, [r7, #16]
 80247d8:	2b00      	cmp	r3, #0
 80247da:	dd12      	ble.n	8024802 <_lv_utils_bsearch+0x5a>
            n    = (n / 2) - ((n & 1) == 0);
 80247dc:	687b      	ldr	r3, [r7, #4]
 80247de:	085b      	lsrs	r3, r3, #1
 80247e0:	687a      	ldr	r2, [r7, #4]
 80247e2:	f002 0201 	and.w	r2, r2, #1
 80247e6:	2a00      	cmp	r2, #0
 80247e8:	bf0c      	ite	eq
 80247ea:	2201      	moveq	r2, #1
 80247ec:	2200      	movne	r2, #0
 80247ee:	b2d2      	uxtb	r2, r2
 80247f0:	1a9b      	subs	r3, r3, r2
 80247f2:	607b      	str	r3, [r7, #4]
            base = (middle += size);
 80247f4:	697a      	ldr	r2, [r7, #20]
 80247f6:	683b      	ldr	r3, [r7, #0]
 80247f8:	4413      	add	r3, r2
 80247fa:	617b      	str	r3, [r7, #20]
 80247fc:	697b      	ldr	r3, [r7, #20]
 80247fe:	60bb      	str	r3, [r7, #8]
 8024800:	e00a      	b.n	8024818 <_lv_utils_bsearch+0x70>
        }
        else if(c < 0) {
 8024802:	693b      	ldr	r3, [r7, #16]
 8024804:	2b00      	cmp	r3, #0
 8024806:	da05      	bge.n	8024814 <_lv_utils_bsearch+0x6c>
            n /= 2;
 8024808:	687b      	ldr	r3, [r7, #4]
 802480a:	085b      	lsrs	r3, r3, #1
 802480c:	607b      	str	r3, [r7, #4]
            middle = base;
 802480e:	68bb      	ldr	r3, [r7, #8]
 8024810:	617b      	str	r3, [r7, #20]
 8024812:	e001      	b.n	8024818 <_lv_utils_bsearch+0x70>
        }
        else {
            return (char *)middle;
 8024814:	697b      	ldr	r3, [r7, #20]
 8024816:	e003      	b.n	8024820 <_lv_utils_bsearch+0x78>
    for(middle = base; n != 0;) {
 8024818:	687b      	ldr	r3, [r7, #4]
 802481a:	2b00      	cmp	r3, #0
 802481c:	d1ce      	bne.n	80247bc <_lv_utils_bsearch+0x14>
        }
    }
    return NULL;
 802481e:	2300      	movs	r3, #0
}
 8024820:	4618      	mov	r0, r3
 8024822:	3718      	adds	r7, #24
 8024824:	46bd      	mov	sp, r7
 8024826:	bd80      	pop	{r7, pc}

08024828 <lv_mutex_init>:
    LV_ASSERT(0);
    return LV_RESULT_INVALID;
}

lv_result_t lv_mutex_init(lv_mutex_t * mutex)
{
 8024828:	b480      	push	{r7}
 802482a:	b083      	sub	sp, #12
 802482c:	af00      	add	r7, sp, #0
 802482e:	6078      	str	r0, [r7, #4]
    LV_UNUSED(mutex);
    return LV_RESULT_OK;
 8024830:	2301      	movs	r3, #1
}
 8024832:	4618      	mov	r0, r3
 8024834:	370c      	adds	r7, #12
 8024836:	46bd      	mov	sp, r7
 8024838:	f85d 7b04 	ldr.w	r7, [sp], #4
 802483c:	4770      	bx	lr

0802483e <lv_mutex_lock>:

lv_result_t lv_mutex_lock(lv_mutex_t * mutex)
{
 802483e:	b480      	push	{r7}
 8024840:	b083      	sub	sp, #12
 8024842:	af00      	add	r7, sp, #0
 8024844:	6078      	str	r0, [r7, #4]
    LV_UNUSED(mutex);
    return LV_RESULT_OK;
 8024846:	2301      	movs	r3, #1
}
 8024848:	4618      	mov	r0, r3
 802484a:	370c      	adds	r7, #12
 802484c:	46bd      	mov	sp, r7
 802484e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024852:	4770      	bx	lr

08024854 <lv_mutex_unlock>:
    LV_UNUSED(mutex);
    return LV_RESULT_OK;
}

lv_result_t lv_mutex_unlock(lv_mutex_t * mutex)
{
 8024854:	b480      	push	{r7}
 8024856:	b083      	sub	sp, #12
 8024858:	af00      	add	r7, sp, #0
 802485a:	6078      	str	r0, [r7, #4]
    LV_UNUSED(mutex);
    return LV_RESULT_OK;
 802485c:	2301      	movs	r3, #1
}
 802485e:	4618      	mov	r0, r3
 8024860:	370c      	adds	r7, #12
 8024862:	46bd      	mov	sp, r7
 8024864:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024868:	4770      	bx	lr
	...

0802486c <lv_mem_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_mem_init(void)
{
 802486c:	b580      	push	{r7, lr}
 802486e:	b082      	sub	sp, #8
 8024870:	af00      	add	r7, sp, #0
#ifdef LV_MEM_POOL_ALLOC
    state.tlsf = lv_tlsf_create_with_pool((void *)LV_MEM_POOL_ALLOC(LV_MEM_SIZE), LV_MEM_SIZE);
#else
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    state.tlsf = lv_tlsf_create_with_pool((void *)work_mem_int, LV_MEM_SIZE);
 8024872:	f44f 3180 	mov.w	r1, #65536	@ 0x10000
 8024876:	4810      	ldr	r0, [pc, #64]	@ (80248b8 <lv_mem_init+0x4c>)
 8024878:	f001 f99c 	bl	8025bb4 <lv_tlsf_create_with_pool>
 802487c:	4603      	mov	r3, r0
 802487e:	4a0f      	ldr	r2, [pc, #60]	@ (80248bc <lv_mem_init+0x50>)
 8024880:	f8c2 3184 	str.w	r3, [r2, #388]	@ 0x184
#endif
#else
    state.tlsf = lv_tlsf_create_with_pool((void *)LV_MEM_ADR, LV_MEM_SIZE);
#endif

    _lv_ll_init(&state.pool_ll, sizeof(lv_pool_t));
 8024884:	2104      	movs	r1, #4
 8024886:	480e      	ldr	r0, [pc, #56]	@ (80248c0 <lv_mem_init+0x54>)
 8024888:	f7fe fbc3 	bl	8023012 <_lv_ll_init>

    /*Record the first pool*/
    lv_pool_t * pool_p = _lv_ll_ins_tail(&state.pool_ll);
 802488c:	480c      	ldr	r0, [pc, #48]	@ (80248c0 <lv_mem_init+0x54>)
 802488e:	f7fe fc0d 	bl	80230ac <_lv_ll_ins_tail>
 8024892:	6078      	str	r0, [r7, #4]
    LV_ASSERT_MALLOC(pool_p);
 8024894:	687b      	ldr	r3, [r7, #4]
 8024896:	2b00      	cmp	r3, #0
 8024898:	d101      	bne.n	802489e <lv_mem_init+0x32>
 802489a:	bf00      	nop
 802489c:	e7fd      	b.n	802489a <lv_mem_init+0x2e>
    *pool_p = lv_tlsf_get_pool(state.tlsf);
 802489e:	4b07      	ldr	r3, [pc, #28]	@ (80248bc <lv_mem_init+0x50>)
 80248a0:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
 80248a4:	4618      	mov	r0, r3
 80248a6:	f001 f9a2 	bl	8025bee <lv_tlsf_get_pool>
 80248aa:	4602      	mov	r2, r0
 80248ac:	687b      	ldr	r3, [r7, #4]
 80248ae:	601a      	str	r2, [r3, #0]

#if LV_MEM_ADD_JUNK
    LV_LOG_WARN("LV_MEM_ADD_JUNK is enabled which makes LVGL much slower");
#endif
}
 80248b0:	bf00      	nop
 80248b2:	3708      	adds	r7, #8
 80248b4:	46bd      	mov	sp, r7
 80248b6:	bd80      	pop	{r7, pc}
 80248b8:	2000024c 	.word	0x2000024c
 80248bc:	2000009c 	.word	0x2000009c
 80248c0:	2000022c 	.word	0x2000022c

080248c4 <lv_malloc_core>:
    }
    LV_LOG_WARN("invalid pool: %p", pool);
}

void * lv_malloc_core(size_t size)
{
 80248c4:	b580      	push	{r7, lr}
 80248c6:	b084      	sub	sp, #16
 80248c8:	af00      	add	r7, sp, #0
 80248ca:	6078      	str	r0, [r7, #4]
#if LV_USE_OS
    lv_mutex_lock(&state.mutex);
#endif
    void * p = lv_tlsf_malloc(state.tlsf, size);
 80248cc:	4b13      	ldr	r3, [pc, #76]	@ (802491c <lv_malloc_core+0x58>)
 80248ce:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
 80248d2:	6879      	ldr	r1, [r7, #4]
 80248d4:	4618      	mov	r0, r3
 80248d6:	f001 f997 	bl	8025c08 <lv_tlsf_malloc>
 80248da:	60f8      	str	r0, [r7, #12]

    if(p) {
 80248dc:	68fb      	ldr	r3, [r7, #12]
 80248de:	2b00      	cmp	r3, #0
 80248e0:	d016      	beq.n	8024910 <lv_malloc_core+0x4c>
        state.cur_used += lv_tlsf_block_size(p);
 80248e2:	68f8      	ldr	r0, [r7, #12]
 80248e4:	f001 f8e0 	bl	8025aa8 <lv_tlsf_block_size>
 80248e8:	4602      	mov	r2, r0
 80248ea:	4b0c      	ldr	r3, [pc, #48]	@ (802491c <lv_malloc_core+0x58>)
 80248ec:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
 80248f0:	4413      	add	r3, r2
 80248f2:	4a0a      	ldr	r2, [pc, #40]	@ (802491c <lv_malloc_core+0x58>)
 80248f4:	f8c2 3188 	str.w	r3, [r2, #392]	@ 0x188
        state.max_used = LV_MAX(state.cur_used, state.max_used);
 80248f8:	4b08      	ldr	r3, [pc, #32]	@ (802491c <lv_malloc_core+0x58>)
 80248fa:	f8d3 218c 	ldr.w	r2, [r3, #396]	@ 0x18c
 80248fe:	4b07      	ldr	r3, [pc, #28]	@ (802491c <lv_malloc_core+0x58>)
 8024900:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
 8024904:	4293      	cmp	r3, r2
 8024906:	bf38      	it	cc
 8024908:	4613      	movcc	r3, r2
 802490a:	4a04      	ldr	r2, [pc, #16]	@ (802491c <lv_malloc_core+0x58>)
 802490c:	f8c2 318c 	str.w	r3, [r2, #396]	@ 0x18c
    }

#if LV_USE_OS
    lv_mutex_unlock(&state.mutex);
#endif
    return p;
 8024910:	68fb      	ldr	r3, [r7, #12]
}
 8024912:	4618      	mov	r0, r3
 8024914:	3710      	adds	r7, #16
 8024916:	46bd      	mov	sp, r7
 8024918:	bd80      	pop	{r7, pc}
 802491a:	bf00      	nop
 802491c:	2000009c 	.word	0x2000009c

08024920 <lv_realloc_core>:

void * lv_realloc_core(void * p, size_t new_size)
{
 8024920:	b580      	push	{r7, lr}
 8024922:	b084      	sub	sp, #16
 8024924:	af00      	add	r7, sp, #0
 8024926:	6078      	str	r0, [r7, #4]
 8024928:	6039      	str	r1, [r7, #0]
#if LV_USE_OS
    lv_mutex_lock(&state.mutex);
#endif

    size_t old_size = lv_tlsf_block_size(p);
 802492a:	6878      	ldr	r0, [r7, #4]
 802492c:	f001 f8bc 	bl	8025aa8 <lv_tlsf_block_size>
 8024930:	60f8      	str	r0, [r7, #12]
    void * p_new = lv_tlsf_realloc(state.tlsf, p, new_size);
 8024932:	4b18      	ldr	r3, [pc, #96]	@ (8024994 <lv_realloc_core+0x74>)
 8024934:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
 8024938:	683a      	ldr	r2, [r7, #0]
 802493a:	6879      	ldr	r1, [r7, #4]
 802493c:	4618      	mov	r0, r3
 802493e:	f001 f9af 	bl	8025ca0 <lv_tlsf_realloc>
 8024942:	60b8      	str	r0, [r7, #8]

    if(p_new) {
 8024944:	68bb      	ldr	r3, [r7, #8]
 8024946:	2b00      	cmp	r3, #0
 8024948:	d01e      	beq.n	8024988 <lv_realloc_core+0x68>
        state.cur_used -= old_size;
 802494a:	4b12      	ldr	r3, [pc, #72]	@ (8024994 <lv_realloc_core+0x74>)
 802494c:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
 8024950:	68fb      	ldr	r3, [r7, #12]
 8024952:	1ad3      	subs	r3, r2, r3
 8024954:	4a0f      	ldr	r2, [pc, #60]	@ (8024994 <lv_realloc_core+0x74>)
 8024956:	f8c2 3188 	str.w	r3, [r2, #392]	@ 0x188
        state.cur_used += lv_tlsf_block_size(p_new);
 802495a:	68b8      	ldr	r0, [r7, #8]
 802495c:	f001 f8a4 	bl	8025aa8 <lv_tlsf_block_size>
 8024960:	4602      	mov	r2, r0
 8024962:	4b0c      	ldr	r3, [pc, #48]	@ (8024994 <lv_realloc_core+0x74>)
 8024964:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
 8024968:	4413      	add	r3, r2
 802496a:	4a0a      	ldr	r2, [pc, #40]	@ (8024994 <lv_realloc_core+0x74>)
 802496c:	f8c2 3188 	str.w	r3, [r2, #392]	@ 0x188
        state.max_used = LV_MAX(state.cur_used, state.max_used);
 8024970:	4b08      	ldr	r3, [pc, #32]	@ (8024994 <lv_realloc_core+0x74>)
 8024972:	f8d3 218c 	ldr.w	r2, [r3, #396]	@ 0x18c
 8024976:	4b07      	ldr	r3, [pc, #28]	@ (8024994 <lv_realloc_core+0x74>)
 8024978:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
 802497c:	4293      	cmp	r3, r2
 802497e:	bf38      	it	cc
 8024980:	4613      	movcc	r3, r2
 8024982:	4a04      	ldr	r2, [pc, #16]	@ (8024994 <lv_realloc_core+0x74>)
 8024984:	f8c2 318c 	str.w	r3, [r2, #396]	@ 0x18c
    }
#if LV_USE_OS
    lv_mutex_unlock(&state.mutex);
#endif

    return p_new;
 8024988:	68bb      	ldr	r3, [r7, #8]
}
 802498a:	4618      	mov	r0, r3
 802498c:	3710      	adds	r7, #16
 802498e:	46bd      	mov	sp, r7
 8024990:	bd80      	pop	{r7, pc}
 8024992:	bf00      	nop
 8024994:	2000009c 	.word	0x2000009c

08024998 <lv_free_core>:

void lv_free_core(void * p)
{
 8024998:	b580      	push	{r7, lr}
 802499a:	b084      	sub	sp, #16
 802499c:	af00      	add	r7, sp, #0
 802499e:	6078      	str	r0, [r7, #4]
#endif

#if LV_MEM_ADD_JUNK
    lv_memset(p, 0xbb, lv_tlsf_block_size(data));
#endif
    size_t size = lv_tlsf_block_size(p);
 80249a0:	6878      	ldr	r0, [r7, #4]
 80249a2:	f001 f881 	bl	8025aa8 <lv_tlsf_block_size>
 80249a6:	60f8      	str	r0, [r7, #12]
    lv_tlsf_free(state.tlsf, p);
 80249a8:	4b0e      	ldr	r3, [pc, #56]	@ (80249e4 <lv_free_core+0x4c>)
 80249aa:	f8d3 3184 	ldr.w	r3, [r3, #388]	@ 0x184
 80249ae:	6879      	ldr	r1, [r7, #4]
 80249b0:	4618      	mov	r0, r3
 80249b2:	f001 f944 	bl	8025c3e <lv_tlsf_free>
    if(state.cur_used > size) state.cur_used -= size;
 80249b6:	4b0b      	ldr	r3, [pc, #44]	@ (80249e4 <lv_free_core+0x4c>)
 80249b8:	f8d3 3188 	ldr.w	r3, [r3, #392]	@ 0x188
 80249bc:	68fa      	ldr	r2, [r7, #12]
 80249be:	429a      	cmp	r2, r3
 80249c0:	d208      	bcs.n	80249d4 <lv_free_core+0x3c>
 80249c2:	4b08      	ldr	r3, [pc, #32]	@ (80249e4 <lv_free_core+0x4c>)
 80249c4:	f8d3 2188 	ldr.w	r2, [r3, #392]	@ 0x188
 80249c8:	68fb      	ldr	r3, [r7, #12]
 80249ca:	1ad3      	subs	r3, r2, r3
 80249cc:	4a05      	ldr	r2, [pc, #20]	@ (80249e4 <lv_free_core+0x4c>)
 80249ce:	f8c2 3188 	str.w	r3, [r2, #392]	@ 0x188
    else state.cur_used = 0;

#if LV_USE_OS
    lv_mutex_unlock(&state.mutex);
#endif
}
 80249d2:	e003      	b.n	80249dc <lv_free_core+0x44>
    else state.cur_used = 0;
 80249d4:	4b03      	ldr	r3, [pc, #12]	@ (80249e4 <lv_free_core+0x4c>)
 80249d6:	2200      	movs	r2, #0
 80249d8:	f8c3 2188 	str.w	r2, [r3, #392]	@ 0x188
}
 80249dc:	bf00      	nop
 80249de:	3710      	adds	r7, #16
 80249e0:	46bd      	mov	sp, r7
 80249e2:	bd80      	pop	{r7, pc}
 80249e4:	2000009c 	.word	0x2000009c

080249e8 <lv_memcpy>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void * LV_ATTRIBUTE_FAST_MEM lv_memcpy(void * dst, const void * src, size_t len)
{
 80249e8:	b480      	push	{r7}
 80249ea:	b08b      	sub	sp, #44	@ 0x2c
 80249ec:	af00      	add	r7, sp, #0
 80249ee:	60f8      	str	r0, [r7, #12]
 80249f0:	60b9      	str	r1, [r7, #8]
 80249f2:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = dst;
 80249f4:	68fb      	ldr	r3, [r7, #12]
 80249f6:	627b      	str	r3, [r7, #36]	@ 0x24
    const uint8_t * s8 = src;
 80249f8:	68bb      	ldr	r3, [r7, #8]
 80249fa:	623b      	str	r3, [r7, #32]

    /*Simplify for small memories*/
    if(len < 16) {
 80249fc:	687b      	ldr	r3, [r7, #4]
 80249fe:	2b0f      	cmp	r3, #15
 8024a00:	d812      	bhi.n	8024a28 <lv_memcpy+0x40>
        while(len) {
 8024a02:	e00c      	b.n	8024a1e <lv_memcpy+0x36>
            *d8 = *s8;
 8024a04:	6a3b      	ldr	r3, [r7, #32]
 8024a06:	781a      	ldrb	r2, [r3, #0]
 8024a08:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a0a:	701a      	strb	r2, [r3, #0]
            d8++;
 8024a0c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a0e:	3301      	adds	r3, #1
 8024a10:	627b      	str	r3, [r7, #36]	@ 0x24
            s8++;
 8024a12:	6a3b      	ldr	r3, [r7, #32]
 8024a14:	3301      	adds	r3, #1
 8024a16:	623b      	str	r3, [r7, #32]
            len--;
 8024a18:	687b      	ldr	r3, [r7, #4]
 8024a1a:	3b01      	subs	r3, #1
 8024a1c:	607b      	str	r3, [r7, #4]
        while(len) {
 8024a1e:	687b      	ldr	r3, [r7, #4]
 8024a20:	2b00      	cmp	r3, #0
 8024a22:	d1ef      	bne.n	8024a04 <lv_memcpy+0x1c>
        }
        return dst;
 8024a24:	68fb      	ldr	r3, [r7, #12]
 8024a26:	e1f6      	b.n	8024e16 <lv_memcpy+0x42e>
    }

    lv_uintptr_t d_align = (lv_uintptr_t)d8 & ALIGN_MASK;
 8024a28:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a2a:	f003 0303 	and.w	r3, r3, #3
 8024a2e:	61fb      	str	r3, [r7, #28]
    lv_uintptr_t s_align = (lv_uintptr_t)s8 & ALIGN_MASK;
 8024a30:	6a3b      	ldr	r3, [r7, #32]
 8024a32:	f003 0303 	and.w	r3, r3, #3
 8024a36:	613b      	str	r3, [r7, #16]

    /*Byte copy for unaligned memories*/
    if(s_align != d_align) {
 8024a38:	693a      	ldr	r2, [r7, #16]
 8024a3a:	69fb      	ldr	r3, [r7, #28]
 8024a3c:	429a      	cmp	r2, r3
 8024a3e:	f000 815b 	beq.w	8024cf8 <lv_memcpy+0x310>
        while(len > 32) {
 8024a42:	e142      	b.n	8024cca <lv_memcpy+0x2e2>
            _REPEAT8(_COPY(d8, s8));
 8024a44:	6a3b      	ldr	r3, [r7, #32]
 8024a46:	781a      	ldrb	r2, [r3, #0]
 8024a48:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a4a:	701a      	strb	r2, [r3, #0]
 8024a4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a4e:	3301      	adds	r3, #1
 8024a50:	627b      	str	r3, [r7, #36]	@ 0x24
 8024a52:	6a3b      	ldr	r3, [r7, #32]
 8024a54:	3301      	adds	r3, #1
 8024a56:	623b      	str	r3, [r7, #32]
 8024a58:	6a3b      	ldr	r3, [r7, #32]
 8024a5a:	781a      	ldrb	r2, [r3, #0]
 8024a5c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a5e:	701a      	strb	r2, [r3, #0]
 8024a60:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a62:	3301      	adds	r3, #1
 8024a64:	627b      	str	r3, [r7, #36]	@ 0x24
 8024a66:	6a3b      	ldr	r3, [r7, #32]
 8024a68:	3301      	adds	r3, #1
 8024a6a:	623b      	str	r3, [r7, #32]
 8024a6c:	6a3b      	ldr	r3, [r7, #32]
 8024a6e:	781a      	ldrb	r2, [r3, #0]
 8024a70:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a72:	701a      	strb	r2, [r3, #0]
 8024a74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a76:	3301      	adds	r3, #1
 8024a78:	627b      	str	r3, [r7, #36]	@ 0x24
 8024a7a:	6a3b      	ldr	r3, [r7, #32]
 8024a7c:	3301      	adds	r3, #1
 8024a7e:	623b      	str	r3, [r7, #32]
 8024a80:	6a3b      	ldr	r3, [r7, #32]
 8024a82:	781a      	ldrb	r2, [r3, #0]
 8024a84:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a86:	701a      	strb	r2, [r3, #0]
 8024a88:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a8a:	3301      	adds	r3, #1
 8024a8c:	627b      	str	r3, [r7, #36]	@ 0x24
 8024a8e:	6a3b      	ldr	r3, [r7, #32]
 8024a90:	3301      	adds	r3, #1
 8024a92:	623b      	str	r3, [r7, #32]
 8024a94:	6a3b      	ldr	r3, [r7, #32]
 8024a96:	781a      	ldrb	r2, [r3, #0]
 8024a98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a9a:	701a      	strb	r2, [r3, #0]
 8024a9c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024a9e:	3301      	adds	r3, #1
 8024aa0:	627b      	str	r3, [r7, #36]	@ 0x24
 8024aa2:	6a3b      	ldr	r3, [r7, #32]
 8024aa4:	3301      	adds	r3, #1
 8024aa6:	623b      	str	r3, [r7, #32]
 8024aa8:	6a3b      	ldr	r3, [r7, #32]
 8024aaa:	781a      	ldrb	r2, [r3, #0]
 8024aac:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024aae:	701a      	strb	r2, [r3, #0]
 8024ab0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024ab2:	3301      	adds	r3, #1
 8024ab4:	627b      	str	r3, [r7, #36]	@ 0x24
 8024ab6:	6a3b      	ldr	r3, [r7, #32]
 8024ab8:	3301      	adds	r3, #1
 8024aba:	623b      	str	r3, [r7, #32]
 8024abc:	6a3b      	ldr	r3, [r7, #32]
 8024abe:	781a      	ldrb	r2, [r3, #0]
 8024ac0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024ac2:	701a      	strb	r2, [r3, #0]
 8024ac4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024ac6:	3301      	adds	r3, #1
 8024ac8:	627b      	str	r3, [r7, #36]	@ 0x24
 8024aca:	6a3b      	ldr	r3, [r7, #32]
 8024acc:	3301      	adds	r3, #1
 8024ace:	623b      	str	r3, [r7, #32]
 8024ad0:	6a3b      	ldr	r3, [r7, #32]
 8024ad2:	781a      	ldrb	r2, [r3, #0]
 8024ad4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024ad6:	701a      	strb	r2, [r3, #0]
 8024ad8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024ada:	3301      	adds	r3, #1
 8024adc:	627b      	str	r3, [r7, #36]	@ 0x24
 8024ade:	6a3b      	ldr	r3, [r7, #32]
 8024ae0:	3301      	adds	r3, #1
 8024ae2:	623b      	str	r3, [r7, #32]
            _REPEAT8(_COPY(d8, s8));
 8024ae4:	6a3b      	ldr	r3, [r7, #32]
 8024ae6:	781a      	ldrb	r2, [r3, #0]
 8024ae8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024aea:	701a      	strb	r2, [r3, #0]
 8024aec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024aee:	3301      	adds	r3, #1
 8024af0:	627b      	str	r3, [r7, #36]	@ 0x24
 8024af2:	6a3b      	ldr	r3, [r7, #32]
 8024af4:	3301      	adds	r3, #1
 8024af6:	623b      	str	r3, [r7, #32]
 8024af8:	6a3b      	ldr	r3, [r7, #32]
 8024afa:	781a      	ldrb	r2, [r3, #0]
 8024afc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024afe:	701a      	strb	r2, [r3, #0]
 8024b00:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b02:	3301      	adds	r3, #1
 8024b04:	627b      	str	r3, [r7, #36]	@ 0x24
 8024b06:	6a3b      	ldr	r3, [r7, #32]
 8024b08:	3301      	adds	r3, #1
 8024b0a:	623b      	str	r3, [r7, #32]
 8024b0c:	6a3b      	ldr	r3, [r7, #32]
 8024b0e:	781a      	ldrb	r2, [r3, #0]
 8024b10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b12:	701a      	strb	r2, [r3, #0]
 8024b14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b16:	3301      	adds	r3, #1
 8024b18:	627b      	str	r3, [r7, #36]	@ 0x24
 8024b1a:	6a3b      	ldr	r3, [r7, #32]
 8024b1c:	3301      	adds	r3, #1
 8024b1e:	623b      	str	r3, [r7, #32]
 8024b20:	6a3b      	ldr	r3, [r7, #32]
 8024b22:	781a      	ldrb	r2, [r3, #0]
 8024b24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b26:	701a      	strb	r2, [r3, #0]
 8024b28:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b2a:	3301      	adds	r3, #1
 8024b2c:	627b      	str	r3, [r7, #36]	@ 0x24
 8024b2e:	6a3b      	ldr	r3, [r7, #32]
 8024b30:	3301      	adds	r3, #1
 8024b32:	623b      	str	r3, [r7, #32]
 8024b34:	6a3b      	ldr	r3, [r7, #32]
 8024b36:	781a      	ldrb	r2, [r3, #0]
 8024b38:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b3a:	701a      	strb	r2, [r3, #0]
 8024b3c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b3e:	3301      	adds	r3, #1
 8024b40:	627b      	str	r3, [r7, #36]	@ 0x24
 8024b42:	6a3b      	ldr	r3, [r7, #32]
 8024b44:	3301      	adds	r3, #1
 8024b46:	623b      	str	r3, [r7, #32]
 8024b48:	6a3b      	ldr	r3, [r7, #32]
 8024b4a:	781a      	ldrb	r2, [r3, #0]
 8024b4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b4e:	701a      	strb	r2, [r3, #0]
 8024b50:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b52:	3301      	adds	r3, #1
 8024b54:	627b      	str	r3, [r7, #36]	@ 0x24
 8024b56:	6a3b      	ldr	r3, [r7, #32]
 8024b58:	3301      	adds	r3, #1
 8024b5a:	623b      	str	r3, [r7, #32]
 8024b5c:	6a3b      	ldr	r3, [r7, #32]
 8024b5e:	781a      	ldrb	r2, [r3, #0]
 8024b60:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b62:	701a      	strb	r2, [r3, #0]
 8024b64:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b66:	3301      	adds	r3, #1
 8024b68:	627b      	str	r3, [r7, #36]	@ 0x24
 8024b6a:	6a3b      	ldr	r3, [r7, #32]
 8024b6c:	3301      	adds	r3, #1
 8024b6e:	623b      	str	r3, [r7, #32]
 8024b70:	6a3b      	ldr	r3, [r7, #32]
 8024b72:	781a      	ldrb	r2, [r3, #0]
 8024b74:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b76:	701a      	strb	r2, [r3, #0]
 8024b78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b7a:	3301      	adds	r3, #1
 8024b7c:	627b      	str	r3, [r7, #36]	@ 0x24
 8024b7e:	6a3b      	ldr	r3, [r7, #32]
 8024b80:	3301      	adds	r3, #1
 8024b82:	623b      	str	r3, [r7, #32]
            _REPEAT8(_COPY(d8, s8));
 8024b84:	6a3b      	ldr	r3, [r7, #32]
 8024b86:	781a      	ldrb	r2, [r3, #0]
 8024b88:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b8a:	701a      	strb	r2, [r3, #0]
 8024b8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b8e:	3301      	adds	r3, #1
 8024b90:	627b      	str	r3, [r7, #36]	@ 0x24
 8024b92:	6a3b      	ldr	r3, [r7, #32]
 8024b94:	3301      	adds	r3, #1
 8024b96:	623b      	str	r3, [r7, #32]
 8024b98:	6a3b      	ldr	r3, [r7, #32]
 8024b9a:	781a      	ldrb	r2, [r3, #0]
 8024b9c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024b9e:	701a      	strb	r2, [r3, #0]
 8024ba0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024ba2:	3301      	adds	r3, #1
 8024ba4:	627b      	str	r3, [r7, #36]	@ 0x24
 8024ba6:	6a3b      	ldr	r3, [r7, #32]
 8024ba8:	3301      	adds	r3, #1
 8024baa:	623b      	str	r3, [r7, #32]
 8024bac:	6a3b      	ldr	r3, [r7, #32]
 8024bae:	781a      	ldrb	r2, [r3, #0]
 8024bb0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024bb2:	701a      	strb	r2, [r3, #0]
 8024bb4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024bb6:	3301      	adds	r3, #1
 8024bb8:	627b      	str	r3, [r7, #36]	@ 0x24
 8024bba:	6a3b      	ldr	r3, [r7, #32]
 8024bbc:	3301      	adds	r3, #1
 8024bbe:	623b      	str	r3, [r7, #32]
 8024bc0:	6a3b      	ldr	r3, [r7, #32]
 8024bc2:	781a      	ldrb	r2, [r3, #0]
 8024bc4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024bc6:	701a      	strb	r2, [r3, #0]
 8024bc8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024bca:	3301      	adds	r3, #1
 8024bcc:	627b      	str	r3, [r7, #36]	@ 0x24
 8024bce:	6a3b      	ldr	r3, [r7, #32]
 8024bd0:	3301      	adds	r3, #1
 8024bd2:	623b      	str	r3, [r7, #32]
 8024bd4:	6a3b      	ldr	r3, [r7, #32]
 8024bd6:	781a      	ldrb	r2, [r3, #0]
 8024bd8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024bda:	701a      	strb	r2, [r3, #0]
 8024bdc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024bde:	3301      	adds	r3, #1
 8024be0:	627b      	str	r3, [r7, #36]	@ 0x24
 8024be2:	6a3b      	ldr	r3, [r7, #32]
 8024be4:	3301      	adds	r3, #1
 8024be6:	623b      	str	r3, [r7, #32]
 8024be8:	6a3b      	ldr	r3, [r7, #32]
 8024bea:	781a      	ldrb	r2, [r3, #0]
 8024bec:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024bee:	701a      	strb	r2, [r3, #0]
 8024bf0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024bf2:	3301      	adds	r3, #1
 8024bf4:	627b      	str	r3, [r7, #36]	@ 0x24
 8024bf6:	6a3b      	ldr	r3, [r7, #32]
 8024bf8:	3301      	adds	r3, #1
 8024bfa:	623b      	str	r3, [r7, #32]
 8024bfc:	6a3b      	ldr	r3, [r7, #32]
 8024bfe:	781a      	ldrb	r2, [r3, #0]
 8024c00:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c02:	701a      	strb	r2, [r3, #0]
 8024c04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c06:	3301      	adds	r3, #1
 8024c08:	627b      	str	r3, [r7, #36]	@ 0x24
 8024c0a:	6a3b      	ldr	r3, [r7, #32]
 8024c0c:	3301      	adds	r3, #1
 8024c0e:	623b      	str	r3, [r7, #32]
 8024c10:	6a3b      	ldr	r3, [r7, #32]
 8024c12:	781a      	ldrb	r2, [r3, #0]
 8024c14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c16:	701a      	strb	r2, [r3, #0]
 8024c18:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c1a:	3301      	adds	r3, #1
 8024c1c:	627b      	str	r3, [r7, #36]	@ 0x24
 8024c1e:	6a3b      	ldr	r3, [r7, #32]
 8024c20:	3301      	adds	r3, #1
 8024c22:	623b      	str	r3, [r7, #32]
            _REPEAT8(_COPY(d8, s8));
 8024c24:	6a3b      	ldr	r3, [r7, #32]
 8024c26:	781a      	ldrb	r2, [r3, #0]
 8024c28:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c2a:	701a      	strb	r2, [r3, #0]
 8024c2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c2e:	3301      	adds	r3, #1
 8024c30:	627b      	str	r3, [r7, #36]	@ 0x24
 8024c32:	6a3b      	ldr	r3, [r7, #32]
 8024c34:	3301      	adds	r3, #1
 8024c36:	623b      	str	r3, [r7, #32]
 8024c38:	6a3b      	ldr	r3, [r7, #32]
 8024c3a:	781a      	ldrb	r2, [r3, #0]
 8024c3c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c3e:	701a      	strb	r2, [r3, #0]
 8024c40:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c42:	3301      	adds	r3, #1
 8024c44:	627b      	str	r3, [r7, #36]	@ 0x24
 8024c46:	6a3b      	ldr	r3, [r7, #32]
 8024c48:	3301      	adds	r3, #1
 8024c4a:	623b      	str	r3, [r7, #32]
 8024c4c:	6a3b      	ldr	r3, [r7, #32]
 8024c4e:	781a      	ldrb	r2, [r3, #0]
 8024c50:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c52:	701a      	strb	r2, [r3, #0]
 8024c54:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c56:	3301      	adds	r3, #1
 8024c58:	627b      	str	r3, [r7, #36]	@ 0x24
 8024c5a:	6a3b      	ldr	r3, [r7, #32]
 8024c5c:	3301      	adds	r3, #1
 8024c5e:	623b      	str	r3, [r7, #32]
 8024c60:	6a3b      	ldr	r3, [r7, #32]
 8024c62:	781a      	ldrb	r2, [r3, #0]
 8024c64:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c66:	701a      	strb	r2, [r3, #0]
 8024c68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c6a:	3301      	adds	r3, #1
 8024c6c:	627b      	str	r3, [r7, #36]	@ 0x24
 8024c6e:	6a3b      	ldr	r3, [r7, #32]
 8024c70:	3301      	adds	r3, #1
 8024c72:	623b      	str	r3, [r7, #32]
 8024c74:	6a3b      	ldr	r3, [r7, #32]
 8024c76:	781a      	ldrb	r2, [r3, #0]
 8024c78:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c7a:	701a      	strb	r2, [r3, #0]
 8024c7c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c7e:	3301      	adds	r3, #1
 8024c80:	627b      	str	r3, [r7, #36]	@ 0x24
 8024c82:	6a3b      	ldr	r3, [r7, #32]
 8024c84:	3301      	adds	r3, #1
 8024c86:	623b      	str	r3, [r7, #32]
 8024c88:	6a3b      	ldr	r3, [r7, #32]
 8024c8a:	781a      	ldrb	r2, [r3, #0]
 8024c8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c8e:	701a      	strb	r2, [r3, #0]
 8024c90:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024c92:	3301      	adds	r3, #1
 8024c94:	627b      	str	r3, [r7, #36]	@ 0x24
 8024c96:	6a3b      	ldr	r3, [r7, #32]
 8024c98:	3301      	adds	r3, #1
 8024c9a:	623b      	str	r3, [r7, #32]
 8024c9c:	6a3b      	ldr	r3, [r7, #32]
 8024c9e:	781a      	ldrb	r2, [r3, #0]
 8024ca0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024ca2:	701a      	strb	r2, [r3, #0]
 8024ca4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024ca6:	3301      	adds	r3, #1
 8024ca8:	627b      	str	r3, [r7, #36]	@ 0x24
 8024caa:	6a3b      	ldr	r3, [r7, #32]
 8024cac:	3301      	adds	r3, #1
 8024cae:	623b      	str	r3, [r7, #32]
 8024cb0:	6a3b      	ldr	r3, [r7, #32]
 8024cb2:	781a      	ldrb	r2, [r3, #0]
 8024cb4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024cb6:	701a      	strb	r2, [r3, #0]
 8024cb8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024cba:	3301      	adds	r3, #1
 8024cbc:	627b      	str	r3, [r7, #36]	@ 0x24
 8024cbe:	6a3b      	ldr	r3, [r7, #32]
 8024cc0:	3301      	adds	r3, #1
 8024cc2:	623b      	str	r3, [r7, #32]
            len -= 32;
 8024cc4:	687b      	ldr	r3, [r7, #4]
 8024cc6:	3b20      	subs	r3, #32
 8024cc8:	607b      	str	r3, [r7, #4]
        while(len > 32) {
 8024cca:	687b      	ldr	r3, [r7, #4]
 8024ccc:	2b20      	cmp	r3, #32
 8024cce:	f63f aeb9 	bhi.w	8024a44 <lv_memcpy+0x5c>
        }
        while(len) {
 8024cd2:	e00c      	b.n	8024cee <lv_memcpy+0x306>
            _COPY(d8, s8)
 8024cd4:	6a3b      	ldr	r3, [r7, #32]
 8024cd6:	781a      	ldrb	r2, [r3, #0]
 8024cd8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024cda:	701a      	strb	r2, [r3, #0]
 8024cdc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024cde:	3301      	adds	r3, #1
 8024ce0:	627b      	str	r3, [r7, #36]	@ 0x24
 8024ce2:	6a3b      	ldr	r3, [r7, #32]
 8024ce4:	3301      	adds	r3, #1
 8024ce6:	623b      	str	r3, [r7, #32]
            len--;
 8024ce8:	687b      	ldr	r3, [r7, #4]
 8024cea:	3b01      	subs	r3, #1
 8024cec:	607b      	str	r3, [r7, #4]
        while(len) {
 8024cee:	687b      	ldr	r3, [r7, #4]
 8024cf0:	2b00      	cmp	r3, #0
 8024cf2:	d1ef      	bne.n	8024cd4 <lv_memcpy+0x2ec>
        }
        return dst;
 8024cf4:	68fb      	ldr	r3, [r7, #12]
 8024cf6:	e08e      	b.n	8024e16 <lv_memcpy+0x42e>
    }

    /*Make the memories aligned*/
    if(d_align) {
 8024cf8:	69fb      	ldr	r3, [r7, #28]
 8024cfa:	2b00      	cmp	r3, #0
 8024cfc:	d01a      	beq.n	8024d34 <lv_memcpy+0x34c>
        d_align = ALIGN_MASK + 1 - d_align;
 8024cfe:	69fb      	ldr	r3, [r7, #28]
 8024d00:	f1c3 0304 	rsb	r3, r3, #4
 8024d04:	61fb      	str	r3, [r7, #28]
        while(d_align && len) {
 8024d06:	e00f      	b.n	8024d28 <lv_memcpy+0x340>
            _COPY(d8, s8);
 8024d08:	6a3b      	ldr	r3, [r7, #32]
 8024d0a:	781a      	ldrb	r2, [r3, #0]
 8024d0c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024d0e:	701a      	strb	r2, [r3, #0]
 8024d10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024d12:	3301      	adds	r3, #1
 8024d14:	627b      	str	r3, [r7, #36]	@ 0x24
 8024d16:	6a3b      	ldr	r3, [r7, #32]
 8024d18:	3301      	adds	r3, #1
 8024d1a:	623b      	str	r3, [r7, #32]
            d_align--;
 8024d1c:	69fb      	ldr	r3, [r7, #28]
 8024d1e:	3b01      	subs	r3, #1
 8024d20:	61fb      	str	r3, [r7, #28]
            len--;
 8024d22:	687b      	ldr	r3, [r7, #4]
 8024d24:	3b01      	subs	r3, #1
 8024d26:	607b      	str	r3, [r7, #4]
        while(d_align && len) {
 8024d28:	69fb      	ldr	r3, [r7, #28]
 8024d2a:	2b00      	cmp	r3, #0
 8024d2c:	d002      	beq.n	8024d34 <lv_memcpy+0x34c>
 8024d2e:	687b      	ldr	r3, [r7, #4]
 8024d30:	2b00      	cmp	r3, #0
 8024d32:	d1e9      	bne.n	8024d08 <lv_memcpy+0x320>
        }
    }

    uint32_t * d32 = (uint32_t *)d8;
 8024d34:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024d36:	61bb      	str	r3, [r7, #24]
    const uint32_t * s32 = (uint32_t *)s8;
 8024d38:	6a3b      	ldr	r3, [r7, #32]
 8024d3a:	617b      	str	r3, [r7, #20]
    while(len > 32) {
 8024d3c:	e052      	b.n	8024de4 <lv_memcpy+0x3fc>
        _REPEAT8(_COPY(d32, s32))
 8024d3e:	697b      	ldr	r3, [r7, #20]
 8024d40:	681a      	ldr	r2, [r3, #0]
 8024d42:	69bb      	ldr	r3, [r7, #24]
 8024d44:	601a      	str	r2, [r3, #0]
 8024d46:	69bb      	ldr	r3, [r7, #24]
 8024d48:	3304      	adds	r3, #4
 8024d4a:	61bb      	str	r3, [r7, #24]
 8024d4c:	697b      	ldr	r3, [r7, #20]
 8024d4e:	3304      	adds	r3, #4
 8024d50:	617b      	str	r3, [r7, #20]
 8024d52:	697b      	ldr	r3, [r7, #20]
 8024d54:	681a      	ldr	r2, [r3, #0]
 8024d56:	69bb      	ldr	r3, [r7, #24]
 8024d58:	601a      	str	r2, [r3, #0]
 8024d5a:	69bb      	ldr	r3, [r7, #24]
 8024d5c:	3304      	adds	r3, #4
 8024d5e:	61bb      	str	r3, [r7, #24]
 8024d60:	697b      	ldr	r3, [r7, #20]
 8024d62:	3304      	adds	r3, #4
 8024d64:	617b      	str	r3, [r7, #20]
 8024d66:	697b      	ldr	r3, [r7, #20]
 8024d68:	681a      	ldr	r2, [r3, #0]
 8024d6a:	69bb      	ldr	r3, [r7, #24]
 8024d6c:	601a      	str	r2, [r3, #0]
 8024d6e:	69bb      	ldr	r3, [r7, #24]
 8024d70:	3304      	adds	r3, #4
 8024d72:	61bb      	str	r3, [r7, #24]
 8024d74:	697b      	ldr	r3, [r7, #20]
 8024d76:	3304      	adds	r3, #4
 8024d78:	617b      	str	r3, [r7, #20]
 8024d7a:	697b      	ldr	r3, [r7, #20]
 8024d7c:	681a      	ldr	r2, [r3, #0]
 8024d7e:	69bb      	ldr	r3, [r7, #24]
 8024d80:	601a      	str	r2, [r3, #0]
 8024d82:	69bb      	ldr	r3, [r7, #24]
 8024d84:	3304      	adds	r3, #4
 8024d86:	61bb      	str	r3, [r7, #24]
 8024d88:	697b      	ldr	r3, [r7, #20]
 8024d8a:	3304      	adds	r3, #4
 8024d8c:	617b      	str	r3, [r7, #20]
 8024d8e:	697b      	ldr	r3, [r7, #20]
 8024d90:	681a      	ldr	r2, [r3, #0]
 8024d92:	69bb      	ldr	r3, [r7, #24]
 8024d94:	601a      	str	r2, [r3, #0]
 8024d96:	69bb      	ldr	r3, [r7, #24]
 8024d98:	3304      	adds	r3, #4
 8024d9a:	61bb      	str	r3, [r7, #24]
 8024d9c:	697b      	ldr	r3, [r7, #20]
 8024d9e:	3304      	adds	r3, #4
 8024da0:	617b      	str	r3, [r7, #20]
 8024da2:	697b      	ldr	r3, [r7, #20]
 8024da4:	681a      	ldr	r2, [r3, #0]
 8024da6:	69bb      	ldr	r3, [r7, #24]
 8024da8:	601a      	str	r2, [r3, #0]
 8024daa:	69bb      	ldr	r3, [r7, #24]
 8024dac:	3304      	adds	r3, #4
 8024dae:	61bb      	str	r3, [r7, #24]
 8024db0:	697b      	ldr	r3, [r7, #20]
 8024db2:	3304      	adds	r3, #4
 8024db4:	617b      	str	r3, [r7, #20]
 8024db6:	697b      	ldr	r3, [r7, #20]
 8024db8:	681a      	ldr	r2, [r3, #0]
 8024dba:	69bb      	ldr	r3, [r7, #24]
 8024dbc:	601a      	str	r2, [r3, #0]
 8024dbe:	69bb      	ldr	r3, [r7, #24]
 8024dc0:	3304      	adds	r3, #4
 8024dc2:	61bb      	str	r3, [r7, #24]
 8024dc4:	697b      	ldr	r3, [r7, #20]
 8024dc6:	3304      	adds	r3, #4
 8024dc8:	617b      	str	r3, [r7, #20]
 8024dca:	697b      	ldr	r3, [r7, #20]
 8024dcc:	681a      	ldr	r2, [r3, #0]
 8024dce:	69bb      	ldr	r3, [r7, #24]
 8024dd0:	601a      	str	r2, [r3, #0]
 8024dd2:	69bb      	ldr	r3, [r7, #24]
 8024dd4:	3304      	adds	r3, #4
 8024dd6:	61bb      	str	r3, [r7, #24]
 8024dd8:	697b      	ldr	r3, [r7, #20]
 8024dda:	3304      	adds	r3, #4
 8024ddc:	617b      	str	r3, [r7, #20]
        len -= 32;
 8024dde:	687b      	ldr	r3, [r7, #4]
 8024de0:	3b20      	subs	r3, #32
 8024de2:	607b      	str	r3, [r7, #4]
    while(len > 32) {
 8024de4:	687b      	ldr	r3, [r7, #4]
 8024de6:	2b20      	cmp	r3, #32
 8024de8:	d8a9      	bhi.n	8024d3e <lv_memcpy+0x356>
    }

    d8 = (uint8_t *)d32;
 8024dea:	69bb      	ldr	r3, [r7, #24]
 8024dec:	627b      	str	r3, [r7, #36]	@ 0x24
    s8 = (const uint8_t *)s32;
 8024dee:	697b      	ldr	r3, [r7, #20]
 8024df0:	623b      	str	r3, [r7, #32]
    while(len) {
 8024df2:	e00c      	b.n	8024e0e <lv_memcpy+0x426>
        _COPY(d8, s8)
 8024df4:	6a3b      	ldr	r3, [r7, #32]
 8024df6:	781a      	ldrb	r2, [r3, #0]
 8024df8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024dfa:	701a      	strb	r2, [r3, #0]
 8024dfc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8024dfe:	3301      	adds	r3, #1
 8024e00:	627b      	str	r3, [r7, #36]	@ 0x24
 8024e02:	6a3b      	ldr	r3, [r7, #32]
 8024e04:	3301      	adds	r3, #1
 8024e06:	623b      	str	r3, [r7, #32]
        len--;
 8024e08:	687b      	ldr	r3, [r7, #4]
 8024e0a:	3b01      	subs	r3, #1
 8024e0c:	607b      	str	r3, [r7, #4]
    while(len) {
 8024e0e:	687b      	ldr	r3, [r7, #4]
 8024e10:	2b00      	cmp	r3, #0
 8024e12:	d1ef      	bne.n	8024df4 <lv_memcpy+0x40c>
    }

    return dst;
 8024e14:	68fb      	ldr	r3, [r7, #12]
}
 8024e16:	4618      	mov	r0, r3
 8024e18:	372c      	adds	r7, #44	@ 0x2c
 8024e1a:	46bd      	mov	sp, r7
 8024e1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024e20:	4770      	bx	lr

08024e22 <lv_memset>:

void LV_ATTRIBUTE_FAST_MEM lv_memset(void * dst, uint8_t v, size_t len)
{
 8024e22:	b480      	push	{r7}
 8024e24:	b089      	sub	sp, #36	@ 0x24
 8024e26:	af00      	add	r7, sp, #0
 8024e28:	60f8      	str	r0, [r7, #12]
 8024e2a:	460b      	mov	r3, r1
 8024e2c:	607a      	str	r2, [r7, #4]
 8024e2e:	72fb      	strb	r3, [r7, #11]
    uint8_t * d8 = (uint8_t *)dst;
 8024e30:	68fb      	ldr	r3, [r7, #12]
 8024e32:	61fb      	str	r3, [r7, #28]
    uintptr_t d_align = (lv_uintptr_t) d8 & ALIGN_MASK;
 8024e34:	69fb      	ldr	r3, [r7, #28]
 8024e36:	f003 0303 	and.w	r3, r3, #3
 8024e3a:	61bb      	str	r3, [r7, #24]

    /*Make the address aligned*/
    if(d_align) {
 8024e3c:	69bb      	ldr	r3, [r7, #24]
 8024e3e:	2b00      	cmp	r3, #0
 8024e40:	d016      	beq.n	8024e70 <lv_memset+0x4e>
        d_align = ALIGN_MASK + 1 - d_align;
 8024e42:	69bb      	ldr	r3, [r7, #24]
 8024e44:	f1c3 0304 	rsb	r3, r3, #4
 8024e48:	61bb      	str	r3, [r7, #24]
        while(d_align && len) {
 8024e4a:	e00b      	b.n	8024e64 <lv_memset+0x42>
            _SET(d8, v);
 8024e4c:	69fb      	ldr	r3, [r7, #28]
 8024e4e:	7afa      	ldrb	r2, [r7, #11]
 8024e50:	701a      	strb	r2, [r3, #0]
 8024e52:	69fb      	ldr	r3, [r7, #28]
 8024e54:	3301      	adds	r3, #1
 8024e56:	61fb      	str	r3, [r7, #28]
            len--;
 8024e58:	687b      	ldr	r3, [r7, #4]
 8024e5a:	3b01      	subs	r3, #1
 8024e5c:	607b      	str	r3, [r7, #4]
            d_align--;
 8024e5e:	69bb      	ldr	r3, [r7, #24]
 8024e60:	3b01      	subs	r3, #1
 8024e62:	61bb      	str	r3, [r7, #24]
        while(d_align && len) {
 8024e64:	69bb      	ldr	r3, [r7, #24]
 8024e66:	2b00      	cmp	r3, #0
 8024e68:	d002      	beq.n	8024e70 <lv_memset+0x4e>
 8024e6a:	687b      	ldr	r3, [r7, #4]
 8024e6c:	2b00      	cmp	r3, #0
 8024e6e:	d1ed      	bne.n	8024e4c <lv_memset+0x2a>
        }
    }

    uint32_t v32 = (uint32_t)v + ((uint32_t)v << 8) + ((uint32_t)v << 16) + ((uint32_t)v << 24);
 8024e70:	7afa      	ldrb	r2, [r7, #11]
 8024e72:	7afb      	ldrb	r3, [r7, #11]
 8024e74:	021b      	lsls	r3, r3, #8
 8024e76:	441a      	add	r2, r3
 8024e78:	7afb      	ldrb	r3, [r7, #11]
 8024e7a:	041b      	lsls	r3, r3, #16
 8024e7c:	441a      	add	r2, r3
 8024e7e:	7afb      	ldrb	r3, [r7, #11]
 8024e80:	061b      	lsls	r3, r3, #24
 8024e82:	4413      	add	r3, r2
 8024e84:	613b      	str	r3, [r7, #16]
    uint32_t * d32 = (uint32_t *)d8;
 8024e86:	69fb      	ldr	r3, [r7, #28]
 8024e88:	617b      	str	r3, [r7, #20]

    while(len > 32) {
 8024e8a:	e032      	b.n	8024ef2 <lv_memset+0xd0>
        _REPEAT8(_SET(d32, v32));
 8024e8c:	697b      	ldr	r3, [r7, #20]
 8024e8e:	693a      	ldr	r2, [r7, #16]
 8024e90:	601a      	str	r2, [r3, #0]
 8024e92:	697b      	ldr	r3, [r7, #20]
 8024e94:	3304      	adds	r3, #4
 8024e96:	617b      	str	r3, [r7, #20]
 8024e98:	697b      	ldr	r3, [r7, #20]
 8024e9a:	693a      	ldr	r2, [r7, #16]
 8024e9c:	601a      	str	r2, [r3, #0]
 8024e9e:	697b      	ldr	r3, [r7, #20]
 8024ea0:	3304      	adds	r3, #4
 8024ea2:	617b      	str	r3, [r7, #20]
 8024ea4:	697b      	ldr	r3, [r7, #20]
 8024ea6:	693a      	ldr	r2, [r7, #16]
 8024ea8:	601a      	str	r2, [r3, #0]
 8024eaa:	697b      	ldr	r3, [r7, #20]
 8024eac:	3304      	adds	r3, #4
 8024eae:	617b      	str	r3, [r7, #20]
 8024eb0:	697b      	ldr	r3, [r7, #20]
 8024eb2:	693a      	ldr	r2, [r7, #16]
 8024eb4:	601a      	str	r2, [r3, #0]
 8024eb6:	697b      	ldr	r3, [r7, #20]
 8024eb8:	3304      	adds	r3, #4
 8024eba:	617b      	str	r3, [r7, #20]
 8024ebc:	697b      	ldr	r3, [r7, #20]
 8024ebe:	693a      	ldr	r2, [r7, #16]
 8024ec0:	601a      	str	r2, [r3, #0]
 8024ec2:	697b      	ldr	r3, [r7, #20]
 8024ec4:	3304      	adds	r3, #4
 8024ec6:	617b      	str	r3, [r7, #20]
 8024ec8:	697b      	ldr	r3, [r7, #20]
 8024eca:	693a      	ldr	r2, [r7, #16]
 8024ecc:	601a      	str	r2, [r3, #0]
 8024ece:	697b      	ldr	r3, [r7, #20]
 8024ed0:	3304      	adds	r3, #4
 8024ed2:	617b      	str	r3, [r7, #20]
 8024ed4:	697b      	ldr	r3, [r7, #20]
 8024ed6:	693a      	ldr	r2, [r7, #16]
 8024ed8:	601a      	str	r2, [r3, #0]
 8024eda:	697b      	ldr	r3, [r7, #20]
 8024edc:	3304      	adds	r3, #4
 8024ede:	617b      	str	r3, [r7, #20]
 8024ee0:	697b      	ldr	r3, [r7, #20]
 8024ee2:	693a      	ldr	r2, [r7, #16]
 8024ee4:	601a      	str	r2, [r3, #0]
 8024ee6:	697b      	ldr	r3, [r7, #20]
 8024ee8:	3304      	adds	r3, #4
 8024eea:	617b      	str	r3, [r7, #20]
        len -= 32;
 8024eec:	687b      	ldr	r3, [r7, #4]
 8024eee:	3b20      	subs	r3, #32
 8024ef0:	607b      	str	r3, [r7, #4]
    while(len > 32) {
 8024ef2:	687b      	ldr	r3, [r7, #4]
 8024ef4:	2b20      	cmp	r3, #32
 8024ef6:	d8c9      	bhi.n	8024e8c <lv_memset+0x6a>
    }

    d8 = (uint8_t *)d32;
 8024ef8:	697b      	ldr	r3, [r7, #20]
 8024efa:	61fb      	str	r3, [r7, #28]
    while(len) {
 8024efc:	e008      	b.n	8024f10 <lv_memset+0xee>
        _SET(d8, v);
 8024efe:	69fb      	ldr	r3, [r7, #28]
 8024f00:	7afa      	ldrb	r2, [r7, #11]
 8024f02:	701a      	strb	r2, [r3, #0]
 8024f04:	69fb      	ldr	r3, [r7, #28]
 8024f06:	3301      	adds	r3, #1
 8024f08:	61fb      	str	r3, [r7, #28]
        len--;
 8024f0a:	687b      	ldr	r3, [r7, #4]
 8024f0c:	3b01      	subs	r3, #1
 8024f0e:	607b      	str	r3, [r7, #4]
    while(len) {
 8024f10:	687b      	ldr	r3, [r7, #4]
 8024f12:	2b00      	cmp	r3, #0
 8024f14:	d1f3      	bne.n	8024efe <lv_memset+0xdc>
    }
}
 8024f16:	bf00      	nop
 8024f18:	bf00      	nop
 8024f1a:	3724      	adds	r7, #36	@ 0x24
 8024f1c:	46bd      	mov	sp, r7
 8024f1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024f22:	4770      	bx	lr

08024f24 <lv_memmove>:

void * LV_ATTRIBUTE_FAST_MEM lv_memmove(void * dst, const void * src, size_t len)
{
 8024f24:	b580      	push	{r7, lr}
 8024f26:	b088      	sub	sp, #32
 8024f28:	af00      	add	r7, sp, #0
 8024f2a:	60f8      	str	r0, [r7, #12]
 8024f2c:	60b9      	str	r1, [r7, #8]
 8024f2e:	607a      	str	r2, [r7, #4]
    if(dst < src || (char *)dst > ((char *)src + len)) {
 8024f30:	68fa      	ldr	r2, [r7, #12]
 8024f32:	68bb      	ldr	r3, [r7, #8]
 8024f34:	429a      	cmp	r2, r3
 8024f36:	d305      	bcc.n	8024f44 <lv_memmove+0x20>
 8024f38:	68ba      	ldr	r2, [r7, #8]
 8024f3a:	687b      	ldr	r3, [r7, #4]
 8024f3c:	4413      	add	r3, r2
 8024f3e:	68fa      	ldr	r2, [r7, #12]
 8024f40:	429a      	cmp	r2, r3
 8024f42:	d906      	bls.n	8024f52 <lv_memmove+0x2e>
        return lv_memcpy(dst, src, len);
 8024f44:	687a      	ldr	r2, [r7, #4]
 8024f46:	68b9      	ldr	r1, [r7, #8]
 8024f48:	68f8      	ldr	r0, [r7, #12]
 8024f4a:	f7ff fd4d 	bl	80249e8 <lv_memcpy>
 8024f4e:	4603      	mov	r3, r0
 8024f50:	e02f      	b.n	8024fb2 <lv_memmove+0x8e>
    }

    if(dst > src) {
 8024f52:	68fa      	ldr	r2, [r7, #12]
 8024f54:	68bb      	ldr	r3, [r7, #8]
 8024f56:	429a      	cmp	r2, r3
 8024f58:	d918      	bls.n	8024f8c <lv_memmove+0x68>
        char * tmp = (char *)dst + len - 1;
 8024f5a:	687b      	ldr	r3, [r7, #4]
 8024f5c:	3b01      	subs	r3, #1
 8024f5e:	68fa      	ldr	r2, [r7, #12]
 8024f60:	4413      	add	r3, r2
 8024f62:	61fb      	str	r3, [r7, #28]
        char * s   = (char *)src + len - 1;
 8024f64:	687b      	ldr	r3, [r7, #4]
 8024f66:	3b01      	subs	r3, #1
 8024f68:	68ba      	ldr	r2, [r7, #8]
 8024f6a:	4413      	add	r3, r2
 8024f6c:	61bb      	str	r3, [r7, #24]

        while(len--) {
 8024f6e:	e007      	b.n	8024f80 <lv_memmove+0x5c>
            *tmp-- = *s--;
 8024f70:	69ba      	ldr	r2, [r7, #24]
 8024f72:	1e53      	subs	r3, r2, #1
 8024f74:	61bb      	str	r3, [r7, #24]
 8024f76:	69fb      	ldr	r3, [r7, #28]
 8024f78:	1e59      	subs	r1, r3, #1
 8024f7a:	61f9      	str	r1, [r7, #28]
 8024f7c:	7812      	ldrb	r2, [r2, #0]
 8024f7e:	701a      	strb	r2, [r3, #0]
        while(len--) {
 8024f80:	687b      	ldr	r3, [r7, #4]
 8024f82:	1e5a      	subs	r2, r3, #1
 8024f84:	607a      	str	r2, [r7, #4]
 8024f86:	2b00      	cmp	r3, #0
 8024f88:	d1f2      	bne.n	8024f70 <lv_memmove+0x4c>
 8024f8a:	e011      	b.n	8024fb0 <lv_memmove+0x8c>
        }
    }
    else {
        char * tmp = (char *)dst;
 8024f8c:	68fb      	ldr	r3, [r7, #12]
 8024f8e:	617b      	str	r3, [r7, #20]
        char * s   = (char *)src;
 8024f90:	68bb      	ldr	r3, [r7, #8]
 8024f92:	613b      	str	r3, [r7, #16]

        while(len--) {
 8024f94:	e007      	b.n	8024fa6 <lv_memmove+0x82>
            *tmp++ = *s++;
 8024f96:	693a      	ldr	r2, [r7, #16]
 8024f98:	1c53      	adds	r3, r2, #1
 8024f9a:	613b      	str	r3, [r7, #16]
 8024f9c:	697b      	ldr	r3, [r7, #20]
 8024f9e:	1c59      	adds	r1, r3, #1
 8024fa0:	6179      	str	r1, [r7, #20]
 8024fa2:	7812      	ldrb	r2, [r2, #0]
 8024fa4:	701a      	strb	r2, [r3, #0]
        while(len--) {
 8024fa6:	687b      	ldr	r3, [r7, #4]
 8024fa8:	1e5a      	subs	r2, r3, #1
 8024faa:	607a      	str	r2, [r7, #4]
 8024fac:	2b00      	cmp	r3, #0
 8024fae:	d1f2      	bne.n	8024f96 <lv_memmove+0x72>
        }
    }

    return dst;
 8024fb0:	68fb      	ldr	r3, [r7, #12]
}
 8024fb2:	4618      	mov	r0, r3
 8024fb4:	3720      	adds	r7, #32
 8024fb6:	46bd      	mov	sp, r7
 8024fb8:	bd80      	pop	{r7, pc}

08024fba <lv_strlen>:

/* See https://en.cppreference.com/w/c/string/byte/strlen for reference */
size_t lv_strlen(const char * str)
{
 8024fba:	b480      	push	{r7}
 8024fbc:	b085      	sub	sp, #20
 8024fbe:	af00      	add	r7, sp, #0
 8024fc0:	6078      	str	r0, [r7, #4]
    size_t i = 0;
 8024fc2:	2300      	movs	r3, #0
 8024fc4:	60fb      	str	r3, [r7, #12]
    while(str[i]) i++;
 8024fc6:	e002      	b.n	8024fce <lv_strlen+0x14>
 8024fc8:	68fb      	ldr	r3, [r7, #12]
 8024fca:	3301      	adds	r3, #1
 8024fcc:	60fb      	str	r3, [r7, #12]
 8024fce:	687a      	ldr	r2, [r7, #4]
 8024fd0:	68fb      	ldr	r3, [r7, #12]
 8024fd2:	4413      	add	r3, r2
 8024fd4:	781b      	ldrb	r3, [r3, #0]
 8024fd6:	2b00      	cmp	r3, #0
 8024fd8:	d1f6      	bne.n	8024fc8 <lv_strlen+0xe>

    return i;
 8024fda:	68fb      	ldr	r3, [r7, #12]
}
 8024fdc:	4618      	mov	r0, r3
 8024fde:	3714      	adds	r7, #20
 8024fe0:	46bd      	mov	sp, r7
 8024fe2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024fe6:	4770      	bx	lr

08024fe8 <lv_strcpy>:
    dst[i] = '\0';
    return dst;
}

char * lv_strcpy(char * dst, const char * src)
{
 8024fe8:	b480      	push	{r7}
 8024fea:	b085      	sub	sp, #20
 8024fec:	af00      	add	r7, sp, #0
 8024fee:	6078      	str	r0, [r7, #4]
 8024ff0:	6039      	str	r1, [r7, #0]
    char * tmp = dst;
 8024ff2:	687b      	ldr	r3, [r7, #4]
 8024ff4:	60fb      	str	r3, [r7, #12]
    while((*dst++ = *src++) != '\0');
 8024ff6:	bf00      	nop
 8024ff8:	683a      	ldr	r2, [r7, #0]
 8024ffa:	1c53      	adds	r3, r2, #1
 8024ffc:	603b      	str	r3, [r7, #0]
 8024ffe:	687b      	ldr	r3, [r7, #4]
 8025000:	1c59      	adds	r1, r3, #1
 8025002:	6079      	str	r1, [r7, #4]
 8025004:	7812      	ldrb	r2, [r2, #0]
 8025006:	701a      	strb	r2, [r3, #0]
 8025008:	781b      	ldrb	r3, [r3, #0]
 802500a:	2b00      	cmp	r3, #0
 802500c:	d1f4      	bne.n	8024ff8 <lv_strcpy+0x10>
    return tmp;
 802500e:	68fb      	ldr	r3, [r7, #12]
}
 8025010:	4618      	mov	r0, r3
 8025012:	3714      	adds	r7, #20
 8025014:	46bd      	mov	sp, r7
 8025016:	f85d 7b04 	ldr.w	r7, [sp], #4
 802501a:	4770      	bx	lr

0802501c <lv_strcmp>:

int32_t lv_strcmp(const char * s1, const char * s2)
{
 802501c:	b480      	push	{r7}
 802501e:	b083      	sub	sp, #12
 8025020:	af00      	add	r7, sp, #0
 8025022:	6078      	str	r0, [r7, #4]
 8025024:	6039      	str	r1, [r7, #0]
    while(*s1 && (*s1 == *s2)) {
 8025026:	e005      	b.n	8025034 <lv_strcmp+0x18>
        s1++;
 8025028:	687b      	ldr	r3, [r7, #4]
 802502a:	3301      	adds	r3, #1
 802502c:	607b      	str	r3, [r7, #4]
        s2++;
 802502e:	683b      	ldr	r3, [r7, #0]
 8025030:	3301      	adds	r3, #1
 8025032:	603b      	str	r3, [r7, #0]
    while(*s1 && (*s1 == *s2)) {
 8025034:	687b      	ldr	r3, [r7, #4]
 8025036:	781b      	ldrb	r3, [r3, #0]
 8025038:	2b00      	cmp	r3, #0
 802503a:	d005      	beq.n	8025048 <lv_strcmp+0x2c>
 802503c:	687b      	ldr	r3, [r7, #4]
 802503e:	781a      	ldrb	r2, [r3, #0]
 8025040:	683b      	ldr	r3, [r7, #0]
 8025042:	781b      	ldrb	r3, [r3, #0]
 8025044:	429a      	cmp	r2, r3
 8025046:	d0ef      	beq.n	8025028 <lv_strcmp+0xc>
    }
    return *(const unsigned char *)s1 - *(const unsigned char *)s2;
 8025048:	687b      	ldr	r3, [r7, #4]
 802504a:	781b      	ldrb	r3, [r3, #0]
 802504c:	461a      	mov	r2, r3
 802504e:	683b      	ldr	r3, [r7, #0]
 8025050:	781b      	ldrb	r3, [r3, #0]
 8025052:	1ad3      	subs	r3, r2, r3
}
 8025054:	4618      	mov	r0, r3
 8025056:	370c      	adds	r7, #12
 8025058:	46bd      	mov	sp, r7
 802505a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802505e:	4770      	bx	lr

08025060 <lv_strdup>:

char * lv_strdup(const char * src)
{
 8025060:	b580      	push	{r7, lr}
 8025062:	b084      	sub	sp, #16
 8025064:	af00      	add	r7, sp, #0
 8025066:	6078      	str	r0, [r7, #4]
    size_t len = lv_strlen(src) + 1;
 8025068:	6878      	ldr	r0, [r7, #4]
 802506a:	f7ff ffa6 	bl	8024fba <lv_strlen>
 802506e:	4603      	mov	r3, r0
 8025070:	3301      	adds	r3, #1
 8025072:	60fb      	str	r3, [r7, #12]
    char * dst = lv_malloc(len);
 8025074:	68f8      	ldr	r0, [r7, #12]
 8025076:	f000 fea7 	bl	8025dc8 <lv_malloc>
 802507a:	60b8      	str	r0, [r7, #8]
    if(dst == NULL) return NULL;
 802507c:	68bb      	ldr	r3, [r7, #8]
 802507e:	2b00      	cmp	r3, #0
 8025080:	d101      	bne.n	8025086 <lv_strdup+0x26>
 8025082:	2300      	movs	r3, #0
 8025084:	e005      	b.n	8025092 <lv_strdup+0x32>

    lv_memcpy(dst, src, len); /*do memcpy is faster than strncpy when length is known*/
 8025086:	68fa      	ldr	r2, [r7, #12]
 8025088:	6879      	ldr	r1, [r7, #4]
 802508a:	68b8      	ldr	r0, [r7, #8]
 802508c:	f7ff fcac 	bl	80249e8 <lv_memcpy>
    return dst;
 8025090:	68bb      	ldr	r3, [r7, #8]
}
 8025092:	4618      	mov	r0, r3
 8025094:	3710      	adds	r7, #16
 8025096:	46bd      	mov	sp, r7
 8025098:	bd80      	pop	{r7, pc}

0802509a <tlsf_ffs>:
}

#else

tlsf_decl int tlsf_ffs(unsigned int word)
{
 802509a:	b480      	push	{r7}
 802509c:	b083      	sub	sp, #12
 802509e:	af00      	add	r7, sp, #0
 80250a0:	6078      	str	r0, [r7, #4]
    return __builtin_ffs(word) - 1;
 80250a2:	687b      	ldr	r3, [r7, #4]
 80250a4:	fa93 f2a3 	rbit	r2, r3
 80250a8:	fab2 f282 	clz	r2, r2
 80250ac:	2b00      	cmp	r3, #0
 80250ae:	d101      	bne.n	80250b4 <tlsf_ffs+0x1a>
 80250b0:	f04f 32ff 	mov.w	r2, #4294967295
 80250b4:	1c53      	adds	r3, r2, #1
 80250b6:	3b01      	subs	r3, #1
}
 80250b8:	4618      	mov	r0, r3
 80250ba:	370c      	adds	r7, #12
 80250bc:	46bd      	mov	sp, r7
 80250be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80250c2:	4770      	bx	lr

080250c4 <tlsf_fls>:

#endif

tlsf_decl int tlsf_fls(unsigned int word)
{
 80250c4:	b480      	push	{r7}
 80250c6:	b085      	sub	sp, #20
 80250c8:	af00      	add	r7, sp, #0
 80250ca:	6078      	str	r0, [r7, #4]
    const int bit = word ? 32 - __builtin_clz(word) : 0;
 80250cc:	687b      	ldr	r3, [r7, #4]
 80250ce:	2b00      	cmp	r3, #0
 80250d0:	d005      	beq.n	80250de <tlsf_fls+0x1a>
 80250d2:	687b      	ldr	r3, [r7, #4]
 80250d4:	fab3 f383 	clz	r3, r3
 80250d8:	f1c3 0320 	rsb	r3, r3, #32
 80250dc:	e000      	b.n	80250e0 <tlsf_fls+0x1c>
 80250de:	2300      	movs	r3, #0
 80250e0:	60fb      	str	r3, [r7, #12]
    return bit - 1;
 80250e2:	68fb      	ldr	r3, [r7, #12]
 80250e4:	3b01      	subs	r3, #1
}
 80250e6:	4618      	mov	r0, r3
 80250e8:	3714      	adds	r7, #20
 80250ea:	46bd      	mov	sp, r7
 80250ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80250f0:	4770      	bx	lr

080250f2 <block_size>:
/*
** block_header_t member functions.
*/

static size_t block_size(const block_header_t * block)
{
 80250f2:	b480      	push	{r7}
 80250f4:	b083      	sub	sp, #12
 80250f6:	af00      	add	r7, sp, #0
 80250f8:	6078      	str	r0, [r7, #4]
    return block->size & ~(block_header_free_bit | block_header_prev_free_bit);
 80250fa:	687b      	ldr	r3, [r7, #4]
 80250fc:	685a      	ldr	r2, [r3, #4]
 80250fe:	2101      	movs	r1, #1
 8025100:	2302      	movs	r3, #2
 8025102:	430b      	orrs	r3, r1
 8025104:	43db      	mvns	r3, r3
 8025106:	4013      	ands	r3, r2
}
 8025108:	4618      	mov	r0, r3
 802510a:	370c      	adds	r7, #12
 802510c:	46bd      	mov	sp, r7
 802510e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025112:	4770      	bx	lr

08025114 <block_set_size>:

static void block_set_size(block_header_t * block, size_t size)
{
 8025114:	b480      	push	{r7}
 8025116:	b085      	sub	sp, #20
 8025118:	af00      	add	r7, sp, #0
 802511a:	6078      	str	r0, [r7, #4]
 802511c:	6039      	str	r1, [r7, #0]
    const size_t oldsize = block->size;
 802511e:	687b      	ldr	r3, [r7, #4]
 8025120:	685b      	ldr	r3, [r3, #4]
 8025122:	60fb      	str	r3, [r7, #12]
    block->size = size | (oldsize & (block_header_free_bit | block_header_prev_free_bit));
 8025124:	2201      	movs	r2, #1
 8025126:	2302      	movs	r3, #2
 8025128:	431a      	orrs	r2, r3
 802512a:	68fb      	ldr	r3, [r7, #12]
 802512c:	401a      	ands	r2, r3
 802512e:	683b      	ldr	r3, [r7, #0]
 8025130:	431a      	orrs	r2, r3
 8025132:	687b      	ldr	r3, [r7, #4]
 8025134:	605a      	str	r2, [r3, #4]
}
 8025136:	bf00      	nop
 8025138:	3714      	adds	r7, #20
 802513a:	46bd      	mov	sp, r7
 802513c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025140:	4770      	bx	lr

08025142 <block_is_last>:

static int block_is_last(const block_header_t * block)
{
 8025142:	b580      	push	{r7, lr}
 8025144:	b082      	sub	sp, #8
 8025146:	af00      	add	r7, sp, #0
 8025148:	6078      	str	r0, [r7, #4]
    return block_size(block) == 0;
 802514a:	6878      	ldr	r0, [r7, #4]
 802514c:	f7ff ffd1 	bl	80250f2 <block_size>
 8025150:	4603      	mov	r3, r0
 8025152:	2b00      	cmp	r3, #0
 8025154:	bf0c      	ite	eq
 8025156:	2301      	moveq	r3, #1
 8025158:	2300      	movne	r3, #0
 802515a:	b2db      	uxtb	r3, r3
}
 802515c:	4618      	mov	r0, r3
 802515e:	3708      	adds	r7, #8
 8025160:	46bd      	mov	sp, r7
 8025162:	bd80      	pop	{r7, pc}

08025164 <block_is_free>:

static int block_is_free(const block_header_t * block)
{
 8025164:	b480      	push	{r7}
 8025166:	b083      	sub	sp, #12
 8025168:	af00      	add	r7, sp, #0
 802516a:	6078      	str	r0, [r7, #4]
    return tlsf_cast(int, block->size & block_header_free_bit);
 802516c:	687b      	ldr	r3, [r7, #4]
 802516e:	685b      	ldr	r3, [r3, #4]
 8025170:	2201      	movs	r2, #1
 8025172:	4013      	ands	r3, r2
}
 8025174:	4618      	mov	r0, r3
 8025176:	370c      	adds	r7, #12
 8025178:	46bd      	mov	sp, r7
 802517a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802517e:	4770      	bx	lr

08025180 <block_set_free>:

static void block_set_free(block_header_t * block)
{
 8025180:	b480      	push	{r7}
 8025182:	b083      	sub	sp, #12
 8025184:	af00      	add	r7, sp, #0
 8025186:	6078      	str	r0, [r7, #4]
    block->size |= block_header_free_bit;
 8025188:	687b      	ldr	r3, [r7, #4]
 802518a:	685b      	ldr	r3, [r3, #4]
 802518c:	2201      	movs	r2, #1
 802518e:	431a      	orrs	r2, r3
 8025190:	687b      	ldr	r3, [r7, #4]
 8025192:	605a      	str	r2, [r3, #4]
}
 8025194:	bf00      	nop
 8025196:	370c      	adds	r7, #12
 8025198:	46bd      	mov	sp, r7
 802519a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802519e:	4770      	bx	lr

080251a0 <block_set_used>:

static void block_set_used(block_header_t * block)
{
 80251a0:	b480      	push	{r7}
 80251a2:	b083      	sub	sp, #12
 80251a4:	af00      	add	r7, sp, #0
 80251a6:	6078      	str	r0, [r7, #4]
    block->size &= ~block_header_free_bit;
 80251a8:	687b      	ldr	r3, [r7, #4]
 80251aa:	685a      	ldr	r2, [r3, #4]
 80251ac:	2301      	movs	r3, #1
 80251ae:	43db      	mvns	r3, r3
 80251b0:	401a      	ands	r2, r3
 80251b2:	687b      	ldr	r3, [r7, #4]
 80251b4:	605a      	str	r2, [r3, #4]
}
 80251b6:	bf00      	nop
 80251b8:	370c      	adds	r7, #12
 80251ba:	46bd      	mov	sp, r7
 80251bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80251c0:	4770      	bx	lr

080251c2 <block_is_prev_free>:

static int block_is_prev_free(const block_header_t * block)
{
 80251c2:	b480      	push	{r7}
 80251c4:	b083      	sub	sp, #12
 80251c6:	af00      	add	r7, sp, #0
 80251c8:	6078      	str	r0, [r7, #4]
    return tlsf_cast(int, block->size & block_header_prev_free_bit);
 80251ca:	687b      	ldr	r3, [r7, #4]
 80251cc:	685b      	ldr	r3, [r3, #4]
 80251ce:	2202      	movs	r2, #2
 80251d0:	4013      	ands	r3, r2
}
 80251d2:	4618      	mov	r0, r3
 80251d4:	370c      	adds	r7, #12
 80251d6:	46bd      	mov	sp, r7
 80251d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80251dc:	4770      	bx	lr

080251de <block_set_prev_free>:

static void block_set_prev_free(block_header_t * block)
{
 80251de:	b480      	push	{r7}
 80251e0:	b083      	sub	sp, #12
 80251e2:	af00      	add	r7, sp, #0
 80251e4:	6078      	str	r0, [r7, #4]
    block->size |= block_header_prev_free_bit;
 80251e6:	687b      	ldr	r3, [r7, #4]
 80251e8:	685b      	ldr	r3, [r3, #4]
 80251ea:	2202      	movs	r2, #2
 80251ec:	431a      	orrs	r2, r3
 80251ee:	687b      	ldr	r3, [r7, #4]
 80251f0:	605a      	str	r2, [r3, #4]
}
 80251f2:	bf00      	nop
 80251f4:	370c      	adds	r7, #12
 80251f6:	46bd      	mov	sp, r7
 80251f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80251fc:	4770      	bx	lr

080251fe <block_set_prev_used>:

static void block_set_prev_used(block_header_t * block)
{
 80251fe:	b480      	push	{r7}
 8025200:	b083      	sub	sp, #12
 8025202:	af00      	add	r7, sp, #0
 8025204:	6078      	str	r0, [r7, #4]
    block->size &= ~block_header_prev_free_bit;
 8025206:	687b      	ldr	r3, [r7, #4]
 8025208:	685a      	ldr	r2, [r3, #4]
 802520a:	2302      	movs	r3, #2
 802520c:	43db      	mvns	r3, r3
 802520e:	401a      	ands	r2, r3
 8025210:	687b      	ldr	r3, [r7, #4]
 8025212:	605a      	str	r2, [r3, #4]
}
 8025214:	bf00      	nop
 8025216:	370c      	adds	r7, #12
 8025218:	46bd      	mov	sp, r7
 802521a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802521e:	4770      	bx	lr

08025220 <block_from_ptr>:

static block_header_t * block_from_ptr(const void * ptr)
{
 8025220:	b480      	push	{r7}
 8025222:	b083      	sub	sp, #12
 8025224:	af00      	add	r7, sp, #0
 8025226:	6078      	str	r0, [r7, #4]
    return tlsf_cast(block_header_t *,
 8025228:	2308      	movs	r3, #8
 802522a:	425b      	negs	r3, r3
 802522c:	687a      	ldr	r2, [r7, #4]
 802522e:	4413      	add	r3, r2
                     tlsf_cast(unsigned char *, ptr) - block_start_offset);
}
 8025230:	4618      	mov	r0, r3
 8025232:	370c      	adds	r7, #12
 8025234:	46bd      	mov	sp, r7
 8025236:	f85d 7b04 	ldr.w	r7, [sp], #4
 802523a:	4770      	bx	lr

0802523c <block_to_ptr>:

static void * block_to_ptr(const block_header_t * block)
{
 802523c:	b480      	push	{r7}
 802523e:	b083      	sub	sp, #12
 8025240:	af00      	add	r7, sp, #0
 8025242:	6078      	str	r0, [r7, #4]
    return tlsf_cast(void *,
 8025244:	2208      	movs	r2, #8
 8025246:	687b      	ldr	r3, [r7, #4]
 8025248:	4413      	add	r3, r2
                     tlsf_cast(unsigned char *, block) + block_start_offset);
}
 802524a:	4618      	mov	r0, r3
 802524c:	370c      	adds	r7, #12
 802524e:	46bd      	mov	sp, r7
 8025250:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025254:	4770      	bx	lr

08025256 <offset_to_block>:

/* Return location of next block after block of given size. */
static block_header_t * offset_to_block(const void * ptr, size_t size)
{
 8025256:	b480      	push	{r7}
 8025258:	b083      	sub	sp, #12
 802525a:	af00      	add	r7, sp, #0
 802525c:	6078      	str	r0, [r7, #4]
 802525e:	6039      	str	r1, [r7, #0]
    return tlsf_cast(block_header_t *, tlsf_cast(tlsfptr_t, ptr) + size);
 8025260:	687a      	ldr	r2, [r7, #4]
 8025262:	683b      	ldr	r3, [r7, #0]
 8025264:	4413      	add	r3, r2
}
 8025266:	4618      	mov	r0, r3
 8025268:	370c      	adds	r7, #12
 802526a:	46bd      	mov	sp, r7
 802526c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025270:	4770      	bx	lr

08025272 <block_prev>:

/* Return location of previous block. */
static block_header_t * block_prev(const block_header_t * block)
{
 8025272:	b580      	push	{r7, lr}
 8025274:	b082      	sub	sp, #8
 8025276:	af00      	add	r7, sp, #0
 8025278:	6078      	str	r0, [r7, #4]
    tlsf_assert(block_is_prev_free(block) && "previous block must be free");
 802527a:	6878      	ldr	r0, [r7, #4]
 802527c:	f7ff ffa1 	bl	80251c2 <block_is_prev_free>
 8025280:	4603      	mov	r3, r0
 8025282:	2b00      	cmp	r3, #0
 8025284:	d101      	bne.n	802528a <block_prev+0x18>
 8025286:	bf00      	nop
 8025288:	e7fd      	b.n	8025286 <block_prev+0x14>
    return block->prev_phys_block;
 802528a:	687b      	ldr	r3, [r7, #4]
 802528c:	681b      	ldr	r3, [r3, #0]
}
 802528e:	4618      	mov	r0, r3
 8025290:	3708      	adds	r7, #8
 8025292:	46bd      	mov	sp, r7
 8025294:	bd80      	pop	{r7, pc}

08025296 <block_next>:

/* Return location of next existing block. */
static block_header_t * block_next(const block_header_t * block)
{
 8025296:	b590      	push	{r4, r7, lr}
 8025298:	b085      	sub	sp, #20
 802529a:	af00      	add	r7, sp, #0
 802529c:	6078      	str	r0, [r7, #4]
    block_header_t * next = offset_to_block(block_to_ptr(block),
 802529e:	6878      	ldr	r0, [r7, #4]
 80252a0:	f7ff ffcc 	bl	802523c <block_to_ptr>
 80252a4:	4604      	mov	r4, r0
                                            block_size(block) - block_header_overhead);
 80252a6:	6878      	ldr	r0, [r7, #4]
 80252a8:	f7ff ff23 	bl	80250f2 <block_size>
 80252ac:	4603      	mov	r3, r0
    block_header_t * next = offset_to_block(block_to_ptr(block),
 80252ae:	2204      	movs	r2, #4
 80252b0:	1a9b      	subs	r3, r3, r2
 80252b2:	4619      	mov	r1, r3
 80252b4:	4620      	mov	r0, r4
 80252b6:	f7ff ffce 	bl	8025256 <offset_to_block>
 80252ba:	60f8      	str	r0, [r7, #12]
    tlsf_assert(!block_is_last(block));
 80252bc:	6878      	ldr	r0, [r7, #4]
 80252be:	f7ff ff40 	bl	8025142 <block_is_last>
 80252c2:	4603      	mov	r3, r0
 80252c4:	2b00      	cmp	r3, #0
 80252c6:	d001      	beq.n	80252cc <block_next+0x36>
 80252c8:	bf00      	nop
 80252ca:	e7fd      	b.n	80252c8 <block_next+0x32>
    return next;
 80252cc:	68fb      	ldr	r3, [r7, #12]
}
 80252ce:	4618      	mov	r0, r3
 80252d0:	3714      	adds	r7, #20
 80252d2:	46bd      	mov	sp, r7
 80252d4:	bd90      	pop	{r4, r7, pc}

080252d6 <block_link_next>:

/* Link a new block with its physical neighbor, return the neighbor. */
static block_header_t * block_link_next(block_header_t * block)
{
 80252d6:	b580      	push	{r7, lr}
 80252d8:	b084      	sub	sp, #16
 80252da:	af00      	add	r7, sp, #0
 80252dc:	6078      	str	r0, [r7, #4]
    block_header_t * next = block_next(block);
 80252de:	6878      	ldr	r0, [r7, #4]
 80252e0:	f7ff ffd9 	bl	8025296 <block_next>
 80252e4:	60f8      	str	r0, [r7, #12]
    next->prev_phys_block = block;
 80252e6:	68fb      	ldr	r3, [r7, #12]
 80252e8:	687a      	ldr	r2, [r7, #4]
 80252ea:	601a      	str	r2, [r3, #0]
    return next;
 80252ec:	68fb      	ldr	r3, [r7, #12]
}
 80252ee:	4618      	mov	r0, r3
 80252f0:	3710      	adds	r7, #16
 80252f2:	46bd      	mov	sp, r7
 80252f4:	bd80      	pop	{r7, pc}

080252f6 <block_mark_as_free>:

static void block_mark_as_free(block_header_t * block)
{
 80252f6:	b580      	push	{r7, lr}
 80252f8:	b084      	sub	sp, #16
 80252fa:	af00      	add	r7, sp, #0
 80252fc:	6078      	str	r0, [r7, #4]
    /* Link the block to the next block, first. */
    block_header_t * next = block_link_next(block);
 80252fe:	6878      	ldr	r0, [r7, #4]
 8025300:	f7ff ffe9 	bl	80252d6 <block_link_next>
 8025304:	60f8      	str	r0, [r7, #12]
    block_set_prev_free(next);
 8025306:	68f8      	ldr	r0, [r7, #12]
 8025308:	f7ff ff69 	bl	80251de <block_set_prev_free>
    block_set_free(block);
 802530c:	6878      	ldr	r0, [r7, #4]
 802530e:	f7ff ff37 	bl	8025180 <block_set_free>
}
 8025312:	bf00      	nop
 8025314:	3710      	adds	r7, #16
 8025316:	46bd      	mov	sp, r7
 8025318:	bd80      	pop	{r7, pc}

0802531a <block_mark_as_used>:

static void block_mark_as_used(block_header_t * block)
{
 802531a:	b580      	push	{r7, lr}
 802531c:	b084      	sub	sp, #16
 802531e:	af00      	add	r7, sp, #0
 8025320:	6078      	str	r0, [r7, #4]
    block_header_t * next = block_next(block);
 8025322:	6878      	ldr	r0, [r7, #4]
 8025324:	f7ff ffb7 	bl	8025296 <block_next>
 8025328:	60f8      	str	r0, [r7, #12]
    block_set_prev_used(next);
 802532a:	68f8      	ldr	r0, [r7, #12]
 802532c:	f7ff ff67 	bl	80251fe <block_set_prev_used>
    block_set_used(block);
 8025330:	6878      	ldr	r0, [r7, #4]
 8025332:	f7ff ff35 	bl	80251a0 <block_set_used>
}
 8025336:	bf00      	nop
 8025338:	3710      	adds	r7, #16
 802533a:	46bd      	mov	sp, r7
 802533c:	bd80      	pop	{r7, pc}

0802533e <align_up>:

static size_t align_up(size_t x, size_t align)
{
 802533e:	b480      	push	{r7}
 8025340:	b083      	sub	sp, #12
 8025342:	af00      	add	r7, sp, #0
 8025344:	6078      	str	r0, [r7, #4]
 8025346:	6039      	str	r1, [r7, #0]
    tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
 8025348:	683b      	ldr	r3, [r7, #0]
 802534a:	1e5a      	subs	r2, r3, #1
 802534c:	683b      	ldr	r3, [r7, #0]
 802534e:	4013      	ands	r3, r2
 8025350:	2b00      	cmp	r3, #0
 8025352:	d001      	beq.n	8025358 <align_up+0x1a>
 8025354:	bf00      	nop
 8025356:	e7fd      	b.n	8025354 <align_up+0x16>
    return (x + (align - 1)) & ~(align - 1);
 8025358:	683a      	ldr	r2, [r7, #0]
 802535a:	687b      	ldr	r3, [r7, #4]
 802535c:	4413      	add	r3, r2
 802535e:	1e5a      	subs	r2, r3, #1
 8025360:	683b      	ldr	r3, [r7, #0]
 8025362:	425b      	negs	r3, r3
 8025364:	4013      	ands	r3, r2
}
 8025366:	4618      	mov	r0, r3
 8025368:	370c      	adds	r7, #12
 802536a:	46bd      	mov	sp, r7
 802536c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025370:	4770      	bx	lr

08025372 <align_down>:

static size_t align_down(size_t x, size_t align)
{
 8025372:	b480      	push	{r7}
 8025374:	b083      	sub	sp, #12
 8025376:	af00      	add	r7, sp, #0
 8025378:	6078      	str	r0, [r7, #4]
 802537a:	6039      	str	r1, [r7, #0]
    tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
 802537c:	683b      	ldr	r3, [r7, #0]
 802537e:	1e5a      	subs	r2, r3, #1
 8025380:	683b      	ldr	r3, [r7, #0]
 8025382:	4013      	ands	r3, r2
 8025384:	2b00      	cmp	r3, #0
 8025386:	d001      	beq.n	802538c <align_down+0x1a>
 8025388:	bf00      	nop
 802538a:	e7fd      	b.n	8025388 <align_down+0x16>
    return x - (x & (align - 1));
 802538c:	683b      	ldr	r3, [r7, #0]
 802538e:	425a      	negs	r2, r3
 8025390:	687b      	ldr	r3, [r7, #4]
 8025392:	4013      	ands	r3, r2
}
 8025394:	4618      	mov	r0, r3
 8025396:	370c      	adds	r7, #12
 8025398:	46bd      	mov	sp, r7
 802539a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802539e:	4770      	bx	lr

080253a0 <align_ptr>:

static void * align_ptr(const void * ptr, size_t align)
{
 80253a0:	b480      	push	{r7}
 80253a2:	b085      	sub	sp, #20
 80253a4:	af00      	add	r7, sp, #0
 80253a6:	6078      	str	r0, [r7, #4]
 80253a8:	6039      	str	r1, [r7, #0]
    const tlsfptr_t aligned =
        (tlsf_cast(tlsfptr_t, ptr) + (align - 1)) & ~(align - 1);
 80253aa:	687a      	ldr	r2, [r7, #4]
 80253ac:	683b      	ldr	r3, [r7, #0]
 80253ae:	4413      	add	r3, r2
 80253b0:	1e5a      	subs	r2, r3, #1
 80253b2:	683b      	ldr	r3, [r7, #0]
 80253b4:	425b      	negs	r3, r3
 80253b6:	4013      	ands	r3, r2
    const tlsfptr_t aligned =
 80253b8:	60fb      	str	r3, [r7, #12]
    tlsf_assert(0 == (align & (align - 1)) && "must align to a power of two");
 80253ba:	683b      	ldr	r3, [r7, #0]
 80253bc:	1e5a      	subs	r2, r3, #1
 80253be:	683b      	ldr	r3, [r7, #0]
 80253c0:	4013      	ands	r3, r2
 80253c2:	2b00      	cmp	r3, #0
 80253c4:	d001      	beq.n	80253ca <align_ptr+0x2a>
 80253c6:	bf00      	nop
 80253c8:	e7fd      	b.n	80253c6 <align_ptr+0x26>
    return tlsf_cast(void *, aligned);
 80253ca:	68fb      	ldr	r3, [r7, #12]
}
 80253cc:	4618      	mov	r0, r3
 80253ce:	3714      	adds	r7, #20
 80253d0:	46bd      	mov	sp, r7
 80253d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80253d6:	4770      	bx	lr

080253d8 <adjust_request_size>:
/*
** Adjust an allocation size to be aligned to word size, and no smaller
** than internal minimum.
*/
static size_t adjust_request_size(size_t size, size_t align)
{
 80253d8:	b580      	push	{r7, lr}
 80253da:	b084      	sub	sp, #16
 80253dc:	af00      	add	r7, sp, #0
 80253de:	6078      	str	r0, [r7, #4]
 80253e0:	6039      	str	r1, [r7, #0]
    size_t adjust = 0;
 80253e2:	2300      	movs	r3, #0
 80253e4:	60fb      	str	r3, [r7, #12]
    if(size) {
 80253e6:	687b      	ldr	r3, [r7, #4]
 80253e8:	2b00      	cmp	r3, #0
 80253ea:	d00f      	beq.n	802540c <adjust_request_size+0x34>
        const size_t aligned = align_up(size, align);
 80253ec:	6839      	ldr	r1, [r7, #0]
 80253ee:	6878      	ldr	r0, [r7, #4]
 80253f0:	f7ff ffa5 	bl	802533e <align_up>
 80253f4:	60b8      	str	r0, [r7, #8]

        /* aligned sized must not exceed block_size_max or we'll go out of bounds on sl_bitmap */
        if(aligned < block_size_max) {
 80253f6:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 80253fa:	68bb      	ldr	r3, [r7, #8]
 80253fc:	4293      	cmp	r3, r2
 80253fe:	d205      	bcs.n	802540c <adjust_request_size+0x34>
            adjust = tlsf_max(aligned, block_size_min);
 8025400:	220c      	movs	r2, #12
 8025402:	68bb      	ldr	r3, [r7, #8]
 8025404:	4293      	cmp	r3, r2
 8025406:	bf38      	it	cc
 8025408:	4613      	movcc	r3, r2
 802540a:	60fb      	str	r3, [r7, #12]
        }
    }
    return adjust;
 802540c:	68fb      	ldr	r3, [r7, #12]
}
 802540e:	4618      	mov	r0, r3
 8025410:	3710      	adds	r7, #16
 8025412:	46bd      	mov	sp, r7
 8025414:	bd80      	pop	{r7, pc}

08025416 <mapping_insert>:
** TLSF utility functions. In most cases, these are direct translations of
** the documentation found in the white paper.
*/

static void mapping_insert(size_t size, int * fli, int * sli)
{
 8025416:	b580      	push	{r7, lr}
 8025418:	b086      	sub	sp, #24
 802541a:	af00      	add	r7, sp, #0
 802541c:	60f8      	str	r0, [r7, #12]
 802541e:	60b9      	str	r1, [r7, #8]
 8025420:	607a      	str	r2, [r7, #4]
    int fl, sl;
    if(size < SMALL_BLOCK_SIZE) {
 8025422:	68fb      	ldr	r3, [r7, #12]
 8025424:	2b7f      	cmp	r3, #127	@ 0x7f
 8025426:	d808      	bhi.n	802543a <mapping_insert+0x24>
        /* Store small blocks in first list. */
        fl = 0;
 8025428:	2300      	movs	r3, #0
 802542a:	617b      	str	r3, [r7, #20]
        sl = tlsf_cast(int, size) / (SMALL_BLOCK_SIZE / SL_INDEX_COUNT);
 802542c:	68fb      	ldr	r3, [r7, #12]
 802542e:	2b00      	cmp	r3, #0
 8025430:	da00      	bge.n	8025434 <mapping_insert+0x1e>
 8025432:	3303      	adds	r3, #3
 8025434:	109b      	asrs	r3, r3, #2
 8025436:	613b      	str	r3, [r7, #16]
 8025438:	e00e      	b.n	8025458 <mapping_insert+0x42>
    }
    else {
        fl = tlsf_fls_sizet(size);
 802543a:	68f8      	ldr	r0, [r7, #12]
 802543c:	f7ff fe42 	bl	80250c4 <tlsf_fls>
 8025440:	6178      	str	r0, [r7, #20]
        sl = tlsf_cast(int, size >> (fl - SL_INDEX_COUNT_LOG2)) ^ (1 << SL_INDEX_COUNT_LOG2);
 8025442:	697b      	ldr	r3, [r7, #20]
 8025444:	3b05      	subs	r3, #5
 8025446:	68fa      	ldr	r2, [r7, #12]
 8025448:	fa22 f303 	lsr.w	r3, r2, r3
 802544c:	f083 0320 	eor.w	r3, r3, #32
 8025450:	613b      	str	r3, [r7, #16]
        fl -= (FL_INDEX_SHIFT - 1);
 8025452:	697b      	ldr	r3, [r7, #20]
 8025454:	3b06      	subs	r3, #6
 8025456:	617b      	str	r3, [r7, #20]
    }
    *fli = fl;
 8025458:	68bb      	ldr	r3, [r7, #8]
 802545a:	697a      	ldr	r2, [r7, #20]
 802545c:	601a      	str	r2, [r3, #0]
    *sli = sl;
 802545e:	687b      	ldr	r3, [r7, #4]
 8025460:	693a      	ldr	r2, [r7, #16]
 8025462:	601a      	str	r2, [r3, #0]
}
 8025464:	bf00      	nop
 8025466:	3718      	adds	r7, #24
 8025468:	46bd      	mov	sp, r7
 802546a:	bd80      	pop	{r7, pc}

0802546c <mapping_search>:

/* This version rounds up to the next block size (for allocations) */
static void mapping_search(size_t size, int * fli, int * sli)
{
 802546c:	b580      	push	{r7, lr}
 802546e:	b086      	sub	sp, #24
 8025470:	af00      	add	r7, sp, #0
 8025472:	60f8      	str	r0, [r7, #12]
 8025474:	60b9      	str	r1, [r7, #8]
 8025476:	607a      	str	r2, [r7, #4]
    if(size >= SMALL_BLOCK_SIZE) {
 8025478:	68fb      	ldr	r3, [r7, #12]
 802547a:	2b7f      	cmp	r3, #127	@ 0x7f
 802547c:	d90d      	bls.n	802549a <mapping_search+0x2e>
        const size_t round = (1 << (tlsf_fls_sizet(size) - SL_INDEX_COUNT_LOG2)) - 1;
 802547e:	68f8      	ldr	r0, [r7, #12]
 8025480:	f7ff fe20 	bl	80250c4 <tlsf_fls>
 8025484:	4603      	mov	r3, r0
 8025486:	3b05      	subs	r3, #5
 8025488:	2201      	movs	r2, #1
 802548a:	fa02 f303 	lsl.w	r3, r2, r3
 802548e:	3b01      	subs	r3, #1
 8025490:	617b      	str	r3, [r7, #20]
        size += round;
 8025492:	68fa      	ldr	r2, [r7, #12]
 8025494:	697b      	ldr	r3, [r7, #20]
 8025496:	4413      	add	r3, r2
 8025498:	60fb      	str	r3, [r7, #12]
    }
    mapping_insert(size, fli, sli);
 802549a:	687a      	ldr	r2, [r7, #4]
 802549c:	68b9      	ldr	r1, [r7, #8]
 802549e:	68f8      	ldr	r0, [r7, #12]
 80254a0:	f7ff ffb9 	bl	8025416 <mapping_insert>
}
 80254a4:	bf00      	nop
 80254a6:	3718      	adds	r7, #24
 80254a8:	46bd      	mov	sp, r7
 80254aa:	bd80      	pop	{r7, pc}

080254ac <search_suitable_block>:

static block_header_t * search_suitable_block(control_t * control, int * fli, int * sli)
{
 80254ac:	b580      	push	{r7, lr}
 80254ae:	b088      	sub	sp, #32
 80254b0:	af00      	add	r7, sp, #0
 80254b2:	60f8      	str	r0, [r7, #12]
 80254b4:	60b9      	str	r1, [r7, #8]
 80254b6:	607a      	str	r2, [r7, #4]
    int fl = *fli;
 80254b8:	68bb      	ldr	r3, [r7, #8]
 80254ba:	681b      	ldr	r3, [r3, #0]
 80254bc:	61fb      	str	r3, [r7, #28]
    int sl = *sli;
 80254be:	687b      	ldr	r3, [r7, #4]
 80254c0:	681b      	ldr	r3, [r3, #0]
 80254c2:	617b      	str	r3, [r7, #20]

    /*
    ** First, search for a block in the list associated with the given
    ** fl/sl index.
    */
    unsigned int sl_map = control->sl_bitmap[fl] & (~0U << sl);
 80254c4:	68fa      	ldr	r2, [r7, #12]
 80254c6:	69fb      	ldr	r3, [r7, #28]
 80254c8:	3304      	adds	r3, #4
 80254ca:	009b      	lsls	r3, r3, #2
 80254cc:	4413      	add	r3, r2
 80254ce:	685a      	ldr	r2, [r3, #4]
 80254d0:	f04f 31ff 	mov.w	r1, #4294967295
 80254d4:	697b      	ldr	r3, [r7, #20]
 80254d6:	fa01 f303 	lsl.w	r3, r1, r3
 80254da:	4013      	ands	r3, r2
 80254dc:	61bb      	str	r3, [r7, #24]
    if(!sl_map) {
 80254de:	69bb      	ldr	r3, [r7, #24]
 80254e0:	2b00      	cmp	r3, #0
 80254e2:	d11c      	bne.n	802551e <search_suitable_block+0x72>
        /* No block exists. Search in the next largest first-level list. */
        const unsigned int fl_map = control->fl_bitmap & (~0U << (fl + 1));
 80254e4:	68fb      	ldr	r3, [r7, #12]
 80254e6:	691a      	ldr	r2, [r3, #16]
 80254e8:	69fb      	ldr	r3, [r7, #28]
 80254ea:	3301      	adds	r3, #1
 80254ec:	f04f 31ff 	mov.w	r1, #4294967295
 80254f0:	fa01 f303 	lsl.w	r3, r1, r3
 80254f4:	4013      	ands	r3, r2
 80254f6:	613b      	str	r3, [r7, #16]
        if(!fl_map) {
 80254f8:	693b      	ldr	r3, [r7, #16]
 80254fa:	2b00      	cmp	r3, #0
 80254fc:	d101      	bne.n	8025502 <search_suitable_block+0x56>
            /* No free blocks available, memory has been exhausted. */
            return 0;
 80254fe:	2300      	movs	r3, #0
 8025500:	e022      	b.n	8025548 <search_suitable_block+0x9c>
        }

        fl = tlsf_ffs(fl_map);
 8025502:	6938      	ldr	r0, [r7, #16]
 8025504:	f7ff fdc9 	bl	802509a <tlsf_ffs>
 8025508:	61f8      	str	r0, [r7, #28]
        *fli = fl;
 802550a:	68bb      	ldr	r3, [r7, #8]
 802550c:	69fa      	ldr	r2, [r7, #28]
 802550e:	601a      	str	r2, [r3, #0]
        sl_map = control->sl_bitmap[fl];
 8025510:	68fa      	ldr	r2, [r7, #12]
 8025512:	69fb      	ldr	r3, [r7, #28]
 8025514:	3304      	adds	r3, #4
 8025516:	009b      	lsls	r3, r3, #2
 8025518:	4413      	add	r3, r2
 802551a:	685b      	ldr	r3, [r3, #4]
 802551c:	61bb      	str	r3, [r7, #24]
    }
    tlsf_assert(sl_map && "internal error - second level bitmap is null");
 802551e:	69bb      	ldr	r3, [r7, #24]
 8025520:	2b00      	cmp	r3, #0
 8025522:	d101      	bne.n	8025528 <search_suitable_block+0x7c>
 8025524:	bf00      	nop
 8025526:	e7fd      	b.n	8025524 <search_suitable_block+0x78>
    sl = tlsf_ffs(sl_map);
 8025528:	69b8      	ldr	r0, [r7, #24]
 802552a:	f7ff fdb6 	bl	802509a <tlsf_ffs>
 802552e:	6178      	str	r0, [r7, #20]
    *sli = sl;
 8025530:	687b      	ldr	r3, [r7, #4]
 8025532:	697a      	ldr	r2, [r7, #20]
 8025534:	601a      	str	r2, [r3, #0]

    /* Return the first block in the free list. */
    return control->blocks[fl][sl];
 8025536:	68fa      	ldr	r2, [r7, #12]
 8025538:	69fb      	ldr	r3, [r7, #28]
 802553a:	0159      	lsls	r1, r3, #5
 802553c:	697b      	ldr	r3, [r7, #20]
 802553e:	440b      	add	r3, r1
 8025540:	330e      	adds	r3, #14
 8025542:	009b      	lsls	r3, r3, #2
 8025544:	4413      	add	r3, r2
 8025546:	685b      	ldr	r3, [r3, #4]
}
 8025548:	4618      	mov	r0, r3
 802554a:	3720      	adds	r7, #32
 802554c:	46bd      	mov	sp, r7
 802554e:	bd80      	pop	{r7, pc}

08025550 <remove_free_block>:

/* Remove a free block from the free list.*/
static void remove_free_block(control_t * control, block_header_t * block, int fl, int sl)
{
 8025550:	b480      	push	{r7}
 8025552:	b087      	sub	sp, #28
 8025554:	af00      	add	r7, sp, #0
 8025556:	60f8      	str	r0, [r7, #12]
 8025558:	60b9      	str	r1, [r7, #8]
 802555a:	607a      	str	r2, [r7, #4]
 802555c:	603b      	str	r3, [r7, #0]
    block_header_t * prev = block->prev_free;
 802555e:	68bb      	ldr	r3, [r7, #8]
 8025560:	68db      	ldr	r3, [r3, #12]
 8025562:	617b      	str	r3, [r7, #20]
    block_header_t * next = block->next_free;
 8025564:	68bb      	ldr	r3, [r7, #8]
 8025566:	689b      	ldr	r3, [r3, #8]
 8025568:	613b      	str	r3, [r7, #16]
    tlsf_assert(prev && "prev_free field can not be null");
 802556a:	697b      	ldr	r3, [r7, #20]
 802556c:	2b00      	cmp	r3, #0
 802556e:	d101      	bne.n	8025574 <remove_free_block+0x24>
 8025570:	bf00      	nop
 8025572:	e7fd      	b.n	8025570 <remove_free_block+0x20>
    tlsf_assert(next && "next_free field can not be null");
 8025574:	693b      	ldr	r3, [r7, #16]
 8025576:	2b00      	cmp	r3, #0
 8025578:	d101      	bne.n	802557e <remove_free_block+0x2e>
 802557a:	bf00      	nop
 802557c:	e7fd      	b.n	802557a <remove_free_block+0x2a>
    next->prev_free = prev;
 802557e:	693b      	ldr	r3, [r7, #16]
 8025580:	697a      	ldr	r2, [r7, #20]
 8025582:	60da      	str	r2, [r3, #12]
    prev->next_free = next;
 8025584:	697b      	ldr	r3, [r7, #20]
 8025586:	693a      	ldr	r2, [r7, #16]
 8025588:	609a      	str	r2, [r3, #8]

    /* If this block is the head of the free list, set new head. */
    if(control->blocks[fl][sl] == block) {
 802558a:	68fa      	ldr	r2, [r7, #12]
 802558c:	687b      	ldr	r3, [r7, #4]
 802558e:	0159      	lsls	r1, r3, #5
 8025590:	683b      	ldr	r3, [r7, #0]
 8025592:	440b      	add	r3, r1
 8025594:	330e      	adds	r3, #14
 8025596:	009b      	lsls	r3, r3, #2
 8025598:	4413      	add	r3, r2
 802559a:	685b      	ldr	r3, [r3, #4]
 802559c:	68ba      	ldr	r2, [r7, #8]
 802559e:	429a      	cmp	r2, r3
 80255a0:	d131      	bne.n	8025606 <remove_free_block+0xb6>
        control->blocks[fl][sl] = next;
 80255a2:	68fa      	ldr	r2, [r7, #12]
 80255a4:	687b      	ldr	r3, [r7, #4]
 80255a6:	0159      	lsls	r1, r3, #5
 80255a8:	683b      	ldr	r3, [r7, #0]
 80255aa:	440b      	add	r3, r1
 80255ac:	330e      	adds	r3, #14
 80255ae:	009b      	lsls	r3, r3, #2
 80255b0:	4413      	add	r3, r2
 80255b2:	693a      	ldr	r2, [r7, #16]
 80255b4:	605a      	str	r2, [r3, #4]

        /* If the new head is null, clear the bitmap. */
        if(next == &control->block_null) {
 80255b6:	68fb      	ldr	r3, [r7, #12]
 80255b8:	693a      	ldr	r2, [r7, #16]
 80255ba:	429a      	cmp	r2, r3
 80255bc:	d123      	bne.n	8025606 <remove_free_block+0xb6>
            control->sl_bitmap[fl] &= ~(1U << sl);
 80255be:	68fa      	ldr	r2, [r7, #12]
 80255c0:	687b      	ldr	r3, [r7, #4]
 80255c2:	3304      	adds	r3, #4
 80255c4:	009b      	lsls	r3, r3, #2
 80255c6:	4413      	add	r3, r2
 80255c8:	685a      	ldr	r2, [r3, #4]
 80255ca:	2101      	movs	r1, #1
 80255cc:	683b      	ldr	r3, [r7, #0]
 80255ce:	fa01 f303 	lsl.w	r3, r1, r3
 80255d2:	43db      	mvns	r3, r3
 80255d4:	401a      	ands	r2, r3
 80255d6:	68f9      	ldr	r1, [r7, #12]
 80255d8:	687b      	ldr	r3, [r7, #4]
 80255da:	3304      	adds	r3, #4
 80255dc:	009b      	lsls	r3, r3, #2
 80255de:	440b      	add	r3, r1
 80255e0:	605a      	str	r2, [r3, #4]

            /* If the second bitmap is now empty, clear the fl bitmap. */
            if(!control->sl_bitmap[fl]) {
 80255e2:	68fa      	ldr	r2, [r7, #12]
 80255e4:	687b      	ldr	r3, [r7, #4]
 80255e6:	3304      	adds	r3, #4
 80255e8:	009b      	lsls	r3, r3, #2
 80255ea:	4413      	add	r3, r2
 80255ec:	685b      	ldr	r3, [r3, #4]
 80255ee:	2b00      	cmp	r3, #0
 80255f0:	d109      	bne.n	8025606 <remove_free_block+0xb6>
                control->fl_bitmap &= ~(1U << fl);
 80255f2:	68fb      	ldr	r3, [r7, #12]
 80255f4:	691a      	ldr	r2, [r3, #16]
 80255f6:	2101      	movs	r1, #1
 80255f8:	687b      	ldr	r3, [r7, #4]
 80255fa:	fa01 f303 	lsl.w	r3, r1, r3
 80255fe:	43db      	mvns	r3, r3
 8025600:	401a      	ands	r2, r3
 8025602:	68fb      	ldr	r3, [r7, #12]
 8025604:	611a      	str	r2, [r3, #16]
            }
        }
    }
}
 8025606:	bf00      	nop
 8025608:	371c      	adds	r7, #28
 802560a:	46bd      	mov	sp, r7
 802560c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025610:	4770      	bx	lr

08025612 <insert_free_block>:

/* Insert a free block into the free block list. */
static void insert_free_block(control_t * control, block_header_t * block, int fl, int sl)
{
 8025612:	b590      	push	{r4, r7, lr}
 8025614:	b087      	sub	sp, #28
 8025616:	af00      	add	r7, sp, #0
 8025618:	60f8      	str	r0, [r7, #12]
 802561a:	60b9      	str	r1, [r7, #8]
 802561c:	607a      	str	r2, [r7, #4]
 802561e:	603b      	str	r3, [r7, #0]
    block_header_t * current = control->blocks[fl][sl];
 8025620:	68fa      	ldr	r2, [r7, #12]
 8025622:	687b      	ldr	r3, [r7, #4]
 8025624:	0159      	lsls	r1, r3, #5
 8025626:	683b      	ldr	r3, [r7, #0]
 8025628:	440b      	add	r3, r1
 802562a:	330e      	adds	r3, #14
 802562c:	009b      	lsls	r3, r3, #2
 802562e:	4413      	add	r3, r2
 8025630:	685b      	ldr	r3, [r3, #4]
 8025632:	617b      	str	r3, [r7, #20]
    tlsf_assert(current && "free list cannot have a null entry");
 8025634:	697b      	ldr	r3, [r7, #20]
 8025636:	2b00      	cmp	r3, #0
 8025638:	d101      	bne.n	802563e <insert_free_block+0x2c>
 802563a:	bf00      	nop
 802563c:	e7fd      	b.n	802563a <insert_free_block+0x28>
    tlsf_assert(block && "cannot insert a null entry into the free list");
 802563e:	68bb      	ldr	r3, [r7, #8]
 8025640:	2b00      	cmp	r3, #0
 8025642:	d101      	bne.n	8025648 <insert_free_block+0x36>
 8025644:	bf00      	nop
 8025646:	e7fd      	b.n	8025644 <insert_free_block+0x32>
    block->next_free = current;
 8025648:	68bb      	ldr	r3, [r7, #8]
 802564a:	697a      	ldr	r2, [r7, #20]
 802564c:	609a      	str	r2, [r3, #8]
    block->prev_free = &control->block_null;
 802564e:	68fa      	ldr	r2, [r7, #12]
 8025650:	68bb      	ldr	r3, [r7, #8]
 8025652:	60da      	str	r2, [r3, #12]
    current->prev_free = block;
 8025654:	697b      	ldr	r3, [r7, #20]
 8025656:	68ba      	ldr	r2, [r7, #8]
 8025658:	60da      	str	r2, [r3, #12]

    tlsf_assert(block_to_ptr(block) == align_ptr(block_to_ptr(block), ALIGN_SIZE)
 802565a:	68b8      	ldr	r0, [r7, #8]
 802565c:	f7ff fdee 	bl	802523c <block_to_ptr>
 8025660:	4604      	mov	r4, r0
 8025662:	68b8      	ldr	r0, [r7, #8]
 8025664:	f7ff fdea 	bl	802523c <block_to_ptr>
 8025668:	4603      	mov	r3, r0
 802566a:	2104      	movs	r1, #4
 802566c:	4618      	mov	r0, r3
 802566e:	f7ff fe97 	bl	80253a0 <align_ptr>
 8025672:	4603      	mov	r3, r0
 8025674:	429c      	cmp	r4, r3
 8025676:	d001      	beq.n	802567c <insert_free_block+0x6a>
 8025678:	bf00      	nop
 802567a:	e7fd      	b.n	8025678 <insert_free_block+0x66>
                && "block not aligned properly");
    /*
    ** Insert the new block at the head of the list, and mark the first-
    ** and second-level bitmaps appropriately.
    */
    control->blocks[fl][sl] = block;
 802567c:	68fa      	ldr	r2, [r7, #12]
 802567e:	687b      	ldr	r3, [r7, #4]
 8025680:	0159      	lsls	r1, r3, #5
 8025682:	683b      	ldr	r3, [r7, #0]
 8025684:	440b      	add	r3, r1
 8025686:	330e      	adds	r3, #14
 8025688:	009b      	lsls	r3, r3, #2
 802568a:	4413      	add	r3, r2
 802568c:	68ba      	ldr	r2, [r7, #8]
 802568e:	605a      	str	r2, [r3, #4]
    control->fl_bitmap |= (1U << fl);
 8025690:	68fb      	ldr	r3, [r7, #12]
 8025692:	691a      	ldr	r2, [r3, #16]
 8025694:	2101      	movs	r1, #1
 8025696:	687b      	ldr	r3, [r7, #4]
 8025698:	fa01 f303 	lsl.w	r3, r1, r3
 802569c:	431a      	orrs	r2, r3
 802569e:	68fb      	ldr	r3, [r7, #12]
 80256a0:	611a      	str	r2, [r3, #16]
    control->sl_bitmap[fl] |= (1U << sl);
 80256a2:	68fa      	ldr	r2, [r7, #12]
 80256a4:	687b      	ldr	r3, [r7, #4]
 80256a6:	3304      	adds	r3, #4
 80256a8:	009b      	lsls	r3, r3, #2
 80256aa:	4413      	add	r3, r2
 80256ac:	685a      	ldr	r2, [r3, #4]
 80256ae:	2101      	movs	r1, #1
 80256b0:	683b      	ldr	r3, [r7, #0]
 80256b2:	fa01 f303 	lsl.w	r3, r1, r3
 80256b6:	431a      	orrs	r2, r3
 80256b8:	68f9      	ldr	r1, [r7, #12]
 80256ba:	687b      	ldr	r3, [r7, #4]
 80256bc:	3304      	adds	r3, #4
 80256be:	009b      	lsls	r3, r3, #2
 80256c0:	440b      	add	r3, r1
 80256c2:	605a      	str	r2, [r3, #4]
}
 80256c4:	bf00      	nop
 80256c6:	371c      	adds	r7, #28
 80256c8:	46bd      	mov	sp, r7
 80256ca:	bd90      	pop	{r4, r7, pc}

080256cc <block_remove>:

/* Remove a given block from the free list. */
static void block_remove(control_t * control, block_header_t * block)
{
 80256cc:	b580      	push	{r7, lr}
 80256ce:	b084      	sub	sp, #16
 80256d0:	af00      	add	r7, sp, #0
 80256d2:	6078      	str	r0, [r7, #4]
 80256d4:	6039      	str	r1, [r7, #0]
    int fl, sl;
    mapping_insert(block_size(block), &fl, &sl);
 80256d6:	6838      	ldr	r0, [r7, #0]
 80256d8:	f7ff fd0b 	bl	80250f2 <block_size>
 80256dc:	f107 0208 	add.w	r2, r7, #8
 80256e0:	f107 030c 	add.w	r3, r7, #12
 80256e4:	4619      	mov	r1, r3
 80256e6:	f7ff fe96 	bl	8025416 <mapping_insert>
    remove_free_block(control, block, fl, sl);
 80256ea:	68fa      	ldr	r2, [r7, #12]
 80256ec:	68bb      	ldr	r3, [r7, #8]
 80256ee:	6839      	ldr	r1, [r7, #0]
 80256f0:	6878      	ldr	r0, [r7, #4]
 80256f2:	f7ff ff2d 	bl	8025550 <remove_free_block>
}
 80256f6:	bf00      	nop
 80256f8:	3710      	adds	r7, #16
 80256fa:	46bd      	mov	sp, r7
 80256fc:	bd80      	pop	{r7, pc}

080256fe <block_insert>:

/* Insert a given block into the free list. */
static void block_insert(control_t * control, block_header_t * block)
{
 80256fe:	b580      	push	{r7, lr}
 8025700:	b084      	sub	sp, #16
 8025702:	af00      	add	r7, sp, #0
 8025704:	6078      	str	r0, [r7, #4]
 8025706:	6039      	str	r1, [r7, #0]
    int fl, sl;
    mapping_insert(block_size(block), &fl, &sl);
 8025708:	6838      	ldr	r0, [r7, #0]
 802570a:	f7ff fcf2 	bl	80250f2 <block_size>
 802570e:	f107 0208 	add.w	r2, r7, #8
 8025712:	f107 030c 	add.w	r3, r7, #12
 8025716:	4619      	mov	r1, r3
 8025718:	f7ff fe7d 	bl	8025416 <mapping_insert>
    insert_free_block(control, block, fl, sl);
 802571c:	68fa      	ldr	r2, [r7, #12]
 802571e:	68bb      	ldr	r3, [r7, #8]
 8025720:	6839      	ldr	r1, [r7, #0]
 8025722:	6878      	ldr	r0, [r7, #4]
 8025724:	f7ff ff75 	bl	8025612 <insert_free_block>
}
 8025728:	bf00      	nop
 802572a:	3710      	adds	r7, #16
 802572c:	46bd      	mov	sp, r7
 802572e:	bd80      	pop	{r7, pc}

08025730 <block_can_split>:

static int block_can_split(block_header_t * block, size_t size)
{
 8025730:	b580      	push	{r7, lr}
 8025732:	b082      	sub	sp, #8
 8025734:	af00      	add	r7, sp, #0
 8025736:	6078      	str	r0, [r7, #4]
 8025738:	6039      	str	r1, [r7, #0]
    return block_size(block) >= sizeof(block_header_t) + size;
 802573a:	6878      	ldr	r0, [r7, #4]
 802573c:	f7ff fcd9 	bl	80250f2 <block_size>
 8025740:	4602      	mov	r2, r0
 8025742:	683b      	ldr	r3, [r7, #0]
 8025744:	3310      	adds	r3, #16
 8025746:	429a      	cmp	r2, r3
 8025748:	bf2c      	ite	cs
 802574a:	2301      	movcs	r3, #1
 802574c:	2300      	movcc	r3, #0
 802574e:	b2db      	uxtb	r3, r3
}
 8025750:	4618      	mov	r0, r3
 8025752:	3708      	adds	r7, #8
 8025754:	46bd      	mov	sp, r7
 8025756:	bd80      	pop	{r7, pc}

08025758 <block_split>:

/* Split a block into two, the second of which is free. */
static block_header_t * block_split(block_header_t * block, size_t size)
{
 8025758:	b590      	push	{r4, r7, lr}
 802575a:	b085      	sub	sp, #20
 802575c:	af00      	add	r7, sp, #0
 802575e:	6078      	str	r0, [r7, #4]
 8025760:	6039      	str	r1, [r7, #0]
    /* Calculate the amount of space left in the remaining block. */
    block_header_t * remaining =
        offset_to_block(block_to_ptr(block), size - block_header_overhead);
 8025762:	6878      	ldr	r0, [r7, #4]
 8025764:	f7ff fd6a 	bl	802523c <block_to_ptr>
 8025768:	4602      	mov	r2, r0
 802576a:	2104      	movs	r1, #4
 802576c:	683b      	ldr	r3, [r7, #0]
 802576e:	1a5b      	subs	r3, r3, r1
 8025770:	4619      	mov	r1, r3
 8025772:	4610      	mov	r0, r2
 8025774:	f7ff fd6f 	bl	8025256 <offset_to_block>
 8025778:	60f8      	str	r0, [r7, #12]

    const size_t remain_size = block_size(block) - (size + block_header_overhead);
 802577a:	6878      	ldr	r0, [r7, #4]
 802577c:	f7ff fcb9 	bl	80250f2 <block_size>
 8025780:	4602      	mov	r2, r0
 8025782:	2104      	movs	r1, #4
 8025784:	683b      	ldr	r3, [r7, #0]
 8025786:	440b      	add	r3, r1
 8025788:	1ad3      	subs	r3, r2, r3
 802578a:	60bb      	str	r3, [r7, #8]

    tlsf_assert(block_to_ptr(remaining) == align_ptr(block_to_ptr(remaining), ALIGN_SIZE)
 802578c:	68f8      	ldr	r0, [r7, #12]
 802578e:	f7ff fd55 	bl	802523c <block_to_ptr>
 8025792:	4604      	mov	r4, r0
 8025794:	68f8      	ldr	r0, [r7, #12]
 8025796:	f7ff fd51 	bl	802523c <block_to_ptr>
 802579a:	4603      	mov	r3, r0
 802579c:	2104      	movs	r1, #4
 802579e:	4618      	mov	r0, r3
 80257a0:	f7ff fdfe 	bl	80253a0 <align_ptr>
 80257a4:	4603      	mov	r3, r0
 80257a6:	429c      	cmp	r4, r3
 80257a8:	d001      	beq.n	80257ae <block_split+0x56>
 80257aa:	bf00      	nop
 80257ac:	e7fd      	b.n	80257aa <block_split+0x52>
                && "remaining block not aligned properly");

    tlsf_assert(block_size(block) == remain_size + size + block_header_overhead);
 80257ae:	6878      	ldr	r0, [r7, #4]
 80257b0:	f7ff fc9f 	bl	80250f2 <block_size>
 80257b4:	4601      	mov	r1, r0
 80257b6:	68ba      	ldr	r2, [r7, #8]
 80257b8:	683b      	ldr	r3, [r7, #0]
 80257ba:	4413      	add	r3, r2
 80257bc:	2204      	movs	r2, #4
 80257be:	4413      	add	r3, r2
 80257c0:	4299      	cmp	r1, r3
 80257c2:	d001      	beq.n	80257c8 <block_split+0x70>
 80257c4:	bf00      	nop
 80257c6:	e7fd      	b.n	80257c4 <block_split+0x6c>
    block_set_size(remaining, remain_size);
 80257c8:	68b9      	ldr	r1, [r7, #8]
 80257ca:	68f8      	ldr	r0, [r7, #12]
 80257cc:	f7ff fca2 	bl	8025114 <block_set_size>
    tlsf_assert(block_size(remaining) >= block_size_min && "block split with invalid size");
 80257d0:	68f8      	ldr	r0, [r7, #12]
 80257d2:	f7ff fc8e 	bl	80250f2 <block_size>
 80257d6:	4603      	mov	r3, r0
 80257d8:	220c      	movs	r2, #12
 80257da:	4293      	cmp	r3, r2
 80257dc:	d201      	bcs.n	80257e2 <block_split+0x8a>
 80257de:	bf00      	nop
 80257e0:	e7fd      	b.n	80257de <block_split+0x86>

    block_set_size(block, size);
 80257e2:	6839      	ldr	r1, [r7, #0]
 80257e4:	6878      	ldr	r0, [r7, #4]
 80257e6:	f7ff fc95 	bl	8025114 <block_set_size>
    block_mark_as_free(remaining);
 80257ea:	68f8      	ldr	r0, [r7, #12]
 80257ec:	f7ff fd83 	bl	80252f6 <block_mark_as_free>

    return remaining;
 80257f0:	68fb      	ldr	r3, [r7, #12]
}
 80257f2:	4618      	mov	r0, r3
 80257f4:	3714      	adds	r7, #20
 80257f6:	46bd      	mov	sp, r7
 80257f8:	bd90      	pop	{r4, r7, pc}

080257fa <block_absorb>:

/* Absorb a free block's storage into an adjacent previous free block. */
static block_header_t * block_absorb(block_header_t * prev, block_header_t * block)
{
 80257fa:	b580      	push	{r7, lr}
 80257fc:	b082      	sub	sp, #8
 80257fe:	af00      	add	r7, sp, #0
 8025800:	6078      	str	r0, [r7, #4]
 8025802:	6039      	str	r1, [r7, #0]
    tlsf_assert(!block_is_last(prev) && "previous block can't be last");
 8025804:	6878      	ldr	r0, [r7, #4]
 8025806:	f7ff fc9c 	bl	8025142 <block_is_last>
 802580a:	4603      	mov	r3, r0
 802580c:	2b00      	cmp	r3, #0
 802580e:	d001      	beq.n	8025814 <block_absorb+0x1a>
 8025810:	bf00      	nop
 8025812:	e7fd      	b.n	8025810 <block_absorb+0x16>
    /* Note: Leaves flags untouched. */
    prev->size += block_size(block) + block_header_overhead;
 8025814:	6838      	ldr	r0, [r7, #0]
 8025816:	f7ff fc6c 	bl	80250f2 <block_size>
 802581a:	4603      	mov	r3, r0
 802581c:	2204      	movs	r2, #4
 802581e:	441a      	add	r2, r3
 8025820:	687b      	ldr	r3, [r7, #4]
 8025822:	685b      	ldr	r3, [r3, #4]
 8025824:	441a      	add	r2, r3
 8025826:	687b      	ldr	r3, [r7, #4]
 8025828:	605a      	str	r2, [r3, #4]
    block_link_next(prev);
 802582a:	6878      	ldr	r0, [r7, #4]
 802582c:	f7ff fd53 	bl	80252d6 <block_link_next>
    return prev;
 8025830:	687b      	ldr	r3, [r7, #4]
}
 8025832:	4618      	mov	r0, r3
 8025834:	3708      	adds	r7, #8
 8025836:	46bd      	mov	sp, r7
 8025838:	bd80      	pop	{r7, pc}

0802583a <block_merge_prev>:

/* Merge a just-freed block with an adjacent previous free block. */
static block_header_t * block_merge_prev(control_t * control, block_header_t * block)
{
 802583a:	b580      	push	{r7, lr}
 802583c:	b084      	sub	sp, #16
 802583e:	af00      	add	r7, sp, #0
 8025840:	6078      	str	r0, [r7, #4]
 8025842:	6039      	str	r1, [r7, #0]
    if(block_is_prev_free(block)) {
 8025844:	6838      	ldr	r0, [r7, #0]
 8025846:	f7ff fcbc 	bl	80251c2 <block_is_prev_free>
 802584a:	4603      	mov	r3, r0
 802584c:	2b00      	cmp	r3, #0
 802584e:	d019      	beq.n	8025884 <block_merge_prev+0x4a>
        block_header_t * prev = block_prev(block);
 8025850:	6838      	ldr	r0, [r7, #0]
 8025852:	f7ff fd0e 	bl	8025272 <block_prev>
 8025856:	60f8      	str	r0, [r7, #12]
        tlsf_assert(prev && "prev physical block can't be null");
 8025858:	68fb      	ldr	r3, [r7, #12]
 802585a:	2b00      	cmp	r3, #0
 802585c:	d101      	bne.n	8025862 <block_merge_prev+0x28>
 802585e:	bf00      	nop
 8025860:	e7fd      	b.n	802585e <block_merge_prev+0x24>
        tlsf_assert(block_is_free(prev) && "prev block is not free though marked as such");
 8025862:	68f8      	ldr	r0, [r7, #12]
 8025864:	f7ff fc7e 	bl	8025164 <block_is_free>
 8025868:	4603      	mov	r3, r0
 802586a:	2b00      	cmp	r3, #0
 802586c:	d101      	bne.n	8025872 <block_merge_prev+0x38>
 802586e:	bf00      	nop
 8025870:	e7fd      	b.n	802586e <block_merge_prev+0x34>
        block_remove(control, prev);
 8025872:	68f9      	ldr	r1, [r7, #12]
 8025874:	6878      	ldr	r0, [r7, #4]
 8025876:	f7ff ff29 	bl	80256cc <block_remove>
        block = block_absorb(prev, block);
 802587a:	6839      	ldr	r1, [r7, #0]
 802587c:	68f8      	ldr	r0, [r7, #12]
 802587e:	f7ff ffbc 	bl	80257fa <block_absorb>
 8025882:	6038      	str	r0, [r7, #0]
    }

    return block;
 8025884:	683b      	ldr	r3, [r7, #0]
}
 8025886:	4618      	mov	r0, r3
 8025888:	3710      	adds	r7, #16
 802588a:	46bd      	mov	sp, r7
 802588c:	bd80      	pop	{r7, pc}

0802588e <block_merge_next>:

/* Merge a just-freed block with an adjacent free block. */
static block_header_t * block_merge_next(control_t * control, block_header_t * block)
{
 802588e:	b580      	push	{r7, lr}
 8025890:	b084      	sub	sp, #16
 8025892:	af00      	add	r7, sp, #0
 8025894:	6078      	str	r0, [r7, #4]
 8025896:	6039      	str	r1, [r7, #0]
    block_header_t * next = block_next(block);
 8025898:	6838      	ldr	r0, [r7, #0]
 802589a:	f7ff fcfc 	bl	8025296 <block_next>
 802589e:	60f8      	str	r0, [r7, #12]
    tlsf_assert(next && "next physical block can't be null");
 80258a0:	68fb      	ldr	r3, [r7, #12]
 80258a2:	2b00      	cmp	r3, #0
 80258a4:	d101      	bne.n	80258aa <block_merge_next+0x1c>
 80258a6:	bf00      	nop
 80258a8:	e7fd      	b.n	80258a6 <block_merge_next+0x18>

    if(block_is_free(next)) {
 80258aa:	68f8      	ldr	r0, [r7, #12]
 80258ac:	f7ff fc5a 	bl	8025164 <block_is_free>
 80258b0:	4603      	mov	r3, r0
 80258b2:	2b00      	cmp	r3, #0
 80258b4:	d010      	beq.n	80258d8 <block_merge_next+0x4a>
        tlsf_assert(!block_is_last(block) && "previous block can't be last");
 80258b6:	6838      	ldr	r0, [r7, #0]
 80258b8:	f7ff fc43 	bl	8025142 <block_is_last>
 80258bc:	4603      	mov	r3, r0
 80258be:	2b00      	cmp	r3, #0
 80258c0:	d001      	beq.n	80258c6 <block_merge_next+0x38>
 80258c2:	bf00      	nop
 80258c4:	e7fd      	b.n	80258c2 <block_merge_next+0x34>
        block_remove(control, next);
 80258c6:	68f9      	ldr	r1, [r7, #12]
 80258c8:	6878      	ldr	r0, [r7, #4]
 80258ca:	f7ff feff 	bl	80256cc <block_remove>
        block = block_absorb(block, next);
 80258ce:	68f9      	ldr	r1, [r7, #12]
 80258d0:	6838      	ldr	r0, [r7, #0]
 80258d2:	f7ff ff92 	bl	80257fa <block_absorb>
 80258d6:	6038      	str	r0, [r7, #0]
    }

    return block;
 80258d8:	683b      	ldr	r3, [r7, #0]
}
 80258da:	4618      	mov	r0, r3
 80258dc:	3710      	adds	r7, #16
 80258de:	46bd      	mov	sp, r7
 80258e0:	bd80      	pop	{r7, pc}

080258e2 <block_trim_free>:

/* Trim any trailing block space off the end of a block, return to pool. */
static void block_trim_free(control_t * control, block_header_t * block, size_t size)
{
 80258e2:	b580      	push	{r7, lr}
 80258e4:	b086      	sub	sp, #24
 80258e6:	af00      	add	r7, sp, #0
 80258e8:	60f8      	str	r0, [r7, #12]
 80258ea:	60b9      	str	r1, [r7, #8]
 80258ec:	607a      	str	r2, [r7, #4]
    tlsf_assert(block_is_free(block) && "block must be free");
 80258ee:	68b8      	ldr	r0, [r7, #8]
 80258f0:	f7ff fc38 	bl	8025164 <block_is_free>
 80258f4:	4603      	mov	r3, r0
 80258f6:	2b00      	cmp	r3, #0
 80258f8:	d101      	bne.n	80258fe <block_trim_free+0x1c>
 80258fa:	bf00      	nop
 80258fc:	e7fd      	b.n	80258fa <block_trim_free+0x18>
    if(block_can_split(block, size)) {
 80258fe:	6879      	ldr	r1, [r7, #4]
 8025900:	68b8      	ldr	r0, [r7, #8]
 8025902:	f7ff ff15 	bl	8025730 <block_can_split>
 8025906:	4603      	mov	r3, r0
 8025908:	2b00      	cmp	r3, #0
 802590a:	d00e      	beq.n	802592a <block_trim_free+0x48>
        block_header_t * remaining_block = block_split(block, size);
 802590c:	6879      	ldr	r1, [r7, #4]
 802590e:	68b8      	ldr	r0, [r7, #8]
 8025910:	f7ff ff22 	bl	8025758 <block_split>
 8025914:	6178      	str	r0, [r7, #20]
        block_link_next(block);
 8025916:	68b8      	ldr	r0, [r7, #8]
 8025918:	f7ff fcdd 	bl	80252d6 <block_link_next>
        block_set_prev_free(remaining_block);
 802591c:	6978      	ldr	r0, [r7, #20]
 802591e:	f7ff fc5e 	bl	80251de <block_set_prev_free>
        block_insert(control, remaining_block);
 8025922:	6979      	ldr	r1, [r7, #20]
 8025924:	68f8      	ldr	r0, [r7, #12]
 8025926:	f7ff feea 	bl	80256fe <block_insert>
    }
}
 802592a:	bf00      	nop
 802592c:	3718      	adds	r7, #24
 802592e:	46bd      	mov	sp, r7
 8025930:	bd80      	pop	{r7, pc}

08025932 <block_trim_used>:

/* Trim any trailing block space off the end of a used block, return to pool. */
static void block_trim_used(control_t * control, block_header_t * block, size_t size)
{
 8025932:	b580      	push	{r7, lr}
 8025934:	b086      	sub	sp, #24
 8025936:	af00      	add	r7, sp, #0
 8025938:	60f8      	str	r0, [r7, #12]
 802593a:	60b9      	str	r1, [r7, #8]
 802593c:	607a      	str	r2, [r7, #4]
    tlsf_assert(!block_is_free(block) && "block must be used");
 802593e:	68b8      	ldr	r0, [r7, #8]
 8025940:	f7ff fc10 	bl	8025164 <block_is_free>
 8025944:	4603      	mov	r3, r0
 8025946:	2b00      	cmp	r3, #0
 8025948:	d001      	beq.n	802594e <block_trim_used+0x1c>
 802594a:	bf00      	nop
 802594c:	e7fd      	b.n	802594a <block_trim_used+0x18>
    if(block_can_split(block, size)) {
 802594e:	6879      	ldr	r1, [r7, #4]
 8025950:	68b8      	ldr	r0, [r7, #8]
 8025952:	f7ff feed 	bl	8025730 <block_can_split>
 8025956:	4603      	mov	r3, r0
 8025958:	2b00      	cmp	r3, #0
 802595a:	d010      	beq.n	802597e <block_trim_used+0x4c>
        /* If the next block is free, we must coalesce. */
        block_header_t * remaining_block = block_split(block, size);
 802595c:	6879      	ldr	r1, [r7, #4]
 802595e:	68b8      	ldr	r0, [r7, #8]
 8025960:	f7ff fefa 	bl	8025758 <block_split>
 8025964:	6178      	str	r0, [r7, #20]
        block_set_prev_used(remaining_block);
 8025966:	6978      	ldr	r0, [r7, #20]
 8025968:	f7ff fc49 	bl	80251fe <block_set_prev_used>

        remaining_block = block_merge_next(control, remaining_block);
 802596c:	6979      	ldr	r1, [r7, #20]
 802596e:	68f8      	ldr	r0, [r7, #12]
 8025970:	f7ff ff8d 	bl	802588e <block_merge_next>
 8025974:	6178      	str	r0, [r7, #20]
        block_insert(control, remaining_block);
 8025976:	6979      	ldr	r1, [r7, #20]
 8025978:	68f8      	ldr	r0, [r7, #12]
 802597a:	f7ff fec0 	bl	80256fe <block_insert>
    }
}
 802597e:	bf00      	nop
 8025980:	3718      	adds	r7, #24
 8025982:	46bd      	mov	sp, r7
 8025984:	bd80      	pop	{r7, pc}

08025986 <block_locate_free>:

    return remaining_block;
}

static block_header_t * block_locate_free(control_t * control, size_t size)
{
 8025986:	b580      	push	{r7, lr}
 8025988:	b086      	sub	sp, #24
 802598a:	af00      	add	r7, sp, #0
 802598c:	6078      	str	r0, [r7, #4]
 802598e:	6039      	str	r1, [r7, #0]
    int fl = 0, sl = 0;
 8025990:	2300      	movs	r3, #0
 8025992:	613b      	str	r3, [r7, #16]
 8025994:	2300      	movs	r3, #0
 8025996:	60fb      	str	r3, [r7, #12]
    block_header_t * block = 0;
 8025998:	2300      	movs	r3, #0
 802599a:	617b      	str	r3, [r7, #20]

    if(size) {
 802599c:	683b      	ldr	r3, [r7, #0]
 802599e:	2b00      	cmp	r3, #0
 80259a0:	d013      	beq.n	80259ca <block_locate_free+0x44>
        mapping_search(size, &fl, &sl);
 80259a2:	f107 020c 	add.w	r2, r7, #12
 80259a6:	f107 0310 	add.w	r3, r7, #16
 80259aa:	4619      	mov	r1, r3
 80259ac:	6838      	ldr	r0, [r7, #0]
 80259ae:	f7ff fd5d 	bl	802546c <mapping_search>
        ** mapping_search can futz with the size, so for excessively large sizes it can sometimes wind up
        ** with indices that are off the end of the block array.
        ** So, we protect against that here, since this is the only callsite of mapping_search.
        ** Note that we don't need to check sl, since it comes from a modulo operation that guarantees it's always in range.
        */
        if(fl < FL_INDEX_COUNT) {
 80259b2:	693b      	ldr	r3, [r7, #16]
 80259b4:	2b09      	cmp	r3, #9
 80259b6:	dc08      	bgt.n	80259ca <block_locate_free+0x44>
            block = search_suitable_block(control, &fl, &sl);
 80259b8:	f107 020c 	add.w	r2, r7, #12
 80259bc:	f107 0310 	add.w	r3, r7, #16
 80259c0:	4619      	mov	r1, r3
 80259c2:	6878      	ldr	r0, [r7, #4]
 80259c4:	f7ff fd72 	bl	80254ac <search_suitable_block>
 80259c8:	6178      	str	r0, [r7, #20]
        }
    }

    if(block) {
 80259ca:	697b      	ldr	r3, [r7, #20]
 80259cc:	2b00      	cmp	r3, #0
 80259ce:	d00e      	beq.n	80259ee <block_locate_free+0x68>
        tlsf_assert(block_size(block) >= size);
 80259d0:	6978      	ldr	r0, [r7, #20]
 80259d2:	f7ff fb8e 	bl	80250f2 <block_size>
 80259d6:	4602      	mov	r2, r0
 80259d8:	683b      	ldr	r3, [r7, #0]
 80259da:	4293      	cmp	r3, r2
 80259dc:	d901      	bls.n	80259e2 <block_locate_free+0x5c>
 80259de:	bf00      	nop
 80259e0:	e7fd      	b.n	80259de <block_locate_free+0x58>
        remove_free_block(control, block, fl, sl);
 80259e2:	693a      	ldr	r2, [r7, #16]
 80259e4:	68fb      	ldr	r3, [r7, #12]
 80259e6:	6979      	ldr	r1, [r7, #20]
 80259e8:	6878      	ldr	r0, [r7, #4]
 80259ea:	f7ff fdb1 	bl	8025550 <remove_free_block>
    }

    return block;
 80259ee:	697b      	ldr	r3, [r7, #20]
}
 80259f0:	4618      	mov	r0, r3
 80259f2:	3718      	adds	r7, #24
 80259f4:	46bd      	mov	sp, r7
 80259f6:	bd80      	pop	{r7, pc}

080259f8 <block_prepare_used>:

static void * block_prepare_used(control_t * control, block_header_t * block, size_t size)
{
 80259f8:	b580      	push	{r7, lr}
 80259fa:	b086      	sub	sp, #24
 80259fc:	af00      	add	r7, sp, #0
 80259fe:	60f8      	str	r0, [r7, #12]
 8025a00:	60b9      	str	r1, [r7, #8]
 8025a02:	607a      	str	r2, [r7, #4]
    void * p = 0;
 8025a04:	2300      	movs	r3, #0
 8025a06:	617b      	str	r3, [r7, #20]
    if(block) {
 8025a08:	68bb      	ldr	r3, [r7, #8]
 8025a0a:	2b00      	cmp	r3, #0
 8025a0c:	d010      	beq.n	8025a30 <block_prepare_used+0x38>
        tlsf_assert(size && "size must be non-zero");
 8025a0e:	687b      	ldr	r3, [r7, #4]
 8025a10:	2b00      	cmp	r3, #0
 8025a12:	d101      	bne.n	8025a18 <block_prepare_used+0x20>
 8025a14:	bf00      	nop
 8025a16:	e7fd      	b.n	8025a14 <block_prepare_used+0x1c>
        block_trim_free(control, block, size);
 8025a18:	687a      	ldr	r2, [r7, #4]
 8025a1a:	68b9      	ldr	r1, [r7, #8]
 8025a1c:	68f8      	ldr	r0, [r7, #12]
 8025a1e:	f7ff ff60 	bl	80258e2 <block_trim_free>
        block_mark_as_used(block);
 8025a22:	68b8      	ldr	r0, [r7, #8]
 8025a24:	f7ff fc79 	bl	802531a <block_mark_as_used>
        p = block_to_ptr(block);
 8025a28:	68b8      	ldr	r0, [r7, #8]
 8025a2a:	f7ff fc07 	bl	802523c <block_to_ptr>
 8025a2e:	6178      	str	r0, [r7, #20]
    }
    return p;
 8025a30:	697b      	ldr	r3, [r7, #20]
}
 8025a32:	4618      	mov	r0, r3
 8025a34:	3718      	adds	r7, #24
 8025a36:	46bd      	mov	sp, r7
 8025a38:	bd80      	pop	{r7, pc}

08025a3a <control_constructor>:

/* Clear structure and point all empty lists at the null block. */
static void control_constructor(control_t * control)
{
 8025a3a:	b480      	push	{r7}
 8025a3c:	b085      	sub	sp, #20
 8025a3e:	af00      	add	r7, sp, #0
 8025a40:	6078      	str	r0, [r7, #4]
    int i, j;

    control->block_null.next_free = &control->block_null;
 8025a42:	687a      	ldr	r2, [r7, #4]
 8025a44:	687b      	ldr	r3, [r7, #4]
 8025a46:	609a      	str	r2, [r3, #8]
    control->block_null.prev_free = &control->block_null;
 8025a48:	687a      	ldr	r2, [r7, #4]
 8025a4a:	687b      	ldr	r3, [r7, #4]
 8025a4c:	60da      	str	r2, [r3, #12]

    control->fl_bitmap = 0;
 8025a4e:	687b      	ldr	r3, [r7, #4]
 8025a50:	2200      	movs	r2, #0
 8025a52:	611a      	str	r2, [r3, #16]
    for(i = 0; i < FL_INDEX_COUNT; ++i) {
 8025a54:	2300      	movs	r3, #0
 8025a56:	60fb      	str	r3, [r7, #12]
 8025a58:	e01c      	b.n	8025a94 <control_constructor+0x5a>
        control->sl_bitmap[i] = 0;
 8025a5a:	687a      	ldr	r2, [r7, #4]
 8025a5c:	68fb      	ldr	r3, [r7, #12]
 8025a5e:	3304      	adds	r3, #4
 8025a60:	009b      	lsls	r3, r3, #2
 8025a62:	4413      	add	r3, r2
 8025a64:	2200      	movs	r2, #0
 8025a66:	605a      	str	r2, [r3, #4]
        for(j = 0; j < SL_INDEX_COUNT; ++j) {
 8025a68:	2300      	movs	r3, #0
 8025a6a:	60bb      	str	r3, [r7, #8]
 8025a6c:	e00c      	b.n	8025a88 <control_constructor+0x4e>
            control->blocks[i][j] = &control->block_null;
 8025a6e:	687a      	ldr	r2, [r7, #4]
 8025a70:	6879      	ldr	r1, [r7, #4]
 8025a72:	68fb      	ldr	r3, [r7, #12]
 8025a74:	0158      	lsls	r0, r3, #5
 8025a76:	68bb      	ldr	r3, [r7, #8]
 8025a78:	4403      	add	r3, r0
 8025a7a:	330e      	adds	r3, #14
 8025a7c:	009b      	lsls	r3, r3, #2
 8025a7e:	440b      	add	r3, r1
 8025a80:	605a      	str	r2, [r3, #4]
        for(j = 0; j < SL_INDEX_COUNT; ++j) {
 8025a82:	68bb      	ldr	r3, [r7, #8]
 8025a84:	3301      	adds	r3, #1
 8025a86:	60bb      	str	r3, [r7, #8]
 8025a88:	68bb      	ldr	r3, [r7, #8]
 8025a8a:	2b1f      	cmp	r3, #31
 8025a8c:	ddef      	ble.n	8025a6e <control_constructor+0x34>
    for(i = 0; i < FL_INDEX_COUNT; ++i) {
 8025a8e:	68fb      	ldr	r3, [r7, #12]
 8025a90:	3301      	adds	r3, #1
 8025a92:	60fb      	str	r3, [r7, #12]
 8025a94:	68fb      	ldr	r3, [r7, #12]
 8025a96:	2b09      	cmp	r3, #9
 8025a98:	dddf      	ble.n	8025a5a <control_constructor+0x20>
        }
    }
}
 8025a9a:	bf00      	nop
 8025a9c:	bf00      	nop
 8025a9e:	3714      	adds	r7, #20
 8025aa0:	46bd      	mov	sp, r7
 8025aa2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025aa6:	4770      	bx	lr

08025aa8 <lv_tlsf_block_size>:
        block = block_next(block);
    }
}

size_t lv_tlsf_block_size(void * ptr)
{
 8025aa8:	b580      	push	{r7, lr}
 8025aaa:	b084      	sub	sp, #16
 8025aac:	af00      	add	r7, sp, #0
 8025aae:	6078      	str	r0, [r7, #4]
    size_t size = 0;
 8025ab0:	2300      	movs	r3, #0
 8025ab2:	60fb      	str	r3, [r7, #12]
    if(ptr) {
 8025ab4:	687b      	ldr	r3, [r7, #4]
 8025ab6:	2b00      	cmp	r3, #0
 8025ab8:	d007      	beq.n	8025aca <lv_tlsf_block_size+0x22>
        const block_header_t * block = block_from_ptr(ptr);
 8025aba:	6878      	ldr	r0, [r7, #4]
 8025abc:	f7ff fbb0 	bl	8025220 <block_from_ptr>
 8025ac0:	60b8      	str	r0, [r7, #8]
        size = block_size(block);
 8025ac2:	68b8      	ldr	r0, [r7, #8]
 8025ac4:	f7ff fb15 	bl	80250f2 <block_size>
 8025ac8:	60f8      	str	r0, [r7, #12]
    }
    return size;
 8025aca:	68fb      	ldr	r3, [r7, #12]
}
 8025acc:	4618      	mov	r0, r3
 8025ace:	3710      	adds	r7, #16
 8025ad0:	46bd      	mov	sp, r7
 8025ad2:	bd80      	pop	{r7, pc}

08025ad4 <lv_tlsf_size>:
/*
** Size of the TLSF structures in a given memory block passed to
** lv_tlsf_create, equal to the size of a control_t
*/
size_t lv_tlsf_size(void)
{
 8025ad4:	b480      	push	{r7}
 8025ad6:	af00      	add	r7, sp, #0
    return sizeof(control_t);
 8025ad8:	f240 533c 	movw	r3, #1340	@ 0x53c
}
 8025adc:	4618      	mov	r0, r3
 8025ade:	46bd      	mov	sp, r7
 8025ae0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025ae4:	4770      	bx	lr

08025ae6 <lv_tlsf_pool_overhead>:
** Overhead of the TLSF structures in a given memory block passed to
** lv_tlsf_add_pool, equal to the overhead of a free block and the
** sentinel block.
*/
size_t lv_tlsf_pool_overhead(void)
{
 8025ae6:	b480      	push	{r7}
 8025ae8:	af00      	add	r7, sp, #0
    return 2 * block_header_overhead;
 8025aea:	2304      	movs	r3, #4
 8025aec:	005b      	lsls	r3, r3, #1
}
 8025aee:	4618      	mov	r0, r3
 8025af0:	46bd      	mov	sp, r7
 8025af2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025af6:	4770      	bx	lr

08025af8 <lv_tlsf_add_pool>:
{
    return block_header_overhead;
}

lv_pool_t lv_tlsf_add_pool(lv_tlsf_t tlsf, void * mem, size_t bytes)
{
 8025af8:	b580      	push	{r7, lr}
 8025afa:	b088      	sub	sp, #32
 8025afc:	af00      	add	r7, sp, #0
 8025afe:	60f8      	str	r0, [r7, #12]
 8025b00:	60b9      	str	r1, [r7, #8]
 8025b02:	607a      	str	r2, [r7, #4]
    block_header_t * block;
    block_header_t * next;

    const size_t pool_overhead = lv_tlsf_pool_overhead();
 8025b04:	f7ff ffef 	bl	8025ae6 <lv_tlsf_pool_overhead>
 8025b08:	61f8      	str	r0, [r7, #28]
    const size_t pool_bytes = align_down(bytes - pool_overhead, ALIGN_SIZE);
 8025b0a:	687a      	ldr	r2, [r7, #4]
 8025b0c:	69fb      	ldr	r3, [r7, #28]
 8025b0e:	1ad3      	subs	r3, r2, r3
 8025b10:	2104      	movs	r1, #4
 8025b12:	4618      	mov	r0, r3
 8025b14:	f7ff fc2d 	bl	8025372 <align_down>
 8025b18:	61b8      	str	r0, [r7, #24]

    if(((ptrdiff_t)mem % ALIGN_SIZE) != 0) {
 8025b1a:	68bb      	ldr	r3, [r7, #8]
 8025b1c:	f003 0303 	and.w	r3, r3, #3
 8025b20:	2b00      	cmp	r3, #0
 8025b22:	d001      	beq.n	8025b28 <lv_tlsf_add_pool+0x30>
        printf("lv_tlsf_add_pool: Memory must be aligned by %u bytes.\n",
               (unsigned int)ALIGN_SIZE);
        return 0;
 8025b24:	2300      	movs	r3, #0
 8025b26:	e02e      	b.n	8025b86 <lv_tlsf_add_pool+0x8e>
    }

    if(pool_bytes < block_size_min || pool_bytes > block_size_max) {
 8025b28:	220c      	movs	r2, #12
 8025b2a:	69bb      	ldr	r3, [r7, #24]
 8025b2c:	4293      	cmp	r3, r2
 8025b2e:	d304      	bcc.n	8025b3a <lv_tlsf_add_pool+0x42>
 8025b30:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 8025b34:	69bb      	ldr	r3, [r7, #24]
 8025b36:	4293      	cmp	r3, r2
 8025b38:	d901      	bls.n	8025b3e <lv_tlsf_add_pool+0x46>
#else
        printf("lv_tlsf_add_pool: Memory size must be between %u and %u bytes.\n",
               (unsigned int)(pool_overhead + block_size_min),
               (unsigned int)(pool_overhead + block_size_max));
#endif
        return 0;
 8025b3a:	2300      	movs	r3, #0
 8025b3c:	e023      	b.n	8025b86 <lv_tlsf_add_pool+0x8e>
    /*
    ** Create the main free block. Offset the start of the block slightly
    ** so that the prev_phys_block field falls outside of the pool -
    ** it will never be used.
    */
    block = offset_to_block(mem, -(tlsfptr_t)block_header_overhead);
 8025b3e:	2304      	movs	r3, #4
 8025b40:	425b      	negs	r3, r3
 8025b42:	4619      	mov	r1, r3
 8025b44:	68b8      	ldr	r0, [r7, #8]
 8025b46:	f7ff fb86 	bl	8025256 <offset_to_block>
 8025b4a:	6178      	str	r0, [r7, #20]
    block_set_size(block, pool_bytes);
 8025b4c:	69b9      	ldr	r1, [r7, #24]
 8025b4e:	6978      	ldr	r0, [r7, #20]
 8025b50:	f7ff fae0 	bl	8025114 <block_set_size>
    block_set_free(block);
 8025b54:	6978      	ldr	r0, [r7, #20]
 8025b56:	f7ff fb13 	bl	8025180 <block_set_free>
    block_set_prev_used(block);
 8025b5a:	6978      	ldr	r0, [r7, #20]
 8025b5c:	f7ff fb4f 	bl	80251fe <block_set_prev_used>
    block_insert(tlsf_cast(control_t *, tlsf), block);
 8025b60:	6979      	ldr	r1, [r7, #20]
 8025b62:	68f8      	ldr	r0, [r7, #12]
 8025b64:	f7ff fdcb 	bl	80256fe <block_insert>

    /* Split the block to create a zero-size sentinel block. */
    next = block_link_next(block);
 8025b68:	6978      	ldr	r0, [r7, #20]
 8025b6a:	f7ff fbb4 	bl	80252d6 <block_link_next>
 8025b6e:	6138      	str	r0, [r7, #16]
    block_set_size(next, 0);
 8025b70:	2100      	movs	r1, #0
 8025b72:	6938      	ldr	r0, [r7, #16]
 8025b74:	f7ff face 	bl	8025114 <block_set_size>
    block_set_used(next);
 8025b78:	6938      	ldr	r0, [r7, #16]
 8025b7a:	f7ff fb11 	bl	80251a0 <block_set_used>
    block_set_prev_free(next);
 8025b7e:	6938      	ldr	r0, [r7, #16]
 8025b80:	f7ff fb2d 	bl	80251de <block_set_prev_free>

    return mem;
 8025b84:	68bb      	ldr	r3, [r7, #8]
}
 8025b86:	4618      	mov	r0, r3
 8025b88:	3720      	adds	r7, #32
 8025b8a:	46bd      	mov	sp, r7
 8025b8c:	bd80      	pop	{r7, pc}

08025b8e <lv_tlsf_create>:
    return rv;
}
#endif

lv_tlsf_t lv_tlsf_create(void * mem)
{
 8025b8e:	b580      	push	{r7, lr}
 8025b90:	b082      	sub	sp, #8
 8025b92:	af00      	add	r7, sp, #0
 8025b94:	6078      	str	r0, [r7, #4]
    if(test_ffs_fls()) {
        return 0;
    }
#endif

    if(((tlsfptr_t)mem % ALIGN_SIZE) != 0) {
 8025b96:	687b      	ldr	r3, [r7, #4]
 8025b98:	f003 0303 	and.w	r3, r3, #3
 8025b9c:	2b00      	cmp	r3, #0
 8025b9e:	d001      	beq.n	8025ba4 <lv_tlsf_create+0x16>
        printf("lv_tlsf_create: Memory must be aligned to %u bytes.\n",
               (unsigned int)ALIGN_SIZE);
        return 0;
 8025ba0:	2300      	movs	r3, #0
 8025ba2:	e003      	b.n	8025bac <lv_tlsf_create+0x1e>
    }

    control_constructor(tlsf_cast(control_t *, mem));
 8025ba4:	6878      	ldr	r0, [r7, #4]
 8025ba6:	f7ff ff48 	bl	8025a3a <control_constructor>

    return tlsf_cast(lv_tlsf_t, mem);
 8025baa:	687b      	ldr	r3, [r7, #4]
}
 8025bac:	4618      	mov	r0, r3
 8025bae:	3708      	adds	r7, #8
 8025bb0:	46bd      	mov	sp, r7
 8025bb2:	bd80      	pop	{r7, pc}

08025bb4 <lv_tlsf_create_with_pool>:

lv_tlsf_t lv_tlsf_create_with_pool(void * mem, size_t bytes)
{
 8025bb4:	b590      	push	{r4, r7, lr}
 8025bb6:	b085      	sub	sp, #20
 8025bb8:	af00      	add	r7, sp, #0
 8025bba:	6078      	str	r0, [r7, #4]
 8025bbc:	6039      	str	r1, [r7, #0]
    lv_tlsf_t tlsf = lv_tlsf_create(mem);
 8025bbe:	6878      	ldr	r0, [r7, #4]
 8025bc0:	f7ff ffe5 	bl	8025b8e <lv_tlsf_create>
 8025bc4:	60f8      	str	r0, [r7, #12]
    lv_tlsf_add_pool(tlsf, (char *)mem + lv_tlsf_size(), bytes - lv_tlsf_size());
 8025bc6:	f7ff ff85 	bl	8025ad4 <lv_tlsf_size>
 8025bca:	4602      	mov	r2, r0
 8025bcc:	687b      	ldr	r3, [r7, #4]
 8025bce:	189c      	adds	r4, r3, r2
 8025bd0:	f7ff ff80 	bl	8025ad4 <lv_tlsf_size>
 8025bd4:	4602      	mov	r2, r0
 8025bd6:	683b      	ldr	r3, [r7, #0]
 8025bd8:	1a9b      	subs	r3, r3, r2
 8025bda:	461a      	mov	r2, r3
 8025bdc:	4621      	mov	r1, r4
 8025bde:	68f8      	ldr	r0, [r7, #12]
 8025be0:	f7ff ff8a 	bl	8025af8 <lv_tlsf_add_pool>
    return tlsf;
 8025be4:	68fb      	ldr	r3, [r7, #12]
}
 8025be6:	4618      	mov	r0, r3
 8025be8:	3714      	adds	r7, #20
 8025bea:	46bd      	mov	sp, r7
 8025bec:	bd90      	pop	{r4, r7, pc}

08025bee <lv_tlsf_get_pool>:
    /* Nothing to do. */
    LV_UNUSED(tlsf);
}

lv_pool_t lv_tlsf_get_pool(lv_tlsf_t tlsf)
{
 8025bee:	b580      	push	{r7, lr}
 8025bf0:	b082      	sub	sp, #8
 8025bf2:	af00      	add	r7, sp, #0
 8025bf4:	6078      	str	r0, [r7, #4]
    return tlsf_cast(lv_pool_t, (char *)tlsf + lv_tlsf_size());
 8025bf6:	f7ff ff6d 	bl	8025ad4 <lv_tlsf_size>
 8025bfa:	4602      	mov	r2, r0
 8025bfc:	687b      	ldr	r3, [r7, #4]
 8025bfe:	4413      	add	r3, r2
}
 8025c00:	4618      	mov	r0, r3
 8025c02:	3708      	adds	r7, #8
 8025c04:	46bd      	mov	sp, r7
 8025c06:	bd80      	pop	{r7, pc}

08025c08 <lv_tlsf_malloc>:

void * lv_tlsf_malloc(lv_tlsf_t tlsf, size_t size)
{
 8025c08:	b580      	push	{r7, lr}
 8025c0a:	b086      	sub	sp, #24
 8025c0c:	af00      	add	r7, sp, #0
 8025c0e:	6078      	str	r0, [r7, #4]
 8025c10:	6039      	str	r1, [r7, #0]
    control_t * control = tlsf_cast(control_t *, tlsf);
 8025c12:	687b      	ldr	r3, [r7, #4]
 8025c14:	617b      	str	r3, [r7, #20]
    const size_t adjust = adjust_request_size(size, ALIGN_SIZE);
 8025c16:	2104      	movs	r1, #4
 8025c18:	6838      	ldr	r0, [r7, #0]
 8025c1a:	f7ff fbdd 	bl	80253d8 <adjust_request_size>
 8025c1e:	6138      	str	r0, [r7, #16]
    block_header_t * block = block_locate_free(control, adjust);
 8025c20:	6939      	ldr	r1, [r7, #16]
 8025c22:	6978      	ldr	r0, [r7, #20]
 8025c24:	f7ff feaf 	bl	8025986 <block_locate_free>
 8025c28:	60f8      	str	r0, [r7, #12]
    return block_prepare_used(control, block, adjust);
 8025c2a:	693a      	ldr	r2, [r7, #16]
 8025c2c:	68f9      	ldr	r1, [r7, #12]
 8025c2e:	6978      	ldr	r0, [r7, #20]
 8025c30:	f7ff fee2 	bl	80259f8 <block_prepare_used>
 8025c34:	4603      	mov	r3, r0
}
 8025c36:	4618      	mov	r0, r3
 8025c38:	3718      	adds	r7, #24
 8025c3a:	46bd      	mov	sp, r7
 8025c3c:	bd80      	pop	{r7, pc}

08025c3e <lv_tlsf_free>:

    return block_prepare_used(control, block, adjust);
}

size_t lv_tlsf_free(lv_tlsf_t tlsf, const void * ptr)
{
 8025c3e:	b580      	push	{r7, lr}
 8025c40:	b086      	sub	sp, #24
 8025c42:	af00      	add	r7, sp, #0
 8025c44:	6078      	str	r0, [r7, #4]
 8025c46:	6039      	str	r1, [r7, #0]
    size_t size = 0;
 8025c48:	2300      	movs	r3, #0
 8025c4a:	617b      	str	r3, [r7, #20]
    /* Don't attempt to free a NULL pointer. */
    if(ptr) {
 8025c4c:	683b      	ldr	r3, [r7, #0]
 8025c4e:	2b00      	cmp	r3, #0
 8025c50:	d021      	beq.n	8025c96 <lv_tlsf_free+0x58>
        control_t * control = tlsf_cast(control_t *, tlsf);
 8025c52:	687b      	ldr	r3, [r7, #4]
 8025c54:	613b      	str	r3, [r7, #16]
        block_header_t * block = block_from_ptr(ptr);
 8025c56:	6838      	ldr	r0, [r7, #0]
 8025c58:	f7ff fae2 	bl	8025220 <block_from_ptr>
 8025c5c:	60f8      	str	r0, [r7, #12]
        tlsf_assert(!block_is_free(block) && "block already marked as free");
 8025c5e:	68f8      	ldr	r0, [r7, #12]
 8025c60:	f7ff fa80 	bl	8025164 <block_is_free>
 8025c64:	4603      	mov	r3, r0
 8025c66:	2b00      	cmp	r3, #0
 8025c68:	d001      	beq.n	8025c6e <lv_tlsf_free+0x30>
 8025c6a:	bf00      	nop
 8025c6c:	e7fd      	b.n	8025c6a <lv_tlsf_free+0x2c>
        size = block->size;
 8025c6e:	68fb      	ldr	r3, [r7, #12]
 8025c70:	685b      	ldr	r3, [r3, #4]
 8025c72:	617b      	str	r3, [r7, #20]
        block_mark_as_free(block);
 8025c74:	68f8      	ldr	r0, [r7, #12]
 8025c76:	f7ff fb3e 	bl	80252f6 <block_mark_as_free>
        block = block_merge_prev(control, block);
 8025c7a:	68f9      	ldr	r1, [r7, #12]
 8025c7c:	6938      	ldr	r0, [r7, #16]
 8025c7e:	f7ff fddc 	bl	802583a <block_merge_prev>
 8025c82:	60f8      	str	r0, [r7, #12]
        block = block_merge_next(control, block);
 8025c84:	68f9      	ldr	r1, [r7, #12]
 8025c86:	6938      	ldr	r0, [r7, #16]
 8025c88:	f7ff fe01 	bl	802588e <block_merge_next>
 8025c8c:	60f8      	str	r0, [r7, #12]
        block_insert(control, block);
 8025c8e:	68f9      	ldr	r1, [r7, #12]
 8025c90:	6938      	ldr	r0, [r7, #16]
 8025c92:	f7ff fd34 	bl	80256fe <block_insert>
    }

    return size;
 8025c96:	697b      	ldr	r3, [r7, #20]
}
 8025c98:	4618      	mov	r0, r3
 8025c9a:	3718      	adds	r7, #24
 8025c9c:	46bd      	mov	sp, r7
 8025c9e:	bd80      	pop	{r7, pc}

08025ca0 <lv_tlsf_realloc>:
**   untouched
** - an extended buffer size will leave the newly-allocated area with
**   contents undefined
*/
void * lv_tlsf_realloc(lv_tlsf_t tlsf, void * ptr, size_t size)
{
 8025ca0:	b580      	push	{r7, lr}
 8025ca2:	b08c      	sub	sp, #48	@ 0x30
 8025ca4:	af00      	add	r7, sp, #0
 8025ca6:	60f8      	str	r0, [r7, #12]
 8025ca8:	60b9      	str	r1, [r7, #8]
 8025caa:	607a      	str	r2, [r7, #4]
    control_t * control = tlsf_cast(control_t *, tlsf);
 8025cac:	68fb      	ldr	r3, [r7, #12]
 8025cae:	62bb      	str	r3, [r7, #40]	@ 0x28
    void * p = 0;
 8025cb0:	2300      	movs	r3, #0
 8025cb2:	62fb      	str	r3, [r7, #44]	@ 0x2c

    /* Zero-size requests are treated as free. */
    if(ptr && size == 0) {
 8025cb4:	68bb      	ldr	r3, [r7, #8]
 8025cb6:	2b00      	cmp	r3, #0
 8025cb8:	d007      	beq.n	8025cca <lv_tlsf_realloc+0x2a>
 8025cba:	687b      	ldr	r3, [r7, #4]
 8025cbc:	2b00      	cmp	r3, #0
 8025cbe:	d104      	bne.n	8025cca <lv_tlsf_realloc+0x2a>
        lv_tlsf_free(tlsf, ptr);
 8025cc0:	68b9      	ldr	r1, [r7, #8]
 8025cc2:	68f8      	ldr	r0, [r7, #12]
 8025cc4:	f7ff ffbb 	bl	8025c3e <lv_tlsf_free>
 8025cc8:	e06b      	b.n	8025da2 <lv_tlsf_realloc+0x102>
    }
    /* Requests with NULL pointers are treated as malloc. */
    else if(!ptr) {
 8025cca:	68bb      	ldr	r3, [r7, #8]
 8025ccc:	2b00      	cmp	r3, #0
 8025cce:	d105      	bne.n	8025cdc <lv_tlsf_realloc+0x3c>
        p = lv_tlsf_malloc(tlsf, size);
 8025cd0:	6879      	ldr	r1, [r7, #4]
 8025cd2:	68f8      	ldr	r0, [r7, #12]
 8025cd4:	f7ff ff98 	bl	8025c08 <lv_tlsf_malloc>
 8025cd8:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8025cda:	e062      	b.n	8025da2 <lv_tlsf_realloc+0x102>
    }
    else {
        block_header_t * block = block_from_ptr(ptr);
 8025cdc:	68b8      	ldr	r0, [r7, #8]
 8025cde:	f7ff fa9f 	bl	8025220 <block_from_ptr>
 8025ce2:	6278      	str	r0, [r7, #36]	@ 0x24
        block_header_t * next = block_next(block);
 8025ce4:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8025ce6:	f7ff fad6 	bl	8025296 <block_next>
 8025cea:	6238      	str	r0, [r7, #32]

        const size_t cursize = block_size(block);
 8025cec:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8025cee:	f7ff fa00 	bl	80250f2 <block_size>
 8025cf2:	61f8      	str	r0, [r7, #28]
        const size_t combined = cursize + block_size(next) + block_header_overhead;
 8025cf4:	6a38      	ldr	r0, [r7, #32]
 8025cf6:	f7ff f9fc 	bl	80250f2 <block_size>
 8025cfa:	4602      	mov	r2, r0
 8025cfc:	69fb      	ldr	r3, [r7, #28]
 8025cfe:	4413      	add	r3, r2
 8025d00:	2204      	movs	r2, #4
 8025d02:	4413      	add	r3, r2
 8025d04:	61bb      	str	r3, [r7, #24]
        const size_t adjust = adjust_request_size(size, ALIGN_SIZE);
 8025d06:	2104      	movs	r1, #4
 8025d08:	6878      	ldr	r0, [r7, #4]
 8025d0a:	f7ff fb65 	bl	80253d8 <adjust_request_size>
 8025d0e:	6178      	str	r0, [r7, #20]
        if(size > cursize && adjust == 0) {
 8025d10:	687a      	ldr	r2, [r7, #4]
 8025d12:	69fb      	ldr	r3, [r7, #28]
 8025d14:	429a      	cmp	r2, r3
 8025d16:	d904      	bls.n	8025d22 <lv_tlsf_realloc+0x82>
 8025d18:	697b      	ldr	r3, [r7, #20]
 8025d1a:	2b00      	cmp	r3, #0
 8025d1c:	d101      	bne.n	8025d22 <lv_tlsf_realloc+0x82>
            /* The request is probably too large, fail */
            return NULL;
 8025d1e:	2300      	movs	r3, #0
 8025d20:	e040      	b.n	8025da4 <lv_tlsf_realloc+0x104>
        }

        tlsf_assert(!block_is_free(block) && "block already marked as free");
 8025d22:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8025d24:	f7ff fa1e 	bl	8025164 <block_is_free>
 8025d28:	4603      	mov	r3, r0
 8025d2a:	2b00      	cmp	r3, #0
 8025d2c:	d001      	beq.n	8025d32 <lv_tlsf_realloc+0x92>
 8025d2e:	bf00      	nop
 8025d30:	e7fd      	b.n	8025d2e <lv_tlsf_realloc+0x8e>

        /*
        ** If the next block is used, or when combined with the current
        ** block, does not offer enough space, we must reallocate and copy.
        */
        if(adjust > cursize && (!block_is_free(next) || adjust > combined)) {
 8025d32:	697a      	ldr	r2, [r7, #20]
 8025d34:	69fb      	ldr	r3, [r7, #28]
 8025d36:	429a      	cmp	r2, r3
 8025d38:	d921      	bls.n	8025d7e <lv_tlsf_realloc+0xde>
 8025d3a:	6a38      	ldr	r0, [r7, #32]
 8025d3c:	f7ff fa12 	bl	8025164 <block_is_free>
 8025d40:	4603      	mov	r3, r0
 8025d42:	2b00      	cmp	r3, #0
 8025d44:	d003      	beq.n	8025d4e <lv_tlsf_realloc+0xae>
 8025d46:	697a      	ldr	r2, [r7, #20]
 8025d48:	69bb      	ldr	r3, [r7, #24]
 8025d4a:	429a      	cmp	r2, r3
 8025d4c:	d917      	bls.n	8025d7e <lv_tlsf_realloc+0xde>
            p = lv_tlsf_malloc(tlsf, size);
 8025d4e:	6879      	ldr	r1, [r7, #4]
 8025d50:	68f8      	ldr	r0, [r7, #12]
 8025d52:	f7ff ff59 	bl	8025c08 <lv_tlsf_malloc>
 8025d56:	62f8      	str	r0, [r7, #44]	@ 0x2c
            if(p) {
 8025d58:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8025d5a:	2b00      	cmp	r3, #0
 8025d5c:	d021      	beq.n	8025da2 <lv_tlsf_realloc+0x102>
                const size_t minsize = tlsf_min(cursize, size);
 8025d5e:	687a      	ldr	r2, [r7, #4]
 8025d60:	69fb      	ldr	r3, [r7, #28]
 8025d62:	4293      	cmp	r3, r2
 8025d64:	bf28      	it	cs
 8025d66:	4613      	movcs	r3, r2
 8025d68:	613b      	str	r3, [r7, #16]
                lv_memcpy(p, ptr, minsize);
 8025d6a:	693a      	ldr	r2, [r7, #16]
 8025d6c:	68b9      	ldr	r1, [r7, #8]
 8025d6e:	6af8      	ldr	r0, [r7, #44]	@ 0x2c
 8025d70:	f7fe fe3a 	bl	80249e8 <lv_memcpy>
                lv_tlsf_free(tlsf, ptr);
 8025d74:	68b9      	ldr	r1, [r7, #8]
 8025d76:	68f8      	ldr	r0, [r7, #12]
 8025d78:	f7ff ff61 	bl	8025c3e <lv_tlsf_free>
            if(p) {
 8025d7c:	e011      	b.n	8025da2 <lv_tlsf_realloc+0x102>
            }
        }
        else {
            /* Do we need to expand to the next block? */
            if(adjust > cursize) {
 8025d7e:	697a      	ldr	r2, [r7, #20]
 8025d80:	69fb      	ldr	r3, [r7, #28]
 8025d82:	429a      	cmp	r2, r3
 8025d84:	d906      	bls.n	8025d94 <lv_tlsf_realloc+0xf4>
                block_merge_next(control, block);
 8025d86:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8025d88:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8025d8a:	f7ff fd80 	bl	802588e <block_merge_next>
                block_mark_as_used(block);
 8025d8e:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8025d90:	f7ff fac3 	bl	802531a <block_mark_as_used>
            }

            /* Trim the resulting block and return the original pointer. */
            block_trim_used(control, block, adjust);
 8025d94:	697a      	ldr	r2, [r7, #20]
 8025d96:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8025d98:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8025d9a:	f7ff fdca 	bl	8025932 <block_trim_used>
            p = ptr;
 8025d9e:	68bb      	ldr	r3, [r7, #8]
 8025da0:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }
    }

    return p;
 8025da2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
 8025da4:	4618      	mov	r0, r3
 8025da6:	3730      	adds	r7, #48	@ 0x30
 8025da8:	46bd      	mov	sp, r7
 8025daa:	bd80      	pop	{r7, pc}

08025dac <lv_memzero>:
 * Same as `memset(dst, 0x00, len)`.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
static inline void lv_memzero(void * dst, size_t len)
{
 8025dac:	b580      	push	{r7, lr}
 8025dae:	b082      	sub	sp, #8
 8025db0:	af00      	add	r7, sp, #0
 8025db2:	6078      	str	r0, [r7, #4]
 8025db4:	6039      	str	r1, [r7, #0]
    lv_memset(dst, 0x00, len);
 8025db6:	683a      	ldr	r2, [r7, #0]
 8025db8:	2100      	movs	r1, #0
 8025dba:	6878      	ldr	r0, [r7, #4]
 8025dbc:	f7ff f831 	bl	8024e22 <lv_memset>
}
 8025dc0:	bf00      	nop
 8025dc2:	3708      	adds	r7, #8
 8025dc4:	46bd      	mov	sp, r7
 8025dc6:	bd80      	pop	{r7, pc}

08025dc8 <lv_malloc>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void * lv_malloc(size_t size)
{
 8025dc8:	b580      	push	{r7, lr}
 8025dca:	b084      	sub	sp, #16
 8025dcc:	af00      	add	r7, sp, #0
 8025dce:	6078      	str	r0, [r7, #4]
    LV_TRACE_MEM("allocating %lu bytes", (unsigned long)size);
    if(size == 0) {
 8025dd0:	687b      	ldr	r3, [r7, #4]
 8025dd2:	2b00      	cmp	r3, #0
 8025dd4:	d101      	bne.n	8025dda <lv_malloc+0x12>
        LV_TRACE_MEM("using zero_mem");
        return &zero_mem;
 8025dd6:	4b08      	ldr	r3, [pc, #32]	@ (8025df8 <lv_malloc+0x30>)
 8025dd8:	e009      	b.n	8025dee <lv_malloc+0x26>
    }

    void * alloc = lv_malloc_core(size);
 8025dda:	6878      	ldr	r0, [r7, #4]
 8025ddc:	f7fe fd72 	bl	80248c4 <lv_malloc_core>
 8025de0:	60f8      	str	r0, [r7, #12]

    if(alloc == NULL) {
 8025de2:	68fb      	ldr	r3, [r7, #12]
 8025de4:	2b00      	cmp	r3, #0
 8025de6:	d101      	bne.n	8025dec <lv_malloc+0x24>
        lv_mem_monitor(&mon);
        LV_LOG_INFO("used: %zu (%3d %%), frag: %3d %%, biggest free: %zu",
                    mon.total_size - mon.free_size, mon.used_pct, mon.frag_pct,
                    mon.free_biggest_size);
#endif
        return NULL;
 8025de8:	2300      	movs	r3, #0
 8025dea:	e000      	b.n	8025dee <lv_malloc+0x26>
#if LV_MEM_ADD_JUNK
    lv_memset(alloc, 0xaa, size);
#endif

    LV_TRACE_MEM("allocated at %p", alloc);
    return alloc;
 8025dec:	68fb      	ldr	r3, [r7, #12]
}
 8025dee:	4618      	mov	r0, r3
 8025df0:	3710      	adds	r7, #16
 8025df2:	46bd      	mov	sp, r7
 8025df4:	bd80      	pop	{r7, pc}
 8025df6:	bf00      	nop
 8025df8:	20000100 	.word	0x20000100

08025dfc <lv_malloc_zeroed>:

void * lv_malloc_zeroed(size_t size)
{
 8025dfc:	b580      	push	{r7, lr}
 8025dfe:	b084      	sub	sp, #16
 8025e00:	af00      	add	r7, sp, #0
 8025e02:	6078      	str	r0, [r7, #4]
    LV_TRACE_MEM("allocating %lu bytes", (unsigned long)size);
    if(size == 0) {
 8025e04:	687b      	ldr	r3, [r7, #4]
 8025e06:	2b00      	cmp	r3, #0
 8025e08:	d101      	bne.n	8025e0e <lv_malloc_zeroed+0x12>
        LV_TRACE_MEM("using zero_mem");
        return &zero_mem;
 8025e0a:	4b0a      	ldr	r3, [pc, #40]	@ (8025e34 <lv_malloc_zeroed+0x38>)
 8025e0c:	e00d      	b.n	8025e2a <lv_malloc_zeroed+0x2e>
    }

    void * alloc = lv_malloc_core(size);
 8025e0e:	6878      	ldr	r0, [r7, #4]
 8025e10:	f7fe fd58 	bl	80248c4 <lv_malloc_core>
 8025e14:	60f8      	str	r0, [r7, #12]
    if(alloc == NULL) {
 8025e16:	68fb      	ldr	r3, [r7, #12]
 8025e18:	2b00      	cmp	r3, #0
 8025e1a:	d101      	bne.n	8025e20 <lv_malloc_zeroed+0x24>
        lv_mem_monitor(&mon);
        LV_LOG_INFO("used: %zu (%3d %%), frag: %3d %%, biggest free: %zu",
                    mon.total_size - mon.free_size, mon.used_pct, mon.frag_pct,
                    mon.free_biggest_size);
#endif
        return NULL;
 8025e1c:	2300      	movs	r3, #0
 8025e1e:	e004      	b.n	8025e2a <lv_malloc_zeroed+0x2e>
    }

    lv_memzero(alloc, size);
 8025e20:	6879      	ldr	r1, [r7, #4]
 8025e22:	68f8      	ldr	r0, [r7, #12]
 8025e24:	f7ff ffc2 	bl	8025dac <lv_memzero>

    LV_TRACE_MEM("allocated at %p", alloc);
    return alloc;
 8025e28:	68fb      	ldr	r3, [r7, #12]
}
 8025e2a:	4618      	mov	r0, r3
 8025e2c:	3710      	adds	r7, #16
 8025e2e:	46bd      	mov	sp, r7
 8025e30:	bd80      	pop	{r7, pc}
 8025e32:	bf00      	nop
 8025e34:	20000100 	.word	0x20000100

08025e38 <lv_free>:

void lv_free(void * data)
{
 8025e38:	b580      	push	{r7, lr}
 8025e3a:	b082      	sub	sp, #8
 8025e3c:	af00      	add	r7, sp, #0
 8025e3e:	6078      	str	r0, [r7, #4]
    LV_TRACE_MEM("freeing %p", data);
    if(data == &zero_mem) return;
 8025e40:	687b      	ldr	r3, [r7, #4]
 8025e42:	4a08      	ldr	r2, [pc, #32]	@ (8025e64 <lv_free+0x2c>)
 8025e44:	4293      	cmp	r3, r2
 8025e46:	d006      	beq.n	8025e56 <lv_free+0x1e>
    if(data == NULL) return;
 8025e48:	687b      	ldr	r3, [r7, #4]
 8025e4a:	2b00      	cmp	r3, #0
 8025e4c:	d005      	beq.n	8025e5a <lv_free+0x22>

    lv_free_core(data);
 8025e4e:	6878      	ldr	r0, [r7, #4]
 8025e50:	f7fe fda2 	bl	8024998 <lv_free_core>
 8025e54:	e002      	b.n	8025e5c <lv_free+0x24>
    if(data == &zero_mem) return;
 8025e56:	bf00      	nop
 8025e58:	e000      	b.n	8025e5c <lv_free+0x24>
    if(data == NULL) return;
 8025e5a:	bf00      	nop
}
 8025e5c:	3708      	adds	r7, #8
 8025e5e:	46bd      	mov	sp, r7
 8025e60:	bd80      	pop	{r7, pc}
 8025e62:	bf00      	nop
 8025e64:	20000100 	.word	0x20000100

08025e68 <lv_realloc>:

void * lv_realloc(void * data_p, size_t new_size)
{
 8025e68:	b580      	push	{r7, lr}
 8025e6a:	b084      	sub	sp, #16
 8025e6c:	af00      	add	r7, sp, #0
 8025e6e:	6078      	str	r0, [r7, #4]
 8025e70:	6039      	str	r1, [r7, #0]
    LV_TRACE_MEM("reallocating %p with %lu size", data_p, (unsigned long)new_size);
    if(new_size == 0) {
 8025e72:	683b      	ldr	r3, [r7, #0]
 8025e74:	2b00      	cmp	r3, #0
 8025e76:	d104      	bne.n	8025e82 <lv_realloc+0x1a>
        LV_TRACE_MEM("using zero_mem");
        lv_free(data_p);
 8025e78:	6878      	ldr	r0, [r7, #4]
 8025e7a:	f7ff ffdd 	bl	8025e38 <lv_free>
        return &zero_mem;
 8025e7e:	4b0d      	ldr	r3, [pc, #52]	@ (8025eb4 <lv_realloc+0x4c>)
 8025e80:	e013      	b.n	8025eaa <lv_realloc+0x42>
    }

    if(data_p == &zero_mem) return lv_malloc(new_size);
 8025e82:	687b      	ldr	r3, [r7, #4]
 8025e84:	4a0b      	ldr	r2, [pc, #44]	@ (8025eb4 <lv_realloc+0x4c>)
 8025e86:	4293      	cmp	r3, r2
 8025e88:	d104      	bne.n	8025e94 <lv_realloc+0x2c>
 8025e8a:	6838      	ldr	r0, [r7, #0]
 8025e8c:	f7ff ff9c 	bl	8025dc8 <lv_malloc>
 8025e90:	4603      	mov	r3, r0
 8025e92:	e00a      	b.n	8025eaa <lv_realloc+0x42>

    void * new_p = lv_realloc_core(data_p, new_size);
 8025e94:	6839      	ldr	r1, [r7, #0]
 8025e96:	6878      	ldr	r0, [r7, #4]
 8025e98:	f7fe fd42 	bl	8024920 <lv_realloc_core>
 8025e9c:	60f8      	str	r0, [r7, #12]

    if(new_p == NULL) {
 8025e9e:	68fb      	ldr	r3, [r7, #12]
 8025ea0:	2b00      	cmp	r3, #0
 8025ea2:	d101      	bne.n	8025ea8 <lv_realloc+0x40>
        LV_LOG_ERROR("couldn't reallocate memory");
        return NULL;
 8025ea4:	2300      	movs	r3, #0
 8025ea6:	e000      	b.n	8025eaa <lv_realloc+0x42>
    }

    LV_TRACE_MEM("reallocated at %p", new_p);
    return new_p;
 8025ea8:	68fb      	ldr	r3, [r7, #12]
}
 8025eaa:	4618      	mov	r0, r3
 8025eac:	3710      	adds	r7, #16
 8025eae:	46bd      	mov	sp, r7
 8025eb0:	bd80      	pop	{r7, pc}
 8025eb2:	bf00      	nop
 8025eb4:	20000100 	.word	0x20000100

08025eb8 <lv_theme_get_from_obj>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

lv_theme_t  * lv_theme_get_from_obj(lv_obj_t * obj)
{
 8025eb8:	b580      	push	{r7, lr}
 8025eba:	b084      	sub	sp, #16
 8025ebc:	af00      	add	r7, sp, #0
 8025ebe:	6078      	str	r0, [r7, #4]
    lv_display_t * disp = obj ? lv_obj_get_display(obj) : lv_display_get_default();
 8025ec0:	687b      	ldr	r3, [r7, #4]
 8025ec2:	2b00      	cmp	r3, #0
 8025ec4:	d004      	beq.n	8025ed0 <lv_theme_get_from_obj+0x18>
 8025ec6:	6878      	ldr	r0, [r7, #4]
 8025ec8:	f7e4 ff76 	bl	800adb8 <lv_obj_get_display>
 8025ecc:	4603      	mov	r3, r0
 8025ece:	e002      	b.n	8025ed6 <lv_theme_get_from_obj+0x1e>
 8025ed0:	f7e5 f906 	bl	800b0e0 <lv_display_get_default>
 8025ed4:	4603      	mov	r3, r0
 8025ed6:	60fb      	str	r3, [r7, #12]
    return lv_display_get_theme(disp);
 8025ed8:	68f8      	ldr	r0, [r7, #12]
 8025eda:	f7e5 fa43 	bl	800b364 <lv_display_get_theme>
 8025ede:	4603      	mov	r3, r0
}
 8025ee0:	4618      	mov	r0, r3
 8025ee2:	3710      	adds	r7, #16
 8025ee4:	46bd      	mov	sp, r7
 8025ee6:	bd80      	pop	{r7, pc}

08025ee8 <lv_theme_apply>:

void lv_theme_apply(lv_obj_t * obj)
{
 8025ee8:	b580      	push	{r7, lr}
 8025eea:	b084      	sub	sp, #16
 8025eec:	af00      	add	r7, sp, #0
 8025eee:	6078      	str	r0, [r7, #4]
    lv_theme_t * th = lv_theme_get_from_obj(obj);
 8025ef0:	6878      	ldr	r0, [r7, #4]
 8025ef2:	f7ff ffe1 	bl	8025eb8 <lv_theme_get_from_obj>
 8025ef6:	60f8      	str	r0, [r7, #12]
    if(th == NULL) return;
 8025ef8:	68fb      	ldr	r3, [r7, #12]
 8025efa:	2b00      	cmp	r3, #0
 8025efc:	d007      	beq.n	8025f0e <lv_theme_apply+0x26>

    lv_obj_remove_style_all(obj);
 8025efe:	6878      	ldr	r0, [r7, #4]
 8025f00:	f7e3 fa1a 	bl	8009338 <lv_obj_remove_style_all>

    apply_theme_recursion(th, obj);    /*Apply the theme including the base theme(s)*/
 8025f04:	6879      	ldr	r1, [r7, #4]
 8025f06:	68f8      	ldr	r0, [r7, #12]
 8025f08:	f000 f821 	bl	8025f4e <apply_theme_recursion>
 8025f0c:	e000      	b.n	8025f10 <lv_theme_apply+0x28>
    if(th == NULL) return;
 8025f0e:	bf00      	nop
}
 8025f10:	3710      	adds	r7, #16
 8025f12:	46bd      	mov	sp, r7
 8025f14:	bd80      	pop	{r7, pc}

08025f16 <apply_theme>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void apply_theme(lv_theme_t * th, lv_obj_t * obj)
{
 8025f16:	b580      	push	{r7, lr}
 8025f18:	b082      	sub	sp, #8
 8025f1a:	af00      	add	r7, sp, #0
 8025f1c:	6078      	str	r0, [r7, #4]
 8025f1e:	6039      	str	r1, [r7, #0]
    if(th->parent) apply_theme(th->parent, obj);
 8025f20:	687b      	ldr	r3, [r7, #4]
 8025f22:	685b      	ldr	r3, [r3, #4]
 8025f24:	2b00      	cmp	r3, #0
 8025f26:	d005      	beq.n	8025f34 <apply_theme+0x1e>
 8025f28:	687b      	ldr	r3, [r7, #4]
 8025f2a:	685b      	ldr	r3, [r3, #4]
 8025f2c:	6839      	ldr	r1, [r7, #0]
 8025f2e:	4618      	mov	r0, r3
 8025f30:	f7ff fff1 	bl	8025f16 <apply_theme>
    if(th->apply_cb) th->apply_cb(th, obj);
 8025f34:	687b      	ldr	r3, [r7, #4]
 8025f36:	681b      	ldr	r3, [r3, #0]
 8025f38:	2b00      	cmp	r3, #0
 8025f3a:	d004      	beq.n	8025f46 <apply_theme+0x30>
 8025f3c:	687b      	ldr	r3, [r7, #4]
 8025f3e:	681b      	ldr	r3, [r3, #0]
 8025f40:	6839      	ldr	r1, [r7, #0]
 8025f42:	6878      	ldr	r0, [r7, #4]
 8025f44:	4798      	blx	r3
}
 8025f46:	bf00      	nop
 8025f48:	3708      	adds	r7, #8
 8025f4a:	46bd      	mov	sp, r7
 8025f4c:	bd80      	pop	{r7, pc}

08025f4e <apply_theme_recursion>:

static void apply_theme_recursion(lv_theme_t * th, lv_obj_t * obj)
{
 8025f4e:	b580      	push	{r7, lr}
 8025f50:	b084      	sub	sp, #16
 8025f52:	af00      	add	r7, sp, #0
 8025f54:	6078      	str	r0, [r7, #4]
 8025f56:	6039      	str	r1, [r7, #0]
    const lv_obj_class_t * original_class_p = obj->class_p;
 8025f58:	683b      	ldr	r3, [r7, #0]
 8025f5a:	681b      	ldr	r3, [r3, #0]
 8025f5c:	60fb      	str	r3, [r7, #12]

    if(obj->class_p->base_class && obj->class_p->theme_inheritable == LV_OBJ_CLASS_THEME_INHERITABLE_TRUE) {
 8025f5e:	683b      	ldr	r3, [r7, #0]
 8025f60:	681b      	ldr	r3, [r3, #0]
 8025f62:	681b      	ldr	r3, [r3, #0]
 8025f64:	2b00      	cmp	r3, #0
 8025f66:	d011      	beq.n	8025f8c <apply_theme_recursion+0x3e>
 8025f68:	683b      	ldr	r3, [r7, #0]
 8025f6a:	681b      	ldr	r3, [r3, #0]
 8025f6c:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
 8025f70:	f003 0310 	and.w	r3, r3, #16
 8025f74:	b2db      	uxtb	r3, r3
 8025f76:	2b00      	cmp	r3, #0
 8025f78:	d008      	beq.n	8025f8c <apply_theme_recursion+0x3e>
        /*Apply the base class theme in obj*/
        obj->class_p = obj->class_p->base_class;
 8025f7a:	683b      	ldr	r3, [r7, #0]
 8025f7c:	681b      	ldr	r3, [r3, #0]
 8025f7e:	681a      	ldr	r2, [r3, #0]
 8025f80:	683b      	ldr	r3, [r7, #0]
 8025f82:	601a      	str	r2, [r3, #0]

        /*apply the base first*/
        apply_theme_recursion(th, obj);
 8025f84:	6839      	ldr	r1, [r7, #0]
 8025f86:	6878      	ldr	r0, [r7, #4]
 8025f88:	f7ff ffe1 	bl	8025f4e <apply_theme_recursion>
    }

    /*Restore the original class*/
    obj->class_p = original_class_p;
 8025f8c:	683b      	ldr	r3, [r7, #0]
 8025f8e:	68fa      	ldr	r2, [r7, #12]
 8025f90:	601a      	str	r2, [r3, #0]

    apply_theme(th, obj);
 8025f92:	6839      	ldr	r1, [r7, #0]
 8025f94:	6878      	ldr	r0, [r7, #4]
 8025f96:	f7ff ffbe 	bl	8025f16 <apply_theme>
}
 8025f9a:	bf00      	nop
 8025f9c:	3710      	adds	r7, #16
 8025f9e:	46bd      	mov	sp, r7
 8025fa0:	bd80      	pop	{r7, pc}
	...

08025fa4 <lv_tick_get>:
    state_p->sys_irq_flag = 0;
    state_p->sys_time += tick_period;
}

uint32_t lv_tick_get(void)
{
 8025fa4:	b580      	push	{r7, lr}
 8025fa6:	b082      	sub	sp, #8
 8025fa8:	af00      	add	r7, sp, #0
    lv_tick_state_t * state_p = &state;
 8025faa:	4b0d      	ldr	r3, [pc, #52]	@ (8025fe0 <lv_tick_get+0x3c>)
 8025fac:	607b      	str	r3, [r7, #4]

    if(state_p->tick_get_cb)
 8025fae:	687b      	ldr	r3, [r7, #4]
 8025fb0:	689b      	ldr	r3, [r3, #8]
 8025fb2:	2b00      	cmp	r3, #0
 8025fb4:	d004      	beq.n	8025fc0 <lv_tick_get+0x1c>
        return state_p->tick_get_cb();
 8025fb6:	687b      	ldr	r3, [r7, #4]
 8025fb8:	689b      	ldr	r3, [r3, #8]
 8025fba:	4798      	blx	r3
 8025fbc:	4603      	mov	r3, r0
 8025fbe:	e00b      	b.n	8025fd8 <lv_tick_get+0x34>
     *This loop detects if `lv_tick_inc` was called while reading `sys_time`.
     *If `tick_irq_flag` was cleared in `lv_tick_inc` try to read again
     *until `tick_irq_flag` remains `1`.*/
    uint32_t result;
    do {
        state_p->sys_irq_flag = 1;
 8025fc0:	687b      	ldr	r3, [r7, #4]
 8025fc2:	2201      	movs	r2, #1
 8025fc4:	711a      	strb	r2, [r3, #4]
        result        = state_p->sys_time;
 8025fc6:	687b      	ldr	r3, [r7, #4]
 8025fc8:	681b      	ldr	r3, [r3, #0]
 8025fca:	603b      	str	r3, [r7, #0]
    } while(!state_p->sys_irq_flag); /*Continue until see a non interrupted cycle*/
 8025fcc:	687b      	ldr	r3, [r7, #4]
 8025fce:	791b      	ldrb	r3, [r3, #4]
 8025fd0:	b2db      	uxtb	r3, r3
 8025fd2:	2b00      	cmp	r3, #0
 8025fd4:	d0f4      	beq.n	8025fc0 <lv_tick_get+0x1c>

    return result;
 8025fd6:	683b      	ldr	r3, [r7, #0]
}
 8025fd8:	4618      	mov	r0, r3
 8025fda:	3708      	adds	r7, #8
 8025fdc:	46bd      	mov	sp, r7
 8025fde:	bd80      	pop	{r7, pc}
 8025fe0:	20000160 	.word	0x20000160

08025fe4 <lv_tick_elaps>:

uint32_t lv_tick_elaps(uint32_t prev_tick)
{
 8025fe4:	b580      	push	{r7, lr}
 8025fe6:	b084      	sub	sp, #16
 8025fe8:	af00      	add	r7, sp, #0
 8025fea:	6078      	str	r0, [r7, #4]
    uint32_t act_time = lv_tick_get();
 8025fec:	f7ff ffda 	bl	8025fa4 <lv_tick_get>
 8025ff0:	60f8      	str	r0, [r7, #12]

    /*If there is no overflow in sys_time simple subtract*/
    if(act_time >= prev_tick) {
 8025ff2:	68fa      	ldr	r2, [r7, #12]
 8025ff4:	687b      	ldr	r3, [r7, #4]
 8025ff6:	429a      	cmp	r2, r3
 8025ff8:	d304      	bcc.n	8026004 <lv_tick_elaps+0x20>
        prev_tick = act_time - prev_tick;
 8025ffa:	68fa      	ldr	r2, [r7, #12]
 8025ffc:	687b      	ldr	r3, [r7, #4]
 8025ffe:	1ad3      	subs	r3, r2, r3
 8026000:	607b      	str	r3, [r7, #4]
 8026002:	e006      	b.n	8026012 <lv_tick_elaps+0x2e>
    }
    else {
        prev_tick = UINT32_MAX - prev_tick + 1;
 8026004:	687b      	ldr	r3, [r7, #4]
 8026006:	425b      	negs	r3, r3
 8026008:	607b      	str	r3, [r7, #4]
        prev_tick += act_time;
 802600a:	687a      	ldr	r2, [r7, #4]
 802600c:	68fb      	ldr	r3, [r7, #12]
 802600e:	4413      	add	r3, r2
 8026010:	607b      	str	r3, [r7, #4]
    }

    return prev_tick;
 8026012:	687b      	ldr	r3, [r7, #4]
}
 8026014:	4618      	mov	r0, r3
 8026016:	3710      	adds	r7, #16
 8026018:	46bd      	mov	sp, r7
 802601a:	bd80      	pop	{r7, pc}

0802601c <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline int32_t lv_area_get_width(const lv_area_t * area_p)
{
 802601c:	b480      	push	{r7}
 802601e:	b083      	sub	sp, #12
 8026020:	af00      	add	r7, sp, #0
 8026022:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->x2 - area_p->x1 + 1);
 8026024:	687b      	ldr	r3, [r7, #4]
 8026026:	689a      	ldr	r2, [r3, #8]
 8026028:	687b      	ldr	r3, [r7, #4]
 802602a:	681b      	ldr	r3, [r3, #0]
 802602c:	1ad3      	subs	r3, r2, r3
 802602e:	3301      	adds	r3, #1
}
 8026030:	4618      	mov	r0, r3
 8026032:	370c      	adds	r7, #12
 8026034:	46bd      	mov	sp, r7
 8026036:	f85d 7b04 	ldr.w	r7, [sp], #4
 802603a:	4770      	bx	lr

0802603c <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline int32_t lv_area_get_height(const lv_area_t * area_p)
{
 802603c:	b480      	push	{r7}
 802603e:	b083      	sub	sp, #12
 8026040:	af00      	add	r7, sp, #0
 8026042:	6078      	str	r0, [r7, #4]
    return (int32_t)(area_p->y2 - area_p->y1 + 1);
 8026044:	687b      	ldr	r3, [r7, #4]
 8026046:	68da      	ldr	r2, [r3, #12]
 8026048:	687b      	ldr	r3, [r7, #4]
 802604a:	685b      	ldr	r3, [r3, #4]
 802604c:	1ad3      	subs	r3, r2, r3
 802604e:	3301      	adds	r3, #1
}
 8026050:	4618      	mov	r0, r3
 8026052:	370c      	adds	r7, #12
 8026054:	46bd      	mov	sp, r7
 8026056:	f85d 7b04 	ldr.w	r7, [sp], #4
 802605a:	4770      	bx	lr

0802605c <lv_point_set>:

    return point;
}

static inline void lv_point_set(lv_point_t * p, int32_t x, int32_t y)
{
 802605c:	b480      	push	{r7}
 802605e:	b085      	sub	sp, #20
 8026060:	af00      	add	r7, sp, #0
 8026062:	60f8      	str	r0, [r7, #12]
 8026064:	60b9      	str	r1, [r7, #8]
 8026066:	607a      	str	r2, [r7, #4]
    p->x = x;
 8026068:	68fb      	ldr	r3, [r7, #12]
 802606a:	68ba      	ldr	r2, [r7, #8]
 802606c:	601a      	str	r2, [r3, #0]
    p->y = y;
 802606e:	68fb      	ldr	r3, [r7, #12]
 8026070:	687a      	ldr	r2, [r7, #4]
 8026072:	605a      	str	r2, [r3, #4]
}
 8026074:	bf00      	nop
 8026076:	3714      	adds	r7, #20
 8026078:	46bd      	mov	sp, r7
 802607a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802607e:	4770      	bx	lr

08026080 <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font      pointer to a font
 * @return the height of a font
 */
static inline int32_t lv_font_get_line_height(const lv_font_t * font)
{
 8026080:	b480      	push	{r7}
 8026082:	b083      	sub	sp, #12
 8026084:	af00      	add	r7, sp, #0
 8026086:	6078      	str	r0, [r7, #4]
    return font->line_height;
 8026088:	687b      	ldr	r3, [r7, #4]
 802608a:	68db      	ldr	r3, [r3, #12]
}
 802608c:	4618      	mov	r0, r3
 802608e:	370c      	adds	r7, #12
 8026090:	46bd      	mov	sp, r7
 8026092:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026096:	4770      	bx	lr

08026098 <lv_anim_set_var>:
 * Set a variable to animate
 * @param a     pointer to an initialized `lv_anim_t` variable
 * @param var   pointer to a variable to animate
 */
static inline void lv_anim_set_var(lv_anim_t * a, void * var)
{
 8026098:	b480      	push	{r7}
 802609a:	b083      	sub	sp, #12
 802609c:	af00      	add	r7, sp, #0
 802609e:	6078      	str	r0, [r7, #4]
 80260a0:	6039      	str	r1, [r7, #0]
    a->var = var;
 80260a2:	687b      	ldr	r3, [r7, #4]
 80260a4:	683a      	ldr	r2, [r7, #0]
 80260a6:	601a      	str	r2, [r3, #0]
}
 80260a8:	bf00      	nop
 80260aa:	370c      	adds	r7, #12
 80260ac:	46bd      	mov	sp, r7
 80260ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80260b2:	4770      	bx	lr

080260b4 <lv_anim_set_exec_cb>:
 * @param exec_cb   a function to execute during animation
 *                  LVGL's built-in functions can be used.
 *                  E.g. lv_obj_set_x
 */
static inline void lv_anim_set_exec_cb(lv_anim_t * a, lv_anim_exec_xcb_t exec_cb)
{
 80260b4:	b480      	push	{r7}
 80260b6:	b083      	sub	sp, #12
 80260b8:	af00      	add	r7, sp, #0
 80260ba:	6078      	str	r0, [r7, #4]
 80260bc:	6039      	str	r1, [r7, #0]
    a->exec_cb = exec_cb;
 80260be:	687b      	ldr	r3, [r7, #4]
 80260c0:	683a      	ldr	r2, [r7, #0]
 80260c2:	605a      	str	r2, [r3, #4]
}
 80260c4:	bf00      	nop
 80260c6:	370c      	adds	r7, #12
 80260c8:	46bd      	mov	sp, r7
 80260ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80260ce:	4770      	bx	lr

080260d0 <lv_anim_set_duration>:
 * Set the duration of an animation
 * @param a         pointer to an initialized `lv_anim_t` variable
 * @param duration  duration of the animation in milliseconds
 */
static inline void lv_anim_set_duration(lv_anim_t * a, uint32_t duration)
{
 80260d0:	b480      	push	{r7}
 80260d2:	b083      	sub	sp, #12
 80260d4:	af00      	add	r7, sp, #0
 80260d6:	6078      	str	r0, [r7, #4]
 80260d8:	6039      	str	r1, [r7, #0]
    a->duration = duration;
 80260da:	683a      	ldr	r2, [r7, #0]
 80260dc:	687b      	ldr	r3, [r7, #4]
 80260de:	631a      	str	r2, [r3, #48]	@ 0x30
}
 80260e0:	bf00      	nop
 80260e2:	370c      	adds	r7, #12
 80260e4:	46bd      	mov	sp, r7
 80260e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80260ea:	4770      	bx	lr

080260ec <lv_anim_set_values>:
 * @param a         pointer to an initialized `lv_anim_t` variable
 * @param start     the start value
 * @param end       the end value
 */
static inline void lv_anim_set_values(lv_anim_t * a, int32_t start, int32_t end)
{
 80260ec:	b480      	push	{r7}
 80260ee:	b085      	sub	sp, #20
 80260f0:	af00      	add	r7, sp, #0
 80260f2:	60f8      	str	r0, [r7, #12]
 80260f4:	60b9      	str	r1, [r7, #8]
 80260f6:	607a      	str	r2, [r7, #4]
    a->start_value = start;
 80260f8:	68fb      	ldr	r3, [r7, #12]
 80260fa:	68ba      	ldr	r2, [r7, #8]
 80260fc:	625a      	str	r2, [r3, #36]	@ 0x24
    a->current_value = INT32_MIN;
 80260fe:	68fb      	ldr	r3, [r7, #12]
 8026100:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
 8026104:	629a      	str	r2, [r3, #40]	@ 0x28
    a->end_value = end;
 8026106:	68fb      	ldr	r3, [r7, #12]
 8026108:	687a      	ldr	r2, [r7, #4]
 802610a:	62da      	str	r2, [r3, #44]	@ 0x2c
}
 802610c:	bf00      	nop
 802610e:	3714      	adds	r7, #20
 8026110:	46bd      	mov	sp, r7
 8026112:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026116:	4770      	bx	lr

08026118 <lv_anim_set_playback_duration>:
 * Make the animation to play back to when the forward direction is ready
 * @param a         pointer to an initialized `lv_anim_t` variable
 * @param time      the duration of the playback animation in milliseconds. 0: disable playback
 */
static inline void lv_anim_set_playback_duration(lv_anim_t * a, uint32_t duration)
{
 8026118:	b480      	push	{r7}
 802611a:	b083      	sub	sp, #12
 802611c:	af00      	add	r7, sp, #0
 802611e:	6078      	str	r0, [r7, #4]
 8026120:	6039      	str	r1, [r7, #0]
    a->playback_duration = duration;
 8026122:	687b      	ldr	r3, [r7, #4]
 8026124:	683a      	ldr	r2, [r7, #0]
 8026126:	63da      	str	r2, [r3, #60]	@ 0x3c
}
 8026128:	bf00      	nop
 802612a:	370c      	adds	r7, #12
 802612c:	46bd      	mov	sp, r7
 802612e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026132:	4770      	bx	lr

08026134 <lv_anim_set_playback_delay>:
 * Make the animation to play back to when the forward direction is ready
 * @param a         pointer to an initialized `lv_anim_t` variable
 * @param delay     delay in milliseconds before starting the playback animation.
 */
static inline void lv_anim_set_playback_delay(lv_anim_t * a, uint32_t delay)
{
 8026134:	b480      	push	{r7}
 8026136:	b083      	sub	sp, #12
 8026138:	af00      	add	r7, sp, #0
 802613a:	6078      	str	r0, [r7, #4]
 802613c:	6039      	str	r1, [r7, #0]
    a->playback_delay = delay;
 802613e:	687b      	ldr	r3, [r7, #4]
 8026140:	683a      	ldr	r2, [r7, #0]
 8026142:	639a      	str	r2, [r3, #56]	@ 0x38
}
 8026144:	bf00      	nop
 8026146:	370c      	adds	r7, #12
 8026148:	46bd      	mov	sp, r7
 802614a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802614e:	4770      	bx	lr

08026150 <lv_anim_set_repeat_count>:
 * Make the animation repeat itself.
 * @param a         pointer to an initialized `lv_anim_t` variable
 * @param cnt       repeat count or `LV_ANIM_REPEAT_INFINITE` for infinite repetition. 0: to disable repetition.
 */
static inline void lv_anim_set_repeat_count(lv_anim_t * a, uint16_t cnt)
{
 8026150:	b480      	push	{r7}
 8026152:	b083      	sub	sp, #12
 8026154:	af00      	add	r7, sp, #0
 8026156:	6078      	str	r0, [r7, #4]
 8026158:	460b      	mov	r3, r1
 802615a:	807b      	strh	r3, [r7, #2]
    a->repeat_cnt = cnt;
 802615c:	687b      	ldr	r3, [r7, #4]
 802615e:	887a      	ldrh	r2, [r7, #2]
 8026160:	f8a3 2044 	strh.w	r2, [r3, #68]	@ 0x44
}
 8026164:	bf00      	nop
 8026166:	370c      	adds	r7, #12
 8026168:	46bd      	mov	sp, r7
 802616a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802616e:	4770      	bx	lr

08026170 <lv_anim_set_repeat_delay>:
 * Set a delay before repeating the animation.
 * @param a         pointer to an initialized `lv_anim_t` variable
 * @param delay     delay in milliseconds before repeating the animation.
 */
static inline void lv_anim_set_repeat_delay(lv_anim_t * a, uint32_t delay)
{
 8026170:	b480      	push	{r7}
 8026172:	b083      	sub	sp, #12
 8026174:	af00      	add	r7, sp, #0
 8026176:	6078      	str	r0, [r7, #4]
 8026178:	6039      	str	r1, [r7, #0]
    a->repeat_delay = delay;
 802617a:	687b      	ldr	r3, [r7, #4]
 802617c:	683a      	ldr	r2, [r7, #0]
 802617e:	641a      	str	r2, [r3, #64]	@ 0x40
}
 8026180:	bf00      	nop
 8026182:	370c      	adds	r7, #12
 8026184:	46bd      	mov	sp, r7
 8026186:	f85d 7b04 	ldr.w	r7, [sp], #4
 802618a:	4770      	bx	lr

0802618c <lv_bidi_calculate_align>:
 * @param align     For LV_TEXT_ALIGN_AUTO give LV_TEXT_ALIGN_LEFT else leave unchanged, write back the calculated align here
 * @param base_dir  Unused
 * @param txt       Unused
 */
static inline void lv_bidi_calculate_align(lv_text_align_t * align, lv_base_dir_t * base_dir, const char * txt)
{
 802618c:	b480      	push	{r7}
 802618e:	b085      	sub	sp, #20
 8026190:	af00      	add	r7, sp, #0
 8026192:	60f8      	str	r0, [r7, #12]
 8026194:	60b9      	str	r1, [r7, #8]
 8026196:	607a      	str	r2, [r7, #4]
    LV_UNUSED(txt);
    LV_UNUSED(base_dir);
    if(*align == LV_TEXT_ALIGN_AUTO) * align = LV_TEXT_ALIGN_LEFT;
 8026198:	68fb      	ldr	r3, [r7, #12]
 802619a:	781b      	ldrb	r3, [r3, #0]
 802619c:	2b00      	cmp	r3, #0
 802619e:	d102      	bne.n	80261a6 <lv_bidi_calculate_align+0x1a>
 80261a0:	68fb      	ldr	r3, [r7, #12]
 80261a2:	2201      	movs	r2, #1
 80261a4:	701a      	strb	r2, [r3, #0]
}
 80261a6:	bf00      	nop
 80261a8:	3714      	adds	r7, #20
 80261aa:	46bd      	mov	sp, r7
 80261ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80261b0:	4770      	bx	lr

080261b2 <lv_obj_get_style_width>:
#include "../misc/lv_area.h"
#include "../misc/lv_style.h"
#include "../core/lv_obj_style.h"

static inline int32_t lv_obj_get_style_width(const lv_obj_t * obj, uint32_t part)
{
 80261b2:	b580      	push	{r7, lr}
 80261b4:	b084      	sub	sp, #16
 80261b6:	af00      	add	r7, sp, #0
 80261b8:	6078      	str	r0, [r7, #4]
 80261ba:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_WIDTH);
 80261bc:	2201      	movs	r2, #1
 80261be:	6839      	ldr	r1, [r7, #0]
 80261c0:	6878      	ldr	r0, [r7, #4]
 80261c2:	f7e3 fab1 	bl	8009728 <lv_obj_get_style_prop>
 80261c6:	4603      	mov	r3, r0
 80261c8:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80261ca:	68fb      	ldr	r3, [r7, #12]
}
 80261cc:	4618      	mov	r0, r3
 80261ce:	3710      	adds	r7, #16
 80261d0:	46bd      	mov	sp, r7
 80261d2:	bd80      	pop	{r7, pc}

080261d4 <lv_obj_get_style_max_width>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MIN_WIDTH);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_max_width(const lv_obj_t * obj, uint32_t part)
{
 80261d4:	b580      	push	{r7, lr}
 80261d6:	b084      	sub	sp, #16
 80261d8:	af00      	add	r7, sp, #0
 80261da:	6078      	str	r0, [r7, #4]
 80261dc:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MAX_WIDTH);
 80261de:	2205      	movs	r2, #5
 80261e0:	6839      	ldr	r1, [r7, #0]
 80261e2:	6878      	ldr	r0, [r7, #4]
 80261e4:	f7e3 faa0 	bl	8009728 <lv_obj_get_style_prop>
 80261e8:	4603      	mov	r3, r0
 80261ea:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 80261ec:	68fb      	ldr	r3, [r7, #12]
}
 80261ee:	4618      	mov	r0, r3
 80261f0:	3710      	adds	r7, #16
 80261f2:	46bd      	mov	sp, r7
 80261f4:	bd80      	pop	{r7, pc}

080261f6 <lv_obj_get_style_pad_top>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TRANSFORM_SKEW_Y);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_pad_top(const lv_obj_t * obj, uint32_t part)
{
 80261f6:	b580      	push	{r7, lr}
 80261f8:	b084      	sub	sp, #16
 80261fa:	af00      	add	r7, sp, #0
 80261fc:	6078      	str	r0, [r7, #4]
 80261fe:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_TOP);
 8026200:	2210      	movs	r2, #16
 8026202:	6839      	ldr	r1, [r7, #0]
 8026204:	6878      	ldr	r0, [r7, #4]
 8026206:	f7e3 fa8f 	bl	8009728 <lv_obj_get_style_prop>
 802620a:	4603      	mov	r3, r0
 802620c:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 802620e:	68fb      	ldr	r3, [r7, #12]
}
 8026210:	4618      	mov	r0, r3
 8026212:	3710      	adds	r7, #16
 8026214:	46bd      	mov	sp, r7
 8026216:	bd80      	pop	{r7, pc}

08026218 <lv_obj_get_style_pad_left>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_BOTTOM);
    return (int32_t)v.num;
}

static inline int32_t lv_obj_get_style_pad_left(const lv_obj_t * obj, uint32_t part)
{
 8026218:	b580      	push	{r7, lr}
 802621a:	b084      	sub	sp, #16
 802621c:	af00      	add	r7, sp, #0
 802621e:	6078      	str	r0, [r7, #4]
 8026220:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_PAD_LEFT);
 8026222:	2212      	movs	r2, #18
 8026224:	6839      	ldr	r1, [r7, #0]
 8026226:	6878      	ldr	r0, [r7, #4]
 8026228:	f7e3 fa7e 	bl	8009728 <lv_obj_get_style_prop>
 802622c:	4603      	mov	r3, r0
 802622e:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8026230:	68fb      	ldr	r3, [r7, #12]
}
 8026232:	4618      	mov	r0, r3
 8026234:	3710      	adds	r7, #16
 8026236:	46bd      	mov	sp, r7
 8026238:	bd80      	pop	{r7, pc}

0802623a <lv_obj_get_style_bg_color>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_MARGIN_RIGHT);
    return (int32_t)v.num;
}

static inline lv_color_t lv_obj_get_style_bg_color(const lv_obj_t * obj, uint32_t part)
{
 802623a:	b580      	push	{r7, lr}
 802623c:	b084      	sub	sp, #16
 802623e:	af00      	add	r7, sp, #0
 8026240:	6078      	str	r0, [r7, #4]
 8026242:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_BG_COLOR);
 8026244:	221c      	movs	r2, #28
 8026246:	6839      	ldr	r1, [r7, #0]
 8026248:	6878      	ldr	r0, [r7, #4]
 802624a:	f7e3 fa6d 	bl	8009728 <lv_obj_get_style_prop>
 802624e:	4603      	mov	r3, r0
 8026250:	60bb      	str	r3, [r7, #8]
    return v.color;
 8026252:	f107 030c 	add.w	r3, r7, #12
 8026256:	f107 0208 	add.w	r2, r7, #8
 802625a:	6812      	ldr	r2, [r2, #0]
 802625c:	4611      	mov	r1, r2
 802625e:	8019      	strh	r1, [r3, #0]
 8026260:	3302      	adds	r3, #2
 8026262:	0c12      	lsrs	r2, r2, #16
 8026264:	701a      	strb	r2, [r3, #0]
 8026266:	2300      	movs	r3, #0
 8026268:	7b3a      	ldrb	r2, [r7, #12]
 802626a:	f362 0307 	bfi	r3, r2, #0, #8
 802626e:	7b7a      	ldrb	r2, [r7, #13]
 8026270:	f362 230f 	bfi	r3, r2, #8, #8
 8026274:	7bba      	ldrb	r2, [r7, #14]
 8026276:	f362 4317 	bfi	r3, r2, #16, #8
}
 802627a:	4618      	mov	r0, r3
 802627c:	3710      	adds	r7, #16
 802627e:	46bd      	mov	sp, r7
 8026280:	bd80      	pop	{r7, pc}

08026282 <lv_obj_get_style_text_color_filtered>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_COLOR);
    return v.color;
}

static inline lv_color_t lv_obj_get_style_text_color_filtered(const lv_obj_t * obj, uint32_t part)
{
 8026282:	b580      	push	{r7, lr}
 8026284:	b086      	sub	sp, #24
 8026286:	af00      	add	r7, sp, #0
 8026288:	6078      	str	r0, [r7, #4]
 802628a:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = _lv_obj_style_apply_color_filter(obj, part, lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_COLOR));
 802628c:	2258      	movs	r2, #88	@ 0x58
 802628e:	6839      	ldr	r1, [r7, #0]
 8026290:	6878      	ldr	r0, [r7, #4]
 8026292:	f7e3 fa49 	bl	8009728 <lv_obj_get_style_prop>
 8026296:	4603      	mov	r3, r0
 8026298:	613b      	str	r3, [r7, #16]
 802629a:	693a      	ldr	r2, [r7, #16]
 802629c:	6839      	ldr	r1, [r7, #0]
 802629e:	6878      	ldr	r0, [r7, #4]
 80262a0:	f7e3 fbfc 	bl	8009a9c <_lv_obj_style_apply_color_filter>
 80262a4:	4603      	mov	r3, r0
 80262a6:	60fb      	str	r3, [r7, #12]
    return v.color;
 80262a8:	f107 0314 	add.w	r3, r7, #20
 80262ac:	f107 020c 	add.w	r2, r7, #12
 80262b0:	6812      	ldr	r2, [r2, #0]
 80262b2:	4611      	mov	r1, r2
 80262b4:	8019      	strh	r1, [r3, #0]
 80262b6:	3302      	adds	r3, #2
 80262b8:	0c12      	lsrs	r2, r2, #16
 80262ba:	701a      	strb	r2, [r3, #0]
 80262bc:	2300      	movs	r3, #0
 80262be:	7d3a      	ldrb	r2, [r7, #20]
 80262c0:	f362 0307 	bfi	r3, r2, #0, #8
 80262c4:	7d7a      	ldrb	r2, [r7, #21]
 80262c6:	f362 230f 	bfi	r3, r2, #8, #8
 80262ca:	7dba      	ldrb	r2, [r7, #22]
 80262cc:	f362 4317 	bfi	r3, r2, #16, #8
}
 80262d0:	4618      	mov	r0, r3
 80262d2:	3718      	adds	r7, #24
 80262d4:	46bd      	mov	sp, r7
 80262d6:	bd80      	pop	{r7, pc}

080262d8 <lv_obj_get_style_text_font>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_OPA);
    return (lv_opa_t)v.num;
}

static inline const lv_font_t * lv_obj_get_style_text_font(const lv_obj_t * obj, uint32_t part)
{
 80262d8:	b580      	push	{r7, lr}
 80262da:	b084      	sub	sp, #16
 80262dc:	af00      	add	r7, sp, #0
 80262de:	6078      	str	r0, [r7, #4]
 80262e0:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_FONT);
 80262e2:	225a      	movs	r2, #90	@ 0x5a
 80262e4:	6839      	ldr	r1, [r7, #0]
 80262e6:	6878      	ldr	r0, [r7, #4]
 80262e8:	f7e3 fa1e 	bl	8009728 <lv_obj_get_style_prop>
 80262ec:	4603      	mov	r3, r0
 80262ee:	60fb      	str	r3, [r7, #12]
    return (const lv_font_t *)v.ptr;
 80262f0:	68fb      	ldr	r3, [r7, #12]
}
 80262f2:	4618      	mov	r0, r3
 80262f4:	3710      	adds	r7, #16
 80262f6:	46bd      	mov	sp, r7
 80262f8:	bd80      	pop	{r7, pc}

080262fa <lv_obj_get_style_text_letter_space>:

static inline int32_t lv_obj_get_style_text_letter_space(const lv_obj_t * obj, uint32_t part)
{
 80262fa:	b580      	push	{r7, lr}
 80262fc:	b084      	sub	sp, #16
 80262fe:	af00      	add	r7, sp, #0
 8026300:	6078      	str	r0, [r7, #4]
 8026302:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_LETTER_SPACE);
 8026304:	225b      	movs	r2, #91	@ 0x5b
 8026306:	6839      	ldr	r1, [r7, #0]
 8026308:	6878      	ldr	r0, [r7, #4]
 802630a:	f7e3 fa0d 	bl	8009728 <lv_obj_get_style_prop>
 802630e:	4603      	mov	r3, r0
 8026310:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8026312:	68fb      	ldr	r3, [r7, #12]
}
 8026314:	4618      	mov	r0, r3
 8026316:	3710      	adds	r7, #16
 8026318:	46bd      	mov	sp, r7
 802631a:	bd80      	pop	{r7, pc}

0802631c <lv_obj_get_style_text_line_space>:

static inline int32_t lv_obj_get_style_text_line_space(const lv_obj_t * obj, uint32_t part)
{
 802631c:	b580      	push	{r7, lr}
 802631e:	b084      	sub	sp, #16
 8026320:	af00      	add	r7, sp, #0
 8026322:	6078      	str	r0, [r7, #4]
 8026324:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_TEXT_LINE_SPACE);
 8026326:	225c      	movs	r2, #92	@ 0x5c
 8026328:	6839      	ldr	r1, [r7, #0]
 802632a:	6878      	ldr	r0, [r7, #4]
 802632c:	f7e3 f9fc 	bl	8009728 <lv_obj_get_style_prop>
 8026330:	4603      	mov	r3, r0
 8026332:	60fb      	str	r3, [r7, #12]
    return (int32_t)v.num;
 8026334:	68fb      	ldr	r3, [r7, #12]
}
 8026336:	4618      	mov	r0, r3
 8026338:	3710      	adds	r7, #16
 802633a:	46bd      	mov	sp, r7
 802633c:	bd80      	pop	{r7, pc}

0802633e <lv_obj_get_style_anim>:
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_COLOR_FILTER_OPA);
    return (lv_opa_t)v.num;
}

static inline const lv_anim_t * lv_obj_get_style_anim(const lv_obj_t * obj, uint32_t part)
{
 802633e:	b580      	push	{r7, lr}
 8026340:	b084      	sub	sp, #16
 8026342:	af00      	add	r7, sp, #0
 8026344:	6078      	str	r0, [r7, #4]
 8026346:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ANIM);
 8026348:	2263      	movs	r2, #99	@ 0x63
 802634a:	6839      	ldr	r1, [r7, #0]
 802634c:	6878      	ldr	r0, [r7, #4]
 802634e:	f7e3 f9eb 	bl	8009728 <lv_obj_get_style_prop>
 8026352:	4603      	mov	r3, r0
 8026354:	60fb      	str	r3, [r7, #12]
    return (const lv_anim_t *)v.ptr;
 8026356:	68fb      	ldr	r3, [r7, #12]
}
 8026358:	4618      	mov	r0, r3
 802635a:	3710      	adds	r7, #16
 802635c:	46bd      	mov	sp, r7
 802635e:	bd80      	pop	{r7, pc}

08026360 <lv_obj_get_style_anim_duration>:

static inline uint32_t lv_obj_get_style_anim_duration(const lv_obj_t * obj, uint32_t part)
{
 8026360:	b580      	push	{r7, lr}
 8026362:	b084      	sub	sp, #16
 8026364:	af00      	add	r7, sp, #0
 8026366:	6078      	str	r0, [r7, #4]
 8026368:	6039      	str	r1, [r7, #0]
    lv_style_value_t v = lv_obj_get_style_prop(obj, part, LV_STYLE_ANIM_DURATION);
 802636a:	2264      	movs	r2, #100	@ 0x64
 802636c:	6839      	ldr	r1, [r7, #0]
 802636e:	6878      	ldr	r0, [r7, #4]
 8026370:	f7e3 f9da 	bl	8009728 <lv_obj_get_style_prop>
 8026374:	4603      	mov	r3, r0
 8026376:	60fb      	str	r3, [r7, #12]
    return (uint32_t)v.num;
 8026378:	68fb      	ldr	r3, [r7, #12]
}
 802637a:	4618      	mov	r0, r3
 802637c:	3710      	adds	r7, #16
 802637e:	46bd      	mov	sp, r7
 8026380:	bd80      	pop	{r7, pc}
	...

08026384 <lv_label_create>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

lv_obj_t * lv_label_create(lv_obj_t * parent)
{
 8026384:	b580      	push	{r7, lr}
 8026386:	b084      	sub	sp, #16
 8026388:	af00      	add	r7, sp, #0
 802638a:	6078      	str	r0, [r7, #4]
    LV_LOG_INFO("begin");
    lv_obj_t * obj = lv_obj_class_create_obj(MY_CLASS, parent);
 802638c:	6879      	ldr	r1, [r7, #4]
 802638e:	4806      	ldr	r0, [pc, #24]	@ (80263a8 <lv_label_create+0x24>)
 8026390:	f7dd fcca 	bl	8003d28 <lv_obj_class_create_obj>
 8026394:	60f8      	str	r0, [r7, #12]
    lv_obj_class_init_obj(obj);
 8026396:	68f8      	ldr	r0, [r7, #12]
 8026398:	f7dd fd5a 	bl	8003e50 <lv_obj_class_init_obj>
    return obj;
 802639c:	68fb      	ldr	r3, [r7, #12]
}
 802639e:	4618      	mov	r0, r3
 80263a0:	3710      	adds	r7, #16
 80263a2:	46bd      	mov	sp, r7
 80263a4:	bd80      	pop	{r7, pc}
 80263a6:	bf00      	nop
 80263a8:	0802b2fc 	.word	0x0802b2fc

080263ac <lv_label_set_text>:
/*=====================
 * Setter functions
 *====================*/

void lv_label_set_text(lv_obj_t * obj, const char * text)
{
 80263ac:	b580      	push	{r7, lr}
 80263ae:	b084      	sub	sp, #16
 80263b0:	af00      	add	r7, sp, #0
 80263b2:	6078      	str	r0, [r7, #4]
 80263b4:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, MY_CLASS);
    lv_label_t * label = (lv_label_t *)obj;
 80263b6:	687b      	ldr	r3, [r7, #4]
 80263b8:	60fb      	str	r3, [r7, #12]

    lv_obj_invalidate(obj);
 80263ba:	6878      	ldr	r0, [r7, #4]
 80263bc:	f7e0 f940 	bl	8006640 <lv_obj_invalidate>

    /*If text is NULL then just refresh with the current text*/
    if(text == NULL) text = label->text;
 80263c0:	683b      	ldr	r3, [r7, #0]
 80263c2:	2b00      	cmp	r3, #0
 80263c4:	d102      	bne.n	80263cc <lv_label_set_text+0x20>
 80263c6:	68fb      	ldr	r3, [r7, #12]
 80263c8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80263ca:	603b      	str	r3, [r7, #0]

    const size_t text_len = get_text_length(text);
 80263cc:	6838      	ldr	r0, [r7, #0]
 80263ce:	f001 fad7 	bl	8027980 <get_text_length>
 80263d2:	60b8      	str	r0, [r7, #8]

    /*If set its own text then reallocate it (maybe its size changed)*/
    if(label->text == text && label->static_txt == 0) {
 80263d4:	68fb      	ldr	r3, [r7, #12]
 80263d6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80263d8:	683a      	ldr	r2, [r7, #0]
 80263da:	429a      	cmp	r2, r3
 80263dc:	d11b      	bne.n	8026416 <lv_label_set_text+0x6a>
 80263de:	68fb      	ldr	r3, [r7, #12]
 80263e0:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 80263e4:	f003 0308 	and.w	r3, r3, #8
 80263e8:	b2db      	uxtb	r3, r3
 80263ea:	2b00      	cmp	r3, #0
 80263ec:	d113      	bne.n	8026416 <lv_label_set_text+0x6a>
        label->text = lv_realloc(label->text, text_len);
 80263ee:	68fb      	ldr	r3, [r7, #12]
 80263f0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80263f2:	68b9      	ldr	r1, [r7, #8]
 80263f4:	4618      	mov	r0, r3
 80263f6:	f7ff fd37 	bl	8025e68 <lv_realloc>
 80263fa:	4602      	mov	r2, r0
 80263fc:	68fb      	ldr	r3, [r7, #12]
 80263fe:	62da      	str	r2, [r3, #44]	@ 0x2c
        LV_ASSERT_MALLOC(label->text);
 8026400:	68fb      	ldr	r3, [r7, #12]
 8026402:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8026404:	2b00      	cmp	r3, #0
 8026406:	d101      	bne.n	802640c <lv_label_set_text+0x60>
 8026408:	bf00      	nop
 802640a:	e7fd      	b.n	8026408 <lv_label_set_text+0x5c>
        if(label->text == NULL) return;
 802640c:	68fb      	ldr	r3, [r7, #12]
 802640e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8026410:	2b00      	cmp	r3, #0
 8026412:	d12f      	bne.n	8026474 <lv_label_set_text+0xc8>
 8026414:	e033      	b.n	802647e <lv_label_set_text+0xd2>
#endif

    }
    else {
        /*Free the old text*/
        if(label->text != NULL && label->static_txt == 0) {
 8026416:	68fb      	ldr	r3, [r7, #12]
 8026418:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802641a:	2b00      	cmp	r3, #0
 802641c:	d00f      	beq.n	802643e <lv_label_set_text+0x92>
 802641e:	68fb      	ldr	r3, [r7, #12]
 8026420:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8026424:	f003 0308 	and.w	r3, r3, #8
 8026428:	b2db      	uxtb	r3, r3
 802642a:	2b00      	cmp	r3, #0
 802642c:	d107      	bne.n	802643e <lv_label_set_text+0x92>
            lv_free(label->text);
 802642e:	68fb      	ldr	r3, [r7, #12]
 8026430:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8026432:	4618      	mov	r0, r3
 8026434:	f7ff fd00 	bl	8025e38 <lv_free>
            label->text = NULL;
 8026438:	68fb      	ldr	r3, [r7, #12]
 802643a:	2200      	movs	r2, #0
 802643c:	62da      	str	r2, [r3, #44]	@ 0x2c
        }

        label->text = lv_malloc(text_len);
 802643e:	68b8      	ldr	r0, [r7, #8]
 8026440:	f7ff fcc2 	bl	8025dc8 <lv_malloc>
 8026444:	4602      	mov	r2, r0
 8026446:	68fb      	ldr	r3, [r7, #12]
 8026448:	62da      	str	r2, [r3, #44]	@ 0x2c
        LV_ASSERT_MALLOC(label->text);
 802644a:	68fb      	ldr	r3, [r7, #12]
 802644c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802644e:	2b00      	cmp	r3, #0
 8026450:	d101      	bne.n	8026456 <lv_label_set_text+0xaa>
 8026452:	bf00      	nop
 8026454:	e7fd      	b.n	8026452 <lv_label_set_text+0xa6>
        if(label->text == NULL) return;
 8026456:	68fb      	ldr	r3, [r7, #12]
 8026458:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802645a:	2b00      	cmp	r3, #0
 802645c:	d00e      	beq.n	802647c <lv_label_set_text+0xd0>

        copy_text_to_label(label, text);
 802645e:	6839      	ldr	r1, [r7, #0]
 8026460:	68f8      	ldr	r0, [r7, #12]
 8026462:	f001 fa9e 	bl	80279a2 <copy_text_to_label>

        /*Now the text is dynamically allocated*/
        label->static_txt = 0;
 8026466:	68fa      	ldr	r2, [r7, #12]
 8026468:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 802646c:	f36f 03c3 	bfc	r3, #3, #1
 8026470:	f882 305c 	strb.w	r3, [r2, #92]	@ 0x5c
    }

    lv_label_refr_text(obj);
 8026474:	6878      	ldr	r0, [r7, #4]
 8026476:	f000 fd01 	bl	8026e7c <lv_label_refr_text>
 802647a:	e000      	b.n	802647e <lv_label_set_text+0xd2>
        if(label->text == NULL) return;
 802647c:	bf00      	nop
}
 802647e:	3710      	adds	r7, #16
 8026480:	46bd      	mov	sp, r7
 8026482:	bd80      	pop	{r7, pc}

08026484 <lv_label_set_long_mode>:

    lv_label_refr_text(obj);
}

void lv_label_set_long_mode(lv_obj_t * obj, lv_label_long_mode_t long_mode)
{
 8026484:	b580      	push	{r7, lr}
 8026486:	b084      	sub	sp, #16
 8026488:	af00      	add	r7, sp, #0
 802648a:	6078      	str	r0, [r7, #4]
 802648c:	460b      	mov	r3, r1
 802648e:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, MY_CLASS);

    lv_label_t * label = (lv_label_t *)obj;
 8026490:	687b      	ldr	r3, [r7, #4]
 8026492:	60fb      	str	r3, [r7, #12]

    /*Delete the old animation (if exists)*/
    lv_anim_delete(obj, set_ofs_x_anim);
 8026494:	4924      	ldr	r1, [pc, #144]	@ (8026528 <lv_label_set_long_mode+0xa4>)
 8026496:	6878      	ldr	r0, [r7, #4]
 8026498:	f7fa fdf0 	bl	802107c <lv_anim_delete>
    lv_anim_delete(obj, set_ofs_y_anim);
 802649c:	4923      	ldr	r1, [pc, #140]	@ (802652c <lv_label_set_long_mode+0xa8>)
 802649e:	6878      	ldr	r0, [r7, #4]
 80264a0:	f7fa fdec 	bl	802107c <lv_anim_delete>
    lv_point_set(&label->offset, 0, 0);
 80264a4:	68fb      	ldr	r3, [r7, #12]
 80264a6:	3354      	adds	r3, #84	@ 0x54
 80264a8:	2200      	movs	r2, #0
 80264aa:	2100      	movs	r1, #0
 80264ac:	4618      	mov	r0, r3
 80264ae:	f7ff fdd5 	bl	802605c <lv_point_set>

    if(long_mode == LV_LABEL_LONG_SCROLL || long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR || long_mode == LV_LABEL_LONG_CLIP)
 80264b2:	78fb      	ldrb	r3, [r7, #3]
 80264b4:	2b02      	cmp	r3, #2
 80264b6:	d005      	beq.n	80264c4 <lv_label_set_long_mode+0x40>
 80264b8:	78fb      	ldrb	r3, [r7, #3]
 80264ba:	2b03      	cmp	r3, #3
 80264bc:	d002      	beq.n	80264c4 <lv_label_set_long_mode+0x40>
 80264be:	78fb      	ldrb	r3, [r7, #3]
 80264c0:	2b04      	cmp	r3, #4
 80264c2:	d107      	bne.n	80264d4 <lv_label_set_long_mode+0x50>
        label->expand = 1;
 80264c4:	68fa      	ldr	r2, [r7, #12]
 80264c6:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 80264ca:	f043 0310 	orr.w	r3, r3, #16
 80264ce:	f882 305c 	strb.w	r3, [r2, #92]	@ 0x5c
 80264d2:	e006      	b.n	80264e2 <lv_label_set_long_mode+0x5e>
    else
        label->expand = 0;
 80264d4:	68fa      	ldr	r2, [r7, #12]
 80264d6:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 80264da:	f36f 1304 	bfc	r3, #4, #1
 80264de:	f882 305c 	strb.w	r3, [r2, #92]	@ 0x5c

    /*Restore the character under the dots*/
    if(label->long_mode == LV_LABEL_LONG_DOT && label->dot_end != LV_LABEL_DOT_END_INV) {
 80264e2:	68fb      	ldr	r3, [r7, #12]
 80264e4:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 80264e8:	f003 0307 	and.w	r3, r3, #7
 80264ec:	b2db      	uxtb	r3, r3
 80264ee:	2b01      	cmp	r3, #1
 80264f0:	d107      	bne.n	8026502 <lv_label_set_long_mode+0x7e>
 80264f2:	68fb      	ldr	r3, [r7, #12]
 80264f4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80264f6:	f1b3 3fff 	cmp.w	r3, #4294967295
 80264fa:	d002      	beq.n	8026502 <lv_label_set_long_mode+0x7e>
        lv_label_revert_dots(obj);
 80264fc:	6878      	ldr	r0, [r7, #4]
 80264fe:	f001 f943 	bl	8027788 <lv_label_revert_dots>
    }

    label->long_mode = long_mode;
 8026502:	78fb      	ldrb	r3, [r7, #3]
 8026504:	f003 0307 	and.w	r3, r3, #7
 8026508:	b2d9      	uxtb	r1, r3
 802650a:	68fa      	ldr	r2, [r7, #12]
 802650c:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 8026510:	f361 0302 	bfi	r3, r1, #0, #3
 8026514:	f882 305c 	strb.w	r3, [r2, #92]	@ 0x5c
    lv_label_refr_text(obj);
 8026518:	6878      	ldr	r0, [r7, #4]
 802651a:	f000 fcaf 	bl	8026e7c <lv_label_refr_text>
}
 802651e:	bf00      	nop
 8026520:	3710      	adds	r7, #16
 8026522:	46bd      	mov	sp, r7
 8026524:	bd80      	pop	{r7, pc}
 8026526:	bf00      	nop
 8026528:	0802793d 	.word	0x0802793d
 802652c:	0802795f 	.word	0x0802795f

08026530 <lv_label_get_text>:
/*=====================
 * Getter functions
 *====================*/

char * lv_label_get_text(const lv_obj_t * obj)
{
 8026530:	b480      	push	{r7}
 8026532:	b085      	sub	sp, #20
 8026534:	af00      	add	r7, sp, #0
 8026536:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);
    lv_label_t * label = (lv_label_t *)obj;
 8026538:	687b      	ldr	r3, [r7, #4]
 802653a:	60fb      	str	r3, [r7, #12]
    return label->text;
 802653c:	68fb      	ldr	r3, [r7, #12]
 802653e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
}
 8026540:	4618      	mov	r0, r3
 8026542:	3714      	adds	r7, #20
 8026544:	46bd      	mov	sp, r7
 8026546:	f85d 7b04 	ldr.w	r7, [sp], #4
 802654a:	4770      	bx	lr

0802654c <lv_label_get_letter_on>:
    if(mutable_bidi_txt) lv_free(mutable_bidi_txt);
#endif
}

uint32_t lv_label_get_letter_on(const lv_obj_t * obj, lv_point_t * pos_in, bool bidi)
{
 802654c:	b590      	push	{r4, r7, lr}
 802654e:	b0a7      	sub	sp, #156	@ 0x9c
 8026550:	af04      	add	r7, sp, #16
 8026552:	60f8      	str	r0, [r7, #12]
 8026554:	60b9      	str	r1, [r7, #8]
 8026556:	4613      	mov	r3, r2
 8026558:	71fb      	strb	r3, [r7, #7]
    LV_UNUSED(bidi);
    LV_ASSERT_OBJ(obj, MY_CLASS);
    LV_ASSERT_NULL(pos_in);
 802655a:	68bb      	ldr	r3, [r7, #8]
 802655c:	2b00      	cmp	r3, #0
 802655e:	d101      	bne.n	8026564 <lv_label_get_letter_on+0x18>
 8026560:	bf00      	nop
 8026562:	e7fd      	b.n	8026560 <lv_label_get_letter_on+0x14>
    lv_label_t * label = (lv_label_t *)obj;
 8026564:	68fb      	ldr	r3, [r7, #12]
 8026566:	677b      	str	r3, [r7, #116]	@ 0x74

    lv_point_t pos;
    pos.x = pos_in->x - lv_obj_get_style_pad_left(obj, LV_PART_MAIN);
 8026568:	68bb      	ldr	r3, [r7, #8]
 802656a:	681c      	ldr	r4, [r3, #0]
 802656c:	2100      	movs	r1, #0
 802656e:	68f8      	ldr	r0, [r7, #12]
 8026570:	f7ff fe52 	bl	8026218 <lv_obj_get_style_pad_left>
 8026574:	4603      	mov	r3, r0
 8026576:	1ae3      	subs	r3, r4, r3
 8026578:	63bb      	str	r3, [r7, #56]	@ 0x38
    pos.y = pos_in->y - lv_obj_get_style_pad_top(obj, LV_PART_MAIN);
 802657a:	68bb      	ldr	r3, [r7, #8]
 802657c:	685c      	ldr	r4, [r3, #4]
 802657e:	2100      	movs	r1, #0
 8026580:	68f8      	ldr	r0, [r7, #12]
 8026582:	f7ff fe38 	bl	80261f6 <lv_obj_get_style_pad_top>
 8026586:	4603      	mov	r3, r0
 8026588:	1ae3      	subs	r3, r4, r3
 802658a:	63fb      	str	r3, [r7, #60]	@ 0x3c

    lv_area_t txt_coords;
    lv_obj_get_content_coords(obj, &txt_coords);
 802658c:	f107 0328 	add.w	r3, r7, #40	@ 0x28
 8026590:	4619      	mov	r1, r3
 8026592:	68f8      	ldr	r0, [r7, #12]
 8026594:	f7df fc1c 	bl	8005dd0 <lv_obj_get_content_coords>
    const char * txt         = lv_label_get_text(obj);
 8026598:	68f8      	ldr	r0, [r7, #12]
 802659a:	f7ff ffc9 	bl	8026530 <lv_label_get_text>
 802659e:	6738      	str	r0, [r7, #112]	@ 0x70
    uint32_t line_start      = 0;
 80265a0:	2300      	movs	r3, #0
 80265a2:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    uint32_t new_line_start  = 0;
 80265a6:	2300      	movs	r3, #0
 80265a8:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
    int32_t max_w         = lv_area_get_width(&txt_coords);
 80265ac:	f107 0328 	add.w	r3, r7, #40	@ 0x28
 80265b0:	4618      	mov	r0, r3
 80265b2:	f7ff fd33 	bl	802601c <lv_area_get_width>
 80265b6:	66f8      	str	r0, [r7, #108]	@ 0x6c
    const lv_font_t * font   = lv_obj_get_style_text_font(obj, LV_PART_MAIN);
 80265b8:	2100      	movs	r1, #0
 80265ba:	68f8      	ldr	r0, [r7, #12]
 80265bc:	f7ff fe8c 	bl	80262d8 <lv_obj_get_style_text_font>
 80265c0:	66b8      	str	r0, [r7, #104]	@ 0x68
    const int32_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);
 80265c2:	2100      	movs	r1, #0
 80265c4:	68f8      	ldr	r0, [r7, #12]
 80265c6:	f7ff fea9 	bl	802631c <lv_obj_get_style_text_line_space>
 80265ca:	6678      	str	r0, [r7, #100]	@ 0x64
    const int32_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);
 80265cc:	2100      	movs	r1, #0
 80265ce:	68f8      	ldr	r0, [r7, #12]
 80265d0:	f7ff fe93 	bl	80262fa <lv_obj_get_style_text_letter_space>
 80265d4:	6638      	str	r0, [r7, #96]	@ 0x60
    const int32_t letter_height = lv_font_get_line_height(font);
 80265d6:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 80265d8:	f7ff fd52 	bl	8026080 <lv_font_get_line_height>
 80265dc:	65f8      	str	r0, [r7, #92]	@ 0x5c
    int32_t y = 0;
 80265de:	2300      	movs	r3, #0
 80265e0:	67fb      	str	r3, [r7, #124]	@ 0x7c

    lv_text_flag_t flag = get_label_flags(label);
 80265e2:	6f78      	ldr	r0, [r7, #116]	@ 0x74
 80265e4:	f001 f9ec 	bl	80279c0 <get_label_flags>
 80265e8:	4603      	mov	r3, r0
 80265ea:	f887 305b 	strb.w	r3, [r7, #91]	@ 0x5b

    /*Search the line of the index letter*/;
    while(txt[line_start] != '\0') {
 80265ee:	e03e      	b.n	802666e <lv_label_get_letter_on+0x122>
        new_line_start += _lv_text_get_next_line(&txt[line_start], font, letter_space, max_w, NULL, flag);
 80265f0:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 80265f2:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80265f6:	18d0      	adds	r0, r2, r3
 80265f8:	f897 305b 	ldrb.w	r3, [r7, #91]	@ 0x5b
 80265fc:	9301      	str	r3, [sp, #4]
 80265fe:	2300      	movs	r3, #0
 8026600:	9300      	str	r3, [sp, #0]
 8026602:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8026604:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8026606:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 8026608:	f7fd fcf4 	bl	8023ff4 <_lv_text_get_next_line>
 802660c:	4602      	mov	r2, r0
 802660e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8026612:	4413      	add	r3, r2
 8026614:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80

        if(pos.y <= y + letter_height) {
 8026618:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 802661a:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
 802661c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 802661e:	440b      	add	r3, r1
 8026620:	429a      	cmp	r2, r3
 8026622:	dc1a      	bgt.n	802665a <lv_label_get_letter_on+0x10e>
            /*The line is found (stored in 'line_start')*/
            /*Include the NULL terminator in the last line*/
            uint32_t tmp = new_line_start;
 8026624:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8026628:	61fb      	str	r3, [r7, #28]
            uint32_t letter;
            letter = _lv_text_encoded_prev(txt, &tmp);
 802662a:	4b55      	ldr	r3, [pc, #340]	@ (8026780 <lv_label_get_letter_on+0x234>)
 802662c:	681b      	ldr	r3, [r3, #0]
 802662e:	f107 021c 	add.w	r2, r7, #28
 8026632:	4611      	mov	r1, r2
 8026634:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8026636:	4798      	blx	r3
 8026638:	6578      	str	r0, [r7, #84]	@ 0x54
            if(letter != '\n' && txt[new_line_start] == '\0') new_line_start++;
 802663a:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 802663c:	2b0a      	cmp	r3, #10
 802663e:	d01e      	beq.n	802667e <lv_label_get_letter_on+0x132>
 8026640:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8026642:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8026646:	4413      	add	r3, r2
 8026648:	781b      	ldrb	r3, [r3, #0]
 802664a:	2b00      	cmp	r3, #0
 802664c:	d117      	bne.n	802667e <lv_label_get_letter_on+0x132>
 802664e:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8026652:	3301      	adds	r3, #1
 8026654:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
            break;
 8026658:	e011      	b.n	802667e <lv_label_get_letter_on+0x132>
        }
        y += letter_height + line_space;
 802665a:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 802665c:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802665e:	4413      	add	r3, r2
 8026660:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8026662:	4413      	add	r3, r2
 8026664:	67fb      	str	r3, [r7, #124]	@ 0x7c

        line_start = new_line_start;
 8026666:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 802666a:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
    while(txt[line_start] != '\0') {
 802666e:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8026670:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8026674:	4413      	add	r3, r2
 8026676:	781b      	ldrb	r3, [r3, #0]
 8026678:	2b00      	cmp	r3, #0
 802667a:	d1b9      	bne.n	80265f0 <lv_label_get_letter_on+0xa4>
 802667c:	e000      	b.n	8026680 <lv_label_get_letter_on+0x134>
            break;
 802667e:	bf00      	nop
        _lv_bidi_process_paragraph(txt + line_start, bidi_txt, txt_len, lv_obj_get_style_base_dir(obj, LV_PART_MAIN), NULL, 0);
    }
    else
#endif
    {
        bidi_txt = (char *)txt + line_start;
 8026680:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8026682:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8026686:	4413      	add	r3, r2
 8026688:	653b      	str	r3, [r7, #80]	@ 0x50
    }

    /*Calculate the x coordinate*/
    int32_t x = 0;
 802668a:	2300      	movs	r3, #0
 802668c:	627b      	str	r3, [r7, #36]	@ 0x24
    const lv_text_align_t align = lv_obj_calculate_style_text_align(obj, LV_PART_MAIN, label->text);
 802668e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8026690:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8026692:	461a      	mov	r2, r3
 8026694:	2100      	movs	r1, #0
 8026696:	68f8      	ldr	r0, [r7, #12]
 8026698:	f7e3 fc20 	bl	8009edc <lv_obj_calculate_style_text_align>
 802669c:	4603      	mov	r3, r0
 802669e:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
    uint32_t length = new_line_start - line_start;
 80266a2:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 80266a6:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 80266aa:	1ad3      	subs	r3, r2, r3
 80266ac:	64bb      	str	r3, [r7, #72]	@ 0x48
    calculate_x_coordinate(&x, align, bidi_txt, length, font, letter_space, &txt_coords);
 80266ae:	f897 104f 	ldrb.w	r1, [r7, #79]	@ 0x4f
 80266b2:	f107 0024 	add.w	r0, r7, #36	@ 0x24
 80266b6:	f107 0328 	add.w	r3, r7, #40	@ 0x28
 80266ba:	9302      	str	r3, [sp, #8]
 80266bc:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 80266be:	9301      	str	r3, [sp, #4]
 80266c0:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 80266c2:	9300      	str	r3, [sp, #0]
 80266c4:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80266c6:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 80266c8:	f001 f9b2 	bl	8027a30 <calculate_x_coordinate>

    uint32_t i = 0;
 80266cc:	2300      	movs	r3, #0
 80266ce:	623b      	str	r3, [r7, #32]
    uint32_t i_act = i;
 80266d0:	6a3b      	ldr	r3, [r7, #32]
 80266d2:	67bb      	str	r3, [r7, #120]	@ 0x78

    if(new_line_start > 0) {
 80266d4:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 80266d8:	2b00      	cmp	r3, #0
 80266da:	d03d      	beq.n	8026758 <lv_label_get_letter_on+0x20c>
        while(i + line_start < new_line_start) {
 80266dc:	e034      	b.n	8026748 <lv_label_get_letter_on+0x1fc>
            /*Get the current letter and the next letter for kerning*/
            /*Be careful 'i' already points to the next character*/
            uint32_t letter;
            uint32_t letter_next;
            _lv_text_encoded_letter_next_2(bidi_txt, &letter, &letter_next, &i);
 80266de:	f107 0320 	add.w	r3, r7, #32
 80266e2:	f107 0214 	add.w	r2, r7, #20
 80266e6:	f107 0118 	add.w	r1, r7, #24
 80266ea:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 80266ec:	f7fd fd9c 	bl	8024228 <_lv_text_encoded_letter_next_2>

            int32_t gw = lv_font_get_glyph_width(font, letter, letter_next);
 80266f0:	69bb      	ldr	r3, [r7, #24]
 80266f2:	697a      	ldr	r2, [r7, #20]
 80266f4:	4619      	mov	r1, r3
 80266f6:	6eb8      	ldr	r0, [r7, #104]	@ 0x68
 80266f8:	f7f5 febc 	bl	801c474 <lv_font_get_glyph_width>
 80266fc:	4603      	mov	r3, r0
 80266fe:	647b      	str	r3, [r7, #68]	@ 0x44

            /*Finish if the x position or the last char of the next line is reached*/
            if(pos.x < x + gw || i + line_start == new_line_start ||  txt[i_act + line_start] == '\0') {
 8026700:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8026702:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8026704:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8026706:	440b      	add	r3, r1
 8026708:	429a      	cmp	r2, r3
 802670a:	db10      	blt.n	802672e <lv_label_get_letter_on+0x1e2>
 802670c:	6a3a      	ldr	r2, [r7, #32]
 802670e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8026712:	4413      	add	r3, r2
 8026714:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 8026718:	429a      	cmp	r2, r3
 802671a:	d008      	beq.n	802672e <lv_label_get_letter_on+0x1e2>
 802671c:	6fba      	ldr	r2, [r7, #120]	@ 0x78
 802671e:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8026722:	4413      	add	r3, r2
 8026724:	6f3a      	ldr	r2, [r7, #112]	@ 0x70
 8026726:	4413      	add	r3, r2
 8026728:	781b      	ldrb	r3, [r3, #0]
 802672a:	2b00      	cmp	r3, #0
 802672c:	d102      	bne.n	8026734 <lv_label_get_letter_on+0x1e8>
                i = i_act;
 802672e:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8026730:	623b      	str	r3, [r7, #32]
 8026732:	e011      	b.n	8026758 <lv_label_get_letter_on+0x20c>
                break;
            }
            x += gw;
 8026734:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8026736:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8026738:	4413      	add	r3, r2
 802673a:	627b      	str	r3, [r7, #36]	@ 0x24
            x += letter_space;
 802673c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 802673e:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8026740:	4413      	add	r3, r2
 8026742:	627b      	str	r3, [r7, #36]	@ 0x24
            i_act = i;
 8026744:	6a3b      	ldr	r3, [r7, #32]
 8026746:	67bb      	str	r3, [r7, #120]	@ 0x78
        while(i + line_start < new_line_start) {
 8026748:	6a3a      	ldr	r2, [r7, #32]
 802674a:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 802674e:	4413      	add	r3, r2
 8026750:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 8026754:	429a      	cmp	r2, r3
 8026756:	d8c2      	bhi.n	80266de <lv_label_get_letter_on+0x192>
        lv_free(bidi_txt);
    }
    else
#endif
    {
        logical_pos = _lv_text_encoded_get_char_id(bidi_txt, i);
 8026758:	4b0a      	ldr	r3, [pc, #40]	@ (8026784 <lv_label_get_letter_on+0x238>)
 802675a:	681b      	ldr	r3, [r3, #0]
 802675c:	6a3a      	ldr	r2, [r7, #32]
 802675e:	4611      	mov	r1, r2
 8026760:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8026762:	4798      	blx	r3
 8026764:	6438      	str	r0, [r7, #64]	@ 0x40
    }

    return  logical_pos + _lv_text_encoded_get_char_id(txt, line_start);
 8026766:	4b07      	ldr	r3, [pc, #28]	@ (8026784 <lv_label_get_letter_on+0x238>)
 8026768:	681b      	ldr	r3, [r3, #0]
 802676a:	f8d7 1084 	ldr.w	r1, [r7, #132]	@ 0x84
 802676e:	6f38      	ldr	r0, [r7, #112]	@ 0x70
 8026770:	4798      	blx	r3
 8026772:	4602      	mov	r2, r0
 8026774:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8026776:	4413      	add	r3, r2
}
 8026778:	4618      	mov	r0, r3
 802677a:	378c      	adds	r7, #140	@ 0x8c
 802677c:	46bd      	mov	sp, r7
 802677e:	bd90      	pop	{r4, r7, pc}
 8026780:	20000014 	.word	0x20000014
 8026784:	2000001c 	.word	0x2000001c

08026788 <lv_label_get_text_selection_start>:
    const int32_t max_diff = lv_font_get_glyph_width(font, letter, letter_next) + letter_space + 1;
    return (pos->x >= (last_x - letter_space) && pos->x <= (last_x + max_diff));
}

uint32_t lv_label_get_text_selection_start(const lv_obj_t * obj)
{
 8026788:	b480      	push	{r7}
 802678a:	b085      	sub	sp, #20
 802678c:	af00      	add	r7, sp, #0
 802678e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

#if LV_LABEL_TEXT_SELECTION
    lv_label_t * label = (lv_label_t *)obj;
 8026790:	687b      	ldr	r3, [r7, #4]
 8026792:	60fb      	str	r3, [r7, #12]
    return label->sel_start;
 8026794:	68fb      	ldr	r3, [r7, #12]
 8026796:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
#else
    LV_UNUSED(obj); /*Unused*/
    return LV_LABEL_TEXT_SELECTION_OFF;
#endif
}
 8026798:	4618      	mov	r0, r3
 802679a:	3714      	adds	r7, #20
 802679c:	46bd      	mov	sp, r7
 802679e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80267a2:	4770      	bx	lr

080267a4 <lv_label_get_text_selection_end>:

uint32_t lv_label_get_text_selection_end(const lv_obj_t * obj)
{
 80267a4:	b480      	push	{r7}
 80267a6:	b085      	sub	sp, #20
 80267a8:	af00      	add	r7, sp, #0
 80267aa:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, MY_CLASS);

#if LV_LABEL_TEXT_SELECTION
    lv_label_t * label = (lv_label_t *)obj;
 80267ac:	687b      	ldr	r3, [r7, #4]
 80267ae:	60fb      	str	r3, [r7, #12]
    return label->sel_end;
 80267b0:	68fb      	ldr	r3, [r7, #12]
 80267b2:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
#else
    LV_UNUSED(obj); /*Unused*/
    return LV_LABEL_TEXT_SELECTION_OFF;
#endif
}
 80267b4:	4618      	mov	r0, r3
 80267b6:	3714      	adds	r7, #20
 80267b8:	46bd      	mov	sp, r7
 80267ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80267be:	4770      	bx	lr

080267c0 <lv_label_constructor>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void lv_label_constructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
{
 80267c0:	b580      	push	{r7, lr}
 80267c2:	b084      	sub	sp, #16
 80267c4:	af00      	add	r7, sp, #0
 80267c6:	6078      	str	r0, [r7, #4]
 80267c8:	6039      	str	r1, [r7, #0]
    LV_UNUSED(class_p);
    LV_TRACE_OBJ_CREATE("begin");

    lv_label_t * label = (lv_label_t *)obj;
 80267ca:	683b      	ldr	r3, [r7, #0]
 80267cc:	60fb      	str	r3, [r7, #12]

    label->text       = NULL;
 80267ce:	68fb      	ldr	r3, [r7, #12]
 80267d0:	2200      	movs	r2, #0
 80267d2:	62da      	str	r2, [r3, #44]	@ 0x2c
    label->static_txt = 0;
 80267d4:	68fa      	ldr	r2, [r7, #12]
 80267d6:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 80267da:	f36f 03c3 	bfc	r3, #3, #1
 80267de:	f882 305c 	strb.w	r3, [r2, #92]	@ 0x5c
    label->dot_end    = LV_LABEL_DOT_END_INV;
 80267e2:	68fb      	ldr	r3, [r7, #12]
 80267e4:	f04f 32ff 	mov.w	r2, #4294967295
 80267e8:	635a      	str	r2, [r3, #52]	@ 0x34
    label->long_mode  = LV_LABEL_LONG_WRAP;
 80267ea:	68fa      	ldr	r2, [r7, #12]
 80267ec:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 80267f0:	f36f 0302 	bfc	r3, #0, #3
 80267f4:	f882 305c 	strb.w	r3, [r2, #92]	@ 0x5c
    lv_point_set(&label->offset, 0, 0);
 80267f8:	68fb      	ldr	r3, [r7, #12]
 80267fa:	3354      	adds	r3, #84	@ 0x54
 80267fc:	2200      	movs	r2, #0
 80267fe:	2100      	movs	r1, #0
 8026800:	4618      	mov	r0, r3
 8026802:	f7ff fc2b 	bl	802605c <lv_point_set>

#if LV_LABEL_LONG_TXT_HINT
    label->hint.line_start = -1;
 8026806:	68fb      	ldr	r3, [r7, #12]
 8026808:	f04f 32ff 	mov.w	r2, #4294967295
 802680c:	639a      	str	r2, [r3, #56]	@ 0x38
    label->hint.coord_y    = 0;
 802680e:	68fb      	ldr	r3, [r7, #12]
 8026810:	2200      	movs	r2, #0
 8026812:	641a      	str	r2, [r3, #64]	@ 0x40
    label->hint.y          = 0;
 8026814:	68fb      	ldr	r3, [r7, #12]
 8026816:	2200      	movs	r2, #0
 8026818:	63da      	str	r2, [r3, #60]	@ 0x3c
#endif

#if LV_LABEL_TEXT_SELECTION
    label->sel_start = LV_DRAW_LABEL_NO_TXT_SEL;
 802681a:	68fb      	ldr	r3, [r7, #12]
 802681c:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8026820:	645a      	str	r2, [r3, #68]	@ 0x44
    label->sel_end   = LV_DRAW_LABEL_NO_TXT_SEL;
 8026822:	68fb      	ldr	r3, [r7, #12]
 8026824:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8026828:	649a      	str	r2, [r3, #72]	@ 0x48
#endif
    label->dot.tmp_ptr   = NULL;
 802682a:	68fb      	ldr	r3, [r7, #12]
 802682c:	2200      	movs	r2, #0
 802682e:	631a      	str	r2, [r3, #48]	@ 0x30
    label->dot_tmp_alloc = 0;
 8026830:	68fa      	ldr	r2, [r7, #12]
 8026832:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 8026836:	f36f 1345 	bfc	r3, #5, #1
 802683a:	f882 305c 	strb.w	r3, [r2, #92]	@ 0x5c

    lv_obj_remove_flag(obj, LV_OBJ_FLAG_CLICKABLE);
 802683e:	2102      	movs	r1, #2
 8026840:	6838      	ldr	r0, [r7, #0]
 8026842:	f7dc f9e8 	bl	8002c16 <lv_obj_remove_flag>
    lv_label_set_long_mode(obj, LV_LABEL_LONG_WRAP);
 8026846:	2100      	movs	r1, #0
 8026848:	6838      	ldr	r0, [r7, #0]
 802684a:	f7ff fe1b 	bl	8026484 <lv_label_set_long_mode>
    lv_label_set_text(obj, LV_LABEL_DEFAULT_TEXT);
 802684e:	4904      	ldr	r1, [pc, #16]	@ (8026860 <lv_label_constructor+0xa0>)
 8026850:	6838      	ldr	r0, [r7, #0]
 8026852:	f7ff fdab 	bl	80263ac <lv_label_set_text>

    LV_TRACE_OBJ_CREATE("finished");
}
 8026856:	bf00      	nop
 8026858:	3710      	adds	r7, #16
 802685a:	46bd      	mov	sp, r7
 802685c:	bd80      	pop	{r7, pc}
 802685e:	bf00      	nop
 8026860:	08027bb4 	.word	0x08027bb4

08026864 <lv_label_destructor>:

static void lv_label_destructor(const lv_obj_class_t * class_p, lv_obj_t * obj)
{
 8026864:	b580      	push	{r7, lr}
 8026866:	b084      	sub	sp, #16
 8026868:	af00      	add	r7, sp, #0
 802686a:	6078      	str	r0, [r7, #4]
 802686c:	6039      	str	r1, [r7, #0]
    LV_UNUSED(class_p);
    lv_label_t * label = (lv_label_t *)obj;
 802686e:	683b      	ldr	r3, [r7, #0]
 8026870:	60fb      	str	r3, [r7, #12]

    lv_label_dot_tmp_free(obj);
 8026872:	6838      	ldr	r0, [r7, #0]
 8026874:	f001 f83d 	bl	80278f2 <lv_label_dot_tmp_free>
    if(!label->static_txt) lv_free(label->text);
 8026878:	68fb      	ldr	r3, [r7, #12]
 802687a:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 802687e:	f003 0308 	and.w	r3, r3, #8
 8026882:	b2db      	uxtb	r3, r3
 8026884:	2b00      	cmp	r3, #0
 8026886:	d104      	bne.n	8026892 <lv_label_destructor+0x2e>
 8026888:	68fb      	ldr	r3, [r7, #12]
 802688a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802688c:	4618      	mov	r0, r3
 802688e:	f7ff fad3 	bl	8025e38 <lv_free>
    label->text = NULL;
 8026892:	68fb      	ldr	r3, [r7, #12]
 8026894:	2200      	movs	r2, #0
 8026896:	62da      	str	r2, [r3, #44]	@ 0x2c
}
 8026898:	bf00      	nop
 802689a:	3710      	adds	r7, #16
 802689c:	46bd      	mov	sp, r7
 802689e:	bd80      	pop	{r7, pc}

080268a0 <lv_label_event>:

static void lv_label_event(const lv_obj_class_t * class_p, lv_event_t * e)
{
 80268a0:	b580      	push	{r7, lr}
 80268a2:	b092      	sub	sp, #72	@ 0x48
 80268a4:	af04      	add	r7, sp, #16
 80268a6:	6078      	str	r0, [r7, #4]
 80268a8:	6039      	str	r1, [r7, #0]
    LV_UNUSED(class_p);

    /*Call the ancestor's event handler*/
    const lv_result_t res = lv_obj_event_base(MY_CLASS, e);
 80268aa:	6839      	ldr	r1, [r7, #0]
 80268ac:	4864      	ldr	r0, [pc, #400]	@ (8026a40 <lv_label_event+0x1a0>)
 80268ae:	f7de faf1 	bl	8004e94 <lv_obj_event_base>
 80268b2:	4603      	mov	r3, r0
 80268b4:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    if(res != LV_RESULT_OK) return;
 80268b8:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 80268bc:	2b01      	cmp	r3, #1
 80268be:	f040 80bb 	bne.w	8026a38 <lv_label_event+0x198>

    const lv_event_code_t code = lv_event_get_code(e);
 80268c2:	6838      	ldr	r0, [r7, #0]
 80268c4:	f7fb ffc4 	bl	8022850 <lv_event_get_code>
 80268c8:	4603      	mov	r3, r0
 80268ca:	85bb      	strh	r3, [r7, #44]	@ 0x2c
    lv_obj_t * obj = lv_event_get_current_target(e);
 80268cc:	6838      	ldr	r0, [r7, #0]
 80268ce:	f7fb ffb3 	bl	8022838 <lv_event_get_current_target>
 80268d2:	62b8      	str	r0, [r7, #40]	@ 0x28

    if((code == LV_EVENT_STYLE_CHANGED) || (code == LV_EVENT_SIZE_CHANGED)) {
 80268d4:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 80268d6:	2b2c      	cmp	r3, #44	@ 0x2c
 80268d8:	d002      	beq.n	80268e0 <lv_label_event+0x40>
 80268da:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 80268dc:	2b2b      	cmp	r3, #43	@ 0x2b
 80268de:	d106      	bne.n	80268ee <lv_label_event+0x4e>
        /*Revert dots for proper refresh*/
        lv_label_revert_dots(obj);
 80268e0:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80268e2:	f000 ff51 	bl	8027788 <lv_label_revert_dots>
        lv_label_refr_text(obj);
 80268e6:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80268e8:	f000 fac8 	bl	8026e7c <lv_label_refr_text>
 80268ec:	e0a5      	b.n	8026a3a <lv_label_event+0x19a>
    }
    else if(code == LV_EVENT_REFR_EXT_DRAW_SIZE) {
 80268ee:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 80268f0:	2b15      	cmp	r3, #21
 80268f2:	d112      	bne.n	802691a <lv_label_event+0x7a>
        /* Italic or other non-typical letters can be drawn of out of the object.
         * It happens if box_w + ofs_x > adw_w in the glyph.
         * To avoid this add some extra draw area.
         * font_h / 4 is an empirical value. */
        const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);
 80268f4:	2100      	movs	r1, #0
 80268f6:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80268f8:	f7ff fcee 	bl	80262d8 <lv_obj_get_style_text_font>
 80268fc:	6138      	str	r0, [r7, #16]
        const int32_t font_h = lv_font_get_line_height(font);
 80268fe:	6938      	ldr	r0, [r7, #16]
 8026900:	f7ff fbbe 	bl	8026080 <lv_font_get_line_height>
 8026904:	60f8      	str	r0, [r7, #12]
        lv_event_set_ext_draw_size(e, font_h / 4);
 8026906:	68fb      	ldr	r3, [r7, #12]
 8026908:	2b00      	cmp	r3, #0
 802690a:	da00      	bge.n	802690e <lv_label_event+0x6e>
 802690c:	3303      	adds	r3, #3
 802690e:	109b      	asrs	r3, r3, #2
 8026910:	4619      	mov	r1, r3
 8026912:	6838      	ldr	r0, [r7, #0]
 8026914:	f7de fb89 	bl	800502a <lv_event_set_ext_draw_size>
 8026918:	e08f      	b.n	8026a3a <lv_label_event+0x19a>
    }
    else if(code == LV_EVENT_GET_SELF_SIZE) {
 802691a:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 802691c:	2b2e      	cmp	r3, #46	@ 0x2e
 802691e:	f040 8084 	bne.w	8026a2a <lv_label_event+0x18a>
        lv_label_t * label = (lv_label_t *)obj;
 8026922:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8026924:	627b      	str	r3, [r7, #36]	@ 0x24
        if(label->invalid_size_cache) {
 8026926:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8026928:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 802692c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8026930:	b2db      	uxtb	r3, r3
 8026932:	2b00      	cmp	r3, #0
 8026934:	d062      	beq.n	80269fc <lv_label_event+0x15c>
            const lv_font_t * font = lv_obj_get_style_text_font(obj, LV_PART_MAIN);
 8026936:	2100      	movs	r1, #0
 8026938:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 802693a:	f7ff fccd 	bl	80262d8 <lv_obj_get_style_text_font>
 802693e:	6238      	str	r0, [r7, #32]
            int32_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);
 8026940:	2100      	movs	r1, #0
 8026942:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8026944:	f7ff fcd9 	bl	80262fa <lv_obj_get_style_text_letter_space>
 8026948:	61f8      	str	r0, [r7, #28]
            int32_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);
 802694a:	2100      	movs	r1, #0
 802694c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 802694e:	f7ff fce5 	bl	802631c <lv_obj_get_style_text_line_space>
 8026952:	61b8      	str	r0, [r7, #24]
            lv_text_flag_t flag = LV_TEXT_FLAG_NONE;
 8026954:	2300      	movs	r3, #0
 8026956:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
            if(label->expand != 0) flag |= LV_TEXT_FLAG_EXPAND;
 802695a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 802695c:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8026960:	f003 0310 	and.w	r3, r3, #16
 8026964:	b2db      	uxtb	r3, r3
 8026966:	2b00      	cmp	r3, #0
 8026968:	d005      	beq.n	8026976 <lv_label_event+0xd6>
 802696a:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 802696e:	f043 0301 	orr.w	r3, r3, #1
 8026972:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37

            int32_t w = lv_obj_get_content_width(obj);
 8026976:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8026978:	f7df f9f6 	bl	8005d68 <lv_obj_get_content_width>
 802697c:	6338      	str	r0, [r7, #48]	@ 0x30
            if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT && !obj->w_layout) w = LV_COORD_MAX;
 802697e:	2100      	movs	r1, #0
 8026980:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8026982:	f7ff fc16 	bl	80261b2 <lv_obj_get_style_width>
 8026986:	4603      	mov	r3, r0
 8026988:	4a2e      	ldr	r2, [pc, #184]	@ (8026a44 <lv_label_event+0x1a4>)
 802698a:	4293      	cmp	r3, r2
 802698c:	d10b      	bne.n	80269a6 <lv_label_event+0x106>
 802698e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8026990:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 8026994:	f003 0308 	and.w	r3, r3, #8
 8026998:	b2db      	uxtb	r3, r3
 802699a:	2b00      	cmp	r3, #0
 802699c:	d103      	bne.n	80269a6 <lv_label_event+0x106>
 802699e:	f06f 4360 	mvn.w	r3, #3758096384	@ 0xe0000000
 80269a2:	633b      	str	r3, [r7, #48]	@ 0x30
 80269a4:	e003      	b.n	80269ae <lv_label_event+0x10e>
            else w = lv_obj_get_content_width(obj);
 80269a6:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80269a8:	f7df f9de 	bl	8005d68 <lv_obj_get_content_width>
 80269ac:	6338      	str	r0, [r7, #48]	@ 0x30

            w = LV_MIN(w, lv_obj_get_style_max_width(obj, 0));
 80269ae:	2100      	movs	r1, #0
 80269b0:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80269b2:	f7ff fc0f 	bl	80261d4 <lv_obj_get_style_max_width>
 80269b6:	4602      	mov	r2, r0
 80269b8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80269ba:	4293      	cmp	r3, r2
 80269bc:	db05      	blt.n	80269ca <lv_label_event+0x12a>
 80269be:	2100      	movs	r1, #0
 80269c0:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 80269c2:	f7ff fc07 	bl	80261d4 <lv_obj_get_style_max_width>
 80269c6:	4603      	mov	r3, r0
 80269c8:	e000      	b.n	80269cc <lv_label_event+0x12c>
 80269ca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80269cc:	633b      	str	r3, [r7, #48]	@ 0x30

            lv_text_get_size(&label->size_cache, label->text, font, letter_space, line_space, w, flag);
 80269ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80269d0:	f103 004c 	add.w	r0, r3, #76	@ 0x4c
 80269d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80269d6:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 80269d8:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 80269dc:	9302      	str	r3, [sp, #8]
 80269de:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80269e0:	9301      	str	r3, [sp, #4]
 80269e2:	69bb      	ldr	r3, [r7, #24]
 80269e4:	9300      	str	r3, [sp, #0]
 80269e6:	69fb      	ldr	r3, [r7, #28]
 80269e8:	6a3a      	ldr	r2, [r7, #32]
 80269ea:	f7fd f999 	bl	8023d20 <lv_text_get_size>
            label->invalid_size_cache = false;
 80269ee:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80269f0:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 80269f4:	f36f 1386 	bfc	r3, #6, #1
 80269f8:	f882 305c 	strb.w	r3, [r2, #92]	@ 0x5c
        }

        lv_point_t * self_size = lv_event_get_param(e);
 80269fc:	6838      	ldr	r0, [r7, #0]
 80269fe:	f7fb ff36 	bl	802286e <lv_event_get_param>
 8026a02:	6178      	str	r0, [r7, #20]
        self_size->x = LV_MAX(self_size->x, label->size_cache.x);
 8026a04:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8026a06:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8026a08:	697b      	ldr	r3, [r7, #20]
 8026a0a:	681b      	ldr	r3, [r3, #0]
 8026a0c:	429a      	cmp	r2, r3
 8026a0e:	bfb8      	it	lt
 8026a10:	461a      	movlt	r2, r3
 8026a12:	697b      	ldr	r3, [r7, #20]
 8026a14:	601a      	str	r2, [r3, #0]
        self_size->y = LV_MAX(self_size->y, label->size_cache.y);
 8026a16:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8026a18:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8026a1a:	697b      	ldr	r3, [r7, #20]
 8026a1c:	685b      	ldr	r3, [r3, #4]
 8026a1e:	429a      	cmp	r2, r3
 8026a20:	bfb8      	it	lt
 8026a22:	461a      	movlt	r2, r3
 8026a24:	697b      	ldr	r3, [r7, #20]
 8026a26:	605a      	str	r2, [r3, #4]
 8026a28:	e007      	b.n	8026a3a <lv_label_event+0x19a>
    }
    else if(code == LV_EVENT_DRAW_MAIN) {
 8026a2a:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 8026a2c:	2b17      	cmp	r3, #23
 8026a2e:	d104      	bne.n	8026a3a <lv_label_event+0x19a>
        draw_main(e);
 8026a30:	6838      	ldr	r0, [r7, #0]
 8026a32:	f000 f809 	bl	8026a48 <draw_main>
 8026a36:	e000      	b.n	8026a3a <lv_label_event+0x19a>
    if(res != LV_RESULT_OK) return;
 8026a38:	bf00      	nop
    }
}
 8026a3a:	3738      	adds	r7, #56	@ 0x38
 8026a3c:	46bd      	mov	sp, r7
 8026a3e:	bd80      	pop	{r7, pc}
 8026a40:	0802b2fc 	.word	0x0802b2fc
 8026a44:	200007d1 	.word	0x200007d1

08026a48 <draw_main>:

static void draw_main(lv_event_t * e)
{
 8026a48:	b5b0      	push	{r4, r5, r7, lr}
 8026a4a:	b0b4      	sub	sp, #208	@ 0xd0
 8026a4c:	af04      	add	r7, sp, #16
 8026a4e:	6078      	str	r0, [r7, #4]
    lv_obj_t * obj = lv_event_get_current_target(e);
 8026a50:	6878      	ldr	r0, [r7, #4]
 8026a52:	f7fb fef1 	bl	8022838 <lv_event_get_current_target>
 8026a56:	f8c7 00bc 	str.w	r0, [r7, #188]	@ 0xbc
    lv_label_t * label = (lv_label_t *)obj;
 8026a5a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8026a5e:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
    lv_layer_t * layer = lv_event_get_layer(e);
 8026a62:	6878      	ldr	r0, [r7, #4]
 8026a64:	f7de faa2 	bl	8004fac <lv_event_get_layer>
 8026a68:	f8c7 00b4 	str.w	r0, [r7, #180]	@ 0xb4

    lv_area_t txt_coords;
    lv_obj_get_content_coords(obj, &txt_coords);
 8026a6c:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
 8026a70:	4619      	mov	r1, r3
 8026a72:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8026a76:	f7df f9ab 	bl	8005dd0 <lv_obj_get_content_coords>

    lv_text_flag_t flag = get_label_flags(label);
 8026a7a:	f8d7 00b8 	ldr.w	r0, [r7, #184]	@ 0xb8
 8026a7e:	f000 ff9f 	bl	80279c0 <get_label_flags>
 8026a82:	4603      	mov	r3, r0
 8026a84:	f887 30b3 	strb.w	r3, [r7, #179]	@ 0xb3

    lv_draw_label_dsc_t label_draw_dsc;
    lv_draw_label_dsc_init(&label_draw_dsc);
 8026a88:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 8026a8c:	4618      	mov	r0, r3
 8026a8e:	f7e6 f9d5 	bl	800ce3c <lv_draw_label_dsc_init>
    label_draw_dsc.text = label->text;
 8026a92:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026a96:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8026a98:	667b      	str	r3, [r7, #100]	@ 0x64
    label_draw_dsc.ofs_x = label->offset.x;
 8026a9a:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026a9e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8026aa0:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    label_draw_dsc.ofs_y = label->offset.y;
 8026aa4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026aa8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8026aaa:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
#if LV_LABEL_LONG_TXT_HINT
    if(label->long_mode != LV_LABEL_LONG_SCROLL_CIRCULAR && lv_area_get_height(&txt_coords) >= LV_LABEL_HINT_HEIGHT_LIMIT) {
 8026aae:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026ab2:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8026ab6:	f003 0307 	and.w	r3, r3, #7
 8026aba:	b2db      	uxtb	r3, r3
 8026abc:	2b03      	cmp	r3, #3
 8026abe:	d00d      	beq.n	8026adc <draw_main+0x94>
 8026ac0:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
 8026ac4:	4618      	mov	r0, r3
 8026ac6:	f7ff fab9 	bl	802603c <lv_area_get_height>
 8026aca:	4603      	mov	r3, r0
 8026acc:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8026ad0:	db04      	blt.n	8026adc <draw_main+0x94>
        label_draw_dsc.hint = &label->hint;
 8026ad2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026ad6:	3338      	adds	r3, #56	@ 0x38
 8026ad8:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    }
#endif

    label_draw_dsc.flag = flag;
 8026adc:	f897 30b3 	ldrb.w	r3, [r7, #179]	@ 0xb3
 8026ae0:	f887 3093 	strb.w	r3, [r7, #147]	@ 0x93
    lv_obj_init_draw_label_dsc(obj, LV_PART_MAIN, &label_draw_dsc);
 8026ae4:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 8026ae8:	461a      	mov	r2, r3
 8026aea:	2100      	movs	r1, #0
 8026aec:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8026af0:	f7de f82b 	bl	8004b4a <lv_obj_init_draw_label_dsc>
    lv_bidi_calculate_align(&label_draw_dsc.align, &label_draw_dsc.bidi_dir, label->text);
 8026af4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026af8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8026afa:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 8026afe:	f103 0149 	add.w	r1, r3, #73	@ 0x49
 8026b02:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 8026b06:	334a      	adds	r3, #74	@ 0x4a
 8026b08:	4618      	mov	r0, r3
 8026b0a:	f7ff fb3f 	bl	802618c <lv_bidi_calculate_align>

    label_draw_dsc.sel_start = lv_label_get_text_selection_start(obj);
 8026b0e:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8026b12:	f7ff fe39 	bl	8026788 <lv_label_get_text_selection_start>
 8026b16:	4603      	mov	r3, r0
 8026b18:	66fb      	str	r3, [r7, #108]	@ 0x6c
    label_draw_dsc.sel_end = lv_label_get_text_selection_end(obj);
 8026b1a:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8026b1e:	f7ff fe41 	bl	80267a4 <lv_label_get_text_selection_end>
 8026b22:	4603      	mov	r3, r0
 8026b24:	673b      	str	r3, [r7, #112]	@ 0x70
    if(label_draw_dsc.sel_start != LV_DRAW_LABEL_NO_TXT_SEL && label_draw_dsc.sel_end != LV_DRAW_LABEL_NO_TXT_SEL) {
 8026b26:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8026b28:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8026b2c:	4293      	cmp	r3, r2
 8026b2e:	d028      	beq.n	8026b82 <draw_main+0x13a>
 8026b30:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8026b32:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8026b36:	4293      	cmp	r3, r2
 8026b38:	d023      	beq.n	8026b82 <draw_main+0x13a>
        label_draw_dsc.sel_color = lv_obj_get_style_text_color_filtered(obj, LV_PART_SELECTED);
 8026b3a:	f44f 2180 	mov.w	r1, #262144	@ 0x40000
 8026b3e:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8026b42:	f7ff fb9e 	bl	8026282 <lv_obj_get_style_text_color_filtered>
 8026b46:	4603      	mov	r3, r0
 8026b48:	461a      	mov	r2, r3
 8026b4a:	f887 2077 	strb.w	r2, [r7, #119]	@ 0x77
 8026b4e:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8026b52:	f887 2078 	strb.w	r2, [r7, #120]	@ 0x78
 8026b56:	f3c3 4307 	ubfx	r3, r3, #16, #8
 8026b5a:	f887 3079 	strb.w	r3, [r7, #121]	@ 0x79
        label_draw_dsc.sel_bg_color = lv_obj_get_style_bg_color(obj, LV_PART_SELECTED);
 8026b5e:	f44f 2180 	mov.w	r1, #262144	@ 0x40000
 8026b62:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8026b66:	f7ff fb68 	bl	802623a <lv_obj_get_style_bg_color>
 8026b6a:	4603      	mov	r3, r0
 8026b6c:	461a      	mov	r2, r3
 8026b6e:	f887 207a 	strb.w	r2, [r7, #122]	@ 0x7a
 8026b72:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8026b76:	f887 207b 	strb.w	r2, [r7, #123]	@ 0x7b
 8026b7a:	f3c3 4307 	ubfx	r3, r3, #16, #8
 8026b7e:	f887 307c 	strb.w	r3, [r7, #124]	@ 0x7c
    }

    /* In SCROLL and SCROLL_CIRCULAR mode the CENTER and RIGHT are pointless, so remove them.
     * (In addition, they will create misalignment in this situation)*/
    if((label->long_mode == LV_LABEL_LONG_SCROLL || label->long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR) &&
 8026b82:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026b86:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8026b8a:	f003 0307 	and.w	r3, r3, #7
 8026b8e:	b2db      	uxtb	r3, r3
 8026b90:	2b02      	cmp	r3, #2
 8026b92:	d008      	beq.n	8026ba6 <draw_main+0x15e>
 8026b94:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026b98:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8026b9c:	f003 0307 	and.w	r3, r3, #7
 8026ba0:	b2db      	uxtb	r3, r3
 8026ba2:	2b03      	cmp	r3, #3
 8026ba4:	d128      	bne.n	8026bf8 <draw_main+0x1b0>
       (label_draw_dsc.align == LV_TEXT_ALIGN_CENTER || label_draw_dsc.align == LV_TEXT_ALIGN_RIGHT)) {
 8026ba6:	f897 3092 	ldrb.w	r3, [r7, #146]	@ 0x92
    if((label->long_mode == LV_LABEL_LONG_SCROLL || label->long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR) &&
 8026baa:	2b02      	cmp	r3, #2
 8026bac:	d003      	beq.n	8026bb6 <draw_main+0x16e>
       (label_draw_dsc.align == LV_TEXT_ALIGN_CENTER || label_draw_dsc.align == LV_TEXT_ALIGN_RIGHT)) {
 8026bae:	f897 3092 	ldrb.w	r3, [r7, #146]	@ 0x92
 8026bb2:	2b03      	cmp	r3, #3
 8026bb4:	d120      	bne.n	8026bf8 <draw_main+0x1b0>
        lv_point_t size;
        lv_text_get_size(&size, label->text, label_draw_dsc.font, label_draw_dsc.letter_space, label_draw_dsc.line_space,
 8026bb6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026bba:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8026bbc:	6ebc      	ldr	r4, [r7, #104]	@ 0x68
 8026bbe:	f8d7 5084 	ldr.w	r5, [r7, #132]	@ 0x84
 8026bc2:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8026bc6:	f107 0020 	add.w	r0, r7, #32
 8026bca:	f897 20b3 	ldrb.w	r2, [r7, #179]	@ 0xb3
 8026bce:	9202      	str	r2, [sp, #8]
 8026bd0:	f06f 4260 	mvn.w	r2, #3758096384	@ 0xe0000000
 8026bd4:	9201      	str	r2, [sp, #4]
 8026bd6:	9300      	str	r3, [sp, #0]
 8026bd8:	462b      	mov	r3, r5
 8026bda:	4622      	mov	r2, r4
 8026bdc:	f7fd f8a0 	bl	8023d20 <lv_text_get_size>
                         LV_COORD_MAX, flag);
        if(size.x > lv_area_get_width(&txt_coords)) {
 8026be0:	6a3c      	ldr	r4, [r7, #32]
 8026be2:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
 8026be6:	4618      	mov	r0, r3
 8026be8:	f7ff fa18 	bl	802601c <lv_area_get_width>
 8026bec:	4603      	mov	r3, r0
 8026bee:	429c      	cmp	r4, r3
 8026bf0:	dd02      	ble.n	8026bf8 <draw_main+0x1b0>
            label_draw_dsc.align = LV_TEXT_ALIGN_LEFT;
 8026bf2:	2301      	movs	r3, #1
 8026bf4:	f887 3092 	strb.w	r3, [r7, #146]	@ 0x92
        }
    }

    lv_area_t txt_clip;
    bool is_common = _lv_area_intersect(&txt_clip, &txt_coords, &layer->_clip_area);
 8026bf8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8026bfc:	f103 0218 	add.w	r2, r3, #24
 8026c00:	f107 019c 	add.w	r1, r7, #156	@ 0x9c
 8026c04:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8026c08:	4618      	mov	r0, r3
 8026c0a:	f7fa fe9d 	bl	8021948 <_lv_area_intersect>
 8026c0e:	4603      	mov	r3, r0
 8026c10:	f887 30b2 	strb.w	r3, [r7, #178]	@ 0xb2
    if(!is_common) {
 8026c14:	f897 30b2 	ldrb.w	r3, [r7, #178]	@ 0xb2
 8026c18:	f083 0301 	eor.w	r3, r3, #1
 8026c1c:	b2db      	uxtb	r3, r3
 8026c1e:	2b00      	cmp	r3, #0
 8026c20:	f040 80e3 	bne.w	8026dea <draw_main+0x3a2>
        return;
    }

    if(label->long_mode == LV_LABEL_LONG_WRAP) {
 8026c24:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026c28:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8026c2c:	f003 0307 	and.w	r3, r3, #7
 8026c30:	b2db      	uxtb	r3, r3
 8026c32:	2b00      	cmp	r3, #0
 8026c34:	d113      	bne.n	8026c5e <draw_main+0x216>
        int32_t s = lv_obj_get_scroll_top(obj);
 8026c36:	f8d7 00bc 	ldr.w	r0, [r7, #188]	@ 0xbc
 8026c3a:	f7e0 fc27 	bl	800748c <lv_obj_get_scroll_top>
 8026c3e:	f8c7 00ac 	str.w	r0, [r7, #172]	@ 0xac
        lv_area_move(&txt_coords, 0, -s);
 8026c42:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 8026c46:	425a      	negs	r2, r3
 8026c48:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
 8026c4c:	2100      	movs	r1, #0
 8026c4e:	4618      	mov	r0, r3
 8026c50:	f7fa fe56 	bl	8021900 <lv_area_move>
        txt_coords.y2 = obj->coords.y2;
 8026c54:	f8d7 30bc 	ldr.w	r3, [r7, #188]	@ 0xbc
 8026c58:	6a1b      	ldr	r3, [r3, #32]
 8026c5a:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    }
    if(label->long_mode == LV_LABEL_LONG_SCROLL || label->long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR) {
 8026c5e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026c62:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8026c66:	f003 0307 	and.w	r3, r3, #7
 8026c6a:	b2db      	uxtb	r3, r3
 8026c6c:	2b02      	cmp	r3, #2
 8026c6e:	d008      	beq.n	8026c82 <draw_main+0x23a>
 8026c70:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026c74:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8026c78:	f003 0307 	and.w	r3, r3, #7
 8026c7c:	b2db      	uxtb	r3, r3
 8026c7e:	2b03      	cmp	r3, #3
 8026c80:	d123      	bne.n	8026cca <draw_main+0x282>
        const lv_area_t clip_area_ori = layer->_clip_area;
 8026c82:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8026c86:	f107 0410 	add.w	r4, r7, #16
 8026c8a:	3318      	adds	r3, #24
 8026c8c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8026c8e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        layer->_clip_area = txt_clip;
 8026c92:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8026c96:	f103 0418 	add.w	r4, r3, #24
 8026c9a:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8026c9e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8026ca0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        lv_draw_label(layer, &label_draw_dsc, &txt_coords);
 8026ca4:	f107 029c 	add.w	r2, r7, #156	@ 0x9c
 8026ca8:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 8026cac:	4619      	mov	r1, r3
 8026cae:	f8d7 00b4 	ldr.w	r0, [r7, #180]	@ 0xb4
 8026cb2:	f7e6 f933 	bl	800cf1c <lv_draw_label>
        layer->_clip_area = clip_area_ori;
 8026cb6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8026cba:	f103 0418 	add.w	r4, r3, #24
 8026cbe:	f107 0310 	add.w	r3, r7, #16
 8026cc2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8026cc4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    if(label->long_mode == LV_LABEL_LONG_SCROLL || label->long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR) {
 8026cc8:	e008      	b.n	8026cdc <draw_main+0x294>
    }
    else {
        lv_draw_label(layer, &label_draw_dsc, &txt_coords);
 8026cca:	f107 029c 	add.w	r2, r7, #156	@ 0x9c
 8026cce:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 8026cd2:	4619      	mov	r1, r3
 8026cd4:	f8d7 00b4 	ldr.w	r0, [r7, #180]	@ 0xb4
 8026cd8:	f7e6 f920 	bl	800cf1c <lv_draw_label>
    }

    lv_area_t clip_area_ori = layer->_clip_area;
 8026cdc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8026ce0:	f107 0428 	add.w	r4, r7, #40	@ 0x28
 8026ce4:	3318      	adds	r3, #24
 8026ce6:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8026ce8:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    layer->_clip_area = txt_clip;
 8026cec:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8026cf0:	f103 0418 	add.w	r4, r3, #24
 8026cf4:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 8026cf8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8026cfa:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    if(label->long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR) {
 8026cfe:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026d02:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8026d06:	f003 0307 	and.w	r3, r3, #7
 8026d0a:	b2db      	uxtb	r3, r3
 8026d0c:	2b03      	cmp	r3, #3
 8026d0e:	d162      	bne.n	8026dd6 <draw_main+0x38e>
        lv_point_t size;
        lv_text_get_size(&size, label->text, label_draw_dsc.font, label_draw_dsc.letter_space, label_draw_dsc.line_space,
 8026d10:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026d14:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8026d16:	6ebc      	ldr	r4, [r7, #104]	@ 0x68
 8026d18:	f8d7 5084 	ldr.w	r5, [r7, #132]	@ 0x84
 8026d1c:	f8d7 3080 	ldr.w	r3, [r7, #128]	@ 0x80
 8026d20:	f107 0008 	add.w	r0, r7, #8
 8026d24:	f897 20b3 	ldrb.w	r2, [r7, #179]	@ 0xb3
 8026d28:	9202      	str	r2, [sp, #8]
 8026d2a:	f06f 4260 	mvn.w	r2, #3758096384	@ 0xe0000000
 8026d2e:	9201      	str	r2, [sp, #4]
 8026d30:	9300      	str	r3, [sp, #0]
 8026d32:	462b      	mov	r3, r5
 8026d34:	4622      	mov	r2, r4
 8026d36:	f7fc fff3 	bl	8023d20 <lv_text_get_size>
                         LV_COORD_MAX, flag);

        /*Draw the text again on label to the original to make a circular effect */
        if(size.x > lv_area_get_width(&txt_coords)) {
 8026d3a:	68bc      	ldr	r4, [r7, #8]
 8026d3c:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
 8026d40:	4618      	mov	r0, r3
 8026d42:	f7ff f96b 	bl	802601c <lv_area_get_width>
 8026d46:	4603      	mov	r3, r0
 8026d48:	429c      	cmp	r4, r3
 8026d4a:	dd20      	ble.n	8026d8e <draw_main+0x346>
            label_draw_dsc.ofs_x = label->offset.x + size.x +
 8026d4c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026d50:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 8026d52:	68bb      	ldr	r3, [r7, #8]
 8026d54:	18d4      	adds	r4, r2, r3
                                   lv_font_get_glyph_width(label_draw_dsc.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
 8026d56:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8026d58:	2220      	movs	r2, #32
 8026d5a:	2120      	movs	r1, #32
 8026d5c:	4618      	mov	r0, r3
 8026d5e:	f7f5 fb89 	bl	801c474 <lv_font_get_glyph_width>
 8026d62:	4603      	mov	r3, r0
 8026d64:	461a      	mov	r2, r3
 8026d66:	4613      	mov	r3, r2
 8026d68:	005b      	lsls	r3, r3, #1
 8026d6a:	4413      	add	r3, r2
            label_draw_dsc.ofs_x = label->offset.x + size.x +
 8026d6c:	4423      	add	r3, r4
 8026d6e:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
            label_draw_dsc.ofs_y = label->offset.y;
 8026d72:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026d76:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8026d78:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

            lv_draw_label(layer, &label_draw_dsc, &txt_coords);
 8026d7c:	f107 029c 	add.w	r2, r7, #156	@ 0x9c
 8026d80:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 8026d84:	4619      	mov	r1, r3
 8026d86:	f8d7 00b4 	ldr.w	r0, [r7, #180]	@ 0xb4
 8026d8a:	f7e6 f8c7 	bl	800cf1c <lv_draw_label>
        }

        /*Draw the text again below the original to make a circular effect */
        if(size.y > lv_area_get_height(&txt_coords)) {
 8026d8e:	68fc      	ldr	r4, [r7, #12]
 8026d90:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
 8026d94:	4618      	mov	r0, r3
 8026d96:	f7ff f951 	bl	802603c <lv_area_get_height>
 8026d9a:	4603      	mov	r3, r0
 8026d9c:	429c      	cmp	r4, r3
 8026d9e:	dd1a      	ble.n	8026dd6 <draw_main+0x38e>
            label_draw_dsc.ofs_x = label->offset.x;
 8026da0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026da4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8026da6:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
            label_draw_dsc.ofs_y = label->offset.y + size.y + lv_font_get_line_height(label_draw_dsc.font);
 8026daa:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 8026dae:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8026db0:	68fb      	ldr	r3, [r7, #12]
 8026db2:	18d4      	adds	r4, r2, r3
 8026db4:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
 8026db6:	4618      	mov	r0, r3
 8026db8:	f7ff f962 	bl	8026080 <lv_font_get_line_height>
 8026dbc:	4603      	mov	r3, r0
 8026dbe:	4423      	add	r3, r4
 8026dc0:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c

            lv_draw_label(layer, &label_draw_dsc, &txt_coords);
 8026dc4:	f107 029c 	add.w	r2, r7, #156	@ 0x9c
 8026dc8:	f107 0348 	add.w	r3, r7, #72	@ 0x48
 8026dcc:	4619      	mov	r1, r3
 8026dce:	f8d7 00b4 	ldr.w	r0, [r7, #180]	@ 0xb4
 8026dd2:	f7e6 f8a3 	bl	800cf1c <lv_draw_label>
        }
    }

    layer->_clip_area = clip_area_ori;
 8026dd6:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 8026dda:	f103 0418 	add.w	r4, r3, #24
 8026dde:	f107 0328 	add.w	r3, r7, #40	@ 0x28
 8026de2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8026de4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8026de8:	e000      	b.n	8026dec <draw_main+0x3a4>
        return;
 8026dea:	bf00      	nop
}
 8026dec:	37c0      	adds	r7, #192	@ 0xc0
 8026dee:	46bd      	mov	sp, r7
 8026df0:	bdb0      	pop	{r4, r5, r7, pc}

08026df2 <overwrite_anim_property>:

static void overwrite_anim_property(lv_anim_t * dest, const lv_anim_t * src, lv_label_long_mode_t mode)
{
 8026df2:	b480      	push	{r7}
 8026df4:	b085      	sub	sp, #20
 8026df6:	af00      	add	r7, sp, #0
 8026df8:	60f8      	str	r0, [r7, #12]
 8026dfa:	60b9      	str	r1, [r7, #8]
 8026dfc:	4613      	mov	r3, r2
 8026dfe:	71fb      	strb	r3, [r7, #7]
    switch(mode) {
 8026e00:	79fb      	ldrb	r3, [r7, #7]
 8026e02:	2b02      	cmp	r3, #2
 8026e04:	d002      	beq.n	8026e0c <overwrite_anim_property+0x1a>
 8026e06:	2b03      	cmp	r3, #3
 8026e08:	d01b      	beq.n	8026e42 <overwrite_anim_property+0x50>
            dest->repeat_cnt = src->repeat_cnt;
            dest->repeat_delay = src->repeat_delay;
            dest->completed_cb = src->completed_cb;
            break;
        default:
            break;
 8026e0a:	e031      	b.n	8026e70 <overwrite_anim_property+0x7e>
            if(dest->act_time <= 0)
 8026e0c:	68fb      	ldr	r3, [r7, #12]
 8026e0e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8026e10:	2b00      	cmp	r3, #0
 8026e12:	dc03      	bgt.n	8026e1c <overwrite_anim_property+0x2a>
                dest->act_time = src->act_time;
 8026e14:	68bb      	ldr	r3, [r7, #8]
 8026e16:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8026e18:	68fb      	ldr	r3, [r7, #12]
 8026e1a:	635a      	str	r2, [r3, #52]	@ 0x34
            dest->repeat_cnt = src->repeat_cnt;
 8026e1c:	68bb      	ldr	r3, [r7, #8]
 8026e1e:	f8b3 2044 	ldrh.w	r2, [r3, #68]	@ 0x44
 8026e22:	68fb      	ldr	r3, [r7, #12]
 8026e24:	f8a3 2044 	strh.w	r2, [r3, #68]	@ 0x44
            dest->repeat_delay = src->repeat_delay;
 8026e28:	68bb      	ldr	r3, [r7, #8]
 8026e2a:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8026e2c:	68fb      	ldr	r3, [r7, #12]
 8026e2e:	641a      	str	r2, [r3, #64]	@ 0x40
            dest->completed_cb = src->completed_cb;
 8026e30:	68bb      	ldr	r3, [r7, #8]
 8026e32:	691a      	ldr	r2, [r3, #16]
 8026e34:	68fb      	ldr	r3, [r7, #12]
 8026e36:	611a      	str	r2, [r3, #16]
            dest->playback_delay = src->playback_delay;
 8026e38:	68bb      	ldr	r3, [r7, #8]
 8026e3a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8026e3c:	68fb      	ldr	r3, [r7, #12]
 8026e3e:	639a      	str	r2, [r3, #56]	@ 0x38
            break;
 8026e40:	e016      	b.n	8026e70 <overwrite_anim_property+0x7e>
            if(dest->act_time <= 0)
 8026e42:	68fb      	ldr	r3, [r7, #12]
 8026e44:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8026e46:	2b00      	cmp	r3, #0
 8026e48:	dc03      	bgt.n	8026e52 <overwrite_anim_property+0x60>
                dest->act_time = src->act_time;
 8026e4a:	68bb      	ldr	r3, [r7, #8]
 8026e4c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8026e4e:	68fb      	ldr	r3, [r7, #12]
 8026e50:	635a      	str	r2, [r3, #52]	@ 0x34
            dest->repeat_cnt = src->repeat_cnt;
 8026e52:	68bb      	ldr	r3, [r7, #8]
 8026e54:	f8b3 2044 	ldrh.w	r2, [r3, #68]	@ 0x44
 8026e58:	68fb      	ldr	r3, [r7, #12]
 8026e5a:	f8a3 2044 	strh.w	r2, [r3, #68]	@ 0x44
            dest->repeat_delay = src->repeat_delay;
 8026e5e:	68bb      	ldr	r3, [r7, #8]
 8026e60:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8026e62:	68fb      	ldr	r3, [r7, #12]
 8026e64:	641a      	str	r2, [r3, #64]	@ 0x40
            dest->completed_cb = src->completed_cb;
 8026e66:	68bb      	ldr	r3, [r7, #8]
 8026e68:	691a      	ldr	r2, [r3, #16]
 8026e6a:	68fb      	ldr	r3, [r7, #12]
 8026e6c:	611a      	str	r2, [r3, #16]
            break;
 8026e6e:	bf00      	nop
    }
}
 8026e70:	bf00      	nop
 8026e72:	3714      	adds	r7, #20
 8026e74:	46bd      	mov	sp, r7
 8026e76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026e7a:	4770      	bx	lr

08026e7c <lv_label_refr_text>:
/**
 * Refresh the label with its text stored in its extended data
 * @param label pointer to a label object
 */
static void lv_label_refr_text(lv_obj_t * obj)
{
 8026e7c:	b590      	push	{r4, r7, lr}
 8026e7e:	b0c7      	sub	sp, #284	@ 0x11c
 8026e80:	af04      	add	r7, sp, #16
 8026e82:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8026e86:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8026e8a:	6018      	str	r0, [r3, #0]
    lv_label_t * label = (lv_label_t *)obj;
 8026e8c:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8026e90:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8026e94:	681b      	ldr	r3, [r3, #0]
 8026e96:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    if(label->text == NULL) return;
 8026e9a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8026e9e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8026ea0:	2b00      	cmp	r3, #0
 8026ea2:	f000 846c 	beq.w	802777e <lv_label_refr_text+0x902>
#if LV_LABEL_LONG_TXT_HINT
    label->hint.line_start = -1; /*The hint is invalid if the text changes*/
 8026ea6:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8026eaa:	f04f 32ff 	mov.w	r2, #4294967295
 8026eae:	639a      	str	r2, [r3, #56]	@ 0x38
#endif
    label->invalid_size_cache = true;
 8026eb0:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 8026eb4:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 8026eb8:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8026ebc:	f882 305c 	strb.w	r3, [r2, #92]	@ 0x5c

    lv_area_t txt_coords;
    lv_obj_get_content_coords(obj, &txt_coords);
 8026ec0:	f107 0278 	add.w	r2, r7, #120	@ 0x78
 8026ec4:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8026ec8:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8026ecc:	4611      	mov	r1, r2
 8026ece:	6818      	ldr	r0, [r3, #0]
 8026ed0:	f7de ff7e 	bl	8005dd0 <lv_obj_get_content_coords>
    int32_t max_w         = lv_area_get_width(&txt_coords);
 8026ed4:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8026ed8:	4618      	mov	r0, r3
 8026eda:	f7ff f89f 	bl	802601c <lv_area_get_width>
 8026ede:	f8c7 00d4 	str.w	r0, [r7, #212]	@ 0xd4
    const lv_font_t * font   = lv_obj_get_style_text_font(obj, LV_PART_MAIN);
 8026ee2:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8026ee6:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8026eea:	2100      	movs	r1, #0
 8026eec:	6818      	ldr	r0, [r3, #0]
 8026eee:	f7ff f9f3 	bl	80262d8 <lv_obj_get_style_text_font>
 8026ef2:	f8c7 00d0 	str.w	r0, [r7, #208]	@ 0xd0
    int32_t line_space = lv_obj_get_style_text_line_space(obj, LV_PART_MAIN);
 8026ef6:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8026efa:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8026efe:	2100      	movs	r1, #0
 8026f00:	6818      	ldr	r0, [r3, #0]
 8026f02:	f7ff fa0b 	bl	802631c <lv_obj_get_style_text_line_space>
 8026f06:	f8c7 00cc 	str.w	r0, [r7, #204]	@ 0xcc
    int32_t letter_space = lv_obj_get_style_text_letter_space(obj, LV_PART_MAIN);
 8026f0a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8026f0e:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8026f12:	2100      	movs	r1, #0
 8026f14:	6818      	ldr	r0, [r3, #0]
 8026f16:	f7ff f9f0 	bl	80262fa <lv_obj_get_style_text_letter_space>
 8026f1a:	f8c7 00c8 	str.w	r0, [r7, #200]	@ 0xc8

    /*Calc. the height and longest line*/
    lv_point_t size;
    lv_text_flag_t flag = get_label_flags(label);
 8026f1e:	f8d7 00d8 	ldr.w	r0, [r7, #216]	@ 0xd8
 8026f22:	f000 fd4d 	bl	80279c0 <get_label_flags>
 8026f26:	4603      	mov	r3, r0
 8026f28:	f887 30c7 	strb.w	r3, [r7, #199]	@ 0xc7

    lv_text_get_size(&size, label->text, font, letter_space, line_space, max_w, flag);
 8026f2c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8026f30:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8026f32:	f107 0070 	add.w	r0, r7, #112	@ 0x70
 8026f36:	f897 30c7 	ldrb.w	r3, [r7, #199]	@ 0xc7
 8026f3a:	9302      	str	r3, [sp, #8]
 8026f3c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 8026f40:	9301      	str	r3, [sp, #4]
 8026f42:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8026f46:	9300      	str	r3, [sp, #0]
 8026f48:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8026f4c:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8026f50:	f7fc fee6 	bl	8023d20 <lv_text_get_size>

    lv_obj_refresh_self_size(obj);
 8026f54:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8026f58:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8026f5c:	6818      	ldr	r0, [r3, #0]
 8026f5e:	f7de ff99 	bl	8005e94 <lv_obj_refresh_self_size>

    /*In scroll mode start an offset animation*/
    if(label->long_mode == LV_LABEL_LONG_SCROLL) {
 8026f62:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8026f66:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8026f6a:	f003 0307 	and.w	r3, r3, #7
 8026f6e:	b2db      	uxtb	r3, r3
 8026f70:	2b02      	cmp	r3, #2
 8026f72:	f040 8195 	bne.w	80272a0 <lv_label_refr_text+0x424>
        const lv_anim_t * anim_template = lv_obj_get_style_anim(obj, LV_PART_MAIN);
 8026f76:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8026f7a:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8026f7e:	2100      	movs	r1, #0
 8026f80:	6818      	ldr	r0, [r3, #0]
 8026f82:	f7ff f9dc 	bl	802633e <lv_obj_get_style_anim>
 8026f86:	f8c7 00a0 	str.w	r0, [r7, #160]	@ 0xa0
        uint32_t anim_time = lv_obj_get_style_anim_duration(obj, LV_PART_MAIN);
 8026f8a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8026f8e:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8026f92:	2100      	movs	r1, #0
 8026f94:	6818      	ldr	r0, [r3, #0]
 8026f96:	f7ff f9e3 	bl	8026360 <lv_obj_get_style_anim_duration>
 8026f9a:	f8c7 0104 	str.w	r0, [r7, #260]	@ 0x104
        if(anim_time == 0) anim_time = LV_LABEL_DEF_SCROLL_SPEED;
 8026f9e:	f8d7 3104 	ldr.w	r3, [r7, #260]	@ 0x104
 8026fa2:	2b00      	cmp	r3, #0
 8026fa4:	d108      	bne.n	8026fb8 <lv_label_refr_text+0x13c>
 8026fa6:	f242 7210 	movw	r2, #10000	@ 0x2710
 8026faa:	f44f 7196 	mov.w	r1, #300	@ 0x12c
 8026fae:	2028      	movs	r0, #40	@ 0x28
 8026fb0:	f7fa f8d8 	bl	8021164 <lv_anim_speed_clamped>
 8026fb4:	f8c7 0104 	str.w	r0, [r7, #260]	@ 0x104
        lv_anim_t a;
        lv_anim_init(&a);
 8026fb8:	f107 030c 	add.w	r3, r7, #12
 8026fbc:	4618      	mov	r0, r3
 8026fbe:	f7f9 ffbb 	bl	8020f38 <lv_anim_init>
        lv_anim_set_var(&a, obj);
 8026fc2:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8026fc6:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8026fca:	f107 020c 	add.w	r2, r7, #12
 8026fce:	6819      	ldr	r1, [r3, #0]
 8026fd0:	4610      	mov	r0, r2
 8026fd2:	f7ff f861 	bl	8026098 <lv_anim_set_var>
        lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);
 8026fd6:	f107 030c 	add.w	r3, r7, #12
 8026fda:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 8026fde:	4618      	mov	r0, r3
 8026fe0:	f7ff f8b6 	bl	8026150 <lv_anim_set_repeat_count>
        lv_anim_set_playback_delay(&a, LV_LABEL_SCROLL_DELAY);
 8026fe4:	f107 030c 	add.w	r3, r7, #12
 8026fe8:	f44f 7196 	mov.w	r1, #300	@ 0x12c
 8026fec:	4618      	mov	r0, r3
 8026fee:	f7ff f8a1 	bl	8026134 <lv_anim_set_playback_delay>
        lv_anim_set_repeat_delay(&a, a.playback_delay);
 8026ff2:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8026ff4:	f107 030c 	add.w	r3, r7, #12
 8026ff8:	4611      	mov	r1, r2
 8026ffa:	4618      	mov	r0, r3
 8026ffc:	f7ff f8b8 	bl	8026170 <lv_anim_set_repeat_delay>

        bool hor_anim = false;
 8027000:	2300      	movs	r3, #0
 8027002:	f887 3103 	strb.w	r3, [r7, #259]	@ 0x103
        if(size.x > lv_area_get_width(&txt_coords)) {
 8027006:	6f3c      	ldr	r4, [r7, #112]	@ 0x70
 8027008:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 802700c:	4618      	mov	r0, r3
 802700e:	f7ff f805 	bl	802601c <lv_area_get_width>
 8027012:	4603      	mov	r3, r0
 8027014:	429c      	cmp	r4, r3
 8027016:	f340 8090 	ble.w	802713a <lv_label_refr_text+0x2be>
            int32_t start = 0;
 802701a:	2300      	movs	r3, #0
 802701c:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
            int32_t end = 0;
 8027020:	2300      	movs	r3, #0
 8027022:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
            else {
                start = 0;
                end = lv_area_get_width(&txt_coords) - size.x;
            }
#else
            end = lv_area_get_width(&txt_coords) - size.x;
 8027026:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 802702a:	4618      	mov	r0, r3
 802702c:	f7fe fff6 	bl	802601c <lv_area_get_width>
 8027030:	4602      	mov	r2, r0
 8027032:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8027034:	1ad3      	subs	r3, r2, r3
 8027036:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
#endif

            lv_anim_set_values(&a, start, end);
 802703a:	f107 030c 	add.w	r3, r7, #12
 802703e:	f8d7 2098 	ldr.w	r2, [r7, #152]	@ 0x98
 8027042:	f8d7 109c 	ldr.w	r1, [r7, #156]	@ 0x9c
 8027046:	4618      	mov	r0, r3
 8027048:	f7ff f850 	bl	80260ec <lv_anim_set_values>
            lv_anim_set_exec_cb(&a, set_ofs_x_anim);
 802704c:	f107 030c 	add.w	r3, r7, #12
 8027050:	49d2      	ldr	r1, [pc, #840]	@ (802739c <lv_label_refr_text+0x520>)
 8027052:	4618      	mov	r0, r3
 8027054:	f7ff f82e 	bl	80260b4 <lv_anim_set_exec_cb>

            lv_anim_t * anim_cur = lv_anim_get(obj, set_ofs_x_anim);
 8027058:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 802705c:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8027060:	49ce      	ldr	r1, [pc, #824]	@ (802739c <lv_label_refr_text+0x520>)
 8027062:	6818      	ldr	r0, [r3, #0]
 8027064:	f7fa f856 	bl	8021114 <lv_anim_get>
 8027068:	f8c7 0094 	str.w	r0, [r7, #148]	@ 0x94
            int32_t act_time = 0;
 802706c:	2300      	movs	r3, #0
 802706e:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
            bool playback_now = false;
 8027072:	2300      	movs	r3, #0
 8027074:	f887 30fb 	strb.w	r3, [r7, #251]	@ 0xfb
            if(anim_cur) {
 8027078:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 802707c:	2b00      	cmp	r3, #0
 802707e:	d011      	beq.n	80270a4 <lv_label_refr_text+0x228>
                act_time = anim_cur->act_time;
 8027080:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 8027084:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8027086:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
                playback_now = anim_cur->playback_now;
 802708a:	f8d7 3094 	ldr.w	r3, [r7, #148]	@ 0x94
 802708e:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 8027092:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8027096:	b2db      	uxtb	r3, r3
 8027098:	2b00      	cmp	r3, #0
 802709a:	bf14      	ite	ne
 802709c:	2301      	movne	r3, #1
 802709e:	2300      	moveq	r3, #0
 80270a0:	f887 30fb 	strb.w	r3, [r7, #251]	@ 0xfb
            }
            if(act_time < a.duration) {
 80270a4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80270a6:	f8d7 20fc 	ldr.w	r2, [r7, #252]	@ 0xfc
 80270aa:	429a      	cmp	r2, r3
 80270ac:	da1a      	bge.n	80270e4 <lv_label_refr_text+0x268>
                a.act_time = act_time;      /*To keep the old position*/
 80270ae:	f8d7 30fc 	ldr.w	r3, [r7, #252]	@ 0xfc
 80270b2:	643b      	str	r3, [r7, #64]	@ 0x40
                a.early_apply = 0;
 80270b4:	f897 305a 	ldrb.w	r3, [r7, #90]	@ 0x5a
 80270b8:	f36f 0300 	bfc	r3, #0, #1
 80270bc:	f887 305a 	strb.w	r3, [r7, #90]	@ 0x5a
                if(playback_now) {
 80270c0:	f897 30fb 	ldrb.w	r3, [r7, #251]	@ 0xfb
 80270c4:	2b00      	cmp	r3, #0
 80270c6:	d00d      	beq.n	80270e4 <lv_label_refr_text+0x268>
                    a.playback_now = 1;
 80270c8:	f897 3060 	ldrb.w	r3, [r7, #96]	@ 0x60
 80270cc:	f043 0301 	orr.w	r3, r3, #1
 80270d0:	f887 3060 	strb.w	r3, [r7, #96]	@ 0x60
                    /*Swap the start and end values*/
                    int32_t tmp;
                    tmp      = a.start_value;
 80270d4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80270d6:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
                    a.start_value = a.end_value;
 80270da:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80270dc:	633b      	str	r3, [r7, #48]	@ 0x30
                    a.end_value   = tmp;
 80270de:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 80270e2:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
            }

            lv_anim_set_duration(&a, anim_time);
 80270e4:	f107 030c 	add.w	r3, r7, #12
 80270e8:	f8d7 1104 	ldr.w	r1, [r7, #260]	@ 0x104
 80270ec:	4618      	mov	r0, r3
 80270ee:	f7fe ffef 	bl	80260d0 <lv_anim_set_duration>
            lv_anim_set_playback_duration(&a, a.duration);
 80270f2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80270f4:	461a      	mov	r2, r3
 80270f6:	f107 030c 	add.w	r3, r7, #12
 80270fa:	4611      	mov	r1, r2
 80270fc:	4618      	mov	r0, r3
 80270fe:	f7ff f80b 	bl	8026118 <lv_anim_set_playback_duration>

            /*If a template animation exists, overwrite some property*/
            if(anim_template)
 8027102:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8027106:	2b00      	cmp	r3, #0
 8027108:	d00e      	beq.n	8027128 <lv_label_refr_text+0x2ac>
                overwrite_anim_property(&a, anim_template, label->long_mode);
 802710a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 802710e:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8027112:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8027116:	b2db      	uxtb	r3, r3
 8027118:	461a      	mov	r2, r3
 802711a:	f107 030c 	add.w	r3, r7, #12
 802711e:	f8d7 10a0 	ldr.w	r1, [r7, #160]	@ 0xa0
 8027122:	4618      	mov	r0, r3
 8027124:	f7ff fe65 	bl	8026df2 <overwrite_anim_property>
            lv_anim_start(&a);
 8027128:	f107 030c 	add.w	r3, r7, #12
 802712c:	4618      	mov	r0, r3
 802712e:	f7f9 ff29 	bl	8020f84 <lv_anim_start>
            hor_anim = true;
 8027132:	2301      	movs	r3, #1
 8027134:	f887 3103 	strb.w	r3, [r7, #259]	@ 0x103
 8027138:	e00b      	b.n	8027152 <lv_label_refr_text+0x2d6>
        }
        else {
            /*Delete the offset animation if not required*/
            lv_anim_delete(obj, set_ofs_x_anim);
 802713a:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 802713e:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8027142:	4996      	ldr	r1, [pc, #600]	@ (802739c <lv_label_refr_text+0x520>)
 8027144:	6818      	ldr	r0, [r3, #0]
 8027146:	f7f9 ff99 	bl	802107c <lv_anim_delete>
            label->offset.x = 0;
 802714a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 802714e:	2200      	movs	r2, #0
 8027150:	655a      	str	r2, [r3, #84]	@ 0x54
        }

        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {
 8027152:	6f7c      	ldr	r4, [r7, #116]	@ 0x74
 8027154:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8027158:	4618      	mov	r0, r3
 802715a:	f7fe ff6f 	bl	802603c <lv_area_get_height>
 802715e:	4603      	mov	r3, r0
 8027160:	429c      	cmp	r4, r3
 8027162:	f340 8090 	ble.w	8027286 <lv_label_refr_text+0x40a>
 8027166:	f897 3103 	ldrb.w	r3, [r7, #259]	@ 0x103
 802716a:	f083 0301 	eor.w	r3, r3, #1
 802716e:	b2db      	uxtb	r3, r3
 8027170:	2b00      	cmp	r3, #0
 8027172:	f000 8088 	beq.w	8027286 <lv_label_refr_text+0x40a>
            lv_anim_set_values(&a, 0, lv_area_get_height(&txt_coords) - size.y - (lv_font_get_line_height(font)));
 8027176:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 802717a:	4618      	mov	r0, r3
 802717c:	f7fe ff5e 	bl	802603c <lv_area_get_height>
 8027180:	4602      	mov	r2, r0
 8027182:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8027184:	1ad4      	subs	r4, r2, r3
 8027186:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 802718a:	f7fe ff79 	bl	8026080 <lv_font_get_line_height>
 802718e:	4603      	mov	r3, r0
 8027190:	1ae2      	subs	r2, r4, r3
 8027192:	f107 030c 	add.w	r3, r7, #12
 8027196:	2100      	movs	r1, #0
 8027198:	4618      	mov	r0, r3
 802719a:	f7fe ffa7 	bl	80260ec <lv_anim_set_values>
            lv_anim_set_exec_cb(&a, set_ofs_y_anim);
 802719e:	f107 030c 	add.w	r3, r7, #12
 80271a2:	497f      	ldr	r1, [pc, #508]	@ (80273a0 <lv_label_refr_text+0x524>)
 80271a4:	4618      	mov	r0, r3
 80271a6:	f7fe ff85 	bl	80260b4 <lv_anim_set_exec_cb>

            lv_anim_t * anim_cur = lv_anim_get(obj, set_ofs_y_anim);
 80271aa:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 80271ae:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 80271b2:	497b      	ldr	r1, [pc, #492]	@ (80273a0 <lv_label_refr_text+0x524>)
 80271b4:	6818      	ldr	r0, [r3, #0]
 80271b6:	f7f9 ffad 	bl	8021114 <lv_anim_get>
 80271ba:	f8c7 008c 	str.w	r0, [r7, #140]	@ 0x8c
            int32_t act_time = 0;
 80271be:	2300      	movs	r3, #0
 80271c0:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
            bool playback_now = false;
 80271c4:	2300      	movs	r3, #0
 80271c6:	f887 30f3 	strb.w	r3, [r7, #243]	@ 0xf3
            if(anim_cur) {
 80271ca:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80271ce:	2b00      	cmp	r3, #0
 80271d0:	d011      	beq.n	80271f6 <lv_label_refr_text+0x37a>
                act_time = anim_cur->act_time;
 80271d2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80271d6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80271d8:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
                playback_now = anim_cur->playback_now;
 80271dc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 80271e0:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
 80271e4:	f3c3 0300 	ubfx	r3, r3, #0, #1
 80271e8:	b2db      	uxtb	r3, r3
 80271ea:	2b00      	cmp	r3, #0
 80271ec:	bf14      	ite	ne
 80271ee:	2301      	movne	r3, #1
 80271f0:	2300      	moveq	r3, #0
 80271f2:	f887 30f3 	strb.w	r3, [r7, #243]	@ 0xf3
            }
            if(act_time < a.duration) {
 80271f6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80271f8:	f8d7 20f4 	ldr.w	r2, [r7, #244]	@ 0xf4
 80271fc:	429a      	cmp	r2, r3
 80271fe:	da1a      	bge.n	8027236 <lv_label_refr_text+0x3ba>
                a.act_time = act_time;      /*To keep the old position*/
 8027200:	f8d7 30f4 	ldr.w	r3, [r7, #244]	@ 0xf4
 8027204:	643b      	str	r3, [r7, #64]	@ 0x40
                a.early_apply = 0;
 8027206:	f897 305a 	ldrb.w	r3, [r7, #90]	@ 0x5a
 802720a:	f36f 0300 	bfc	r3, #0, #1
 802720e:	f887 305a 	strb.w	r3, [r7, #90]	@ 0x5a
                if(playback_now) {
 8027212:	f897 30f3 	ldrb.w	r3, [r7, #243]	@ 0xf3
 8027216:	2b00      	cmp	r3, #0
 8027218:	d00d      	beq.n	8027236 <lv_label_refr_text+0x3ba>
                    a.playback_now = 1;
 802721a:	f897 3060 	ldrb.w	r3, [r7, #96]	@ 0x60
 802721e:	f043 0301 	orr.w	r3, r3, #1
 8027222:	f887 3060 	strb.w	r3, [r7, #96]	@ 0x60
                    /*Swap the start and end values*/
                    int32_t tmp;
                    tmp      = a.start_value;
 8027226:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8027228:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
                    a.start_value = a.end_value;
 802722c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 802722e:	633b      	str	r3, [r7, #48]	@ 0x30
                    a.end_value   = tmp;
 8027230:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8027234:	63bb      	str	r3, [r7, #56]	@ 0x38
                }
            }

            lv_anim_set_duration(&a, anim_time);
 8027236:	f107 030c 	add.w	r3, r7, #12
 802723a:	f8d7 1104 	ldr.w	r1, [r7, #260]	@ 0x104
 802723e:	4618      	mov	r0, r3
 8027240:	f7fe ff46 	bl	80260d0 <lv_anim_set_duration>
            lv_anim_set_playback_duration(&a, a.duration);
 8027244:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8027246:	461a      	mov	r2, r3
 8027248:	f107 030c 	add.w	r3, r7, #12
 802724c:	4611      	mov	r1, r2
 802724e:	4618      	mov	r0, r3
 8027250:	f7fe ff62 	bl	8026118 <lv_anim_set_playback_duration>

            /*If a template animation exists, overwrite some property*/
            if(anim_template)
 8027254:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 8027258:	2b00      	cmp	r3, #0
 802725a:	d00e      	beq.n	802727a <lv_label_refr_text+0x3fe>
                overwrite_anim_property(&a, anim_template, label->long_mode);
 802725c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8027260:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8027264:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8027268:	b2db      	uxtb	r3, r3
 802726a:	461a      	mov	r2, r3
 802726c:	f107 030c 	add.w	r3, r7, #12
 8027270:	f8d7 10a0 	ldr.w	r1, [r7, #160]	@ 0xa0
 8027274:	4618      	mov	r0, r3
 8027276:	f7ff fdbc 	bl	8026df2 <overwrite_anim_property>
            lv_anim_start(&a);
 802727a:	f107 030c 	add.w	r3, r7, #12
 802727e:	4618      	mov	r0, r3
 8027280:	f7f9 fe80 	bl	8020f84 <lv_anim_start>
        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {
 8027284:	e273      	b.n	802776e <lv_label_refr_text+0x8f2>
        }
        else {
            /*Delete the offset animation if not required*/
            lv_anim_delete(obj, set_ofs_y_anim);
 8027286:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 802728a:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 802728e:	4944      	ldr	r1, [pc, #272]	@ (80273a0 <lv_label_refr_text+0x524>)
 8027290:	6818      	ldr	r0, [r3, #0]
 8027292:	f7f9 fef3 	bl	802107c <lv_anim_delete>
            label->offset.y = 0;
 8027296:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 802729a:	2200      	movs	r2, #0
 802729c:	659a      	str	r2, [r3, #88]	@ 0x58
 802729e:	e266      	b.n	802776e <lv_label_refr_text+0x8f2>
        }
    }
    /*In roll inf. mode keep the size but start offset animations*/
    else if(label->long_mode == LV_LABEL_LONG_SCROLL_CIRCULAR) {
 80272a0:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80272a4:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 80272a8:	f003 0307 	and.w	r3, r3, #7
 80272ac:	b2db      	uxtb	r3, r3
 80272ae:	2b03      	cmp	r3, #3
 80272b0:	f040 8127 	bne.w	8027502 <lv_label_refr_text+0x686>
        const lv_anim_t * anim_template = lv_obj_get_style_anim(obj, LV_PART_MAIN);
 80272b4:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 80272b8:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 80272bc:	2100      	movs	r1, #0
 80272be:	6818      	ldr	r0, [r3, #0]
 80272c0:	f7ff f83d 	bl	802633e <lv_obj_get_style_anim>
 80272c4:	f8c7 00b4 	str.w	r0, [r7, #180]	@ 0xb4
        uint32_t anim_time = lv_obj_get_style_anim_duration(obj, LV_PART_MAIN);
 80272c8:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 80272cc:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 80272d0:	2100      	movs	r1, #0
 80272d2:	6818      	ldr	r0, [r3, #0]
 80272d4:	f7ff f844 	bl	8026360 <lv_obj_get_style_anim_duration>
 80272d8:	f8c7 00ec 	str.w	r0, [r7, #236]	@ 0xec
        if(anim_time == 0) anim_time = LV_LABEL_DEF_SCROLL_SPEED;
 80272dc:	f8d7 30ec 	ldr.w	r3, [r7, #236]	@ 0xec
 80272e0:	2b00      	cmp	r3, #0
 80272e2:	d108      	bne.n	80272f6 <lv_label_refr_text+0x47a>
 80272e4:	f242 7210 	movw	r2, #10000	@ 0x2710
 80272e8:	f44f 7196 	mov.w	r1, #300	@ 0x12c
 80272ec:	2028      	movs	r0, #40	@ 0x28
 80272ee:	f7f9 ff39 	bl	8021164 <lv_anim_speed_clamped>
 80272f2:	f8c7 00ec 	str.w	r0, [r7, #236]	@ 0xec
        lv_anim_t a;
        lv_anim_init(&a);
 80272f6:	f107 030c 	add.w	r3, r7, #12
 80272fa:	4618      	mov	r0, r3
 80272fc:	f7f9 fe1c 	bl	8020f38 <lv_anim_init>
        lv_anim_set_var(&a, obj);
 8027300:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8027304:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8027308:	f107 020c 	add.w	r2, r7, #12
 802730c:	6819      	ldr	r1, [r3, #0]
 802730e:	4610      	mov	r0, r2
 8027310:	f7fe fec2 	bl	8026098 <lv_anim_set_var>
        lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);
 8027314:	f107 030c 	add.w	r3, r7, #12
 8027318:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 802731c:	4618      	mov	r0, r3
 802731e:	f7fe ff17 	bl	8026150 <lv_anim_set_repeat_count>

        bool hor_anim = false;
 8027322:	2300      	movs	r3, #0
 8027324:	f887 30eb 	strb.w	r3, [r7, #235]	@ 0xeb
        if(size.x > lv_area_get_width(&txt_coords)) {
 8027328:	6f3c      	ldr	r4, [r7, #112]	@ 0x70
 802732a:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 802732e:	4618      	mov	r0, r3
 8027330:	f7fe fe74 	bl	802601c <lv_area_get_width>
 8027334:	4603      	mov	r3, r0
 8027336:	429c      	cmp	r4, r3
 8027338:	dd62      	ble.n	8027400 <lv_label_refr_text+0x584>
                end = -size.x - lv_font_get_glyph_width(font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
            }

            lv_anim_set_values(&a, start, end);
#else
            lv_anim_set_values(&a, 0, -size.x - lv_font_get_glyph_width(font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT);
 802733a:	2220      	movs	r2, #32
 802733c:	2120      	movs	r1, #32
 802733e:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 8027342:	f7f5 f897 	bl	801c474 <lv_font_get_glyph_width>
 8027346:	4603      	mov	r3, r0
 8027348:	461a      	mov	r2, r3
 802734a:	009b      	lsls	r3, r3, #2
 802734c:	1ad2      	subs	r2, r2, r3
 802734e:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8027350:	1ad2      	subs	r2, r2, r3
 8027352:	f107 030c 	add.w	r3, r7, #12
 8027356:	2100      	movs	r1, #0
 8027358:	4618      	mov	r0, r3
 802735a:	f7fe fec7 	bl	80260ec <lv_anim_set_values>
#endif
            lv_anim_set_exec_cb(&a, set_ofs_x_anim);
 802735e:	f107 030c 	add.w	r3, r7, #12
 8027362:	490e      	ldr	r1, [pc, #56]	@ (802739c <lv_label_refr_text+0x520>)
 8027364:	4618      	mov	r0, r3
 8027366:	f7fe fea5 	bl	80260b4 <lv_anim_set_exec_cb>
            lv_anim_set_duration(&a, anim_time);
 802736a:	f107 030c 	add.w	r3, r7, #12
 802736e:	f8d7 10ec 	ldr.w	r1, [r7, #236]	@ 0xec
 8027372:	4618      	mov	r0, r3
 8027374:	f7fe feac 	bl	80260d0 <lv_anim_set_duration>

            lv_anim_t * anim_cur = lv_anim_get(obj, set_ofs_x_anim);
 8027378:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 802737c:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8027380:	4906      	ldr	r1, [pc, #24]	@ (802739c <lv_label_refr_text+0x520>)
 8027382:	6818      	ldr	r0, [r3, #0]
 8027384:	f7f9 fec6 	bl	8021114 <lv_anim_get>
 8027388:	f8c7 00b0 	str.w	r0, [r7, #176]	@ 0xb0
            int32_t act_time = anim_cur ? anim_cur->act_time : 0;
 802738c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8027390:	2b00      	cmp	r3, #0
 8027392:	d007      	beq.n	80273a4 <lv_label_refr_text+0x528>
 8027394:	f8d7 30b0 	ldr.w	r3, [r7, #176]	@ 0xb0
 8027398:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 802739a:	e004      	b.n	80273a6 <lv_label_refr_text+0x52a>
 802739c:	0802793d 	.word	0x0802793d
 80273a0:	0802795f 	.word	0x0802795f
 80273a4:	2300      	movs	r3, #0
 80273a6:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac

            /*If a template animation exists, overwrite some property*/
            if(anim_template) {
 80273aa:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 80273ae:	2b00      	cmp	r3, #0
 80273b0:	d00f      	beq.n	80273d2 <lv_label_refr_text+0x556>
                overwrite_anim_property(&a, anim_template, label->long_mode);
 80273b2:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80273b6:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 80273ba:	f3c3 0302 	ubfx	r3, r3, #0, #3
 80273be:	b2db      	uxtb	r3, r3
 80273c0:	461a      	mov	r2, r3
 80273c2:	f107 030c 	add.w	r3, r7, #12
 80273c6:	f8d7 10b4 	ldr.w	r1, [r7, #180]	@ 0xb4
 80273ca:	4618      	mov	r0, r3
 80273cc:	f7ff fd11 	bl	8026df2 <overwrite_anim_property>
 80273d0:	e00d      	b.n	80273ee <lv_label_refr_text+0x572>
            }
            else if(act_time < a.duration) {
 80273d2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80273d4:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 80273d8:	429a      	cmp	r2, r3
 80273da:	da08      	bge.n	80273ee <lv_label_refr_text+0x572>
                a.act_time = act_time;      /*To keep the old position when the label text is updated mid-scrolling*/
 80273dc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	@ 0xac
 80273e0:	643b      	str	r3, [r7, #64]	@ 0x40
                a.early_apply = 0;
 80273e2:	f897 305a 	ldrb.w	r3, [r7, #90]	@ 0x5a
 80273e6:	f36f 0300 	bfc	r3, #0, #1
 80273ea:	f887 305a 	strb.w	r3, [r7, #90]	@ 0x5a
            }

            lv_anim_start(&a);
 80273ee:	f107 030c 	add.w	r3, r7, #12
 80273f2:	4618      	mov	r0, r3
 80273f4:	f7f9 fdc6 	bl	8020f84 <lv_anim_start>
            hor_anim = true;
 80273f8:	2301      	movs	r3, #1
 80273fa:	f887 30eb 	strb.w	r3, [r7, #235]	@ 0xeb
 80273fe:	e00b      	b.n	8027418 <lv_label_refr_text+0x59c>
        }
        else {
            /*Delete the offset animation if not required*/
            lv_anim_delete(obj, set_ofs_x_anim);
 8027400:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8027404:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8027408:	49c0      	ldr	r1, [pc, #768]	@ (802770c <lv_label_refr_text+0x890>)
 802740a:	6818      	ldr	r0, [r3, #0]
 802740c:	f7f9 fe36 	bl	802107c <lv_anim_delete>
            label->offset.x = 0;
 8027410:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8027414:	2200      	movs	r2, #0
 8027416:	655a      	str	r2, [r3, #84]	@ 0x54
        }

        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {
 8027418:	6f7c      	ldr	r4, [r7, #116]	@ 0x74
 802741a:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 802741e:	4618      	mov	r0, r3
 8027420:	f7fe fe0c 	bl	802603c <lv_area_get_height>
 8027424:	4603      	mov	r3, r0
 8027426:	429c      	cmp	r4, r3
 8027428:	dd5e      	ble.n	80274e8 <lv_label_refr_text+0x66c>
 802742a:	f897 30eb 	ldrb.w	r3, [r7, #235]	@ 0xeb
 802742e:	f083 0301 	eor.w	r3, r3, #1
 8027432:	b2db      	uxtb	r3, r3
 8027434:	2b00      	cmp	r3, #0
 8027436:	d057      	beq.n	80274e8 <lv_label_refr_text+0x66c>
            lv_anim_set_values(&a, 0, -size.y - (lv_font_get_line_height(font)));
 8027438:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 802743a:	425c      	negs	r4, r3
 802743c:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 8027440:	f7fe fe1e 	bl	8026080 <lv_font_get_line_height>
 8027444:	4603      	mov	r3, r0
 8027446:	1ae2      	subs	r2, r4, r3
 8027448:	f107 030c 	add.w	r3, r7, #12
 802744c:	2100      	movs	r1, #0
 802744e:	4618      	mov	r0, r3
 8027450:	f7fe fe4c 	bl	80260ec <lv_anim_set_values>
            lv_anim_set_exec_cb(&a, set_ofs_y_anim);
 8027454:	f107 030c 	add.w	r3, r7, #12
 8027458:	49ad      	ldr	r1, [pc, #692]	@ (8027710 <lv_label_refr_text+0x894>)
 802745a:	4618      	mov	r0, r3
 802745c:	f7fe fe2a 	bl	80260b4 <lv_anim_set_exec_cb>
            lv_anim_set_duration(&a, anim_time);
 8027460:	f107 030c 	add.w	r3, r7, #12
 8027464:	f8d7 10ec 	ldr.w	r1, [r7, #236]	@ 0xec
 8027468:	4618      	mov	r0, r3
 802746a:	f7fe fe31 	bl	80260d0 <lv_anim_set_duration>

            lv_anim_t * anim_cur = lv_anim_get(obj, set_ofs_y_anim);
 802746e:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8027472:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8027476:	49a6      	ldr	r1, [pc, #664]	@ (8027710 <lv_label_refr_text+0x894>)
 8027478:	6818      	ldr	r0, [r3, #0]
 802747a:	f7f9 fe4b 	bl	8021114 <lv_anim_get>
 802747e:	f8c7 00a8 	str.w	r0, [r7, #168]	@ 0xa8
            int32_t act_time = anim_cur ? anim_cur->act_time : 0;
 8027482:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 8027486:	2b00      	cmp	r3, #0
 8027488:	d003      	beq.n	8027492 <lv_label_refr_text+0x616>
 802748a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	@ 0xa8
 802748e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8027490:	e000      	b.n	8027494 <lv_label_refr_text+0x618>
 8027492:	2300      	movs	r3, #0
 8027494:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4

            /*If a template animation exists, overwrite some property*/
            if(anim_template) {
 8027498:	f8d7 30b4 	ldr.w	r3, [r7, #180]	@ 0xb4
 802749c:	2b00      	cmp	r3, #0
 802749e:	d00f      	beq.n	80274c0 <lv_label_refr_text+0x644>
                overwrite_anim_property(&a, anim_template, label->long_mode);
 80274a0:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80274a4:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 80274a8:	f3c3 0302 	ubfx	r3, r3, #0, #3
 80274ac:	b2db      	uxtb	r3, r3
 80274ae:	461a      	mov	r2, r3
 80274b0:	f107 030c 	add.w	r3, r7, #12
 80274b4:	f8d7 10b4 	ldr.w	r1, [r7, #180]	@ 0xb4
 80274b8:	4618      	mov	r0, r3
 80274ba:	f7ff fc9a 	bl	8026df2 <overwrite_anim_property>
 80274be:	e00d      	b.n	80274dc <lv_label_refr_text+0x660>
            }
            else if(act_time < a.duration) {
 80274c0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80274c2:	f8d7 20a4 	ldr.w	r2, [r7, #164]	@ 0xa4
 80274c6:	429a      	cmp	r2, r3
 80274c8:	da08      	bge.n	80274dc <lv_label_refr_text+0x660>
                a.act_time = act_time;      /*To keep the old position when the label text is updated mid-scrolling*/
 80274ca:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 80274ce:	643b      	str	r3, [r7, #64]	@ 0x40
                a.early_apply = 0;
 80274d0:	f897 305a 	ldrb.w	r3, [r7, #90]	@ 0x5a
 80274d4:	f36f 0300 	bfc	r3, #0, #1
 80274d8:	f887 305a 	strb.w	r3, [r7, #90]	@ 0x5a
            }

            lv_anim_start(&a);
 80274dc:	f107 030c 	add.w	r3, r7, #12
 80274e0:	4618      	mov	r0, r3
 80274e2:	f7f9 fd4f 	bl	8020f84 <lv_anim_start>
        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {
 80274e6:	e142      	b.n	802776e <lv_label_refr_text+0x8f2>
        }
        else {
            /*Delete the offset animation if not required*/
            lv_anim_delete(obj, set_ofs_y_anim);
 80274e8:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 80274ec:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 80274f0:	4987      	ldr	r1, [pc, #540]	@ (8027710 <lv_label_refr_text+0x894>)
 80274f2:	6818      	ldr	r0, [r3, #0]
 80274f4:	f7f9 fdc2 	bl	802107c <lv_anim_delete>
            label->offset.y = 0;
 80274f8:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80274fc:	2200      	movs	r2, #0
 80274fe:	659a      	str	r2, [r3, #88]	@ 0x58
 8027500:	e135      	b.n	802776e <lv_label_refr_text+0x8f2>
        }
    }
    else if(label->long_mode == LV_LABEL_LONG_DOT) {
 8027502:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8027506:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 802750a:	f003 0307 	and.w	r3, r3, #7
 802750e:	b2db      	uxtb	r3, r3
 8027510:	2b01      	cmp	r3, #1
 8027512:	f040 812c 	bne.w	802776e <lv_label_refr_text+0x8f2>
        if(size.y <= lv_area_get_height(&txt_coords)) { /*No dots are required, the text is short enough*/
 8027516:	6f7c      	ldr	r4, [r7, #116]	@ 0x74
 8027518:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 802751c:	4618      	mov	r0, r3
 802751e:	f7fe fd8d 	bl	802603c <lv_area_get_height>
 8027522:	4603      	mov	r3, r0
 8027524:	429c      	cmp	r4, r3
 8027526:	dc05      	bgt.n	8027534 <lv_label_refr_text+0x6b8>
            label->dot_end = LV_LABEL_DOT_END_INV;
 8027528:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 802752c:	f04f 32ff 	mov.w	r2, #4294967295
 8027530:	635a      	str	r2, [r3, #52]	@ 0x34
 8027532:	e11c      	b.n	802776e <lv_label_refr_text+0x8f2>
        }
        else if(size.y <= lv_font_get_line_height(font)) { /*No dots are required for one-line texts*/
 8027534:	6f7c      	ldr	r4, [r7, #116]	@ 0x74
 8027536:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 802753a:	f7fe fda1 	bl	8026080 <lv_font_get_line_height>
 802753e:	4603      	mov	r3, r0
 8027540:	429c      	cmp	r4, r3
 8027542:	dc05      	bgt.n	8027550 <lv_label_refr_text+0x6d4>
            label->dot_end = LV_LABEL_DOT_END_INV;
 8027544:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8027548:	f04f 32ff 	mov.w	r2, #4294967295
 802754c:	635a      	str	r2, [r3, #52]	@ 0x34
 802754e:	e10e      	b.n	802776e <lv_label_refr_text+0x8f2>
        }
        else if(_lv_text_get_encoded_length(label->text) <= LV_LABEL_DOT_NUM) {   /*Don't turn to dots all the characters*/
 8027550:	4b70      	ldr	r3, [pc, #448]	@ (8027714 <lv_label_refr_text+0x898>)
 8027552:	681b      	ldr	r3, [r3, #0]
 8027554:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 8027558:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 802755a:	4610      	mov	r0, r2
 802755c:	4798      	blx	r3
 802755e:	4603      	mov	r3, r0
 8027560:	2b03      	cmp	r3, #3
 8027562:	d805      	bhi.n	8027570 <lv_label_refr_text+0x6f4>
            label->dot_end = LV_LABEL_DOT_END_INV;
 8027564:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8027568:	f04f 32ff 	mov.w	r2, #4294967295
 802756c:	635a      	str	r2, [r3, #52]	@ 0x34
 802756e:	e0fe      	b.n	802776e <lv_label_refr_text+0x8f2>
        }
        else {
            lv_point_t p;
            int32_t y_overed;
            p.x = lv_area_get_width(&txt_coords) -
 8027570:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8027574:	4618      	mov	r0, r3
 8027576:	f7fe fd51 	bl	802601c <lv_area_get_width>
 802757a:	4604      	mov	r4, r0
                  (lv_font_get_glyph_width(font, '.', '.') + letter_space) *
 802757c:	222e      	movs	r2, #46	@ 0x2e
 802757e:	212e      	movs	r1, #46	@ 0x2e
 8027580:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 8027584:	f7f4 ff76 	bl	801c474 <lv_font_get_glyph_width>
 8027588:	4603      	mov	r3, r0
 802758a:	461a      	mov	r2, r3
 802758c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	@ 0xc8
 8027590:	4413      	add	r3, r2
 8027592:	461a      	mov	r2, r3
 8027594:	009b      	lsls	r3, r3, #2
 8027596:	1ad3      	subs	r3, r2, r3
            p.x = lv_area_get_width(&txt_coords) -
 8027598:	4423      	add	r3, r4
 802759a:	66bb      	str	r3, [r7, #104]	@ 0x68
                  LV_LABEL_DOT_NUM; /*Shrink with dots*/
            p.y = lv_area_get_height(&txt_coords);
 802759c:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 80275a0:	4618      	mov	r0, r3
 80275a2:	f7fe fd4b 	bl	802603c <lv_area_get_height>
 80275a6:	4603      	mov	r3, r0
 80275a8:	66fb      	str	r3, [r7, #108]	@ 0x6c
            y_overed = p.y %
 80275aa:	6efc      	ldr	r4, [r7, #108]	@ 0x6c
                       (lv_font_get_line_height(font) + line_space); /*Round down to the last line*/
 80275ac:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 80275b0:	f7fe fd66 	bl	8026080 <lv_font_get_line_height>
 80275b4:	4602      	mov	r2, r0
 80275b6:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 80275ba:	4413      	add	r3, r2
            y_overed = p.y %
 80275bc:	fb94 f2f3 	sdiv	r2, r4, r3
 80275c0:	fb02 f303 	mul.w	r3, r2, r3
 80275c4:	1ae3      	subs	r3, r4, r3
 80275c6:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
            if(y_overed >= lv_font_get_line_height(font)) {
 80275ca:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 80275ce:	f7fe fd57 	bl	8026080 <lv_font_get_line_height>
 80275d2:	4602      	mov	r2, r0
 80275d4:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80275d8:	4293      	cmp	r3, r2
 80275da:	db0d      	blt.n	80275f8 <lv_label_refr_text+0x77c>
                p.y -= y_overed;
 80275dc:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80275de:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80275e2:	1ad3      	subs	r3, r2, r3
 80275e4:	66fb      	str	r3, [r7, #108]	@ 0x6c
                p.y += lv_font_get_line_height(font);
 80275e6:	f8d7 00d0 	ldr.w	r0, [r7, #208]	@ 0xd0
 80275ea:	f7fe fd49 	bl	8026080 <lv_font_get_line_height>
 80275ee:	4602      	mov	r2, r0
 80275f0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80275f2:	4413      	add	r3, r2
 80275f4:	66fb      	str	r3, [r7, #108]	@ 0x6c
 80275f6:	e009      	b.n	802760c <lv_label_refr_text+0x790>
            }
            else {
                p.y -= y_overed;
 80275f8:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80275fa:	f8d7 30c0 	ldr.w	r3, [r7, #192]	@ 0xc0
 80275fe:	1ad3      	subs	r3, r2, r3
 8027600:	66fb      	str	r3, [r7, #108]	@ 0x6c
                p.y -= line_space;
 8027602:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8027604:	f8d7 30cc 	ldr.w	r3, [r7, #204]	@ 0xcc
 8027608:	1ad3      	subs	r3, r2, r3
 802760a:	66fb      	str	r3, [r7, #108]	@ 0x6c
            }

            uint32_t letter_id = lv_label_get_letter_on(obj, &p, false);
 802760c:	f107 0168 	add.w	r1, r7, #104	@ 0x68
 8027610:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8027614:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8027618:	2200      	movs	r2, #0
 802761a:	6818      	ldr	r0, [r3, #0]
 802761c:	f7fe ff96 	bl	802654c <lv_label_get_letter_on>
 8027620:	f8c7 00e4 	str.w	r0, [r7, #228]	@ 0xe4

            /*Be sure there is space for the dots*/
            size_t txt_len = lv_strlen(label->text);
 8027624:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8027628:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 802762a:	4618      	mov	r0, r3
 802762c:	f7fd fcc5 	bl	8024fba <lv_strlen>
 8027630:	f8c7 00bc 	str.w	r0, [r7, #188]	@ 0xbc
            uint32_t byte_id     = _lv_text_encoded_get_byte_id(label->text, letter_id);
 8027634:	4b38      	ldr	r3, [pc, #224]	@ (8027718 <lv_label_refr_text+0x89c>)
 8027636:	681b      	ldr	r3, [r3, #0]
 8027638:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 802763c:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 802763e:	f8d7 10e4 	ldr.w	r1, [r7, #228]	@ 0xe4
 8027642:	4610      	mov	r0, r2
 8027644:	4798      	blx	r3
 8027646:	4603      	mov	r3, r0
 8027648:	667b      	str	r3, [r7, #100]	@ 0x64
            while(byte_id + LV_LABEL_DOT_NUM > txt_len) {
 802764a:	e00d      	b.n	8027668 <lv_label_refr_text+0x7ec>
                _lv_text_encoded_prev(label->text, &byte_id);
 802764c:	4b33      	ldr	r3, [pc, #204]	@ (802771c <lv_label_refr_text+0x8a0>)
 802764e:	681b      	ldr	r3, [r3, #0]
 8027650:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 8027654:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 8027656:	f107 0164 	add.w	r1, r7, #100	@ 0x64
 802765a:	4610      	mov	r0, r2
 802765c:	4798      	blx	r3
                letter_id--;
 802765e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8027662:	3b01      	subs	r3, #1
 8027664:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
            while(byte_id + LV_LABEL_DOT_NUM > txt_len) {
 8027668:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 802766a:	3303      	adds	r3, #3
 802766c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 8027670:	429a      	cmp	r2, r3
 8027672:	d3eb      	bcc.n	802764c <lv_label_refr_text+0x7d0>
            }

            /*Save letters under the dots and replace them with dots*/
            uint32_t byte_id_ori = byte_id;
 8027674:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 8027676:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
            uint32_t i;
            uint8_t len = 0;
 802767a:	2300      	movs	r3, #0
 802767c:	f887 30df 	strb.w	r3, [r7, #223]	@ 0xdf
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
 8027680:	2300      	movs	r3, #0
 8027682:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 8027686:	e026      	b.n	80276d6 <lv_label_refr_text+0x85a>
                len += _lv_text_encoded_size(&label->text[byte_id]);
 8027688:	4b25      	ldr	r3, [pc, #148]	@ (8027720 <lv_label_refr_text+0x8a4>)
 802768a:	681b      	ldr	r3, [r3, #0]
 802768c:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 8027690:	6ad1      	ldr	r1, [r2, #44]	@ 0x2c
 8027692:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 8027694:	440a      	add	r2, r1
 8027696:	4610      	mov	r0, r2
 8027698:	4798      	blx	r3
 802769a:	4603      	mov	r3, r0
 802769c:	461a      	mov	r2, r3
 802769e:	f897 30df 	ldrb.w	r3, [r7, #223]	@ 0xdf
 80276a2:	4413      	add	r3, r2
 80276a4:	f887 30df 	strb.w	r3, [r7, #223]	@ 0xdf
                _lv_text_encoded_next(label->text, &byte_id);
 80276a8:	4b1e      	ldr	r3, [pc, #120]	@ (8027724 <lv_label_refr_text+0x8a8>)
 80276aa:	681b      	ldr	r3, [r3, #0]
 80276ac:	f8d7 20d8 	ldr.w	r2, [r7, #216]	@ 0xd8
 80276b0:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 80276b2:	f107 0164 	add.w	r1, r7, #100	@ 0x64
 80276b6:	4610      	mov	r0, r2
 80276b8:	4798      	blx	r3
                if(len > LV_LABEL_DOT_NUM || byte_id > txt_len) {
 80276ba:	f897 30df 	ldrb.w	r3, [r7, #223]	@ 0xdf
 80276be:	2b03      	cmp	r3, #3
 80276c0:	d80d      	bhi.n	80276de <lv_label_refr_text+0x862>
 80276c2:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80276c4:	f8d7 20bc 	ldr.w	r2, [r7, #188]	@ 0xbc
 80276c8:	429a      	cmp	r2, r3
 80276ca:	d308      	bcc.n	80276de <lv_label_refr_text+0x862>
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
 80276cc:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80276d0:	3301      	adds	r3, #1
 80276d2:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 80276d6:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80276da:	2b03      	cmp	r3, #3
 80276dc:	d9d4      	bls.n	8027688 <lv_label_refr_text+0x80c>
                    break;
                }
            }

            if(lv_label_set_dot_tmp(obj, &label->text[byte_id_ori], len)) {
 80276de:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80276e2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80276e4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 80276e8:	18d1      	adds	r1, r2, r3
 80276ea:	f897 20df 	ldrb.w	r2, [r7, #223]	@ 0xdf
 80276ee:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 80276f2:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 80276f6:	6818      	ldr	r0, [r3, #0]
 80276f8:	f000 f89e 	bl	8027838 <lv_label_set_dot_tmp>
 80276fc:	4603      	mov	r3, r0
 80276fe:	2b00      	cmp	r3, #0
 8027700:	d035      	beq.n	802776e <lv_label_refr_text+0x8f2>
                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {
 8027702:	2300      	movs	r3, #0
 8027704:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 8027708:	e01e      	b.n	8027748 <lv_label_refr_text+0x8cc>
 802770a:	bf00      	nop
 802770c:	0802793d 	.word	0x0802793d
 8027710:	0802795f 	.word	0x0802795f
 8027714:	20000020 	.word	0x20000020
 8027718:	20000018 	.word	0x20000018
 802771c:	20000014 	.word	0x20000014
 8027720:	2000000c 	.word	0x2000000c
 8027724:	20000010 	.word	0x20000010
                    label->text[byte_id_ori + i] = '.';
 8027728:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 802772c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 802772e:	f8d7 10b8 	ldr.w	r1, [r7, #184]	@ 0xb8
 8027732:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8027736:	440b      	add	r3, r1
 8027738:	4413      	add	r3, r2
 802773a:	222e      	movs	r2, #46	@ 0x2e
 802773c:	701a      	strb	r2, [r3, #0]
                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {
 802773e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8027742:	3301      	adds	r3, #1
 8027744:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 8027748:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 802774c:	2b02      	cmp	r3, #2
 802774e:	d9eb      	bls.n	8027728 <lv_label_refr_text+0x8ac>
                }
                label->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\0';
 8027750:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 8027754:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8027756:	f8d7 30b8 	ldr.w	r3, [r7, #184]	@ 0xb8
 802775a:	3303      	adds	r3, #3
 802775c:	4413      	add	r3, r2
 802775e:	2200      	movs	r2, #0
 8027760:	701a      	strb	r2, [r3, #0]
                label->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
 8027762:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8027766:	1cda      	adds	r2, r3, #3
 8027768:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 802776c:	635a      	str	r2, [r3, #52]	@ 0x34
    }
    else if(label->long_mode == LV_LABEL_LONG_CLIP) {
        /*Do nothing*/
    }

    lv_obj_invalidate(obj);
 802776e:	f507 7384 	add.w	r3, r7, #264	@ 0x108
 8027772:	f5a3 7382 	sub.w	r3, r3, #260	@ 0x104
 8027776:	6818      	ldr	r0, [r3, #0]
 8027778:	f7de ff62 	bl	8006640 <lv_obj_invalidate>
 802777c:	e000      	b.n	8027780 <lv_label_refr_text+0x904>
    if(label->text == NULL) return;
 802777e:	bf00      	nop
}
 8027780:	f507 7786 	add.w	r7, r7, #268	@ 0x10c
 8027784:	46bd      	mov	sp, r7
 8027786:	bd90      	pop	{r4, r7, pc}

08027788 <lv_label_revert_dots>:

static void lv_label_revert_dots(lv_obj_t * obj)
{
 8027788:	b580      	push	{r7, lr}
 802778a:	b088      	sub	sp, #32
 802778c:	af00      	add	r7, sp, #0
 802778e:	6078      	str	r0, [r7, #4]
    lv_label_t * label = (lv_label_t *)obj;
 8027790:	687b      	ldr	r3, [r7, #4]
 8027792:	61bb      	str	r3, [r7, #24]

    if(label->long_mode != LV_LABEL_LONG_DOT) return;
 8027794:	69bb      	ldr	r3, [r7, #24]
 8027796:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 802779a:	f003 0307 	and.w	r3, r3, #7
 802779e:	b2db      	uxtb	r3, r3
 80277a0:	2b01      	cmp	r3, #1
 80277a2:	d141      	bne.n	8027828 <lv_label_revert_dots+0xa0>
    if(label->dot_end == LV_LABEL_DOT_END_INV) return;
 80277a4:	69bb      	ldr	r3, [r7, #24]
 80277a6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80277a8:	f1b3 3fff 	cmp.w	r3, #4294967295
 80277ac:	d03e      	beq.n	802782c <lv_label_revert_dots+0xa4>

    const uint32_t letter_i = label->dot_end - LV_LABEL_DOT_NUM;
 80277ae:	69bb      	ldr	r3, [r7, #24]
 80277b0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80277b2:	3b03      	subs	r3, #3
 80277b4:	617b      	str	r3, [r7, #20]
    const uint32_t byte_i = _lv_text_encoded_get_byte_id(label->text, letter_i);
 80277b6:	4b1f      	ldr	r3, [pc, #124]	@ (8027834 <lv_label_revert_dots+0xac>)
 80277b8:	681b      	ldr	r3, [r3, #0]
 80277ba:	69ba      	ldr	r2, [r7, #24]
 80277bc:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 80277be:	6979      	ldr	r1, [r7, #20]
 80277c0:	4610      	mov	r0, r2
 80277c2:	4798      	blx	r3
 80277c4:	6138      	str	r0, [r7, #16]

    /*Restore the characters*/
    uint8_t i = 0;
 80277c6:	2300      	movs	r3, #0
 80277c8:	77fb      	strb	r3, [r7, #31]
    char * dot_tmp = lv_label_get_dot_tmp(obj);
 80277ca:	6878      	ldr	r0, [r7, #4]
 80277cc:	f000 f878 	bl	80278c0 <lv_label_get_dot_tmp>
 80277d0:	60f8      	str	r0, [r7, #12]
    while(label->text[byte_i + i] != '\0') {
 80277d2:	e00d      	b.n	80277f0 <lv_label_revert_dots+0x68>
        label->text[byte_i + i] = dot_tmp[i];
 80277d4:	7ffb      	ldrb	r3, [r7, #31]
 80277d6:	68fa      	ldr	r2, [r7, #12]
 80277d8:	441a      	add	r2, r3
 80277da:	69bb      	ldr	r3, [r7, #24]
 80277dc:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 80277de:	7ff8      	ldrb	r0, [r7, #31]
 80277e0:	693b      	ldr	r3, [r7, #16]
 80277e2:	4403      	add	r3, r0
 80277e4:	440b      	add	r3, r1
 80277e6:	7812      	ldrb	r2, [r2, #0]
 80277e8:	701a      	strb	r2, [r3, #0]
        i++;
 80277ea:	7ffb      	ldrb	r3, [r7, #31]
 80277ec:	3301      	adds	r3, #1
 80277ee:	77fb      	strb	r3, [r7, #31]
    while(label->text[byte_i + i] != '\0') {
 80277f0:	69bb      	ldr	r3, [r7, #24]
 80277f2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80277f4:	7ff9      	ldrb	r1, [r7, #31]
 80277f6:	693b      	ldr	r3, [r7, #16]
 80277f8:	440b      	add	r3, r1
 80277fa:	4413      	add	r3, r2
 80277fc:	781b      	ldrb	r3, [r3, #0]
 80277fe:	2b00      	cmp	r3, #0
 8027800:	d1e8      	bne.n	80277d4 <lv_label_revert_dots+0x4c>
    }
    label->text[byte_i + i] = dot_tmp[i];
 8027802:	7ffb      	ldrb	r3, [r7, #31]
 8027804:	68fa      	ldr	r2, [r7, #12]
 8027806:	441a      	add	r2, r3
 8027808:	69bb      	ldr	r3, [r7, #24]
 802780a:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 802780c:	7ff8      	ldrb	r0, [r7, #31]
 802780e:	693b      	ldr	r3, [r7, #16]
 8027810:	4403      	add	r3, r0
 8027812:	440b      	add	r3, r1
 8027814:	7812      	ldrb	r2, [r2, #0]
 8027816:	701a      	strb	r2, [r3, #0]

    lv_label_dot_tmp_free(obj);
 8027818:	6878      	ldr	r0, [r7, #4]
 802781a:	f000 f86a 	bl	80278f2 <lv_label_dot_tmp_free>

    label->dot_end = LV_LABEL_DOT_END_INV;
 802781e:	69bb      	ldr	r3, [r7, #24]
 8027820:	f04f 32ff 	mov.w	r2, #4294967295
 8027824:	635a      	str	r2, [r3, #52]	@ 0x34
 8027826:	e002      	b.n	802782e <lv_label_revert_dots+0xa6>
    if(label->long_mode != LV_LABEL_LONG_DOT) return;
 8027828:	bf00      	nop
 802782a:	e000      	b.n	802782e <lv_label_revert_dots+0xa6>
    if(label->dot_end == LV_LABEL_DOT_END_INV) return;
 802782c:	bf00      	nop
}
 802782e:	3720      	adds	r7, #32
 8027830:	46bd      	mov	sp, r7
 8027832:	bd80      	pop	{r7, pc}
 8027834:	20000018 	.word	0x20000018

08027838 <lv_label_set_dot_tmp>:
 * @param label pointer to label object
 * @param len Number of characters to store.
 * @return true on success.
 */
static bool lv_label_set_dot_tmp(lv_obj_t * obj, char * data, uint32_t len)
{
 8027838:	b580      	push	{r7, lr}
 802783a:	b086      	sub	sp, #24
 802783c:	af00      	add	r7, sp, #0
 802783e:	60f8      	str	r0, [r7, #12]
 8027840:	60b9      	str	r1, [r7, #8]
 8027842:	607a      	str	r2, [r7, #4]

    lv_label_t * label = (lv_label_t *)obj;
 8027844:	68fb      	ldr	r3, [r7, #12]
 8027846:	617b      	str	r3, [r7, #20]
    lv_label_dot_tmp_free(obj); /*Deallocate any existing space*/
 8027848:	68f8      	ldr	r0, [r7, #12]
 802784a:	f000 f852 	bl	80278f2 <lv_label_dot_tmp_free>
    if(len > sizeof(char *)) {
 802784e:	687b      	ldr	r3, [r7, #4]
 8027850:	2b04      	cmp	r3, #4
 8027852:	d922      	bls.n	802789a <lv_label_set_dot_tmp+0x62>
        /*Memory needs to be allocated. Allocates an additional byte
         *for a NULL-terminator so it can be copied.*/
        label->dot.tmp_ptr = lv_malloc(len + 1);
 8027854:	687b      	ldr	r3, [r7, #4]
 8027856:	3301      	adds	r3, #1
 8027858:	4618      	mov	r0, r3
 802785a:	f7fe fab5 	bl	8025dc8 <lv_malloc>
 802785e:	4602      	mov	r2, r0
 8027860:	697b      	ldr	r3, [r7, #20]
 8027862:	631a      	str	r2, [r3, #48]	@ 0x30
        if(label->dot.tmp_ptr == NULL) {
 8027864:	697b      	ldr	r3, [r7, #20]
 8027866:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8027868:	2b00      	cmp	r3, #0
 802786a:	d101      	bne.n	8027870 <lv_label_set_dot_tmp+0x38>
            LV_LOG_ERROR("Failed to allocate memory for dot_tmp_ptr");
            return false;
 802786c:	2300      	movs	r3, #0
 802786e:	e023      	b.n	80278b8 <lv_label_set_dot_tmp+0x80>
        }
        lv_memcpy(label->dot.tmp_ptr, data, len);
 8027870:	697b      	ldr	r3, [r7, #20]
 8027872:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8027874:	687a      	ldr	r2, [r7, #4]
 8027876:	68b9      	ldr	r1, [r7, #8]
 8027878:	4618      	mov	r0, r3
 802787a:	f7fd f8b5 	bl	80249e8 <lv_memcpy>
        label->dot.tmp_ptr[len] = '\0';
 802787e:	697b      	ldr	r3, [r7, #20]
 8027880:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8027882:	687b      	ldr	r3, [r7, #4]
 8027884:	4413      	add	r3, r2
 8027886:	2200      	movs	r2, #0
 8027888:	701a      	strb	r2, [r3, #0]
        label->dot_tmp_alloc    = true;
 802788a:	697a      	ldr	r2, [r7, #20]
 802788c:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 8027890:	f043 0320 	orr.w	r3, r3, #32
 8027894:	f882 305c 	strb.w	r3, [r2, #92]	@ 0x5c
 8027898:	e00d      	b.n	80278b6 <lv_label_set_dot_tmp+0x7e>
    }
    else {
        /*Characters can be directly stored in object*/
        label->dot_tmp_alloc = false;
 802789a:	697a      	ldr	r2, [r7, #20]
 802789c:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 80278a0:	f36f 1345 	bfc	r3, #5, #1
 80278a4:	f882 305c 	strb.w	r3, [r2, #92]	@ 0x5c
        lv_memcpy(label->dot.tmp, data, len);
 80278a8:	697b      	ldr	r3, [r7, #20]
 80278aa:	3330      	adds	r3, #48	@ 0x30
 80278ac:	687a      	ldr	r2, [r7, #4]
 80278ae:	68b9      	ldr	r1, [r7, #8]
 80278b0:	4618      	mov	r0, r3
 80278b2:	f7fd f899 	bl	80249e8 <lv_memcpy>
    }
    return true;
 80278b6:	2301      	movs	r3, #1
}
 80278b8:	4618      	mov	r0, r3
 80278ba:	3718      	adds	r7, #24
 80278bc:	46bd      	mov	sp, r7
 80278be:	bd80      	pop	{r7, pc}

080278c0 <lv_label_get_dot_tmp>:
 * Get the stored dot_tmp characters
 * @param label pointer to label object
 * @return char pointer to a stored characters. Is *not* necessarily NULL-terminated.
 */
static char * lv_label_get_dot_tmp(lv_obj_t * obj)
{
 80278c0:	b480      	push	{r7}
 80278c2:	b085      	sub	sp, #20
 80278c4:	af00      	add	r7, sp, #0
 80278c6:	6078      	str	r0, [r7, #4]
    lv_label_t * label = (lv_label_t *)obj;
 80278c8:	687b      	ldr	r3, [r7, #4]
 80278ca:	60fb      	str	r3, [r7, #12]
    if(label->dot_tmp_alloc) {
 80278cc:	68fb      	ldr	r3, [r7, #12]
 80278ce:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 80278d2:	f003 0320 	and.w	r3, r3, #32
 80278d6:	b2db      	uxtb	r3, r3
 80278d8:	2b00      	cmp	r3, #0
 80278da:	d002      	beq.n	80278e2 <lv_label_get_dot_tmp+0x22>
        return label->dot.tmp_ptr;
 80278dc:	68fb      	ldr	r3, [r7, #12]
 80278de:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80278e0:	e001      	b.n	80278e6 <lv_label_get_dot_tmp+0x26>
    }
    else {
        return label->dot.tmp;
 80278e2:	68fb      	ldr	r3, [r7, #12]
 80278e4:	3330      	adds	r3, #48	@ 0x30
    }
}
 80278e6:	4618      	mov	r0, r3
 80278e8:	3714      	adds	r7, #20
 80278ea:	46bd      	mov	sp, r7
 80278ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80278f0:	4770      	bx	lr

080278f2 <lv_label_dot_tmp_free>:
 * Free the dot_tmp_ptr field if it was previously allocated.
 * Always clears the field
 * @param label pointer to label object.
 */
static void lv_label_dot_tmp_free(lv_obj_t * obj)
{
 80278f2:	b580      	push	{r7, lr}
 80278f4:	b084      	sub	sp, #16
 80278f6:	af00      	add	r7, sp, #0
 80278f8:	6078      	str	r0, [r7, #4]
    lv_label_t * label = (lv_label_t *)obj;
 80278fa:	687b      	ldr	r3, [r7, #4]
 80278fc:	60fb      	str	r3, [r7, #12]
    if(label->dot_tmp_alloc && label->dot.tmp_ptr) {
 80278fe:	68fb      	ldr	r3, [r7, #12]
 8027900:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 8027904:	f003 0320 	and.w	r3, r3, #32
 8027908:	b2db      	uxtb	r3, r3
 802790a:	2b00      	cmp	r3, #0
 802790c:	d008      	beq.n	8027920 <lv_label_dot_tmp_free+0x2e>
 802790e:	68fb      	ldr	r3, [r7, #12]
 8027910:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8027912:	2b00      	cmp	r3, #0
 8027914:	d004      	beq.n	8027920 <lv_label_dot_tmp_free+0x2e>
        lv_free(label->dot.tmp_ptr);
 8027916:	68fb      	ldr	r3, [r7, #12]
 8027918:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 802791a:	4618      	mov	r0, r3
 802791c:	f7fe fa8c 	bl	8025e38 <lv_free>
    }
    label->dot_tmp_alloc = false;
 8027920:	68fa      	ldr	r2, [r7, #12]
 8027922:	f892 305c 	ldrb.w	r3, [r2, #92]	@ 0x5c
 8027926:	f36f 1345 	bfc	r3, #5, #1
 802792a:	f882 305c 	strb.w	r3, [r2, #92]	@ 0x5c
    label->dot.tmp_ptr   = NULL;
 802792e:	68fb      	ldr	r3, [r7, #12]
 8027930:	2200      	movs	r2, #0
 8027932:	631a      	str	r2, [r3, #48]	@ 0x30
}
 8027934:	bf00      	nop
 8027936:	3710      	adds	r7, #16
 8027938:	46bd      	mov	sp, r7
 802793a:	bd80      	pop	{r7, pc}

0802793c <set_ofs_x_anim>:

static void set_ofs_x_anim(void * obj, int32_t v)
{
 802793c:	b580      	push	{r7, lr}
 802793e:	b084      	sub	sp, #16
 8027940:	af00      	add	r7, sp, #0
 8027942:	6078      	str	r0, [r7, #4]
 8027944:	6039      	str	r1, [r7, #0]
    lv_label_t * label = (lv_label_t *)obj;
 8027946:	687b      	ldr	r3, [r7, #4]
 8027948:	60fb      	str	r3, [r7, #12]
    label->offset.x    = v;
 802794a:	68fb      	ldr	r3, [r7, #12]
 802794c:	683a      	ldr	r2, [r7, #0]
 802794e:	655a      	str	r2, [r3, #84]	@ 0x54
    lv_obj_invalidate(obj);
 8027950:	6878      	ldr	r0, [r7, #4]
 8027952:	f7de fe75 	bl	8006640 <lv_obj_invalidate>
}
 8027956:	bf00      	nop
 8027958:	3710      	adds	r7, #16
 802795a:	46bd      	mov	sp, r7
 802795c:	bd80      	pop	{r7, pc}

0802795e <set_ofs_y_anim>:

static void set_ofs_y_anim(void * obj, int32_t v)
{
 802795e:	b580      	push	{r7, lr}
 8027960:	b084      	sub	sp, #16
 8027962:	af00      	add	r7, sp, #0
 8027964:	6078      	str	r0, [r7, #4]
 8027966:	6039      	str	r1, [r7, #0]
    lv_label_t * label = (lv_label_t *)obj;
 8027968:	687b      	ldr	r3, [r7, #4]
 802796a:	60fb      	str	r3, [r7, #12]
    label->offset.y    = v;
 802796c:	68fb      	ldr	r3, [r7, #12]
 802796e:	683a      	ldr	r2, [r7, #0]
 8027970:	659a      	str	r2, [r3, #88]	@ 0x58
    lv_obj_invalidate(obj);
 8027972:	6878      	ldr	r0, [r7, #4]
 8027974:	f7de fe64 	bl	8006640 <lv_obj_invalidate>
}
 8027978:	bf00      	nop
 802797a:	3710      	adds	r7, #16
 802797c:	46bd      	mov	sp, r7
 802797e:	bd80      	pop	{r7, pc}

08027980 <get_text_length>:

static size_t get_text_length(const char * text)
{
 8027980:	b580      	push	{r7, lr}
 8027982:	b084      	sub	sp, #16
 8027984:	af00      	add	r7, sp, #0
 8027986:	6078      	str	r0, [r7, #4]
    size_t len = 0;
 8027988:	2300      	movs	r3, #0
 802798a:	60fb      	str	r3, [r7, #12]
#if LV_USE_ARABIC_PERSIAN_CHARS
    len = _lv_text_ap_calc_bytes_count(text);
#else
    len = lv_strlen(text) + 1;
 802798c:	6878      	ldr	r0, [r7, #4]
 802798e:	f7fd fb14 	bl	8024fba <lv_strlen>
 8027992:	4603      	mov	r3, r0
 8027994:	3301      	adds	r3, #1
 8027996:	60fb      	str	r3, [r7, #12]
#endif

    return len;
 8027998:	68fb      	ldr	r3, [r7, #12]
}
 802799a:	4618      	mov	r0, r3
 802799c:	3710      	adds	r7, #16
 802799e:	46bd      	mov	sp, r7
 80279a0:	bd80      	pop	{r7, pc}

080279a2 <copy_text_to_label>:

static void copy_text_to_label(lv_label_t * label, const char * text)
{
 80279a2:	b580      	push	{r7, lr}
 80279a4:	b082      	sub	sp, #8
 80279a6:	af00      	add	r7, sp, #0
 80279a8:	6078      	str	r0, [r7, #4]
 80279aa:	6039      	str	r1, [r7, #0]
#if LV_USE_ARABIC_PERSIAN_CHARS
    _lv_text_ap_proc(text, label->text);
#else
    lv_strcpy(label->text, text);
 80279ac:	687b      	ldr	r3, [r7, #4]
 80279ae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80279b0:	6839      	ldr	r1, [r7, #0]
 80279b2:	4618      	mov	r0, r3
 80279b4:	f7fd fb18 	bl	8024fe8 <lv_strcpy>
#endif
}
 80279b8:	bf00      	nop
 80279ba:	3708      	adds	r7, #8
 80279bc:	46bd      	mov	sp, r7
 80279be:	bd80      	pop	{r7, pc}

080279c0 <get_label_flags>:

static lv_text_flag_t get_label_flags(lv_label_t * label)
{
 80279c0:	b580      	push	{r7, lr}
 80279c2:	b084      	sub	sp, #16
 80279c4:	af00      	add	r7, sp, #0
 80279c6:	6078      	str	r0, [r7, #4]
    lv_text_flag_t flag = LV_TEXT_FLAG_NONE;
 80279c8:	2300      	movs	r3, #0
 80279ca:	73fb      	strb	r3, [r7, #15]

    if(label->expand) flag |= LV_TEXT_FLAG_EXPAND;
 80279cc:	687b      	ldr	r3, [r7, #4]
 80279ce:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
 80279d2:	f003 0310 	and.w	r3, r3, #16
 80279d6:	b2db      	uxtb	r3, r3
 80279d8:	2b00      	cmp	r3, #0
 80279da:	d003      	beq.n	80279e4 <get_label_flags+0x24>
 80279dc:	7bfb      	ldrb	r3, [r7, #15]
 80279de:	f043 0301 	orr.w	r3, r3, #1
 80279e2:	73fb      	strb	r3, [r7, #15]

    lv_obj_t * obj = (lv_obj_t *) label;
 80279e4:	687b      	ldr	r3, [r7, #4]
 80279e6:	60bb      	str	r3, [r7, #8]
    if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT &&
 80279e8:	2100      	movs	r1, #0
 80279ea:	68b8      	ldr	r0, [r7, #8]
 80279ec:	f7fe fbe1 	bl	80261b2 <lv_obj_get_style_width>
 80279f0:	4603      	mov	r3, r0
 80279f2:	4a0e      	ldr	r2, [pc, #56]	@ (8027a2c <get_label_flags+0x6c>)
 80279f4:	4293      	cmp	r3, r2
 80279f6:	d114      	bne.n	8027a22 <get_label_flags+0x62>
       lv_obj_get_style_max_width(obj, LV_PART_MAIN) == LV_COORD_MAX &&
 80279f8:	2100      	movs	r1, #0
 80279fa:	68b8      	ldr	r0, [r7, #8]
 80279fc:	f7fe fbea 	bl	80261d4 <lv_obj_get_style_max_width>
 8027a00:	4603      	mov	r3, r0
    if(lv_obj_get_style_width(obj, LV_PART_MAIN) == LV_SIZE_CONTENT &&
 8027a02:	f06f 4260 	mvn.w	r2, #3758096384	@ 0xe0000000
 8027a06:	4293      	cmp	r3, r2
 8027a08:	d10b      	bne.n	8027a22 <get_label_flags+0x62>
       !obj->w_layout) {
 8027a0a:	68bb      	ldr	r3, [r7, #8]
 8027a0c:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
 8027a10:	f003 0308 	and.w	r3, r3, #8
 8027a14:	b2db      	uxtb	r3, r3
       lv_obj_get_style_max_width(obj, LV_PART_MAIN) == LV_COORD_MAX &&
 8027a16:	2b00      	cmp	r3, #0
 8027a18:	d103      	bne.n	8027a22 <get_label_flags+0x62>
        flag |= LV_TEXT_FLAG_FIT;
 8027a1a:	7bfb      	ldrb	r3, [r7, #15]
 8027a1c:	f043 0302 	orr.w	r3, r3, #2
 8027a20:	73fb      	strb	r3, [r7, #15]
    }

    return flag;
 8027a22:	7bfb      	ldrb	r3, [r7, #15]
}
 8027a24:	4618      	mov	r0, r3
 8027a26:	3710      	adds	r7, #16
 8027a28:	46bd      	mov	sp, r7
 8027a2a:	bd80      	pop	{r7, pc}
 8027a2c:	200007d1 	.word	0x200007d1

08027a30 <calculate_x_coordinate>:

/* Function created because of this pattern be used in multiple functions */
static void calculate_x_coordinate(int32_t * x, const lv_text_align_t align, const char * txt, uint32_t length,
                                   const lv_font_t * font, int32_t letter_space, lv_area_t * txt_coords)
{
 8027a30:	b580      	push	{r7, lr}
 8027a32:	b086      	sub	sp, #24
 8027a34:	af00      	add	r7, sp, #0
 8027a36:	60f8      	str	r0, [r7, #12]
 8027a38:	607a      	str	r2, [r7, #4]
 8027a3a:	603b      	str	r3, [r7, #0]
 8027a3c:	460b      	mov	r3, r1
 8027a3e:	72fb      	strb	r3, [r7, #11]
    if(align == LV_TEXT_ALIGN_CENTER) {
 8027a40:	7afb      	ldrb	r3, [r7, #11]
 8027a42:	2b02      	cmp	r3, #2
 8027a44:	d11a      	bne.n	8027a7c <calculate_x_coordinate+0x4c>
        const int32_t line_w = lv_text_get_width(txt, length, font, letter_space);
 8027a46:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8027a48:	6a3a      	ldr	r2, [r7, #32]
 8027a4a:	6839      	ldr	r1, [r7, #0]
 8027a4c:	6878      	ldr	r0, [r7, #4]
 8027a4e:	f7fc fb9f 	bl	8024190 <lv_text_get_width>
 8027a52:	6138      	str	r0, [r7, #16]
        *x += lv_area_get_width(txt_coords) / 2 - line_w / 2;
 8027a54:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8027a56:	f7fe fae1 	bl	802601c <lv_area_get_width>
 8027a5a:	4603      	mov	r3, r0
 8027a5c:	0fda      	lsrs	r2, r3, #31
 8027a5e:	4413      	add	r3, r2
 8027a60:	105b      	asrs	r3, r3, #1
 8027a62:	4619      	mov	r1, r3
 8027a64:	693b      	ldr	r3, [r7, #16]
 8027a66:	0fda      	lsrs	r2, r3, #31
 8027a68:	4413      	add	r3, r2
 8027a6a:	105b      	asrs	r3, r3, #1
 8027a6c:	425b      	negs	r3, r3
 8027a6e:	18ca      	adds	r2, r1, r3
 8027a70:	68fb      	ldr	r3, [r7, #12]
 8027a72:	681b      	ldr	r3, [r3, #0]
 8027a74:	441a      	add	r2, r3
 8027a76:	68fb      	ldr	r3, [r7, #12]
 8027a78:	601a      	str	r2, [r3, #0]
        *x += lv_area_get_width(txt_coords) - line_w;
    }
    else {
        /* Nothing to do */
    }
}
 8027a7a:	e014      	b.n	8027aa6 <calculate_x_coordinate+0x76>
    else if(align == LV_TEXT_ALIGN_RIGHT) {
 8027a7c:	7afb      	ldrb	r3, [r7, #11]
 8027a7e:	2b03      	cmp	r3, #3
 8027a80:	d111      	bne.n	8027aa6 <calculate_x_coordinate+0x76>
        const int32_t line_w = lv_text_get_width(txt, length, font, letter_space);
 8027a82:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8027a84:	6a3a      	ldr	r2, [r7, #32]
 8027a86:	6839      	ldr	r1, [r7, #0]
 8027a88:	6878      	ldr	r0, [r7, #4]
 8027a8a:	f7fc fb81 	bl	8024190 <lv_text_get_width>
 8027a8e:	6178      	str	r0, [r7, #20]
        *x += lv_area_get_width(txt_coords) - line_w;
 8027a90:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8027a92:	f7fe fac3 	bl	802601c <lv_area_get_width>
 8027a96:	4602      	mov	r2, r0
 8027a98:	697b      	ldr	r3, [r7, #20]
 8027a9a:	1ad2      	subs	r2, r2, r3
 8027a9c:	68fb      	ldr	r3, [r7, #12]
 8027a9e:	681b      	ldr	r3, [r3, #0]
 8027aa0:	441a      	add	r2, r3
 8027aa2:	68fb      	ldr	r3, [r7, #12]
 8027aa4:	601a      	str	r2, [r3, #0]
}
 8027aa6:	bf00      	nop
 8027aa8:	3718      	adds	r7, #24
 8027aaa:	46bd      	mov	sp, r7
 8027aac:	bd80      	pop	{r7, pc}
	...

08027ab0 <lv_span_stack_init>:

/**********************
 *   GLOBAL FUNCTIONS
 **********************/
void lv_span_stack_init(void)
{
 8027ab0:	b580      	push	{r7, lr}
 8027ab2:	b082      	sub	sp, #8
 8027ab4:	af00      	add	r7, sp, #0
    struct _snippet_stack * stack = snippet_stack = lv_malloc(sizeof(struct _snippet_stack));
 8027ab6:	f240 7004 	movw	r0, #1796	@ 0x704
 8027aba:	f7fe f985 	bl	8025dc8 <lv_malloc>
 8027abe:	4603      	mov	r3, r0
 8027ac0:	4a07      	ldr	r2, [pc, #28]	@ (8027ae0 <lv_span_stack_init+0x30>)
 8027ac2:	f8c2 31a8 	str.w	r3, [r2, #424]	@ 0x1a8
 8027ac6:	4b06      	ldr	r3, [pc, #24]	@ (8027ae0 <lv_span_stack_init+0x30>)
 8027ac8:	f8d3 31a8 	ldr.w	r3, [r3, #424]	@ 0x1a8
 8027acc:	607b      	str	r3, [r7, #4]
    LV_ASSERT_MALLOC(stack);
 8027ace:	687b      	ldr	r3, [r7, #4]
 8027ad0:	2b00      	cmp	r3, #0
 8027ad2:	d101      	bne.n	8027ad8 <lv_span_stack_init+0x28>
 8027ad4:	bf00      	nop
 8027ad6:	e7fd      	b.n	8027ad4 <lv_span_stack_init+0x24>
    if(!stack) {
        LV_LOG_ERROR("malloc failed for snippet_stack");
    }
}
 8027ad8:	bf00      	nop
 8027ada:	3708      	adds	r7, #8
 8027adc:	46bd      	mov	sp, r7
 8027ade:	bd80      	pop	{r7, pc}
 8027ae0:	2000009c 	.word	0x2000009c

08027ae4 <memset>:
 8027ae4:	4402      	add	r2, r0
 8027ae6:	4603      	mov	r3, r0
 8027ae8:	4293      	cmp	r3, r2
 8027aea:	d100      	bne.n	8027aee <memset+0xa>
 8027aec:	4770      	bx	lr
 8027aee:	f803 1b01 	strb.w	r1, [r3], #1
 8027af2:	e7f9      	b.n	8027ae8 <memset+0x4>

08027af4 <__libc_init_array>:
 8027af4:	b570      	push	{r4, r5, r6, lr}
 8027af6:	4d0d      	ldr	r5, [pc, #52]	@ (8027b2c <__libc_init_array+0x38>)
 8027af8:	4c0d      	ldr	r4, [pc, #52]	@ (8027b30 <__libc_init_array+0x3c>)
 8027afa:	1b64      	subs	r4, r4, r5
 8027afc:	10a4      	asrs	r4, r4, #2
 8027afe:	2600      	movs	r6, #0
 8027b00:	42a6      	cmp	r6, r4
 8027b02:	d109      	bne.n	8027b18 <__libc_init_array+0x24>
 8027b04:	4d0b      	ldr	r5, [pc, #44]	@ (8027b34 <__libc_init_array+0x40>)
 8027b06:	4c0c      	ldr	r4, [pc, #48]	@ (8027b38 <__libc_init_array+0x44>)
 8027b08:	f000 f826 	bl	8027b58 <_init>
 8027b0c:	1b64      	subs	r4, r4, r5
 8027b0e:	10a4      	asrs	r4, r4, #2
 8027b10:	2600      	movs	r6, #0
 8027b12:	42a6      	cmp	r6, r4
 8027b14:	d105      	bne.n	8027b22 <__libc_init_array+0x2e>
 8027b16:	bd70      	pop	{r4, r5, r6, pc}
 8027b18:	f855 3b04 	ldr.w	r3, [r5], #4
 8027b1c:	4798      	blx	r3
 8027b1e:	3601      	adds	r6, #1
 8027b20:	e7ee      	b.n	8027b00 <__libc_init_array+0xc>
 8027b22:	f855 3b04 	ldr.w	r3, [r5], #4
 8027b26:	4798      	blx	r3
 8027b28:	3601      	adds	r6, #1
 8027b2a:	e7f2      	b.n	8027b12 <__libc_init_array+0x1e>
 8027b2c:	0802b328 	.word	0x0802b328
 8027b30:	0802b328 	.word	0x0802b328
 8027b34:	0802b328 	.word	0x0802b328
 8027b38:	0802b32c 	.word	0x0802b32c

08027b3c <memcpy>:
 8027b3c:	440a      	add	r2, r1
 8027b3e:	4291      	cmp	r1, r2
 8027b40:	f100 33ff 	add.w	r3, r0, #4294967295
 8027b44:	d100      	bne.n	8027b48 <memcpy+0xc>
 8027b46:	4770      	bx	lr
 8027b48:	b510      	push	{r4, lr}
 8027b4a:	f811 4b01 	ldrb.w	r4, [r1], #1
 8027b4e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8027b52:	4291      	cmp	r1, r2
 8027b54:	d1f9      	bne.n	8027b4a <memcpy+0xe>
 8027b56:	bd10      	pop	{r4, pc}

08027b58 <_init>:
 8027b58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8027b5a:	bf00      	nop
 8027b5c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8027b5e:	bc08      	pop	{r3}
 8027b60:	469e      	mov	lr, r3
 8027b62:	4770      	bx	lr

08027b64 <_fini>:
 8027b64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8027b66:	bf00      	nop
 8027b68:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8027b6a:	bc08      	pop	{r3}
 8027b6c:	469e      	mov	lr, r3
 8027b6e:	4770      	bx	lr
